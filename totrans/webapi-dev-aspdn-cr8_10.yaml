- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing in ASP.NET Core (Part 2 – Integration Testing)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371), we learned how to write
    unit tests for a ASP.NET Core web API application. Unit tests are used to test
    code units in isolation. However, a code unit often depends on other components,
    such as the database, external services, and so on. To test the code thoroughly,
    we need to test the code units in the context of the application. In other words,
    we need to test how the code units interact with other parts of the application.
    This type of testing is called integration testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will mainly focus on integration testing. We will cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with authentication and authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding code coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to write integration tests for
    a ASP.NET Core web API application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
    You can use VS Code or VS 2022 to open the solutions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the unit tests, we create the instances of the controllers directly. This
    approach does not consider some features of ASP.NET Core, such as routing, model
    binding, and validation and so on. To test the application thoroughly, we need
    to write integration tests. In this section, we will write integration tests for
    the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Unlike unit tests, which focus on isolated units, integration tests focus on
    the interactions between components. These integration tests may involve different
    layers, such as the database, the file system, the network, the HTTP request/response
    pipeline and so on. Integration tests ensure that the components of the application
    work together as expected. So, normally, integration tests use actual dependencies
    instead of mocks. Also, integration tests are slower than unit tests because they
    involve more components. Considering the cost of integration tests, we do not
    need to write too many integration tests. Instead, we should focus on the critical
    parts of the application. Most of the time, we can use unit tests to cover the
    other parts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample code of this section in the `IntegrationTestsDemo` folder.
    The code is based on the `InvoiceApp` project we created in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
    You can use VS 2022 or VS Code to open the solution. We will use the term **System
    Under Test** (**SUT**) to refer to the ASP.NET Core web API application we are
    testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the integration test project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can continue to use **xUnit** as the test framework for integration tests.
    A good practice is to create a separate integration test project from the unit
    test project. This approach allows us to run the unit tests and integration tests
    separately and also makes it easier to use different configurations for the two
    types of tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: If you are using VS 2022, you can create a new xUnit project by right-clicking
    on the solution and selecting `InvoiceApp.IntegrationTests` and click `InvoiceApp.WebApi`
    project to allow the integration test project to access the classes in the web
    API project (see [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using **.NET CLI**, you can create a new xUnit test project by running
    the following commands in the terminal:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ASP.NET Core provides a built-in test web host that we can use to host the SUT
    to handle the HTTP requests. The benefit of using a test web host is that we can
    use a different configuration for the test environment, and it also saves the
    network traffic because the HTTP requests are handled in the same process. So,
    the tests using a test web host are faster than those using a real web host. To
    use the test web host, we need to add the `Microsoft.AspNetCore.Mvc.Testing` NuGet
    package to the integration test project. You can add the package in VS 2022 by
    right-clicking on the project and selecting `Microsoft.AspNetCore.Mvc.Testing`
    and install the package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the following command to add the package:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default `UnitTest1.cs` file can be removed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to install **FluentAssertions** if you want to use it in the tests,
    as we demonstrated in the *Using FluentAssertions to verify the test results*
    section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start to write integration tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic integration tests with WebApplicationFactory
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let'sstart with a simple integration test to check whether the SUT can correctly
    handle the HTTP requests. The sample application has a `WeatherForecastController.cs`
    controller that is provided by the ASP.NET Core project template. It returns a
    list of weather forecasts. We can write an integration test to check whether the
    controller returns the expected result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `WeatherForecastApiTests` in the `InvoiceApp.IntegrationTests`
    project. Then add the following code to the file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the test class, we use the `WebApplicationFactory<T>` type to create a test
    web host and use it as the class fixture. The instance of this class fixture will
    be shared across the tests in the class. The `WebApplicationFactory<T>` type is
    provided by the `Microsoft.AspNetCore.Mvc.Testing` package. It is a generic type
    that allows us to create a test web host for the specified application entry point.
    In this case, we use the `Program` class defined in the web API project as the
    entry point. But you will see an error that says `CS0122'Program' is inaccessible
    due to its protection level`. This is because the `Program` class is defined as
    `internal` by default.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this issue, there are two ways:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `InvoiceApp.WebApi.csproj` file and add the following line to the
    file:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Replace `MyTestProject` with the name of your test project, such as `InvoiceApp.IntegrationTests`.
    This approach allows the test project to access the internal members of the web
    API project.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, you can change the access modifier of the `Program` class to
    `public`. Add the following code to the end of the `Program.cs` file:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use either approach to solve the issue. After that, we can write the
    test method, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the test method, we first create an instance of the `HttpClient` class using
    the `WebApplicationFactory<T>` instance. Then we send an HTTP `GET` request to
    the `/WeatherForecast` endpoint. The `EnsureSuccessStatusCode` method ensures
    that the response has a status code in the *200-299* range. Then we check whether
    the content type of the response is `application/json; charset=utf-8`. Finally,
    we deserialize the response content to a list of `WeatherForecast` objects and
    check whether the list contains five items.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Because this controller does not have any dependencies, the test is simple.
    What if the controller has dependencies, such as a database context, other services,
    or other external dependencies? We will see how to handle these scenarios in the
    following sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a database context
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the sample application, the `ContactController` class has dependencies, such
    as the `IContactRepository` interface. The `ContactRepository` class implements
    this interface and uses the `InvoiceContext` class to access the database. So,
    if we want to test whether the SUT can correctly handle the HTTP requests, we
    need to create a test database and configure the test web host to use the test
    database. Similar to the unit tests, we can use a separate database for integration
    tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WebApplicationFactory<T>` type provides a way to configure the test web
    host. We can override the `ConfigureWebHost` method to configure the test web
    host. For example, we can replace the default database context with a test database
    context. Let us create a new text fixture class named `CustomIntegrationTestsFixture`
    and add the following code to the class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we override the `ConfigureWebHost()` method to configure
    the test web host for the SUT. When the test web host is created, the `Program`
    class will execute first, which means the default database context defined in
    the `Program` class will be created. Then the `ConfigureWebHost()` method defined
    in the `CustomIntegrationTestsFixture` class will be executed. So we need to find
    the default database context using `services.SingleOrDefault(d => d.ServiceType
    == typeof(DbContextOptions<InvoiceDbContext>))` and then remove it from the service
    collection. Then we add a new database context that uses the test database. This
    approach allows us to use a separate database for integration tests. We also need
    to create the test database and seed some test data when we initialize the test
    fixture.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add more customizations to the test web host in the `ConfigureWebHost()`
    method. For example, you can configure the test web host to use a different configuration
    file, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The default environment for the test web host of the SUT is `Development`.
    If you want to use a different environment, you can use the `UseEnvironment()`
    method, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need a way to create the test database and seed some test data. Create
    a static class named `Utilities` and add the following code to the class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Utilities` class contains a few static methods that help us manage the
    test database. We need to initialize the test database before we run the tests
    and clean up the test database after we run the tests that change the data in
    the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'When should we initialize the test database? We learned that the instance of
    the class fixture is created before the test class is initialized and is shared
    among all test methods in the test class. So, we can initialize the test database
    in the class fixture. Update the following code in the `ConfigureWebHost()` method
    of the `CustomIntegrationTestsFixture` class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the test web host of SUT is created, we replace the default database context
    with a test database context, and also initialize the test database, so that all
    the test methods in the test class can use the same test database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can create a new test class named `InvoicesApiTests`, which is used
    to test the `/api/invoices` endpoint. Add the following code to the class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `InvoicesApiTests` test class will be initialized with an instance of the
    `CustomIntegrationTestsFixture` class. Then we can create some test methods to
    test the `/api/invoices` endpoint. A test method to test the `GET /api/invoices`
    endpoint might look as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As this request to the `GET /api/invoices` endpoint does not change the database,
    the test method is straightforward.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see how to test the `POST /api/invoices` endpoint, which changes
    the database. A test method to test this endpoint might look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As this request to the `POST /api/invoices` endpoint changes the database, we
    need to clean up the database after we run the test. To get the current instance
    of the database context, we need to create a new scope and get the database context
    from the scope. Then we can use the `Cleanup` method of the `Utilities` class
    to clean up the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'A test for the sad path of the `POST /api/invoices` endpoint might look as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can try to add more integration tests per your needs. Note that we need
    to manage the test database carefully. If you have multiple test classes that
    change the database, you may need to follow the same pattern (using a lock or
    collection fixture) as that in the unit tests we introduced in the *Creating a
    test fixture* section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371), to ensure
    the test database is clean before each test class runs and clean up the test database
    after each test class runs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have another `ContactsApiTests` class that also uses `CustomIntegrationTestsFixture`,
    xUnit will run `InvoicesApiTests` and `ContactsApiTests` in parallel. This may
    cause issues because both test classes try to initialize the test database at
    the same time. To avoid this issue, we can run these test classes in one collection
    to ensure that they run sequentially.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this by creating a test collection named `CustomIntegrationTests`
    and adding the `CollectionDefinition` attribute to the `CustomIntegrationTestsCollection`
    class. This attribute will enable us to define the collection and its associated
    tests, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can add the `Collection` attribute to the `InvoicesApiTestsWithCollection`
    and `ContactsApiTestsWithCollection` classes. For example, the `InvoicesApiTestsWithCollection`
    class might look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can find the complete source code in the sample repo. Note that the normal
    integration test class, `InvoicesApiTests`, does not have the `Collection` attribute,
    so xUnit will run it in parallel with the `CustomIntegrationTests` collection.
    To avoid conflicts, we can skip the test methods in the `InvoicesApiTests` class,
    as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you run the tests in the sample repo, please add or comment out the `Skip`
    attributes per your needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Testing with mock services
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we explained in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371), unit tests
    should focus on isolated units of code. So, unit tests often use mock or stub
    services to isolate the code under test from other services. Integration tests,
    on the other hand, should test the integration between different components. So,
    technically, integration tests should use real services instead of mock services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in some cases, using mock dependencies in integration tests can be
    helpful. For example, in the sample invoice application, we need to call a third-party
    service to send emails. If we use the real email service in the integration tests,
    it may have the following issues:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The actual email service may not be available in the test environment. For example,
    the email service may be hosted in a different environment, and the test environment
    may not be able to access the email service.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email service may have rate limits, strict network policies, or other restrictions
    that may cause issues in the integration tests or slow down the test execution.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email service may cause unnecessary costs in the test environment, especially
    if the service has usage-based pricing or requires a paid subscription. If we
    run the integration tests frequently, it may incur high costs.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test may impact production and cause issues for real users.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, using a mock email service in the integration can help us avoid
    these issues so that we can run the tests faster and more efficiently, avoid impacting
    production, and save costs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use a mock email service in the integration tests. The service
    we use to send email is the `IEmailSender` interface. We can inject a mock service
    that implements the `IEmailSender` interface in the integration tests. Create
    a new test method in the test class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we created a mock email sender service using the `Moq`
    library. The test web host of SUT provides a `WithWebHostBuilder()` method to
    configure the web host builder. In this method, we can configure the service collection
    of the web host using the `ConfigureTestServices()` method. Similar to the mock
    database context we introduced in the *Testing with a database context* section,
    we find the registered `IEmailSender` service and remove it from the service collection,
    then add the mock service to the service collection. Finally, we create the HTTP
    client and send the request to the API endpoint. If the mock service is used correctly,
    the test should pass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In summary, whether to use mock services in integration tests or not should
    be decided on a case-by-case basis and depends on the specific requirements and
    objectives of the tests. Mocks can be useful in certain scenarios, but they should
    not be overused, otherwise, the integration tests may not be able to reflect the
    real-world scenarios.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If your web API project runs in a microservice architecture, you may need to
    call other microservices in the integration tests. In this case, you can use the
    same approach to mock the HTTP client and the HTTP responses. The integration
    tests may be more complicated. We will stop here and explore more when we discuss
    the microservice architecture in the next chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Testing with authentication and authorization
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scenario in web APIs is that some API endpoints require authentication
    and authorization. We introduced how to implement authentication and authorization
    in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307). In this section, we will discuss
    how to test the API endpoints that require authentication and authorization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the sample application
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate testing with authentication and authorization, we will use the
    sample application we created in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307).
    You can find the source code in the `chapter10\AuthTestsDemo\start\` folder of
    the sample repo. This sample application uses claims-based authentication and
    authorization. You can recap the implementation details in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In `WeatherForecastController`, there are several methods that require authentication
    and authorization. (Forgive the naming – we just use the default template of ASP.NET
    Core web APIs.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new integration test project as described in the *Setting up the integration
    test project* section. You need to ensure that the integration test project has
    the following NuGet packages installed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Mvc.Testing`: This is the test web host of SUT'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xUnit`: This is the test framework'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Moq`: This is the mocking library'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FluentAssertions`: This is the assertion library (optional)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to run the tests in VS 2022, you also need to install `xunit.runner.visualstudio`,
    the test runner for VS 2022.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Also add the reference to the sample application project. For simplicity, we
    will only focus on the integration tests for authentication and authorization.
    So, this demo does not involve the database context and the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing you need to do is make the `Program` class public. Just add the
    following code at the end of the `Program` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we can start to write the integration tests for the API endpoints that
    require authentication and authorization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test fixture
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we explained in the *Creating a test fixture* section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371),
    we can create a test fixture to share the common code among the tests. Create
    a new class named `IntegrationTestsFixture` and add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a simple test fixture that inherits from the `WebApplicationFactory<Program>`
    class. Because we do not need to set up any services in this demo, there is no
    custom code in the `ConfigureWebHost` method. If you need to set up services,
    you can do it in this method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test class
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we can create the test class. Create a new class named `AuthTests` and
    add the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is similar to the test class we created in the *Using the test fixture*
    section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371). It inherits from the
    `IClassFixture<IntegrationTestsFixture>` interface and has a constructor that
    accepts an `IntegrationTestsFixture` instance. So, the test class can use the
    `IntegrationTestsFixture` instance to access the test web host of SUT. So far,
    there is no special code in the test class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Testing the anonymous API endpoints
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let us test the API endpoints that do not require authentication and
    authorization. In the `WeatherForecastController` class, copy the `Get()` method
    and paste it below the `Get()` method. Rename the new method `GetAnonymous()`
    and add the `AllowAnonymous` attribute. The new method should look like the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have a new API endpoint that does not require authentication and authorization.
    Create a new test method in the test class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are not many differences between this test method and the test method
    we created in the *Using the test fixture* section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
    When we use the `CreateClient()` method, there is no special code to set up `HttpClient`.
    So, the test method can send the request to the API endpoint without any authentication
    and authorization. Because this endpoint allows anonymous access, the test should
    pass.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Testing the authorized API endpoints
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `WeatherForecastController` class has an `Authorize` attribute. So, the
    API endpoints that do not have the `AllowAnonymous` attribute require authentication
    and authorization. Let''s test the sad path for the `Get()` method. Create a new
    test method in the test class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test method is similar to the previous `GetAnonymousWeatherForecast_ShouldReturnOk()`
    method, but we expect the status code to be `401 Unauthorized` because the API
    endpoint requires authentication and authorization. This test should pass as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the authentication and authorization in the test. There
    are several ways to do this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In the test, call the authentication endpoint to get the access token. Then
    add the access token to the `Authorization` header of the HTTP request. However,
    this approach is not recommended because it needs additional effort to maintain
    the credentials, such as the username, password, client ID, client secret, and
    so on. Also, the tests may not be able to access the authentication endpoint in
    the test environment. If the tests depend on the authentication endpoint, it increases
    the complexity of the tests.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a helper method to generate the access token. Then add the access token
    to the `Authorization` header of the HTTP request. This approach does not need
    to call the authentication endpoint in the test. However, it means that we need
    to know how to generate the access token. If the authentication logic is provided
    by a third-party provider, we may not be able to make the same implementation
    in the test. So, it is only available if we have full control of the authentication
    logic.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `WebApplicationFactory` to set up the authentication and authorization and
    create a custom `AuthenticationHandler` to simulate the authentication and authorization
    process. This approach is more practical because it does not need to call the
    authentication endpoint in the test. Also, it does not need to duplicate the authentication
    logic in the test project.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have the source code of the sample application, which includes the authentication
    logic, we can demonstrate how to use the second approach, and then we will show
    you how to use the third approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Generating the access token in the test
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code we use to generate the access token is from the `AccountController`
    class, which is the authentication endpoint. We can find a `GenerateToken` method
    in the `AccountController` class. This method is invoked when the user successfully
    logs in. Create a new method in the `IntegrationTestsFixture` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding method, we use the `IConfiguration` service to get the secret,
    issuer, and audience from the configuration. Then we copy the code from the `GenerateToken()`
    method in the `AccountController` class to generate the access token. Note that
    the configuration comes from the `appsettings.json` file in the main web API project.
    As we did not change the configuration of the test web host, the configuration
    is the same as that in the main web API project. But if you need to use a different
    configuration for the tests, please add proper code to the `ConfigureWebHost`
    method in the `IntegrationTestsFixture` class to apply any changes, as we introduced
    in the *Creating a test* *fixture* section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can use the `GenerateToken` method in the `AuthTest` class. Create
    a new test method in the test class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this test method, we call the `GenerateToken()` method to generate an access
    token, and then add the access token to the `Authorization` header of the HTTP
    request. Because the logic we use to generate the token is the same as the authentication
    endpoint, the test should pass.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom authentication handler
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to test the authorized API endpoints is to use a custom authentication
    handler. A custom authentication handler can simulate the authentication and authorization
    process. So, we can use it to test the authorized API endpoints without calling
    the authentication endpoint. This is the recommended approach to test the authorized
    API endpoints because it does not need any other dependencies, nor does it need
    to duplicate the authentication logic in the test project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In the actual authentication process, we need to generate a JWT token that includes
    the claims of the authenticated user and add it to the `Authorization` header
    of the HTTP request. If we use a custom authentication handler, we can skip the
    process of generating the JWT token, but we still need to find a way to define
    the claims that we need and pass them to the custom authentication handler. We
    can simply add the claims in the request headers and then read the values in the
    custom authentication handler to create the `ClaimsPrincipal` object. Let us demonstrate
    how to do this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a custom authentication handler, first create a new class named `TestAuthHandler`,
    which inherits from the `AuthenticationHandler` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we define the authentication scheme name as `TestScheme`,
    which is an alternative name to the actual scheme name, `Bearer`. You can find
    the definition in the `Program` class. Also, we define a few names for HTTP headers,
    which we will use to pass the claims to the custom authentication handler. The
    `HandleAuthenticateAsync()` method is the method that we need to override to implement
    the authentication logic. We will implement it in the following code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that when we create the request in the test, we simply add the
    claims to the request headers. So that the custom authentication handler can read
    the values from the request headers, update the `HandleAuthenticateAsync()` method
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Instead of getting claims from the JWT token, we get the claims from the request
    headers. If the values exist, we add them to the `ClaimsIdentity` object. Then
    we create the `ClaimsPrincipal` object and the `AuthenticationTicket` object.
    Finally, we return the `AuthenticateResult` object with the `Success` status.
    This method simulates the authentication process, which avoids the need to generate
    the JWT token, but it still creates the `ClaimsPrincipal` object that we need
    to test the authorized API endpoints.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can test the authorized API endpoints by using the custom authentication
    handler. In the `WeatherForecastController` class, we can find a `GetDrivingLicense`
    method, which is an authorized API endpoint that needs the `DrivingLicenseNumber`
    claim. We can create a new test method in the `AuthTest` class as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this test method, we specify the test web host of SUT with the `WithWebHostBuilder`
    method and then call the `AddAuthentication` method to specify the authentication
    scheme. Then we call the `AddScheme` method to apply the `TestAuthHandler` authentication
    handler to the authentication service. With this customized test web host, we
    can create a new HTTP client. Before we send the request using this HTTP client,
    we need to add the `Authorization` header that specifies the authentication scheme.
    We also add the claims to the request headers for simplicity, so that the custom
    authentication handler can read the values from the request headers and create
    the `ClaimsPrincipal` object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Then we can call the `GetAsync` method to send the HTTP request to the API endpoint.
    Finally, we can verify the response status code and the response content type
    to ensure the request was successful.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding test method is for a happy path. To test the unauthorized scenario,
    we can create a new test method that does not add the `DrivingLicenseNumberHeader`
    header to the request, and verify that the response status code is `401 Unauthorized`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding test method, we do not add the `DrivingLicenseNumberHeader`
    header to the request. So, the custom authentication handler cannot find the `DrivingLicenseNumber`
    claim, and it will return the `Forbidden` status code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we found that there is some duplicated code in the preceding test methods.
    If we need to set up the test web host and create the HTTP client for each test
    method, we can move the code to the `IntegrationTestsFixture` class. Create a
    method called `CreateClientWithAuth` in the `IntegrationTestsFixture` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `CreateClientWithAuth()` method accepts the claims as parameters and then
    creates the `HttpClient` with the customized test web host. In this way, we can
    easily control the claims for each test method. Then we can update the test methods
    to use this method. For example, the test methods for the `GetCountry` endpoint
    can be updated as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we can verify that the test methods are still working as expected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The test methods pass as expected in VS 2022](img/B18971_10_1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The test methods pass as expected in VS 2022
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can also customize the `AuthenticationSchemeOptions` class if
    you need to. For example, you can define a `TestAuthHandlerOptions` class that
    inherits from the `AuthenticationSchemeOptions` class, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can then configure `TestAuthHandlerOptions` in the `ConfigureTestServices`
    method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `TestAuthHandler` class should now be updated as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `TestAuthHandler` class can now get the username from the `TestAuthHandlerOptions`
    class. You can also define other properties in the `TestAuthHandlerOptions` class,
    and then use them in the `TestAuthHandler` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'If your project does not use claim-based authorization, you can also define
    a custom authorization handler to implement the authorization logic. Please check
    the official document for more information: [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have covered the unit tests and integration tests in ASP.NET Core. In
    this section, we will discuss **code coverage**, which is a metric that measures
    the extent to which the source code of the application is covered by the test
    suite during testing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a very important metric for software quality. If the code coverage
    is low, it means that there are many parts of the code that are not covered by
    the tests. In this case, we are not confident that the code is working as expected.
    Also, when we make changes or refactor the code, we are not sure whether the changes
    will break the existing code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage provides insights into which parts of the code are covered (or
    not covered) by the tests. It can help us identify areas that may require additional
    testing and ensure that the code is tested thoroughly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage plays a vital role in assessing the effectiveness and reliability
    of the testing process. By analyzing code coverage, we can gain confidence in
    the quality of the code and identify potential areas of weakness or untested code.
    Adequate code coverage is essential to improve the quality of the code and reduce
    the risks of bugs and defects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that code coverage is not the sole indicator of code
    quality. While high code coverage is desirable, achieving 100% code coverage does
    not guarantee that the code is bug-free. Code coverage should be accompanied by
    other factors such as effective test design, code reviews, static analysis, manual
    testing, and so on. Additionally, factors such as code design, architecture, and
    development practices also play a role in the quality of the code. We need to
    find a balance between code coverage and other factors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'To analyze the code coverage, we have two steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Collecting test data**: The data collector can monitor the test execution
    and collect the code coverage data during test runs. It can report code coverage
    data in different formats, such as XML or JSON.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generating the report**: The report generator can read the collected data
    and generate the code coverage report, often in HTML format.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us see how to use the data collector and report generator. We will use the
    `InvoiceApp` project as an example. You can find the sample project in the `chapter10\IntegrationTestsDemo\IntegrationTest-v1`
    folder.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Using data collectors
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use data collectors, we can use **Coverlet**. Coverlet is a cross-platform
    code coverage framework for .NET, with support for line, branch, and method coverage.
    It can be used either as a .NET Core global tool or a NuGet package. For more
    information, please check the Coverlet repo on GitHub: [https://github.com/coverlet-coverage/coverlet](https://github.com/coverlet-coverage/coverlet).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The xUnit project template already includes the Coverlet package. If your test
    project does not include the Coverlet package, you can install it by running the
    following command in the Package Manager Console:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To get coverage data, navigate to the test project folder, and run the following
    command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `--collect:"XPlat Code Coverage"` option tells the `dotnet test` command
    to collect the code coverage data. The `XPlat Code Coverage` parameter is a friendly
    name for the collector. You can use any name you like but note that it is case
    insensitive. The code coverage data will be saved in the `TestResults` folder.
    You can find the code coverage data in the `coverage.cobertura.xml` file. The
    folder structure is `/TestResults/{GUID}/coverage.cobertura.xml`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample of the `coverage.cobertura.xml` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code, we can see the following information:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`line-rate`: This is the percentage of lines covered by tests'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`branch-rate`: This is the percentage of branches covered by tests'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lines-covered`: This is the number of lines covered by tests'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lines-valid`: This is the number of lines in the source code'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`branches-covered`: This is the number of branches covered by tests'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`branches-valid`: This is the number of branches in the source code'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use Coverlet as a .NET global tool. To do this, you can run the
    following command to install Coverlet as a .NET global tool:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then you can use it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Please update the paths in the preceding command to match your project structure.
    The `--no-build` option is used to skip building the test project, which is useful
    if you have already built the test project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the code coverage data. However, the `coverage.cobertura.xml` file
    is not human-readable. So, we must generate a human-readable report, which we
    will introduce in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Generating a code coverage report
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand the coverage data, we can generate a code coverage report.
    To do this, we can use the `ReportGenerator` NuGet package. **ReportGenerator**
    is a tool that can convert coverage data generated by Coverlet into human-readable
    reports. It also supports other coverage formats, such as **OpenCover**, **dotCover**,
    **NCover**, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'To install ReportGenerator, we can run the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we can run the following command to generate a code coverage report:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please update the paths in the preceding command to match your project structure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'If the command runs successfully, you will see the generated HTML report in
    the `coveragereport` folder. You can open the `index.html` file in the browser
    to view the report. The report looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Code coverage report](img/B18971_10_2.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Overview of the code coverage report
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check each class to see the code coverage details, as shown in *Figure
    10**.3*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Code coverage details](img/B18971_10_3.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Overview of the code coverage details
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 10**.4*, we can see that some lines are not covered by tests:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Lines not covered by tests highlighted in red](img/B18971_10_4.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Overview of the lines not covered by tests highlighted in red
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the code coverage in our sample project is awful. But luckily, it is
    just a sample project. In real-world projects, we should try our best to improve
    the code coverage!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to use Coverlet and ReportGenerator to
    generate code coverage data and reports. Code coverage is an essential aspect
    of effective software testing. By leveraging these reports, developers and quality
    assurance teams can gain insights into the quality of their tests and the quality
    of their code, which can ultimately enhance the reliability and stability of the
    application and also help us confidently refactor code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to write integration tests for ASP.NET Core
    web API applications. We learned how to create a test fixture to set up the test
    web host, and how to use the test fixture in the test class. We also learned how
    to test authorized endpoints and generate code coverage data and reports.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何为ASP.NET Core网络API应用程序编写集成测试。我们学习了如何创建测试固定装置来设置测试网络主机，以及如何在测试类中使用测试固定装置。我们还学习了如何测试授权端点并生成代码覆盖率数据和报告。
- en: As a good developer, it is important to write tests for your code. Writing tests
    is not only a beneficial practice but also a beneficial habit to form. You may
    find that you spend more time writing tests than writing features, but the effort
    is worth it. To ensure your ASP.NET web API applications are functioning correctly,
    make sure to write both unit tests and integration tests. Doing so will help to
    ensure your code is reliable and secure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名优秀的开发者，为你的代码编写测试非常重要。编写测试不仅是一种有益的实践，而且是一种有益的习惯。你可能发现你在编写测试上花费的时间比编写功能还要多，但这份努力是值得的。为了确保你的ASP.NET网络API应用程序能够正确运行，请确保编写单元测试和集成测试。这样做将有助于确保你的代码是可靠和安全的。
- en: 'In the next chapter, we will explore another aspect of web APIs: gRPC, which
    is a high-performance, open-source, universal RPC framework.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨网络API的另一个方面：gRPC，这是一个高性能、开源的通用RPC框架。
