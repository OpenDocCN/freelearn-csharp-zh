- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Common .NET Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about some common types that are included with .NET. These include
    types for manipulating numbers, text, and collections; improving working with
    spans, indexes, and ranges; and, in an optional online-only section, working with
    network resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple objects in collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with spans, indexes, and ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common types of data is numbers. The most common types in .NET
    for working with numbers are shown in *Table 8.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Example types** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `SByte`, `Int16`, `Int32`, `Int64`, `Int128` | Integers; that
    is, zero, and positive and negative whole numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64`, `UInt128` | Cardinals; that
    is, zero and positive whole numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Half`, `Single`, `Double` | Reals; that is, floating-point numbers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Decimal` | Accurate reals; that is, for use in science, engineering,
    or financial scenarios. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | Arbitrarily large
    integers, complex numbers, and quaternion numbers. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Common .NET number types'
  prefs: []
  type: TYPE_NORMAL
- en: .NET has had the 32-bit `float` and 64-bit `double` types since .NET Framework
    1.0 was released in 2002\. The IEEE 754 specification also defines a 16-bit floating-point
    standard. Machine learning and other algorithms would benefit from this smaller,
    lower-precision number type; so, Microsoft introduced the `System.Half` type with
    .NET 5 and later. Currently, the C# language does not define a `half` alias, so
    you must use the .NET type `System.Half`. This might change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Int128` and `System.UInt128` were introduced with .NET 7, and they
    too do not yet have a C# alias keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with big integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The largest whole number that can be stored in .NET types that have a C# alias
    is about eighteen and a half quintillion, stored in an unsigned 64-bit integer
    using `ulong`. But what if you need to store numbers larger than that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore numerics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithNumbers`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter08`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the project file, add an element to statically and globally import the `System.Console`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add a statement to
    import `System.Numerics`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to output the maximum value of the `ulong` type, and a number
    with 30 digits using `BigInteger`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `width` constant with the value `40` in the format code means “right-align
    40 characters,” so both numbers are lined up to the right-hand edge. The `N0`
    means “use a thousand separators and zero decimal places.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BigInteger` can represent integer values of nearly unlimited length. However,
    in reality, this is constrained by factors like available memory and computation
    time. Some APIs can also fail if the value produced is excessively large. Therefore,
    in .NET 9 and later, a maximum length for `BigInteger` has been enforced, limiting
    it to `(2^31) - 1` bits (approximately 2.14 billion bits). This translates to
    about 256 MB and approximately 646.5 million digits. This limit ensures APIs remain
    reliable and consistent while still supporting numbers far larger than most practical
    needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying big integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you multiply two 32-bit integers, the result can exceed the range of a
    32-bit integer. For instance, the maximum value of a 32-bit integer (`int`) is
    2,147,483,647\. If you multiply this by another large integer, the result can
    exceed this limit, causing an overflow and potentially resulting in incorrect
    calculations if only 32 bits are used to store the result.
  prefs: []
  type: TYPE_NORMAL
- en: Since the earliest versions of .NET, the `System.Math` class has a `BigMul`
    method that performs a multiplication of two 32-bit integers and returns the full
    64-bit result as a `long`. This method is necessary because multiplying two 32-bit
    integers using the * operator can result in a 64-bit integer, which might overflow
    the typical 32-bit integer type.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 5, `BigMul` has gained overloads to multiply two signed or unsigned
    `long` values. In .NET 9 and later, the number types themselves, like `int` and
    `long` and `uint` and `ulong`, now gain `BigMul` methods to multiply their values
    and return the results in the next largest type. For example, `long.BigMul` returns
    a `System.Int128`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at how to multiply big integers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to multiply some big integers using old and
    new methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex number can be expressed as *a + bi*, where *a* and *b* are real numbers
    and *i* is an imaginary unit, where *i*² *= −1*. If the real part *a* is zero,
    it is a purely imaginary number. If the imaginary part *b* is zero, it is a real
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers have practical applications in many **science, technology,
    engineering, and mathematics** (**STEM**) fields of study. They are added by separately
    adding the real and imaginary parts of the summands; consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explore complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two complex numbers, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '.NET 6 and earlier used a different default format for complex numbers: `(4,
    2) added to (3, 7) is (7, 9)`. In .NET 7 and later, the default format was changed
    to use angle brackets and semi-colons because some cultures use round brackets
    to indicate negative numbers and use commas for decimal numbers. At the time of
    writing, the official documentation has not been updated to use the new format,
    as shown at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex.tostring](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex.tostring).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with tensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tensors are a fundamental data structure in **artificial** **intelligence**
    (**AI**). You can think of them as specialized multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Tensors are used to represent and encode various forms of data, including text
    sequences (tokens), images, videos, and audio. Tensors perform computations on
    high-dimensional data with optimal efficiency and store weight information and
    intermediate calculations within neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 9 introduced a new `Tensor<T>` type that enables efficient interoperation
    with AI libraries, such as ML.NET, TorchSharp, and ONNX Runtime, and minimizes
    data copying where possible. It simplifies data manipulation through intuitive
    indexing and slicing operations, ensuring ease of use and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers for games and similar apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In scenarios that don’t need truly random numbers like games, you can create
    an instance of the `Random` class, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Random` has a constructor with a parameter for specifying a seed value used
    to initialize its pseudo-random number generator, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you learned in *Chapter 2*, *Speaking C#*, parameter names should use *camel
    case*. The developer who defined the constructor for the `Random` class broke
    this convention. The parameter name should be `seed`, not `Seed`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Shared seed values act as a secret key; so, if you use the
    same random number generation algorithm with the same seed value in two applications,
    then they can generate the same “random” sequences of numbers. Sometimes this
    is necessary, for example, when synchronizing a GPS receiver with a satellite,
    or when a game needs to randomly generate the same level. But usually, you want
    to keep your seed secret.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers with the Random class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid allocating more memory than necessary, .NET 6 introduced a shared static
    instance of `Random` that you can access instead of creating your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Random` class has commonly used methods for generating random numbers,
    as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Next`: This method returns a random `int` (whole number) and it takes two
    parameters, `minValue` and `maxValue`, but `maxValue` is not the maximum value
    that the method returns! It is an *exclusive upper bound*, meaning `maxValue`
    is one more than the maximum value returned. Use the `NextInt64` method to return
    a `long` integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NextDouble`: This method returns a number that is greater than or equal to
    `0.0` and less than and never equal to `1.0`. Use the `NextSingle` method to return
    a `float`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NextBytes`: This method populates an array of any size with random `byte`
    (`0` to `255`) values. It is common to format `byte` values as hexadecimal, for
    example, `00` to `FF`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some examples of generating pseudo-random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to access the shared `Random` instance, and
    then call its methods to generate random numbers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In scenarios that do need truly random numbers, like cryptography, there are
    specialized types for that, like `RandomNumberGenerator`. I cover this and other
    cryptographic types in the companion book, *Tools and Skills for .NET 8*, in a
    chapter titled *Protecting Data and Apps Using Cryptography*, published in July
    2024.
  prefs: []
  type: TYPE_NORMAL
- en: New random methods in .NET 8 and later
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '.NET 8 introduced two new `Random` methods, as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetItems<T>`: This method is passed an array or read-only span of any type
    `T` of choices and the number of items you want to generate, and then it returns
    that number of items randomly selected from the choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shuffle<T>`: This method is passed an array or span of any type `T` and the
    order of items is randomized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example of each:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to access the shared `Random` instance, and
    then call its methods to generate random numbers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generating GUIDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **globally unique identifier (GUID)** is a 128-bit text string that represents
    a unique value for identification. As a developer, you will need to generate GUIDs
    when a unique reference is needed to identify information. Traditionally, database
    and computer systems may have used an incrementing integer value, but a GUID is
    more likely to avoid conflicts in multi-tasking systems.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Guid` type is a value type (`struct`) that represents a GUID value.
    It has `Parse` and `TryParse` methods to take an existing GUID value represented
    as a `string` and convert it into the `Guid` type. It has a `NewGuid` method to
    generate a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewGuid` method implements version 4 of the **universally unique identifiers
    (UUIDs)** specification. You can learn about the UUID specification at the following
    link: [https://datatracker.ietf.org/doc/rfc9562/](https://datatracker.ietf.org/doc/rfc9562/).'
  prefs: []
  type: TYPE_NORMAL
- en: .NET 9 introduced support for version 7 of the UUID specification, which allows
    you to control the first 48-bit timestamp millisecond ticks since Unix Epoch so
    that you can create sortable GUIDs. This is much better for unique IDs for databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down an example value: `0191a398-12ec-7d5e-a8d3-8a629eae8be1`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first 48 bits are a timestamp in hexadecimal: `0191a39812ec`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0191a398`: The first 32 bits represent the high part of the timestamp.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`12ec`: The next 16 bits continue the timestamp.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next 12 bits are a version and variant in hexadecimal: `7d5e`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `7` indicates that this is a version 7 UUID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining three digits (`d5e`) combine parts of the timestamp and the variant,
    which is used to identify the layout of the UUID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final 68 bits are a random section in hexadecimal: `a8d3-8a629eae8be1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures the uniqueness of the GUID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we can generate GUID values and output them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to output the value of an empty `Guid`, generate
    a new random `Guid` and then output its value, and finally output each individual
    byte of the random `Guid` value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the first parts of the three GUID
    values (`0191a398-12ec` and so on) are sortable because they are based on the
    same `DateTimeOffset` value, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The EF Core team has a proposal to enable the use of version 7 GUIDs in your
    data models. You can learn more about that idea at the following link: [https://github.com/dotnet/efcore/issues/34158](https://github.com/dotnet/efcore/issues/34158).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the other most common types of data for variables is text. The most
    common types in .NET for working with text are shown in *Table 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Char` | Storage for a single text character |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `String` | Storage for multiple text characters |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Text` | `StringBuilder` | Efficiently manipulates strings |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Text.RegularExpressions` | `Regex` | Efficiently pattern-matches
    strings |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.2: Common .NET types for working with text'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the length of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore some common tasks when working with text; for example, sometimes
    you need to find out the length of a piece of text stored in a `string` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithText` to the `Chapter08` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithText` project, in `Program.cs`, delete the existing statements
    and then add statements to define a variable to store the name of the city, London,
    and then write its name and length to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting the characters of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` class uses an array of `char` internally to store the text. It
    also has an indexer, which means that we can use the array syntax to read its
    characters. Array indexes start at 0, so the third character will be at index
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a statement to write the characters at the first and fourth positions in
    the `string` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Splitting a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to split some text wherever there is a character, such
    as a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a single `string` variable containing comma-separated
    city names, then use the `Split` method and specify that you want to treat commas
    as the separator, and then enumerate the returned array of `string` values, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Later in this chapter, you will learn how to handle more complex string-splitting
    scenarios using a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Getting part of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to get part of some text. The `IndexOf` method has nine
    overloads that return the index position of a specified `char` or `string` within
    a `string`. The `Substring` method has two overloads, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Substring(startIndex, length)`: This returns part of a string starting at
    `startIndex` and containing the next `length` characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Substring(startIndex)`: This returns part of a string starting at `startIndex`
    and containing all characters up to the end of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a person’s full name in a `string` variable with a
    space character between the first and last names, find the position of the space,
    and then extract the first name and last name as two parts so that they can be
    recombined in a different order, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the format of the initial full name was different, for example, `"LastName,
    FirstName"`, then the code would need to be different. As an optional exercise,
    try writing some statements that would change the input `"Shore, Alan"` into `"Alan
    Shore"`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking a string for content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to check whether a piece of text starts or ends with some
    characters or contains some characters. You can achieve this with methods named
    `StartsWith`, `EndsWith`, and `Contains`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a `string` value and then check if it starts with or
    contains a couple of different `char` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: `StartsWith`, `EndsWith`, and `Contains` can be passed a
    `string` or `char` value. The single quotes indicate a `char` value in the preceding
    code. Searching for a `char` like `''M''` is more efficient than searching for
    a `string` value like `"M"`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comparing string values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two common tasks with string values are sorting (aka collating) and comparing.
    For example, when a user enters their username or password, you need to compare
    what they entered with what is stored.
  prefs: []
  type: TYPE_NORMAL
- en: The `string` class implements the `IComparable` interface, meaning that you
    can easily compare two string values using the `CompareTo` instance method and
    it will return `-1`, `0`, or `1` depending on if the value is “less than,” “equal
    to,” or “greater than” the other. You saw an example of this when you implemented
    the `IComparable` interface for the `Person` class in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the lower or upper casing of characters can affect ordering, and the
    ordering rules for text are culture-dependent. For example, double-L is treated
    as a single character in traditional Spanish, as shown in *Table 8.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Culture** | **Description** | **Example string values** |'
  prefs: []
  type: TYPE_TB
- en: '| Spanish | In 1994, the Royal Spanish Academy issued a new alphabetization
    rule to treat LL and CH as Latin alphabetic characters instead of separate individual
    characters. | Modern: `llegar` comes before `lugar`. Traditional: `llegar` comes
    after `lugar`. |'
  prefs: []
  type: TYPE_TB
- en: '| Swedish | In 2006, the Swedish Academy issued a new rule. Before 2006, V
    and W were the same character. Since 2006, they have been treated as separate
    characters. | Swedish words mostly only use V. Loanwords (words taken from other
    languages) that contain W can now keep those Ws instead of replacing the Ws with
    Vs. |'
  prefs: []
  type: TYPE_TB
- en: '| German | Phonebook ordering is different than dictionary ordering, for example,
    umlauts are sorted as combinations of letters. | `Müller` and `Mueller` in phonebook
    ordering are the same name. |'
  prefs: []
  type: TYPE_TB
- en: '| German | The character `ß` is sorted as `SS`. This is a common issue with
    addresses since the word for `street` is `Straße`. | `Straße` and `Strasse` have
    the same meaning. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.3: Examples of ordering rules in European languages'
  prefs: []
  type: TYPE_NORMAL
- en: For consistency and performance, you sometimes want to make comparisons in a
    culture-invariant way. It is therefore better to use the `static` method `Compare`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for working with cultures
    and enable special characters like the Euro currency symbol, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, define some text variables and compare them in different cultures,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that a lowercase “a” is “less than”
    (`-1`) an uppercase “A,” so the comparison returns -1\. But we can either set
    an option to ignore case, or even better, do a culture- and case-invariant comparison
    to treat the two string values as equal (`0`), as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: You can learn more about `string` comparisons at the
    following link: [https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison](https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison).'
  prefs: []
  type: TYPE_NORMAL
- en: Joining, formatting, and other string members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other `string` members, as shown in *Table 8.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Trim`, `TrimStart`, `TrimEnd` | These methods trim whitespace characters
    such as space, tab, and carriage return from the start and/or end. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToUpper`, `ToLower` | These convert all the characters into uppercase or
    lowercase. |'
  prefs: []
  type: TYPE_TB
- en: '| `Insert`, `Remove` | These methods insert or remove some text. |'
  prefs: []
  type: TYPE_TB
- en: '| `Replace` | This replaces some text with other text. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Empty` | This can be used instead of allocating memory each time
    you use a literal string value using an empty pair of double quotes (`""`). |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Concat` | This concatenates two string variables. The `+` operator
    does the equivalent when used between string operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Join` | This concatenates one or more string variables with a character
    in between each one. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrEmpty` | This checks whether a string variable is null or
    empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrWhiteSpace` | This checks whether a string variable is null
    or whitespace; that is, a mix of any number of horizontal and vertical spacing
    characters, for example, tab, space, carriage return, line feed, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Format` | An alternative method to string interpolation for outputting
    formatted string values, which uses positioned instead of named parameters. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.4: Joining, formatting, and other string members'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the preceding methods are `static` methods. This means that the method
    can only be called from the type, not from a variable instance. In the preceding
    table, I indicated the static methods by prefixing them with `string.`, as in
    `string.Format`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore some of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to take an array of `string` values and combine them back together
    into a single `string` variable with separators using the `Join` method, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to use positioned parameters and interpolated `string` formatting
    syntax to output the same three variables twice, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some code editors, like Rider, will warn you about boxing operations. These
    are slow but not a problem in this scenario. To avoid boxing, call `ToString`
    on `price` and `when`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we could have simplified the second statement because `Console.WriteLine`
    supports the same format code as `string.Format`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Building strings efficiently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can concatenate two strings to make a new `string` using the `String.Concat`
    method or simply by using the `+` operator. But both choices are bad practices
    when combining more than a few values because .NET must create a completely new
    `string` in memory.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be noticeable if you are only adding two `string` values, but
    if you concatenate inside a loop with many iterations, it can have a significant
    negative impact on performance and memory use. You can concatenate `string` variables
    more efficiently using the `StringBuilder` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have written an online-only section for the companion book, *Apps and Services
    with .NET 8*, about performance benchmarking using `string` concatenations as
    the main example. You can optionally complete the section and its practical coding
    tasks at the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md).'
  prefs: []
  type: TYPE_NORMAL
- en: '**More information**: You can see examples of using `StringBuilder` at the
    following link: [https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#examples](https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#examples).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to work with individual characters. The `System.Char` type
    (aka `char`) has some useful methods, as shown in *Table 8.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsDigit(char)`, `char.IsDigit(string, int)` | Returns `true` if the
    character is a decimal digit. |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsLetter(char)`, `char.IsLetter(string, int)` | Returns `true` if the
    character is a letter. |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsLower(char)`, `char.IsLower(string, int)` | Returns `true` if the
    character is a lowercase letter. |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsUpper(char)`, `char.IsUpper(string, int)` | Returns `true` if the
    character is an uppercase letter. |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsSeparator(char)`, `char.IsSeparator(string, int)` | Returns `true`
    if the character is a separator. |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsSymbol(char)`, `char.IsSymbol(string, int)` | Returns `true` if the
    character is a symbol. |'
  prefs: []
  type: TYPE_TB
- en: '| `char.IsWhiteSpace(char)`, `char.IsWhiteSpace(string, int)` | Returns `true`
    if the character is whitespace like a space or tab. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.5: Methods for working with characters'
  prefs: []
  type: TYPE_NORMAL
- en: Searching in strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET 8 introduced the `SearchValues` type, which implements an optimized method
    for searching for sets of characters or bytes within spans. For example, `SearchValues`
    helps to find the first instance of a vowel in a text value, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first vowel in the text `Fred` is at index position 2, as shown in the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In .NET 9 or later, `SearchValues` now supports searching for substrings as
    well as searching for characters within a larger string, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first name from the list of Andor characters starts at index position 55,
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are useful for validating input from the user. They are
    very powerful and can get very complicated. Almost all programming languages have
    support for regular expressions and use a common set of special characters to
    define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out some example regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithRegularExpressions` to the `Chapter08` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then import the following
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Checking for digits entered as text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by implementing the common example of validating number input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to prompt the user to enter their age and then
    check that it is valid using a regular expression that looks for a digit character,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following about the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@` character switches off the ability to use escape characters in the `string`.
    Escape characters are prefixed with a backslash. For example, `\t` means a tab
    and `\n` means a new line. When writing regular expressions, we need to disable
    this feature. To paraphrase the television show *The West Wing*, “Let backslash
    be backslash.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once escape characters are disabled with `@`, then they can be interpreted by
    a regular expression. For example, `\d` means digit. You will learn about more
    regular expression symbols that are prefixed with a backslash later in this topic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code, enter a whole number, such as `34`, for the age, and view the
    result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again, enter `carrots`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again, enter `bob30smith`, and view the result, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The regular expression we used is `\d`, which means *one digit*. However, it
    does not specify what can be entered before and after that one digit. This regular
    expression could be described in English as “Enter any characters you want as
    long as you enter at least one digit character.”
  prefs: []
  type: TYPE_NORMAL
- en: In regular expressions, you indicate the start of some input with the caret
    `^` symbol and the end of some input with the dollar `$` symbol. Let’s use these
    symbols to indicate that we expect nothing else between the start and end of the
    input except for a digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `^` and a `$` to change the regular expression to `^\d$`, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code again and note that it rejects any input except a single digit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `+` after the `\d` expression to modify the meaning to one or more digits,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code again and note the regular expression only allows zero or positive
    whole numbers of any length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regular expression performance improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET types for working with regular expressions are used throughout the
    .NET platform and many of the apps built with it. As such, they have a significant
    impact on performance. However, until .NET 5, they had not received much optimization
    attention from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 5 and later, the types in the `System.Text.RegularExpressions` namespace
    have rewritten implementations to squeeze out maximum performance. Common regular
    expression benchmarks using methods like `IsMatch` are now five times faster.
    The best thing is you do not have to change your code to get the benefits!
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 7 and later, the `IsMatch` method of the `Regex` class now has an
    overload for a `ReadOnlySpan<char>` as its input, which gives even better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the syntax of a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some common symbols that you can use in regular expressions are shown in *Table
    8.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Meaning** | **Symbol** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of input | `$` | End of input |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit | `\D` | A single *non*-digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Whitespace | `\S` | *Non*-whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Word characters | `\W` | *Non*-word characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Za-z0-9]` | Range(s) of characters | `\^` | ^ (caret) character |'
  prefs: []
  type: TYPE_TB
- en: '| `[aeiou]` | Set of characters | `[^aeiou]` | *Not* in a set of characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any single character | `\.` | . (dot) character |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.6: Common regular expression symbols'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, some common regular expression quantifiers that affect the previous
    symbols in a regular expression are shown in *Table 8.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Meaning** | **Symbol** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more | `?` | One or none |'
  prefs: []
  type: TYPE_TB
- en: '| `{3}` | Exactly three | `{3,5}` | Three to five |'
  prefs: []
  type: TYPE_TB
- en: '| `{3,}` | At least three | `{,3}` | Up to three |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.7: Common regular expression quantifiers'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some examples of regular expressions with a description of their meaning are
    shown in *Table 8.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | The character “a” somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `Bob` | The word “Bob” somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `^Bob` | The word “Bob” at the start of the input |'
  prefs: []
  type: TYPE_TB
- en: '| `Bob$` | The word “Bob” at the end of the input |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d{2}$` | Exactly two digits |'
  prefs: []
  type: TYPE_TB
- en: '| `^[0-9]{2}$` | Exactly two digits |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{4,}$` | At least four uppercase English letters in the ASCII character
    set only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z]{4,}$` | At least four upper or lowercase English letters in the
    ASCII character set only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{2}\d{3}$` | Two uppercase English letters in the ASCII character
    set and three digits only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z\u00c0-\u017e]+$` | At least one uppercase or lowercase English
    letter in the ASCII character set or European letters in the Unicode character
    set, as shown in the following list:`ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝ``Þßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸŽž`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `^d.g$` | The letter `d`, then any character, and then the letter `g`, so
    it would match both `dig` and `dog` or any single character between the `d` and
    `g` |'
  prefs: []
  type: TYPE_TB
- en: '| `^d\.g$` | The letter `d`, then a dot `.`, and then the letter `g`, so it
    would match `d.g` only |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.8: Examples of regular expressions with descriptions of their meaning'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Use regular expressions to validate input from the user.
    The same regular expressions can be reused in other languages, such as JavaScript
    and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A handy website for building and testing regular expressions can be found at
    the following link: [https://regex101.com/](https://regex101.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex comma-separated string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned how to split a simple comma-separated string
    variable. But what about the following example of film titles?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `string` value uses double quotes around each film title. We can use these
    to identify whether we need to split on a comma (or not). The `Split` method is
    not powerful enough, so we can use a regular expression instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: You can read a fuller explanation in the Stack Overflow
    article that inspired this task at the following link: [https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include double quotes inside a `string` value, we prefix them with a backslash,
    or we could use the raw string literal feature in C# 11 or later:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a complex comma-separated `string` variable, and then
    split it in a dumb way using the `Split` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to define a regular expression to split and write the film titles
    in a smart way, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a later section, you will see how you can get a source generator to auto-generate
    XML comments for a regular expression to explain how it works. This is really
    useful for regular expressions that you might have copied from a website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Activating regular expression syntax coloring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use Visual Studio as your code editor, then you probably noticed that
    when passing a `string` value to the `Regex` constructor, you see color syntax
    highlighting, as shown in *Figure 8.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Regular expression color syntax highlighting when using the Regex
    constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be a good time to remind print book readers, who will only see the
    preceding figure in grayscale, that they can see all figures in full color as
    a PDF at the following link: [https://packt.link/gbp/9781837635870](https://packt.link/gbp/9781837635870).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does this `string` get syntax coloring for regular expressions when most
    `string` values do not? Let’s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `new` constructor, select **Go To Implementation**, and
    note the `string` parameter named `pattern` is decorated with an attribute named
    `StringSyntax` that has the `string` constant `Regex` value passed to it, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right-click on the `StringSyntax` attribute, select **Go To Implementation**,
    and note there are 12 recognized `string` syntax formats that you can choose from
    as well as `Regex`, as shown in the following partial code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `WorkingWithRegularExpressions` project, add a new class file named
    `Program.Strings.cs`, delete any existing statements, and then define some `string`
    constants in a partial `Program` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the two `string` constants do not have any color syntax highlighting
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, replace the literal `string` with the `string` constant for
    the digits-only regular expression, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, replace the literal `string` with the `string` constant for
    the comma-separator regular expression, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `WorkingWithRegularExpressions` project and confirm that the regular
    expression behavior is as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Strings.cs`, import the namespace for the `[StringSyntax]` attribute
    and then decorate both `string` constants with it, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Strings.cs`, add another `string` constant for formatting a date,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click inside the empty string, type the letter `d`, and note the IntelliSense
    explanation, as shown in *Figure 8.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: IntelliSense activated due to the StringSyntax attribute'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish entering the date format and as you type, note the IntelliSense value:
    `dddd, d MMMM yyyy`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside, at the end of the `DigitsOnlyText` string literal, enter `\`, and note
    the IntelliSense to help you write a valid regular expression, as shown in *Figure
    8.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: IntelliSense for writing a regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `\` that you entered to trigger IntelliSense.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `[StringSyntax]` attribute is a feature introduced in .NET 7\. It depends
    on your code editor whether it is recognized. The .NET BCL has more than 350 parameters,
    properties, and fields that are now decorated with this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Improving regular expression performance with source generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you pass a string literal or string constant to the constructor of `Regex`,
    the class parses the string and transforms it into an internal tree structure
    that represents the expression in an optimized way that can be executed efficiently
    by a regular expression interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also compile regular expressions by specifying `RegexOptions`, as in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, compiling has the negative effect of slowing down the initial
    creation of the regular expression. After creating the tree structure that would
    then be executed by the interpreter, the compiler then must convert the tree into
    IL code, and then that IL code needs to be JIT compiled into native code. If you’re
    only running the regular expression a few times, it is not worth compiling it,
    which is why it is not the default behavior. If you’re running the regular expression
    more than a few times, for example, because it will be used to validate the URL
    for every incoming HTTP request to a website, then it is worth compiling. But
    even then, you should only use compilation if you must use .NET 6 or earlier.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 7 introduced a source generator for regular expressions that recognizes
    if you decorate a partial method that returns `Regex` with the `[GeneratedRegex]`
    attribute. It generates an implementation of that method that implements the logic
    for the regular expression. .NET 9 allows you to use partial properties, which
    have a more natural syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithRegularExpressions` project, add a new class file named
    `Program.Regexs.cs` and modify its content to define some `partial` properties,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, replace the `new` constructor with a call to the `partial`
    method that returns the digits-only regular expression, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, replace the new constructor with a call to the `partial` method
    that returns the comma-separator regular expression, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hover your mouse pointer over the `partial` methods and note the tooltip describes
    the behavior of the regular expression, as shown in *Figure 8.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Tooltip for a partial method shows a description of the regular
    expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the `DigitsOnly` `partial` method, select **Go To Definition**,
    and note that you can review the implementation of the auto-generated partial
    methods, as shown in *Figure 8.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The auto-generated source code for the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: Run the project and confirm that the functionality is the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can learn more about the improvements to regular expressions with .NET
    7 at the following link: [https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7](https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7).'
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple objects in collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another of the most common types of data is collections. If you need to store
    multiple values in a variable, then you can use a collection.
  prefs: []
  type: TYPE_NORMAL
- en: A collection is a data structure in memory that can manage multiple items in
    different ways, although all collections have some shared functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common types in .NET for working with collections are shown in *Table
    8.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Example types** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections` | `IEnumerable`,`IEnumerable<T>` | Interfaces and base
    classes used by collections. |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Generic` | `List<T>`,`Dictionary<T>`,`Queue<T>`,`Stack<T>`
    | Introduced in C# 2.0 with .NET Framework 2.0\. These collections allow you to
    specify the type you want to store using a generic type parameter (which is safer,
    faster, and more efficient). |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Concurrent` | `BlockingCollection`,`ConcurrentDictionary`,`ConcurrentQueue`
    | These collections are safe to use in multithreaded scenarios. |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Immutable` | `ImmutableArray`,`ImmutableDictionary`,`ImmutableList`,`ImmutableQueue`
    | Designed for scenarios where the contents of the original collection will never
    change, although they can create modified collections as a new instance. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.9: Common .NET collection types'
  prefs: []
  type: TYPE_NORMAL
- en: Common features of all collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections implement the `ICollection` interface; this means that they
    must have a `Count` property to tell you how many objects are in them, and three
    other members, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we had a collection named `passengers`, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you have probably surmised, `CopyTo` copies the collection to an array. `IsSynchronized`
    and `SyncRoot` are used in multithreading scenarios, so I do not cover them in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'All collections implement the `IEnumerable` interface, which means that they
    can be iterated using the `foreach` statement. They must have a `GetEnumerator`
    method that returns an object that implements `IEnumerator`; this means that the
    returned `object` must have `MoveNext` and `Reset` methods for navigating through
    the collection and a `Current` property containing the current item in the collection,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to perform an action on each object in the `passengers` collection,
    we could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the `object`-based collection interface, there is also a generic
    collection interface, where the generic type defines the type stored in the collection.
    It has additional members like `IsReadOnly`, `Add`, `Clear`, `Contains`, and `Remove`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Working with lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists, that is, a type that implements `IList<T>`, are **ordered collections**,
    with an `int` index to show the position of an item within the list, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `[DefaultMember]` attribute allows you to specify which member is accessed
    by default when no member name is specified. To make `IndexOf` the default member,
    you would use `[DefaultMember("IndexOf")]`. To specify the indexer, you use `[DefaultMember("Item")]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`IList<T>` derives from `ICollection<T>`, so it has a `Count` property, and
    an `Add` method to put an item at the end of the collection, as well as an `Insert`
    method to put an item in the list at a specified position, and `RemoveAt` to remove
    an item at a specified position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are a good choice when you want to manually control the order of items
    in a collection. Each item in a list has a unique index (or position) that is
    automatically assigned. Items can be any type defined by `T` and items can be
    duplicated. Indexes are `int` types and start from `0`, so the first item in a
    list is at index `0`, as shown in *Table 8.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Item** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Sydney |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.10: Cities in a list with indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a new item (for example, Santiago) is inserted between London and Sydney,
    then the index of Sydney is automatically incremented. Therefore, you must be
    aware that an item’s index can change after inserting or removing items, as shown
    in *Table 8.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Item** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Santiago |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Sydney |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.11: Cities list after an item is inserted'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Some developers can get into the poor habit of using `List<T>`
    and other collections when an array would be better. Use arrays instead of collections
    if the data will not change size after instantiation. You should also use lists
    initially while you are adding and removing items, but then convert them into
    an array once you are done with manipulating the items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithCollections` to the `Chapter08` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, define a partial `Program` class with a generic method
    to output a collection of `T` values with a title, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements and then add some statements
    to illustrate some of the common ways of defining and working with lists, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: LINQ has extension methods named `All()` and `Count()` that
    work like the `List<T>` class `TrueForAll()` method and `Count` property respectively.
    You will generally achieve better performance by using methods provided by a class
    rather than the more general LINQ methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dictionaries are a good choice when each **value** (or object) has a unique
    sub-value (or a made-up value) that can be used as a **key** to quickly find a
    value in the collection later. The key must be unique. For example, if you are
    storing a list of people, you could choose to use a government-issued identity
    number as the key. Dictionaries are called **hashmaps** in other languages like
    Python and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the key as being like an index entry in a real-world dictionary. It
    allows you to quickly find the definition of a word because the words (in other
    words, keys) are kept sorted; if we know we’re looking for the definition of *manatee*,
    we will jump to the middle of the dictionary to start looking, because the letter
    *m* is in the middle of the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries in programming are similarly smart when looking something up.
    They must implement the interface `IDictionary<TKey, TValue>`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Items in a dictionary are instances of the `struct`, aka the value type, `KeyValuePair<TKey,
    TValue>`, where `TKey` is the type of the key and `TValue` is the type of the
    value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'An example `Dictionary<string, Person>` uses a `string` as the key and a `Person`
    instance as the value. `Dictionary<string, string>` uses `string` values for both,
    as shown in *Table 8.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| BSA | Bob Smith |'
  prefs: []
  type: TYPE_TB
- en: '| MW | Max Williams |'
  prefs: []
  type: TYPE_TB
- en: '| BSB | Bob Smith |'
  prefs: []
  type: TYPE_TB
- en: '| AM | Amir Mohammed |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.12: Dictionary with keys and values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, define an alias for the `Dictionary<TKey, TValue>`
    class, where `TKey` and `TValue` are both `string`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add some statements to illustrate some of the common ways
    of working with dictionaries, for example, looking up word definitions, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The trailing commas after the third item is added to the dictionary are optional
    and the compiler will not complain about them. This is convenient so that you
    can change the order of the three items without having to delete and add commas
    in the right places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In *Chapter 11*, *Querying and Manipulating Data Using LINQ*, you will learn
    how to create dictionaries and lookups from existing data sources, like tables
    in a database, using LINQ methods, like `ToDictionary` and `ToLookup`. This is
    much more common than manually adding items to a dictionary, as shown in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Sets, stacks, and queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sets** are a good choice when you want to perform set operations between
    two collections. For example, you may have two collections of city names, and
    you want to know which names appear in both sets (known as the *intersect* between
    the sets). Items in a set must be unique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common set methods are shown in *Table 8.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Add` | If the item does not already exist in the set, then it is added.
    This returns `true` if the item was added, and `false` if it was already in the
    set. |'
  prefs: []
  type: TYPE_TB
- en: '| `ExceptWith` | This removes the items in the set passed as the parameter
    from the set. |'
  prefs: []
  type: TYPE_TB
- en: '| `IntersectWith` | This removes the items not in the set passed as the parameter
    and in the set. |'
  prefs: []
  type: TYPE_TB
- en: '| `IsProperSubsetOf`, `IsProperSupersetOf`, `IsSubsetOf`, `IsSupersetOf` |
    A subset is a set whose items are all in the other set. A proper subset is a set
    whose items are all in the other set but there is at least one item in the other
    set that is not in the set. A superset is a set that contains all the items in
    the other set. A proper superset is a set that contains all the items in the other
    set and at least one more not in the other set. |'
  prefs: []
  type: TYPE_TB
- en: '| `Overlaps` | The set and the other set share at least one common item. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetEquals` | The set and the other set contain exactly the same items. |'
  prefs: []
  type: TYPE_TB
- en: '| `SymmetricExceptWith` | This removes the items not in the set passed as the
    parameter from the set and adds any that are missing. |'
  prefs: []
  type: TYPE_TB
- en: '| `UnionWith` | This adds any items in the set passed as the parameter to the
    set that are not already in the set. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.13: Set methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore example code for sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add some statements to add items to a set, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see more set operations in *Chapter 11*, *Querying and Manipulating
    Data Using LINQ*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stacks** are a good choice when you want to implement **last-in, first-out**
    (**LIFO**) behavior. With a stack, you can only directly access or remove the
    one item at the top of the stack, although you can enumerate to read through the
    whole stack of items. You cannot, for example, directly access the second item
    in a stack.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, word processors use a stack to remember the sequence of actions
    you have recently performed, and then, when you press *Ctrl* + *Z*, it will undo
    the last action in the stack, and then the next-to-last action, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Queues** are a good choice when you want to implement **first-in, first-out**
    (**FIFO**) behavior. With a queue, you can only directly access or remove the
    item at the front of the queue, although you can enumerate to read through the
    whole queue of items. You cannot, for example, directly access the second item
    in a queue.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, background processes use a queue to process work items in the order
    that they arrive, just like people standing in line at the post office.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 6 introduced the `PriorityQueue`, where each item in the queue has a priority
    value assigned, as well as its position in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore example code for queues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add some statements to illustrate some of the common ways
    of working with queues, for example, handling customers in a queue for coffee,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Helpers.cs`, in the partial `Program` class, add a static method
    named `OutputPQ`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `OutputPQ` method is generic. You can specify the two types used
    in the tuples that are passed in as `collection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add some statements to illustrate some of the common ways
    of working with priority queues, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: .NET 9 introduced a `Remove` method to `PriorityQueue`. The method performs
    a linear-time scan through each element in the heap, removing the first occurrence
    that matches the specified element parameter. If there are duplicate entries,
    the method removes one of them in a non-deterministic manner, without considering
    any priority.
  prefs: []
  type: TYPE_NORMAL
- en: Collection add and remove methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each collection has a different set of methods to “add” and “remove” items,
    as shown in *Table 8.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Collection** | **“Add” methods** | **“Remove” methods** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `Add`, `Insert` | `Remove`, `RemoveAt` | Lists are ordered so items
    have an integer index position. `Add` will add a new item at the end of the list.
    `Insert` will add a new item at the index position specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `Dictionary` | `Add` | `Remove` | Dictionaries are not ordered so items do
    not have integer index positions. You can check if a key has been used by calling
    the `ContainsKey` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `Stack` | `Push` | `Pop` | Stacks always add a new item at the top of the
    stack using the `Push` method. The first item is at the bottom. Items are always
    removed from the top of the stack using the `Pop` method. Call the `Peek` method
    to see this value without removing it. Stacks are LIFO. |'
  prefs: []
  type: TYPE_TB
- en: '| `Queue` | `Enqueue` | `Dequeue` | Queues always add a new item at the end
    of the queue using the `Enqueue` method. The first item is at the front of the
    queue. Items are always removed from the front of the queue using the `Dequeue`
    method. Call the `Peek` method to see this value without removing it. Queues are
    FIFO. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.14: Collection “add” and “remove” methods'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `List<T>` class can be sorted by manually calling its `Sort` method (but remember
    that the indexes of each item will change). Manually sorting a list of `string`
    values or other built-in types will work without extra effort on your part, but
    if you create a collection of your own type, then that type must implement an
    interface named `IComparable`. You learned how to do this in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: A `Stack<T>` or `Queue<T>` collection cannot be sorted because you wouldn’t
    usually want that functionality; for example, you would probably never sort a
    queue of guests checking into a hotel. But sometimes, you might want to sort a
    dictionary or a set.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it would be useful to have an automatically sorted collection, that
    is, one that maintains the items in a sorted order as you add and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple auto-sorting collections to choose from. The differences
    between these sorted collections are often subtle but can have an impact on the
    memory requirements and performance of your application, so it is worth putting
    effort into picking the most appropriate option for your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Since the early days of .NET, the `OrderedDictionary` type has supported this,
    but it was non-generic, with keys and values typed as `System.Object`. .NET 9
    introduces the long-awaited `OrderedDictionary<TKey, TValue>` collection, offering
    an efficient and generic solution for these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other common auto-sorting collections are shown in *Table 8.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Collection** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedDictionary<TKey, TValue>` | This represents a collection of key-value
    pairs that are sorted by key. Internally, it maintains a binary tree for items.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedList<TKey, TValue>` | This represents a collection of key-value pairs
    that are sorted by key. The name is misleading because this is not a list. Compared
    to `SortedDictionary<TKey, TValue>`, retrieval performance is similar, it uses
    less memory, and insert and remove operations are slower for unsorted data. If
    it is populated from sorted data, then it is faster. Internally, it maintains
    a sorted array with a binary search to find elements. |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedSet<T>` | This represents a collection of unique objects that are
    maintained in a sorted order. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.15: Common auto-sorting collections'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few other collections for special situations.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Collections.BitArray` collection manages a compact array of bit
    values, which are represented as Booleans, where `true` indicates that the bit
    is on (value is 1) and `false` indicates that the bit is off (value is 0).
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Collections.Generics.LinkedList<T>` collection represents a doubly
    linked list where every item has a reference to its previous and next items. They
    provide better performance compared to `List<T>` for scenarios where you will
    frequently insert and remove items from the middle of the list. In a `LinkedList<T>`,
    the items do not have to be rearranged in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only, immutable, and frozen collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we looked at the generic collection interface, we saw that it has a property
    named `IsReadOnly`. This is useful when we want to pass a collection to a method
    but not allow it to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might define a method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Generic collections, like `List<T>` and `Dictionary<TKey, TValue>`, have an
    `AsReadOnly` method to create a `ReadOnlyCollection<T>` that references the original
    collection. Although the `ReadOnlyCollection<T>` has to have an `Add` and a `Remove`
    method because it implements `ICollection<T>`, it throws a `NotImplementedException`
    to prevent changes.
  prefs: []
  type: TYPE_NORMAL
- en: If the original collection has items added or removed, the `ReadOnlyCollection<T>`
    will see those changes. You can think of a `ReadOnlyCollection<T>` as a protected
    view of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can make sure a collection is read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithCollections` project, in `Program.Helpers.cs`, add a method
    that should only be given a read-only dictionary with `string` for the type of
    key and value, but the naughty method tries to call `Add`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the type of parameter is `IDictionary<TKey, TValue>`. Using an interface
    provides more flexibility because we can pass either a `Dictionary<TKey, TValue>`,
    a `ReadOnlyDictionary<TKey, TValue>`, or anything else that implements that interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to pass the `keywords` dictionary to this naughty
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the naughty method was able to
    add a new key-value pair, so the count has incremented, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the `UseDictionary` statement, and then add a
    statement to pass the dictionary converted into a read-only collection, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that this time, the method was not
    able to add an item, so the count is the same, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of `Program.cs`, import the `System.Collections.Immutable` namespace,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the `AsReadOnly` statement and then add a statement
    to pass the keywords converted into an immutable dictionary, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, view the result, and note that this time, the method was also
    not able to add a default value, so the count is the same – it is the same behavior
    as using a read-only collection, so what’s the point of immutable collections?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you import the `System.Collections.Immutable` namespace, then any collection
    that implements `IEnumerable<T>` is given six extension methods to convert it
    into an immutable collection, like a list, dictionary, set, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Although the immutable collection will have a method named `Add`, it does not
    add an item to the original immutable collection! Instead, it returns a new immutable
    collection with the new item in it. The original immutable collection still only
    has the original items in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to convert the keywords dictionary into an
    immutable dictionary, and then add a new keyword definition to it by randomly
    generating GUID values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the immutable keywords dictionary
    does not get modified when you call the `Add` method on it; instead, it returns
    a new dictionary with all the existing keywords plus the newly added keyword,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Newly added items will not always appear at the top of the dictionary, as shown
    in the output above. Internally, the order is defined by the hash of the key.
    This is why dictionaries are sometimes called hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: To improve performance, many applications store a shared
    copy of commonly accessed objects in a central cache. To safely allow multiple
    threads to work with those objects knowing they won’t change, you should make
    them immutable or use a concurrent collection type, which you can read about at
    the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent).'
  prefs: []
  type: TYPE_NORMAL
- en: The generic collections have some potential performance issues related to how
    they are designed.
  prefs: []
  type: TYPE_NORMAL
- en: First, being generic, the types of items or types used for keys and values for
    a dictionary have a big effect on performance, depending on what they are. Since
    they could be any type, the .NET team cannot optimize the algorithm. `string`
    and `int` types are the most used in real life. If the .NET team could rely on
    those always being the types used, then they could greatly improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Second, collections are dynamic, meaning that new items can be added, and existing
    items can be removed at any time. Even more optimizations could be made if the
    .NET team knew that no more changes would be made to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 8 introduced a new concept: frozen collections. Hmmm, we already have
    immutable collections, so what is different about frozen collections? Are they
    delicious like ice cream? The idea is that 95% of the time, a collection is populated
    and then never changed. So, if we could optimize them at the time of creation,
    then those optimizations could be made, adding some time and effort upfront, but
    then after that, performance for reading the collection could be greatly improved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET 8, there are only two frozen collections: `FrozenDictionary<TKey, TValue>`
    and `FrozenSet<T>`. More may come in future versions of .NET, but these are the
    two most common scenarios that would benefit from the frozen concept.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the `System.Collections.Frozen` namespace,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add statements to convert the keywords dictionary
    into a frozen dictionary, output its items, and then look up the definition of
    `long`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What the `Add` method does depends on the type, as summarized in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<T>`: This adds a new item to the end of the existing list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>`: This adds a new item to the existing dictionary
    in a position determined by its internal structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadOnlyCollection<T>`: This throws a not-supported exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImmutableList<T>`: This returns a new list with the new item in it. This does
    not affect the original list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImmutableDictionary<TKey, TValue>`: This returns a new dictionary with the
    new item in it. This does not affect the original dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrozenDictionary<TKey, TValue>`: This does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More information**: The documentation for frozen collections is found at
    the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen](https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen).'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen that you can create read-only lists and dictionaries, but what about
    sets? In .NET 9, there is now a `ReadOnlySet<T>` to address this.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing collections using collection expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced with C# 12 is a new consistent syntax for initializing arrays, collections,
    and span variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'With C# 11 and earlier, you would have to declare and initialize an array,
    collection, or span of `int` values using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with C# 12, you can now consistently use square brackets, and the
    compiler will do the right thing, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '**More information**: You can learn more about collection expressions at the
    following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Collection expressions do not work with all collections. For example, they
    do not work with dictionaries or multidimensional arrays. The documentation lists
    the types that a collection expression can be converted to: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#conversions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#conversions).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the spread element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **spread element** `..` can be prefixed before any expression that can be
    enumerated to evaluate it in a collection expression. For example, any type that
    can be enumerated using `foreach`, like an array or collection, can be evaluated
    using the spread element.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the spread element `..` in a collection expression replaces its argument
    with the elements from that collection. You can combine spread elements with individual
    elements in a collection expression.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft official documentation uses both the **spread element** and **spread
    operator** to refer to the same language feature. I prefer the element because
    it is used in collection expressions to represent an element within the defined
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of using the spread element, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '**More information**: You can learn more about the spread element at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions#spread-element](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions#spread-element).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Be careful not to confuse the spread element `..` that must be
    applied before an enumerable expression, with the range operator `..` that is
    used to define a `Range`. You will learn about ranges in the next major section
    in this chapter, *Working with spans, indexes, and ranges*. There is a discussion
    about the design decision around the spread element at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#drawbacks](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions#drawbacks).'
  prefs: []
  type: TYPE_NORMAL
- en: Good practice with collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s end this section about collections by reviewing some good practices that
    you should follow when working with collections.
  prefs: []
  type: TYPE_NORMAL
- en: Presizing collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since .NET 1.1, types like `StringBuilder` have had a method named `EnsureCapacity`
    that can presize its internal storage array to the expected final size of the
    `string`. This improves performance because it does not have to repeatedly increment
    the size of the array as more characters are appended.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Core 2.1, types like `Dictionary<T>` and `HashSet<T>` have also had
    `EnsureCapacity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET 6 and later, collections like `List<T>`, `Queue<T>`, and `Stack<T>`
    now have an `EnsureCapacity` method too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Passing collections to methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say you need to create a method to process a collection. For maximum
    flexibility, you could declare the input parameter to be `IEnumerable<T>` and
    make the method generic, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: I could pass an array, a list, a queue, or a stack, containing any type, like
    `int`, `string`, `Person`, or anything else that implements `IEnumerable<T>`,
    into this method and it will process the items. However, the flexibility to pass
    any collection to this method comes at a performance cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the performance problems with `IEnumerable<T>` is also one of its benefits:
    deferred execution, also known as lazy loading. Types that implement this interface
    do not have to implement deferred execution, but many do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the worst performance problem with `IEnumerable<T>` is that the iteration
    must allocate an object on the heap. To avoid this memory allocation, you should
    define your method using a concrete type, as shown highlighted in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This will use the `List<T>.Enumerator GetEnumerator()` method, which returns
    a `struct`, instead of the `IEnumerator<T> GetEnumerator()` method, which returns
    a reference type. Your code will be two to three times faster and require less
    memory. As with all recommendations related to performance, you should confirm
    the benefit by running performance tests on your actual code in a product environment.
  prefs: []
  type: TYPE_NORMAL
- en: Returning collections from members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Collections are reference types, which means they can be `null`. You might
    define methods or properties that return `null`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This can cause issues if a developer calls your methods and properties that
    return a collection without checking for `null`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'In your implementations of methods and properties that return collections,
    return an empty collection or array instead of `null`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Working with spans, indexes, and ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Microsoft’s goals with .NET Core 2.1 was to improve performance and resource
    usage. A key .NET feature that enables this is the `Span<T>` type.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory efficiently using spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When manipulating arrays, you will often create new copies or subsets of existing
    ones so that you can process just the subset. This is not efficient because duplicate
    objects must be created in memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to work with a subset of an array, use a **span** because it is
    like a window into the original array. This is more efficient in terms of memory
    usage and improves performance. Spans only work with arrays, not collections,
    because the memory must be contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at spans in more detail, we need to understand some related
    objects: indexes and ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying positions with the Index type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# 8 introduced two features for identifying an item’s index position within
    an array and a range of items using two indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned in the previous section that objects in a list can be accessed
    by passing an integer into their indexer, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Index` value type is a more formal way of identifying a position, and
    supports counting from the end, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Identifying ranges with the Range type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Range` value type uses `Index` values to indicate the start and end of
    its range, using its constructor, C# syntax, or its static methods, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods have been added to `string` values (which internally use an
    array of `char`), `int` arrays, and spans to make ranges easier to work with.
    These extension methods accept a range as a parameter and return a `Span<T>`.
    This makes them very memory-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** The range operator `..` (introduced with C# 8) and the spread
    element `..` (introduced with C# 12) look identical. Be careful to differentiate
    them when reading code. The range operator should always appear next to an integer,
    either before, after, or both. The spread element should always appear before
    a named variable that is enumerable.'
  prefs: []
  type: TYPE_NORMAL
- en: Using indexes, ranges, and spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore using indexes and ranges to return spans:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithRanges` to the `Chapter08` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    compare using the `string` type’s `Substring` method with ranges to extract parts
    of someone’s name, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using spans for efficient text handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common problems with working with text is that copies of `string`
    values are often allocated in memory during processing. It would be more efficient
    to reuse the original values when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Spans enable this by creating data structures that point to the original parts
    of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a `string` value containing integers separated by addition
    symbols that need to be summed up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With .NET 9 and later, we can now create a span over the `string` value, and
    then use ranges to efficiently divide the integer values and pass them to the
    `int.Parse` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If you set a breakpoint in the loop, then note the range object named `r` is
    first `[0..2]`, as shown in *Figure 8.6*, then `{3..5}`, and finally `{6..9}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: A span and range used to split a string efficiently'
  prefs: []
  type: TYPE_NORMAL
- en: The range values efficiently define windows into the original string without
    allocating new memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring, with deeper research into the topics in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.1 – online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material could be created by Microsoft or third parties, or extra content
    for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Working with network resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are interested in some low-level types for working with network resources,
    then you can read an online-only section found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch08-network-resources.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch08-network-resources.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a useful online book about networking with .NET by Chris Woodruff
    called *Beyond Boundaries – Networking Programming with C# 12 and .NET 8*, which
    you can find at the following link: [https://csharp-networking.com](https://csharp-networking.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Collection expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about how to refactor existing code to make the most of
    collection expressions at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/refactor-your-code-with-collection-expressions/](https://devblogs.microsoft.com/dotnet/refactor-your-code-with-collection-expressions/)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.2 – practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `Chapter08` solution, create a console app named `Exercise_RegularExpressions`
    that prompts the user to enter a regular expression and then prompts the user
    to enter some input, and compare the two for a match until the user presses *Esc*,
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `Chapter08` solution, create a class library named `Exercise_NumbersAsWordsLib`
    and projects to test it. It should define extension methods that extend number
    types such as `BigInteger` and `int` with a method named `ToWords` that returns
    a `string` describing the number.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `18,000,000` would be eighteen million, and `18,456,002,032,011,000,007`
    would be eighteen quintillion, four hundred and fifty-six quadrillion, two trillion,
    thirty-two billion, eleven million, and seven.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about names for large numbers at the following link: [https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: Create projects to test your class library using xUnit and as an interactive
    console app.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.3 – test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the web to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the maximum number of characters that can be stored in a `string` variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why should you use a `SecureString` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it appropriate to use a `StringBuilder` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `LinkedList<T>` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `SortedDictionary<T>` class rather than a `SortedList<T>`
    class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, what does `$` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, how can you represent digits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you *not* use the official standard for email addresses to create
    a regular expression to validate a user’s email address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What characters are output when the following code runs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How could you check that a web service is available before calling it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 8.4 – explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following link to learn more details about the topics covered in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-8---working-with-common-net-types)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you explored:'
  prefs: []
  type: TYPE_NORMAL
- en: Choices for types to store and manipulate numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling text, including using regular expressions for validating input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections to use for storing multiple items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with indexes, ranges, and spans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will manage files and streams, encode and decode text,
    and perform serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharp13dotnet9](https://packt.link/csharp13dotnet9)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code281224304227278796.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  Description automatically generated](img/review1.png)'
  prefs: []
  type: TYPE_IMG
