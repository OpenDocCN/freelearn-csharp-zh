<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. API</h1></div></div></div><p>So far, we've only looked at the graphical tools to interact with <span class="strong"><strong>Windows Azure BizTalk Services</strong></span> (<span class="strong"><strong>WABS</strong></span>)<a id="id366" class="indexterm"/>. These have included Visual Studio for creating and deploying solutions as well as the BizTalk Services Portal (and Azure Management Portal) for management and monitoring of the deployed solutions. Underlying all these tools though is a REST-based API that allows easy integration with scripting tools as well as your own processes to facilitate automated actions such as deployment, testing, and management.</p><p>In this chapter, we'll look at the WABS API and how to interact with it using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RESTful web services</li><li class="listitem" style="list-style-type: disc">PowerShell</li><li class="listitem" style="list-style-type: disc">Custom code</li></ul></div><p>While there are three methods in which the API can be used (portal, REST services, and PowerShell), each serves a different need, and although there is an overlap, there are also differences in functionality. The portal has been explored elsewhere in this book and provides an easy-to-access dashboard for system administrators. PowerShell is a familiar tool for IT pros that is useful for scripting system interactions such as deployments. Using the REST API directly is useful for building your own tools and capabilities on top of WABS or for interacting with WABS from another application. By the end of this chapter, you'll have a good understanding of the WABS API and how you can leverage it to your advantage in your own organization.</p><div class="section" title="REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>REST</h1></div></div></div><p>First, let's<a id="id367" class="indexterm"/> take a quick look at the grounding of the provided API. All functions available in Visual Studio and in the management portal are also available in the API. In fact, the API actually provides more capabilities than these tools do, as we'll see. This shouldn't be too much of a surprise as it is often the case—the API usually comes first and the tools later. It's therefore a good idea to understand what the API can do. Underpinning this API is a set of web services accessible using HTTP. WABS uses RESTful services for this. REST is not a standard or protocol, but an architectural style that enables simple HTTP-based integration. It doesn't need the overhead of SOAP or frameworks such as Microsoft's WCF. In fact, you can often use just your web browser to make requests or query for information. REST is based on a set of standard HTTP verbs that specify the type of request. WABS uses the following HTTP verbs in its API:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Verb</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>PUT</p>
</td><td style="text-align: left" valign="top">
<p>Create a new artifact or update an existing one</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GET</p>
</td><td style="text-align: left" valign="top">
<p>Retrieve artifact(s)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>DELETE</p>
</td><td style="text-align: left" valign="top">
<p>Remove an artifact from WABS</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>POST</p>
</td><td style="text-align: left" valign="top">
<p>Update an artifact or service status</p>
</td></tr></tbody></table></div><p>WABS REST API verbs</p><p>As you<a id="id368" class="indexterm"/> can see, the full set of CRUD (create, read, update, and delete) operations are supported in this way, which provides a great deal of flexibility as it facilitates cross-platform access and easy integration with third-party tools.</p></div></div>
<div class="section" title="Calling the API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Calling the API</h1></div></div></div><p>Let's start by<a id="id369" class="indexterm"/> looking at a simple REST call to the BizTalk Services API. In this example, we'll query the BizTalk Services instances deployed for a given Azure subscription. We are going to see how you can execute this request using a very useful tool <a id="id370" class="indexterm"/>called Fiddler. You can download Fiddler for free from <a class="ulink" href="http://fiddler2.com/">http://fiddler2.com/</a>.</p><p>In order to execute these API calls against Azure, a mutual certificate exchange process is required in order for each party to authenticate one another. When your machine makes a request to the Windows Azure management endpoint, Azure returns the configured certificate and in return your client machine sends Azure its certificate to validate. Once complete, Azure executes the request and returns an acknowledgement. In order for this to work, we first need to create a client certificate and then upload it to Azure.</p><p>There are two options here. You can use a certificate you create yourself, which is known as a self-signed certificate. Such a certificate is useful for testing but would not be appropriate for the production usage. In this case, you would purchase a certificate from a signing authority and use that. The reason for this is that certificates are about trust, not just between the two parties (your machine/organization and Azure), but with the signing authority as well. When a party receives a certificate, it can check its validity with the signing authority. This also allows, for example, the ability for a signing authority to revoke a certificate if it has been compromised.</p><p>For our purposes though, a self-signed certificate will do just fine. To create a certificate, open a command prompt and enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>makecert -sky exchange -r -n "CN=wabstest" -pe -a sha1 -len 2048 -ss </strong></span>
<span class="strong"><strong>My "%HOMEPATH%\documents\wabstest.cer"</strong></span>
</pre></div><p>This command will create a self-signed certificate and install it in your machine's certificate store under your logged on account. With this done, we need to associate it with our Azure subscription where we have provisioned BizTalk Services:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open<a id="id371" class="indexterm"/> the Windows Azure Management Portal at <a class="ulink" href="http://manage.windowsazure.com">http://manage.windowsazure.com</a>.</li><li class="listitem">In the<a id="id372" class="indexterm"/> left-hand margin, click on <span class="strong"><strong>Settings</strong></span> (it's the last one in the list).</li><li class="listitem">Under <span class="strong"><strong>Settings</strong></span>, click on the <span class="strong"><strong>Management Certificates</strong></span> tab and then click on <span class="strong"><strong>Upload</strong></span>.</li><li class="listitem">Browse to the certificate file you created in the command window earlier—it will be located by default under <code class="literal">c:\users\&lt;youraccount&gt;\documents</code>.</li><li class="listitem">Click on the tick button to associate your certificate with the management service.<div class="mediaobject"><img src="graphics/7401EN_06_01.jpg" alt="Calling the API"/><div class="caption"><p>Upload management certificate</p></div></div></li></ol></div><p>Now that we've done this, we can make a call using the Request Composer feature of Fiddler to query the WABS services deployment. To set up the certificate in Fiddler, we need to perform a few steps first before making the request:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open Fiddler.</li><li class="listitem">On the <span class="strong"><strong>Rules</strong></span> menu, select <span class="strong"><strong>Customize Rules…</strong></span>.</li><li class="listitem">In the <code class="literal">CustomRules.js</code> file, which opens in<a id="id373" class="indexterm"/> Notepad, find the <code class="literal">OnBeforeRequest</code> function.</li><li class="listitem">Add the following at the top of this function, replacing <code class="literal">&lt;username&gt;</code> with your username:<div class="informalexample"><pre class="programlisting">if (oSession.HostnameIs("management.core.windows.net")) {
   oSession["https-Client-Certificate"] = "C:\\Users\\&lt;username&gt;\\Documents\\wabstest.cer";
}</pre></div></li><li class="listitem">Save the file and close Notepad.</li></ol></div><p>What this will do<a id="id374" class="indexterm"/> is send the client certificate to the service whenever the Azure management URL is accessed. For the next step, you will need your Azure subscription ID. To get this, go back to the Azure Management Portal, and under <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Subscriptions</strong></span>, you will see a list of your subscriptions in the <span class="strong"><strong>Subscription</strong></span> column and the required subscription IDs in the <span class="strong"><strong>SubscriptionID</strong></span> column, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7401EN_06_02.jpg" alt="Calling the API"/><div class="caption"><p>Obtaining the subscription ID</p></div></div><p>Now, we can make the request as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on the <span class="strong"><strong>Composer</strong></span> tab.</li><li class="listitem">Ensure the verb next to the URL is set to <span class="strong"><strong>GET</strong></span>.</li><li class="listitem">Enter the following URL in the box, replacing <code class="literal">&lt;SubscriptionID&gt;</code> with your own:<p><code class="literal">https://management.core.windows.net/&lt;SubscriptionID&gt;/cloudservices</code></p></li><li class="listitem">Add the<a id="id375" class="indexterm"/> header provided here in the <span class="strong"><strong>Request Headers</strong></span> area:<p><code class="literal">x-ms-version:2010-10-28</code></p><p>This HTTP header specifies the service version we want and is mandatory. Currently, there is only one version, but over time the service may change, and this will allow you to call a particular version of it.</p><p>Your Fiddler request should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/7401EN_06_03.jpg" alt="Calling the API"/><div class="caption"><p>Retrieving a list of cloud services</p></div></div></li><li class="listitem">Click <a id="id376" class="indexterm"/>on the <span class="strong"><strong>Execute</strong></span> button.</li></ol></div><p>If all went as planned, you should now see the results of the call in the Fiddler window as shown in the following screenshot. What you are looking at is a list, in XML format, of all the BizTalk Services instances provisioned for the subscription you passed in as the argument. If you were to call this API programmatically, you could read through the XML and pull out particular properties for each instance and perhaps stop or restart them all. I've blurred out the subscription IDs and other details for obvious reasons.</p><p> </p><div class="mediaobject"><img src="graphics/7401EN_06_04.jpg" alt="Calling the API"/><div class="caption"><p>Retrieving a list of cloud services</p></div></div><p>With the <a id="id377" class="indexterm"/>results of this call, we can now retrieve the details of a single WABS instance with the following URL. Here, the cloud service name returned by the previous call is passed into the Get Cloud Service call:</p><p><code class="literal">https://management.core.windows.net/&lt;SubscriptionID&gt;/cloudservices/&lt;CloudServiceName&gt;</code></p><p>The request and response are shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7401EN_06_05.jpg" alt="Calling the API"/><div class="caption"><p>Retrieving a single BizTalk Services instance</p></div></div></div>
<div class="section" title="Back up and restore"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Back up and restore</h1></div></div></div><p>Now that we've<a id="id378" class="indexterm"/> looked at a simple example of what the WABS <a id="id379" class="indexterm"/>API can do, let's look at some of the more interesting capabilities. An essential aspect of enterprise development is the ability to move artifacts between environments. Commonly, an organization or team will have a development, testing, user acceptance, and production environment (and multiple instances of each). This DTAP (dev, test, user, and prod) setup is perfectly possible with BizTalk Services by creating multiple service instances and provisioning them as required. Then, each can be used as desired to manage the overall integration estate.</p><p>Backing up a BizTalk Services instance is not just useful to move content between environments, but can also be used to keep a set of backups or snapshots of a particular environment for disaster recovery or to restore to a particular point in time. It is also possible to restore an instance to a different version of the service, provided that the service type is at least the same or higher. For example, a Basic subscription can be restored to not just another Basic sub, but to Standard or Premium as well. Downgrading however, is not possible, and nor is backing up a Developer instance of the service.</p><p>This feature <a id="id380" class="indexterm"/>now has (as of the February 2014 service update) out <a id="id381" class="indexterm"/>of the box tooling via the Windows Azure Management Portal as shown in the following screenshot in the <span class="strong"><strong>CONFIGURE</strong></span> tab. While the portal UI now allows you to back up a service instance and even create a new BizTalk Services instance from a backup, using the API programmatically is very useful. The API provides the ability to move or "promote" a set of artifacts from one instance (say Test) to another (for example, User Acceptance) programmatically. In this section, we'll look at how to achieve this capability with the REST API by writing some .NET code to do it. As you'll see, this is very easy and straightforward to perform.</p><div class="mediaobject"><img src="graphics/7401EN_06_06.jpg" alt="Back up and restore"/><div class="caption"><p>Back up BizTalk Service Instance with the Management Portal</p></div></div><p>Before trying this out, I should point out that this capability provides a similar copy of the service instance. It's quite possible (even likely) that some of your settings or configuration is environment specific. For example, if your bridges send messages to Service Bus queues, it is unlikely that you would use the same queues for test as production. Therefore, while being able to back up one environment and restore to another is certainly very useful, you also need to think about using the REST API to apply configuration changes on top of a restored service instance.</p><p>Open Visual Studio and create a new console application. Call it <code class="literal">BackupService</code>. In the static <code class="literal">Main</code> method<a id="id382" class="indexterm"/>, add the following code to replace the empty <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void Main()
  {
    Task t = new Task(Run);
    t.Start();
    Console.ReadLine();
  }</pre></div><p>Now add the <code class="literal">Run</code> method<a id="id383" class="indexterm"/> as shown in the next code snippet. This code formats the required URL<a id="id384" class="indexterm"/> to make the backup API call. For this, three<a id="id385" class="indexterm"/> pieces of information are required.</p><p>Firstly, you'll need your Windows Azure subscription ID; this is the same ID as discussed earlier, and you can obtain it as before through the Windows Azure portal in the <span class="emphasis"><em>Upload management certificate</em></span> screenshot in the <span class="emphasis"><em>Calling the API</em></span> section. You'll also need the service name. This is the value in the <span class="strong"><strong>Name</strong></span> field as shown previously, and you can obtain yours by making that API call in Fiddler as we saw. The final piece of data you need is the resource name of the BizTalk Services instance. This is the name you gave your WABS instance when you created it. It can be obtained either through the Azure portal, by clicking the BizTalk Services link, or again by using Fiddler as shown in the previous screenshot. The name you need is under the <span class="strong"><strong>Resources</strong></span>/<span class="strong"><strong>Resource</strong></span>/<span class="strong"><strong>Name</strong></span> element. Replace the three placeholders in the code with your service values as shown in the following code:</p><div class="informalexample"><pre class="programlisting">static void Run()
{
  string subscriptionId = "&lt;SubscriptionID&gt;";
  string operationName = "cloudservices";
  string serviceName = "&lt;servicename&gt;";
  string resourceName = "&lt;resourcename&gt;";
  Uri requestUri = new Uri("https://management.core.windows.net/"
                                    + subscriptionId
                                    + "/cloudservices/"+ serviceName
                                    + "/resources/biztalkservices/~/biztalk/"
                                    + resourceName
                                    + "/?comp=backup");
MakeRequest(requestUri);
}</pre></div><p>Now, add the following two assembly references that contain the necessary types to make the request to the service endpoint:</p><div class="informalexample"><pre class="programlisting">System.Net.Http
System.net.Http.Request</pre></div><p>Add the following method directly underneath the previously added code. This will set up the call to the Backup REST API, and to do this, it needs your certificate. As discussed earlier, the management API calls authenticate services using mutual certificates, and therefore we<a id="id386" class="indexterm"/> need to pass our certificate. However, as the rule<a id="id387" class="indexterm"/> that we added to Fiddler earlier sends the client certificate with each request made to the management URL, we don't need to send the certificate in the code—you just need to ensure that Fiddler is still running (the code is provided to add the certificate later if you want to run it without Fiddler). This simplifies things quite a bit.</p><div class="informalexample"><pre class="programlisting">static async void MakeRequest(Uri requestUri) {
   string payload =
"{\"BackupName\":\"&lt;backupname&gt;\",\"BackupStoreConnectionString\":\"AccountName=&lt;storageaccountname&gt;;AccountKey=&lt;storageaccountkey&gt;;DefaultEndpointsProtocol=https\"}";
        
   HttpContent content = new StringContent(payload);
   content.Headers.ContentType.MediaType = "application/json";
   content.Headers.Add("x-ms-version", "2010-10-28");
   using (var client = new HttpClient())
   {
      var response = await client.PostAsync(requestUri, content);
      response.EnsureSuccessStatusCode();
      Console.WriteLine("Backup started");
   }
}</pre></div><p>You need to replace the <code class="literal">&lt;storageaccountname&gt;</code> and <code class="literal">&lt;storageaccountkey&gt;</code> values in the preceding code with your own storage account details. To obtain your <code class="literal">AccountName</code> and <code class="literal">AccountKey</code> values, do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the Azure Management Portal.</li><li class="listitem">Click on the Storage icon in the left-hand navigation bar.</li><li class="listitem">In the list of storage accounts, select the one that has the same name as the one created by your BizTalk Services instance.</li><li class="listitem">Click<a id="id388" class="indexterm"/> on the <span class="strong"><strong>Manage Access Keys</strong></span> button at the bottom of the page.</li><li class="listitem">Copy and paste the <span class="strong"><strong>Storage Account Name</strong></span> and <span class="strong"><strong>Primary Access Key</strong></span> fields into the preceding code.</li></ol></div><p>You can actually use any storage account you like in step 3, or even create a new one. The account is used to store the backed-up WABS instance. The third placeholder in the code is <code class="literal">&lt;backupname&gt;</code>. This is the label to use for backup, and it is good practice to name this something meaningful, such as with the date the backup was made. The label you use must start with a letter or a digit, can only contain digits, dashes (-), or lowercase letters, and can be between 3 and 63 characters long. Dashes must not be consecutive.</p><p>The format of the data posted to the service is <span class="strong"><strong>JSON</strong></span> (<span class="strong"><strong>JavaScript Object Notation</strong></span>), and this is simply<a id="id389" class="indexterm"/> a string containing the storage account details and backup name. The PostAsync call will invoke the API and wait for a response. If successful, the service will return an OK response HTTP code 200. This API is asynchronous because the service backup can take up to an hour to complete. In response, we get a tracking identifier that allows you to check the status of the backup operation. The API provides a polling query for this that allows you to make a call passing your returned identifier (a GUID) and retrieve the results of the operation at any point. In this way, you can ensure that the backup was successfully completed.</p><p>Now that the <a id="id390" class="indexterm"/>code is complete, hit <span class="emphasis"><em>F5</em></span> to build and run it. If <a id="id391" class="indexterm"/>successful, the console application should just open and close down a few seconds later. You might want to put a couple of breakpoints in the code and run it to see if it's working. I've also omitted any exception handling code for brevity. If it fails to call the API, an exception will be thrown. In such a case, run the debugger so you can determine what the problem is.</p><p>Of course, there is also a reciprocal Restore API call that allows you to restore a previously backed up instance to any other BizTalk Service instance.</p><p>As I mentioned previously, you need to keep Fiddler running for this example as Fiddler is supplying the necessary certificate. If you want to run without Fiddler, just add the following code <a id="id392" class="indexterm"/>at the start of the <code class="literal">MakeRequest</code> method, replacing the <code class="literal">&lt;your thumbprint&gt;</code> placeholder with your own certificate's thumbprint as displayed in the Azure Management Portal:</p><div class="informalexample"><pre class="programlisting">var certHandler = new WebRequestHandler();
string certThumbprint = "&lt;your thumbprint&gt;";
X509Store certStore = new X509Store(StoreName.My,     
                                    StoreLocation.CurrentUser);
certStore.Open(OpenFlags.ReadOnly);
X509Certificate2Collection certCollection = certStore.Certificates.Find(X509FindType.FindByThumbprint, certThumbprint, false);
certStore.Close();
X509Certificate2 certificate = certCollection[0];
certHandler.ClientCertificates.Add(certificate);You also need to change the using statement as shown below to pass in the certificate from:
using (var client = new HttpClient())
To:
using (var client = new HttpClient(certHandler))</pre></div><p>The preceding code retrieves your certificate from your local machine's certificate store. You therefore need to ensure it is stored already. To do this, double-click on your certificate, and in the wizard that appears, do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Accept any security warnings first.</li><li class="listitem">Click on the <span class="strong"><strong>Install Certificate</strong></span> button.</li><li class="listitem">For the <span class="strong"><strong>Store Location</strong></span> option, select <span class="strong"><strong>Local Machine</strong></span>.</li><li class="listitem">Accept any warning that appears.</li><li class="listitem">Select <span class="strong"><strong>Place all certificates in the following store</strong></span>.</li><li class="listitem">Click on the <span class="strong"><strong>Browse</strong></span> button.</li><li class="listitem">Select <span class="strong"><strong>Personal</strong></span> and click on <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> and then <span class="strong"><strong>Finish</strong></span>.</li><li class="listitem">You<a id="id393" class="indexterm"/> should see a message confirming successful<a id="id394" class="indexterm"/> installation.</li><li class="listitem">Close the dialog.</li></ol></div></div>
<div class="section" title="Using PowerShell"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Using PowerShell</h1></div></div></div><p>So far, <a id="id395" class="indexterm"/>we've seen two different ways to utilize the API provided by BizTalk Services, directly making HTTP requests in Fiddler and by writing code to make the calls to it programmatically. Now we'll look at an even easier way, using Windows PowerShell. Windows PowerShell is a command-line tool aimed at administrators that provides a consistent way to perform tasks across many Microsoft products (and third-party ones). With PowerShell, it is possible to automate common actions and create sophisticated scripts that perform configuration and administration of BizTalk Services environments and Azure in general.</p><p>BizTalk Services provides a set of PowerShell cmdlets that can call the complete set of APIs provided. Cmdlets are units of functionality that are executed in PowerShell, and BizTalk Services provides a cmdlet for each API call available.</p><p>To be absolutely correct, BizTalk Services actually provides two sets of cmdlets. The first is installed when you download and install the BizTalk Services SDK while the second needs to be downloaded. The first allows control over the artifacts in a provisioned BizTalk Services instance while the second allows control over BizTalk Services as a whole—including creating new BizTalk Services instances. As the second set is associated with the APIs we've already been looking at, we'll start there. This second set is provided as source code and can be downloaded from the following link:</p><p><a class="ulink" href="http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-91e1bdf3">http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-91e1bdf3</a></p><p>As it is the source code, it needs to be opened and compiled in Visual Studio. We should also note that this is a sample and not officially supported code from Microsoft. Once the source code is built, open PowerShell on Windows 8/Server 2012 by clicking on the Start button and typing <code class="literal">PowerShell</code> (on Windows 8 or 2012). You should see Windows Azure PowerShell appear in the list of results. Click on it to launch it. If you don't see Windows <a id="id396" class="indexterm"/>Azure PowerShell, make sure you have installed it and you have at least Version 0.6.19 installed.</p><p>In the PowerShell command window, enter the following command to load the cmdlets:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import-module &lt;pathtosource&gt;/Microsoft.WindowsAzure.Management.BizTalkService.dll</strong></span>
</pre></div><p>In order to use the cmdlets, the subscription context must first be set. Do this by entering the following code in the command window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$sub = '&lt;subscription ID&gt;'</strong></span>
<span class="strong"><strong>$thumbprint = '&lt;certificate thumbprint&gt;'</strong></span>
<span class="strong"><strong>$cert = Get-Item cert:\\LocalMachine\My\$thumbprint</strong></span>
<span class="strong"><strong>Set-AzureSubscription -SubscriptionName "Test" -SubscriptionId $sub -Certificate $cert</strong></span>
<span class="strong"><strong>select-azuresubscription –SubscriptionName "Test"</strong></span>
</pre></div><p>You should now know how to obtain the value for <code class="literal">&lt;subscription ID&gt;</code> that needs to be substituted. For <code class="literal">&lt;certificate thumbprint&gt;</code>, if you followed the steps earlier to generate and upload a certificate, you need to replace this value with the thumbprint of your own certificate. To find this, go to the Azure portal and click on <span class="strong"><strong>Settings</strong></span> in the left-hand navigation bar. On the Settings page, click on <span class="strong"><strong>Management Certificates</strong></span> and then cut and paste the value for the thumbprint column for the certificate you uploaded earlier.</p><p>I've used the value of <code class="literal">Test</code> in the previous code to name the subscription. This can be any label you like. It is only used to name the subscription during the PowerShell session. Now, as soon as this is done, all cmdlets will be executed in the context of the particular subscription.</p><p>As an example of how to use the cmdlets, let's look at one of the API calls we made earlier. In the command window, type the following command, substituting the name of your BizTalk Service instance for <code class="literal">&lt;service name&gt;</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Get-AzureBizTalkService -resourcename &lt;service name&gt;</strong></span>
</pre></div><p>You should see a response in the command window similar to the one in the following screenshot:</p><div class="mediaobject"><img src="graphics/7401EN_06_07.jpg" alt="Using PowerShell"/><div class="caption"><p>Get BizTalk Service cmdlet</p></div></div><p>Using the<a id="id397" class="indexterm"/> API doesn't stop at just being able to query the service. We can also create a brand new BizTalk Services instance or delete an existing one. It is also possible to suspend or resume a particular service instance if required. To create a new instance, the <code class="literal">New-AzureBizTalkService</code> cmdlet is provided. This takes the following form:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>New-AzureBizTalkService -ResourceName MyNewBizTalk -Location "West Europe" –ConfigurationFile "c: \ create_new.xml"</strong></span>
</pre></div><p>Apart from the name of the instance and what data center to create it in, the main parameter is actually a file. The download for the source code actually contains a couple of example files that you can adapt for this purpose. The file you provide contains all the details that you would normally specify when creating a new service via the Azure portal; for example, the database to use, the certificate to protect the service with, the type of service—developer, premium, among others—and the ACS settings. Given what you know after reading this book, you should find editing the provided sample files with your settings quite straightforward. Once done, you can automate the creation of services to your heart's content!</p><p>OK, so far we've covered the management aspects of the BizTalk Services API. But as mentioned earlier, there is also another set of PowerShell cmdlets that are used to manipulate artifacts and settings in a BizTalk Services instance. This set of cmdlets is already installed if you have the BizTalk Services SDK installed, which by default is located under <code class="literal">C:\Program Files\Windows Azure BizTalk Services Tools</code>.</p><p>To load the cmdlets, type the following command in the PowerShell window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import-module "C:\Program Files\Windows Azure BizTalk Services Tools\Microsoft.BizTalk.Services.Powershell.dll"</strong></span>
</pre></div><p>This PowerShell <a id="id398" class="indexterm"/>module provides features that are not available in the UI of BizTalk Services via the portal. One example is the ability to start and stop a bridge. When a new bridge is deployed, it is active by default, but there are times when you may wish to stop a bridge from receiving messages. This can be achieved with the <code class="literal">Stop-AzureBizTalkBridgeSource</code> cmdlet as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Stop-AzureBizTalkBridgeSource –AcsNamespace &lt;namespace&gt; –IssuerName owner –IssuerKey &lt;key&gt; –BridgePath MyBridge</strong></span>
</pre></div><p>This will stop all sources available on the bridge <code class="literal">MyBridge</code>, but it's also possible to stop a particular source<a id="id399" class="indexterm"/> by providing the <code class="literal">SourceName</code> parameter. This is very useful when you need to perform maintenance that requires some or all of the sources to be temporarily stopped. To restart a bridge/source, the corresponding <code class="literal">Start-AzureBizTalkBridgeSource</code> cmdlet is used with the same parameters.</p><p>The remaining cmdlets concern adding and removing artifacts such as bridges, schemas, certificates, and assemblies to a BizTalk Service. Visual Studio uses these API calls during deployment and their primary usage outside of this is to automate and manage deployments. For the full <a id="id400" class="indexterm"/>list of cmdlets, visit <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windowsazure/dn232360.aspx">http://msdn.microsoft.com/en-us/library/windowsazure/dn232360.aspx</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we have looked at the API underpinning BizTalk Services. We've seen how to leverage the API from the humble web browser and how to use PowerShell cmdlets and write our own code to invoke it. We've looked at the different types of APIs, capabilities, and the cmdlets that wrap all of them, and hopefully you've seen how you can make use of the capabilities of the BizTalk Services API to create, manage, maintain, and more importantly, automate your BizTalk Services instances. In the next chapter, we will look at troubleshooting your integration solutions and how to use the tracking capabilities of WABS.</p></div></body></html>