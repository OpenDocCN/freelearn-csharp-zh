<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Game Mechanics</h1>
                
            
            <article>
                
<p class="calibre3">In <a target="_blank" href="part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79" class="calibre10">Chapter 3</a>, <em class="calibre14">RPG Character Design,</em> we covered a wide range of topics to prepare your character model for the game. We looked at how to import and set up our character model, created the <kbd class="calibre13">BaseCharacter</kbd> class, used the Animator Controller to set up the state diagram, created the initial character controller to handle the motion and behavior of our character model, and finally, looked at some basic inverse kinematics for the foot.</p>
<p class="calibre3">In this chapter, we will expand on the character player and also the non-character player, covering the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Customizing the player character:
<ul class="calibre32">
<li class="calibre12">Customizable parts (model)</li>
<li class="calibre12">C# code for customization</li>
<li class="calibre12">Preserving character state</li>
<li class="calibre12">Recap</li>
</ul>
</li>
<li class="calibre12">Non-player characters:
<ul class="calibre32">
<li class="calibre12">Non-player character basics</li>
<li class="calibre12">Setting up the non-player character</li>
<li class="calibre12">Navmesh setup</li>
<li class="calibre12">NPC Animator Controller</li>
<li class="calibre12">NPC Attack</li>
<li class="calibre12">NPC AI</li>
</ul>
</li>
<li class="calibre12">PC and NPC interaction</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Customizing the player character</h1>
                
            
            <article>
                
<p class="calibre3">One of the key features of an RPG is to be able to customize your character player. In this section, we will take a look at how we can provide a means to achieve this.</p>
<div class="packt_infobox">Once again, the approach and concept are universal, but the actual implementation might be a little different based on your model structure.</div>
<p class="calibre3">Create a new scene and name it <kbd class="calibre13">CharacterCustomization</kbd>. Create a Cube prefab and set it to the origin. Change the Scale of the cube to <kbd class="calibre13">&lt;5, 0.1, 5&gt;</kbd>. You can also change the name of the GameObject to Base. This will be the platform that our character model stands on while the player customizes his/her character before game play.</p>
<div class="packt_infobox">I used my environment assets to create the stage. This takes more time, but it is more attractive. This is totally up to you, the creator and designer of the game, and the sky is the limit!</div>
<p class="calibre3">Drag and the drop the prefab representing your character model into the Scene View. The next few steps will entirely depend on your model hierarchy and structure as designed.</p>
<p class="calibre3">I am using the Barbarian model to illustrate the structure.</p>
<p class="calibre3">To illustrate the point, I have placed the same model in the scene twice. The one on the left is the model that has been configured to display only the basics, and the model on the right is the model in its original state, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00075.jpeg" class="calibre80"/></div>
<div class="mce-root2">Barbarian model: simple and fully geared</div>
<p class="calibre3">Notice that the particular model I am using has everything attached. This includes the different types of weapons, shoes, helmets, armor, and skins. The instantiated prefab on the left-hand side has turned off all of the extras from the model's hierarchy. Here is how the hierarchy looks in <kbd class="calibre13">Hierarchy View</kbd>:</p>
<div class="mce-root1"><img src="../images/00076.jpeg" class="calibre81"/></div>
<div class="mce-root2">Barbarian model structure</div>
<p class="calibre3">The model has a very extensive hierarchy in its structure. The preceding screenshot is a small snippet to demonstrate that you will need to navigate the structure and manually identify and enable or disable the mesh representing a particular part of the model.</p>
<p class="calibre3"/>
<p class="calibre3">Model root:</p>
<p class="calibre3">Pelvis:</p>
<p class="calibre3">Left thigh:</p>
<ul class="calibre11">
<li class="calibre12">Left calf</li>
</ul>
<p class="calibre3">Right thigh:</p>
<ul class="calibre11">
<li class="calibre12">Right calf</li>
</ul>
<p class="calibre3">Spine:</p>
<ul class="calibre11">
<li class="calibre12">Ribcage:
<ul class="calibre32">
<li class="calibre12">Left collarbone:
<ul class="calibre32">
<li class="calibre12">Left upper arm:
<ul class="calibre32">
<li class="calibre12">Left forearm</li>
</ul>
</li>
</ul>
</li>
<li class="calibre12">Neck:
<ul class="calibre32">
<li class="calibre12">Head</li>
</ul>
</li>
<li class="calibre12">Right collarbone:
<ul class="calibre32">
<li class="calibre12">Right upper arm:
<ul class="calibre32">
<li class="calibre12">Right forearm:
<ul class="calibre32">
<li class="calibre12">Right palm</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="calibre3">Each one of your character models will have their own unique hierarchy and bone structure. You will need to study this, as mentioned previously, to understand and plan how you will configure and program them during game play.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Customizable parts</h1>
                
            
            <article>
                
<p class="calibre3">Using my Barbarian model, I can customize a few items with it. I can customize the shoulder pads, the body type, the weapons, the armor, the helmets, the shoes, and, finally, the texture or skin of the model to give it different and unique looks.</p>
<p class="calibre3">Let's get a list of all the different customizable items we have for our character:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Shields</strong>: There are two types</li>
<li class="calibre12"><strong class="calibre1">Body Type</strong>: There are three body types: skinny, buff, and chubby</li>
</ul>
<p class="calibre3"/>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Armor</strong>: knee pad, leg plate</li>
<li class="calibre12"><strong class="calibre1">Boots</strong>: There are two types of boots</li>
<li class="calibre12"><strong class="calibre1">Helmet</strong>: There are four types of helmets</li>
<li class="calibre12"><strong class="calibre1">Weapons</strong>: There are 13 different types of weapons</li>
<li class="calibre12"><strong class="calibre1">Skins</strong>: There are 13 different types of skins</li>
</ul>
<div class="mce-root1"><img src="../images/00077.jpeg" class="calibre45"/></div>
<div class="mce-root2">Model assets 1</div>
<p class="calibre3"><span class="calibre6">You can easily extract each accessory from the main model and create a prefab of the individual weapon, armor, and clothing: </span></p>
<div class="mce-root1"><img src="../images/00078.jpeg" class="calibre45"/></div>
<div class="mce-root2">Model assets 2</div>
<p class="calibre3"><span class="calibre6">We are separating the items in such a way to give the player the ability to level-up or find the required weapon or armor during game play: </span></p>
<div class="mce-root1"><img src="../images/00079.jpeg" class="calibre45"/></div>
<div class="mce-root2"><span>Model assets 3</span></div>
<p class="calibre3">Once an item is picked up, we would have it in our inventory and the player can easily access it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">User interface</h1>
                
            
            <article>
                
<p class="calibre3">Now that we know what our options are for customizing our player character, we can start thinking about the <strong class="calibre5">User Interface</strong> (<strong class="calibre5">UI</strong>). The UI will be used for the customization of the character.</p>
<p class="calibre3">The following is a sketch of an idea for the UI. As we start implementing the UI, we might have to make some adjustments to accommodate the usability of the original concept:</p>
<div class="mce-root1"><img src="../images/00080.gif" class="calibre82"/></div>
<p class="calibre3">To design our UI, we will need to create a Canvas GameObject. This is done by right-clicking in the <strong class="calibre5">Hierarchy View</strong> and selecting <span class="calibre6">Create</span> <em class="calibre14">|</em> <span class="calibre6">UI</span> <em class="calibre14">|</em> <span class="calibre6">Canvas</span>. This will place a Canvas GameObject and an <kbd class="calibre13">EventSystem</kbd> GameObject in the <span class="calibre6">Hierarchy View</span>.</p>
<div class="packt_infobox">It is assumed that you already know how to create a UI in Unity. If you do not, please refer to <em class="calibre30">Introduction to Game Programming: Using C# and Unity 3D,</em> <a target="_blank" href="part0109.html#37UDA0-7a1ef7ae3ef249cdb149f8344d2e8e79" class="calibre46">Chapter 5</a>, <em class="calibre30">GameMaster and Game Mechanics,</em> at <a href="https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/" class="calibre46">https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/</a>.</div>
<p class="calibre3">I am going to use panels to group the customizable items. For the moment, I will be using checkboxes for some items and scroll bars for the weapons and skin texture. The following screenshot illustrates how my UI for customization looks:</p>
<div class="mce-root1"><img src="../images/00081.jpeg" class="calibre45"/></div>
<div class="mce-root2">Character customization UI</div>
<p class="calibre3">These UI elements will need to be integrated with event handlers that will perform the necessary actions for enabling or disabling certain parts of the character model.</p>
<p class="calibre3">For instance, using the UI, I can select Shoulder Pad 4, use the scroll bar to increase or decrease the chubbiness of the body, and move the weapons type scroll bar until the Hammer weapon shows up. Selecting the second Helmet checkbox, selecting Shield 1, and Boot 2, my character will look the like following screenshot.</p>
<p class="calibre3">We need a way to refer to each one of the meshes representing the different types of customizable objects on the model. This will be done through a C# script. The script will need to keep track of all the parts we are going to be managing for customization.</p>
<div class="packt_infobox">Some models will not have the extra meshes attached. You can always create empty GameObjects at a particular location on the model, and you can dynamically instantiate the prefab representing your custom object at the given point. This can also be done for our current model. For instance, if we have a special space weapon that somehow gets dropped by aliens in the game world, we can attach the weapon to our model through C# code. The important thing is to understand the concept, and the rest is up to you!</div>
<div class="mce-root1"><img src="../images/00082.jpeg" class="calibre45"/></div>
<div class="mce-root2">Character customization in action</div>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The code for character customization</h1>
                
            
            <article>
                
<p class="calibre3">Things don't happen automatically. We need to create some C# code that will handle the customization of our character model. The script we create here will handle the UI events that will drive the enabling and disabling of different parts of the model mesh.</p>
<p class="calibre3">Create a new C# script and call it <kbd class="calibre13">BarbarianCharacterCustomization.cs</kbd>. Create an empty GameObject called <kbd class="calibre13">__Base</kbd> and attach the script to <kbd class="calibre13">__Base GameObject</kbd> in the scene. Here is a listing of the script:</p>
<p class="calibre3"><kbd class="calibre13">path of the code</kbd></p>
<pre class="calibre18">using System;<br class="title-page-name"/>using UnityEngine;<br class="title-page-name"/>using UnityEngine.UI;<br class="title-page-name"/><br class="title-page-name"/>namespace com.noorcon.rpg2e<br class="title-page-name"/>{<br class="title-page-name"/>  public class BarbarianCharacterCustomization : MonoBehaviour<br class="title-page-name"/>  {<br class="title-page-name"/>    public GameObject PLAYER_CHARACTER;<br class="title-page-name"/><br class="title-page-name"/>    public PlayerCharacter PlayerCharacterData;<br class="title-page-name"/><br class="title-page-name"/>    public Material[] PLAYER_SKIN;<br class="title-page-name"/><br class="title-page-name"/>    public GameObject CLOTH_01LOD0;<br class="title-page-name"/>    public GameObject CLOTH_01LOD0_SKIN;<br class="title-page-name"/>    public GameObject CLOTH_02LOD0;<br class="title-page-name"/><br class="title-page-name"/>    // Player Character Defense Weapons<br class="title-page-name"/>    public GameObject SHIELD_01LOD0;<br class="title-page-name"/>    public GameObject SHIELD_02LOD0;<br class="title-page-name"/><br class="title-page-name"/>    public GameObject QUIVER_LOD0;<br class="title-page-name"/>    public GameObject BOW_01_LOD0;<br class="title-page-name"/><br class="title-page-name"/>    // Player Character Calf - Right / Left<br class="title-page-name"/>    public GameObject KNEE_PAD_R_LOD0;<br class="title-page-name"/>    public GameObject LEG_PLATE_R_LOD0;<br class="title-page-name"/><br class="title-page-name"/>    public GameObject KNEE_PAD_L_LOD0;<br class="title-page-name"/>    public GameObject LEG_PLATE_L_LOD0;<br class="title-page-name"/><br class="title-page-name"/>    public GameObject BOOT_01LOD0;<br class="title-page-name"/>    public GameObject BOOT_02LOD0;<br class="title-page-name"/><br class="title-page-name"/>    // Use this for initialization<br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>      PlayerCharacterData = PLAYER_CHARACTER.GetComponent&lt;PlayerAgent&gt;().playerCharacterData;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public bool ROTATE_MODEL = false;<br class="title-page-name"/><br class="title-page-name"/>    // Update is called once per frame<br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>      if (Input.GetKeyUp(KeyCode.R))<br class="title-page-name"/>      {<br class="title-page-name"/>        ROTATE_MODEL = !ROTATE_MODEL;<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      if (ROTATE_MODEL)<br class="title-page-name"/>      {<br class="title-page-name"/>        PLAYER_CHARACTER.transform.Rotate(new Vector3(0, 1, 0), 33.0f * Time.deltaTime);<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      if (Input.GetKeyUp(KeyCode.L))<br class="title-page-name"/>      {<br class="title-page-name"/>        Debug.Log(PlayerPrefs.GetString("Name"));<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>        void DisableShoulderPads()<br class="title-page-name"/>        {<br class="title-page-name"/>            SHOULDER_PAD_R_01LOD0.SetActive(false);<br class="title-page-name"/>            SHOULDER_PAD_R_02LOD0.SetActive(false);<br class="title-page-name"/>            SHOULDER_PAD_R_03LOD0.SetActive(false);<br class="title-page-name"/>            SHOULDER_PAD_R_04LOD0.SetActive(false);<br class="title-page-name"/><br class="title-page-name"/>            SHOULDER_PAD_L_01LOD0.SetActive(false);<br class="title-page-name"/>            SHOULDER_PAD_L_02LOD0.SetActive(false);<br class="title-page-name"/>            SHOULDER_PAD_L_03LOD0.SetActive(false);<br class="title-page-name"/>            SHOULDER_PAD_L_04LOD0.SetActive(false);<br class="title-page-name"/>        }</pre>
<p class="calibre3"/>
<p class="calibre3">This is a long script<span class="calibre6"> but it is straightforward. At the top of the script, we have defined all of the variables that will be referencing the different meshes in the model character. All variables are of type GameObject with the exception of the </span><kbd class="calibre13">PLAYER_SKIN</kbd><span class="calibre6"> variable, which is an array of </span><kbd class="calibre13">Material</kbd><span class="calibre6"> data type. The array is used to store the different types of texture created for the character model:</span></p>
<pre class="calibre18">    public void SetShoulderPad(Toggle id)<br class="title-page-name"/>    {<br class="title-page-name"/>      try<br class="title-page-name"/>      {<br class="title-page-name"/>        PlayerCharacter.ShoulderPad name <br class="title-page-name"/>          = (PlayerCharacter.ShoulderPad)Enum.Parse(typeof(PlayerCharacter.ShoulderPad), id.name, true);<br class="title-page-name"/>        if (id.isOn)<br class="title-page-name"/>        {<br class="title-page-name"/>          PlayerCharacterData.SelectedShoulderPad = name;<br class="title-page-name"/>        }<br class="title-page-name"/>        else<br class="title-page-name"/>        {<br class="title-page-name"/>          PlayerCharacterData.SelectedShoulderPad <br class="title-page-name"/>            = PlayerCharacter.ShoulderPad.none;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      catch<br class="title-page-name"/>      {<br class="title-page-name"/>        // if the value passed is not in the enumeration set it to none<br class="title-page-name"/>        PlayerCharacterData.SelectedShoulderPad <br class="title-page-name"/>          = PlayerCharacter.ShoulderPad.none;<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>            // disable before new selection<br class="title-page-name"/>            DisableShoulderPads();<br class="title-page-name"/><br class="title-page-name"/>            switch (id.name)<br class="title-page-name"/>      {<br class="title-page-name"/>        case "SP01":<br class="title-page-name"/>          {<br class="title-page-name"/>            SHOULDER_PAD_R_01LOD0.SetActive(id.isOn);<br class="title-page-name"/>            SHOULDER_PAD_L_01LOD0.SetActive(id.isOn);<br class="title-page-name"/>            break;<br class="title-page-name"/>          }<br class="title-page-name"/><a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a><br class="title-page-name"/>        case "SP04":<br class="title-page-name"/>          {<br class="title-page-name"/>            SHOULDER_PAD_R_04LOD0.SetActive(id.isOn);<br class="title-page-name"/>            SHOULDER_PAD_L_04LOD0.SetActive(id.isOn);<br class="title-page-name"/>            break;<br class="title-page-name"/>          }<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public void SetShoulderPad(PlayerCharacter.ShoulderPad id)<br class="title-page-name"/>    {<br class="title-page-name"/>            // disable before new selection<br class="title-page-name"/>            DisableShoulderPads();<br class="title-page-name"/><br class="title-page-name"/>            switch (id.ToString())<br class="title-page-name"/>      {<br class="title-page-name"/>        case "SP01":<br class="title-page-name"/>          {<br class="title-page-name"/>            SHOULDER_PAD_R_01LOD0.SetActive(true);<br class="title-page-name"/>            SHOULDER_PAD_L_01LOD0.SetActive(true);<br class="title-page-name"/>            break;<br class="title-page-name"/>          }<br class="title-page-name"/><a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a><br class="title-page-name"/>        case "SP04":<br class="title-page-name"/>          {<br class="title-page-name"/>            SHOULDER_PAD_R_04LOD0.SetActive(true);<br class="title-page-name"/>            SHOULDER_PAD_L_04LOD0.SetActive(true);<br class="title-page-name"/>            break;<br class="title-page-name"/>          }<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>...<a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition</a></pre>
<p class="calibre3">There are a few functions defined that are called by the UI event handler. These functions are: <kbd class="calibre13">SetShoulderPad(Toggle id)</kbd>, <kbd class="calibre13">SetBodyType(Toggle id)</kbd>, <kbd class="calibre13">SetKneePad(Toggle id)</kbd>, <kbd class="calibre13">SetLegPlate(Toggle id)</kbd>, <kbd class="calibre13">SetWeaponType(Slider id)</kbd>, <kbd class="calibre13">SetHelmetType(Toggle id)</kbd>, <kbd class="calibre13">SetShieldType(Toggle id)</kbd>, <kbd class="calibre13">SetSkinType(Slider id)</kbd>, <kbd class="calibre13">SetBodyFat(Slider id)</kbd>, and <kbd class="calibre13">SetBodySkinny(Slider id)</kbd>;</p>
<p class="calibre3">All of the functions take a parameter that identifies which specific type should enable or disable.</p>
<p class="calibre3">We have just created a tool that will enable you quickly visualize character customization.</p>
<p class="calibre3">You can also use the system we just built to create all of the different variations of your player character or non-character player models and store them as prefabs! Wow! This will save you so much time and effort in creating your characters representing different barbarians!</p>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preserving our character state</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have spent the time to customize our character, we need to preserve our character and use it in our game. In Unity, there is a function called <kbd class="calibre13">DontDestroyOnLoad()</kbd>.</p>
<p class="calibre3">This is a great function that can be utilized at this time. What does it do? It keeps the specified GameObject in memory going from one scene to the next. We can use these mechanisms for now. Eventually, though, you will want to create a system that you can save and load your user data.</p>
<p class="calibre3">Go ahead and create a new C# script and call it <kbd class="calibre13">DoNotDestroy.cs</kbd>. This script is going to be very simple. Here is the listing:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class DoNotDestroy : MonoBehaviour 
{ 
 
   // Use this for initialization 
   void Start() 
   { 
      DontDestroyOnLoad(this); 
   } 
 
   // Update is called once per frame 
   void Update() 
   { 
 
   } 
} </pre>
<p class="calibre3">After you create the script, go ahead and attach it to your character model prefab in the scene. Not bad; let's do a quick recap of what we have done so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Recap</h1>
                
            
            <article>
                
<p class="calibre3">By now you should have three scenes that are functional. We have our scene that represents the main menu, we have our scene that represents our initial level, and we just created a scene that is used for character customization. Here is the flow of our game thus far:</p>
<div class="mce-root1"><img src="../images/00083.jpeg" class="calibre84"/></div>
<p class="calibre3">We start the game, see the main menu, select the <span class="calibre6">Start Game</span> button to enter the character customization scene, do our customization, and when we click the <span class="calibre6">Save</span> button, we load level 1.</p>
<p class="calibre3">For this to work, we have created the following C# scripts:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">GameMaster.cs</kbd>: This is used as the main script to keep track of our game state</li>
<li class="calibre12"><kbd class="calibre13">BarbarianCharacterCustomization.cs</kbd>: This is used exclusively for customizing our character</li>
<li class="calibre12"><kbd class="calibre13">DoNotDestroy.cs</kbd>: This is used to save the state of a given object</li>
<li class="calibre12"><kbd class="calibre13">BarbarianCharacterController.cs</kbd>: This is used to control the motion of our character</li>
<li class="calibre12"><kbd class="calibre13">IKHandle.cs</kbd>: This is used to implement inverse kinematics for the foot</li>
</ul>
<p class="calibre3">When you combine all of this together, you now have a good framework and flow that can be used to extend and improve as we go along.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Non-player characters</h1>
                
            
            <article>
                
<p class="calibre3">Until now, we have concentrated on the player character. In this section, we will start thinking about our non-player characters. Let's start with our Barbarians. We can use our Character Customization scene to quickly create a few prefabs that will represent our unique Barbarians.</p>
<p class="calibre3"/>
<p class="calibre3">Using the tool we have just developed, you can make your adjustments, and when satisfied with your model, drag and drop the GameObject representing your character player into the <kbd class="calibre13">Prefabs</kbd> folder. This will create a copy of the instance of the GameObject as you see it and save it into a prefab. The following screenshot demonstrates the two characters I have created and stored as a prefab:</p>
<div class="mce-root1"><img src="../images/00084.jpeg" class="calibre45"/></div>
<div class="mce-root2">Creating unique characters using the tool</div>
<p class="calibre3">What I have shown you, if done properly, could save you hours of tedious work to manually go down the model structure and individually enable and disable the different meshes. In other words, we not only create a scene that allows us to customize the in-game player character, we have also created a tool that can help us customize our own character models quickly for use within the game!</p>
<p class="calibre3">Another point to emphasize here is the power of prefabs. Think of a prefab as a storage that can be used to save the state of a given GameObject and used over and over again within your game environment. When you update your prefab, all instances of the prefab will automatically get updated! This is great, but at the same time you have to be careful not to break anything for the same reason. When you update a code logic on a script that is attached to a prefab, all instances of the prefab will use the updated script, so a bit of planning on your part can save a lot of time and headache in the long run.</p>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Non-player character basics</h1>
                
            
            <article>
                
<p class="calibre3">We are going to be using the newly created prefabs to implement our non-player characters. Since there are some similarities in the character models, we can re-use some of the assets that we have created so far.</p>
<p class="calibre3">For instance, all character will be inheriting the BaseCharacte<em class="calibre14">r</em> class defined in <a target="_blank" href="part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79" class="calibre10">Chapter 3</a>, <em class="calibre14">RPG Character Design</em>. They will also incorporate the same states we have already created for the player character and extend a few more states specifically for the NPC, such as searching and seeking.</p>
<p class="calibre3">We have used our character customization tool to create and save our non-player character; hence, we are OK with the modeling part. What we need to concentrate on is the motion of our non-player characters. We would need to create a new Animator Controller that will handle the states of our NPCs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the non-player character</h1>
                
            
            <article>
                
<p class="calibre3">One of the main difficulties for implementing an NPC is the ability to give it realistic intelligence. This can be achieved easily by identifying and implementing several key areas for our NPCs.</p>
<p class="calibre3">There are a few new components we would need to attach to our NPCs. Using the prefab we have saved, we will need to add the following components:</p>
<ul class="calibre11">
<li class="calibre12">New Sphere Collider, this will be used to implement the range of sight for our NPC.</li>
<li class="calibre12">We already have an Animator component attached, but we will need to create a new Animator Controller to capture new states for the NPC.</li>
<li class="calibre12">We also need to add a Nav Mesh Agent component. We are going to use the built-in navigation and pathfinding system for our NPC.</li>
</ul>
<p class="calibre3">To add the Sphere Collider, you will need to select the prefab defined for the NCP, and in the <strong class="calibre5">Inspector</strong> Window. Select <span class="calibre6">Add Component</span> <em class="calibre14">|</em> <span class="calibre6">Physics</span> <em class="calibre14">|</em> <span class="calibre6">Sphere Collider</span>. This will attach a Sphere Collider to our prefab.</p>
<p class="calibre3">Next, we need to add Nav Mesh Agent<em class="calibre14">.</em> Again, from the Inspector Window, select Add <span class="calibre6">Component</span> <em class="calibre14">|</em> <span class="calibre6">Navigation</span> | <span class="calibre6">Nav Mesh Agent</span>. OK, so now we have set up our main built-in components that are going to be used for the NPC.</p>
<p class="calibre3"/>
<p class="calibre3">Since our prefab is an instance of our player character, we will need to remove some of the script components that have been carried over. If your NPC prefab contains any scripts attached to it, go ahead and remove them now.</p>
<div class="packt_infobox">Make sure you also change the <kbd class="calibre85">Tag</kbd> property to <kbd class="calibre85">Untagged</kbd>, if you have not done so already.</div>
<p class="calibre3">The following screenshot illustrates the components that we have so far on the NPC. This will include both the existing components, including the scripts we have brought over from the player character, and the newly added components that will be used for the NPC:</p>
<div class="mce-root1"><img src="../images/00085.jpeg" class="calibre86"/></div>
<div class="packt_infobox">Before you perform the next step, make sure you are in one of the level scenes. I am going to use the Awakening scene.</div>
<p class="calibre3">Switch to one of your playable game scenes.</p>
<p class="calibre3">The next step is to set up our Navmesh. To create a Navmesh, we need to get into the <span class="calibre6">Navigation</span> window, by selecting <span class="calibre6">Window</span> <em class="calibre14">|</em> <span class="calibre6">Navigation</span>:</p>
<div class="mce-root1"><img src="../images/00086.jpeg" class="calibre87"/></div>
<p class="calibre3">In order for the navmesh to work properly, we will need to mark all GameObjects that are going to be static in the scene as <span class="calibre6">Navigation Static</span>. This wkill create a navmesh based on the static objects in the scene; that is, GameObjects that are not going to be moving throughout the lifespan on the scene:</p>
<div class="mce-root1"><img src="../images/00087.jpeg" class="calibre88"/></div>
<p class="calibre3">In your active scene, select the GameObjects that are going to be set as <span class="calibre6">Navigation Static</span>, as shown in the preceding screenshot (<span class="calibre6">1</span>), use the <span class="calibre6">Static</span> drop-down menu (<span class="calibre6">2</span>), and select the <span class="calibre6">Navigation Static</span> option (<span class="calibre6">3</span>). If your GameObject is a parent GameObject with children, Unity will ask if you want to apply the property change to all children.</p>
<div class="packt_infobox">Notice that I have placed all of my environment GameObjecst under a GameObject called <kbd class="calibre85">__Structure</kbd><em class="calibre30">,</em> <kbd class="calibre85">_RootRockCollection</kbd> and a few others that have been added at a later time. This way, if I have many static objects, I can apply the property change to the parent and the children will automatically inherit the change as well. But make sure everything in the group will be static!</div>
<p class="calibre3"/>
<p class="calibre3">Once this is complete, we need to go back to the <span class="calibre6">Navigation</span> window and make some adjustments. In the <span class="calibre6">Navigation</span> tab, select <span class="calibre6">Terrains</span> and make sure it is set to <span class="calibre6">Navigation Static</span>, and the <em class="calibre14"><span class="calibre6">Navigation Area</span></em> is set to <span class="calibre6">Walkable</span>:</p>
<div class="mce-root1"><img src="../images/00088.jpeg" class="calibre89"/></div>
<p class="calibre3">In the <span class="calibre6">Bake</span> tab, change the <span class="calibre6">Agent Radius</span> to <span class="calibre6">0.3</span> and <span class="calibre6">Agent Height</span> to <span class="calibre6">1</span>. Keep the rest of the properties the same. This will give the NPC more freedom to pass through tight corners:</p>
<div class="mce-root1"><img src="../images/00089.jpeg" class="calibre90"/></div>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3">When you are ready, you can select the <span class="calibre6">Bake</span> button at the bottom of the <span class="calibre6">Navigation</span> window.</p>
<p class="calibre3">Unity will take some time to generate the Navmesh for your scene. This will depend on the complexity of your level. If all is done correctly, you will see something similar to the following screenshot displaying your Navmesh:</p>
<div class="mce-root1"><img src="../images/00090.jpeg" class="calibre45"/></div>
<div class="mce-root2">Navmesh generation</div>
<p class="calibre3">The blue areas you see are all the regions that the NPC can actually navigate to:</p>
<div class="mce-root1"><img src="../images/00091.jpeg" class="calibre45"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">NPC Animator Controller</h1>
                
            
            <article>
                
<p class="calibre3">We now need to create the <strong class="calibre5">Animator Controller</strong> (<strong class="calibre5">AC</strong>) for our NPC. The Animator Controller will use input from the <kbd class="calibre13">MeshAgent</kbd> to control and change the state of our NPC. We also need to define a few parameters for our NPC AC. These are going to be:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">AngularSpeed</kbd>: This will be used for directional movement</li>
<li class="calibre12"><kbd class="calibre13">Speed</kbd>: This will be used to determine how fast the NPC will be moving</li>
<li class="calibre12"><kbd class="calibre13">Attack</kbd>: This will be used to determine if it needs to attack</li>
<li class="calibre12"><kbd class="calibre13">AttackWeight</kbd>: This might be used</li>
<li class="calibre12"><kbd class="calibre13">PlayerInSight</kbd>: This will be used to determine if the PC is in sight</li>
</ul>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3">Go ahead and create a new Animator Controller in your project and name it <kbd class="calibre13">NPC_BarbarianAnimatorController</kbd>. Open the Animator Window. Create a new Blend Tree by right-clicking in the Animator Window and selecting <span class="calibre6">Create State</span> | <span class="calibre6">From New Blend Tree</span>. Change the name to <kbd class="calibre13">NPC_Locomotion</kbd>. Double-click it so that you can edit the Blend Tree. Change the node name to <kbd class="calibre13">NPC_Locomotion</kbd> as well:</p>
<div class="mce-root1"><img src="../images/00092.jpeg" class="calibre91"/></div>
<p class="calibre3">From the Inspector Window, change the <em class="calibre14">Blend Type</em> to <em class="calibre14">2D Freeform Cartesian:</em></p>
<div class="mce-root1"><img src="../images/00093.jpeg" class="calibre92"/></div>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3">The <em class="calibre14">x</em>-axis will be represented by the <em class="calibre14">AngularSpeed</em>, and the <em class="calibre14">y</em>-axis will be represented by the <em class="calibre14">Speed</em> parameters.</p>
<p class="calibre3">The Blend Tree is going to hold all of the different locomotion animation states. These are going to be the idle, walking, and running states.</p>
<p class="calibre3">I have set up 11 different animation states for the locomotion of my NPC. The following screenshot will give you and overview of the Blend Tree:</p>
<div class="mce-root1"><img src="../images/00094.jpeg" class="calibre45"/></div>
<div class="mce-root2">NPC Blend Tree</div>
<p class="calibre3">Once you include all of the animations states in the Blend Tree, you will need to compute the positions of your animations. An easy way to do this, is to select the <em class="calibre14">Compute Positions</em> dropdown and select <em class="calibre14">AngularSpeed and Speed</em>. This will place the animation position based on the root motion, as illustrated in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00095.jpeg" class="calibre93"/></div>
<div class="packt_infobox">You can use your mouse to drag the red point shown in the screenshot to preview your animation states in action.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">NPC Attack</h1>
                
            
            <article>
                
<p class="calibre3">In order to implement our attack mode, we will need to create a new layer in the Animator Controller. Go ahead and create a new layer and call it <kbd class="calibre13">NPC_Attack</kbd>. This layer will be responsible for animating our character when we enter the attack mode.</p>
<p class="calibre3">We need to create a new mask for the layer. The mask will be used to determine which parts of the humanoid body will be affected by the layer animation. To create a mask, right-click in your Project Window and select <span class="calibre6">Create</span> <em class="calibre14">|</em> <span class="calibre6">Avatar Mask</span>. Name the new mask <kbd class="calibre13">NPC_BarbarianAttackMask</kbd>. Use the Inspector Window to disable the body parts that we don't want to be affected by the layer animation, as illustrated in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00096.jpeg" class="calibre94"/></div>
<p class="calibre3">Your layer setup should look like the following screenshot:</p>
<div class="mce-root1"><img src="../images/00097.jpeg" class="calibre95"/></div>
<p class="calibre3">Make sure you change the Weight property to <em class="calibre14">1</em>, the Mask property assigned to the Avatar Mask we created, and also that the IK property is checked. Now we are ready to create our attack state machine.</p>
<p class="calibre3">Right-click in the Animator Window and select <span class="calibre6">Create State</span> <em class="calibre14">|</em> <span class="calibre6">Empty</span>. Drag and drop your attack animation(s). The empty state is used to have a nice transition between the main layer and back.</p>
<p class="calibre3">After you have dropped your attack animation(s) into the Animator, you will need to connect them using the transition conditions. I have added three more parameters to the parameter list named <span class="calibre6">attack1</span>, <span class="calibre6">attack2</span>, and <span class="calibre6">attack3</span>. These parameters, in connection with the Attack parameter, will determine which attack state our NPC will transition to.</p>
<p class="calibre3">The following screenshot shows the <kbd class="calibre13">NPC_Attack</kbd> layer as configured up to this point:</p>
<div class="mce-root1"><img src="../images/00098.jpeg" class="calibre45"/></div>
<div class="mce-root2">New parameters</div>
<p class="calibre3">Finally, you want to assign the new <kbd class="calibre13">NPC_BarbarianAnimatorController</kbd> to the NPC prefab(s).</p>
<p class="calibre3"/>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">NPC AI</h1>
                
            
            <article>
                
<p class="calibre3">Now it is time to give some intelligence to our NPCs. One of the scripts we will need to create is to give the NPC the ability to detect the player. This script will be called <kbd class="calibre13">NPC_BarbarianMovement.cs</kbd>. The script will be used to detect if the player is in-sight, calculate the field of view for the NPC, and calculate the path from the NPC to the player character.</p>
<p class="calibre3">Here is a listing of the source code:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.AI;<br class="title-page-name"/>namespace com.noorcon.rpg2e<br class="title-page-name"/>{<br class="title-page-name"/>public class NPC_BarbarianMovement : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>// reference to the animator<br class="title-page-name"/>public Animator animator;<br class="title-page-name"/>// these variables are used for the speed<br class="title-page-name"/>// horizontal and vertical movement of the NPC<br class="title-page-name"/>public float speed = 0.0f;<br class="title-page-name"/>public float h = 0.0f;<br class="title-page-name"/>public float v = 0.0f;<br class="title-page-name"/>public bool attack = false; // used for attack mode 1<br class="title-page-name"/>public bool jump = false; // used for jumping<br class="title-page-name"/>public bool die = false; // are we alive?<br class="title-page-name"/>// used for debugging<br class="title-page-name"/>public bool DEBUG = false;<br class="title-page-name"/>public bool DEBUG_DRAW = false;<br class="title-page-name"/>// Reference to the NavMeshAgent component.<br class="title-page-name"/>private NavMeshAgent nav;<br class="title-page-name"/>// Reference to the sphere collider trigger component.<br class="title-page-name"/>private SphereCollider col;<br class="title-page-name"/>// where is the player character in relation to NPC<br class="title-page-name"/>public Vector3 direction;<br class="title-page-name"/>// how far away is the player character from NPC<br class="title-page-name"/>public float distance = 0.0f;<br class="title-page-name"/>// what is the angle between the PC and NPC<br class="title-page-name"/>public float angle = 0.0f;<br class="title-page-name"/>// a reference to the player character<br class="title-page-name"/>public GameObject player;<br class="title-page-name"/>// is the PC in sight?<br class="title-page-name"/>public bool playerInSight;<br class="title-page-name"/>// what is the field of view for our NPC?<br class="title-page-name"/>// currently set to 110 degrees<br class="title-page-name"/>public float fieldOfViewAngle = 110.0f;<br class="title-page-name"/>// calculate the angle between PC and NPC<br class="title-page-name"/>public float calculatedAngle;<br class="title-page-name"/>void Awake()<br class="title-page-name"/>{<br class="title-page-name"/>// get reference to the animator component<br class="title-page-name"/>animator = GetComponent&lt;Animator&gt;() as Animator;<br class="title-page-name"/>// get reference to nav mesh agent<br class="title-page-name"/>nav = GetComponent&lt;NavMeshAgent&gt;() as NavMeshAgent;<br class="title-page-name"/>// get reference to the sphere collider<br class="title-page-name"/>col = GetComponent&lt;SphereCollider&gt;() as SphereCollider;<br class="title-page-name"/>// get reference to the player<br class="title-page-name"/>player = GameObject.FindGameObjectWithTag("Player") as GameObject;<br class="title-page-name"/>// we don't see the player by default<br class="title-page-name"/>playerInSight = false;<br class="title-page-name"/>}<br class="title-page-name"/>// Use this for initialization<br class="title-page-name"/>void Start()<br class="title-page-name"/>{<br class="title-page-name"/>}<br class="title-page-name"/>void Update()<br class="title-page-name"/>{<br class="title-page-name"/>// if player is in sight let's slerp towards the player<br class="title-page-name"/>if (playerInSight)<br class="title-page-name"/>{<br class="title-page-name"/>transform.rotation =<br class="title-page-name"/>Quaternion.Slerp(this.transform.rotation,<br class="title-page-name"/>Quaternion.LookRotation(direction), 0.1f);<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>// let's update our scene using fixed update<br class="title-page-name"/>void FixedUpdate()<br class="title-page-name"/>{<br class="title-page-name"/>h = angle; // assign horizontal axis<br class="title-page-name"/>v = distance; // assign vertical axis<br class="title-page-name"/>// calculate speed based on distance and delta time<br class="title-page-name"/>speed = distance / Time.deltaTime;<br class="title-page-name"/>if (DEBUG)<br class="title-page-name"/>Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed));<br class="title-page-name"/>// set the parameters defined in the animator controller<br class="title-page-name"/>animator.SetFloat("Speed", speed);<br class="title-page-name"/>animator.SetFloat("AngularSpeed", v);<br class="title-page-name"/>animator.SetBool("Attack", attack);<br class="title-page-name"/>}</pre>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"><span class="calibre6">OK, so let's actually take a look and see what this code is trying to do. In the</span> <kbd class="calibre13">Awake()</kbd><span class="calibre6"> function we are initializing our variables that will be used in the script. We have a reference to the </span><kbd class="calibre13">NavMeshAgent</kbd><span class="calibre6">, the </span><kbd class="calibre13">SphereCollider</kbd>, <span class="calibre6">and the</span> <kbd class="calibre13">Animator</kbd> <span class="calibre6">components attached to the NPC. These are stored in the</span> <kbd class="calibre13">nav</kbd>, <kbd class="calibre13">col</kbd>, and <kbd class="calibre13">anim</kbd><span class="calibre6"> variables, respectively:</span></p>
<pre class="calibre18">// if the PC is in our collider, we want to examine the location<br class="title-page-name"/>// of the player<br class="title-page-name"/>// calculate the direction based on our position and the<br class="title-page-name"/>// player's position<br class="title-page-name"/>// use the DOT product to get the angle between the two vectors<br class="title-page-name"/>// calculate the angle between the NPC forward vector and the PC<br class="title-page-name"/>// if it falls within the field of view, we have the player in<br class="title-page-name"/>// sight<br class="title-page-name"/>// if the player is in sight, we will set the nav agent destination<br class="title-page-name"/>// if we are within a certain distance from the PC, the NPC has<br class="title-page-name"/>// the ability to attack<br class="title-page-name"/>void OnTriggerStay(Collider other)<br class="title-page-name"/>{<br class="title-page-name"/>if (other.transform.tag.Equals("Player"))<br class="title-page-name"/>{<br class="title-page-name"/>// Create a vector from the enemy to the player and store<br class="title-page-name"/>// the angle between it and forward.<br class="title-page-name"/>direction = other.transform.position - transform.position;<br class="title-page-name"/>distance = Vector3.Distance(other.transform.position, transform.position) - 1.0f;<br class="title-page-name"/>float DotResult = Vector3.Dot(transform.forward, player.transform.position);<br class="title-page-name"/>angle = DotResult;<br class="title-page-name"/>if (DEBUG_DRAW)<br class="title-page-name"/>{<br class="title-page-name"/>Debug.DrawLine(transform.position + Vector3.up, direction * 50, Color.gray);<br class="title-page-name"/>Debug.DrawLine(other.transform.position, transform.position, Color.cyan);<br class="title-page-name"/>}<br class="title-page-name"/>playerInSight = false;<br class="title-page-name"/>calculatedAngle = Vector3.Angle(direction, transform.forward);<br class="title-page-name"/>if (calculatedAngle &lt; fieldOfViewAngle * 0.5f)<br class="title-page-name"/>{<br class="title-page-name"/>RaycastHit hit;<br class="title-page-name"/>if (DEBUG_DRAW)<br class="title-page-name"/>Debug.DrawRay(transform.position + transform.up, direction.normalized, Color.magenta);<br class="title-page-name"/>// ... and if a raycast towards the player hits something...<br class="title-page-name"/>if (Physics.Raycast(transform.position + transform.up, direction.normalized, out hit,<br class="title-page-name"/>col.radius))<br class="title-page-name"/>{<br class="title-page-name"/>// ... and if the raycast hits the player...<br class="title-page-name"/>if (hit.collider.gameObject == player)<br class="title-page-name"/>{<br class="title-page-name"/>// ... the player is in sight.<br class="title-page-name"/>playerInSight = true;<br class="title-page-name"/>if (DEBUG)<br class="title-page-name"/>Debug.Log("PlayerInSight: " + playerInSight);<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>if (playerInSight)<br class="title-page-name"/>{<br class="title-page-name"/>nav.SetDestination(other.transform.position);<br class="title-page-name"/>CalculatePathLength(other.transform.position);<br class="title-page-name"/>if (distance &lt; 1.1f)<br class="title-page-name"/>{<br class="title-page-name"/>attack = true;<br class="title-page-name"/>}<br class="title-page-name"/>else<br class="title-page-name"/>{<br class="title-page-name"/>attack = false;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3"><span class="calibre6">We also need to get a reference to the player and the player animator component. These is done through the </span><kbd class="calibre13">player</kbd><span class="calibre6"> variable. We are also setting the </span><kbd class="calibre13">playerInSight</kbd><span class="calibre6"> variable to false by default:</span></p>
<pre class="calibre18">void OnTriggerExit(Collider other)<br class="title-page-name"/>{<br class="title-page-name"/>if (other.transform.tag.Equals("Player"))<br class="title-page-name"/>{<br class="title-page-name"/>distance = 0.0f;<br class="title-page-name"/>angle = 0.0f;<br class="title-page-name"/>attack = false;<br class="title-page-name"/>playerInSight = false;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>// this is a helper function at this point<br class="title-page-name"/>// in the future we will use it to calculate distance around<br class="title-page-name"/>// the corners<br class="title-page-name"/>// it currently is also used to draw the path of the nav mesh<br class="title-page-name"/>// agent in the<br class="title-page-name"/>// editor<br class="title-page-name"/>float CalculatePathLength(Vector3 targetPosition)<br class="title-page-name"/>{<br class="title-page-name"/>// Create a path and set it based on a target position.<br class="title-page-name"/>NavMeshPath path = new NavMeshPath();<br class="title-page-name"/>if (nav.enabled)<br class="title-page-name"/>nav.CalculatePath(targetPosition, path);<br class="title-page-name"/>// Create an array of points which is the length of the number<br class="title-page-name"/>// of corners in the path + 2.<br class="title-page-name"/>Vector3[] allWayPoints = new Vector3[path.corners.Length + 2];<br class="title-page-name"/>// The first point is the enemy's position.<br class="title-page-name"/>allWayPoints[0] = transform.position;<br class="title-page-name"/>// The last point is the target position.<br class="title-page-name"/>allWayPoints[allWayPoints.Length - 1] = targetPosition;<br class="title-page-name"/>// The points inbetween are the corners of the path.<br class="title-page-name"/>for (int i = 0; i &lt; path.corners.Length; i++)<br class="title-page-name"/>{<br class="title-page-name"/>allWayPoints[i + 1] = path.corners[i];<br class="title-page-name"/>}<br class="title-page-name"/>// Create a float to store the path length that is by default 0.<br class="title-page-name"/>float pathLength = 0;<br class="title-page-name"/>// Increment the path length by an amount equal to the<br class="title-page-name"/>// distance between each waypoint and the next.<br class="title-page-name"/>for (int i = 0; i &lt; allWayPoints.Length - 1; i++)<br class="title-page-name"/>{<br class="title-page-name"/>pathLength += Vector3.Distance(allWayPoints[i], allWayPoints[i + 1]);<br class="title-page-name"/>if (DEBUG_DRAW)<br class="title-page-name"/>Debug.DrawLine(allWayPoints[i], allWayPoints[i + 1], Color.red);<br class="title-page-name"/>}<br class="title-page-name"/>return pathLength;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3">The <kbd class="calibre13">Update()</kbd> function is not performing anything major at this point. It is just checking to see if the player character is in sight, and, if so, it makes sure that the NPC is orienting itself to look at the player.</p>
<p class="calibre3">Most of the meat of our code is in the <kbd class="calibre13">OnTriggerStay()</kbd> function. The first things we need to do is make sure the object that has entered our collider is the player object. This is done by checking the tag attribute on the other collider.</p>
<p class="calibre3">If the player is within our collider, then we go ahead and calculate the direction, the distance, and the angle of the player relative to the NPC. This is done with the following lines:</p>
<pre class="calibre18">direction = other.transform.position - transform.position; 
 
distance = Vector3.Distance(other.transform.position, transform.position) - 1.0f; 
 
float DotResult = Vector3.Dot(transform.forward,player.transform.position); 
 
angle = DotResult; </pre>
<p class="calibre3">Then, if the angle is smaller than the <kbd class="calibre13">fieldOfViewAngle</kbd> variable, we can use ray casting to determine if we can hit the player. If that is the case, the player is in NPC's sight:</p>
<div class="mce-root1"><img src="../images/00099.jpeg" class="calibre45"/></div>
<div class="mce-root2">Debug rays</div>
<p class="calibre3">There is one more critical calculation the NPC needs to perform. That is how to get to the player once it is in range. Once we have established that the player is in range and that we are facing the player, we need to make the NPC find its way to the player. This is where the <kbd class="calibre13">NavMesh</kbd> and the <kbd class="calibre13">NavMeshAgent</kbd> come into play.</p>
<p class="calibre3">The <kbd class="calibre13">CalculatePathLength()</kbd> is a function that takes the position of the player and, using the mesh data, it calculates the best path to navigate from the NPCs location to the player's location.</p>
<p class="calibre3"/>
<p class="calibre3">However, there is one more additional calculation we are performing, and that is, we are calculating the length of the path between the two points. This length calculation will be used in the future to perform the following:</p>
<p class="calibre3">If the length of the path is larger than a threshold we have set, then we won't make the NPC attack. If it is within mean, then we can make the NPC move towards the player to engage in battle.</p>
<p class="calibre3">In the last function <kbd class="calibre13">OnTriggerExit()</kbd>, we set the <kbd class="calibre13">playerInSight</kbd> variable to false. This will stop the NPC from pursuing the player:</p>
<div class="mce-root1"><img src="../images/00100.jpeg" class="calibre96"/></div>
<div class="mce-root2">Navmesh path</div>
<p class="calibre3">The preceding screenshot illustrates the path between the NPC and the player based on real-time calculation.</p>
<p class="calibre3">Go ahead and attach the script to the NPC prefab if you have not done so already, and run the application to test it out. If all things are good, then you will be able to move the player character around the level, and once the player character enters the NPC field of view, the NPC will start moving towards the player and when close enough, it will attack:</p>
<p class="calibre3"/>
<div class="mce-root1"><img src="../images/00101.jpeg" class="calibre45"/></div>
<p class="calibre3">At this point, your NPC should have the following components attached to its prefab:</p>
<ul class="calibre11">
<li class="calibre12">Animator</li>
<li class="calibre12">Rigidbody</li>
<li class="calibre12">Capsule and sphere colliders</li>
<li class="calibre12">NavMesh Agent</li>
<li class="calibre12"><kbd class="calibre13">NPC_BarbarianMovement</kbd> script</li>
</ul>
<p class="calibre3">We have covered a lot of information. I would encourage you to take the time to read through it one more time and understand the concepts before moving forward.</p>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">PC and NPC interaction</h1>
                
            
            <article>
                
<p class="calibre3">Thus far, we have created the basics movement for both our PC and NPC. The next item I would like to complete is the attack mechanism for the PC and the NPC characters. Let's start by implementing the hit for the NPC.</p>
<p class="calibre3">Our NPC detects the player character based on the code we just created in the previous section. When the player character is in sight, the NPC will find the shortest path to the player character, and at a given range, it will attack the player character. We have the movement and animation mechanics completed. The next objective is to keep track of the hit points when the NPC is attacking.</p>
<p class="calibre3">There are a few adjustments we need to make in <kbd class="calibre13">NPC_Animator_Controller</kbd>. Open the <span class="calibre6">Animator</span> window, and select the <kbd class="calibre13">NPC_Attack</kbd> layer:</p>
<div class="mce-root1"><img src="../images/00102.jpeg" class="calibre97"/></div>
<div class="mce-root2">NPC attack layer</div>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3">Double-click on the <em class="calibre14">attack1</em> state, or the attack state you have defined in your state machine. This will open the related animation in the <span class="calibre6">Inspector</span> window.</p>
<p class="calibre3">In the <span class="calibre6">Inspector</span> window, scroll down to the <em class="calibre14">Curves</em> section. We are going to create a new curve by selecting the (+) sign under the <em class="calibre14">Curves</em> section. We are also going to create a new parameter called <em class="calibre14">Attack1C</em> to represent the value of the curve. This parameter should of type float:</p>
<div class="mce-root1"><img src="../images/00103.gif" class="calibre98"/></div>
<p class="calibre3">The curve displayed in the preceding screenshot will be based on your animation:</p>
<div class="mce-root1"><img src="../images/00104.jpeg" class="calibre99"/></div>
<p class="calibre3">In the preceding screenshot, I have marked the important parts of the interface that you will need to work with to configure the curve of an animation. The first step would be to actually preview your animation and get a feeling for it.</p>
<p class="calibre3"/>
<p class="calibre3">The next step for my particular animation sequence was determining when the right arm of the model is coming along and I set a marker in the curve. I make another marker a bit more into the animation where the right arm has crossed a good deal from the right side to the left side.</p>
<p class="calibre3">These markers will indicate a hit point during the animation when the NPC is in attack mode:</p>
<div class="mce-root1"><img src="../images/00105.jpeg" class="calibre100"/></div>
<p class="calibre3">OK, why do we do this? Simple. This will help us only generate a hit based on the curve of the animation. This way, we don't hit the player and reduce the health of the player while the weapon is away from the player's body.</p>
<p class="calibre3">Next, we need to update out <kbd class="calibre13">NPC_BarbarianMovement.cs</kbd> code to program the NPC attack.</p>
<div class="packt_infobox">Note: I have only listed the portions that have been updated.</div>
<p class="calibre3"/>
<p class="calibre3">Here is an updated listing of the code:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class NPC_Movement : MonoBehaviour 
{ 
<a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a> 
    void Update() 
    { 
        // if player is in sight let's slerp towards the player 
        if (playerInSight) 
        { 
            this.transform.rotation = 
                Quaternion.Slerp(this.transform.rotation, 
                Quaternion.LookRotation(direction), 0.1f); 
        } 
 
        if(this.player.transform.GetComponent&lt;CharacterController&gt;().die) 
        { 
            animator.SetBool("Attack", false); 
            animator.SetFloat("Speed", 0.0f); 
            animator.SetFloat("AngularSpeed", 0.0f); 
        } 
    } 
 
    // let's update our scene using fixed update 
    void FixedUpdate() 
    { 
        h = angle;          // assign horizontal axis 
        v = distance;       // assign vertical axis 
 
        // calculate speed based on distance and delta time 
        speed = distance / Time.deltaTime; 
 
        if (DEBUG) 
            Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed)); 
 
        // set the parameters defined in the animator controller 
        animator.SetFloat("Speed", speed); 
        animator.SetFloat("AngularSpeed", v); 
        animator.SetBool("Attack", attack1); 
        animator.SetBool("Attack1", attack1); 
 
        if(playerInSight) 
        { 
            if (animator.GetFloat("Attack1C") == 1.0f) 
            { 
                this.player.GetComponent&lt;PlayerAgent&gt;().playerCharacterData.HEALTH -= 1.0f; 
            } 
        } 
    } 
<a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a> 
} </pre>
<p class="calibre3">The new addition to the code checks to see if the player is in sight, and if that is the case, we check to see if we are in range to be able to attack. If that is the case, we get into the attack mode. If we are in the attack mode, the attack animation is played.</p>
<p class="calibre3">In the code, we check to get the value of the newly created parameter called Attack1, and if it happens to be of value 1.0, then we go ahead and reduce the health of the player character.</p>
<p class="calibre3">If the player dies while the NPC is attacking, it will stop attacking and go back into the idle state.</p>
<p class="calibre3">OK, you might be wondering how did we get the ability to get the information from the player character. This is because we need to make some more additional C# scripts. Let's go ahead and do so now. Create the following C# scripts:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">PlayerCharacter.cs</kbd>: This is going to be our player character class, which inherits from the <kbd class="calibre13">BaseCharacter</kbd> class we have defined previously</li>
<li class="calibre12"><kbd class="calibre13">PlayerAgent.cs</kbd>: This is going to be used to store the PC data and also inherit <kbd class="calibre13">MonoBehaviour</kbd></li>
<li class="calibre12"><kbd class="calibre13">NPC.cs</kbd>: This is going to be our non-player character class, which inherits from the <kbd class="calibre13">BaseCharacter</kbd> class as well</li>
<li class="calibre12"><kbd class="calibre13">NPC_Agent.cs</kbd>: This is going to be used to store the NPC data and also inherit <kbd class="calibre13">MonoBehaviour</kbd></li>
</ul>
<p class="calibre3">I have made some modification to the <kbd class="calibre13">BaseCharacter.cs</kbd> script to make it more accessible through the editor. Here is the new listing:</p>
<pre class="calibre18">    using System;
    using UnityEngine;
    
    namespace com.noorcon.rpg2e
    {
       [Serializable]
       public class BaseCharacter
       {
          [SerializeField]
          public string Name;
          [SerializeField]
          public string Description;
    
          [SerializeField]
          public float Strength;
          [SerializeField]
          public float Defense;
          [SerializeField]
          public float Dexterity;
          [SerializeField]
          public float Intelligence;
          [SerializeField]
          public float Health;
       }
    }</pre>
<p class="calibre3">I have gone ahead and made the class and the fields serializable.</p>
<p class="calibre3">Let's take a look at the listing for <kbd class="calibre13">PlayerCharacter.cs</kbd>:</p>
<pre class="calibre18">using System; 
using UnityEngine; 
 
namespace com.noorcon.rpg2e 
{ 
   [Serializable] 
   public class PlayerCharacter : MonoBehaviour 
   { 
 
   } 
} </pre>
<p class="calibre3">There is nothing much going on there at this point. Now let's take a look at the <kbd class="calibre13">PlayerAgent.cs</kbd>:</p>
<pre class="calibre18">using System; 
using UnityEngine; 
 
namespace com.noorcon.rpg2e 
{ 
   [Serializable] 
   public class PlayerAgent : MonoBehaviour 
   { 
      public PlayerCharacter playerCharacterData; 
 
      void Awake() 
      { 
         PlayerCharacter tmp = new PlayerCharacter(); 
         tmp.Name = "Maximilian"; 
         tmp.Health = 100.0f; 
         tmp.Defense = 50.0f; 
         tmp.Description = "Our Hero"; 
         tmp.Dexterity = 33.0f; 
         tmp.Intelligence = 80.0f; 
         tmp.Strength = 60.0f; 
 
         playerCharacterData = tmp; 
      } 
 
      // Use this for initialization 
      void Start() 
      { 
 
      } 
 
      // Update is called once per frame 
      void Update() 
      { 
         if (playerCharacterData.Health &lt; 0.0f) 
         { 
            playerCharacterData.Health = 0.0f; 
 
            transform.GetComponent&lt;BarbarianCharacterController&gt;().die = true; 
         } 
      } 
   } 
} </pre>
<p class="calibre3">In the player agent code, we are initializing some default values for our PC data in the <kbd class="calibre13">Awake()</kbd> function. Since the class has been serialized, we can actually see the data during runtime for debugging purposes.</p>
<p class="calibre3">In the <kbd class="calibre13">Update()</kbd> function, we check to see if the health of our PC is less than 0.0f, and if it is, then this indicates the player has died. Then we use the <kbd class="calibre13">CharacterController</kbd> component we have created to set the <em class="calibre14">die</em> property to true. The <kbd class="calibre13">CharacterController</kbd> then will use the new value and communicate with the Animator Controller for the player character to get into the die state.</p>
<div class="packt_infobox">Notice that our <kbd class="calibre85">NPC_BarbarianMovement.cs</kbd> script is accessing the exact same PC data through the reference we have created in the script.</div>
<p class="calibre3">You will need to attach the <kbd class="calibre13">PlayerAgent.cs</kbd> script to your player character in the scene:</p>
<div class="mce-root1"><img src="../images/00106.jpeg" class="calibre45"/></div>
<div class="mce-root2">Player character data</div>
<p class="calibre3">In the preceding screenshot, you can see the additions we have done to the scripts and how they look during runtime. We will have a listing for the <kbd class="calibre13">NPC.cs</kbd> and <kbd class="calibre13">NPC_Agent.cs</kbd> in future chapters. At this point, they are not used.</p>
<p class="calibre3"/>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">This chapter was a very involved one. We covered some very important topics and concepts in the chapter that can be used and enhanced for your games. We started the chapter by looking into how to customize your player character. The concepts you take away from the section can be applied to a wide variety of scenarios.</p>
<p class="calibre3">We looked at how to understand the structure of your character model so that you can better determine the customization methods. These are the different types of weapons, clothing, armor, shields, and on.</p>
<p class="calibre3">We then looked at how to create a user interface to help enable us with the customization of our player character during game play. We also learned that the tool we developed can be used to quickly create several different character models (customized) and store them as prefabs for later use. Great time saver! We also learned how to preserve the state of our player character after customization for game play.</p>
<p class="calibre3">We looked at the non-player characters next. We went through the basics of setting up the NPC with the different necessary components. We then looked at how to create a Navmesh and how to work with Navmesh Agent and Pathfinding using the Navmesh.</p>
<p class="calibre3">We created a new Animator Controller for the NPC. We created a 2D Freeform Cartesian Blend Tree that was used for the animation of the NPC. We looked at how to create multiple layers in the Animation Controller and enable IK for different regions of the humanoid skeleton. We created the initial NPC AI script to detect and determine if the player is close enough for it to make a move and attack. Finally, we created new scripts to make interaction between the NPC and the player character possible.</p>
<p class="calibre3">By the end of the chapter, you should have a good grasp of how everything is interrelated and have an idea of how to approach your project.</p>
<p class="calibre3">In the next chapter, we will create a better way to manage our game state.</p>


            </article>

            
        </section>
    </body></html>