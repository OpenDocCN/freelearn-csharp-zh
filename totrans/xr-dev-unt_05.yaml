- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Interactive VR Experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into the world of more complex VR applications, empowering
    you to craft immersive and interactive experiences for a wide range of use cases.
    You will learn how to use the powerful Unity engine to create interactive VR apps
    without code and with C#.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this chapter lies in its practical approach. You’ll acquire hands-on
    skills to construct a VR environment that mirrors the responsiveness and realism
    of our natural world. Though some background in C# could be advantageous, it is
    by no means a prerequisite. Our tutorial is designed to be beginner-friendly,
    allowing anyone with an interest in XR applications to follow along comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is split into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building interactive VR experiences without code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building interactive VR experience with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we embark on this exciting journey, let’s ensure you meet the needed
    technical requirements to power through this chapter. Besides having the most
    recent version of Unity installed, you also need to have either *Windows*/*Linux*/*Mac*
    or *Android Build Support* enabled, depending on whether your VR device is running
    standalone or in PC-based VR mode. If you are unsure whether your PC or laptop
    meets the hardware requirements of Unity, have a look at this page: [https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Building interactive VR experiences without code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After exploring the demo scene in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009),
    let’s build interactive VR experiences ourselves, starting with a virtual car
    exhibition. In the experience we are going to build, the user should be able to
    walk around the ground via continuous movement (walking with the joystick) and
    via teleportation (only to teleportation anchors).
  prefs: []
  type: TYPE_NORMAL
- en: To kick off our experience, create a new project by following the *Setting up
    a VR project in Unity and the XR Interaction Toolkit* section in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009).
    If you have followed the steps in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009),
    you can just open the existing project for this chapter and go through the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Once your project is loaded, begin by creating a new empty scene. This can be
    done by navigating to `CarExhibition`.
  prefs: []
  type: TYPE_NORMAL
- en: By double clicking on it, you’re now inside the newly created scene that contains
    only a **Main Camera** and a **Directional Light**. You can delete the **Main
    Camera**, as it is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the VR Setup, we must first set the stage for our interaction.
    In this case, this means creating a dedicated area to house our two car exhibits.
    For the sake of simplicity, we’ll be fashioning our exhibition ground from a simple
    cube primitive. Achieve this by right-clicking in the Scene Hierarchy and selecting
    `20`, `0.1`, `20`). Now, rename the cube `ground`. This will form the foundation
    of our car exhibition.
  prefs: []
  type: TYPE_NORMAL
- en: The next section details how we can import cars from the Asset Store.
  prefs: []
  type: TYPE_NORMAL
- en: Importing cars from the Asset Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Animating cars in our scene requires the prerequisite step of importing them.
    Let’s walk through the process of importing the `simple cars pack` from the Unity
    Asset Store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Unity Asset Store ([https://assetstore.unity.com/](https://assetstore.unity.com/)).
    Search for the `simple cars pack` or, for a more direct route, access the package
    page via this link: [https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669](https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the package to your assets, find the **Open in Unity** button and
    click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This action should prompt the Unity application to open, presenting you with
    the option to import the package. Please proceed with the **Import** operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the import is successful, journey to the package’s directory in the project
    window. The path you’re looking for is **Assets** | **Simple Vehicle Pack** |
    **Prefabs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unleash the taxi into the scene at coordinates (`-6`,`0`,`0`) and adjust its
    scale to (`2`,`2`,`2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Occasionally, you might encounter a peculiar magenta hue on the object. This
    typically implies that the associated materials are missing or incompatible with
    the current rendering pipeline. To rectify this issue, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*URP Installation*: Before proceeding, ensure you have the URP installed, as
    it’s not included by default in the VR Template project. If it’s not installed,
    go to **Window** | **Package Manager**. Then, search for the URP and install it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head to `Assets` | `Simple Vehicle Pack` | `Materials` | `Cars_1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Cars_1` material selected, alter the **Shader** drop-down menu in
    the **Inspector** window to **URP |** **Lit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the small torus symbol next to `cars_albedo` to the `cars_metallic`
    to the **Metallic Map**, and **cars_AO** to the **Occlusion Map**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should restore the car’s normal appearance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Repeat this process for `Bus_1`, `Bus_2`, and `Cars_2` materials, ensuring the
    corresponding `bus_albedo`, `bus_albedo_2`, `bus_metallic`, `bus _AO`, and `cars_albedo_2`
    textures are assigned to the relevant maps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that making manual adjustments can be quite time-consuming.
    Fortunately, Unity offers a more streamlined solution for such scenarios. The
    **Render Pipeline Converter** is designed to handle bulk conversions of assets
    and shaders to the URP format. Here’s how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to **Window** | **Rendering** | **Render** **Pipeline Converter**.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. In the opened window, select the materials or shaders you want to convert.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Click **Convert**. The tool will then attempt to automatically adjust your
    selected materials or shaders for compatibility with URP.
  prefs: []
  type: TYPE_NORMAL
- en: Do keep in mind that while this is convenient for bulk operations, you might
    still need to verify each material to ensure it is converted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: With this task completed, revisit the `Assets` | `Simple Vehicle Pack` | `Prefabs`
    and let your creativity run wild by placing all the vehicles from the asset into
    our scene. Please note that in addition to the Taxi, we’re particularly interested
    in the `Police_car`, positioned at (`6`,`0`,`0`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that our cars have arrived at the scene, we’re ready to add the player and
    button prefabs in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the player, teleport anchors, and button to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin implementing our game logic into the VR experience, we must
    first add some additional GameObjects and prefabs to our scenes that are just
    as important for its functionality as the cars themselves. Let’s start with adding
    the player.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the player
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s imagine our scene as a stage and ourselves as the directors. In our toolbox,
    we’ve got this lovely XR Interaction setup prefab, a sort of puppet we can animate
    around our virtual stage. We highly recommend using the XR Interaction Toolkit
    version *2.5.1* by following the *Installing the XR Interaction Toolkit and Samples*
    section in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009). While the toolkit
    is consistently updated, newer versions might come with different prefabs. Let’s
    add and configure this prefab using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The XR Interaction setup prefab is easy to find; it’s nestled in the `Assets`
    | `Samples` | `XR Interaction Toolkit` folder. Search for the version you have,
    maybe it’s *2.5.1*, as recommended, or something newer. Then, dig through **Starter
    Assets** till you find **Prefabs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `Prefabs` folder and drag it right on the scene. Adjust it as needed
    to sit right at the center, at coordinates (`0`,`0`,`0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Successfully, we’ve integrated a player into our scene. Now, let’s enhance the
    experience by setting up teleport anchors at various points of interest within
    our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up two teleport anchors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For those new to VR, a great way to prevent motion sickness is to restrict
    movement to teleportation. The XR Interaction Toolkit provides us with three teleportation
    prefab options: **Teleport Anchor**, **Snapping Teleport Anchor**, and **Teleportation
    Area**. Think of **Snapping Teleport Anchor** as a specific point on our stage
    where the teleportation ray snaps to. In contrast, with **Teleport Anchor**, the
    teleportation ray will glide without snapping. However, both anchors essentially
    serve the same purpose: they’re designated spots where users can teleport. On
    the other hand, **Teleportation** **Areas** are expansive zones allowing user
    teleportation within their boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this particular scene, we will be using two snapping teleport anchors to
    ensure users teleport only to specific locations. Here’s how we can set them up:'
  prefs: []
  type: TYPE_NORMAL
- en: In our project window, navigate to `Assets` | `Samples` | `XR Interaction Toolkit`
    | `2.5.1` | `Starter Assets` | `DemoSceneAssets` | `Prefabs` | `Teleport`. Within
    this location, you’ll come across the just-described **Teleport** **Anchor**,
    **Snapping Teleport Anchor**, and **Teleportation Area**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the snapping teleport anchor from the `Teleport` folder and drop it into
    the `Taxi Teleport Anchor`. Position it at coordinates (`-2`, `0`, `0`) and scale
    it to (`2`, `1`, `2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop another snapping teleport anchor into the `Police_car Teleport
    Anchor`. Position it at (`2`, `0`, `0`) and scale it to the same size as the previous
    anchor: (`2`, `1`, `2`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once set up, your scene should resemble what’s illustrated in *Figure 5**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.1 – \uFEFFThe taxi and the police car with their teleport anchors](img/B20869_05_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The taxi and the police car with their teleport anchors
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll enhance the `Taxi Teleport Anchor` by adding a push button directly
    onto it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a push button for the taxi animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make our push button for the taxi animation stand out and be easily accessible,
    we’re going to place it on a pedestal created using a cylinder. This cylinder
    will serve as the button’s dedicated stand:'
  prefs: []
  type: TYPE_NORMAL
- en: To create this pedestal, right-click in the `Taxi Button Stand`. Adjust its
    size to dimensions (`0.2`, `0.5`, `0.2`) and position it at (`-2.7`, `0.55`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find the `Assets` | `Samples` | `XR Interaction Toolkit` | `2.5.1` | `Starter
    Assets` | `DemoSceneAssets` | `Prefabs` | `Interactables`. Once you've found it,
    drag and drop it onto the `Taxi Button Stand` in the `5`, `5`, `5`) and adjust
    its y-coordinate to `1.075` so it sits correctly on the pedestal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to *Figure 5**.2* to ensure that your scene looks as expected with the
    newly added push button. In the subsequent section, we’ll focus on setting up
    text buttons for the police car animations.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.2 – \uFEFFThe taxi button stand we just added to the scene](img/B20869_05_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The taxi button stand we just added to the scene
  prefs: []
  type: TYPE_NORMAL
- en: Adding text buttons for police car animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our police car, we’ll create a canvas that holds two buttons, enabling users
    to either shrink or enlarge the police car.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the canvas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Begin by creating a canvas: right-click in the hierarchy and select **XR**
    | **UI** **Canvas**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust its size dimensions. The correct size for our purpose is (`0.001`, `0.001`,
    `0`), making it a square. This scaling is essential for optimal viewing in the
    VR environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the canvas at coordinates (`3`,`1`,`-1`) and rotate it (`0`, `90`,
    `0`) towards the player’s direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re facing difficulties altering the UI Canvas properties, head to the
    Inspector window of the canvas component. Here, change the **Render Mode** from
    **Screen Space – Overlay** to **World Space**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjusting the Canvas components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the canvas selected in the **Scene Hierarchy**, open the **Inspector**
    window. Click on **Add Component** to attach new components to the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, add a `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Middle Center** for **Child Alignment**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Child Force Expand** for both width and height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For visual appeal, add an **Image** component to the canvas. In the **Image**
    component’s settings, set the source image to **UISprite** and choose a background
    color that complements your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Navigate to `Assets` | `Samples` | `XR Interaction Toolkit``2.5.1` | `Starter
    Assets` | `Prefabs` | `DemoSceneAssets` | `Prefabs` | `UI`. Here, you should find
    the **TextButton** prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop this prefab onto the **Canvas** twice. This will automatically
    place two **TextButton** prefabs as child objects beneath the **Canvas**. Due
    to the **Vertical Layout Group**, they’ll be aligned neatly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale them to (`0.4`, `0.4`, `0`) and rename the first button as `Scale Big
    Button` and the second one as `Scale` `Small Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Labeling the buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify the child text object of each button by unfolding them twice. With the
    `Text` GameObject selected, head to the Inspector window and search for the text
    component. Label one button as `Scale Big` and the other as `Scale Small`.
  prefs: []
  type: TYPE_NORMAL
- en: By following these steps, you’ll have a neatly organized UI ready for your police
    car animations, as shown in *Figure 5**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3 – \uFEFFThe text buttons for the police car animations](img/B20869_05_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The text buttons for the police car animations
  prefs: []
  type: TYPE_NORMAL
- en: Now our stage is set, it’s ready for the show and should look like *Figure 5**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.4 – \uFEFFThe current status of the CarExhibition scene](img/B20869_05_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The current status of the CarExhibition scene
  prefs: []
  type: TYPE_NORMAL
- en: Up next, we’re going to learn about the puppet strings, or in other words, the
    button events we can manipulate in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Interactable events that can be triggered
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interactable events, particularly those found in the **XR Simple Interactable**
    component, play a pivotal role in enhancing user experience. Such events, often
    tied to push buttons, facilitate diverse interactions within VR environments.
    There are many different options for interactable events. Imagine you are in a
    virtual reality car exhibition where you can interact with push buttons next to
    each car. Here’s how these events might apply in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First Hover Entered**: You approach a car and point at its information button
    for the first time. This event triggers a subtle glow around the button indicating
    it is selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hover Entered**: Each time you point at the button, the event renews the
    glow, showing that the button is currently the focus of your attention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hover Exited**: As soon as your hand or pointer moves away from the button,
    the glow dissipates, indicating that the button is no longer selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last Hover Exited**: The final time you move away from the button, the glow
    dissipates, and it seems as though the button subtly moves back to its original
    position, indicating that it’s no longer in focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First Select Entered**: The first time you press the information button,
    this event is triggered. It might cause the car’s information panel to appear
    with a smooth animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select Entered**: Each time you press the button, the car’s information panel
    appears, whether it’s the first press or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select Exited**: When you release the button, the panel begins to fade, indicating
    the end of the interaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last Select Exited**: The final time you release the button, it seems as
    though the panel not only fades but also shrinks back into the button, signifying
    the interaction’s conclusion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activated**: This event could be tied to a button in the car that starts
    the engine. Upon pressing, you hear the car’s engine roar to life.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deactivated**: When you press the button to turn off the car’s engine, this
    event is triggered. You hear the engine wind down to a stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sequence of events provides a natural, intuitive interaction flow for the
    user, enhancing the immersive feel of the VR car exhibition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll delve into how to choreograph these interactions
    and bring animations to life without writing a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding animations and animator systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity’s **animation system** functions like a mechanism for manipulating GameObjects
    by controlling their movement, rotation, size, color, and so on. It works by defining
    keyframes, which are specific states at certain times, and constructing an animation
    clip from these keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of a virtual door. An animation clip can illustrate the
    door’s movement from closed to open, and another clip can depict the door returning
    to its closed position.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure smooth transitions between these clips, Unity’s **Animator Controller**
    is used. This is a control system that directs the timing and sequence of the
    animation clips, transitioning between them based on specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: For the door example, the Animator Controller would manage the clips for opening
    and closing the door and transitioning between them at the right moment, possibly
    based on user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other examples that can be crafted using Unity’s animation system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object movement**: For an object moving across the screen, the animation
    system can create the movement, but additional scripting may be required to control
    it based on user interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object rotation**: A constantly spinning gear can be animated, but player-based
    control of the spin requires code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object scaling**: Scaling animation can depict an object’s growth, but linking
    this to other factors, such as energy level, requires scripting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color change**: An animation can be made for a changing light color, but
    synchronizing it with game conditions requires coding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera movement**: Camera movement between characters can be created using
    keyframes, but complex interactions with player movement might need additional
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blend shapes**: Facial expressions can be controlled using blend shapes,
    but they may need to be scripted to correspond to specific game dialogues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI animations**: A graphical UI element, such as a flashing button, can be
    animated, but stopping the animation when certain conditions are met (e.g., a
    race begins) requires a script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As seen in these examples, the animation system in Unity provides a powerful
    tool for bringing objects and scenes to life. However, adding scripts or coding
    to these animations unlocks a higher level of refinement and interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: In general, coding enables us to create animations in Unity that can respond
    to various inputs and game states, making them more dynamic. Coding also provides
    precise control over the animation, allowing for complex logic and customized
    interactions that cannot be achieved with Unity’s animation system alone.
  prefs: []
  type: TYPE_NORMAL
- en: While Unity’s animation system may not have the same level of complexity and
    fine control that coding offers, it still holds a significant place as a primary
    tool for creating interactions within Unity. The visual interface and intuitive
    controls allow for a rapid and user-friendly way to animate GameObjects, even
    without delving into scripts. This makes it accessible to both novice and experienced
    developers, enabling them to add life and movement to their game scenes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of this chapter, we will only be using the animation system,
    demonstrating how powerful and useful it can be on its own. Through hands-on examples,
    you’ll see how it’s possible to achieve engaging and interactive animations without
    relying on coding and how this tool can become a vital part of your XR development
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a 360-degree car rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive into the world of animation. Think of a spinning top: it goes round
    and round, and we want our taxi to do the same when we push a button. The twist
    is that when we let go of the button, the taxi should stop spinning. Sound fun?
    Here’s how we’ll make it happen using the magic of Unity’s animation system and
    UnityEvents without writing a line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we need to choreograph this spin for our taxi. Imagine
    it as a pirouette, a 360-degree turn on the taxi’s y-axis. Go through the following
    steps to bring this dance to life:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the `Assets` folder and select **Create** | **Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the taxi object in your scene and go to `RotateCar`, and save it in our
    newly minted `Animations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a 360-degree rotation for the y-axis by selecting **Transform** | **Rotation**
    and modifying your keyframes as shown in *Figure 5**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.5 – \uFEFFThe modified Keyframes to define a 360-degree rotation\
    \ for the y-axis](img/B20869_05_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The modified Keyframes to define a 360-degree rotation for the
    y-axis
  prefs: []
  type: TYPE_NORMAL
- en: Set the initial keyframes at `0:00` with `0` as the rotation; this is our taxi’s
    starting pose. Then, leap to `0:10` and give the `355`-degree spin. Why not 360?
    That would be like turning on a dime, too abrupt for our gentle spin.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `RotateCar` animation clip in the project window to view its settings
    in the Inspector. In the Inspector, give the **Loop Time** box a check to tell
    our taxi to keep repeating its spin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach an `RotateCar` animation clip into the **Controller** field of the **Animator**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will start our Taxi’s twirl right when we step into our virtual world.
    But remember, we want the spin to start only when we push the button. It’s time
    to make that happen:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to open the Animator Controller. Select the **Animator Controller**
    for our Taxi and double-click it to open the Animator Controller window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like a blank canvas, right-click in the `Idle`; it’s the calm before the Taxi’s
    spinning storm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click on the `Idle` state and set it as the **Layer Default State**.
    This tells the Animator Controller to start in this state, doing nothing when
    the scene begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then make a bridge from the `Idle` state to the `RotateCar` state: the state
    that initiates our taxi’s spin. To do this, right-click on `Idle`, choose `RotateCar`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let’s navigate to the `Rotate`. This parameter will initiate the transition
    from the `Idle` state to the `RotateCar` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the arrow representing the transition from `Idle` to `RotateCar`. In
    the `Rotate` parameter that we just created, as shown in *Figure 5**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.6 – \uFEFFThe Inspector window showing the newly added condition:\
    \ the Rotate trigger](img/B20869_05_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6 – The Inspector window showing the newly added condition: the Rotate
    trigger'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to halt our taxi’s spin once the button is released. Right-click
    on the `RotateCar` state, choose `Idle` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the `StopRotation`. This will initiate the transition from the `RotateCar`
    state back to `Idle`. Your parameters should now match what’s shown in *Figure
    5**.7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.7 – \uFEFFThe Parameters tab of the Animator window showing both\
    \ newly added parameters](img/B20869_05_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The Parameters tab of the Animator window showing both newly added
    parameters
  prefs: []
  type: TYPE_NORMAL
- en: Click on the transition arrow that goes from the `RotateCar` to the `Idle` state
    this time. Under `StopRotation` parameter as we did with the `Rotate` parameter
    earlier. Your **Animator** window should now resemble *Figure 5**.8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.8 – \uFEFFThe Animator window showing the current states and their\
    \ transitions](img/B20869_05_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The Animator window showing the current states and their transitions
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Animator.SetTrigger()`. Think of it as the cue for our Taxi to start
    or stop its dance. When the button is pressed (`Rotate`, and when the button is
    released (`StopRotation`. If set up correctly, your events will mirror those in
    *Figure 5**.9*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.9 – \uFEFFThe Select Entered and Select Excited events](img/B20869_05_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The Select Entered and Select Excited events
  prefs: []
  type: TYPE_NORMAL
- en: 'Well done! Your taxi is now set to dance to your button’s beats, spinning a
    full circle each time you press it. Don’t forget to try it out: give that button
    a good press and watch the taxi perform its 360-degree spin.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll delve into the magic of 2D text buttons on a canvas,
    learning how they can change a police car’s size to make it shrink or grow at
    the press of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a police car
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine the compelling possibilities of incorporating two additional interactive
    features in our VR auto show: one button to miniaturize the car and another to
    magnify it. Similar to our earlier interactions, we will employ a set of procedures,
    but this time with 2D buttons on a canvas. First, we create two animation clips
    that capture the essence of the car’s transformation as it scales up and down.
    Next, we create an Animator Controller: a crucial component that defines and manages
    the animation states. Lastly, we assign the corresponding trigger events to the
    button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s bring this magic to life with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the police car in the hierarchy. Open the Animation window (`ScaleCar`
    and store it in the `Animations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s choreograph the transformation. On the timeline in the Animation
    window, mark the beginning (`0:00`) and the end (`1:00`) with keyframes (the diamond
    icon). At the beginning, the scale of the car (`0`. At the end, the scale should
    be at its largest size; let’s go with `3`. This gives us an animation that sees
    the car scaling from minuscule to massive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don’t want our car continuously growing and shrinking. So, in the Inspector,
    uncheck the **Loop** **Time** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our police car needs an `ScaleCar`animation clip into the **Controller** field
    of the **Animator Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve got the growing part down, now let’s work on the shrinking. Create a second
    animation clip named `ShrinkCar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar to *step 2*, mark the beginning and the end with keyframes. This time,
    at the beginning, the scale of the car should be at its largest size (`3`). At
    the end, the scale should be at its smallest size (`0`). We’ve now reversed the
    transformation, creating an animation that shrinks the car from massive to minuscule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By now, we’ve successfully created two animation clips and an Animator Controller.
    If we were to play the scene, the police car would scale up once thanks to the
    unchecked loop checkbox and the absence of the downscaling animation in our Animation
    Controller. We’re one step closer to our transforming car. Ready for the next
    part? Let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to make our police car dance to our tune. We want it to change
    sizes when we wish and be idle when we don’t. That’s where the Animator Controller
    comes in. It’s our maestro, dictating when the car grows, shrinks, or takes a
    breather. Here’s how we bring this to life:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to open the Animator Controller. Locate the one assigned to the
    police car in the project window and double-click to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember our shrinking dance? Drag and drop the `ShrinkCar` animation clip into
    the **Animator Controller** window. It now has both the growing and shrinking
    routines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need a state of rest, a breather in between our dance routines. Right-click
    in the `Idle`. It’s like the calm before the storm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don’t want our car to start dancing right away when the curtain rises. So,
    set the `Idle` state as the default state. This ensures that when the scene begins,
    our car stands still, awaiting its cue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our maestro is ready to conduct. Right-click on the `Idle` state and choose
    `ScaleCar` and another time to the `ShrinkCar` states. Now, we’ve set the stage
    for our car to transition from standing idle to growing big and shrinking small.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But what cues the transitions? We need to set trigger parameters for this. In
    the `ScaleBig` and `ScaleSmall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the transition arrows. Under `ScaleBig` cues the transition from `Idle`
    to `ScaleCar`, while `ScaleSmall` cues the transition from `Idle` to `ShrinkCar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dance is never one-way. Our car needs to move smoothly from growing to shrinking
    and vice versa. So, create transitions from `ShrinkCar` to `ScaleCar``ScaleBig`
    trigger for the lower and the `ScaleSmall` trigger for the upper transition arrow,
    as shown in *Figure 5**.10*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 5.10 – \uFEFFThe Animator Controller of the police car](img/B20869_05_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The Animator Controller of the police car
  prefs: []
  type: TYPE_NORMAL
- en: Voila! Our police car is now ready to twirl to our commands. Try out the scene
    and watch as it gracefully grows and shrinks at your will by testing or deploying
    the scene onto your VR headset, as described in the *Deploying and testing VR
    experiences onto different VR platforms or simulators* section in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009).
    It’s a delightful sight, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Building interactive VR experiences with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have added interactions to our scene just by using Unity’s Animation
    system without writing a single line of code. In the next sections, you will learn
    how you can use scripting with C# to add even more complex breaths of air into
    your GameObjects and scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question we are going to answer is this: when do we need to write
    C# code for our animations and interactions?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when to use C# for animations and interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to understand that Unity’s animation and animator systems and
    the use of C# scripting are not mutually exclusive. They are often used together,
    with the animator controlling predefined animations and C# adding interactivity
    based on user input or other game events.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we rotated and scaled cars based using Unity’s animation
    and animator systems. These systems are primarily used to create predefined animations.
    We can divide this process into the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization event**: First, an event must occur to start the animation.
    This can be a button press, game event, collision, or any other trigger. In our
    example, to scale and rotate the cars, we used a physical push button and a 2D
    UI button. Unity’s built-in animation and animator systems are largely designed
    around the idea of predefined animations that are triggered under specific conditions.
    These conditions are typically defined within the Animator Controller itself and
    are usually based on parameters that you set up ahead of time, such as a boolean
    to track if a character is jumping or a trigger that gets activated when a button
    is pressed. This means that, with the built-in system, we do not have the ability
    to trigger animations based on virtually any event or condition in our game and
    have to work with the available events.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Animation**: Using Unity’s animation system, we define what changes during
    the animation (position, rotation, scale, etc.) by creating keyframes. For instance,
    we changed the rotation and scale of the cars with keyframes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ShrinkCar` state to a `ScaleCar` state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This system is perfect for creating animations that are predefined and occur
    under specific conditions; for instance, character animations (walking, running,
    jumping) or environmental animations (door opening, elevator moving).
  prefs: []
  type: TYPE_NORMAL
- en: 'While Unity’s built-in system excels at predefined animations, C# comes into
    play when animations need to respond dynamically to user input or other game events.
    Here, we follow similar steps as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization event**: The event that starts an animation can be anything,
    such as button presses, user input, or changes in the game state. The biggest
    difference with Unity’s built-in system is that with C# scripts, you have much
    greater flexibility and control over the initialization events for your animations.
    For instance, you can respond to complex sequences of input, such as a fighting
    game action combo. You can base animations on game logic or game state, such as
    an enemy’s health level or the player’s current score. You can trigger animations
    based on collisions, entering/exiting certain zones, or other physics events.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AI Decisions**: You can initiate animations based on the decisions made by
    an AI system. In a multiplayer game, you can trigger animations based on network
    events, such as another player’s actions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Animation**: Animations can be created in two ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the animation system to create keyframes as before and then use
    C# to control the playback of these animations (for example, play, pause, stop,
    or alter speed).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use C# to modify the properties of GameObjects directly,
    creating animations programmatically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State control**: With C#, you gain more direct control over when and how
    animations and transitions occur. You can create conditions based on any aspect
    of your game’s state, not just parameters in the Animator Controller. For example,
    you could change an NPC’s animation based on the player’s health or inventory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using C# for animations is ideal when the animation needs to respond in complex
    ways to the game state or user input. This is especially the case in the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time user input**: You often use C# to animate GameObjects in response
    to real-time user input. For example, in a flight simulator, you might animate
    the plane’s control surfaces (such as the ailerons, elevators, and rudder) based
    on the player’s joystick input. Since the exact position of these surfaces depends
    on the player’s input, it’s not something that can be predetermined with keyframes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics-based animations**: If your animation needs to incorporate or respond
    to physics, it often makes sense to animate it programmatically. For example,
    in a pool game, the balls move and spin based on physics calculations rather than
    predefined paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedurally generated content**: When the content of your game is procedurally
    generated, you often need to animate things programmatically because the exact
    nature of the animations can’t be predetermined. For instance, in a rogue-like
    dungeon crawler, the layout of the dungeon and the placement of enemies are generated
    on the fly, so any animations related to these elements would also need to be
    generated at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex AI behavior**: When creating complex AI behavior, you might use C#
    to animate GameObjects based on the AI’s decision-making processes. For instance,
    an enemy character might have an idle animation, a walk animation, and an attack
    animation, and you can use C# to decide which one to play based on the AI’s current
    state and the player’s position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood the scenarios in which it is useful to use C# for
    animations and interactions, let’s put our new knowledge to use by scaling a car
    using a slider in the following section. This would fall under the “real-time
    user input” category. When we want to scale a car using a slider, it’s the user
    input (moving the slider) that’s driving the animation (the scaling of the car).
    This kind of interaction can’t be predefined with keyframes because the exact
    scale of the car depends on the player’s input at any given moment. But before
    we add these to our scene, we first need to understand the very basics of the
    C# language, which are explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scripting with C# in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating scripts for VR development in Unity involves using C#. As a high-level
    language, it simplifies many computing complexities, making it user-friendly compared
    to languages such as C++.
  prefs: []
  type: TYPE_NORMAL
- en: Through its strong, static typing, C# helps you spot programming errors before
    running a game in Unity, which is incredibly helpful for developers. Additionally,
    it’s good at managing memory use, as it minimizes the risk of **memory leaks**—a
    situation where a game eats up an increasing amount of memory, potentially causing
    crashes.
  prefs: []
  type: TYPE_NORMAL
- en: C# is supported by Microsoft, which ensures you get reliable help, plenty of
    tools to work with, and access to a big community of other developers. And, importantly,
    just like Unity, C# works across many platforms.
  prefs: []
  type: TYPE_NORMAL
- en: When using C# in Unity, your coding is mostly event-based. This means you override
    certain Unity functions that get triggered at specific times, such as the `Start()`
    or `Update()` functions of a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when it comes to using C# for VR development in Unity, there are three
    key object-oriented programming concepts you’ll need to understand: variables,
    functions, and classes. Let’s get to know these a bit better.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Variables** are like storage boxes that your script uses to hold data. Every
    variable has a type, which tells you what kind of data it can hold. For example,
    if you’re using the XR Interaction Toolkit, you might have variables to store
    things such as the position of a VR controller, the state of an object in the
    virtual world, and so on. Let''s see an example of how we can use variables in
    the context of a C# script for Unity with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `grabInteractable` is an `XRGrabInteractable` object
    that represents a VR object that can be interacted with. `isGrabbed` is a private
    Boolean variable tracking whether the object is currently grabbed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think of **functions** (or methods) in C# as cooking recipes. Just like a recipe
    provides step-by-step instructions to cook a specific dish, a function in C# consists
    of a set of instructions that performs a specific task. You can reuse these recipes
    multiple times, either within the same script or across different scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, there are some special functions, such as unique cooking recipes,
    that are triggered at specific times during the life cycle of a script. Here is
    an overview of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Awake()`: This is like an alarm clock for your script. This function rings
    when the script first wakes up (or loads). Often, it’s used to set up variables
    or the state of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start()`: This is the runner on their mark, ready to start the race. This
    function gets called right before the first frame of the game is displayed. It’s
    also used to set things up, but unlike `Awake()`, it won’t run if the script isn’t
    enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update()`: This function is the heart of your game, beating once per frame.
    It’s usually used for tasks that need to happen regularly, such as moving objects
    around, checking for user input, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FixedUpdate()`: This is like `Update()`, but it runs at a consistent pace,
    no matter the frame rate. It’s typically used for physics-related tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LateUpdate()`: This is the function that tidies up after everyone else. It
    runs after all `Update()` functions have done their thing, doing any tasks that
    need to happen after everything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnEnable()`: This method is a special Unity method that gets called whenever
    the object this script is attached to becomes active in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when it comes to VR interactions, Unity’s XR Interaction Toolkit provides
    its own set of special functions that react to VR actions. Here are a few important
    ones you’ll want to know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnSelectEntered()`: This function is called when you select an interactable
    object in VR. Imagine it as the moment when you point at a virtual object with
    your VR controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSelectExited()`: This function is the moment when you stop selecting an
    interactable object. Think of it as letting go of the object you were pointing
    at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActivate()`: This is when you activate an interactable object. It’s a bit
    like pressing a button while you’re already holding the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDeactivate()`: This is when you deactivate the object. It’s like letting
    go of the button you just pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnHoverEntered()`: This function gets called when you start hovering over
    an interactable object. This could be used to make the object light up, for instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnHoverExited()`: This function is when you stop hovering over an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions can be combined in different ways to create all sorts of interactions
    in the virtual world. It’s like stacking building blocks together to create something
    more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MonoBehaviour`, `ScriptableObject`, or others to illustrate the characteristics
    of classes in C#. Let’s go through an example class called `XRGrab`, which inherits
    from the base class, `MonoBehaviour`. The first section of this class consists
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `XRGrab` class consists of two fields. `public
    XRGrabInteractable grabInteractable` is a reference to an `XRGrabInteractable`
    object. This script is typically attached to a GameObject that you want to make
    interactable in a VR or AR setting; for example, an object the user should be
    able to grab. `isGrabbed` is a boolean variable that keeps track of whether the
    interactable object is currently grabbed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of our class consists of methods. The first method of our
    class is called `OnEnable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `OnEnable()` method adds `Grabbed()` and `Released()` methods as listeners
    to the `onSelectEntered` and `onSelectExited` events of the `grabInteractable`
    object. This means when the user interacts with the object in the VR/AR world
    by selecting it, the `Grabbed()` method will be called, and when the user stops
    interacting with it and hence deselects it, the `Released()` method will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at what both of these methods might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `Grabbed()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Grabbed()` method sets `isGrabbed` to true, indicating that the object
    has been grabbed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s the `Released()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Released()` method sets `isGrabbed` to false, indicating that the object
    has been released.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, scripting in Unity using C# involves defining variables to hold
    data, implementing functions to manipulate that data or implement gameplay, and
    organizing these variables and functions into classes that represent objects or
    concepts in your game. The Unity engine then uses these scripts to drive the behavior
    of GameObjects within your scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the realm of C#, class names typically follow the **PascalCase convention**,
    where each word begins with an uppercase letter and underscores are absent. You
    have the freedom to select any name that pleases you, as long as it complies with
    the general naming conventions of C#. Here are the naming guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Names should commence with an uppercase letter instead of an underscore or a
    digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names can incorporate letters and digits but not underscores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spaces or special characters should not be part of the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the name must not be a reserved word in C#. Words such as “class”, “int”,
    “void”, and so on are reserved and cannot be employed as a name. This is because
    they have specific meanings in C#, as they are part of its syntax. The compiler
    expects them to be used in specific ways, so using them as identifiers would cause
    confusion and lead to compilation errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that’s a gentle introduction to scripting in Unity for VR development. Don’t
    worry if it still sounds a bit complex; like with any language, practice makes
    perfect, and this is exactly what you are going to do in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a bus using a slider and C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are about to embark on an exciting task: enriching our car exhibition experience
    by adding a dynamic scaling feature to a bus. Previously, we used fixed animations
    to scale a police car. However, this time, we will scale a bus in real time based
    on user interaction with a slider.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these steps, we will achieve our objective. So, let’s dive in:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to bring the bus into our scene. Go to `Assets` | `Simple Vehicle
    Pack` | `Prefabs`, drag and drop `Bus_2` into the scene. Position it at coordinates
    (`0,0,-6`), with a `-90` degree rotation on the y-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we require a slider and a descriptive text that indicates that the bus
    can be scaled using the slider. To accomplish this, we first need to create a
    canvas. Right-click in the hierarchy and select `0.01,0.01,0`), position it at
    (`0,1.5,-5`), and rotate it to (`0,180,0`). Now it is facing the player’s direction.
    Note that you must set the `Bus Scale Canvas` for clarity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One thing is missing before adding UI elements to the canvas: the **Vertical
    Layout Group** component. Let’s add this in the Inspector and change the **Child
    Alignment** property to the **Upper Center**. This ensures that both the slider
    and text will be vertically aligned at the upper center of the canvas.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we can add the slider. Right-click on the `0` and the `5`, allowing the
    bus to be scaled between these values. Let’s rename the slider to `Bus Scale Slider`
    for distinction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For enhanced user experience, we will also place a text above the slider. Add
    a `Slider` GameObject by right-clicking on `Bus Scale Slider`, select `Bus` `Scale
    Text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set up the slider, which serves as our initialization event, as
    shown in *Figure 5**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.11 – \uFEFFThe bus scale slider](img/B20869_05_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The bus scale slider
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we will link this with the scaling animation and state control
    via a single C# script. The idea is to bind the slider’s value to the bus’s scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with scripting, it’s advisable to maintain organization by
    creating a new folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the `Assets` folder, choose `Scripts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this new folder, create a new C# script and rename it `BusScaler`. This
    script will be our primary tool in bringing dynamic scaling to life.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now double-click on the script. This will open it in the IDE that is installed
    on your computer. This is the code we are going to develop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing the animation script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following explanations guide you on how the main components of the `BusScaler`
    script interact with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the following two lines of code to define your namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step of any C# script in Unity is to include `using` keyword is used
    to include namespaces in the script. `UnityEngine` contains all the classes needed
    for creating games in Unity, while `UnityEngine.UI` contains classes for creating
    and manipulating UI elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The class declaration follows next. In our script, let''s declare a new class
    named `BusScaler` with the following code sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class inherits from `MonoBehaviour`, which is the base class for all Unity
    scripts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, declare the variables of the `BusScaler` class with the following code
    sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `public` keyword means these variables can be accessed from other scripts
    and can also be set from Unity’s `bus` variable will hold the bus object in the
    scene and the `slider` variable will hold the slider UI object in the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s override the `Awake()` function to set up initial settings and
    references before the game starts. This includes setting the initial scale of
    the bus to `1` on the x-, y-, and z-axes. We do this with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our final step is to override the `Update()` function. Type or paste in the
    following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code retrieves the value of the slider (which ranges between its minimum
    and maximum values set in Unity’s Inspector) and sets the scale of the bus to
    this value on the x-, y-, and z-axes. This means if the slider’s value is `0.5`,
    the bus will be half its original size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing our animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that our C# script is finished, there are only a few steps left to complete
    until we can test our animation:'
  prefs: []
  type: TYPE_NORMAL
- en: In our C# script, the class `BusScaler` is derived from `MonoBehaviour`. To
    utilize this script, it needs to be associated with a GameObject within the Unity
    editor. To do this, right-click in the hierarchy and select `Bus` `Scaler Controller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you can drag your script and drop it into the **Inspector** panel of this
    new GameObject. This action will attach your script as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon doing this, you’ll notice that the public fields `bus` and `slider` become
    visible in the script component within the Unity editor. These fields need to
    be populated with the actual `bus` GameObject and the slider object this script
    will interact with. To do this, simply drag and drop these objects into the corresponding
    field, as shown in *Figure 5**.12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.12 – \uFEFFThe Inspector window of the Bus Scaler Controller with\
    \ the bus and slider objects placed into their corresponding fields in the Bus\
    \ Scaler script](img/B20869_05_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The Inspector window of the Bus Scaler Controller with the bus
    and slider objects placed into their corresponding fields in the Bus Scaler script
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step before you can test your interactive slider is to place a teleport
    anchor in front of it. This can be done by going back to our toolbox and navigating
    to `Assets` | `Samples` | `XR` `Interaction Toolkit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you’ll find the `Bus` `Teleport Anchor`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Position this anchor at coordinates (`0`,`0`,`-2.5`) and adjust its size to
    (`2`,`1`,`2`). With this setup, the user can now teleport to a position in front
    of the slider, enabling them to scale the bus interactively, as shown in *Figure
    5**.13*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.13 – \uFEFFHow the bus is scaled when the user interacts with the\
    \ slider in VR](img/B20869_05_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – How the bus is scaled when the user interacts with the slider
    in VR
  prefs: []
  type: TYPE_NORMAL
- en: Hurray, you have successfully completed all the steps needed for this animation.
    Now, it is time to explore your interactive VR scene once more. For this, follow
    the steps described in the *Deploying and testing VR experiences onto different
    VR platforms or simulators* section of [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to add interactivity into your VR scenes
    in Unity, using both code-dependent and code-free methods. By now, having successfully
    navigated through the steps provided in this chapter, you should have brought
    your Unity scene to life and acquired a solid understanding of and established
    a comfort level in deciding when to opt for Unity’s animator system and when to
    leverage the power of C# for your interactive scene creation needs.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve delved into the intricacies of triggering button events and utilizing
    the animator system, thereby equipping you with the skills to create simple yet
    effective interactions in your VR landscape without having to write a line of
    code. For more intricate interaction designs, you should now feel very familiar
    with the essential functions of C# in Unity and be familiar with the robust functionalities
    provided by the XR Interaction Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Be it industrial applications or academic projects, these skills and techniques
    should empower you to create immersive VR scenes in Unity using the XR Interaction
    Toolkit and its demo scene. You should feel ready to apply what you've learned
    to your unique use cases.
  prefs: []
  type: TYPE_NORMAL
- en: But our journey does not end here. In the forthcoming chapter, we’ll broaden
    our horizon by venturing into the creation of interactive AR and MR experiences
    in Unity. This will ensure that you are comprehensively equipped to add interactions
    across the spectrum of XR scenes. Let’s continue our exciting exploration into
    the world of immersive technology.
  prefs: []
  type: TYPE_NORMAL
