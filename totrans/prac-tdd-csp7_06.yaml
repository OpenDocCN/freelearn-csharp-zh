- en: Approaching the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195), *Tabula
    Rasa – Approaching an Application with TDD in Mind*, the details of the Speaker
    Meet application were discussed. The requirements have been defined at a very
    high level. A picture has been painted with very, very broad strokes. This is
    often how the concept for many applications begins, with a high-level description
    and an important key functionality defined. It may have started with a bar napkin
    or a whiteboard sketch, but somewhere, somehow an idea was formed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Speaker Meet application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural choices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define the problem, first the vision must be defined. Clear objectives should
    be described and outlined. The Speaker Meet problem came about as a result of
    technology speakers looking for a single, centralized place in which to find speaking
    opportunities and venues. It was determined that user group and conference organizers
    were equally in need of a solution to seek and find speakers for their meetings.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the idea for Speaker Meet was born. But, how would the application work?
    Should it be a mobile application or a website? How would the data be collected
    and managed? Would users be allowed to create their own profiles? Could users
    submit speaker, community, and conference information? Where would the application
    live and how would it be hosted? And where in the world do we begin?
  prefs: []
  type: TYPE_NORMAL
- en: Digesting the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem the application will be designed to solve has been defined. Speaker
    Meet will bring technology speakers, communities, and conferences together. Now
    that the purpose has been defined, it must be digested.
  prefs: []
  type: TYPE_NORMAL
- en: As was suggested before in a previous chapter, attacking a new application from
    all directions is ill-advised. It can be quite a daunting task to attempt to approach
    a new software project by implementing each and every desired feature all at once.
    It can also be a large chore to define every want and need of the system.
  prefs: []
  type: TYPE_NORMAL
- en: It would be far better to define small, manageable chunks of the application
    that can be delivered quickly in order to evaluate their correctness and effectiveness.
    The trouble is, how does one define what can be separated into small pieces and
    determine that this small piece is of sufficient value?
  prefs: []
  type: TYPE_NORMAL
- en: Epics, features, and stories; oh my!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many software development projects will maintain what is referred to as a *product
    backlog*. This is where everything that the system might be asked to do is compiled.
    The product backlog might contain the largest of ideas down to the most minute
    detail. The important thing is that these ideas are recorded.
  prefs: []
  type: TYPE_NORMAL
- en: The backlog should be regularly groomed and maintained. Items should be evaluated
    for their importance and ordered appropriately. If it is determined that an item
    is the next most important thing on which to be worked, it should be broken down
    into appropriately sized stories for the team to effectively deliver in a timely
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Epics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Larger, broader ideas are defined as *epics*. These could potentially be quite
    significant and wide-ranging in scope and size. Speakers would be defined as an
    epic. The speakers epic is a segment of the application devoted to anything and
    everything related to technology speakers.
  prefs: []
  type: TYPE_NORMAL
- en: The term epic is used to signify that the features and stories contained within
    the epic all revolve around a single, central idea. These essentially start life
    as a single, large user story, and are broken down into smaller features and stories.
    Epics can often take several sprints to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Features are generally smaller than epics and are contained within epics. A
    feature will usually contain many stories related to the subject matter it is
    responsible for. Think of features the same way you think of epics, they are just
    a smaller grouping.
  prefs: []
  type: TYPE_NORMAL
- en: A feature might comprise a s*peaker catalog* or s*peaker detail*. The speaker
    catalog might contain everything associated with displaying, sorting, filtering,
    and searching for speakers within the system. The speaker detail feature might
    define details and functionality regarding single, individual speaker information
    and how it is displayed within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on team preference, a story might be as small as seeing a speaker''s
    name when viewing their details. A word of caution: it is possible to have too
    small a story. It is better to break a story down so it''s just small enough and
    begin work than to waste time on minute details. If done correctly, the details
    will emerge during the development cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining what is small enough should be left to the team to decide. A good
    rule of thumb is that stories should take from half a day to three days to complete.
    Less than half a days' worth of work and the story will likely be broken down
    into pieces that are too small. More than three day's work and there is likely
    an opportunity to break the story into two or more stories.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to have too small a story.
  prefs: []
  type: TYPE_NORMAL
- en: Don't fall into the trap of breaking down stories into piece that are too small.
    Effort can be wasted by trying to compose smaller and smaller stories. If you're
    practicing Scrum, remember that small improvements can and should be proposed
    at the conclusion of each sprint. During the retrospective, story size and its
    effectiveness should be discussed. If it is decided that the size was not appropriate,
    whether that be too large or too small, adjustments should be made before the
    next sprint begins.
  prefs: []
  type: TYPE_NORMAL
- en: Maintain your backlog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So why is it so important to maintain the product backlog? A well-maintained
    backlog will define what the team should work on and help them plan for known,
    upcoming tasks. This will also help a team put together forecasting in order to
    plan for when a particular feature might be completed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If appropriate metrics are captured, a well-disciplined team can deliver a reliable
    velocity in each sprint. With appropriately sized and estimated stories a reasonable
    timeline can be predicted for upcoming items in the backlog. For example, if a
    team has reliably delivered 20 points per sprint and the next five stories have
    been estimated at 8 points each it would not be unreasonable to expect these five
    stories to be completed in about two sprints. Of course, this is not a commitment;
    it is merely an estimate.
  prefs: []
  type: TYPE_NORMAL
- en: The Speaker Meet problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the application scope will initially be kept small and limited
    in functionality. Some features might be identified now as an item for the future,
    but the limited scope for the Minimum Viable Product still needs to be better
    defined. More features will continue to be added to the product backlog and prioritized
    quite low if it is determined that they are not needed for a first release. Consider,
    though, that a minimum viable product still needs to deliver some value. A software
    application that doesn't do anything isn't worth much to anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the time to prioritize the potential value of features and stories will
    help decide what should be included in an initial release, and what can wait.
    By determining the effort involved to deliver specific functionality and combining
    that information with the proposed value, an educated decision can be made regarding
    which features will be delivered first.
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful separation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brainstorming the proposed features of the application will help to describe
    the system. Finding meaningful, logical separation will help define the scope
    of particular sections of the software solution. Logical boundaries could include
    epics and features as defined in the product backlog. They could also be determined
    by divisions in technology.
  prefs: []
  type: TYPE_NORMAL
- en: Speakers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The speaker epic will be made up of all of the features and stories surrounding
    the speakers portion of the application. This will include the speaker catalog
    and speaker details. This section will also contain any future enhancements and
    features that might be added at a later date. Future functionality might include
    speaker ratings and reviews, slide decks, and presentations, YouTube or Vimeo
    videos, and so on. These have yet to be determined and can be evaluated at a later
    date when a proposed value can be weighed.
  prefs: []
  type: TYPE_NORMAL
- en: Not all functionality needs to be decided up front. Remember, work towards a
    Minimum Viable Product and build functionality as it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some basic features stories for the speaker epic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are using a story format to describe detail at all levels of the application.
    That is, epics are presented as a story, themes or features are presented as a
    story, and specific requirements are presented as a story. In the hierarchy, only
    the specific requirements are called user stories though. The reason for giving
    them all the story format is simple. We want to be able to write a requirement
    and be able to transition it from user story to feature or even to epic with minimal
    hassle. So, we use the same format for a requirement regardless of the abstraction
    level of that requirement.
  prefs: []
  type: TYPE_NORMAL
- en: These feature stories are a good start. This will provide the business with
    an opportunity to grade and prioritize features before determining what should
    be worked on first. When presented to the team, these will likely need to be broken
    down into smaller, more detailed user stories with acceptance criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Good acceptance criteria will help the team determine when a story can be marked
    complete. If all conditions have been met, then the story is done and can be delivered.
    If at some point, it is decided that more work is needed in order to deliver the
    requested functionality, additional criteria should be included or new stories
    added to the backlog.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Communities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User groups and meetups comprise the community section of the application. The
    main purpose of this portion of the application is to provide a place for speakers
    and potential members and attendees to find and discover technical communities
    in their area. Anyone traveling to a specific city might also be interested in
    learning which user groups or meetups are available to them, whether for speaking
    purposes or general attendance. The community segment of the application will
    include the community directory and user group details. If any future enhancements
    are proposed, they can be added as new features or user stories to the community
    epic.
  prefs: []
  type: TYPE_NORMAL
- en: At some point in the near future, location search will be added to the community
    portion of the system. This would allow the user to search for communities based
    on distance, perhaps allowing speakers to determine communities within a 200-mile
    radius at which they may be interested in speaking. This feature was determined
    to be unnecessary for an initial release of the Speaker Meet application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A small list of community feature stories can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like the speaker feature stories, the community feature stories will help
    the product owner prioritize the functionality to be developed. These, too, will
    likely need to be broken down into smaller, more detailed user stories with acceptance
    criteria. Take a look at the stories here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Conferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The details and functionality within the application regarding conferences are
    defined and described in the conferences epic. This will include the conference
    catalog and conference details. Future enhancements and features proposed at a
    later date may be added to the conferences epic.
  prefs: []
  type: TYPE_NORMAL
- en: Conferences, too, may utilize location search. There are a variety of third-party
    services available and they can be evaluated for inclusion in a future release.
    Like all third-party code, these will be abstracted away from the main application,
    so that the system is insulated from potential changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Conferences differ from communities in that they happen only once per year
    and often have many speakers and sessions for the event. The conference feature
    stories will help the product owner prioritize the functionality to be developed.
    These, too, will likely need to be broken down into smaller, more detailed user
    stories with acceptance criteria. Take a look at the stories here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Separate by team function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many self-organizing teams split themselves by expertise. This might mean that
    members divide themselves into front-end developers, back-end developers, QA,
    and so on. Likewise, stories and tasks can be separated by functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It is best left up to the team to decide how to effectively organize themselves
    and their body of work. For example, Sally may be the most knowledgeable developer
    when it comes to the .NET framework, while Steve may have more expertise with
    React. It might prove better to let Sally take a majority of the back-end stories
    and let Steve focus on front-end functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is an easy pitfall to prioritize stories in such a manner that
    each team member has the most suitable work for them available. This will be efficient
    but not effective. Instead, priorities should focus on value delivered and optimized
    later on. There's no harm in letting someone (for example, Sally) work on UI features
    together with Steve when for example large UI design changes are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Technical separations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be a time when you must perform some work that doesn't fit neatly
    into the epics defined previously. Non-functionality requirements may include
    items related to the technology chosen for parts of the system. Stories could
    comprise purely web or front-end functionality, such as bundling JavaScript files.
    Alternatively, back-end or server-side functionality may need to be defined outside
    the previous epics.
  prefs: []
  type: TYPE_NORMAL
- en: There will likely be a number of non-functional or system specifications that
    will also need to be evaluated. Examples of these requirements might include response
    times, throughput, or memory consumption. These are commonly added to the checklist
    for *Definition of Done* so that each story should confirm the non-functional
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Many modern web-enabled applications are built as a **Single Page Application**
    (**SPA**) using JavaScript. These applications are hosted by a web server and
    delivered to a web browser on request. The entire application, or rather large
    pieces of the application, are delivered all at once. As requests are made by
    the client browser, the SPA will update the data on screen or mimic a page transition.
    Full-page postbacks and page reloading are not used with an SPA. This provides
    a perceptible increase in performance and increases in responsiveness for the
    end user. It also allows for distributing some of the processing of an application
    to client machines.
  prefs: []
  type: TYPE_NORMAL
- en: With this division of the SPA, much of the functionality can be split into *web*
    and *non-web* designations. A team may choose to write their stories in this way.
    Similarly, a team may choose to designate web specialists to work primarily on
    web-related functionality. One issue with this split is that the single story
    with just a front-end or back-end is not potentially shippable software. They
    do not separately deliver value. Instead, the story could be split by stripping
    out special case handling, offering only one purpose, keeping the UI simpler,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Like the web designation, a team may decide to separate stories into server-side
    or back-end functionality. This might cover all functionality from the API to
    the database and everything in between. The back-end of the Speaker Meet application
    is written in .NET with C# and Entity Framework Core and a SQL Server database.
    These technologies provide an excellent opportunity to create technical separations.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a consistent API, for example, is an excellent place to start. How
    the back-end might be further subdivided is discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Speaker Meet application has an assortment of technical requirements. Language
    choices and platform decisions can have an immense effect on an application. These
    decisions will determine how an application is delivered to a client and how many
    parts of the application are expected to behave.
  prefs: []
  type: TYPE_NORMAL
- en: Technology specifications can have a big impact on an application. Whether **LAMP**
    (**Linux, Apache, MySQL, PHP**/**Perl**/**Python**), **MEAN** (**MongoDB, Express,
    Angular, Node**), or in the case of Speaker Meet .NET and React, programming languages
    and frameworks can play a big role in a software system.
  prefs: []
  type: TYPE_NORMAL
- en: React web user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first *user interface d*efined for the Speaker Meet application is an SPA using
    React, a JavaScript library. React was written by the Facebook team for the purpose
    of developing modern web applications. This equates to the View in the traditional
    *Model-View-Controller* template. By using a one-way data flow model along with
    the *Virtual DOM*, React is an extremely powerful library that performs well and
    scales nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Many additional libraries will be included using the JavaScript package manager
    NPM. Additional libraries include webpack, a bundler for JavaScript, CSS, and
    other such files. More will be introduced in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary language for the server-side application will be C# in .NET Core.
    With the release of the latest overhaul to the .NET Framework, developers can
    choose which parts of the framework to include within their application and keep
    core level libraries to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way to expose internal information and behavior to an external system, and
    the SPA is considered an external system, is to provide an **Application Programming
    Interface** (**API**). The API layer exposes data functionality to the outside
    world. The primary gateway into the application is an assemblage of APIs using
    .NET Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the Speaker Meet application, an **Object-Relational Mapper** (**ORM**)
    is utilized to convert database objects into C# objects. There are many such ORMs
    available for a variety of different languages and platforms. In .NET alone there
    is NHibernate, LLBLGen, Dapper, and many more. For the Speaker Meet application,
    **Entity Framework** (**EF**) Core was selected.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an ORM mapper such as EF Core in and of itself is a requirement that
    will affect architectural choices for an application. The team will likely need
    to determine the pros and cons of ORM options available to them, and whether to
    use an ORM at all.
  prefs: []
  type: TYPE_NORMAL
- en: Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Speaker Meet application is hosted using Microsoft Azure. Choosing Azure
    allows the team to scale up or down parts of the application as demand arises.
    Of course, there are architectural decisions that must be made to effectively
    leverage the available functionality that Azure provides.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about upcoming or desired future functionality can allow a team to make
    wise decisions while developing parts of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Future enhancements are planned to employ the power of Azure Search. The core
    search functionality was written in such a way that switching to Azure Search
    would have minimal impact on the rest of the system. Implementing Azure Search,
    of course, would be developed using TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft SQL Azure is utilized to persist speaker information, user group and
    community particulars, information about conferences, as well as user login details.
    SQL Azure is very similar to using SQL Server on-premise, with a few caveats.
    For example, SQL Azure requires clustered indexes on each table. Knowing the requirements
    and differences of available database options allows the team to make an informed
    decision about their data storage choices.
  prefs: []
  type: TYPE_NORMAL
- en: An N-Tiered hexagonal architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous chapter, the N-Tiered architecture was discussed, where a software
    application is divided up into layers. N-Tiered applications are typically separated
    in successive layers, like the layers of a cake, from *A* to *B* to *C* and so
    on. There is a danger in defining an application in this way, as sometimes pieces
    of functionality don't cleanly fall into one layer. As long as the layers remain
    loosely coupled and functionality does not cross the boundaries, your application
    should remain well-structured and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hexagonal architecture was first described by Alistair Cockburn in the 2000s.
    Hexagonal architecture has also been referred to as ports and adapters, in which
    ports are abstractions and adapters are the implementations. This approach to
    designing applications changes the concept of layers to one of internal and external
    pieces to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some may argue that the hexagonal architecture and N-Tiered architecture are
    one and the same. While it''s possible to achieve a hexagonal architecture using
    an N-Tiered linear layered approach, the main distinction lies in how the layers
    interact with one another—linear or through specific ports and adapters: two distinct
    zones, internal and external bits. In the simplest of terms, a hexagonal method
    will save you in the event that something doesn’t fit neatly into a series of
    sequential layers and helps to prevent tight coupling between layers.'
  prefs: []
  type: TYPE_NORMAL
- en: The main thing to remember is that there are things that need to be separated—data
    source, user interface, third-party libraries, frameworks—essentially anything
    that isn't written by your team, possibly even the layers themselves. With the
    use of the *Dependency Inversion Principle*, as discussed in a previous chapter,
    and the *Repository Pattern,* coupling can be kept to a minimum. This allows for
    greater flexibility, maintainability, and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Greater flexibility can be provided by minimizing coupling between parts. New
    features can be plugged into the existing application. Existing parts of an application
    can be swapped out in favor of something else entirely. This simply cannot be
    done if existing parts of your application are tightly coupled to other parts.
  prefs: []
  type: TYPE_NORMAL
- en: If an application is segmented properly, it becomes much easier to maintain.
    By strictly adhering to the SOLID Principles as outlined in a previous chapters,
    this becomes almost effortless. With the strict adherence to hexagonal design
    and by keeping internal logic free from outside dependencies, it is simple to
    make modifications without impacts on other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a loosely coupled system is much easier than the alternative. By limiting
    the dependencies, tests can be limited to the functionality of the method, function,
    or system under test.
  prefs: []
  type: TYPE_NORMAL
- en: Basic yet effective N-Tiered divisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typical layers in a three-tiered application include presentation, business
    logic, and data access. These can be and often are subdivided even further, but
    this is a basic starting point for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: By dividing an application in this way, the first separation of concerns is
    born. Business logic should not be found in the presentation layer. Data access
    code should not be found in the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: A place for everything and everything in its place.
  prefs: []
  type: TYPE_NORMAL
- en: -Mary Poppins
  prefs: []
  type: TYPE_NORMAL
- en: Service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The business layer, or *service layer*, is where the business logic for the
    application resides. Whether you choose to use the idea of individual services,
    managers, or domain objects, the idea is effectively the same. The logic of the
    application should reside in a separate place from the presentation information
    and data access code.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have heard the term *microservices* at some point in your development
    career. These are typically very small, independent applications that serve one
    and only one purpose for the rest of the system. Whether they be standalone APIs
    or executables deployed to Azure Service Fabric, they can be developed and deployed
    independently from the rest of the application. Microservices tend to be small,
    reusable functions, often consumed by a number of different applications or deployed
    user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of littering the rest of the application with data persistence code,
    many applications rely on a data access layer of some sort. This allows for a
    centralized location of all data retrieval and storage procedures.
  prefs: []
  type: TYPE_NORMAL
- en: As the Speaker Meet application relies on EF Core, the data access layer is
    where much of this information will reside.
  prefs: []
  type: TYPE_NORMAL
- en: Repository Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Repository Pattern allows for abstraction between the domain layer and the
    data access layer. This allows for the rest of the application to be agnostic
    to the way data is persisted or retrieved. This allows for improved testability
    and for code reuse within the repositories themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Generic repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much of the data access functionality is the same across database models,
    a g*eneric repository* is used to minimize duplication of code. Many standard
    **CRUD** (**Create, Read, Update, Delete**) operations are used across all database
    objects. This provides the opportunity to create a generic repository to be used
    across all models and this will be covered in [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195),
    *Test Driving C# Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: As in life, often one size does not fit all. While the generic repository fits
    most cases, there may come a time when you need to create a specific repository
    or to extend the generic repository. These instances should be carefully evaluated
    and a proper solution should be put in place for them.
  prefs: []
  type: TYPE_NORMAL
- en: User interface adapter layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user interface adapter layer is where a user interface can "plug in" to
    the rest of the application. The Speaker Meet application provides a collection
    of web APIs to provide data and functionality to external systems. The first such
    external system is the React SPA. Utilizing a user interface adapter layer allows
    for the replacement or addition of a new UI application. This could be in the
    form of native mobile application, a Facebook application, or integration with
    another external site such as Meetup.
  prefs: []
  type: TYPE_NORMAL
- en: User interface layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications have a dual N-Tiered approach with architectures on both
    the back-end and front-end. This means that as much planning and separation as
    is done on the server side, the same amount of effort could also be spent architecting
    a UI application.
  prefs: []
  type: TYPE_NORMAL
- en: With much of the functionality of an entire system being delivered to the client,
    the SPA in the case of the Speaker Meet system can be treated as a wholly independent
    application. It, too, must have its own application architecture specification.
  prefs: []
  type: TYPE_NORMAL
- en: Front-end business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Redux action creators allows for front-end business logic to be contained
    in a single layer or location. Within an action creator, behavior can be encapsulated
    and concerns separated. Reusable functions may be exposed, minimizing code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Front-end user interface layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components and containers provide the presentation to the end user. Reusable
    components should be created and kept small, and without external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Front-end data source layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using React with Redux, data will be stored in state on the client's machine
    by way of a reducer. The shape of the data store should be carefully planned and
    evaluated. If something is not shared by more than one component, then it should
    likely not be placed in state. If you need the same data to take on many shapes,
    consider the use of something such as React Reselect, which provides a way to
    transform or compute derived data for use throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a basic plan for your architecture you have to think about
    where you should begin your testing. There are a few options for where to start:'
  prefs: []
  type: TYPE_NORMAL
- en: You could choose to start testing at the data access or data source layers and
    work your way up to the user interface layers. This method is a back-to-front
    approach to testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could start at the user interface layers and work your way to the data access
    layers. Approaching the tests in this manner is a front-to-back method of testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, you could start testing in the business layers and work your way out
    to the hexagonal boundaries of the system. This method is an inside-out testing
    approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a demonstration of the three testing directions to be examined, the same
    scenario of user login will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Back-to-front
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most back-end developers have been taught to think in a database-first manner.
    This style of thinking will lead them to find that a back-to-front style of testing
    makes more sense. As mentioned previously, in back-to-front testing you start
    at the data access layers. Mentally you really start by imagining the data structure
    within the data source. Once a data source has been defined, you can move up a
    layer and begin thinking about the business layer's design. Finally, you can apply
    the models and functionality you have created to a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By starting in the data layer, you are presented with defining your data model
    as early as possible. For this application and the requirements you have received,
    we suggest you go with a SQL database and use an entity framework for your data
    connections. Since you are working in a relational database, you will need some
    kind of primary key. These keys are for relational database concerns and are often
    not mentioned in the system requirements. In a situation like this you might end
    up with a table that looks something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '| UserProfile |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **ID** | **Integer** | **Primary Key, Identity** |'
  prefs: []
  type: TYPE_TB
- en: '| Username | `Varchar(255)` | Unique, Not Null |'
  prefs: []
  type: TYPE_TB
- en: '| PasswordHash | `Binary(64)` | Not Null |'
  prefs: []
  type: TYPE_TB
- en: '| FirstName | `Varchar(255)` | Not Null |'
  prefs: []
  type: TYPE_TB
- en: Now that you have a table defined, you can see that, instead of having a simple
    password field, you must use a password hash for security reasons. The next step
    is to create the data access layer code that will interact with this table.
  prefs: []
  type: TYPE_NORMAL
- en: Start with tests to properly define the model. These tests will provide some
    of the validations defined in your requirements and put you in a good place to
    define the entity framework model builder relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These are the tests that will get you started testing the model, the rest is
    up to you as an exercise. At the end of it, you should have a model that looks
    similar to this one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this model is not too complicated, but could get that way quickly
    if the number of database fields needed to expand. This is only a partial example
    of what a user profile would look like. Before moving on, think about what other
    fields would be needed and how they might need to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a data transfer object, you need to be able to read that model
    into the application from the database. As mentioned in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195),
    *Setting up a JavaScript Environment*, in the *What to Know Before Getting Started*
    section, we prefer to use a repository pattern for this. As a quick recap, the
    repository pattern is a simple pattern that helps us deal with create, read, update,
    and delete operations on a data source.
  prefs: []
  type: TYPE_NORMAL
- en: We are only going to use as much of the `FakeRepository` as is needed. For now
    that means that we will only implement `Get` and `GetAll`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are using a `FakeRepository`, we can move on to business layer integration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `UserProfileDto` defined previously, you can now focus on the service
    needed to log on. As you will be dealing with the `UserProfileDto` and repository,
    call this the `UserProfileService`. It will house all the interactions in the
    app with user profile objects.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, you only need to worry about the logon capabilities of the system.
    You will create a `GetUser` method which will consume a username and return a
    `UserProfile`. Then you will use the `UserProfile` and a password to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: First, here is the starting test to create a `UserProfileService`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What we normally do at this point is create a new class and a folder structure
    to support tests related to the `UserProfileService`. Our next test class with
    be for testing the `GetUserProfile` method, so we will create the folder structure
    and add that test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now write tests for a `GetUserProfile` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we will let you implement the class method that will pass these
    tests. Remember, we only want to the write a minimal amount of code to pass the
    tests. You will also want to create tests to verify case insensitivity, if that
    is something you believe the system needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a user profile, you need to verify that the password supplied
    by the user is the correct password. We won't be getting into security concerns
    too much as part of this book, but you should know that passwords should be a
    one-way hash. Now, write the test to check the password before you move on to
    creating a user interface for logging in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now there is enough functionality for you to begin working on your user interface.
    In a C# web API, the user interface is an API controller. The basic tests needed
    for an API controller are that it exists and that it inherits correctly from the
    controller class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to make sure it has a logon method that accepts a username and
    password. That same method must also return either a 200 OK or 401 NOT AUTHORIZED,
    depending on the validity of the user information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: One of the downsides to approaching the application in this manner is that now
    almost all of our layers are concerned with an object that is almost an exact
    representation of the database. Normally, this is not a real problem. But database
    tables do change so what if our user profile table needs some touching up in the
    future? Our entire application will need to be updated at this point. Did you
    pick up on some of the side-effects of thinking about the application in a back-to-front
    way? If not, that is okay, but keep an eye open as you explore the two other directional
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Front-to-back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way that some developers choose to approach application design and implementation
    is from a user experience perspective. First, think about how the user would want
    to interact with the system, then design the system around that concept.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To attack the application in this way, first you must determine what you think
    the best user experience would be. It would probably be best if the user not only
    got notified whether the logon was accepted, but also received a message explaining
    to them the current status.
  prefs: []
  type: TYPE_NORMAL
- en: What would you call our controller when testing from this direction? The user
    is wanting to log on so, you should call it a logon controller.
  prefs: []
  type: TYPE_NORMAL
- en: As before, you need to test that your controller exists. Then test that it properly
    inherits from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can test for your API method. What should it be called? Think again
    about the user. They are trying to log on so, again, we should probably stick
    with something simple related to logon. The default post action on this controller
    should probably be the method used to activate a logon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With the front-to-back directional approach, you don't yet have any of your
    dependencies defined so you have no choice but to hardcode decisions. You can
    push those decisions back slightly, though.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an interface and move your valid user login into a fake logon service
    for that interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you are following along, you will need to update all the controller references
    in the tests to use this new fake logon service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an interface defined, you can write tests to create a service
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Building a data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a service, you can focus on the data layer. Believe it or
    not, this part is not really any different from what we did at this stage for
    the back-to-front approach.
  prefs: []
  type: TYPE_NORMAL
- en: We have managed to do one thing differently. We have created a contract for
    our data interaction. The rest of the table, if we are using a relational data
    store, could be anything and we don't care. We only care about the username and
    password hash. We only have ID because the `FakeRepository` requires it.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to program the repository that do not require this feature. We
    are not going to recreate the table from the previous example. It is the same
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Inside out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last directional approach that we are going to cover in this chapter is
    the inside-out approach. With the inside-out approach, you begin, not with the
    UI or the data source, but instead with the business rules defined in the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking back at our requirements, we can build tests and logic that are a one-to-one
    match for our requirements such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a registered speaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And given an invalid username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When attempting login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then an INVALID_USERNAME_OR_PASSWORD error occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Some significant changes are made by the next requirement in order to provide
    some latitude going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Given a registered speaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And given a valid username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And given a valid password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When attempting login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the user is granted access to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the last requirement that we were provided:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a registered speaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And given a valid username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And given an invalid password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When attempting login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then an INVALID_USERNAME_OR_PASSWORD error occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This last test was quite simple and closely resembles the first test we wrote
    for inside-out development. One thing to note, but which we are not showing here,
    is that we had to extend our `UserCredentials` class with the password hash property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user interface and data layers from this point is almost exactly
    like what we have shown in the earlier examples, so we will not show them here.
  prefs: []
  type: TYPE_NORMAL
- en: The tasks left for this example are abstracting the business layer behind an
    interface, using the business object in the UI, and creating the appropriate data
    configuration for the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've defined the Speaker Meet application in more detail. Architectural
    choices were discussed and a path has been set. Epics, features, and user stories
    have been covered in enough detail that we're now ready to take the next steps
    with the Speaker Meet application.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195), *Test
    Driving C# Applications*, we'll focus on test driving the C# API. Topics such
    as *fakes, stubs, *and *mocks* will be introduced to help you navigate the testing
    world.
  prefs: []
  type: TYPE_NORMAL
