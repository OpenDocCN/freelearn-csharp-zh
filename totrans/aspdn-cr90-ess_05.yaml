- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Data and Persistence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据和持久性
- en: Every application, at some point, will consume data, whether through services
    or even in a data source, such as a SQL Server database or MySQL. Interacting
    with the database is an important feature, and ASP.NET Core 9 offers mechanisms
    such as Entity Framework Core and easily integrates with other database interface
    providers, such as Dapper, a library optimized for abstracting data access in
    a simple way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序，在某个时刻，都会消耗数据，无论是通过服务还是甚至在一个数据源中，例如 SQL Server 数据库或 MySQL。与数据库的交互是一个重要的功能，ASP.NET
    Core 9 提供了诸如 Entity Framework Core 等机制，并且可以轻松地与其他数据库接口提供商集成，例如 Dapper，这是一个用于以简单方式抽象数据访问的库。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Connecting to a SQL database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 SQL 数据库
- en: Understanding SQL, NoSQL, ORM, and Micro ORM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 SQL、NoSQL、ORM 和 Micro ORM
- en: Working with Entity Framework core and Dapper
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Entity Framework core 和 Dapper 进行操作
- en: We will explore communication between web applications and databases using technologies
    such as Entity Framework and Dapper, in addition to understanding important concepts
    such as the use of ORM and different data persistence models.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用诸如 Entity Framework 和 Dapper 等技术之间的 Web 应用程序和数据库通信，以及理解诸如 ORM 的使用和不同的数据持久性模型等重要概念。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has some prerequisites in order to get the most out of it. Therefore,
    you will need to install Docker and Azure Data Studio.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，有一些先决条件需要满足。因此，您需要安装 Docker 和 Azure Data Studio。
- en: All source code and examples for this chapter can be found in the GitHub repository
    at [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05)
    .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码和示例都可以在 GitHub 仓库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05)。
- en: Docker installation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 安装
- en: We will use Docker as the basis for running a SQL database server. Using Docker
    will avoid the problems associated with installing databases on different operating
    systems as it is a portable option.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Docker 作为运行 SQL 数据库服务器的基准。使用 Docker 可以避免在不同操作系统上安装数据库时遇到的问题，因为它是一个可移植的选项。
- en: To install Docker, follow the instructions for your operating system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker，请遵循您操作系统的说明。
- en: Windows
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'Run the following command as an administrator on the terminal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上以管理员身份运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Mac
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac
- en: 'Access the following link and follow the tutorial for installation according
    to your processor: [https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac](https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac)
    .'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接，并根据您的处理器遵循安装教程：[https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac](https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac)。
- en: Linux
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: Docker supports **Ubuntu** , **Debian** , and **Fedora** . Use the instructions
    according to your platform at [https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/)
    .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 支持 **Ubuntu**、**Debian** 和 **Fedora**。请根据您的平台使用以下说明：[https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/)。
- en: Azure Data Studio
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Data Studio
- en: Azure Data Studio is a specialized database editor and will be used to perform
    database operations, such as table creation, inclusion, and record querying.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Data Studio 是一个专门的数据库编辑器，将用于执行数据库操作，例如创建表、插入和记录查询。
- en: 'Its installation is simple, and it supports different operating systems: [https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio](https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio)
    .'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其安装简单，并且支持不同的操作系统：[https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio](https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio)。
- en: Connecting to a SQL database
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 SQL 数据库
- en: In each chapter, we have learned about different aspects involving ASP.NET Core
    9 and how this platform provides a large number of resources for the development
    of the most diverse types of applications. Each application has a purpose, which
    is to process data that generates information for users. However, at some point,
    your application will end up interacting with a data persistence model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，我们都学习了涉及 ASP.NET Core 9 的不同方面以及该平台如何为开发各种类型的应用程序提供大量资源。每个应用程序都有一个目的，即处理生成用户信息的数据。然而，在某个时候，您的应用程序将最终与数据持久性模型交互。
- en: '**Data persistence** occurs in several ways, but in general, it is the serialization
    of information allocated in memory to the disk, which can be in the form of files,
    and commonly takes place using a data persistence platform, such as a **Database
    Management System** ( **DBMS** ) or non-relational data. We will discuss these
    two persistence models in more depth soon.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据持久性**以多种方式发生，但通常是将分配在内存中的信息序列化到磁盘上，这可以是文件的形式，通常使用数据持久化平台，如 **数据库管理系统**（**DBMS**）或非关系型数据来实现，我们将在不久的将来更深入地讨论这两种持久化模型。'
- en: Most applications use a persistence model based on databases such as SQL Server,
    Oracle, and MySQL. Each DBMS has models of administration, typing, and organization
    of resources; however, they share the same purpose of persisting data in a tabular
    format and use **Structured Query Language** ( **SQL** ) to manipulate and manage
    all persisted data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序使用基于数据库的持久化模型，如 SQL Server、Oracle 和 MySQL。每个数据库管理系统都有管理、类型和资源组织的模型；然而，它们共享将数据以表格格式持久化的相同目的，并使用
    **结构化查询语言**（**SQL**）来操作和管理所有持久化数据。
- en: ASP.NET Core 9 can communicate with different types of DBMS, but we will focus
    on the SQL Server database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 可以与不同类型的数据库管理系统（DBMS）通信，但我们将重点关注 SQL Server 数据库。
- en: 'For an application to connect to a database, the following are necessary:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序连接到数据库，以下内容是必要的：
- en: A database driver (a NuGet package)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库驱动程序（一个 NuGet 包）
- en: A connection string
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接字符串
- en: Access to the desired resource
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问所需资源
- en: With this model, we can connect to any database that has a NuGet package ported
    to the .NET platform, such as the **System.Data.SqlClient** package for SQL databases,
    allowing applications to easily implement a persistence model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模型，我们可以连接到任何已将 NuGet 包移植到 .NET 平台的数据库，例如用于 SQL 数据库的 **System.Data.SqlClient**
    包，这使得应用程序能够轻松实现持久化模型。
- en: Now that we know the principles related to the interaction between applications
    and data persistence, let’s learn how the ASP.NET Core 9 platform communicates
    with a SQL Server database.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了与应用程序和数据持久性交互相关的原则，让我们学习 ASP.NET Core 9 平台如何与 SQL Server 数据库进行通信。
- en: Preparing SQL Server
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 SQL Server
- en: In current versions of the .NET platform, they work mainly with the **dependency
    injection** ( **DI** ) design pattern, which allows the use of a technique called
    **inversion of control** ( **IoC** ), causing classes and their dependencies to
    be managed by the .NET dependency container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的 .NET 平台中，它们主要使用 **依赖注入**（**DI**）设计模式，该模式允许使用称为 **控制反转**（**IoC**）的技术，导致类及其依赖项由
    .NET 依赖项容器管理。
- en: DI in .NET
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中的 DI
- en: The DI pattern design’s main objective is to abstract the management of class
    instances and their respective dependencies. It is a common practice in most high-performance
    solutions. If you want to learn more about DI, visit [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0)
    .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DI 模式设计的主要目标是抽象类实例及其相应依赖项的管理。这是大多数高性能解决方案中的常见做法。如果您想了解更多关于 DI 的信息，请访问 [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0)
    。
- en: Through DI, we can register a class to control the connection to the database.
    We will work with this approach in the topic where we will learn about using the
    Entity Framework in the *Working with EF Core and* *Dapper* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 DI，我们可以注册一个类来控制对数据库的连接。我们将在学习使用 Entity Framework 的 *与 EF Core 和 Dapper 一起工作*
    部分时采用这种方法。
- en: For now, it is important to understand the fundamentals of communicating between
    an application and the database. We will use SQL Server as the DBMS and for this,
    you must consult the *Technical requirements* section and install the Docker Engine.
    How Docker works is beyond the scope of this book. However, its use will allow
    you to continue with the examples described in this chapter without any compatibility
    problems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，了解应用程序和数据库之间通信的基本原理很重要。我们将使用 SQL Server 作为 DBMS，为此，您必须查阅 *技术要求* 部分，并安装 Docker
    引擎。Docker 的工作原理超出了本书的范围。然而，它的使用将允许您继续本章中描述的示例，而不会出现任何兼容性问题。
- en: 'Let’s start configuring the database:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始配置数据库：
- en: 'The first step is to run a Docker container to run SQL Server. We will use
    the following command to start an instance of SQL Server:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是运行一个 Docker 容器来运行 SQL Server。我们将使用以下命令启动 SQL Server 的一个实例：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s review the preceding command:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的命令：
- en: '**docker run** : This uses the Docker Engine to run a container.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker run** : 这使用 Docker 引擎来运行容器。'
- en: '**-d** : This parameter is used to execute the command in the background.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d** : 此参数用于在后台执行命令。'
- en: '**-e** : These are definitions of environment variables, used when starting
    the container. In this case, the **ACCEPT_EULA** variable is configured to agree
    with Microsoft’s terms and the **MSSQL_SA_PASSWORD** parameter is where a password
    is defined for the SA user, the default SQL user administrator.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-e** : 这些是环境变量的定义，用于启动容器时使用。在这种情况下，**ACCEPT_EULA** 变量被配置为同意微软的条款，而 **MSSQL_SA_PASSWORD**
    参数用于定义 SA 用户的密码，这是默认的 SQL 用户管理员。'
- en: '**-p** : This defines the port of the host machine that will be used to communicate
    with port 1433 of the container. In this scenario, we’re defining the host and
    container ports as the same, 1433.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-p** : 这定义了主机机器的端口，该端口将用于与容器的 1433 端口通信。在这种情况下，我们定义主机和容器端口相同，为 1433。'
- en: '**mcr.microsoft.com/mssql/server:2019-latest** : This is the type and version
    of the Docker image that will be run.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mcr.microsoft.com/mssql/server:2019-latest** : 这是将要运行的 Docker 镜像的类型和版本。'
- en: Docker does all the magic of downloading the SQL Server image onto your machine
    and running it in a virtualized way. The preceding command will return a hash
    code indicating that the image is running.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Docker 会将 SQL Server 镜像下载到您的机器上，并以虚拟化的方式运行。前面的命令将返回一个哈希码，指示镜像正在运行。
- en: 'Now, run the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The running image will be listed as shown in *Figure 5* *.1* , and the number
    of images listed may be different if you already use Docker.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行的镜像将按 *图 5.1* 所示列出，如果您已经使用 Docker，则列出的镜像数量可能不同。
- en: '![Figure 5.1 – Docker image running](img/B21788_05_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 运行中的 Docker 镜像](img/B21788_05_1.jpg)'
- en: Figure 5.1 – Docker image running
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 运行中的 Docker 镜像
- en: Learn more about Docker
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 Docker 的信息
- en: 'To learn more about Docker, take a look at the following official documentation:
    [https://docs.docker.com/](https://docs.docker.com/) .'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Docker 的信息，请查看以下官方文档：[https://docs.docker.com/](https://docs.docker.com/)。
- en: 'Now that we have the image running, open **Azure Data Studio** , installed
    as described in the *Technical requirements* section, and click the **Create a
    connection** button, as highlighted in *Figure 5* *.2* :'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经运行了镜像，打开 **Azure Data Studio**，如 *技术要求* 部分所述安装，然后点击 **创建连接** 按钮，如图 5.2
    所示：
- en: '![Figure 5.2 – Creating a connection to the database](img/B21788_05_2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 创建数据库连接](img/B21788_05_2.jpg)'
- en: Figure 5.2 – Creating a connection to the database
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 创建数据库连接
- en: 'Fill in the fields as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写字段：
- en: '**Server** : **localhost,1433**'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器** : **localhost,1433**'
- en: '**Authentication type** : **SQL Login**'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证类型** : **SQL 登录**'
- en: '**User** **name** : **sa**'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名** : **sa**'
- en: '**Password** : **Password123**'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码** : **Password123**'
- en: Keep the other parameters as they are, then click **Connect** . In some cases,
    a popup will be displayed informing you about the use of certificates. Just click
    the **Enable Trust server certificate** button. This certificate is automatically
    created by Azure Data Studio, so don’t worry.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他参数不变，然后点击 **连接** 。在某些情况下，将显示一个弹出窗口，告知您有关证书的使用。只需点击 **启用信任服务器证书** 按钮。此证书由
    Azure Data Studio 自动创建，所以请放心。
- en: After making the connection, you will have access to the server, which only
    has the standard databases. Click on the **New Query** option and you will see
    a new tab, as shown in *Figure 5* *.3* , that we will use to create a database
    and a table.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接后，您将能够访问服务器，该服务器仅包含标准数据库。点击 **新查询** 选项，您将看到一个新选项卡，如图 *图 5* *.3* 所示，我们将使用它来创建数据库和表。
- en: '![Figure 5.3 – New Query tab](img/B21788_05_3.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 新查询选项卡](img/B21788_05_3.jpg)'
- en: Figure 5.3 – New Query tab
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 新查询选项卡
- en: Now, in the book GitHub repository, in the [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    folder, copy the code from the **InitialDb.sql** file and paste it into the **New
    Query** tab, created previously, in Azure Data Studio.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在本书的 GitHub 仓库中，在 [*第 5 章*](B21788_05.xhtml#_idTextAnchor078) 文件夹中，从 **InitialDb.sql**
    文件中复制代码，并将其粘贴到之前在 Azure Data Studio 中创建的 **新查询** 选项卡中。
- en: Then click the **Run** button. The **DbStore** database and the **Product**
    table will be created, and some products will be inserted as an example of data.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**运行**按钮。**DbStore** 数据库和 **Product** 表将被创建，并将一些产品作为数据示例插入。
- en: Now that we have prepared the SQL database, it’s time to create a simple console
    application, make the connection, and list the data from the product table.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 SQL 数据库，是时候创建一个简单的控制台应用程序，建立连接，并从产品表中列出数据。
- en: Using the SQL client
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SQL 客户端
- en: As mentioned previously, the .NET platform has more modern ways of establishing
    a connection to the database and we will talk more about this subject in the *ORM
    and Micro ORM* section. However, it is important that you understand the fundamentals
    of communication between an application and a database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，.NET 平台有更多现代的方式来建立数据库连接，我们将在 *ORM 和 Micro ORM* 部分更多地讨论这个主题。然而，了解应用程序和数据库之间通信的基本原理是非常重要的。
- en: To do this, we will create a console application and add the necessary NuGet
    package to connect to the previously prepared SQL Server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个控制台应用程序，并添加必要的 NuGet 包以连接到之前准备好的 SQL Server。
- en: 'Then, we’ll open the terminal in a folder of your choice and execute the following
    commands in sequence:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您选择的文件夹中打开终端，并依次执行以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the project ready, we will need to carry out the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 项目准备就绪后，我们需要执行以下步骤：
- en: Create a connection to the database. We will use the **SqlConnection** class.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建到数据库的连接。我们将使用 **SqlConnection** 类。
- en: Open the connection.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开连接。
- en: Create a SQL command that will be executed. We will use the **SqlCommand** class.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将要执行的 SQL 命令。我们将使用 **SqlCommand** 类。
- en: Read data based on the SQL command. We will use the **SQLDataReader** class.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 SQL 命令读取数据。我们将使用 **SQLDataReader** 类。
- en: Display the data on the screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示数据。
- en: Close the connection.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭连接。
- en: 'In just six steps, we will be able to interact with a data source. The code
    in the **Program.cs** file must be identical to the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只需六个步骤，我们就能与数据源进行交互。**Program.cs** 文件中的代码必须与以下内容完全一致：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s discuss the most important details of this implementation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这个实现最重要的细节。
- en: 'The first step was to create the database connection class, **SqlConnection**
    , which receives a connection string as a parameter in the constructor. The connection
    string can be understood as the address of the database server. In this case,
    this address is made up of three basic properties: **Server** , **user id** ,
    and **password** . The default connection port is **1433** , which can be omitted,
    but you must explicitly define it if the connection port is different. These are
    the same parameters used previously to connect to the database through Azure Data
    Studio through the UI.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建数据库连接类 **SqlConnection**，它在构造函数中接收一个连接字符串作为参数。连接字符串可以理解为数据库服务器的地址。在这种情况下，这个地址由三个基本属性组成：**服务器**、**用户
    ID** 和 **密码**。默认连接端口是 **1433**，可以省略，但如果连接端口不同，则必须明确定义它。这些参数与之前通过 Azure Data Studio
    通过 UI 连接到数据库时使用的参数相同。
- en: The connection string offers several other types of parameters to determine
    how the connection will be made. The version we are currently using is the simplest.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串提供了几种其他类型的参数，用于确定如何建立连接。我们目前使用的是最简单的一种。
- en: Connection String
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'As mentioned, the connection string is made up of different parameters, including
    sensitive data such as username and password. For this reason, it is good practice
    to keep connection string management out of the source code, to prevent vulnerabilities
    and to prevent sensitive data from being available in the application’s version
    control. We will learn secure credential management approaches in [*Chapter 9*](B21788_09.xhtml#_idTextAnchor146)
    . More details about connection strings can be found in this great reference:
    [https://www.connectionstrings.com/sql-server/](https://www.connectionstrings.com/sql-server/)
    .'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，连接字符串由不同的参数组成，包括用户名和密码等敏感数据。因此，将连接字符串管理从源代码中分离出来是一种良好的做法，以防止漏洞并防止敏感数据在应用程序的版本控制中可用。我们将在[*第9章*](B21788_09.xhtml#_idTextAnchor146)中学习安全的凭证管理方法。有关连接字符串的更多详细信息，请参阅这个优秀的参考资料：[https://www.connectionstrings.com/sql-server/](https://www.connectionstrings.com/sql-server/)。
- en: After creating the **SqlConnection** object, it is time to open the connection
    using the **sql.Open()** code. Next, the **SqlCommand** class is created, where
    the constructor receives an SQL string and also the database connection object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建**SqlConnection**对象后，是时候使用**sql.Open()**代码打开连接了。接下来，创建**SqlCommand**类，其构造函数接收一个SQL字符串以及数据库连接对象。
- en: The SQL code used performs a simple query on the **Product** table, obtaining
    all available rows and columns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的SQL代码对**Product**表执行简单查询，获取所有可用行和列。
- en: '**SqlCommand** has different methods, such as **ExecuteNonQuery** , that are
    generally used to execute commands that change the database, such as **Insert**
    , **Delete** , and **Update** , or **ExecuteReader** , which is being used in
    this example to obtain data from the Product table. The **ExecuteReader** method
    returns an object of type **SqlDataReader** , which abstracts the rows and columns
    into an object, where it is possible to perform interactions and access table
    information.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**SqlCommand**有不同的方法，例如**ExecuteNonQuery**，通常用于执行更改数据库的命令，如**Insert**、**Delete**和**Update**，或者**ExecuteReader**，如本例中所用，用于从Product表获取数据。**ExecuteReader**方法返回一个**SqlDataReader**类型的对象，它将行和列抽象为一个对象，其中可以进行交互和访问表信息。'
- en: All this abstraction work is done by the **System.Data.SqlClient** library,
    which has access to the SQL Server database connection driver and provides several
    classes for manipulating data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些抽象工作都是由**System.Data.SqlClient**库完成的，它有权访问SQL Server数据库连接驱动程序，并提供几个用于操作数据的类。
- en: After obtaining the data by executing the **ExecuteReader** method, we finally
    iterate on the returned object by displaying the data obtained from the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行**ExecuteReader**方法获取数据后，我们最终通过显示从数据库获取的数据来迭代返回的对象。
- en: All code is protected by a **try..catch..finally** block to guarantee error
    handling and, above all, to close the connection at the end of use.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都通过**try..catch..finally**块进行保护，以确保错误处理，最重要的是，在结束时关闭连接。
- en: 'We can analyze the result of listing the database records in *Figure 5* *.4*
    :'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分析在*图5.4*中列出数据库记录的结果：
- en: '![Figure 5.4 – Displaying records in the Product table](img/B21788_05_4.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 显示Product表中的记录](img/B21788_05_4.jpg)'
- en: Figure 5.4 – Displaying records in the Product table
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 显示Product表中的记录
- en: Despite being a simple application, we learned important concepts and fundamentals
    related to interactions between applications and databases. We use SQL Server
    as a base, but the lessons learned apply to other data sources, such as MySQL
    or Oracle, varying, of course, the connection, command, and reading objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的应用程序，但我们学到了与应用程序和数据库交互相关的重要概念和基础知识。我们以SQL Server为基础，但学到的教训也适用于其他数据源，如MySQL或Oracle，当然，连接、命令和读取对象会有所不同。
- en: Furthermore, we prepared the basis of the environment for the remainder of the
    chapter, where we will explore other concepts, starting with the differences between
    relational and non-relational databases, in addition to understanding what ORM
    and Micro ORMs are.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们为本章剩余部分的环境准备奠定了基础，我们将探讨其他概念，从关系型数据库和非关系型数据库之间的区别开始，此外还将了解ORM和Micro ORM是什么。
- en: Understanding SQL, NoSQL, ORM, and Micro ORM
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SQL、NoSQL、ORM和Micro ORM
- en: With the emergence of different application structures and needs, different
    ways of managing data have also been developed. Choosing the right database and
    interaction methods has a significant impact on application performance, scalability,
    and maintainability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着不同应用程序结构和需求的出现，也发展出了不同的数据管理方式。选择合适的数据库和交互方法对应用程序的性能、可扩展性和可维护性有重大影响。
- en: Likewise, with the increase in systems complexity, new technologies for manipulating
    data obtained through DBMSs have also emerged, such as **Object-relational mapping**
    ( **ORM** ) and micro ORM. Each of the technologies has benefits for certain contexts,
    and it is important to know them correctly as there are no silver bullets.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，随着系统复杂性的增加，通过数据库管理系统（DBMS）获取数据的新技术也出现了，例如**对象关系映射**（**ORM**）和微型ORM。每种技术都在某些情境下有其优势，正确了解它们很重要，因为不存在万能的解决方案。
- en: SQL versus NoSQL
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL与NoSQL
- en: The complexity of applications and different data management needs have led
    to several challenges for companies, such as having suitable performance for managing
    large amounts of data, which leads to maintainability and scalability challenges.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的复杂性和不同的数据管理需求给公司带来了几个挑战，例如，为了管理大量数据而拥有合适的性能，这导致了可维护性和可扩展性的挑战。
- en: Along with these variables, keeping the servers running perfectly is expensive.
    **Relational Database Management System** ( **RDBMS** ) were the main means of
    tracking organizations’ information, and their approach in a relational model
    that prioritizes the integrity and relationship between information has defined
    how development teams handle data manipulation for years.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些变量一起，保持服务器完美运行是昂贵的。**关系型数据库管理系统**（**RDBMS**）是跟踪组织信息的主要手段，它们在关系模型中优先考虑信息的完整性和关系的方法已经定义了开发团队多年来处理数据操作的方式。
- en: '**Relational databases** have tables that represent a type of information.
    This information is distributed in columns, representing the characteristics of
    a piece of data. Complete data is determined in a row of a table. Tables can have
    relationships with other tables, associating different data to compose information.
    That’s why they are called relational models. The example in *Figure 5* *.5* shows
    some tables and their relationships, representing a data abstraction from a bank
    account application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系型数据库**中的表代表了一种信息类型。这种信息分布在列中，代表了一份数据的特征。完整的数据由表中的一行确定。表可以与其他表建立关系，将不同的数据关联起来以组成信息。这就是为什么它们被称为关系模型。*图5.5*中的一些示例展示了某些表及其关系，代表了一个来自银行账户应用程序的数据抽象：'
- en: '![Figure 5.5 – Basic bank account data model](img/B21788_05_5.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 基本银行账户数据模型](img/B21788_05_5.jpg)'
- en: Figure 5.5 – Basic bank account data model
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 基本银行账户数据模型
- en: In the figure, you can see that a customer has an account that has transactions.
    This is a basic representation of this context. But in large contexts, this relational
    structure model leads to different challenges for companies and follows the application
    development model based on how data should be persisted.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，你可以看到客户有一个有交易的账户。这是这个情境的基本表示。但在大型情境中，这种关系结构模型给公司带来了不同的挑战，并遵循基于数据应如何持久化的应用程序开发模型。
- en: Relational databases provide flexibility; however, basing applications on the
    data model shown in *Figure 5* *.5* leads to several challenges.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库提供了灵活性；然而，基于*图5.5*中所示的数据模型构建应用程序会带来一些挑战。
- en: Modern systems need to have flexibility and elasticity, and in some cases must
    be technology agnostic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统需要具备灵活性和弹性，在某些情况下还必须是技术中立的。
- en: With the emergence of the cloud, the possibility of having elastic resources
    also emerged. However, maintaining a cluster of data and synchronizing and managing
    it is not an easy or cheap task, even in cloud environments. Nowadays, through
    **Platform as a Service** ( **PaaS** ), such activities are abstracted by cloud
    providers; however, they come at a cost.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云的出现，弹性资源的可能性也随之产生。然而，即使在云环境中，维护数据集群、同步和管理它也不是一件容易或便宜的任务。如今，通过**平台即服务**（**PaaS**），这些活动被云提供商抽象化；然而，这需要付出代价。
- en: With the evolution of technology, other types of persistence models and different
    opportunities for applications and companies have emerged. One of the big terms
    generally misunderstood in the technical community a few years ago was the term
    **NoSQL** , which means **non-relational database** or **not-only SQL** .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步，其他类型的持久化模型和为应用和公司提供的机会也出现了。几年前在技术社区中普遍被误解的一个大词是**NoSQL**，它意味着**非关系数据库**或**不仅仅是SQL**。
- en: This persistence model has a different approach to the traditional relational
    model. NoSQL databases have a more flexible data structure that does not have
    many restrictions about how data will be persisted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种持久化模型对传统的关系模型有不同的方法。NoSQL数据库具有更灵活的数据结构，对数据如何持久化没有太多限制。
- en: For many years, NoSQL was seen as the new persistence model for DBMSs, causing
    companies to try to migrate to this model without fully understanding the fundamentals
    and using relational database approaches in NoSQL structures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，NoSQL被视为DBMS的新持久化模型，导致公司试图迁移到这种模型，而没有完全理解其基础，并在NoSQL结构中使用关系数据库方法。
- en: This way of interacting with a different source of data persistence had several
    benefits, including making developers, engineers, and companies change their perspective
    on application development, but focused on the business instead of how the data
    should be persisted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种与不同数据持久化源交互的方式带来了几个好处，包括使开发人员、工程师和公司改变他们对应用开发的看法，但更关注业务而不是数据应该如何持久化。
- en: In *Figure 5* *.6* , we can see most of the differences between relational databases
    and NoSQL databases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.6*中，我们可以看到关系数据库和NoSQL数据库之间的大部分差异。
- en: '![Figure 5.6 – Biggest differences in relational databases and NoSQL](img/B21788_05_6.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 关系数据库和NoSQL之间最大的差异](img/B21788_05_6.jpg)'
- en: Figure 5.6 – Biggest differences in relational databases and NoSQL
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 关系数据库和NoSQL之间最大的差异
- en: 'The NoSQL approach offers different types of data persistence that bring several
    benefits to applications. The most common are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL方法提供了不同类型的数据持久化，为应用带来了几个好处。最常见的是以下几种：
- en: Key-value stores ( Redis, Memcached)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值存储（Redis, Memcached）
- en: Document databases ( MongoDB, Couchbase)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据库（MongoDB, Couchbase）
- en: Column-family databases ( Cassandra, HBase)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列族数据库（Cassandra, HBase）
- en: Graph databases ( Neo4j, OrientDB)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图谱数据库（Neo4j, OrientDB）
- en: Likewise, the data manipulation model for NoSQL is different from relational
    databases, and query methods vary depending on the NoSQL database type and may
    not be as standardized as SQL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，NoSQL数据库的数据操作模型与关系数据库不同，查询方法根据NoSQL数据库类型而异，可能不如SQL标准化。
- en: Furthermore, it is important to understand that NoSQL databases often prioritize
    scalability, performance for specific query patterns, and flexibility to handle
    evolving data structures.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要理解NoSQL数据库通常优先考虑可扩展性、针对特定查询模式的高性能以及处理不断变化的数据结构的灵活性。
- en: But when should we use one approach over the other?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们何时应该使用一种方法而不是另一种方法？
- en: 'Let’s analyze the following table to understand the differences between persistence
    approaches:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下表格，以了解持久化方法之间的差异：
- en: '| **Feature** | **RDBMS** | **NoSQL** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **RDBMS** | **NoSQL** |'
- en: '| Structure | Rigid, predefined schemas | Flexible, adaptable, schemas can
    be schema-less or defined on-the-fly |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 结构 | 严格、预定义的架构 | 灵活、可适应，架构可以是无架构的或动态定义的 |'
- en: '| Scalability | Usually scales vertically (increase hardware power) | Often
    designed for horizontal scaling (adding more servers) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 通常垂直扩展（增加硬件功率） | 通常设计为水平扩展（添加更多服务器） |'
- en: '| Consistency | Strong ACID guarantees | Eventual consistency is common for
    faster writes |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 一致性 | 强大的ACID保证 | 最终一致性对于更快的写入是常见的 |'
- en: '| Querying | Powerful, expressive SQL queries | Varies by database type, potentially
    less powerful than SQL for complex relationships |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 查询 | 强大的、表达式的SQL查询 | 根据数据库类型而异，对于复杂关系可能不如SQL强大 |'
- en: '| Use cases | Data with rigid schemas, complex relationships, strong consistency
    needs | High-volume data, rapidly changing data models, high performance, specific
    query patterns, distributed systems |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 具有严格架构、复杂关系、强一致性需求的数据 | 高量数据、快速变化的数据模型、高性能、特定查询模式、分布式系统 |'
- en: Table 5.1 – Comparison between data persistence models
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 数据持久化模型比较
- en: As shown in *Table 5.1* , RDBMSs excel in predictable and structured data models,
    where data accuracy and relationships are key. NoSQL stands out in scenarios where
    flexibility, massive scalability, and high performance for specific needs take
    priority. Both are excellent proposals for different types of applications, with
    their varied applicability, such as an application persisting data in SQL Server
    and using Redis to manage the cache of some information, avoiding constant access
    to the database. Both approaches are used for the same application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *表 5.1* 所示，RDBMS 在可预测和结构化的数据模型中表现出色，其中数据准确性和关系至关重要。NoSQL 在需要灵活性、大规模可扩展性和针对特定需求的高性能的场景中脱颖而出。两者都是针对不同类型应用程序的优秀方案，具有不同的适用性，例如一个将数据持久化在
    SQL Server 中的应用程序，同时使用 Redis 来管理某些信息的缓存，避免频繁访问数据库。这两种方法都用于同一应用程序。
- en: Fortunately, ASP.NET Core 9 allows us to work with different types of data models
    because it is extensible and dynamic. Let’s delve a little deeper into two important
    concepts for manipulating data in relational databases, which are ORMs and Micro
    ORMs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ASP.NET Core 9 允许我们与不同类型的数据模型一起工作，因为它具有可扩展性和动态性。让我们更深入地探讨两个在关系型数据库中操作数据的重要概念，即
    ORM 和 Micro ORM。
- en: ORM and Micro ORM
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM 和 Micro ORM
- en: ORM is a technique that acts as a bridge between the world of **object-oriented
    programming** ( **OOP** ) and the relational world of databases. OOP models data
    as objects with properties and behaviors, while databases work with tables, rows,
    and columns.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 是一种作为面向对象编程（**OOP**）世界和数据库关系世界之间桥梁的技术。OOP 将数据建模为具有属性和行为的对象，而数据库则使用表、行和列进行操作。
- en: As we learned at the beginning of the chapter, we use objects such as **SqlConnection**
    , **SqlCommand** , and **SqlDatReader** to read data in SQL Server. This is a
    simple approach, but as businesses become more complex, it can be a big problem
    to work with obtaining and mapping data to apply the required business rules in
    the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所学的，我们使用诸如 **SqlConnection**、**SqlCommand** 和 **SqlDatReader** 这样的对象来读取
    SQL Server 中的数据。这是一个简单的方法，但随着商业的复杂性增加，获取和映射数据以在应用程序中应用所需业务规则可能成为一个大问题。
- en: In the example of the **Products** table, we implemented in the *Using the SQL
    Client* section, a SQL query was used to obtain all existing records. In real,
    large-scale applications, it is impractical for any interaction by users to be
    necessary to obtain all records from a table. This could cause serious performance
    problems in the application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 SQL 客户端* 部分实现的 **Products** 表示例中，我们使用 SQL 查询来获取所有现有记录。在实际的大型应用程序中，用户与任何交互都必需获取表中的所有记录是不切实际的，这可能会在应用程序中引起严重的性能问题。
- en: It is necessary to insert, delete, and update data, and even customize searches
    through filters, meaning that a SQL command is written for each situation. Furthermore,
    for data to be processed efficiently, it is necessary to abstract what persistence
    is and what the business domain is. In C#, we can work with the concept of **object
    orientation** at a high level and, in this context, ORM emerges as a powerful
    technique that allows us to focus on the business, in addition to other flexibilities.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 必须插入、删除和更新数据，甚至可以通过过滤器进行自定义搜索，这意味着为每种情况编写一个 SQL 命令。此外，为了有效地处理数据，有必要抽象化持久性和业务领域。在
    C# 中，我们可以在高层次上与面向对象的概念一起工作，在这种情况下，ORM 作为一种强大的技术出现，使我们能够专注于业务，同时提供其他灵活性。
- en: The implementation of an ORM on the .NET platform is called **Entity Framework**
    ( **EF** ). EF provides all the high-level mechanisms for manipulating and translating
    data either from objects to databases or from databases to C# objects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 平台上实现 ORM 被称为 **Entity Framework**（**EF**）。EF 提供了所有高级机制，用于从对象到数据库或从数据库到
    C# 对象的操作和转换数据。
- en: With EF, we don’t need to worry about writing SQL queries for the various operations
    in a database. EF also has other features, such as **migrations** , which allow
    you to update the database according to the developed code model, providing a
    great solution for database versioning.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EF，我们不需要担心为数据库中的各种操作编写 SQL 查询。EF 还具有其他功能，例如 **迁移**，允许您根据开发的代码模型更新数据库，为数据库版本控制提供了一个很好的解决方案。
- en: 'To better understand how ORM works, look at *Figure 5* *.7* :'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 ORM 的工作原理，请参阅 *图 5.7*：
- en: '![Figure 5.7 – Simple data model of a banking system](img/B21788_05_7.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 银行系统的简单数据模型](img/B21788_05_7.jpg)'
- en: Figure 5.7 – Simple data model of a banking system
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 银行系统的简单数据模型
- en: 'We know that it is possible to obtain data in a C# application, as we learned
    previously. To translate the data objects shown in *Figure 5* *.7* , it would
    be necessary to create three C# classes: **Customer.cs** , **Account.cs** , and
    **Movement.cs** . However, for each of the classes, it would be necessary to write
    different SQL queries to perform any operations on the database. Furthermore,
    for each business need, it would be necessary to map the data to C# classes and
    vice versa to persist data.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在 C# 应用程序中可以获取数据，因为我们之前学过。为了翻译 *图 5* *.7* 中显示的数据对象，需要创建三个 C# 类：**Customer.cs**、**Account.cs**
    和 **Movement.cs**。然而，对于每个类，都需要编写不同的 SQL 查询来执行对数据库的任何操作。此外，对于每个业务需求，都需要将数据映射到 C#
    类，反之亦然以持久化数据。
- en: This means that to obtain customer data, such as their accounts and transactions,
    it would be necessary to carry out at least three database queries, interact with
    **SqlDataReader** objects, and create the respective C# objects. Although it is
    not a very complex job, as the software becomes more complex, with various changes,
    this model becomes problematic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要获取客户数据，例如他们的账户和交易，至少需要进行三次数据库查询，与 **SqlDataReader** 对象交互，并创建相应的 C# 对象。尽管这不是一项非常复杂的工作，但随着软件变得更加复杂，各种变化使得这种模型变得有问题。
- en: Imagine changing the name of the **Description** column in the **Movement**
    table to **Event** . It would even be necessary to change all the SQL queries
    created in C#, in addition to the mappings. When it comes to more complex data
    models, maintenance difficulties and possible problems grow exponentially.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设将 **Movement** 表中的 **Description** 列的名称更改为 **Event**。甚至还需要更改在 C# 中创建的所有 SQL
    查询，以及映射。当涉及到更复杂的数据模型时，维护困难和可能出现的问题会呈指数级增长。
- en: 'When working with an ORM, this entire task is abstracted and less complicated.
    Fortunately, EF provides a great solution for this scenario, requiring the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM 时，整个任务被抽象化并简化。幸运的是，EF 为此场景提供了一个很好的解决方案，需要以下步骤：
- en: '**Connection string** : Database address and access credentials'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接字符串**：数据库地址和访问凭证'
- en: '**DbContext object** : Orchestrator of the connection to the database and management
    of objects and mappings'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DbContext 对象**：数据库连接和对象映射的协调者'
- en: '**DbSet** : Domain objects that will be mapped to database objects'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DbSet**：将被映射到数据库对象的域对象'
- en: EF Core manages all the communication with the database, mapping, and migrations,
    allowing developers to focus on the business.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 管理与数据库的所有通信、映射和迁移，使开发者能够专注于业务。
- en: 'The **DbContext** class for the example in *Figure 5* *.7* would look like
    this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5* *.7* 中的示例的 **DbContext** 类看起来是这样的：'
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will implement this class in more detail in the next section. At this point,
    it is important to understand that all the tables that will be managed by **DbContext**
    are properties of the class **BankingDbContext** with the type **DbSet** .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地实现这个类。在此阶段，重要的是要理解所有将由 **DbContext** 管理的表都是 **BankingDbContext**
    类的 **DbSet** 类型属性。
- en: The mapping of database objects is generally done by conventions, where EntityFramework
    Core compares the property names and types against the table column names and
    types in the database, but can be easily customized using specialized attributes
    or classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库对象的映射通常是通过约定完成的，其中 EntityFramework Core 将属性名称和类型与数据库中的表列名称和类型进行比较，但可以通过使用专门的属性或类轻松自定义。
- en: Conventions in EF Core
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 的约定
- en: To learn more about conventions, visit [https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions](https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions)
    .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于约定的信息，请访问 [https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions](https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions)
    。
- en: 'With mapping database conventions, we can obtain all the customers in the database
    through the **BankingDbContext** class, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过映射数据库约定，我们可以通过 **BankingDbContext** 类获取数据库中的所有客户，如下所示：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in the previous code, the **GetAllAccountsAsync** method searches
    for all the accounts in the database. The EF Core **ToListAsync** method will
    query the database asynchronously, returning a list of **Account** objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，**GetAllAccountsAsync** 方法在数据库中搜索所有账户。EF Core 的 **ToListAsync** 方法将异步查询数据库，返回一个
    **Account** 对象的列表。
- en: The preceding code shows a simple and powerful approach using ORM, without needing
    to manage the connection or write SQL commands, as they are generated by EF, in
    addition to there being no need to map database objects into classes. All these
    functionalities are already abstracted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用ORM的简单而强大的方法，无需管理连接或编写SQL命令，因为它们由EF生成，此外，无需将数据库对象映射到类中。所有这些功能都已抽象化。
- en: 'In this way, ORMs provide several benefits:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，ORM提供了以下好处：
- en: '*Reduced boilerplate code* : ORMs automatically generate much of the repetitive
    SQL code ( **SELECT** , **INSERT** , **UPDATE** ), allowing developers to focus
    on application logic, not data access code.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少样板代码*：ORM自动生成大量重复的SQL代码（**SELECT**，**INSERT**，**UPDATE**），使开发者能够专注于应用程序逻辑，而不是数据访问代码。'
- en: '*Enhanced productivity* : Working with objects is often more intuitive for
    developers who are used to OOP principles, speeding up development.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高生产力*：对于习惯于面向对象原则的开发者来说，使用对象通常更直观，可以加快开发速度。'
- en: '*Increased maintainability* : ORMs provide a certain level of abstraction between
    your application code and the specific database, making it easier to switch database
    providers or refactor your data model with less impact on your codebase.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高可维护性*：ORM在您的应用程序代码和特定数据库之间提供了一定程度的抽象，这使得切换数据库提供商或重构数据模型更容易，对代码库的影响更小。'
- en: 'However, ORM technologies have pros and cons to consider:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ORM技术有其优缺点需要考虑：
- en: '*Performance overhead* : In some cases, the SQL queries generated by an ORM
    might not be the most efficient. Experienced developers can often write more performant
    SQL by hand.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能开销*：在某些情况下，ORM生成的SQL查询可能不是最有效的。经验丰富的开发者通常可以手动编写更高效的SQL。'
- en: '*Potential abstraction issues* : ORMs can hide some of the underlying database
    concepts, which can be beneficial, but might make optimization or troubleshooting
    more challenging for those unfamiliar with database fundamentals.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*潜在的抽象问题*：ORM可以隐藏一些底层数据库概念，这可能是有益的，但可能会使那些不熟悉数据库基础的人优化或故障排除更具挑战性。'
- en: EF Core is in version 8 and, over the years, it has been improved, with different
    features added. However, we still recommend using the best technology offered
    to us wisely.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core目前处于第8版，多年来它得到了改进，添加了不同的功能。然而，我们仍然建议明智地使用我们所能提供的最佳技术。
- en: Although ORM technologies are becoming increasingly modern, there is still a
    concern about performance, especially when you have a complex data model, with
    several levels of relationships between objects. ORMs are often not capable of
    generating extremely performant queries, and, in some cases, it is necessary to
    use other resources, such as the Micro ORM approach learned at the beginning of
    the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ORM技术变得越来越现代，但仍然存在对性能的担忧，尤其是在您有一个复杂的数据模型，对象之间存在多个级别的关系时。ORM通常无法生成非常高效的查询，在某些情况下，有必要使用其他资源，例如本章开头学到的微ORM方法。
- en: In this context of facilitating work between the application and database objects,
    the concept of Micro ORM emerged.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在促进应用程序和数据库对象之间工作的情况下，微ORM的概念应运而生。
- en: '**Micro ORMs** are conceptually very similar to the ORM model. However, micro
    ORMs abstracts the database mapping objects into C# classes but prioritize performance.
    In some cases, they even provide some automatic generation of queries.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**微ORM**在概念上与ORM模型非常相似。然而，微ORM将数据库映射对象抽象为C#类，但更注重性能。在某些情况下，它们甚至提供一些查询的自动生成。'
- en: 'Some differences between Micro ORM and ORM are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 微ORM与ORM之间的差异如下：
- en: '*Footprint* : Micro ORMs have a much smaller code base and fewer dependencies,
    resulting in significantly less overhead.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*占用空间*：微ORM具有更小的代码库和更少的依赖项，导致显著减少开销。'
- en: '*Complexity* : Micro ORMs offer a basic set of features for mapping and executing
    queries, leaving behind many of the complexities found in traditional ORMs.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂性*：微ORM提供了一组基本的映射和执行查询的功能，而忽略了传统ORM中发现的许多复杂性。'
- en: '*Control* : With less abstraction, developers have more direct control over
    the SQL queries being executed.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制*：由于抽象程度较低，开发者对正在执行的SQL查询有更多的直接控制。'
- en: '*Features* : Micro ORMs typically lack these features often found in larger
    ORMs:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能*：微ORM通常缺乏在大型ORM中常见的以下功能：'
- en: Extensive object relationship management
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛的对象关系管理
- en: Change tracking
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更跟踪
- en: Automatic schema migrations
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模式迁移
- en: Identity maps (entity tracking to prevent duplicate payloads)
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识映射（实体跟踪以防止重复负载）
- en: There are some Micro ORM technologies commonly used by the .NET community, the
    most famous of which is called Dapper.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: .NET社区中常用的Micro ORM技术有一些，其中最著名的是Dapper。
- en: Dapper is open source
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper是开源的
- en: 'The Dapper library is open source and is constantly being updated. There is
    a comparison between different ORM engines, including EF Core, on GitHub: [https://github.com/DapperLib/Dapper](https://github.com/DapperLib/Dapper)
    .'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper库是开源的，并且正在不断更新。有关EF Core等不同ORM引擎的比较，可以在GitHub上找到：[https://github.com/DapperLib/Dapper](https://github.com/DapperLib/Dapper)。
- en: Using a Micro ORM does not preclude using an ORM. They can coexist in an application,
    depending on the need and context. It is important to keep in mind that this approach
    allows us to bring greater quality to our applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Micro ORM并不妨碍使用ORM。根据需要和上下文，它们可以在应用程序中共存。重要的是要记住，这种方法可以使我们的应用程序质量更高。
- en: In the next section, we will cover, in a practical way, the use of EF Core and
    Dapper based on the previously mentioned *bank* *account* concept.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将以实用的方式介绍EF Core和Dapper的使用，基于之前提到的*银行* *账户*概念。
- en: Now that we understand what an ORM and a Micro ORM are, the time has come to
    implement solutions using these approaches.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了ORM和Micro ORM是什么，是时候实现使用这些方法解决方案了。
- en: Working with EF Core and Dapper
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EF Core和Dapper
- en: ORM and Micro ORM are widely techniques used in modern applications due to their
    various benefits. As we have learned, ASP.NET Core 9 has several options for working
    with data models from different technologies. We will learn how to use EF Core
    as an ORM, and we will also use Dapper as a Micro ORM.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ORM和Micro ORM是现代应用程序中广泛使用的技术，因为它们具有各种优点。正如我们所学的，ASP.NET Core 9有几种处理来自不同技术数据模型的方法。我们将学习如何使用EF
    Core作为ORM，同时也会使用Dapper作为Micro ORM。
- en: EF Core
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EF Core
- en: Based on the example of the bank account data model, we have tables *Customer*
    , *Account* , and *Movement* , we will create a project to connect to the SQL
    database we configured at the beginning of the chapter, which is running in a
    Docker container.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基于银行账户数据模型的示例，我们有*客户*、*账户*和*交易*表，我们将创建一个项目以连接到本章开头配置的SQL数据库，该数据库运行在Docker容器中。
- en: The complete solution code will therefore be available in the GitHub repository
    mentioned in the *Technical* *requirements* section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完整的解决方案代码将在*技术要求*部分提到的GitHub仓库中可用。
- en: 'For this project, we will use a Minimal API project and, to do this, open the
    terminal in administrator mode and execute the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用Minimal API项目，为此，以管理员模式打开终端并执行以下命令：
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we need to add the EF Core libraries that will be necessary for the application
    to connect to the SQL server database. Additionally, we will need to install an
    EF CLI tool. This tool will be used to apply some updates to the database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加EF Core库，这些库对于应用程序连接到SQL服务器数据库是必需的。此外，我们还需要安装一个EF CLI工具。这个工具将用于对数据库应用一些更新。
- en: 'Run the following commands in the terminal:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE8]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first command installs the EF CLI tool, and the following commands are the
    EF libraries that will be used to connect the application to the database.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令安装EF CLI工具，接下来的命令是用于将应用程序连接到数据库的EF库。
- en: EF Core database providers
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core数据库提供者
- en: EF Core has the ability to work with different databases; it is not restricted
    to SQL Server. More details about the available providers can be found at [https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli](https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli)
    .
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core能够与不同的数据库一起工作；它不仅限于SQL Server。有关可用提供者的更多详细信息，可以在[https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli](https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli)找到。
- en: 'The project is now ready to be configured, and we will perform the following
    steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已准备好配置，我们将执行以下步骤：
- en: Configure the connection string.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置连接字符串。
- en: Create model classes.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模型类。
- en: Create a class that inherits from **DbContext** .
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自**DbContext**的类。
- en: Configure the **DbContext** created in the ASP.NET Core 9 DI container.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置在ASP.NET Core 9 DI容器中创建的**DbContext**。
- en: Add migrations.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加迁移。
- en: Update the database.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据库。
- en: As you perform these steps, you will notice some differences from implementing
    communication with the database in the traditional approach using **SqlConnection**
    , **SqlCommand** , and **SqlDataReader** .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这些步骤的过程中，您将注意到与传统方法使用**SqlConnection**、**SqlCommand**和**SqlDataReader**进行数据库通信的一些差异。
- en: 'Open the project in Visual Studio Code with the following command in the terminal:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中打开Visual Studio Code中的项目：
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The complete project has the structure shown in *Figure 5* *.8* :'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的项目结构如*图5.8*所示：
- en: '![Figure 5.8 – Banking project project structure](img/B21788_05_8.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 银行项目项目结构](img/B21788_05_8.jpg)'
- en: Figure 5.8 – Banking project project structure
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 银行项目项目结构
- en: To configure the connection string, we will use **appsettings.json** . It is
    important to mention that information containing user credentials should not be
    available directly in a code repository. The best practice is to use secrets or
    even a configuration server such as **Azure App Configurator** to manage this
    information. We’ll talk more about good security practices in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093)
    .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置连接字符串，我们将使用`appsettings.json`。重要的是要提到，包含用户凭据的信息不应直接在代码仓库中可用。最佳实践是使用密钥或甚至使用配置服务器，如**Azure
    App Configurator**来管理这些信息。我们将在[*第6章*](B21788_06.xhtml#_idTextAnchor093)中更多地讨论良好的安全实践。
- en: 'For teaching purposes, we will add the connection string to the **appsettings.json**
    file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了教学目的，我们将连接字符串添加到`appsettings.json`文件中：
- en: '[PRE10]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are using the same connection string as the database server running through
    Docker, with an additional default, **Database=dbBanking** , which will be used
    for this application. The JSON **ConnectionStrings** object is an ASP.NET Core
    9 convention, with each property of this object representing a different connection
    string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与通过Docker运行的数据库服务器相同的连接字符串，并添加了一个默认的**Database=dbBanking**，它将用于此应用程序。JSON中的**ConnectionStrings**对象是ASP.NET
    Core 9的约定，该对象的每个属性代表不同的连接字符串。
- en: EF Core does all the work of managing the connection and mapping database entities
    into C# objects, as well as generating SQL commands. For this to be possible,
    there is a base object that we must use to map the domain classes. This base object
    is called **DbContext** .
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core负责管理连接、将数据库实体映射到C#对象以及生成SQL命令的所有工作。为此，我们必须使用一个基对象来映射域类。这个基对象被称为**DbContext**。
- en: '**DBContext** implements the **Unit of Work** design pattern, managing all
    states of the objects manipulated in memory and persisting changes when necessary.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**DBContext**实现了**工作单元**设计模式，管理内存中操作的所有对象的状态，并在必要时持久化更改。'
- en: Unit of Work pattern
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元模式
- en: The Unit of Work design pattern is used in different contexts, favoring the
    separation of responsibilities, such as separating all the business rules of an
    application from the responsibility of communicating with and manipulating data
    in a database.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元设计模式在不同的上下文中被使用，它倾向于责任分离，例如将应用程序的所有业务规则与与数据库通信和操作数据的责任分离。
- en: Learn more about the Unit of Work pattern at [https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance](https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance)
    .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance](https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance)了解更多关于工作单元模式的信息。
- en: 'According to the project structure shown in *Figure 5* *.8* , we will create
    a class called **BankingDbContext.cs** that will have the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图5.8所示的项目结构，我们将创建一个名为**BankingDbContext.cs**的类，它将包含以下代码：
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the application we are creating, the class is quite simple. Let’s explore
    the most important points of this code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在创建的应用程序，该类相当简单。让我们探索这段代码最重要的几点：
- en: '**DbContext** : The **BankingDbContext** class inherits from the **DbContext**
    superclass, which has the necessary abstractions for communication between the
    application and the database, state management, mapping, and the generation of
    SQL commands.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DbContext**：`BankingDbContext`类继承自`DbContext`超类，该超类提供了应用程序与数据库之间通信、状态管理、映射以及生成SQL命令所需的必要抽象。'
- en: '**BankingDbContext** constructor: The class constructor receives, as a parameter,
    the generic **DbContextOptions<BankingDbContext>** class, which allows us to pre-define
    configurations that will be used in the DI container to create an instance of
    the **DbContext** object. The constructor can also receive a connection string;
    however, it is good practice to use the C# options pattern.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BankingDbContext** 构造函数：类构造函数接收一个参数，即泛型 **DbContextOptions<BankingDbContext>**
    类，这允许我们预定义在依赖注入容器中创建 **DbContext** 对象时将使用的配置。构造函数还可以接收一个连接字符串；然而，使用 C# 选项模式是一种良好的实践。'
- en: '**DbSet** : Each property of the **DbSet** type represents a table in the database,
    and it is these properties that provide information to EF Core to transform data
    from tables into objects and vice versa.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DbSet**：**DbSet** 类型的每个属性代表数据库中的一个表，这些属性为 EF Core 提供信息，以便将数据从表转换为对象，反之亦然。'
- en: C# options pattern
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: C# 选项模式
- en: The **options pattern** is widely used in the .NET platform with the aim of
    providing strongly typed access to groups of related settings.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**options pattern** 在 .NET 平台上被广泛使用，目的是提供对相关设置组的强类型访问。'
- en: Learn more about the options pattern at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern)
    .
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern)
    了解更多关于选项模式的信息。
- en: The **BankingDbContext** class is now complete and provides everything needed
    to interact with the SQL database. The mapping model used, in this case, is based
    on the EF Core convention, which infers the name of the table and columns from
    the name of the class and its properties.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**BankingDbContext** 类现在已经完整，提供了与 SQL 数据库交互所需的一切。在这种情况下使用的映射模型基于 EF Core 约定，该约定从类及其属性名称推断表和列的名称。'
- en: 'Let’s look at the **Account.cs** class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 **Account.cs** 类：
- en: '[PRE12]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Based on this class and the EF Core convention, it is expected that there will
    be a table named **Account** and columns called **Id** , **Name** , **Balance**
    , and **CustomerId** in the database.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本课程和 EF Core 的约定，预期数据库中将有一个名为 **Account** 的表，以及名为 **Id**、**Name**、**Balance**
    和 **CustomerId** 的列。
- en: But there is, in addition, a property called **Customer** and a collection of
    **Movement** objects. Due to the existence of the **CustomerId** property, EF
    infers that there is a relationship with the **Customer** table, which has a foreign
    key ( **<TableName>+Id** ) in the **Account** table. Likewise, because there is
    a **Movement** collection, EF infers that the **Account** class may have one or
    more **Movements** in the **Movement** table.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为 **Customer** 的属性和一个 **Movement** 对象的集合。由于存在 **CustomerId** 属性，EF 推断出与
    **Customer** 表存在关系，该表在 **Account** 表中有一个外键（**<TableName>+Id**）。同样，由于存在 **Movement**
    集合，EF 推断出 **Account** 类可能在 **Movement** 表中有一个或多个 **Movements**。
- en: However, if it is necessary to follow different naming standards from database
    to database, the names of tables, columns, primary keys, and so on can be mapped
    directly into the **DbContext** class using the fluent API. This can be done using
    data annotation in the domain classes, or even by implementing a specific mapping
    class for each entity using the **IEntityTypeConfiguration<TEntity>** interface.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果需要遵循不同的命名标准，则可以使用流畅 API 将表、列、主键等的名称直接映射到 **DbContext** 类中。这可以通过在域类中使用数据注释来完成，甚至可以通过实现每个实体的特定映射类来使用
    **IEntityTypeConfiguration<TEntity>** 接口。
- en: 'The following code example represents a custom or manual mapping of the **Customer**
    class to the **tbl_customer** table. In order to customize the mapping of classes
    in database entities, it is necessary to override the **OnModelCreating** method,
    inherited from the **DbContext** class:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例表示将 **Customer** 类手动映射到 **tbl_customer** 表的自定义映射。为了在数据库实体中自定义类的映射，需要重写从
    **DbContext** 类继承的 **OnModelCreating** 方法：
- en: '[PRE13]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in the code, it is possible to define all the attributes required
    for the correct mapping of entities.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，可以定义所有必要的属性以正确映射实体。
- en: With the **BankingDbContext** class finalized, we must configure it in the DI
    container and configure the connection string.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 **BankingDbContext** 类的完成，我们必须在依赖注入容器中配置它并配置连接字符串。
- en: 'We will add the following line to the **Program.cs** file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 **Program.cs** 文件中添加以下行：
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use the **AddDbContext<BankingDbContext>** extension method to configure
    the connection string that will be used for the connection. Note that we are using
    the **options** property, which is expected in the **DbContext** constructor,
    and through the use of the **UseSqlServer** extension method, we are recovering
    the connection string that we configured in the **appsettings.json** file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**AddDbContext<BankingDbContext>**扩展方法来配置用于连接的连接字符串。请注意，我们正在使用**options**属性，这是**DbContext**构造函数中预期的，并且通过使用**UseSqlServer**扩展方法，我们正在恢复在**appsettings.json**文件中配置的连接字符串。
- en: The application is practically ready to communicate with the database; however,
    it will still be necessary to add migrations and update the database.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序实际上已经准备好与数据库通信；然而，仍然需要添加迁移并更新数据库。
- en: 'Open the terminal in the project directory and run the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录中打开终端并运行以下命令：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command uses the EF CLI tool that we installed previously, adding migrations
    with the name **InitialDatabase** .
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用我们之前安装的EF CLI工具，并添加名为**InitialDatabase**的迁移。
- en: The objective of migrations is to allow the application and the database to
    remain synchronized in the objects that are used. In real applications, changes
    to the database, such as creating new tables or adding or removing columns, can
    happen constantly. These changes impact both the database in question and the
    application that consumes the objects in this database. When adding a migration,
    such as in the preceding command, we are taking a picture of the domain model
    that the application uses, and EF Core generates the scripts that will be applied
    to the database to keep it up to date.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的目的是使应用程序和数据库在使用的对象上保持同步。在实际应用程序中，数据库的更改，如创建新表或添加或删除列，可能会不断发生。这些更改会影响相关的数据库以及消耗该数据库中对象的相应应用程序。当添加迁移，如前面的命令中所示，我们正在对应用程序使用的领域模型进行快照，EF
    Core生成将应用于数据库以保持其最新的脚本。
- en: 'Migrations create a set of classes in the project. These classes must not be
    changed manually. As we can see in *Figure 5* *.9* , three files were added to
    the application’s **Migrations** folder:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移在项目中创建了一组类。这些类不应手动更改。正如我们在*图5.9*中看到的那样，三个文件被添加到应用程序的**Migrations**文件夹中：
- en: '![Figure 5.9 – Initial database migration files](img/B21788_05_9.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 初始数据库迁移文件](img/B21788_05_9.jpg)'
- en: Figure 5.9 – Initial database migration files
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 初始数据库迁移文件
- en: 'When observing a snippet of code extracted from the **InitialDatabase.cs**
    suffix file, we observe that they are resource creation scripts in the database:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当观察从**InitialDatabase.cs**后缀文件中提取的代码片段时，我们发现它们是数据库中的资源创建脚本：
- en: '[PRE16]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With each change in your application’s domain model, a new migration must be
    added. This way, you will maintain a history of changes, and this will facilitate
    the maintenance and evolution of the database and the application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序领域模型的每次更改，都必须添加一个新的迁移。这样，您将维护更改的历史记录，这将有助于数据库和应用程序的维护和演进。
- en: Now, you will need to update the database. So far, we have not run any SQL scripts
    on SQL Server, much less created the database. Instead of opening Azure Data Studio
    to perform this task, we will use the EF Core CLI tool to update the database
    according to the version mapped in the application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要更新数据库。到目前为止，我们还没有在SQL Server上运行任何SQL脚本，更不用说创建数据库了。我们不会打开Azure Data Studio来执行此任务，而是将使用EF
    Core CLI工具根据应用程序中映射的版本更新数据库。
- en: 'To do this, run the following command in the terminal, in the project directory:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请在项目目录中的终端运行以下命令：
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The CLI tool will connect to SQL Server and execute scripts to create the database
    and tables mapped in the application. *Figure 5* *.10* displays the created objects:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: CLI工具将连接到SQL Server并执行脚本以创建应用程序中映射的数据库和表。*图5.10*显示了创建的对象：
- en: '![Figure 5.10 – Objects created in the database using the EF CLI tool](img/B21788_05_10.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 使用EF CLI工具在数据库中创建的对象](img/B21788_05_10.jpg)'
- en: Figure 5.10 – Objects created in the database using the EF CLI tool
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 使用EF CLI工具在数据库中创建的对象
- en: 'All communication with the database has been properly configured. The time
    has come to add the APIs to interact with the database. Therefore, create the
    following routes in the **Program.cs** file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库的所有通信都已正确配置。现在是时候添加与数据库交互的API了。因此，在**Program.cs**文件中创建以下路由：
- en: '[PRE18]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The above routes perform operations on the Customer table. Notice the first
    Get method. This method receives as a parameter an instance of the **BankingDbContext**
    object that is automatically resolved through the .NET Core dependency injection
    DI context.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上述路由对客户表执行操作。注意第一个Get方法。此方法接收一个**BankingDbContext**对象的实例作为参数，该实例通过.NET Core依赖注入DI上下文自动解析。
- en: Then, using the **dbContext.Customers.ToListAsync(cancellationToken)** code,
    all existing customers in the database are retrieved. We only use the **Customers**
    **DbContext** and **DbSet** , and EF Core takes care of creating the SQL query
    to select the records. There is no need to open connections, create commands,
    or even map manually. Everything is done transparently.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用**dbContext.Customers.ToListAsync(cancellationToken)**代码，检索数据库中所有现有的客户。我们只使用**Customers**
    **DbContext**和**DbSet**，EF Core负责创建SQL查询以选择记录。无需打开连接、创建命令，甚至无需手动映射。所有操作都是透明完成的。
- en: 'The **Post** method performs the following operations:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**Post**方法执行以下操作：'
- en: '**dbContext.Customers.AddAsync** : The **Customer** object is passed as a parameter
    in the request body. This is then added to **DbSet** in the same way as we would
    add an item to a list.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dbContext.Customers.AddAsync**：将**Customer**对象作为请求体中的参数传递。然后以与我们向列表中添加项相同的方式将其添加到**DbSet**中。'
- en: '**dbContext.SaveChangesAsync** : When executing this method, **dbContext**
    updates the database. This means that if there were other operations on the **DbSets**
    , such as removal, updates, or additions, this information would only be updated
    in the database after executing the **SaveChanges** or **SaveChangesAsync** methods.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dbContext.SaveChangesAsync**：当执行此方法时，**dbContext**更新数据库。这意味着如果**DbSets**上有其他操作，例如删除、更新或添加，这些信息只有在执行**SaveChanges**或**SaveChangesAsync**方法后才会更新到数据库中。'
- en: Asynchronous processing and cancellation token
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理和取消令牌
- en: Asynchronous processing is a fundamental aspect of modern web application development.
    In ASP.NET Core 9, asynchronous methods allow the server to handle more requests
    simultaneously by not blocking threads during operations such as database queries,
    file access, or consuming HTTP resources. This approach allows the application
    to scale and respond quickly under load. The **async** and **await** keywords
    make it possible to write asynchronous code that is easy to maintain and read,
    and the .NET platform abstracts the complexity of managing asynchronous mechanisms.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理是现代Web应用程序开发的基本方面。在ASP.NET Core 9中，异步方法通过在操作期间（如数据库查询、文件访问或消耗HTTP资源）不阻塞线程，允许服务器同时处理更多请求。这种方法允许应用程序在负载下扩展并快速响应。**async**和**await**关键字使得编写易于维护和阅读的异步代码成为可能，.NET平台抽象了管理异步机制复杂性。
- en: In conjunction with asynchronous methods, it is a good practice to use cancellation
    tokens, which allow applications to properly handle the cancellation of requests,
    making applications more responsive and resilient. The cancellation token associated
    with an asynchronous method propagates a cancellation signal throughout all of
    the application’s asynchronous operations, allowing them to terminate early and
    free up resources. ASP.NET Core 9 and C# simplify asynchronous programming and
    the use of cancellation tokens, providing a robust framework that ensures applications
    remain responsive even under varying loads.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 结合异步方法，使用取消令牌是一种良好的做法，这允许应用程序正确处理请求的取消，使应用程序更具响应性和弹性。与异步方法关联的取消令牌在整个应用程序的异步操作中传播取消信号，允许它们提前终止并释放资源。ASP.NET
    Core 9和C#简化了异步编程和取消令牌的使用，提供了一个健壮的框架，确保应用程序即使在不同的负载下也能保持响应。
- en: For more information about asynchronous programming and token cancellation,
    visit [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)
    and [https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads](https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads)
    .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关异步编程和令牌取消的更多信息，请访问[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)和[https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads](https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads)。
- en: With this, we can run the application to interact with the database in a simple
    way, making it possible to perform any operations using **Language Integrated
    Query** ( **LINQ** ), such as advanced filters or obtaining records ordered by
    specific columns.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以运行应用程序以简单的方式与数据库交互，使得能够使用 **语言集成查询**（**LINQ**）执行任何操作，例如高级筛选或按特定列排序的记录。
- en: The use of an ORM provides several benefits for high-level applications and,
    likewise, several challenges when we delegate the management of data management
    complexity to the ORM. This makes them slow, since, despite several innovations
    and improvements, in many cases, they are not the best choice when it comes to
    performance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ORM 提供了高级应用的多项好处，同样，当我们把数据管理复杂性的管理委托给 ORM 时，也会带来一些挑战。这使得它们运行缓慢，尽管有多个创新和改进，但在许多情况下，它们在性能方面并不是最佳选择。
- en: In this case, Micro ORMs are great options; they have similar performance to
    traditional approaches and mapping capabilities like ORMs. Therefore, let’s explore
    how Dapper can be used to add more features to the database communication model.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Micro ORM 是很好的选择；它们具有与传统方法相似的性能和 ORM 的映射能力。因此，让我们探索如何使用 Dapper 来为数据库通信模型添加更多功能。
- en: Dapper
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dapper
- en: '**Dapper** is a Micro ORM that gives us the ability to interact with the database
    in a performative way while mapping database entities into C# objects.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dapper** 是一个 Micro ORM，它使我们能够以高效的方式与数据库交互，同时将数据库实体映射到 C# 对象中。'
- en: It is a simple-to-use yet powerful library. Its mapping model is interesting
    and flexible, allowing you to create different types of query result projections
    quickly and effectively.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个简单易用且功能强大的库。其映射模型有趣且灵活，允许您快速有效地创建不同类型的查询结果投影。
- en: Dapper and EF Core are not mutually exclusive technologies, and using both approaches
    in a project can provide great benefits.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper 和 EF Core 不是相互排斥的技术，在一个项目中同时使用这两种方法可以提供很大的好处。
- en: 'Let’s add the Dapper library to the project created previously by executing
    the following command in the terminal, in the application directory:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中执行以下命令，将 Dapper 库添加到之前创建的项目中，在应用程序目录下：
- en: '[PRE19]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All the prerequisites required to work with Dapper have already been implemented
    in the project, the main one being the connection string that we configured in
    the **appsettings.json** file.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，与 Dapper 一起工作的所有先决条件都已实现，其中最重要的是我们在 **appsettings.json** 文件中配置的连接字符串。
- en: 'Let’s change the **Program.cs** file to add two new routes that use Dapper
    to perform a query where we can obtain all the customers in the database and query
    a customer by **Id** :'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 **Program.cs** 文件，添加两个新的路由，使用 Dapper 执行查询，我们可以从中获取数据库中的所有客户以及通过 **Id**
    查询客户：
- en: '[PRE20]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s explore the preceding code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索前面的代码：
- en: In C# and ASP.NET Core 9, the **_ => new** syntax is known as discarded lambda
    and is used when there is no need to use the input parameter of the lambda expression.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 和 ASP.NET Core 9 中，**_ => new** 语法被称为丢弃 lambda，当不需要使用 lambda 表达式的输入参数时使用。
- en: '**SqlConnection** : We are adding the **SqlConnection** object to the DI container
    using the same connection string used by the **DbContext** . We are using the
    **AddScoped** method, which means that each time the **SqlConnection** object
    is used during a request, it will be reused.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SqlConnection**：我们正在使用与 **DbContext** 相同的连接字符串将 **SqlConnection** 对象添加到 DI
    容器中。我们使用的是 **AddScoped** 方法，这意味着每次在请求期间使用 **SqlConnection** 对象时，它将被重用。'
- en: '**QueryAsync** : We are getting all the customers from the database using a
    simple SQL query. The desired columns have been added to the SQL command, along
    with an **ORDER BY NAME** statement. **QueryAsync** is a **SqlConnection** extension
    method and, when it obtains the result, it will automatically map the data to
    C# objects based on the names of the properties and columns.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QueryAsync**：我们使用简单的 SQL 查询从数据库中获取所有客户。所需的列已添加到 SQL 命令中，以及一个 **ORDER BY NAME**
    语句。**QueryAsync** 是 **SqlConnection** 扩展方法，当它获取结果时，它将自动根据属性和列的名称将数据映射到 C# 对象。'
- en: Get all the data from the database
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中获取所有数据
- en: 'Generally, it is not recommended to fetch all the records from a database in
    a single query as there may be thousands or millions of records in the database
    tables, which can cause performance problems. Keep in mind that the example proposed
    here is intended to facilitate understanding of the concept and should not be
    used in production applications. The recommended solution is to use pagination.
    Pagination involves breaking data into small, manageable chunks. To learn more,
    the following page contains implementation examples: [https://learn.microsoft.com/en-us/ef/core/querying/pagination](https://learn.microsoft.com/en-us/ef/core/querying/pagination)
    .'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不建议在单个查询中从数据库中检索所有记录，因为数据库表可能有成千上万或数百万条记录，这可能导致性能问题。请记住，这里提出的示例旨在帮助理解概念，不应在生产应用程序中使用。建议的解决方案是使用分页。分页涉及将数据分成小块，便于管理。要了解更多信息，以下页面包含实现示例：[https://learn.microsoft.com/en-us/ef/core/querying/pagination](https://learn.microsoft.com/en-us/ef/core/querying/pagination)。
- en: '**QueryFirstOrDefaultAsync** : In the same way as the previous method, a query
    is made in the database and if the record is found, it will be returned and mapped
    to a Customer object. If the record is not found, then it returns the value **Null**
    . The important point in the SQL query is the use of the **@Id** parameter. Dapper
    methods can substitute named parameters in the string. So, after defining the
    SQL command with the parameters, we must define an object that contains the named
    properties of the same parameters as the parameters defined in the SQL command.
    In the code example above, the defined parameter is named **@Id** , which requires
    that the object passed as a parameter has a property named Id, like the snippet
    **new {Id = id}** . Using an object allows us to define more than one parameter
    if necessary.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QueryFirstOrDefaultAsync**：与之前的方法相同，在数据库中执行查询，如果找到记录，则将其返回并映射到Customer对象。如果没有找到记录，则返回值**Null**。在SQL查询中的重要点是使用**@Id**参数。Dapper方法可以在字符串中替换命名参数。因此，在定义带有参数的SQL命令后，我们必须定义一个包含与SQL命令中定义的参数相同的命名属性的同一参数的对象。在上面的代码示例中，定义的参数名为**@Id**，这要求传递给参数的对象必须有一个名为Id的属性，就像片段**new
    {Id = id}**。使用对象允许我们在必要时定义多个参数。'
- en: The use of SQL commands, in this case, allows us to create more performant queries
    for different purposes. Likewise, Dapper can be used to add, change, and remove
    records in the database.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用SQL命令允许我们为不同的目的创建更高效的查询。同样，Dapper也可以用来在数据库中添加、更改和删除记录。
- en: In this case, we do not need to manage the SQL connections that are controlled
    by the DI container, and we benefit from the ORM’s automatic mapping approach.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要管理由DI容器控制的SQL连接，并从ORM的自动映射方法中受益。
- en: Dapper SqlBuilder
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper SqlBuilder
- en: Dapper also has an extension that makes it easier to write SQL commands in the
    format needed by the Micro ORM called Dapper SQL Builder. It is a very useful
    extension, even when it is necessary to manipulate SQL strings according to some
    conditions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper还有一个扩展，使得编写Micro ORM所需的SQL命令格式更加容易，称为Dapper SQL Builder。这是一个非常有用的扩展，即使在需要根据某些条件操作SQL字符串时也是如此。
- en: You can find out more about the Dapper SQL Builder extension by visiting [https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder](https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder)
    .
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder](https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder)了解更多关于Dapper
    SQL Builder扩展的信息。
- en: As we have seen, both ORM and Micro ORM are great allies in the communication
    model with the database and can be used together, providing different benefits
    in different contexts.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，ORM和Micro ORM都是与数据库通信的强大盟友，可以一起使用，在不同的环境中提供不同的好处。
- en: This flexibility of ASP.NET Core 9 allows us to create different types of applications,
    from the simplest to the most complex, and interact with databases using best
    practices.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性使得ASP.NET Core 9能够让我们创建不同类型的应用程序，从最简单的到最复杂的，并使用最佳实践与数据库交互。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about data persistence in ASP.NET Core 9, exploring
    how applications interact with databases to store and manage critical information.
    You’ve compared the strengths of relational (SQL) and non-relational (NoSQL) databases,
    allowing you to choose the right fit for your project. Additionally, you’ve seen
    how ORMs such as EF Core simplify development by mapping objects to database records,
    and you’ve learned about the benefits of Micro ORMs such as Dapper for fine-grained
    control over performance-critical database operations.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了ASP.NET Core 9中的数据持久性，探讨了应用程序如何与数据库交互以存储和管理关键信息。你比较了关系型（SQL）和非关系型（NoSQL）数据库的优势，以便为你的项目选择合适的匹配。此外，你还看到了ORM（如EF
    Core）如何通过将对象映射到数据库记录来简化开发，以及Micro ORM（如Dapper）在精细控制性能关键数据库操作方面的好处。
- en: We’ll take another step toward developing high-quality applications by learning
    about security best practices in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093)
    . We’ll explore essential best practices and strategies for defending your applications
    against vulnerabilities. You’ll learn how to ensure user data protection, authentication
    security, and overall application integrity – vital foundations for building robust,
    reliable web applications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习[*第6章*](B21788_06.xhtml#_idTextAnchor093)中的安全最佳实践，再迈出一步，以开发高质量的应用程序。我们将探讨防御应用程序免受漏洞侵害的基本最佳实践和策略。你将学习如何确保用户数据保护、身份验证安全和整体应用程序完整性——这是构建强大、可靠的Web应用程序的重要基础。
