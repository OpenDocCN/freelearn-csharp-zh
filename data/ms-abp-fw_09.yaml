- en: '*Chapter 7*: Exploring Cross-Cutting Concerns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：探索横切关注点'
- en: Cross-cutting concerns such as authorization, validation, exception handling,
    and logging are fundamental parts of any serious system. They are essential to
    make your system secure and operate well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点，如授权、验证、异常处理和日志记录，是任何严肃系统的基本组成部分。它们对于使您的系统安全并良好运行至关重要。
- en: One problem with implementing cross-cutting concerns is that you should implement
    these concerns everywhere in your application, which leads to a repetitive code
    base. Also, one missing authorization or validation check may explode your entire
    system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实现横切关注点的一个问题是，您应该在应用程序的每个地方实现这些关注点，这会导致代码库重复。此外，缺少一个授权或验证检查可能会导致整个系统崩溃。
- en: One of ABP Framework's main goals is to help you apply the **Don't Repeat Yourself**
    (**DRY**) principle! ASP.NET Core already provides a good infrastructure for some
    cross-cutting concerns, but ABP takes it further to automate or make them much
    easier for you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架的主要目标之一是帮助您应用**不要重复自己**（**DRY**）原则！ASP.NET Core已经为一些横切关注点提供了一个良好的基础设施，但ABP将其进一步自动化或使它们对您来说更容易实现。
- en: 'This chapter explores ABP''s infrastructure for the following cross-cutting
    concerns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了ABP以下横切关注点的架构：
- en: Working with authorization and permission systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与授权和权限系统一起工作
- en: Validating user inputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Exception handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow along and try the examples, you need to install an **integrated
    development environment** (**IDE**)/editor (for example, Visual Studio) to build
    the ASP.NET Core projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随示例进行尝试，您需要安装一个**集成开发环境**（**IDE**）/编辑器（例如，Visual Studio）来构建ASP.NET Core项目。
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下GitHub仓库下载代码示例：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)。
- en: 'This chapter also references the *EventHub* project for some code examples.
    That project was introduced in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130),
    *Understanding the Reference Solution*, and you can access its source code from
    the following GitHub repository: [https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还引用了*EventHub*项目的一些代码示例。该项目在[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，“理解参考解决方案”中介绍，您可以从以下GitHub仓库访问其源代码：[https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub)。
- en: Working with authorization and permission systems
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与授权和权限系统一起工作
- en: '**Authentication** and **authorization** are two major concepts in software
    security. Authentication is the process of identifying the current user. On the
    other hand, authorization is used to allow or prohibit a user from performing
    a specific action in the application.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**和**授权**是软件安全中的两个主要概念。身份验证是识别当前用户的过程。另一方面，授权用于允许或禁止用户在应用程序中执行特定操作。'
- en: ASP.NET Core's authorization system provides an advanced and flexible way to
    authorize the current user. ABP Framework's authorization infrastructure is 100%
    compatible with ASP.NET Core's authorization system and extends it by introducing
    the permission system. ABP allows permissions to be easily granted to roles and
    users. It allows the same permissions to be checked on the client side too.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core的授权系统提供了一种高级且灵活的方式来授权当前用户。ABP框架的授权基础设施与ASP.NET Core的授权系统100%兼容，并通过引入权限系统对其进行扩展。ABP允许权限轻松地授予角色和用户。它还允许在客户端检查相同的权限。
- en: I will explain the authorization system as a mix of ASP.NET Core's and ABP's
    infrastructure by indicating which part is added by ABP Framework. Let's begin
    with the simplest authorization check.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过指出ABP框架添加的部分，将授权系统解释为ASP.NET Core和ABP基础设施的混合。让我们从最简单的授权检查开始。
- en: Simple authorization
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单授权
- en: In the simplest case, you may want to allow a certain operation only for those
    logged in to the application. The `[Authorize]` attribute, without any parameters,
    only checks whether the current user has been authenticated (logged in).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，您可能只想允许已登录到应用程序的用户执行某些操作。没有参数的`[Authorize]`属性仅检查当前用户是否已通过身份验证（登录）。
- en: 'See the following **model-view-controller** (**MVC**) example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下**模型-视图-控制器**（**MVC**）示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the `CreateAsync` and `DeleteAsync` actions are only usable
    by authenticated users. Suppose an anonymous user (a user that has not logged
    in to the application, so we couldn't identify them) tries to execute these actions.
    In that case, ASP.NET Core returns an authorization error response to the client.
    However, the `GetListAsync` method is available to everyone, even to anonymous
    users.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`CreateAsync` 和 `DeleteAsync` 操作仅对经过身份验证的用户可用。假设一个匿名用户（未登录到应用程序的用户，因此我们无法识别他们）试图执行这些操作。在这种情况下，ASP.NET
    Core会向客户端返回一个授权错误响应。然而，`GetListAsync` 方法对所有用户都可用，即使是匿名用户。
- en: 'The `[Authorize]` attribute can be used at the controller class level to authorize
    all the actions inside that controller. In that case, we can use the `[AllowAnonymous]`
    attribute to allow a specific action to anonymous users. So, we could rewrite
    the same example, as shown in the following code block:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Authorize]` 属性可以在控制器类级别使用，以授权该控制器内的所有操作。在这种情况下，我们可以使用 `[AllowAnonymous]`
    属性来允许特定操作对匿名用户。因此，我们可以重写相同的示例，如下面的代码块所示：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, I used the `[Authorize]` attribute on top of the class and added `[AllowAnonymous]`
    to the `GetListAsync` method. This makes it possible to also consume that particular
    action for users who haven't logged in to the application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我在类上使用了 `[Authorize]` 属性，并将 `[AllowAnonymous]` 添加到 `GetListAsync` 方法中。这使得也可以为尚未登录到应用程序的用户消费该特定操作。
- en: While the parameterless `[Authorize]` attribute has some use cases, you generally
    want to define specific permissions (or policies) in your application so that
    all authenticated users don't have the same privileges.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `[Authorize]` 属性（无参数）有一些用例，但您通常希望在您的应用程序中定义特定的权限（或策略），以便所有经过身份验证的用户都不具有相同的权限。
- en: Using the permission system
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用权限系统
- en: The most important authorization extension of ABP Framework for ASP.NET Core
    is the permission system. A permission is a simple policy that is granted or prohibited
    for a particular user or role. It is then associated with a particular functionality
    of your application and is checked when users try to use that functionality. If
    the current user has the related permission granted, then the user can use the
    application functionality. Otherwise, the user cannot use that functionality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架为ASP.NET Core最重要的授权扩展是权限系统。权限是一个简单的策略，它为特定的用户或角色授予或禁止。然后它与您的应用程序的特定功能相关联，并在用户尝试使用该功能时进行检查。如果当前用户拥有相关的权限授予，则用户可以使用应用程序功能。否则，用户不能使用该功能。
- en: ABP provides all the functionality to define, grant, and check permissions in
    your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ABP为您提供了在应用程序中定义、授予和检查权限的所有功能。
- en: Defining permissions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义权限
- en: 'We should define permissions before using them. To define permissions, create
    a class that inherits from the `PermissionDefinitionProvider` class. When you
    create a new ABP solution, an empty permission definition provider class comes
    in the `Application.Contracts` project of the solution. See the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，我们应该定义权限。要定义权限，创建一个继承自 `PermissionDefinitionProvider` 类的类。当您创建一个新的ABP解决方案时，一个空的权限定义提供者类会包含在解决方案的
    `Application.Contracts` 项目中。请参阅以下示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ABP Framework calls the `Define` method on application startup. In this example,
    I've created a permission group, named `ProductManagement`, and defined two permissions
    inside it. Groups are used to group permissions on the `string` values (it is
    suggested to define `const` fields instead of using magic strings).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架在应用程序启动时调用 `Define` 方法。在此示例中，我创建了一个名为 `ProductManagement` 的权限组，并在其中定义了两个权限。组用于在
    `string` 值上分组权限（建议使用 `const` 字段而不是使用魔法字符串）。
- en: 'That was a minimal configuration. You can also specify display names as localizable
    strings for the group, and permission names to show them in a user-friendly way
    on the UI. The following code block uses the localization system to specify the
    display names while defining the group and the permissions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小配置。您还可以指定用于组的本地化字符串显示名称，以及用于在用户界面中以用户友好的方式显示权限名称。以下代码块使用本地化系统在定义组和权限时指定显示名称：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I've defined an `L` method to simplify the localization. The localization system
    will be covered in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using
    the Features and Services of ABP*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个 `L` 方法来简化本地化。本地化系统将在[*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)中介绍，*使用ABP的功能和服务*。
- en: Permission Definitions in Multi-Tenant Applications
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户应用程序中的权限定义
- en: For multi-tenant applications, you can specify the `multiTenancySide` parameter
    for the `AddPermission` method, to define host-only or tenant-only permissions.
    We will return to this topic in [*Chapter 16*](B17287_16_Epub_AM.xhtml#_idTextAnchor457),
    *Implementing Multi-Tenancy*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多租户应用程序，您可以为`AddPermission`方法的`multiTenancySide`参数指定，以定义仅主机或仅租户的权限。我们将在[*第16章*](B17287_16_Epub_AM.xhtml#_idTextAnchor457)
    *实现多租户*中回到这个话题。
- en: Once you define a permission, it becomes available on the permission management
    dialog after the next application startup.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了权限，在下次应用程序启动后，它就会在权限管理对话框中可用。
- en: Managing permissions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理权限
- en: 'A permission can be granted for a user or role by default. For example, assume
    that you have created a manager role and want to grant the product permissions
    for that role. When you run the application, navigate to the `manager` role if
    you haven''t created it before; to do so, click on the **Actions** button and
    select the **Permissions** action, as shown in *Figure 7.1*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可以为用户或角色授予权限。例如，假设您已创建一个管理员角色并希望为该角色授予产品权限。当您运行应用程序时，如果之前没有创建该角色，请导航到`manager`角色；要这样做，请单击**操作**按钮并选择**权限**操作，如图*图7.1*所示：
- en: '![Figure 7.1 – Selecting the Permissions action on the Role Management page'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 在角色管理页面上选择权限操作'
- en: '](img/Figure_7.1_B17287.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.1_B17287.jpg)'
- en: Figure 7.1 – Selecting the Permissions action on the Role Management page
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 在角色管理页面上选择权限操作
- en: 'Clicking on the **Permissions** action opens a modal dialog to manage the permissions
    of the selected role, as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**权限**操作将打开一个模态对话框以管理所选角色的权限，如图所示：
- en: '![Figure 7.2 – Permission Management modal'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 权限管理模态框'
- en: '](img/Figure_7.2_B17287.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.2_B17287.jpg)'
- en: Figure 7.2 – Permission Management modal
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 权限管理模态框
- en: In *Figure 7.2*, you see the permission groups on the left-hand side, while
    the permissions in this group are available on the right-hand side. The permission
    group and the permissions we've defined are available in this dialog box without
    any additional effort.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.2*中，您可以看到左侧的权限组，而该组中的权限在右侧可用。权限组和我们所定义的权限可以在该对话框中无需额外努力即可使用。
- en: All users with the manager role inherit the permissions of that role. Users
    can have multiple roles, and they inherit a union of all permissions of all the
    assigned roles. You can also grant permissions directly to the users on the user
    management page for more flexibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有管理员角色的用户都继承该角色的权限。用户可以有多个角色，并且继承所有分配角色的所有权限的并集。您还可以在用户管理页面上直接授予用户权限，以获得更多灵活性。
- en: We've defined permissions and assigned them to roles. The next step is to check
    whether the current user has the requested permissions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了权限并将它们分配给了角色。下一步是检查当前用户是否有请求的权限。
- en: Checking permissions
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查权限
- en: You can check a permission either declaratively, using the `[Authorize]` attribute,
    or programmatically, using `IAuthorizationService`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用声明方式，使用`[Authorize]`属性，或使用`IAuthorizationService`以编程方式检查权限。
- en: 'We can rewrite the `ProductController` class (which was introduced in the *Simple
    authorization* section) to request the product creation and deletion permissions
    on specific actions, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`ProductController`类（在*简单授权*部分介绍）重写为在特定操作上请求产品创建和删除权限，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `[Authorize]` attribute, with this usage, takes a string parameter as a
    policy name. ABP defines permissions as automatic policies, so you can use a permission
    name wherever you need to specify a policy name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此用法，`[Authorize]`属性接受一个字符串参数作为策略名称。ABP将权限定义为自动策略，因此您可以在需要指定策略名称的地方使用权限名称。
- en: 'Declarative authorization is simple to use and recommended wherever possible.
    However, it is limited when you want to check permissions or perform logic for
    unauthorized cases conditionally. For such cases, you can inject and use `IAuthorizationService`,
    as shown in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式授权简单易用，在可能的情况下推荐使用。然而，当您想要条件性地检查权限或执行未经授权的情况的逻辑时，它是有局限性的。对于此类情况，您可以注入并使用`IAuthorizationService`，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `IsGrantedAsync` method checks the given permission and returns `true`
    if the current user (or a role of the user) has been granted the current permission.
    This is useful if you have custom logic for an unauthorized case. However, if
    you want to simply check the permission and throw an exception for unauthorized
    cases, the `CheckAsync` method is more practical:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsGrantedAsync` 方法检查给定的权限，如果当前用户（或用户的角色）已被授予当前权限，则返回 `true`。这在您有针对未经授权情况的自定义逻辑时很有用。然而，如果您只想简单地检查权限并在未经授权的情况下抛出异常，则
    `CheckAsync` 方法更为实用：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CheckAsync` method throws an `AbpAuthorizationException` exception if the
    user doesn't have permission to carry out that operation, which is handled by
    ABP Framework to return a proper `IsGrantedAsync` and `CheckAsync` methods are
    useful extension methods defined by ABP Framework.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有权限执行该操作，`CheckAsync` 方法将抛出 `AbpAuthorizationException` 异常，由 ABP 框架处理以返回适当的
    `IsGrantedAsync` 和 `CheckAsync` 方法。这些是 ABP 框架定义的有用扩展方法。
- en: 'Tip: Inherit from AbpController'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：从 AbpController 继承
- en: It is suggested to derive your controller classes from the `AbpController` class
    instead of the standard `Controller` class. This extends the standard `Controller`
    class and defines some useful base properties. For example, it has the `AuthorizationService`
    property (of the `IAuthorizationService` type), which you can directly use instead
    of manually injecting the `IAuthorizationService` interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从 `AbpController` 类而不是标准 `Controller` 类派生您的控制器类。这扩展了标准 `Controller` 类并定义了一些有用的基本属性。例如，它有
    `AuthorizationService` 属性（`IAuthorizationService` 类型），您可以直接使用它而不是手动注入 `IAuthorizationService`
    接口。
- en: Checking permissions on the server is a common approach. However, you may also
    need to check permissions on the client side.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上检查权限是一种常见方法。但是，您可能还需要在客户端检查权限。
- en: Using permissions on the client side
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端使用权限
- en: ABP exposes a standard HTTP API with a URL of `/api/abp/application-configuration`,
    which returns JSON data containing localization texts, settings, permissions,
    and more. Then, the client application can consume that API to check permissions
    or perform localization on the client side.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 提供了一个标准 HTTP API，URL 为 `/api/abp/application-configuration`，它返回包含本地化文本、设置、权限等
    JSON 数据。然后，客户端应用程序可以消费该 API 来检查权限或执行客户端的本地化。
- en: 'Different client types may provide different services to check permissions.
    For example, in an MVC/Razor Pages application, you can use the `abp.auth` JavaScript
    API to check a permission, as illustrated here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的客户端类型可能提供不同的服务来检查权限。例如，在一个 MVC/Razor Pages 应用程序中，您可以使用 `abp.auth` JavaScript
    API 来检查权限，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a global function that returns `true` if the current user has the given
    permission. Otherwise, it returns `false`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全局函数，如果当前用户具有给定的权限，则返回 `true`。否则，返回 `false`。
- en: In a Blazor application, you can reuse the same `[Authorize]` attribute and
    `IAuthorizationService`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Blazor 应用程序中，您可以重用相同的 `[Authorize]` 属性和 `IAuthorizationService`。
- en: We will return to client-side permission checking in *Part 4*, *User Interface
    and API Development*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 4 部分*，*用户界面和 API 开发* 中回到客户端权限检查。
- en: Child permissions
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子权限
- en: 'In a complex application, you may need to create some child permissions that
    depend on their parent permissions. The child permissions are meaningful only
    if the parent permission has been granted. See *Figure 7.3*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的应用程序中，您可能需要创建一些依赖于其父权限的子权限。只有当父权限已被授予时，子权限才有意义。参见 *图 7.3*：
- en: '![Figure 7.3 – Parent-child permissions'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 父子权限'
- en: '](img/Figure_7.3_B17287.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B17287.jpg)'
- en: Figure 7.3 – Parent-child permissions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 父子权限
- en: In *Figure 7.3*, the **Role management** permission has some child permissions
    such as **Create**, **Edit**, and **Delete**. The **Role management** permission
    is used to allow a user to enter the **Role Management** page. If the user cannot
    enter the page, then there is no point in granting the role creation permission,
    since it is practically impossible to create a new role without entering that
    page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7.3* 中，**角色管理**权限有一些子权限，例如**创建**、**编辑**和**删除**。**角色管理**权限用于允许用户进入**角色管理**页面。如果用户无法进入该页面，那么授予角色创建权限就没有意义，因为实际上无法在不进入该页面的情况下创建新角色。
- en: 'In the permission definition class, the `AddPermission` method returns the
    created permission so that you can assign it to a variable and use the `AddChild`
    method to create a child permission, as shown in the following code block:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在权限定义类中，`AddPermission` 方法返回创建的权限，这样您就可以将其赋给一个变量，并使用 `AddChild` 方法创建子权限，如下面的代码块所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we've created a permission named `MyParentPermission`, then
    created another permission named `MyChildPermission` as a child permission.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `MyParentPermission` 的权限，然后创建了一个名为 `MyChildPermission` 的权限作为子权限。
- en: Child permissions can also have child permissions. You can assign the return
    value of the `parent.AddChild` method to a variable and call its `AddChild` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 子权限也可以有子权限。您可以将 `parent.AddChild` 方法的返回值赋给一个变量，并调用其 `AddChild` 方法。
- en: Defining and using permissions is an easy yet powerful way to authorize an application
    via simple on/off-style policies. However, ASP.NET Core allows the creation of
    complete custom logic to define policies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和使用权限是一种简单而强大的方式，可以通过简单的开/关式策略来授权应用程序。然而，ASP.NET Core 允许创建完整的自定义逻辑来定义策略。
- en: Policy-based authorization
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略的授权
- en: The ASP.NET Core **policy-based authorization** system allows you to authorize
    certain operations in your application, just as with permissions, but this time,
    with your custom logic expressed with code. Actually, a permission is a simplified
    and automated policy provided by ABP Framework.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的**基于策略的授权**系统允许您授权应用程序中的某些操作，就像使用权限一样，但这次是通过代码表达的自定义逻辑。实际上，权限是
    ABP 框架提供的一个简化和自动化的策略。
- en: 'Assume that you want to authorize a *product creation* operation with your
    custom code. You first need to define a requirement that you will check later
    (we can define these classes in the application layer of the solution, while there
    is no strict rule). The code is illustrated in the following snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想使用自定义代码授权一个**产品创建**操作。首先，您需要定义一个您稍后将要检查的要求（我们可以在解决方案的应用层中定义这些类，而无需遵循严格的规则）。以下代码片段展示了代码的示例：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ProductCreationRequirement` is an empty class that just implements the `IAuthorizationRequirement`
    marker interface. Then, you should define an authorization handler for that requirement,
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductCreationRequirement` 是一个空类，它仅实现了 `IAuthorizationRequirement` 标记接口。然后，您应该为该要求定义一个授权处理器，如下所示：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The handler class must be derived from `AuthorizationHandler<T>`, where `T`
    is the type of your requirement class. In this example, I simply checked whether
    the current user has the `productManager` claim, which is my custom claim (a claim
    is a simple named value stored in the authentication ticket). You can build your
    custom logic. All you're going to do is call `context.Succeed` if you want to
    allow the current user to have the requirement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器类必须从 `AuthorizationHandler<T>` 派生，其中 `T` 是您的要求类类型。在这个例子中，我简单地检查当前用户是否有 `productManager`
    断言，这是我自定义的断言（断言是存储在身份验证票据中的简单命名值）。您可以构建自己的自定义逻辑。您要做的只是调用 `context.Succeed`，如果您想允许当前用户拥有该要求。
- en: 'Once you define a requirement and handler, you need to register them in the
    `ConfigureServices` method of your module class, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了要求和处理器，您需要将它们注册到您的模块类的 `ConfigureServices` 方法中，如下所示：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I've used `AuthorizationOptions` to define a policy named `ProductManagement.ProductCreation`
    with the `ProductCreationRequirement` requirement. Then, I've registered `ProductCreationRequirementHandler`
    as a singleton service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `AuthorizationOptions` 来定义一个名为 `ProductManagement.ProductCreation` 的策略，并带有
    `ProductCreationRequirement` 要求。然后，我将 `ProductCreationRequirementHandler` 注册为一个单例服务。
- en: Now, suppose I use the `[Authorize("ProductManagement.ProductCreation")]` attribute
    on a controller or action or use `IAuthorizationService` to check the policy.
    In that case, my custom authorization handler logic works to allow me to take
    complete control of the policy-check logic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我在控制器或操作上使用 `[Authorize("ProductManagement.ProductCreation")]` 属性，或者使用
    `IAuthorizationService` 来检查策略。在这种情况下，我的自定义授权处理器逻辑将允许我完全控制策略检查逻辑。
- en: Permissions versus Custom Policies
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 权限与自定义策略的比较
- en: Once you implement a custom policy, you cannot use the permission management
    dialog to grant permission to users and roles because it is not a simple on/off
    permission that you can enable/disable. However, a client-side policy check still
    works, since ABP is well integrated into ASP.NET Core's policy system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您实现了自定义策略，您就不能使用权限管理对话框来授予用户和角色的权限，因为它不是一个简单的开启/关闭权限，您可以启用/禁用。然而，客户端策略检查仍然有效，因为
    ABP 与 ASP.NET Core 的策略系统很好地集成。
- en: As you can see, ABP's permission system is much easier and more powerful if
    you just need on/off-style policies, while custom policies allow you to dynamically
    check policies with your custom logic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您只需要开启/关闭风格的策略，ABP 的权限系统就简单得多，功能也更强大；而自定义策略允许您使用自定义逻辑动态检查策略。
- en: Resource-Based Authorization
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基于资源的授权
- en: 'ASP.NET Core''s authorization system has more features than covered here. Resource-based
    authorization is one feature that allows you to control policies based on objects
    (such as entities). For example, you can control access to delete a specific product,
    rather than having a common deleting permission for all products. ABP is 100%
    compatible with the ASP.NET Core authorization system, so I suggest you check
    ASP.NET Core''s documentation to learn more about authorization: [https://docs.microsoft.com/en-us/aspnet/core/security/authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的授权系统比这里所涵盖的功能更多。基于资源的授权是一个允许您根据对象（如实体）来控制策略的功能。例如，您可以控制删除特定产品的访问权限，而不是为所有产品设置一个通用的删除权限。ABP
    与 ASP.NET Core 授权系统 100% 兼容，因此我建议您查看 ASP.NET Core 的文档以了解更多关于授权的信息：[https://docs.microsoft.com/en-us/aspnet/core/security/authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization)。
- en: Up to now, we've seen the usage of the `[Authorize]` attribute on MVC controllers.
    However, this attribute and `IAuthorizationService` are not limited to controllers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 `[Authorize]` 属性在 MVC 控制器上的用法。然而，这个属性和 `IAuthorizationService`
    并不仅限于控制器。
- en: Authorizations outside of controllers
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器之外的授权
- en: 'ASP.NET Core allows you to use the `[Authorize]` attribute and `IAuthorizationService`
    for Razor Pages, Razor components, and some other points in the web layer. You
    can refer to ASP.NET Core''s documentation to learn about these standard usages:
    [https://docs.microsoft.com/en-us/aspnet/core/security/authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 允许您在 Razor Pages、Razor 组件和 Web 层的一些其他点上使用 `[Authorize]` 属性和 `IAuthorizationService`。您可以参考
    ASP.NET Core 的文档来了解这些标准用法：[https://docs.microsoft.com/en-us/aspnet/core/security/authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization)。
- en: 'ABP Framework takes it one step further and allows using the `[Authorize]`
    attribute for the application service classes and methods without depending on
    the web layer, even in a non-web application. So, this usage is completely valid,
    as illustrated here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架更进一步，允许在应用程序服务类和方法上使用 `[Authorize]` 属性，而无需依赖于网络层，即使在非网络应用程序中也是如此。因此，这种用法是完全有效的，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `CreateAsync` method can only be executed if the current user has the `ProductManagement.ProductCreation`
    permission/policy. Actually, `[Authorize]` is usable in any class that is registered
    for **dependency injection** (**DI**). However, since authorization is considered
    an application layer aspect, it is recommended that authorization be used at the
    application layer and not at the domain layer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAsync` 方法只能在当前用户具有 `ProductManagement.ProductCreation` 权限/策略的情况下执行。实际上，`[Authorize]`
    可以在任何注册了 **依赖注入**（**DI**）的类中使用。然而，由于授权被认为是一个应用层方面，建议在应用层而不是领域层使用授权。'
- en: Dynamic Proxying/Interceptors
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代理/拦截器
- en: ABP uses dynamic proxying using interceptors to accomplish the authorization
    check on method calls. If you inject a service via a class reference (rather than
    an interface reference), the dynamic proxying system uses the dynamic inheritance
    technique. In this case, your method must be defined with the `virtual` keyword
    to allow the dynamic proxying system to override it and perform the authorization
    check.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 使用拦截器通过动态代理来实现方法调用上的授权检查。如果您通过类引用（而不是接口引用）注入服务，动态代理系统会使用动态继承技术。在这种情况下，您的方法必须使用
    `virtual` 关键字定义，以便动态代理系统可以覆盖它并执行授权检查。
- en: The authorization system guarantees that only authorized users consume your
    services. It is one of the systems that you need to use to secure your application,
    while the other one is input validation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 授权系统确保只有授权用户才能使用你的服务。这是你需要用来保护应用程序的系统之一，另一个是输入验证。
- en: Validating user inputs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: 'Validation ensures your data security and consistency and helps your application
    to operate properly. Validation is a wide topic, and there are some common levels
    of validation, as outlined here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 验证确保你的数据安全和一致性，并帮助你的应用程序正常运行。验证是一个广泛的话题，有一些常见的验证级别，如下所述：
- en: '**Client-side validation** is used to pre-validate the user input before sending
    data to the server. It is important for the **user experience** (**UX**), and
    you should always implement it wherever possible. However, it cannot guarantee
    security—even an inexperienced hacker can bypass it. For example, checking whether
    a required textbox field is empty is a type of client-side validation. We will
    cover client-side validation in *Part 4*, *User Interface and API Development*.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端验证**用于在将数据发送到服务器之前预先验证用户输入。这对于**用户体验**（**UX**）非常重要，你应该在可能的情况下始终实现它。然而，它不能保证安全性——即使是经验不足的黑客也可以绕过它。例如，检查必填的文本框字段是否为空是一种客户端验证。我们将在*第4部分*，*用户界面和API开发*中介绍客户端验证。'
- en: '**Server-side validation** is performed by the server to prevent incomplete,
    badly formatted, or malicious requests. It provides some level of security for
    your application and is generally performed when you first touch the data sent
    by the client. For example, checking a required input field is empty on the server
    side is an example of this type of validation.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端验证**由服务器执行，以防止不完整、格式错误或恶意请求。它为你的应用程序提供了一定程度的安全性，通常在第一次接触客户端发送的数据时执行。例如，在服务器端检查必填的输入字段是否为空是此类验证的一个例子。'
- en: '**Business validation** is also performed in the server; it implements your
    business rules and keeps your business data consistent. It is done at every level
    of your business code. For example, checking a user''s balance before a money
    transfer is a kind of business validation. We will cover business validation in
    [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD – The Domain Layer*.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务验证**也在服务器端执行；它实现了你的业务规则并保持你的业务数据一致性。它在你业务代码的每个级别上执行。例如，在转账前检查用户的余额是一种业务验证。我们将在[*第10章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*领域驱动设计（DDD）-
    领域层*中介绍业务验证。'
- en: About the ASP.NET Core Validation System
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 ASP.NET Core 验证系统
- en: 'ASP.NET Core provides many options for input validation. This book covers the
    basics by focusing on the features added by ABP Framework. See ASP.NET Core''s
    documentation for all the validation possibilities: [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation).'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了许多输入验证选项。本书通过关注 ABP 框架添加的功能来介绍基础知识。有关所有验证可能性的详细信息，请参阅 ASP.NET
    Core 的文档：[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation)。
- en: This section focuses on server-side validation and shows how to perform input
    validation in different ways. It also explores ways to control the validation
    process and deal with validation exceptions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍服务器端验证，展示如何以不同的方式执行输入验证。它还探讨了控制验证过程和处理验证异常的方法。
- en: Let's start with the easiest way to perform validation—using data annotation
    attributes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的方式进行验证的方法开始——使用数据标注属性。
- en: Using data annotation attributes
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据标注属性
- en: 'Using data annotation attributes is the simplest way to perform a formal validation
    for the user input. See the following application service method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据标注属性是执行用户输入正式验证的最简单方法。请参阅以下应用服务方法：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`ProductAppService` is an application service, and the application service
    inputs are automatically validated in ABP Framework, just as with controllers
    in the ASP.NET Core MVC framework. The `ProductAppService` service takes an input
    parameter, as shown in the following code block:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductAppService` 是一个应用服务，在 ABP 框架中，应用服务的输入会自动进行验证，就像在 ASP.NET Core MVC 框架中的控制器一样。`ProductAppService`
    服务接受一个输入参数，如下面的代码块所示：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ProductCreationDto` has three properties decorated with validation attributes.
    There are many built-in validation attributes of ASP.NET Core, including the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductCreationDto` 有三个属性被验证属性装饰。ASP.NET Core 有许多内置的验证属性，包括以下内容：'
- en: '`[Required]`: Validates that the property is not null'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Required]`：验证属性不为空'
- en: '`[StringLength]`: Validates a maximum (and optionally minimum) length for a
    string property'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[StringLength]`：验证字符串属性的最大（和可选的最小）长度'
- en: '`[Range]`: Validates that the property value is in the specified range'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Range]`：验证属性值是否在指定的范围内'
- en: '`[Url]`: Validates that the property value has a proper URL format'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Url]`：验证属性值具有正确的URL格式'
- en: '`[RegularExpression]`: Allows the specifying of a custom **regular expression**
    (**regex**) to validate the property value'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[RegularExpression]`：允许指定一个自定义**正则表达式**（**regex**）来验证属性值'
- en: '`[EmailAddress]`: Validates that the property has a properly formatted email
    address value'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[EmailAddress]`：验证属性具有正确格式的电子邮件地址值'
- en: ASP.NET Core also allows you to define custom validation attributes by inheriting
    them from the `ValidationAttribute` class and overriding the `IsValid` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core还允许你通过从`ValidationAttribute`类继承并重写`IsValid`方法来定义自定义验证属性。
- en: Data annotation attributes are very easy to use and are suggested to perform
    formal validation for your **data transfer objects** (**DTOs**) and models. However,
    they are limited when you need to perform custom code logic to validate the input.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据注释属性非常易于使用，建议用于对**数据传输对象**（**DTOs**）和模型进行正式验证。然而，当需要执行自定义代码逻辑来验证输入时，它们是有限的。
- en: Custom validation with the IValidatableObject interface
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IValidatableObject接口进行自定义验证
- en: 'A model or DTO object can implement the `IValidatableObject` interface to perform
    validation using a custom code block. See the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 模型或DTO对象可以实现`IValidatableObject`接口，使用自定义代码块进行验证。请参阅以下示例：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, `ProductCreationDto` has a custom rule: a profile picture
    is required if `IsDraft` is `false`. So, we are checking the condition and adding
    a validation error in this case.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`ProductCreationDto`有一个自定义规则：如果`IsDraft`为`false`，则必须提供个人资料图片。因此，我们检查条件并在这种情况下添加一个验证错误。
- en: 'If you need to resolve a service from the DI system, you can use the `context.GetRequiredService`
    method. For example, if we want to localize the error message, we can rewrite
    the `Validate` method, as shown in the following code block:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从DI系统中解析服务，你可以使用`context.GetRequiredService`方法。例如，如果我们想本地化错误消息，我们可以重写`Validate`方法，如下面的代码块所示：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we resolve an `IStringLocalizer<ProductManagementResource>` instance from
    the DI and use it to return a localized error message to the client. We will cover
    the localization system in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从DI中解析一个`IStringLocalizer<ProductManagementResource>`实例，并使用它向客户端返回本地化错误消息。我们将在[*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)中介绍本地化系统，*使用ABP的功能和服务*。
- en: Formal Validation versus Business Validation
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正式验证与业务验证
- en: As a best practice, implement only formal validation (such as if a DTO property
    was not filled or not formatted as expected) in the DTO/model classes and use
    only the data already available on the DTO/model class. Implement your business
    validation logic inside application or domain layer services. For example, if
    you want to check whether a given product name already exists in the database,
    do not try to implement this logic in the `Validate` method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，仅在DTO/模型类中实现正式验证（例如，如果DTO属性未填写或未按预期格式化），并仅使用DTO/模型类上已存在的数据。在你的应用程序或领域层服务中实现你的业务验证逻辑。例如，如果你想检查给定的产品名称是否已在数据库中存在，不要尝试在`Validate`方法中实现此逻辑。
- en: Using either the validation attributes or custom validation logic, ABP Framework
    handles the validation result and throws an exception prior to the execution of
    your method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用验证属性或自定义验证逻辑，ABP框架处理验证结果，并在执行你的方法之前抛出异常。
- en: Understanding the validation exception
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解验证异常
- en: 'If the user input is not valid, ABP Framework automatically throws an exception
    of the `AbpValidationException` type. The exception is thrown in the following
    situations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入无效，ABP框架会自动抛出`AbpValidationException`类型的异常。异常在以下情况下抛出：
- en: The input object is `null`, so you don't need to check whether it is `null`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入对象是`null`，所以你不需要检查它是否为`null`。
- en: The input object is invalid in any way, so you don't have to check `Model.IsValid`
    in your API controllers.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入对象在任何方面都是无效的，因此你不需要在你的API控制器中检查`Model.IsValid`。
- en: ABP doesn't call your service method (or controller action) in these cases.
    If your method is being executed, you can be sure that the input is not null and
    is valid.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，ABP不会调用你的服务方法（或控制器操作）。如果你的方法正在执行，你可以确信输入不是null且有效。
- en: 'If you perform additional validation inside your services and want to throw
    a validation-related exception, you can also throw `AbpValidationException`, as
    illustrated in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在服务内部执行额外的验证并抛出与验证相关的异常，你也可以抛出`AbpValidationException`，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are assuming that `HasExistingProductAsync` returns `true` if there
    is a product with the given name. In this case, we are throwing `AbpValidationException`
    by specifying the validation error(s). `ValidationResult` represents a validation
    error; its first constructor parameter is the validation error message, and the
    second parameter (optional) is the name of the DTO properties that caused the
    validation error.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设`HasExistingProductAsync`方法在存在具有给定名称的产品时返回`true`。在这种情况下，我们通过指定验证错误抛出`AbpValidationException`。`ValidationResult`代表一个验证错误；其第一个构造函数参数是验证错误消息，第二个参数（可选）是导致验证错误的DTO属性名称。
- en: Once you or the ABP validation system throws an `AbpValidationException` exception,
    the ABP exception-handling system catches and handles it properly, as we will
    see in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你或ABP验证系统抛出`AbpValidationException`异常，ABP异常处理系统会捕获并正确处理它，正如我们将在下一个章节中看到的。
- en: The ABP validation system works just as you want most of the time, but sometimes,
    you may need to bypass it and apply your custom logic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ABP验证系统大多数时候都按你的预期工作，但有时你可能需要绕过它并应用你自定义的逻辑。
- en: Disabling the validation
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用验证
- en: 'It is possible to bypass the ABP validation system at a method or class level
    using the `[DisableValidation]` attribute, as in the following example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[DisableValidation]`属性，可以在方法或类级别绕过ABP验证系统，如下面的例子所示：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the `CreateAsync` method is decorated with the `[DisableValidation]`
    attribute, so ABP doesn't perform any automatic validation for the `input` object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CreateAsync`方法被装饰了`[DisableValidation]`属性，因此ABP不会对`input`对象执行任何自动验证。
- en: If you use the `[DisableValidation]` attribute for a class, then the validation
    is disabled for all the methods. In this case, you can use the `[EnableValidation]`
    attribute for a method to enable validation only for that particular method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为类使用`[DisableValidation]`属性，则所有方法都将禁用验证。在这种情况下，你可以为方法使用`[EnableValidation]`属性，仅为此特定方法启用验证。
- en: When you disable auto-validation for a method, you can still perform your custom
    validation logic and throw `AbpValidationException`, as explained in the previous
    section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你禁用方法的自动验证时，你仍然可以执行你自定义的验证逻辑并抛出`AbpValidationException`，正如前一个章节所解释的。
- en: Validation in other types
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在其他类型中的验证
- en: ASP.NET Core performs validation for controller actions and Razor Page handlers.
    ABP, in addition to ASP.NET Core, performs validation for application service
    methods by default.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core为控制器操作和Razor页面处理程序执行验证。除了ASP.NET Core之外，ABP默认情况下还会为应用程序服务方法执行验证。
- en: 'Beyond the default behavior, ABP allows you to enable the auto-validation feature
    for any kind of class in your application. All you need to do is to implement
    the `IValidationEnabled` marker interface, as shown in the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认行为之外，ABP允许你在应用程序中的任何类型的类上启用自动验证功能。你需要做的就是实现`IValidationEnabled`标记接口，如下面的例子所示：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, ABP auto-validates all the inputs for this class, using the validation
    system explained in this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，ABP使用本章中解释的验证系统自动验证这个类的所有输入。
- en: Dynamic Proxying/Interceptors
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代理/拦截器
- en: ABP uses dynamic proxying using interceptors to accomplish validation on method
    calls. If you inject a service via a class reference (rather than an interface
    reference), the dynamic proxying system uses the dynamic inheritance technique.
    In this case, your method must be defined with the `virtual` keyword to allow
    the dynamic proxying system to override it and perform the validation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ABP使用拦截器进行动态代理以在方法调用上完成验证。如果你通过类引用（而不是接口引用）注入服务，动态代理系统使用动态继承技术。在这种情况下，你的方法必须使用`virtual`关键字定义，以便动态代理系统可以覆盖它并执行验证。
- en: Up to now, we've explained the ABP validation system that is directly compatible
    with ASP.NET Core's validation infrastructure. The next section introduces `FluentValidation`
    library integration, which allows you to separate the validation logic from the
    validated object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了与ASP.NET Core验证基础设施直接兼容的ABP验证系统。下一节将介绍`FluentValidation`库集成，它允许你将验证逻辑与验证对象分离。
- en: Integrating the FluentValidation library
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成FluentValidation库
- en: The built-in validation system is enough for most cases, and it is easy to use
    to define formal validation rules. I personally don't see any problem with it
    and find it practical to embed the data validation logic inside DTO/model classes.
    However, some developers think that the validation logic inside DTO/model classes
    is a bad practice, even when it is only a formal validation. In this case, ABP
    provides an integration package with the popular `FluentValidation` library, which
    decouples the validation logic from the DTO/model class and provides more powerful
    features compared to the standard data annotation approach.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的验证系统对于大多数情况来说已经足够，并且使用它来定义正式的验证规则非常容易。我个人认为它没有问题，并且发现将数据验证逻辑嵌入DTO/模型类中是实用的。然而，一些开发者认为，即使在只有正式验证的情况下，DTO/模型类中的验证逻辑也是一种不良实践。在这种情况下，ABP提供了一个与流行的`FluentValidation`库集成的包，它将验证逻辑与DTO/模型类解耦，并提供了比标准数据注释方法更强大的功能。
- en: 'If you want to use the `FluentValidation` library, you first need to install
    it into your project. You can use the `add-package` command of the **ABP Command-Line
    Interface** (**ABP CLI**) to install it for a project easily, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`FluentValidation`库，首先需要将其安装到你的项目中。你可以使用**ABP命令行界面（ABP CLI**）的`add-package`命令轻松地为项目安装它，如下所示：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you install the package, you can create your validator classes and set
    your validation rules, as shown in the following code block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，你就可以创建你的验证器类并设置你的验证规则，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Please refer to the `FluentValidation` documentation to learn how to define
    advanced validation rules: [https://fluentvalidation.net](https://fluentvalidation.net).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`FluentValidation`文档了解如何定义高级验证规则：[https://fluentvalidation.net](https://fluentvalidation.net)。
- en: ABP automatically discovers the validator classes and integrates them into the
    validation process. That means you can even mix the standard validation logic
    with the `FluentValidation` validator classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ABP自动发现验证器类并将它们集成到验证过程中。这意味着你甚至可以将标准验证逻辑与`FluentValidation`验证器类混合使用。
- en: Authorization and validation exceptions are well-defined exception types, and
    ABP automatically handles them. The next section explores the ABP exception-handling
    system and explains how to deal with different kinds of exceptions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 授权和验证异常是定义良好的异常类型，ABP会自动处理它们。下一节将探讨ABP异常处理系统，并解释如何处理不同类型的异常。
- en: Exception handling
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: One of the most important quality indicators of an application is how it responds
    to errors and exceptional cases. A good application should handle errors, return
    a proper response to the client, and gracefully inform the user about the problem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序最重要的质量指标之一是它如何响应错误和异常情况。一个好的应用程序应该处理错误，向客户端返回适当的响应，并优雅地通知用户问题。
- en: In a typical web application, we should care about exceptions in every client
    request, which makes it a repetitive and tedious task for developers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的Web应用程序中，我们应该关注每个客户端请求中的异常，这使得对于开发者来说，它变成了一项重复且繁琐的任务。
- en: 'ABP Framework completely automates error handling in every aspect of your application.
    Most of the time, you don''t need to write any `try-catch` statement in your application
    code, as it does the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架完全自动化了应用程序每个方面的错误处理。大多数时候，你不需要在应用程序代码中编写任何`try-catch`语句，因为它会执行以下操作：
- en: Handles all exceptions, logs them, and returns a standard-formatted error response
    to the client for an API request or shows a standard error page for a server-rendered
    page
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理所有异常，记录它们，并在API请求中向客户端返回标准格式的错误响应，或在服务器渲染的页面中显示标准错误页面
- en: Hides internal infrastructure errors while allowing you to return user-friendly,
    localized error messages when you need them
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隐藏内部基础设施错误的同时，允许你在需要时返回用户友好的、本地化的错误消息
- en: Understands standard exceptions such as validation and authorization exceptions
    and sends a proper HTTP status code to the client
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解标准异常，如验证和授权异常，并向客户端发送适当的HTTP状态码
- en: Handles all errors on the client and shows a meaningful message to the end user
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端处理所有错误并向最终用户显示有意义的消息
- en: While ABP takes care of exceptions, you can throw exceptions to return user-friendly
    messages or business-specific error codes to the client.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当ABP处理异常时，您可以抛出异常以返回用户友好的消息或业务特定的错误代码给客户端。
- en: User-friendly exceptions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户友好的异常
- en: ABP provides some predefined exception classes to customize the error-handling
    behavior. One of these is the `UserFriendlyException` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了一些预定义的异常类来定制错误处理行为。其中之一是`UserFriendlyException`类。
- en: 'First, to understand the need for the `UserFriendlyException` class, see what
    happens if an arbitrary exception is thrown from a server-side API. The following
    method throws an exception with a custom message:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了理解`UserFriendlyException`类的需求，看看如果从服务器端API抛出一个任意异常会发生什么。以下方法抛出一个带有自定义消息的异常：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Assume that a browser client calls that method via an AJAX request. It will
    show the following error message to the end user:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个浏览器客户端通过AJAX请求调用该方法。它将向最终用户显示以下错误消息：
- en: '![Figure 7.4 – The default error message'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 默认错误消息'
- en: '](img/Figure_7.4_B17287.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B17287.jpg)'
- en: Figure 7.4 – The default error message
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 默认错误消息
- en: As you see in *Figure 7.4*, ABP shows a standard error message about an internal
    problem. The actual error message is written to the logging system. The server
    returns an HTTP 500 status code to the client for such generic errors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图7.4*中看到的那样，ABP显示了一个关于内部问题的标准错误消息。实际的错误消息被写入日志系统。服务器对于此类通用错误向客户端返回HTTP 500状态码。
- en: That is good behavior because it is not useful to show a raw exception message
    to an end user. It can even be dangerous, since it may include some sensitive
    information about your internal systems, such as database table names and fields.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种良好的行为，因为向最终用户显示原始异常消息是没有用的。甚至可能很危险，因为它可能包含一些关于您内部系统的敏感信息，例如数据库表名和字段。
- en: 'However, you may want to return a user-friendly, informative message to the
    end user for some specific cases. For such cases, you can throw a `UserFriendlyException`
    exception, as shown in the following code block:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能希望在某些特定情况下向最终用户返回一个用户友好的、信息丰富的消息。对于此类情况，您可以抛出一个`UserFriendlyException`异常，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'ABP, at this time, doesn''t hide the error message, as we can see here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，ABP没有隐藏错误消息，正如我们在这里看到的那样：
- en: '![Figure 7.5 – Custom error message'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 自定义错误消息'
- en: '](img/Figure_7.5_B17287.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B17287.jpg)'
- en: Figure 7.5 – Custom error message
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 自定义错误消息
- en: The `UserFriendlyException` class is not unique. Any exception class that inherits
    from the `UserFriendlyException` class or directly implements the `IUserFriendlyException`
    interface can be used to return user-friendly exception messages. ABP returns
    an HTTP 403 (forbidden) status code to the client when you throw a user-friendly
    exception. See the *Controlling the HTTP status code* section of this chapter
    for all HTTP status code mappings.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserFriendlyException`类不是唯一的。任何继承自`UserFriendlyException`类或直接实现`IUserFriendlyException`接口的异常类都可以用来返回用户友好的异常消息。当您抛出一个用户友好的异常时，ABP向客户端返回HTTP
    403（禁止）状态码。有关所有HTTP状态码映射，请参阅本章的*控制HTTP状态码*部分。'
- en: In a multilingual application, you will probably want to return a localized
    message. Use the localization system in this case, which will be introduced in
    [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249), *Using the Features and
    Services of ABP*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在多语言应用程序中，您可能希望返回本地化消息。在这种情况下，使用本地化系统，该系统将在[*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)，*使用ABP的功能和服务*中介绍。
- en: '`UserFriendlyException` is a special type of business exception where you directly
    return a message to the user.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserFriendlyException`是一种特殊的业务异常，其中您直接向用户返回一条消息。'
- en: Business exceptions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务异常
- en: You will have some business rules in a business application, and you need to
    throw exceptions when the requested operation is not appropriate to execute in
    the current conditions based on these rules. Business exceptions in ABP are special
    kinds of exceptions recognized and handled by ABP Framework.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务应用程序中，您将有一些业务规则，并且当根据这些规则在当前条件下请求的操作不适当执行时，您需要抛出异常。ABP中的业务异常是ABP框架识别和处理的特殊类型的异常。
- en: 'In the simplest case, you can directly use the `BusinessException` class to
    throw a business exception. See the following example from the *EventHub* project:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，您可以直接使用`BusinessException`类来抛出业务异常。请参见以下来自*EventHub*项目的示例：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`EventRegistrationManager` is a domain service that is used to perform business
    rules for event registrations. The `RegisterAsync` method checks the event time
    and prevents registering to events in the past by throwing a business exception
    in that case.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventRegistrationManager` 是一个用于执行事件注册业务规则的领域服务。`RegisterAsync` 方法检查事件时间，并防止注册过去的事件，在这种情况下会抛出业务异常。'
- en: 'The constructor of `BusinessException` takes a few parameters, and all are
    optional. These are listed here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`BusinessException` 的构造函数接受一些参数，所有这些参数都是可选的。这些参数在此列出：'
- en: '`code`: A string value that is used as a custom error code for the exception.
    Client applications can check it while handling the exception and track the error
    type easily. You typically use different error codes for different exceptions.
    The error code can also be used to localize the exception, as we will see in the
    *Localizing a business exception* section.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`：用作异常自定义错误代码的字符串值。客户端应用程序可以在处理异常时检查它，并轻松跟踪错误类型。您通常为不同的异常使用不同的错误代码。错误代码也可以用于本地化异常，正如我们将在
    *本地化业务异常* 部分中看到的那样。'
- en: '`message`: A string exception message, if needed.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：如果需要，一个字符串异常消息。'
- en: '`details`: A detailed explanation message string, if needed.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`details`：如果需要，一个详细的解释消息字符串。'
- en: '`innerException`: An inner exception, if available. You can pass here if you
    have cached an exception and throw a business exception based on that exception.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerException`：如果有的话，一个内部异常。如果您已缓存一个异常并基于该异常抛出业务异常，可以在这里传递。'
- en: '`logLevel`: The logging level for this exception. It is an enum of the `LogLevel`
    type, and the default value is `LogLevel.Warning`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logLevel`：此异常的日志级别。它是一个 `LogLevel` 类型的枚举，默认值为 `LogLevel.Warning`。'
- en: You generally only pass `code`, which is easier to find in logs. It is also
    used for localizing the error message returned to the client.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常只传递 `code`，这在日志中更容易找到。它也用于将错误消息本地化到客户端。
- en: Localizing a business exception
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化业务异常
- en: If you use `UserFriendlyException`, you have to localize the message yourself
    since the exception message is shown directly to the end user. If you throw `BusinessException`,
    ABP doesn't show the exception message to the end user unless you explicitly localize
    it. It uses error code namespaces for that purpose.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `UserFriendlyException`，您必须自己本地化消息，因为异常消息会直接显示给最终用户。如果您抛出 `BusinessException`，除非您明确本地化它，否则
    ABP 不会将异常消息显示给最终用户。它使用错误代码命名空间来达到这个目的。
- en: 'Assume that you''ve used `EventHub:CantRegisterOrUnregisterForAPastEvent` as
    the error code. `EventHub`, here, becomes the error code namespace through the
    usage of the colon. We must map the error code namespace to a localization resource
    so that ABP can know which localization resource to use for these error messages.
    The code is illustrated in the following snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已使用 `EventHub:CantRegisterOrUnregisterForAPastEvent` 作为错误代码。在这里，“EventHub”通过冒号的使用成为错误代码命名空间。我们必须将错误代码命名空间映射到本地化资源，以便
    ABP 能够知道为这些错误消息使用哪个本地化资源。以下代码片段展示了这一过程：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this code snippet, we map the `EventHub` error code namespace to the `EventHubResource`
    localization resource. Now, you can define the error code as a key in your localization
    file, including the namespace, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们将 `EventHub` 错误代码命名空间映射到 `EventHubResource` 本地化资源。现在，您可以在本地化文件中将错误代码定义为键，包括命名空间，如下所示：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After that configuration, ABP shows the localized message to the user whenever
    you throw a `BusinessException` exception with that error code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在该配置之后，每当您使用该错误代码抛出 `BusinessException` 异常时，ABP 都会向用户显示本地化消息。
- en: 'In some cases, you may want to include some additional data in the error message.
    See the following code snippet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在错误消息中包含一些额外的数据。请参阅以下代码片段：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we include the organization name in the error message, using the `WithData`
    extension method. Then, we can define the localization string, as shown in the
    following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `WithData` 扩展方法在错误消息中包含组织名称。然后，我们可以定义本地化字符串，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, `{Name}` is a placeholder for the organization name. ABP automatically
    replaces it with the given name.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`{Name}` 是组织名称的占位符。ABP 会自动将其替换为给定的名称。
- en: We will cover the localization system in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249) 中介绍本地化系统，*使用 ABP 的功能和服务*。
- en: We've seen how to throw a `BusinessException` exception. What if you want to
    create specialized exception classes?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何抛出`BusinessException`异常。如果您想创建专门的异常类怎么办？
- en: Custom business exception classes
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义业务异常类
- en: 'It is also possible to create custom exception classes instead of directly
    throwing a `BusinessException` exception. In this case, you can create a new class
    inheriting from the `BusinessException` class, as shown in the following code
    block:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以创建自定义异常类，而不是直接抛出`BusinessException`异常。在这种情况下，您可以创建一个新的类，从`BusinessException`类继承，如下面的代码块所示：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, `OrganizationNameAlreadyExistsException` is a custom business
    exception class. It takes the organization''s name in its constructor. It sets
    the `"Name"` data so that ABP can use the organization name in the localization
    process. Throwing this exception is pretty straightforward, as we can see here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`OrganizationNameAlreadyExistsException`是一个自定义业务异常类。它在构造函数中接受组织的名称。它设置`"Name"`数据，以便ABP可以在本地化过程中使用组织名称。抛出此异常非常直接，如下所示：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This usage is simpler than throwing a `BusinessException` exception with custom
    data, which the developer can forget to set. It also reduces duplication when
    you throw the same exception in multiple places in your code base.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法比抛出带有自定义数据的`BusinessException`异常简单，开发者可能会忘记设置这些数据。它还减少了在代码库的多个地方抛出相同异常时的重复。
- en: Controlling exception logging
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制异常记录
- en: As mentioned at the beginning of the *Exception handling* section, ABP automatically
    logs all exceptions. Business exceptions, authorization, and validation exceptions
    are logged with the `Warning` level, while other errors are logged with the `Error`
    level by default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*异常处理*部分开头所述，ABP会自动记录所有异常。业务异常、授权和验证异常以`Warning`级别记录，而其他错误默认以`Error`级别记录。
- en: 'You can implement the `IHasLogLevel` interface to set a different log level
    for an exception class. See the following example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实现`IHasLogLevel`接口为异常类设置不同的日志级别。请参见以下示例：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `MyException` class implements the `IHasLogLevel` interface with the `Warning`
    level. ABP will write warning logs if you throw exceptions of the `MyException`
    type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyException`类使用`Warning`级别实现了`IHasLogLevel`接口。如果您抛出`MyException`类型的异常，ABP将写入警告日志。'
- en: 'It is also possible to write additional logs for an exception. You can implement
    the `IExceptionWithSelfLogging` interface to write additional logs, as shown in
    the following example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以为异常写入额外的日志。您可以通过实现`IExceptionWithSelfLogging`接口来写入额外的日志，如下面的示例所示：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, the `MyException` class implements the `IExceptionWithSelfLogging`
    interface, which defines a `Log` method. ABP passes the logger here to allow you
    to write additional logs if you need them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`MyException`类实现了`IExceptionWithSelfLogging`接口，该接口定义了一个`Log`方法。ABP将记录器传递到这里，以便您在需要时写入额外的日志。
- en: Controlling the HTTP status code
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制HTTP状态码
- en: 'ABP does its best to return a proper HTTP status code for known exception types,
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ABP会尽力为已知异常类型返回适当的HTTP状态码，如下所示：
- en: Returns `401` (unauthorized) if the user has not logged in, for `AbpAuthorizationException`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户未登录，则对于`AbpAuthorizationException`返回`401`（未授权）
- en: Returns `403` (forbidden) if the user has logged in, for `AbpAuthorizationException`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已登录，则对于`AbpAuthorizationException`返回`403`（禁止）
- en: Returns `400` (bad request) for `AbpValidationException`
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`AbpValidationException`返回`400`（错误请求）
- en: Returns `404` (not found) for `EntityNotFoundException`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`EntityNotFoundException`返回`404`（未找到）
- en: Returns `403` (forbidden) for business and user-friendly exceptions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于业务和用户友好的异常返回`403`（禁止）
- en: Returns `501` (not implemented) for `NotImplementedException`
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`NotImplementedException`返回`501`（未实现）
- en: Returns `500` (internal server error) for other exceptions (those are assumed
    to be infrastructure errors)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他异常（假设为基础设施错误）返回`500`（内部服务器错误）
- en: 'If you want to return another HTTP status code for your custom exceptions,
    you can map your error code to an HTTP status code, as shown in the following
    configuration:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为自定义异常返回另一个HTTP状态码，可以将您的错误代码映射到HTTP状态码，如下面的配置所示：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is suggested to make that configuration in the web or HTTP API layer of your
    solution.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在解决方案的Web或HTTP API层进行此配置。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've explored three fundamental cross-cutting concerns that
    we should implement in every serious business application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在每个严肃的商业应用程序中都应该实现的三项基本横切关注点。
- en: Authorization is a key concern for system security. You should carefully control
    the authorization rules in every operation of your application. ABP simplifies
    the use of ASP.NET Core's authorization infrastructure and adds a flexible permission
    system that is a very common pattern for enterprise applications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是系统安全的关键关注点。你应该仔细控制应用程序每个操作中的授权规则。ABP简化了ASP.NET Core授权基础设施的使用，并添加了一个灵活的权限系统，这对于企业应用程序来说是一个非常常见的模式。
- en: Validation, on the other hand, supports system security and improves the UX
    by gracefully preventing badly formatted or malicious requests. ABP enhances the
    standard ASP.NET Core validation by allowing you to implement the validation in
    any service of your application and integrating it into the `FluentValidation`
    library for advanced usage.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，验证通过优雅地阻止格式错误或恶意请求来支持系统安全并提高用户体验。ABP通过允许你在应用程序的任何服务中实现验证并将其集成到`FluentValidation`库以进行高级使用，增强了标准的ASP.NET
    Core验证。
- en: Finally, ABP's exception-handling system works seamlessly and automates exception
    handling on the server side and client side. It also allows you to decouple localizing
    error messages and map them to HTTP status codes from your code that throws an
    exception.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ABP的异常处理系统工作无缝，并在服务器端和客户端自动处理异常。它还允许你将本地化错误消息与抛出异常的代码中的HTTP状态代码解耦并映射。
- en: The next chapter will continue to explore ABP Framework services by introducing
    some fancy ABP features such as automatic audit logging and data filtering.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续通过介绍一些有趣的ABP功能，如自动审计日志和数据过滤，来探索ABP框架服务。
