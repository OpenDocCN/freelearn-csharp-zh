<html><head></head><body>
<div><h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-61">Understanding Basic Blazor Components</h1>
<p class="normal">In this chapter, we will look at the components that come with the Blazor template and start to build our own components. Knowing the different techniques used for creating Blazor websites will help us when we start building our components.</p>
<p class="normal">Blazor uses components for most things, so we will use the knowledge from this chapter throughout the book.</p>
<p class="normal">We will start this chapter with theory and end by creating a component to show some blog posts using the API we created previously, in <em class="chapterRef">Chapter 3</em>, <em class="italic">Managing State – Part 1</em>.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Exploring components</li>
<li class="bulletList">Learning Razor syntax</li>
<li class="bulletList">Understanding dependency injection</li>
<li class="bulletList">Changing the Render mode</li>
<li class="bulletList">Figuring out where to put the code</li>
<li class="bulletList">Lifecycle events</li>
<li class="bulletList">Parameters</li>
<li class="bulletList">Writing our first component</li>
</ul>
<h1 class="heading-1" id="_idParaDest-62">Technical requirements</h1>
<p class="normal">Make sure you have followed the previous chapters or use the <code class="inlineCode">Chapter03</code> folder as the starting point.</p>
<p class="normal">You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04</a>.</p>
<h1 class="heading-1" id="_idParaDest-63">Exploring components</h1>
<p class="normal">In Blazor, a <code class="inlineCode">component</code> is a <code class="inlineCode">.razor</code> file containing a small, isolated functionality (code and markup), or it can be used as a page. A component can host other components as well. This chapter will show us how components work and how to use them.</p>
<p class="normal">There are three <a id="_idIndexMarker123"/>different ways we can create a component:</p>
<ul>
<li class="bulletList">Using Razor syntax, with the code and HTML sharing the same file</li>
<li class="bulletList">Using a code-behind file together with a <code class="inlineCode">.razor</code> file</li>
<li class="bulletList">Using only a code-behind file</li>
</ul>
<p class="normal">In this chapter, we will go through the different options. First, we’ll go through the components in the template we used to create the project; these all use the first option, <code class="inlineCode">.razor</code> files, where we have a mix of code and HTML in the same file.</p>
<p class="normal">The components in the template are as follows:</p>
<ul>
<li class="bulletList"><strong class="screenText">Counter</strong></li>
<li class="bulletList"><strong class="screenText">Weather</strong></li>
</ul>
<h2 class="heading-2" id="_idParaDest-64">Counter</h2>
<p class="normal">The <code class="inlineCode">counter</code> page shows <a id="_idIndexMarker124"/>a button and a counter; if we click the button, the counter increases. We will now break the page apart, making it easier to understand. It is located in the <code class="inlineCode">BlazorWebApp.Client</code> project, inside the <code class="inlineCode">Pages</code> folder.</p>
<p class="normal">At the top of the page is the <code class="inlineCode">@page</code> directive, which makes it possible to route to the component directly, as we can see in this code:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/counter"
</code></pre>
<p class="normal">If we start the <code class="inlineCode">BlazorWebApp</code> project and add <code class="inlineCode">/counter</code> to the end of the URL, we see that we can directly access the component by using its route. We can also make the route take parameters, but we will return to that later.</p>
<p class="normal">Beneath that, we have the render mode:</p>
<pre class="programlisting code"><code class="hljs-code">@rendermode InteractiveAuto
</code></pre>
<p class="normal">This is the way we can set the render mode on a specific component. This means that when we use this <a id="_idIndexMarker125"/>component, it will first render the page using Blazor Server (with SignalR) and, in the background, download the WebAssembly version so that the next time we load the page, it will then run the WebAssembly version instead.</p>
<p class="normal">Next, let’s explore the code. To add code to the page, we use the <code class="inlineCode">@code</code> statement, and within that statement, we can add ordinary C# code, as shown:</p>
<pre class="programlisting code"><code class="hljs-code">@code {
    private int currentCount = 0;
    private void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre>
<p class="normal">In the preceding code block, we have a private <code class="inlineCode">currentCount</code> variable set to <code class="inlineCode">0</code>. Then, we have a method called <code class="inlineCode">IncrementCount()</code>, which increments the <code class="inlineCode">currentCount</code> variable by <code class="inlineCode">1</code>.</p>
<p class="normal">We show the current value by using the <code class="inlineCode">@</code> sign. In Razor, the <code class="inlineCode">@</code> sign indicates that it is time for some code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;p role="status"&gt;Current count: @currentCount&lt;/p&gt;
</code></pre>
<p class="normal">As we can see, Razor is very smart because it understands when the code stops and the markup continues, so there is no need to add something extra to transition from the code to the markup (more on that in the next section).</p>
<p class="normal">As we can see in the preceding example, we are mixing HTML tags with <code class="inlineCode">@currentCount</code> and Razor understands the difference. Next, we have a button that is the trigger for changing the value:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;
</code></pre>
<p class="normal">This is an HTML button with a <code class="inlineCode">Bootstrap</code> class (to make it look a bit nicer). <code class="inlineCode">@onclick</code> binds the button’s <code class="inlineCode">onclick</code> event to the <code class="inlineCode">IncrementCount()</code> method. If we were to use <code class="inlineCode">onclick</code> without the <code class="inlineCode">@</code>, it would refer to the JavaScript event and not work.</p>
<p class="normal">So, when we click the button, it will call the <code class="inlineCode">IncrementCount()</code> method (depicted by <code class="inlineCode">1</code> in <em class="italic">Figure 4.1</em>), the method increments the variable (depicted by <code class="inlineCode">2</code>), and due to changing the variable, the UI will <a id="_idIndexMarker126"/>automatically be updated (depicted by <code class="inlineCode">3</code>), as shown in <em class="italic">Figure 4.1</em>:</p>
<figure class="mediaobject"><img alt="Figure 4.1 – The flow of the counter component " src="img/B21849_04_01.png"/></figure>
<p class="packt_figref">Figure 4.1: The flow of the counter component</p>
<p class="normal">The <code class="inlineCode">counter</code> component is implemented inside the <code class="inlineCode">BlazorWebApp.Client</code> project, which is the WebAssembly project. In that project, we should put all the components that we want to run as WebAssembly. The <code class="inlineCode">BlazorWebApp</code> project is then referencing the <code class="inlineCode">BlazorWebApp.Client</code> project, so that it finds all the components and can run them as Blazor Server components if we want to. </p>
<h2 class="heading-2" id="_idParaDest-65">Weather</h2>
<p class="normal">The next component <a id="_idIndexMarker127"/>we will take a look at is the <code class="inlineCode">Weather</code> component. It’s located in the <code class="inlineCode">Components/Pages/Weather.razor</code> folder.</p>
<p class="normal">The <code class="inlineCode">Weather</code> components introduces the new streaming rendering functionality. The file initially looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/weather"
@attribute [StreamRendering(true)]
</code></pre>
<p class="normal">Just as with the <code class="inlineCode">Counter</code> component, we first define a route. There is no render mode attribute on this page. The component will be<a id="_idIndexMarker128"/> rendered using <strong class="keyWord">Server-Side Rendering</strong> (<strong class="keyWord">SSR</strong>). This is the default behavior for all the components unless specified, like the Counter component. </p>
<p class="normal">When we started the project, we set <strong class="screenText">Interactivity location </strong>to <strong class="screenText">Per Page/Component</strong>. This means that when we want interactivity, we need to specify that. But with the <code class="inlineCode">[StreamRendering(true)]</code> attribute, we will get a feeling of interactivity. The page will first load, showing loading text. Then, using the same request, we get the rest of the data, like a <code class="inlineCode">…</code> well, stream. So, we will get fast loading without waiting for the data, with no need to add interactivity using WebAssembly or SignalR, but still get some loading progress happening. We will dive into this some more in a later section.</p>
<p class="normal">The HTML part of the <code class="inlineCode">Weather</code> component looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PageTitle&gt;Weather&lt;/PageTitle&gt;
&lt;h1&gt;Weather&lt;/h1&gt;
&lt;p&gt;This component demonstrates showing data.&lt;/p&gt;
@if (forecasts == null)
{
    &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;
}
else
{
    &lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Temp. (C)&lt;/th&gt;
&lt;th&gt;Temp. (F)&lt;/th&gt;
&lt;th&gt;Summary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
            @foreach (var forecast in forecasts)
            {
                &lt;tr&gt;
&lt;td&gt;@forecast.Date.ToShortDateString()&lt;/td&gt;
&lt;td&gt;@forecast.TemperatureC&lt;/td&gt;
&lt;td&gt;@forecast.TemperatureF&lt;/td&gt;
&lt;td&gt;@forecast.Summary&lt;/td&gt;
&lt;/tr&gt;
            }
        &lt;/tbody&gt;
&lt;/table&gt;
}
</code></pre>
<p class="normal">If we don’t have any forecasts, it will show “Loading…” and as soon as we have some data, it will render a table showing the data.</p>
<p class="normal">The code section that generates some mock data looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@code {
    private WeatherForecast[]? forecasts;
    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate streaming rendering
await Task.Delay(500);
        var startDate = DateOnly.FromDateTime(DateTime.Now);
        var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
        forecasts = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
    }
    private class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
    }
} 
</code></pre>
<p class="normal">When the page is initialized, the <code class="inlineCode">WeatherForecast</code> array is filled with random data.</p>
<p class="normal">This reminds me that someone (as a joke) added a bug report to one of Dan Roth’s repos on GitHub, reporting “Weather forecast is unreliable.”</p>
<p class="normal">The conversation continued, “The weather forecast feature was completely accurate during my trip to London but has proven to be misleading in California. Counter and overall purpleness are great.” With Dan Roth replying: “Thanks for the feedback! I’ll get in touch with the<a id="_idIndexMarker129"/> folks on the .NET core framework team to make sure that <code class="inlineCode">System.Random</code> does a better job of taking California weather patterns into account.”</p>
<p class="normal">This is one of many reasons why I love the .NET community.</p>
<p class="normal">As we can see, by using the Razor syntax, we are seamlessly mixing code with HTML. The code checks whether there is any data – if so, it will render the table; if not, it will show a loading message. The component will update automatically once we have data. We have full control over the HTML, and Blazor will not add anything to the generated HTML.</p>
<p class="normal">There are component libraries that can make this process a bit simpler, which we will look at in the next chapter, <em class="chapterRef">Chapter 5</em>, <em class="italic">Creating Advanced Blazor Components</em>.</p>
<p class="normal">Now that we know how the sample template is implemented, it is time to dive deeper into the Razor syntax.</p>
<h1 class="heading-1" id="_idParaDest-66">Learning Razor syntax</h1>
<p class="normal">One of the things I like <a id="_idIndexMarker130"/>about the Razor syntax is that it is easy to mix code and HTML tags. By having the code close to the markup, it is, in my opinion, easier to follow and understand. The syntax is very fluid; the razor parser understands when the code stops and markup begins, which means we don’t need to think about it that much. It is also not a new language; instead, we can leverage our existing C# and HTML knowledge to create our components. This section will contain a lot of theory to help us understand the Razor syntax.</p>
<p class="normal">To transition from HTML to code (C#), we use the <code class="inlineCode">@</code> symbol. There are a handful of ways we can add code to our<a id="_idIndexMarker131"/> file, which we’ll explore in the following sections:</p>
<ul>
<li class="bulletList">Razor code blocks</li>
<li class="bulletList">Implicit Razor expressions</li>
<li class="bulletList">Explicit Razor expressions</li>
<li class="bulletList">Expression encoding</li>
<li class="bulletList">Directives</li>
</ul>
<h2 class="heading-2" id="_idParaDest-67">Razor code blocks</h2>
<p class="normal">We have already<a id="_idIndexMarker132"/> seen some code blocks. A code block looks<a id="_idIndexMarker133"/> like this:</p>
<pre class="programlisting code"><code class="hljs-code">@code {
    //your code here
}
</code></pre>
<p class="normal">If we wish, we can skip the <code class="inlineCode">code</code> keyword like so:</p>
<pre class="programlisting code"><code class="hljs-code">@{
    //your code here
}
</code></pre>
<p class="normal">Inside those curly braces, we can mix HTML and code like this:</p>
<pre class="programlisting code"><code class="hljs-code">@{
    void RenderName(string name)
    {
        &lt;p&gt;Name: &lt;strong&gt;@name&lt;/strong&gt;&lt;/p&gt;
    }
    RenderName("Steve Sanderson");
    RenderName("Daniel Roth");
}
</code></pre>
<p class="normal">Notice how the <code class="inlineCode">RenderName()</code> method transitions from code into the paragraph tags and back to code; this is an implicit transition.</p>
<p class="normal">If we want to output<a id="_idIndexMarker134"/> text without having an HTML tag, we can use the <code class="inlineCode">text</code> tag instead of using the paragraph tags, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;text&gt;Name: &lt;strong&gt;@name&lt;/strong&gt;&lt;/text&gt;
</code></pre>
<p class="normal">This would render the same<a id="_idIndexMarker135"/> result as the previous code but without the paragraph tags, and the <code class="inlineCode">text</code> tag wouldn’t be rendered.</p>
<h2 class="heading-2" id="_idParaDest-68">Implicit Razor expressions</h2>
<p class="normal"><strong class="keyWord">Implicit Razor expressions</strong> are <a id="_idIndexMarker136"/>when we add code inside HTML <a id="_idIndexMarker137"/>tags.</p>
<p class="normal">We have already seen this in the <code class="inlineCode">Weather</code> example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;td&gt;@forecast.Summary&lt;/td&gt;
</code></pre>
<p class="normal">We start with a <code class="inlineCode">&lt;td&gt;</code> tag, then use the <code class="inlineCode">@</code> symbol to switch to C#, and switch back to HTML with the end tag. We can use the <code class="inlineCode">await</code> keyword together with a method call, but other than that, implicit Razor expressions cannot contain any spaces.</p>
<p class="normal">We cannot call a generic method using implicit expressions since <code class="inlineCode">&lt;&gt;</code> would be interpreted as HTML. Hence, to solve this issue, we can use explicit expressions.</p>
<h2 class="heading-2" id="_idParaDest-69">Explicit Razor expressions</h2>
<p class="normal">We can use explicit <a id="_idIndexMarker138"/>Razor expressions if we want to use spaces in the code. Write<a id="_idIndexMarker139"/> the code with the <code class="inlineCode">@</code> symbol followed by parentheses <code class="inlineCode">( )</code>. So, it would look like this: <code class="inlineCode">@()</code>.</p>
<p class="normal">In this sample, we subtract <code class="inlineCode">7</code> days from the current date:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;td&gt;@(DateTime.Now - TimeSpan.FromDays(7))&lt;/td&gt;
</code></pre>
<p class="normal">We can also use explicit Razor expressions to concatenate text; for example, we can concatenate text and code like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;td&gt;Temp@(forecast.TemperatureC)&lt;/td&gt;
</code></pre>
<p class="normal">The output would then be <code class="inlineCode">&lt;td&gt;Temp42&lt;/td&gt;</code>.</p>
<p class="normal">Using explicit expressions, we can easily call generic methods by using this syntax:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;td&gt;@(MyGenericMethod&lt;string&gt;())&lt;/td&gt;
</code></pre>
<p class="normal">The Razor engine<a id="_idIndexMarker140"/> knows whether we are using code or not. It also makes sure to<a id="_idIndexMarker141"/> encode strings to HTML when outputting it to the browser, called <strong class="keyWord">expression encoding</strong>.</p>
<h2 class="heading-2" id="_idParaDest-70">Expression encoding</h2>
<p class="normal">If we have HTML as a string, it will be <a id="_idIndexMarker142"/>escaped by default. Take this <a id="_idIndexMarker143"/>code, for example:</p>
<pre class="programlisting code"><code class="hljs-code">@("&lt;span&gt;Hello World&lt;/span&gt;")
</code></pre>
<p class="normal">The rendered HTML would look like this:</p>
<pre class="programlisting code"><code class="hljs-code">&amp;lt;span&amp;gt;Hello World&amp;lt;/span&amp;gt;
</code></pre>
<p class="normal">To output the actual HTML from a string (something we will do later, in <em class="chapterRef">Chapter 5</em>, <em class="italic">Creating Advanced Blazor Components</em>), you can use this syntax:</p>
<pre class="programlisting code"><code class="hljs-code">@((MarkupString)"&lt;span&gt;Hello World&lt;/span&gt;")
</code></pre>
<p class="normal">Using <code class="inlineCode">MarkupString</code>, the output will be HTML, showing the HTML tag span. In some cases, one line of code isn’t enough; then, we can use code blocks.</p>
<h2 class="heading-2" id="_idParaDest-71">Directives</h2>
<p class="normal">There are a bunch <a id="_idIndexMarker144"/>of directives that change the way a component gets parsed or can enable functionality. These are reserved keywords that follow the <code class="inlineCode">@</code> symbol. We will go through the most common and useful ones.</p>
<p class="normal">I find that it is pretty nice to have the layout and the code inside of the same <code class="inlineCode">.razor</code> file.</p>
<p class="normal">Note that we can use code-behind to write our code to get a bit more separation between the code and layout. Later in this chapter, we will look at how to use code-behind instead of Razor syntax for everything. For now, the following examples will look at how we would do the same directives using both Razor syntax and code-behind.</p>
<h3 class="heading-3" id="_idParaDest-72">Adding an attribute</h3>
<p class="normal">To add an <a id="_idIndexMarker145"/>attribute to our <a id="_idIndexMarker146"/>page, we can use the <code class="inlineCode">attribute</code> directive:</p>
<pre class="programlisting code"><code class="hljs-code">@attribute [Authorize]
</code></pre>
<p class="normal">If we were using a code-behind file, we would use the following syntax instead:</p>
<pre class="programlisting code"><code class="hljs-code">[Authorize] public partial class SomeClass {}
</code></pre>
<h3 class="heading-3" id="_idParaDest-73">Adding an interface</h3>
<p class="normal">To implement <a id="_idIndexMarker147"/>an interface (<code class="inlineCode">IDisposable</code> in this case), we would use the following code:</p>
<pre class="programlisting code"><code class="hljs-code">@implements IDisposable
</code></pre>
<p class="normal">Then, we would implement the methods the interface needs in a <code class="inlineCode">@code{}</code> section.</p>
<p class="normal">To do the same in a code-behind scenario, we would add the interface after the class name, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">public partial class SomeClass : IDisposable {}
</code></pre>
<h3 class="heading-3" id="_idParaDest-74">Inheriting</h3>
<p class="normal">To inherit another<a id="_idIndexMarker148"/> class, we should use the following code:</p>
<pre class="programlisting code"><code class="hljs-code">@inherits TypeNameOfClassToInheritFrom
</code></pre>
<p class="normal">To do the same in a code-behind scenario, we would add the class we want to inherit from after the class name:</p>
<pre class="programlisting code"><code class="hljs-code">public class SomeClass : TypeNameOfClassToInheritFrom {}
</code></pre>
<h3 class="heading-3" id="_idParaDest-75">Generics</h3>
<p class="normal">We can define<a id="_idIndexMarker149"/> our component as a generic component.</p>
<p class="normal">Generics<a id="_idIndexMarker150"/> allow us<a id="_idIndexMarker151"/> to define the data type, so the component works with any data type.</p>
<p class="normal">To define a component as a generic component, we add the <code class="inlineCode">@typeparam</code> directive; then, we can use the type in the code of the component like this:</p>
<pre class="programlisting code"><code class="hljs-code">@typeparam TItem
@code
{
      [Parameter]
      public List&lt;TItem&gt; Data { get; set; }
}
</code></pre>
<p class="normal">Generics are super-powerful <a id="_idIndexMarker152"/>when creating reusable components; this will make our components reusable for different data types. We will return to generics in <em class="chapterRef">Chapter 6</em>, <em class="italic">Building Forms with Validation</em>.</p>
<h3 class="heading-3" id="_idParaDest-76">Changing the layout</h3>
<p class="normal">If we want to have a<a id="_idIndexMarker153"/> specific layout for a page (not the default one specified in the <code class="inlineCode">Routes.razor</code> file), we can use the <code class="inlineCode">@layout</code> directive:</p>
<pre class="programlisting code"><code class="hljs-code">@layout AnotherLayout
</code></pre>
<p class="normal">This way, our component will use the specified layout (this only works for components with the <code class="inlineCode">@page</code> directive).</p>
<h3 class="heading-3" id="_idParaDest-77">Setting a namespace</h3>
<p class="normal">By default, the <a id="_idIndexMarker154"/>component’s namespace will be the name of the default namespace of our project, plus the folder structure. If we want our component to be in a specific namespace, we can use the following:</p>
<pre class="programlisting code"><code class="hljs-code">@namespace Another.NameSpace
</code></pre>
<h3 class="heading-3" id="_idParaDest-78">Setting a route</h3>
<p class="normal">We have already<a id="_idIndexMarker155"/> touched on the <code class="inlineCode">@page</code> directive. If we want our component to be directly accessed using a URL, we can use the <code class="inlineCode">@page</code> directive:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/theurl"
</code></pre>
<p class="normal">The URL can contain parameters, subfolders, and much more, which we will return to later in this chapter.</p>
<h3 class="heading-3" id="_idParaDest-79">Adding a using statement</h3>
<p class="normal">To add a namespace to<a id="_idIndexMarker156"/> our component, we can use the <code class="inlineCode">@using</code> directive:</p>
<pre class="programlisting code"><code class="hljs-code">@using System.IO
</code></pre>
<p class="normal">If there are namespaces that<a id="_idIndexMarker157"/> we use in several of our components, then we can add them to the <code class="inlineCode">_Imports.razor</code> file instead. This way, they will be available in all<a id="_idIndexMarker158"/> the components we create.</p>
<div><p class="normal">If you want to dive further<a id="_idIndexMarker159"/> into directives, you can find more information here: <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives">https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives</a></p>
</div>
<p class="normal">Now we know more about how Razor syntax works. Don’t worry; we will have plenty of time to practice it. There is one more directive that I haven’t covered in this section, and that is <code class="inlineCode">inject</code>. We first need to understand what <strong class="keyWord">Dependency Injection</strong> (<strong class="keyWord">DI</strong>) is and how it works, which we will see in the next section.</p>
<h1 class="heading-1" id="_idParaDest-80">Understanding dependency injection</h1>
<p class="normal">DI is a software pattern<a id="_idIndexMarker160"/> and a technique to implement <strong class="keyWord">Inversion of Control</strong> (<strong class="keyWord">IoC</strong>).</p>
<p class="normal">IoC is a generic term that <a id="_idIndexMarker161"/>means we can indicate that the class needs a class instance instead of letting our classes instantiate an object. We can say that our class wants either a specific class or a specific interface. </p>
<p class="normal">The creation of the class is somewhere else, and it is up to IoC what class it will create.</p>
<p class="normal">When it comes to DI, it is a form of IoC when an object (class instance) is passed through constructors, parameters, or service lookups.</p>
<p class="normal">Here is a great resource if you want to dive <a id="_idIndexMarker162"/>deeper into DI in .NET: <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection">https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection</a>.</p>
<p class="normal">In Blazor, we can configure DI by providing a way to instantiate an object; this is a key architecture pattern that we should use. We have already seen a couple of references to it, for example, in <code class="inlineCode">Program.cs</code>:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped&lt;IBlogApi, BlogApiJsonDirectAccess&gt;(); 
</code></pre>
<p class="normal">Here, we say that if any class wants <code class="inlineCode">IBlogApi</code>, the application should instantiate an object of the <code class="inlineCode">BlogApiJsonDirectAccess</code> type. In this case, we are using an interface; instead, we could just say:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped&lt;BlogApiJsonDirectAccess&gt;(); 
</code></pre>
<p class="normal">In this case, when we ask for a <code class="inlineCode">BlogApiJsonDirectAccess</code> object, it will return an object of that type. If there only is one implementation of the thing we are building, there is no reason to create an interface <a id="_idIndexMarker163"/>for it. In the previous chapter, <em class="chapterRef">Chapter 3</em>, <em class="italic">Managing State – Part 1</em>. We created an <code class="inlineCode">IBlogApi</code> interface that returned an instance of <code class="inlineCode">BlogApiJsonDirectAccess</code>. When we implement the WebAssembly version, DI will return another class instead.</p>
<p class="normal">There are many advantages to using DI. Our dependencies are loosely coupled, so we don’t instantiate another class in our class. Instead, we ask for an instance, which makes it easier to write tests and change implementations depending on platforms.</p>
<p class="normal">Any external dependencies will be much more apparent since we must pass them into the class. We also can set the way we should instantiate the object in a central place. We configure the DI in <code class="inlineCode">Program.cs</code>.</p>
<p class="normal">We can configure the creation of objects in different ways, such as the following:</p>
<ul>
<li class="bulletList">Singleton</li>
<li class="bulletList">Scoped</li>
<li class="bulletList">Transient</li>
</ul>
<h2 class="heading-2" id="_idParaDest-81">Singleton</h2>
<p class="normal">When we use a singleton, the <a id="_idIndexMarker164"/>object will be the same for all site users. The object will only be created once.</p>
<p class="normal">To configure a singleton service, use the following:</p>
<pre class="programlisting code"><code class="hljs-code">services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();
</code></pre>
<p class="normal">We should use a singleton when we want to share our object with all the users of our site, but beware because since the state is shared, it can lead to issues if the object stores data specific to an individual user or a session because once this data is changed by one user, the<a id="_idIndexMarker165"/> change is reflected for all users who might be using the application simultaneously. It may also lead to data being shared unintentionally. </p>
<h2 class="heading-2" id="_idParaDest-82">Scoped</h2>
<p class="normal">When we use scoped, a new object will be created once for each connection, and since Blazor Server needs a<a id="_idIndexMarker166"/> connection to work, it will be the same object as long as the user has a connection. WebAssembly does not have the concept of scoped, since there is no connection, so all the code runs inside the user’s web browser. If we use scoped, it will work the same way as a singleton for Blazor WebAssembly, since we only have one user and everything is running inside the browser. The recommendation is still to use scoped if the idea is to scope a service to the current user. This makes it easier to move code between Blazor Server and Blazor WebAssembly and gives a bit more context on how the service is supposed to be used.</p>
<p class="normal">To configure a scoped service, use the following:</p>
<pre class="programlisting code"><code class="hljs-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();
</code></pre>
<p class="normal">We should use scoped if we have data that belongs to the user. We can keep the user’s state by using scoped objects. More on that in <em class="chapterRef">Chapter 11</em>, <em class="italic">Managing State – Part 2</em>.</p>
<p class="normal">It’s worth mentioning here that the new “per component” model will create a SignalR connection if there is any component currently running in InteractiveServer mode. If we navigate to a new page without any <code class="inlineCode">InteractiveServer</code> components, the connection will eventually be disconnected. This means that the state will also be removed. So, when using the “per component” model, we need to make sure not to save any important information in a scoped variable unless we persist it in some other way as well.</p>
<h2 class="heading-2" id="_idParaDest-83">Transient</h2>
<p class="normal">When we use<a id="_idIndexMarker167"/> transient, a new object will be created every time we ask for it.</p>
<p class="normal">To configure a transient service, use the following:</p>
<pre class="programlisting code"><code class="hljs-code">services.AddTransient&lt;IWeatherForecastService, WeatherForecastService&gt;();
</code></pre>
<p class="normal">We can use transient if we don’t need to keep any state, and we don’t mind the object being created every time we ask for it.</p>
<p class="normal">Now that we know<a id="_idIndexMarker168"/> how to configure a service, we need to start using the service by injecting it.</p>
<h2 class="heading-2" id="_idParaDest-84">Injecting the service</h2>
<p class="normal">There are three <a id="_idIndexMarker169"/>ways to inject a service. We can use the <code class="inlineCode">@inject</code> directive in the Razor file:</p>
<pre class="programlisting code"><code class="hljs-code">@inject WeatherForecastService ForecastService
</code></pre>
<p class="normal">This will make sure we have access to <code class="inlineCode">WeatherForecastService</code> in our component.</p>
<p class="normal">The second way is to create a property by adding the <code class="inlineCode">Inject</code> attribute if we are using code-behind:</p>
<pre class="programlisting code"><code class="hljs-code">[Inject]
public WeatherForecastService ForecastService { get; set; }
</code></pre>
<p class="normal">The third way is for when we want to inject a service into another service – then, we need to inject the services using the constructor:</p>
<pre class="programlisting code"><code class="hljs-code">public class MyService
{
    public MyService(WeatherForecastService
      weatherForecastService)
    {
    }
}
</code></pre>
<p class="normal">Now we know how DI works and why we should use it. In .NET 7, using a scoped service meant that the data was accessible as long as the connection (or circuit) was active. But with .NET 8, it changes just slightly depending on the render mode. Let’s look at that next. </p>
<h2 class="heading-2" id="_idParaDest-85">Changing the render mode</h2>
<p class="normal">The biggest change when it comes to .NET 8 is the ability to change render mode in the same app. In .NET 7, we had to choose one or the other, but with .NET 8, we can change it as we see fit. Perhaps if a <a id="_idIndexMarker170"/>specific page is not interactive, we can use the new <strong class="keyWord">Server-Side Rendering </strong>(<strong class="keyWord">SSR</strong>). This is very similar to WebForms or MVC. The page gets rendered on the server. No<a id="_idIndexMarker171"/> additional interactivity will work. We can set the render mode on each component, or we can do it when we use the component. When we create the project, we select what interactive render mode we want.</p>
<p class="normal">Let’s take a look at the different options:</p>
<ul>
<li class="bulletList"><strong class="keyWord"> None</strong> – No interactivity, only static rendered files, no SignalR, and no WebAssembly. Using this option, we can use both static SSR and streaming server-side rendering.</li>
<li class="bulletList"><strong class="keyWord"> Server</strong> – This will give us access to interactivity using Blazor Server, not WebAssembly.</li>
<li class="bulletList"><strong class="keyWord"> WebAssembly</strong> – This will give us access to interactivity using Blazor WebAssembly, not Blazor Server.</li>
<li class="bulletList"><strong class="keyWord">Auto</strong> (Server and WebAssembly) – Gives us the ability to use both Server and WebAssembly.</li>
</ul>
<p class="normal"> We also set <strong class="screenText">Interactivity location </strong>to <strong class="screenText">Per page/component</strong>, which means that the default behavior of the site is static, and we need to specify on each component if we want to use interactivity. We can also set it to <strong class="screenText">Global</strong>, which will set the interactivity on the <code class="inlineCode">Routes</code> component like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Routes @rendermode="@InteractiveAuto" /&gt;
</code></pre>
<p class="normal">To change the render mode per component, we can use the syntax above or use the attribute we saw in the Counter component:</p>
<pre class="programlisting code"><code class="hljs-code">@rendermode InteractiveAuto
</code></pre>
<p class="normal">By default, all components are rendered using server pre-rendering. This means that the component is first rendered on the server and then pushed to the web browser. SignalR or WebAssembly starts up, and the component is rendered again, making additional calls to the database, for example. I personally rarely use server pre-rendering. I like that the pages load by first sending what the server has ready and then, when database calls are done, sends the rest. We can also disable pre-rendering by doing it like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Routes @rendermode="new InteractiveServerRenderMode(prerender: false)" /&gt;
</code></pre>
<p class="normal">We will have plenty of time to learn more about render modes during the course of the book. In .NET 7, we had more<a id="_idIndexMarker172"/> templates, but by using combinations of these settings, we can create the same scenarios.</p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal">.NET 7 Template</p>
</td>
<td class="table-cell">
<p class="normal">.NET 8 Template</p>
</td>
<td class="table-cell">
<p class="normal">Interactive render mode</p>
</td>
<td class="table-cell">
<p class="normal">Interactivity location</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blazor Server App</p>
</td>
<td class="table-cell">
<p class="normal">Blazor Web App</p>
</td>
<td class="table-cell">
<p class="normal">Server</p>
</td>
<td class="table-cell">
<p class="normal">Global</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blazor WebAssembly App</p>
</td>
<td class="table-cell">
<p class="normal">Blazor WebAssembly Standalone App</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blazor WebAssembly (ASP.NET Core Hosted)</p>
</td>
<td class="table-cell">
<p class="normal">Blazor Web App</p>
</td>
<td class="table-cell">
<p class="normal">WebAssembly</p>
</td>
<td class="table-cell">
<p class="normal">Global</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">If you are new to Blazor, this table has no significance, but if you have worked with Blazor in .NET 7 and want to use a project template that you have used in .NET 7, this is how to do it. In this chapter, we have mentioned code-behind a couple of times. In the next section, we will look at how we can use code-behind with Razor files and skip the Razor files altogether.</p>
<h1 class="heading-1" id="_idParaDest-86">Figuring out where to put the code</h1>
<p class="normal">We have seen examples of writing code directly in the Razor file. I prefer doing that unless the code gets too long or too complicated. I always lean in favor of readability.</p>
<p class="normal">There are four ways we can write our components:</p>
<ul>
<li class="bulletList">In the Razor file</li>
<li class="bulletList">In a partial class</li>
<li class="bulletList">Inheriting a class</li>
<li class="bulletList">Only code</li>
</ul>
<p class="normal">Let’s go through each item on this list in more detail.</p>
<h2 class="heading-2" id="_idParaDest-87">In the Razor file</h2>
<p class="normal">If we are writing<a id="_idIndexMarker173"/> a file that is not that complex, it would be nice not to switch files when writing components. As we already covered in this chapter, we can use the <code class="inlineCode">@code</code> directive to add code directly to our Razor file.</p>
<p class="normal">If we want to move the code to a code-behind file, then it is only the directives that we need to change. For the rest of the code, we can just move to the code-behind class. When I started with Blazor, writing code and markup in the same file felt strange, coming from an MVC world where the separation between code and markup is a big part of the way to use MVC. But I suggest you try it out when developing your web apps.</p>
<p class="normal">At work, we started using code-behind but switched to writing code in the <code class="inlineCode">.razor</code> file instead, and we haven’t looked back since.</p>
<p class="normal">However, many developers prefer code-behind, separating code from the layout. For that, we can use a partial class.</p>
<h2 class="heading-2" id="_idParaDest-88">In a partial class</h2>
<p class="normal">We can create a partial class<a id="_idIndexMarker174"/> with the same filename as the Razor file and add <code class="inlineCode">.cs</code>.</p>
<p class="normal">If you have downloaded the source code (or you can check the code on GitHub), you can look at <code class="inlineCode">WeatherCodeBehind.razor.cs</code> in the <code class="inlineCode">Examples</code> folder. I have moved all the code to the code-behind file; the result when compiling this will be the same as if we kept the code in the Razor file. It is just a matter of preference.</p>
<p class="normal">The code-behind looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">namespace BlazorWebApp.Components.Pages;
[StreamRendering(true)]
public partial class WeatherWithCodeBehind
{
    private WeatherForecast[]? forecasts;
    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate streaming rendering
await Task.Delay(500);
        var startDate = DateOnly.FromDateTime(DateTime.Now);
        var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
        forecasts = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
    }
    private class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
    }
}
</code></pre>
<p class="normal">Since we are using a partial class, there is no need to connect the razor with the code-behind. If it has the same <a id="_idIndexMarker175"/>name, it will just work. We can mix where we put the code; in this case, we have the <code class="inlineCode">StreamingRendering</code> attribute in the code-behind, and we can keep it in the <code class="inlineCode">.razor</code> file if we want to. If you prefer using code-behind, this is the way you want to do it.</p>
<p class="normal">This is not the only way to use a code-behind file; we can also inherit from a code-behind file.</p>
<h2 class="heading-2" id="_idParaDest-89">Inheriting a class</h2>
<p class="normal">We can also create a completely different class (the common pattern is to call it the same thing as the<a id="_idIndexMarker176"/> Razor file and add <code class="inlineCode">Model</code> at the end) and inherit it in our Razor file. For that to work, we need to inherit from <code class="inlineCode">ComponentBase</code>. In the case of a partial class, the class already inherits from <code class="inlineCode">ComponentBase</code>, since the Razor file does that.</p>
<p class="normal">Fields must be protected or public (not private) for the page to access the fields. I recommend using the partial class if we don’t need to inherit from our base class.</p>
<p class="normal">This is a snippet of the code-behind class declaration:</p>
<pre class="programlisting code"><code class="hljs-code">public class WeatherWithInheritsModel:ComponentBase
</code></pre>
<p class="normal">We’ll need to inherit from <code class="inlineCode">ComponentBase</code> or from a class that inherits from <code class="inlineCode">ComponentBase</code>.</p>
<p class="normal">In the Razor file, we will use the <code class="inlineCode">@inherits</code> directive:</p>
<pre class="programlisting code"><code class="hljs-code">@inherits WeatherWithInheritsModel
</code></pre>
<p class="normal">The Razor file will now inherit from our code-behind class (this was the first way available to create code-behind classes).</p>
<p class="normal">Both the partial and inherit options are simple ways of moving the code to a code-behind file. Inheriting a model was the first available way, but as I mentioned, use partial classes instead if you prefer code-behind. But another option is to skip the Razor file and use only code entirely.</p>
<h2 class="heading-2" id="_idParaDest-90">Only code</h2>
<p class="normal">Visual Studio will use source<a id="_idIndexMarker177"/> generators to convert the Razor code into C#. We will dig deeper into source generators in <em class="chapterRef">Chapter 17</em>, <em class="italic">Examining Source Generators</em>. The Razor file will generate code at compile time. We can skip the Razor step if we want to and write our layout completely in code.</p>
<p class="normal">This file (<code class="inlineCode">CounterWithoutRazor.cs</code>) is available on GitHub.</p>
<p class="normal">The counter example would look like this:</p>
<pre class="programlisting code"><code class="hljs-code">using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.Web;
namespace BlazorWebApp.Component.Pages;
[Route("/CounterWithoutRazor")]
public class CounterWithoutRazor : ComponentBase
{
    protected override void BuildRenderTree
      (RenderTreeBuilder builder)
    {
        builder.AddMarkupContent(0, "&lt;h1&gt;Counter&lt;/h1&gt;\r\n\r\n");
        builder.OpenElement(1, "p");
        builder.AddContent(2, "Current count: ");
        builder.AddContent(3, currentCount);
        builder.CloseElement();
        builder.AddMarkupContent(4, "\r\n\r\n");
        builder.OpenElement(5, "button");
        builder.AddAttribute(6, "class", "btn btn-primary");
        builder.AddAttribute(7, "onclick", EventCallback.Factory.Create&lt;MouseEventArgs&gt;(this, IncrementCount));
        builder.AddContent(8, "Click me");
        builder.CloseElement();
    }
    private int currentCount = 0;
    private void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre>
<p class="normal">The Razor file will first be converted into something roughly the same as the previous code, and then the code is compiled. It adds the elements one by one, which, in the end, will render the HTML.</p>
<p class="normal">The numbers in the code <a id="_idIndexMarker178"/>are how Blazor keeps track of each element in the render tree. Some prefer to write the code as in the previous code block rather than using the Razor syntax; there are even efforts in the community to simplify the process of manually writing the <code class="inlineCode">BuildRenderTree()</code> function.</p>
<p class="normal">Some of Microsoft’s built-in components are built in this way.</p>
<p class="normal">I recommend never writing this manually, but I’ve kept it in the book because it shows how Razor files get compiled. Now that we know how to use code-behind, let’s look at the lifecycle events of Blazor and when they get executed.</p>
<h1 class="heading-1" id="_idParaDest-91">Lifecycle events</h1>
<p class="normal">We can use a couple of lifecycle events to run our code. In this section, we will go through them and see when we should use them. Most lifecycle events have two versions – synchronous and asynchronous.</p>
<h2 class="heading-2" id="_idParaDest-92">OnInitialized and OnInitializedAsync</h2>
<p class="normal">The first time the <a id="_idIndexMarker179"/>component<a id="_idIndexMarker180"/> is loaded, <code class="inlineCode">OnInitialized()</code> is called, then <code class="inlineCode">OnInitializedAsync()</code>. This is a great method to load any data, as the <a id="_idIndexMarker181"/>UI has not <a id="_idIndexMarker182"/>yet been rendered. If we are doing long-running tasks (such as getting data from a database), we should put that code in<a id="_idIndexMarker183"/> the <code class="inlineCode">OnInitializedAsync()</code> method.</p>
<p class="normal">These methods will <a id="_idIndexMarker184"/>only run once. If you want to update the<a id="_idIndexMarker185"/> UI when a <a id="_idIndexMarker186"/>parameter changes, see <code class="inlineCode">OnParametersSet()</code> and <code class="inlineCode">OnParametersSetAsync()</code>.</p>
<h2 class="heading-2" id="_idParaDest-93">OnParametersSet and OnParametersSetAsync</h2>
<p class="normal"><code class="inlineCode">OnParametersSet()</code> and <code class="inlineCode">OnParametersSetAsync()</code> are called when the component is initialized (after <code class="inlineCode">OnInitialized()</code> and <code class="inlineCode">OnInitializedAsync()</code>) and whenever we change the<a id="_idIndexMarker187"/> value of a <a id="_idIndexMarker188"/>parameter.</p>
<p class="normal">If we, for example, load <a id="_idIndexMarker189"/>data in the <code class="inlineCode">OnInitialized()</code> method but it<a id="_idIndexMarker190"/> uses a parameter, the data won’t be reloaded if the parameter is changed since <code class="inlineCode">OnInitialized()</code> will only run once. We need to trigger a reload of the data in <code class="inlineCode">OnParametersSet()</code> or <code class="inlineCode">OnParametersSetAsync()</code> or move the loading to that method.</p>
<h2 class="heading-2" id="_idParaDest-94">OnAfterRender and OnAfterRenderAsync</h2>
<p class="normal">After the component renders, the <code class="inlineCode">OnAfterRender()</code> and <code class="inlineCode">OnAfterRenderAsync()</code> methods are<a id="_idIndexMarker191"/> called. When the methods are called, all the elements<a id="_idIndexMarker192"/> are rendered, so if we want/need to call any JavaScript code, we have to do that from these methods (we will get an error if <a id="_idIndexMarker193"/>we try to make a JavaScript interop from any of the other lifecycle event methods). This is a limitation of the prerendering. When the component prerenders, there is<a id="_idIndexMarker194"/> nothing connected to the web browser, and we will not be able to run any JavaScript. However, if we disable the prerendering, we can run JavaScript in the other lifecycle methods as well. We also have access to a <code class="inlineCode">firstRender</code> parameter, so we can only run our code on the first render. </p>
<h2 class="heading-2" id="_idParaDest-95">ShouldRender</h2>
<p class="normal"><code class="inlineCode">ShouldRender()</code> is<a id="_idIndexMarker195"/> called when our component is re-rendered; if it<a id="_idIndexMarker196"/> returns <code class="inlineCode">false</code>, the component will not be rendered again. The component will always render once, even if this method returns <code class="inlineCode">false</code>.</p>
<p class="normal"><code class="inlineCode">ShouldRender()</code> does not have an asynchronous option.</p>
<p class="normal">Now we know when the different lifecycle events happen and in what order. A component can also have parameters, and that way, we can reuse them but with different data.</p>
<h1 class="heading-1" id="_idParaDest-96">Parameters</h1>
<p class="normal">A parameter makes it <a id="_idIndexMarker197"/>possible to send a value to a component. To add a parameter to a component, we use the <code class="inlineCode">[Parameter]</code> attribute on the <code class="inlineCode">public</code> property:</p>
<pre class="programlisting code"><code class="hljs-code">@code {
    [Parameter]
    public int MyParameter { get; set; }
}
</code></pre>
<p class="normal">The syntax for this is the same if we use a code-behind file. We can add a parameter to the route using the <code class="inlineCode">@page</code> directive by specifying it in the route:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/parameterdemo/{MyParameter}"
</code></pre>
<p class="normal">In this case, we have to have a parameter specified with the same name as the name inside the curly braces. To set the parameter in the <code class="inlineCode">@page</code> directive, we go to <code class="inlineCode">/parameterdemo/THEVALUE</code>.</p>
<p class="normal">There are cases where we want to specify another type instead of a string (string is the default). We can add the data type after the parameter name like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/parameterdemo/{MyParameter:int}"
</code></pre>
<p class="normal">This will match the <a id="_idIndexMarker198"/>route only if the data type is an integer. We can also pass parameters using cascading parameters. We can also have more than one page directive per component if we want to handle more than one route.</p>
<h2 class="heading-2" id="_idParaDest-97">Cascading parameters</h2>
<p class="normal">If we want to pass <a id="_idIndexMarker199"/>a value to multiple components, we can use a cascading <a id="_idIndexMarker200"/>parameter.</p>
<p class="normal">Instead of using <code class="inlineCode">[Parameter]</code>, we can use <code class="inlineCode">[CascadingParameter]</code> like this:</p>
<pre class="programlisting code"><code class="hljs-code">[CascadingParameter]
public int MyParameter { get; set; }
</code></pre>
<p class="normal">To pass a value to the component, we surround it with a <code class="inlineCode">CascadingValue</code> component like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CascadingValue Value="MyProperty"&gt;
&lt;ComponentWithCascadingParameter/&gt;
&lt;/CascadingValue&gt; 
@code {
    public string MyProperty { get; set; } = "Test Value";
}
</code></pre>
<p class="normal"><code class="inlineCode">CascadingValue</code> is the<a id="_idIndexMarker201"/> value we pass to the component, and <code class="inlineCode">CascadingParameter</code> is the property that receives the value.</p>
<p class="normal">As we can see, we don’t pass any parameter values to the <code class="inlineCode">ComponentWithCascadingParameter</code> component; the cascading value will match the parameter with the same data type. If we have multiple parameters of the same type, we can specify the name of the parameter in the component with the cascading parameter like this:</p>
<pre class="programlisting code"><code class="hljs-code">[CascadingParameter(Name = "MyCascadingParameter")]
</code></pre>
<p class="normal">We can also do so for the component that passes <code class="inlineCode">CascadingValue</code>, like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CascadingValue Value="MyProperty" Name="MyCascadingParameter"&gt;
&lt;ComponentWithCascadingParameter/&gt;
&lt;/CascadingValue&gt;
</code></pre>
<p class="normal">If we know that the value won’t change, we can specify that by using the <code class="inlineCode">IsFixed</code> property:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CascadingValue Value="MyProperty" Name="MyCascadingParameter" IsFixed="True"&gt;
&lt;ComponentWithCascadingParameter/&gt;
&lt;/CascadingValue&gt;
</code></pre>
<p class="normal">This way, Blazor won’t look for changes, which is more efficient if we know the values won’t change. The cascading values/parameters cannot be updated upward but are updated only downward. This means that to update a cascading value, we need to implement it in another way; updating it from inside the component won’t change any components that are higher in the hierarchy.</p>
<p class="normal">In <em class="chapterRef">Chapter 5</em>, <em class="italic">Creating Advanced Blazor Components</em>, we will look at events, which are one way to solve the problem of updating a cascading value.</p>
<p class="normal">Phew! This has been<a id="_idIndexMarker202"/> an information-heavy chapter, but now <a id="_idIndexMarker203"/>we know the basics of Blazor components. Now, it is time to build one!</p>
<h1 class="heading-1" id="_idParaDest-98">Writing our first component</h1>
<p class="normal">The first component we<a id="_idIndexMarker204"/> will build shows all the blog posts on a site. To be fair, we haven’t written any blog posts yet, but we will temporarily solve that so we can start doing something fun.</p>
<p class="normal">In <em class="chapterRef">Chapter 3</em>, <em class="italic">Managing State – Part 1</em>, we created a JSON repository and an API (or interface); now, it is time to use them.</p>
<p class="normal">We will share the code between the <code class="inlineCode">BlazorWebApp</code> project and the <code class="inlineCode">BlazorWebApp.Client</code> project. We will even change the implementation of how they run depending on whether they run as WebAssembly or not.</p>
<p class="normal">There is a whole chapter on sharing (<em class="chapterRef">Chapter 9</em>, <em class="italic">Sharing Code and Resources</em>), but let’s start now.</p>
<h2 class="heading-2" id="_idParaDest-99">Creating a components library</h2>
<p class="normal">The first thing we need to do is to create a new project and then add our components to that project. We could have <a id="_idIndexMarker205"/>added the components to the <code class="inlineCode">BlazorWebApp</code> or the <code class="inlineCode">BlazorWebApp.Client</code> project directly, but this demonstrates how we can build reusable components and distribute them as packages later on.</p>
<p class="normal">To create our first component, follow these instructions:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Right-click on the <strong class="screenText">MyBlog</strong> solution and select <strong class="screenText">Add</strong> | <strong class="screenText">New Project</strong>.</li>
<li class="numberedList">Find the template <strong class="screenText">Razor Class Library</strong> and click <strong class="screenText">Next</strong>.</li>
<li class="numberedList">Name the project <code class="inlineCode">SharedComponents</code> and click <strong class="screenText">Next</strong>.</li>
<li class="numberedList">Select <strong class="screenText">.NET 8.0</strong> and click <strong class="screenText">Create</strong>.</li>
<li class="numberedList">We now have a project called <code class="inlineCode">SharedComponents</code>, where we can add all the components we want to share. Remove <code class="inlineCode">Component1.razor</code> and <code class="inlineCode">ExampleJsInterop.cs</code> that are created by default.</li>
<li class="numberedList">In the <code class="inlineCode">SharedComponents</code> project, add a project reference to <code class="inlineCode">Data.Models</code> and add the <code class="inlineCode">Nuget</code> package reference to <code class="inlineCode">Microsoft.AspNetCore.Components.Web</code>.</li>
</ol>
<p class="normal">We have a new<a id="_idIndexMarker206"/> project. This is where we can share components. Right now, we don’t have any components to share, but that is what we will do next.</p>
<h2 class="heading-2" id="_idParaDest-100">Using our components library</h2>
<p class="normal">We have a<a id="_idIndexMarker207"/> nice library, but for our project to trigger when we navigate to a route, we need to add additional assemblies to the router.</p>
<p class="normal">To do that, we need to follow a couple of steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">We already have a Home component in the <code class="inlineCode">BlazorWebApp</code> project so let’s delete that one. In the <code class="inlineCode">Components/Pages</code> folder, delete the <code class="inlineCode">Home.razor</code> file.</li>
<li class="numberedList">We need a component to navigate to. In the <code class="inlineCode">SharedComponents</code> project, in the Pages folder, we need to create a new component. You can select the folder or project node in the solution explorer and press <em class="keystroke">Shift</em> + <em class="keystroke">F2</em>, type <code class="inlineCode">Home.razor</code>, and press <em class="keystroke">Enter</em>. This is the fastest way to create new components.</li>
<li class="numberedList"> In the <code class="inlineCode">BlazorWebApp</code> project, add a project reference to the <code class="inlineCode">SharedComponents</code> project.</li>
<li class="numberedList">Also in the <code class="inlineCode">BlazorWebApp.Client</code> project, add a project reference to the <code class="inlineCode">SharedComponents</code> project.</li>
<li class="numberedList">Now, we have access to the shared components in both the WebAssembly project (<code class="inlineCode">BlazorWebApp.Client</code>) and the <code class="inlineCode">BlazorWebProject</code>. This means that we can run any component we put into the shared project (<code class="inlineCode">SharedComponents</code>) as <code class="inlineCode">InteractiveWebAssembly</code> or <code class="inlineCode">InteractiveServer</code>.</li>
<li class="numberedList">Open <code class="inlineCode">Router.razor</code>. It looks like this:
        <pre class="programlisting code"><code class="hljs-code">&lt;Router AppAssembly="@typeof(Program).Assembly" AdditionalAssemblies="new[] { typeof(Client._Imports).Assembly }"&gt;
</code></pre>
<p class="normal">The router defines where to look for components. <code class="inlineCode">AppAssembly</code> is where it will look first. We can also add additional assemblies, and as we can see, we already have an additional assembly. We are referencing the <code class="inlineCode">BlazorWebbApp.Client</code> project so that we can pre - render and server render (SignalR) the Counter component. But now we want to add an additional assembly. Change the router to this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Router AppAssembly="@typeof(Program).Assembly" AdditionalAssemblies="new[] { typeof(Client._Imports).Assembly,typeof(SharedComponents.Pages.Home).Assembly }"&gt;
</code></pre>
<p class="normal">We add the <a id="_idIndexMarker208"/>new assembly to additional assemblies. The router will now look for components in the <code class="inlineCode">SharedComponents</code> assembly as well.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">We also have to add a row in <code class="inlineCode">Program.cs</code>. In the <code class="inlineCode">BlazorWebApp</code> project, open <code class="inlineCode">Program.cs</code>. There, you will find these lines:
        <pre class="programlisting code"><code class="hljs-code"> app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(Counter).Assembly);
</code></pre>
<p class="normal">We need to add the new assembly there as well, like this:</p>
<pre class="programlisting code"><code class="hljs-code">app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(Counter).Assembly)
.AddAdditionalAssemblies(typeof(SharedComponents.Pages.Home).Assembly); 
</code></pre>
</li>
</ol>
<p class="normal">We need to add additional assemblies in the <code class="inlineCode">Program.cs</code> as well to get server-side rendering to work. Great! We have all components in a separate library and are sharing the components between the <code class="inlineCode">BlazorWebApp</code> and the <code class="inlineCode">BlazorWebApp.Client</code> projects.</p>
<h2 class="heading-2" id="_idParaDest-101">Creating our own component</h2>
<p class="normal">Now it’s time to start adding our own component!</p>
<p class="normal">OK, this is not <a id="_idIndexMarker209"/>completely true because we will continue working on <code class="inlineCode">Home.razor</code>. Let’s start by creating a component that lists our blog posts:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">Home.razor</code>.</li>
<li class="numberedList">Replace the contents of that file with the following code:
        <pre class="programlisting code"><code class="hljs-code">@page "/"
@using Data.Models.Interfaces
@using Data.Models
@inject IBlogApi _api
@code{
}
</code></pre>
<p class="normal">If we start from the top, we can see a page directive. It will ensure that the component is shown when the route is “<code class="inlineCode">/</code>". Then, we have three <code class="inlineCode">@using</code> directives, bringing <a id="_idIndexMarker210"/>in the namespaces so we can use them in the Razor file.</p>
<p class="normal">Then we inject our API (using DI) and name the instance <code class="inlineCode">_api</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Add a variable that holds all our posts. In the <code class="inlineCode">code</code> section, add the following:
        <pre class="programlisting code"><code class="hljs-code">protected List&lt;BlogPost&gt; posts = new();
</code></pre>
</li>
<li class="numberedList">Now, we need to load the data.
    <p class="normal">To load posts, add the following in the <code class="inlineCode">code</code> section:</p>
<pre class="programlisting code"><code class="hljs-code">protected override async Task OnInitializedAsync()
{
    posts = await _api.GetBlogPostsAsync(10, 0);
    await base.OnInitializedAsync();
}
</code></pre>
<p class="normal">Now, when the page loads, the posts will be loaded as well: <code class="inlineCode">10</code> posts and page <code class="inlineCode">0</code> (the first page).</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Under the <code class="inlineCode">@inject</code> row, add the following code:
        <pre class="programlisting code"><code class="hljs-code">&lt;ul&gt;
    @foreach (var p in posts)
    {
        &lt;li&gt;@p.Title&lt;/li&gt;
    }
&lt;/ul&gt;
</code></pre>
</li>
</ol>
<p class="normal">We add an <strong class="keyWord">Unordered List</strong> (<strong class="keyWord">UL</strong>); inside that, we<a id="_idIndexMarker211"/> loop over blog posts and show the title.</p>
<p class="normal">Now, we can run the application by pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">F5</em> (<strong class="screenText">Debug </strong>| <strong class="screenText">Start Without Debugging</strong>). Make sure you have the <code class="inlineCode">BlazorWebApp</code> selected as the startup project.</p>
<p class="normal">Since we don’t have any blog posts, this would take us to an empty page. Luckily, there is a folder in the<a id="_idIndexMarker212"/> repo called <code class="inlineCode">ExampleData</code>. If you download that, put those files in the <code class="inlineCode">Data</code> folder that we created in <em class="chapterRef">Chapter 3</em>, <em class="italic">Managing State – Part 1</em>, and reload the web, you should see a couple of posts.</p>
<p class="normal">Great job, we have created our first component!</p>
<p class="normal">There are a few noteworthy things. The <code class="inlineCode">SharedComponents</code> project knows nothing about the JSON repository implementation and only knows about the <code class="inlineCode">IBlogApi</code> interface.</p>
<p class="normal">The <code class="inlineCode">Home</code> component asks for an instance of <code class="inlineCode">IBlogApi</code>, and the <code class="inlineCode">BlazorWebApp</code> project knows it should return an instance of <code class="inlineCode">BlogApiJsonDirectAccess</code>. This is one of the things I love about Blazor; we can create components that only consume an interface and know nothing about the implementation.</p>
<p class="normal">We will return to this when we implement a web API for WebAssembly in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating an API</em>.</p>
<h1 class="heading-1" id="_idParaDest-102">Summary</h1>
<p class="normal">In this chapter, we learned a lot about Razor syntax – something we will use throughout the book. We learned about DI, directives, and parameters and, of course, created our first component. This knowledge will help us understand how to create and reuse components.</p>
<p class="normal">In the next chapter, we will look at more advanced component scenarios.</p>
</div>
</body></html>