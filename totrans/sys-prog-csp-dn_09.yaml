- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Hardware Handshakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hardware interaction* *and control*'
  prefs: []
  type: TYPE_NORMAL
- en: As system programmers, we never deal with users. We deal with other software.
    That other software could be on the same machine, or it could be on another machine.
    And sometimes, we deal with hardware. That hardware could be part of our machine,
    hardware attached to our machine, or hardware somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into all of these options. We will look at interacting
    with hardware directly and connecting to remote devices, and we will dive deep
    into the world of serial communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a serial port on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an Arduino device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming a simple program on an Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data from a serial port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events from the outside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging code depending on external devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make this sort of code as reliable as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, we have much ground to cover. Join me in exploring this new land
    of exotic hardware!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into some external hardware. I will show you how
    to talk to an **Arduino microcontroller** through a serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have access to such a device, do not worry. I will also talk about
    how to mock these devices so that you can test your code before deploying it on
    an actual device. You can follow along and try out the code if you encounter these
    devices later.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you can download the source code for these samples from the GitHub
    repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter09](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to serial ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to have some fun. Let’s break out of the confinements of the machine
    we are working on and step into the world of peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we look at the code, we have to see how software communicates
    with hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The path to the hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we have an application connecting to some hardware. It doesn’t matter
    what kind of hardware, but let’s say we want to send data to a USB port.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data from our application to the device involves several steps where
    the data is transformed. It is slightly like the OSI layer we discussed in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with our application. We devised the C# code to send data to the
    USB device. We have downloaded the correct NuGet packages, installed the frameworks,
    written the code, and compiled it into an executable.
  prefs: []
  type: TYPE_NORMAL
- en: When that executable runs, that code is called the correct code in the .NET
    libraries installed on your machine when you installed the runtime or the SDK.
    The BCL has a class called `SerialPort` that receives the commands from your code
    and translates them to the next layer, where the .NET runtime hands over the commands
    to the operating system. In our case, that is Windows. Windows looks at the data
    and where it needs to go and decides it cannot handle it. It is hardware, so the
    operating system calls upon the device driver for the USB port.
  prefs: []
  type: TYPE_NORMAL
- en: The device driver ensures it has everything needed for the specific hardware
    it is written for. It knows about baud rates, parity, stop bits, and so on. Once
    that is all figured out, the device driver sends the data to the USB/serial controller.
    This controller is a bit of hardware that physically connects to the port.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data has come that far, it leaves our system on a set of wires, out
    of our machine, and on its way to some other hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot is going on, but we hardly see it. All we see in our code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the `SerialPort` class. We give it the parameters it
    expects. First, we need to specify which port we want to talk to. Computers usually
    have more than one serial port. In the old days, computers did have a minimal
    number of physical ports. They were either parallel ports, capable of sending
    multiple bits simultaneously, or serial ports, which could only process one bit
    simultaneously. The serial ports were also called **Communication Ports**, shortened
    to **COMs**. In my example, we connect to the third one because I happen to know
    there is hardware attached to that port that I can talk to.
  prefs: []
  type: TYPE_NORMAL
- en: I also give it the speed – in my case, 9,600 baud.
  prefs: []
  type: TYPE_NORMAL
- en: Baud versus bits per second
  prefs: []
  type: TYPE_NORMAL
- en: There is a common misconception about the best way to describe the speed of
    communications. We used **baud** for the older COM ports. The term *baud* is named
    after the French scientist Jean-Maurice-Emile Baudot (1845–1903), who worked on
    a system to allow multiple transmissions of a single telegraph wire. Baud stands
    for the number of signal changes per second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bits per second* means just that – how many bits per second can we send? Since
    baud is analog and can combine signals, there is no direct relationship between
    baud and bits per second.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in most cases, they are pretty close. 9,600 baud can be considered
    to be around 9,600 bits per second. But don’t rely on it!
  prefs: []
  type: TYPE_NORMAL
- en: On a related note, a byte does not have to be 8 bits. A byte transmitted over
    a wire can be as long as 12 bits, depending on the communication settings.
  prefs: []
  type: TYPE_NORMAL
- en: We also define **parity as none**. We set the data packet to be 8 bits. We also
    add 1 stop bit.
  prefs: []
  type: TYPE_NORMAL
- en: The settings I have given here (no parity, 8 bits, and 1 stop bit) are the default
    settings, but you could have omitted them. However, you must ensure the device
    on the other side of the line uses the same settings. You can imagine what a mess
    it would be if you send 10 bits per byte, some of which are for error checking,
    and the other side expects only 8 bits to be sent per byte. It is better to be
    clear about this sort of thing.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have `SerialPort`, we can open the connection. And when that is done,
    we send 1 byte over the wire. Somewhere in the chain from our application to the
    actual wires, the parity, conversion to the correct number of bits, and stop bits
    are added or converted, but we have nothing to do with that. The BCL, OS, and
    device drivers take care of it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we finalize it all by closing the port again.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data is just as simple, but we will look at that later on.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serial communication, especially over COM ports, is old-school technology. These
    days, we use a wired network, Wi-Fi, Bluetooth, or USB if we want to connect to
    other hardware. Or, at least, that is what you might think.
  prefs: []
  type: TYPE_NORMAL
- en: For most software developers, this is true. They will hardly ever encounter
    a thing such as a serial port. But we system programmers are not like most software
    developers. We deal with hardware. And often, that hardware is old. Or at least
    the design of that hardware is old.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, many factories have robots. A lot of them communicate over serial
    ports. Medical devices are another example. It takes a very long time to certify
    medical equipment, so the manufacturer is usually very reluctant to change part
    of the hardware just because a new kind of cable has been announced. They tend
    to stick to what works. As long as serial communications work well enough, they
    keep using them.
  prefs: []
  type: TYPE_NORMAL
- en: Industrial CNC machines, barcode scanners, and GPS receivers are all examples
    of hardware still used widely today that rely on serial ports. We system programmers
    are the developers most likely to encounter those devices.
  prefs: []
  type: TYPE_NORMAL
- en: So, it’s crucial that you know what serial communication is and what it does.
    But, of course, how can you program for it?
  prefs: []
  type: TYPE_NORMAL
- en: Although you are not likely to see actual D-Port-style serial connectors on
    computers anymore (unless you specifically add one), serial ports are still a
    thing. The difference between those older ports and what we use today is that
    we use virtual COM ports.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system and the device drivers channel communication through the
    USB port to the outside world, mimicking the older ports. The D-style ports had
    multiple pins for power, ground, data, TX signals, and much more. These days,
    the USB devices take care of that. But if you want to connect to one of these
    older machines, you can get cheap and simple USB-to-serial (or, technically, RS232)
    converters.
  prefs: []
  type: TYPE_NORMAL
- en: I suspect we will have serial ports for a long time to come. That is why I’m
    spending so much time discussing them here in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A word about parity, data sizes, and stop bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set the serial port in the previous sample to use no parity, 8 data bits,
    and 1 stop bit. But what does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you do not need to care about how the actual hardware communicates.
    If you want to load a file from your storage medium, you are not bothered by the
    internal workings. You do not care whether the medium is a super-fast SSD or a
    slow SD card inserted somewhere. You choose where to store your data, and you
    are good to go. The operating system and device drivers take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: For COMs, this isn’t an option. You do not have to worry about the voltages
    across the wires, but you have to know a bit more about how the devices want to
    communicate. Oh, in case you are wondering, for low-speed USB devices, the voltages
    are between 0.0V and 0.3V for a zero and between 2.8V and 3.6V for a one. Now
    you know.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what do we need to know if we want to communicate over a serial communication
    line? Well, there are four parameters we need to decide on. Both the sender and
    the recipient need to agree on this. The serial protocol does not care: it only
    knows how to put ones and zeros on that line. We need to tell our software what
    that data means.'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters we need to set are the speed, whether we want to use parity,
    the size of a data packet, and whether we want to use stop bits.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speed is essential. We specify the speed as the number of changes in voltages
    per second. We do not specify it in bits per second. This distinction is important
    because a bit is a discrete unit. A bit is a bit. Nothing more, nothing less.
    But a bit does not exist in the world of electronics; all we can deal with is
    a flow of electrons, making up voltages (I am really oversimplifying things here,
    but the basic idea is valid).
  prefs: []
  type: TYPE_NORMAL
- en: If a wire has a high voltage for a second, followed by a low voltage for a second,
    we have no idea what that means. It is just that – one second of high voltage,
    followed by one second of low voltage.
  prefs: []
  type: TYPE_NORMAL
- en: But if we establish that we can do four changes per second, we can determine
    that we got eight changes; the first four were high, and the second four were
    low. Then, we can agree that we had four 1s, followed by four 0s. Thus, in two
    seconds, we transmitted the bits 11110000\. But if we would have established that
    we can do eight changes per second, the data would have been 11111111 00000000\.
    And that is an entirely different number.
  prefs: []
  type: TYPE_NORMAL
- en: The baud rate, which we use to specify the speed, tells a system how much data
    is transmitted in a certain time or how long it takes to send one element (OK,
    this is a bit) over the wire.
  prefs: []
  type: TYPE_NORMAL
- en: It’s all about timing, which can help hardware do some rudimentary error checking.
    I will explain this when we talk about stop bits.
  prefs: []
  type: TYPE_NORMAL
- en: Parity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, data gets messed up. We are dealing with electrical connections here,
    which can sometimes be unreliable. Sometimes, the voltage drops or a spike occurs,
    getting in the way of the data we want to send. There are several advanced ways
    to handle this, but the oldest and easiest way to do some rudimentary checking
    is by using parity.
  prefs: []
  type: TYPE_NORMAL
- en: Three kinds of parity checks exist – **even, odd, and none**. None is the simplest
    – we do not want any checks.
  prefs: []
  type: TYPE_NORMAL
- en: The other two, even and odd, mean we add one extra bit to each data packet.
    That extra bit is either a one or a zero, so the total number of ones in the packages,
    including the parity bit, is an even or odd number.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to transmit the following sequence of 4 bits – 1011\. If the
    parity is set to even, the system counts the number of ones in that message. It
    notices there are three, which is an odd number. We need to make it even, so the
    system adds a one to the package and sends that over the wire, resulting in the
    bits 10111.
  prefs: []
  type: TYPE_NORMAL
- en: If we had chosen to send 1001 over the wire, the number of ones is already even,
    so there is no need for an extra one. The system adds a zero and sends 10010 over
    the wire.
  prefs: []
  type: TYPE_NORMAL
- en: On the receiving end, the system counts the numbers of one in the package and
    checks to see whether it is indeed an even number. If that is not the case, something
    has gone wrong. The system can then ignore that package or request a resend.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we had set the parity to odd, it would have only added a one if
    the number of ones in the data package was even.
  prefs: []
  type: TYPE_NORMAL
- en: If two bits flip instead of just one, the system falls apart. There is no way
    to tell that that happened with this simple setup. There are other ways to do
    that, but you must implement them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Parity does add data to a package, slowing communications down slightly.
  prefs: []
  type: TYPE_NORMAL
- en: The data size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How significant is a byte? I guess you are inclined to say 8 bits. But in the
    early days of computing, this was not a fixed number. There were lots of 10-bit-based
    computers. Data transmission was slow and expensive back then, so they decided
    they could get away with sending only 7 bytes if they wanted to send text. After
    all, most ASCII characters fit in 7 bits. So why send extra data? I know that
    these days, it is hard to imagine people worrying about an extra bit, but remember
    that times change. For instance, the first modem I used to connect my computer
    to the outside world had a transmission speed of 1200/75\. That means it could
    receive with a speed of around 1,200 bits per second, or roughly 120 bytes per
    second. But I could only upload with 75 baud. That is around 10 bytes per second.
    Removing one bit can make a big difference in those cases!
  prefs: []
  type: TYPE_NORMAL
- en: '`SerialPort` allows you to choose the size of your data package. This size
    is the number of bits each package contains, not counting the parity bit or any
    stop bits. You can choose between 7 or 8 bits. Technically, you could specify
    other sizes. In reality, you never encounter that in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: 7 bits is enough for ASCII characters. If you use 8 bits, you double the amount
    of information you can transmit in one single go, but you also make it a bit slower.
    In the world of serial communication, this can be important.
  prefs: []
  type: TYPE_NORMAL
- en: The default is 8 bits, but if you want to really get the most out of your system,
    7 bits might be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Stop bits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Then, we have **stop bits**. Stop bits are added to a data package to signal
    that it is the end of that package. You can decide between 1, 1.5, or 2 stop bits.
    The system adds these bits to the end of the package, usually ones. Adding data
    achieves three things – first, it signals the end of the package. It helps detect
    timing issues or errors and allows the hardware to catch up.
  prefs: []
  type: TYPE_NORMAL
- en: Stop bits are not actual bits; they are not data. They do not reach the software
    at the end of the chain. Instead, they are a fixed amount of time when the voltage
    is high. This explains why we can have 1.5 stop bits. There is no *half a bit*,
    but you can set the voltage high for half the time it takes to transmit one bit.
    Remember when I said that timing can help detect errors? This is what I was talking
    about.
  prefs: []
  type: TYPE_NORMAL
- en: If the receiving system thinks it has received the agreed-upon 8 data bits and
    parity bits, it expects a stop bit (assuming we set the stop bit to 1). If the
    voltage on the line is low, something has gone wrong. Combined with the parity
    bit, this can detect simple errors.
  prefs: []
  type: TYPE_NORMAL
- en: The stop bits can be 1, 1.5, or 2 *bits* long (remember that they are not bits
    but the amount of time it takes to send a bit). Adding extra time between two
    packets means that a receiving system has time to process the bits it got, calculate
    the parity, and pass it on to the rest of the system before the next package arrives.
    Again, in these days of ultra-fast hardware, it seems weird to take that into
    account, but when serial communication was devised, adding 1, 1.5, or even 2 *bits*
    of pause could mean the difference between an excellent working system or a barrage
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Working with an Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I do not have a medical MRI machine nearby, so I cannot show you how to connect
    to one of those using the discussed techniques. However, I do have another device
    lying around – an Arduino Uno.
  prefs: []
  type: TYPE_NORMAL
- en: Arduinos are really cheap microcontrollers. Although an actual Arduino can set
    you back $20 to $30; comparable devices with the same capabilities can be found
    for about $5 to $7\. For that price, you get a good running microcontroller that
    you can connect to your computer, program against, and use to hook up all sorts
    of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware is simple – a CPU, a USB connector, a little memory, and an EEPROM
    that can hold your program. Also, an Arduino has pins that you can use to connect
    to other hardware.
  prefs: []
  type: TYPE_NORMAL
- en: You can program your Arduino with a free tool called the Arduino IDE. Now, this
    book is about systems programming with C# and .NET, and not about Arduino. But
    I need to talk about this briefly in case you decide to get an Arduino and follow
    along. If you do, great! If you don’t, continue reading until we get to the part
    about faking hardware.
  prefs: []
  type: TYPE_NORMAL
- en: I chose Arduino because it uses a serial port to communicate with your computer.
    It is cheap, and many people have one lying around somewhere. Then, we can build
    an elementary device to talk to and have it talk to us. Do not worry if you have
    no experience with these devices; I will explain everything you need to know to
    follow along.
  prefs: []
  type: TYPE_NORMAL
- en: We need to write some software for the Arduino. The code is simple and included
    in the GitHub repo that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: But before we look at the code, let me explain the device we will create.
  prefs: []
  type: TYPE_NORMAL
- en: The device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I want our Windows machine to be more susceptible to the world outside its enclosure.
    I want it to be aware of sounds. I want a device that warns Windows when a loud
    noise is detected.
  prefs: []
  type: TYPE_NORMAL
- en: We could use a microphone and plug that into the correct ports, but a microphone
    is complicated. It can record sounds in high fidelity. I do not want that; I only
    want to know whether there is a loud sound, not what kind of sound it is. Furthermore,
    we can only have one microphone in use at a time. So, if we were to use the microphone,
    we would not be able to use our machines to make Teams calls or anything like
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s best to offload that work to a separate device. To do that, we need a
    couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino or a compatible device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard. This is a piece of plastic with wires, allowing us to plug in
    hardware and connect them without soldering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A KY-037 sound detector. This very simple device puts out a voltage as soon
    as it “hears” a noise. They cost anywhere between $1.50 and $3.00.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An LED and a 200 ohm resistor (optional). I thought it would be fun to light
    up an LED when the device hears a sound. You do not need this; the Arduino has
    a built-in LED we can also use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB cable to connect it all to our machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some wires to connect the different parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The schematics for this device look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF9.1: The sound detector schematics](img/B20924_10_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The sound detector schematics'
  prefs: []
  type: TYPE_NORMAL
- en: If you have never worked with this sort of electronics before, do not worry.
    It is not as scary as you might think. The thing at the bottom of the preceding
    figure is the Arduino. As I stated earlier, it has pins we can connect wires to
    hook it up with other hardware. I have used four wires here. The one from the
    bottom to the breadboard (the white piece of plastic) is connected to a 5-volt
    power supply from the Arduino. I have connected it to the lowest row on the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: The breadboard works like this – all the little holes on the lowest row are
    electrically connected. That means if I plug in a wire with 5 volts on one of
    the holes in that row, all the other holes in that same horizontal row will also
    have 5 volts. The same happens with the second row from the bottom; they are also
    all horizontally connected. I use this for the ground connections. I hook one
    of the holes up with the Arduino’s **GND** (meaning **ground**) pins. All the
    wires I plug into the second row are connected to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: The red piece of electronics you see is connected to the breadboard. Except
    for the lowest two rows of the breadboard, each column is also connected. That
    means if I plug something into the hole in the first column (above the two bottom
    rows), all the holes above it are also connected. Columns are isolated from each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: The breadboard consists of two halves – a bottom and a top half. These two halves
    are entirely isolated; no wires run from one half to another. So, the top half
    of the breadboard is a mirror of the bottom half.
  prefs: []
  type: TYPE_NORMAL
- en: I plugged the KY-037 (the red thing in the schematic) into the breadboard. I
    connected the 5-volt from the first row to the correct column. I did the same
    for the GND signal. Then, I connected a wire from the leftmost pin of the KY-037
    directly to pin 8 of the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: I did a similar thing for the LED; the plus side of the LED is connected to
    pin 13 of the Arduino, and the negative side is connected to a 200-ohm resistor
    that, in turn, is connected to the GND row of the breadboard (and, thus, to the
    GND of the Arduino).
  prefs: []
  type: TYPE_NORMAL
- en: Are you with me so far?
  prefs: []
  type: TYPE_NORMAL
- en: The idea is simple – if the KY-037 detects a sound, it will (if powered by the
    5 volts from the Arduino) put a voltage on the D0 line connected to pin 8 on the
    Arduino. If that happens, the microprocessor can pick that up and put a voltage
    on pin 13\. That will light up the LED.
  prefs: []
  type: TYPE_NORMAL
- en: If the sound is dropped, the voltage on pin 8 will also go to LOW, and we can
    program the Arduino to stop the LED. That is, of course, achieved by removing
    the voltage from pin 13.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to instruct the Arduino on how to behave. That means we have to program
    it. We can use the free Arduino IDE to write and deploy our software to the device.
    The device itself is simple; it can only have one program. That program starts
    as soon as the device is powered on and does not stop until the power is removed.
    There is no real operating system, no loading, and no multitasking.
  prefs: []
  type: TYPE_NORMAL
- en: The program itself is also straightforward. It consists of two parts. The first
    part is a method called `setup()`. This method is called as soon as the program
    starts (or as soon as the Arduino powers up). It is called only once and is a
    good place to do some initialization.
  prefs: []
  type: TYPE_NORMAL
- en: There is another method called `loop()`. This method is, as the name suggests,
    a loop. The Arduino goes through the code in `loop()`, and restarts at the beginning
    of `loop()` as soon as it reaches the end. And that’s it. Of course, you can (and
    should) write your own methods and functions, but this is needed to get the device
    going.
  prefs: []
  type: TYPE_NORMAL
- en: The programming is done in C (technically, it can be C++, but let’s not go there).
    The IDE can compile the code for you and deploy it to an attached Arduino. When
    you connect your Arduino through a USB cable to your machine, the IDE recognizes
    it and knows how to talk to the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The software I want to use looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore it.
  prefs: []
  type: TYPE_NORMAL
- en: First, I define some constants. I create the `LedPin` constant and set it to
    13\. This pin 13 is the number of the pin we connect the LED to see whether sound
    is detected. I chose pin 13 because most Arduino devices have a built-in LED on
    the board, connected to pin 13\. So, if you do not want an external LED, you can
    look at the board and see the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: I also define the pin that the KY-037 uses to send the signal back to us, pin
    8, and I call it `SoundPin`. There is no specific reason I chose pin 8; it was
    conveniently located on the Arduino, so I could easily attach it to the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the `setup()` method. Again, this is used to initialize the system.
    We do three things here:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the direction of pin 13 to `OUTPUT`; we do this by calling `pinMode(LedPin,
    OUTPUT)`. This direction means that the Arduino can use this pin to write to.
    We need this to turn the LED on or off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the direction of pin 8 to `INPUT`, by calling `pinMode(SoundPin, INPUT)`.
    Now, the Arduino knows we want to read from that pin instead of writing to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We open the serial port. We do that by calling `Serial.begin(9600)`. This opens
    the serial connection through the USB connector to whatever it connects. We tell
    it we have a speed of 9600 baud. We could have specified the parity, packet size,
    and the number of stop bits, but the defaults (no parity, 8 bits, and 1 stop bit)
    are good enough for us. We need to remember these settings, as we will need them
    at the receiving end as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we can look at the `loop()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with reading from the `SoundPin` pin. We do that by calling `digitalRead(SoundPin)`.
    Remember that the KY-037 adds voltage to the device when it hears a sound. We
    can read that result; the voltage level is translated into a one or a zero. We
    compare that with the results of the previous reading; if the value is different
    than before, we suddenly hear something (or stop hearing something). If that is
    the case, we determine whether there was a sound and add that information to the
    serial bus; we use `Serial.write(1)` or `Serial.write(0)` to send that value.
    You can as quickly send a string over the serial port by calling `Serial.PrintLn("My
    data")`. However, we do not need that in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Then, depending on the conditions, we turn the LED on or off. Just like we used
    `digitalRead()` to read the state of a pin, we can now use `digitalWrite()` to
    set the state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `delay(100)` to give the sound 100 milliseconds to die out.
  prefs: []
  type: TYPE_NORMAL
- en: And then it starts all over again; we are in a loop after all.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. Upload that program to the Arduino and watch what happens. If you
    make a noise, you will see the LED light up. You haven’t seen the effect of a
    `serial.print()` yet, but we will fix that next.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving serial data with .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have done a lot already. But that was just the setup to get to where we really
    want to be as system programmers – dealing with code in our C# programs.
  prefs: []
  type: TYPE_NORMAL
- en: I have written a sample that does just that; it opens the serial port, and it
    gets data. That in itself is not too hard; I have shown you how to open `SerialPort`
    and write data to it. Reading data from that same port is just as easy; `SerialPort.ReadLine()`,
    for instance, is one way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are a lot more considerations when dealing with other hardware,
    and that’s what we will discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: First, the sample I provide is not a console application. It is a worker service.
    I chose this template because I want this code to work quietly in the background
    and only do something when data comes in on the serial bus. This is the closest
    we can get to writing a device driver in .NET. Second, USB and serial ports are
    brittle. It’s not that they fail a lot, but it is extremely easy to remove a device
    and plug it in again. You can never be sure that the device you need is attached
    to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Users rarely remove their primary hard drive. Network adapters tend to stay
    inside. Network cables can be removed but hardly ever are. USB devices, however,
    are plugged in and removed again all the time. Sometimes, that happens intentionally,
    and sometimes, your cat decides to play around with that thing with blinky lights
    and wires hanging out of it (yes, that happened to me when I was writing this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: If we cannot rely on the presence of the device we want to talk with, we need
    to make sure it is there before we do something. We also need to handle a scenario
    where the device gets unplugged while working with it.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we already know how to do this. In previous chapters, we looked into
    **Windows Management Instrumentation** (**WMI**). That allowed us to investigate
    the hardware attached to our machine, and we saw that it could raise events if
    something changed. That sounds like something we can use here.
  prefs: []
  type: TYPE_NORMAL
- en: Watching the COM ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I created a class called `ComPortWatcher`. As the name suggests, this watches
    the `IComPortWatcher` interface, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The interface declares two events. These events get called when a device we
    are interested in is plugged into a computer or when such a device is removed
    again. Other classes can subscribe to these events and take action.
  prefs: []
  type: TYPE_NORMAL
- en: We have a method called `Start()` that starts watching the ports. `Stop()` does
    the opposite – it stops watching the ports.
  prefs: []
  type: TYPE_NORMAL
- en: I also added a method called `FindMatchingComPort`(`string partialMatch`). All
    devices have a set of properties, sometimes including the Caption. That Caption
    contains some information about the device attached to our machine. In the case
    of the Arduino, `Caption` contains the `Arduino` string and the actual COM port.
    This method tries to find that string and extracts the correct COM port, so we
    can use that to open the serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the implementation. We will start with the easiest, `FindMatchingComPort(string
    partialMatch)`. This is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I am skipping a lot of error checking and safeguarding; otherwise, the code
    becomes too long to read. I am sure that you can spot what I left out and figure
    out how to do that yourself. Here I have focussed on only the essential parts.
  prefs: []
  type: TYPE_NORMAL
- en: First, I create a new instance of the `ManagementObjectSearcher` class. I give
    it the `"Select * From Win32_PnPEntity Where Caption Like '%{partialMatch}%'"`
    search string. This searches through all Plug and Play devices and tries to match
    the caption of those devices with whatever string we pass in. Again, in my case,
    I give it the `Arduino` string.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no matches, we simply return an empty string, stating that no Arduino
    devices are found. However, if one is found (I only check for one; this is one
    of those areas you can improve a lot on), I take that caption and use some `GetComPortName()`
    method) to extract the name of the COM port.
  prefs: []
  type: TYPE_NORMAL
- en: 'That RegEx code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. We take the `"(COM\d+)"` RegEx pattern,
    which means we look for the string COM, followed by one or more numbers. Then,
    we return that part of the string. The caption of the port on my machine looks
    like `Arduino Uno (COM4),` so this method returns, in my case, the `COM4` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Start()` method of this class sets up the watchers. We have two private
    members in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the WMI watchers that can trigger events when something interesting
    happens. What we define as interesting is specified in the `Start()` method. Here
    it goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, I check to see whether this is not already running. There is no point
    in doing this twice. Then, I define the query string that defines the searches
    for both inserting and deleting devices.
  prefs: []
  type: TYPE_NORMAL
- en: When a device is inserted, the `__InstanceCreatedEvent` class in the operating
    system gets information about that device. We query for that class, but only if
    the target is a Plug and Play device (`Win32_PnpEntity`) and `Caption` contains
    *Arduino*. I am not interested in any other device.
  prefs: []
  type: TYPE_NORMAL
- en: I create a similar query string for the deletion event.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I create an instance of that `Watcher` class, give it the query, and set
    up the event handlers. Finally, I call `Start()` on the watchers so that they
    start doing what they are meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: The `Stop()` method stops the watchers and cleans them up. There is nothing
    special there, but you can look at the code in the GitHub repository for further
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event handlers are slightly more interesting than the `Stop()` method.
    Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when the watcher sees an exciting event in the operating
    system. We take `EventArgs` (of type `EventArrivedEventArgs`), take the `NewEvent`
    property, and get the `TargetInstance` member. We cast that to its correct type,
    `ManagementBaseObject`, and remove the caption. Then, we extract the COM port
    name and call any attached event handler. Since I know the attached event handler
    will start the serial communication, I wrap it in a `Task.Run()` method, making
    it work asynchronously and, thus, stopping it from blocking the current thread.
    Remember that all things that take time, such as I/O, should be written as asynchronous
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The event handler for the delete event looks similar.
  prefs: []
  type: TYPE_NORMAL
- en: With this class in place, we can sit back and relax. We can ensure a COM port
    is available when needed, and we can take action if it gets unplugged.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the serial port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a slight problem with the serial port class in .NET. It is not written
    for this day and age. It is a leftover from a much slower world. It is not asynchronous.
    And that can be a problem. Serial communications are slow enough already, and
    all calls to it block the thread it runs on. We need to wrap the class into something
    more modern.
  prefs: []
  type: TYPE_NORMAL
- en: 'I created an interface that shows us how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The interface has an `IsOpen` property that can help us prevent more than one
    connection from opening. We have the `Open()` method, and I wrote it so that the
    parameters are there, but when a user of this class omits them, the serial port
    gets created with the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: We have a `Close()` method that closes the connection.
  prefs: []
  type: TYPE_NORMAL
- en: I also added a `ReadByteAsync()` method that reads 1 byte from the device. I
    do not need more; our sound detector device only sends 1 byte at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I have a private member in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already encountered the `SerialPort` class, so the implementation of
    the `Open()` method should be familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special happens here – we create an instance of the `SerialPort` class,
    give it the correct parameters, and then open it. That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: '`Close()` is even simpler – it only calls `Close()` on the `_serialPort` member.
    OK, it does that and a bit of cleaning up.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadByteAsycn()` is a lot more interesting. It is the reason we wrote this
    class. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, we wrap the synchronous calls in `Task.Run()` so that the whole thing
    becomes asynchronous. We return that `Task` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: We call `_serialPort?.Read(buffer,0,1)`. This results in one byte of data, if
    available. If no data is available, this call is blocked until the data is there.
    That is why we use `Task.Run()` – we do not want to block our entire system and
    wait for a single byte to come in.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the device is removed from our system while waiting for that data,
    we get `OperationCanceledException`. That makes sense; we are waiting for data
    from a device that no longer exists. We catch that exception and return the `0xFF`
    byte. Since we know we can only get a `0` or a `1` from the Arduino board (that’s
    how we programmed it), we can safely use this magical number here to indicate
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can use these two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Making it all work together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned that we are building a worker service. This service runs in the
    background and does not influence other codes or programs. The default template
    gives you a class called `Worker`, where we can do the actual work. We shall add
    our code to this `Worker` class.
  prefs: []
  type: TYPE_NORMAL
- en: But before doing that, we need to change the `Program` class slightly. One of
    the nice things about the worker service template is that it gives you dependency
    injection for free, out of the box. We can use that to register our `IAsyncSerial`
    and `IComPortWatcher` interfaces and their accompanying classes. That way, we
    do not have to create instances ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Program` class needs to be changed to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we registered our new interfaces and classes, making them available
    for anyone needing one. And that *anyone* in our case is the `Worker` class. Let’s
    look at the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We set the incoming instances of our classes and then look for a COM port attached
    to an Arduino. If there is one, we can set the `_deviceIsAvailable` variable to
    true.
  prefs: []
  type: TYPE_NORMAL
- en: We add the events that get called when the device is inserted or deleted. Then,
    if a device is already available, we start the serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'That method, `StartSerialConnection()`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since we have already done the hard work in the `AsyncSerial` class, we can
    simply call it `_serialOpen(_comPortName)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event handler for `ComportAddedEvent` does more or less the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The event gets the name of the COM port from the `ComPortWatcher` class. So,
    all we have to do here is save that name and start the communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual work happens in the `ExecuteAsync` method of the worker. As you
    probably recall, the runtime calls this part of the class to do the actual work.
    Usually, this method contains a loop that gets repeated until `CancellationToken`
    signals that it needs to stop. Our version looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether a device is available. There is no point in reading
    data if no device is attached, right?
  prefs: []
  type: TYPE_NORMAL
- en: Call the new `ReadByteAsync()` method if there is a device, and check the results.
    If they return `0xFF`, we have a problem – the device is removed. Otherwise, we
    just display the data we have.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all there is to it! That was quite a lot. We introduced the Arduino
    and built our own device from it. We learned what communication over serial ports
    looks like. We discussed extracting data from our serial ports and how to make
    it work asynchronously. All in all, I think you deserve a break. We covered a
    lot of ground here.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the complete sample in the GitHub repository to see the little
    details I left out here. However, with the information I just gave you, you have
    everything you need to start talking to serial devices!
  prefs: []
  type: TYPE_NORMAL
- en: Faking a serial device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I promised to discuss with you another thing – what to do if you have no device
    available. Well, there is a reason I used the `IComPortWatcher` and `IAsyncSerial`
    interfaces. We can mock them in a unit test and write fake code that mimics devices.
    And that is a pretty good idea, as serial communication is brittle and often fails.
    If you are developing your software, you want an environment you can rely on.
    Using these interfaces can help you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, I can have another implementation of `IComPortWatcher` that contains
    a `Start()` method that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If I plug this into my `Program` class, I can fake `ComPortWatcher`. The `Program`
    class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I can easily switch between the real and fake code by defining
    the `FAKESERIAL`. Of course, you can do this better by *defining* this in your
    build profile and not in the source code. That way, you can choose which version
    you want to run.
  prefs: []
  type: TYPE_NORMAL
- en: I will leave the implementation of `FakeAsyncSerial` to you.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have looked at programming your computer to send and receive data to
    and from the serial port, or COM ports. There are many ways to communicate with
    the outside world, but COM is still around. System programmers encounter that
    specific protocol quite often, and now you know how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: We used an Arduino to mimic an external device. Of course, you might encounter
    many different kinds of devices. They all have their different use cases and ways
    of communicating. But they usually use a serial connection if they are attached
    to your machine through a cable. Now, you have seen how to set up such a connection
    and a test environment to fake a serial connection. But there is one more thing
    I want to discuss – how to make this sort of system more foolproof.
  prefs: []
  type: TYPE_NORMAL
- en: Making it foolproof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw that we can use WMI to intercept unwanted removal of devices.
    USB cables can be removed from a machine easily. One of their selling points is
    how easy it is to plug devices in and remove them again. From a user’s standpoint,
    that is great. But from a developer’s perspective, it is not so great.
  prefs: []
  type: TYPE_NORMAL
- en: And even if the user (or your cat) doesn’t fiddle around with the cable, many
    things can get in the way of a reliable data stream.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons things go haywire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your software fails, you can easily look up what happened. Well, not really
    easily – debugging software, especially low-level, multithreaded software, can
    be challenging. But it is doable.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with issues from other hardware is much harder to solve. There are so
    many reasons things can go wrong. Let’s go through some of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interference**: The cables used for serial communication are simple – several
    copper wires carry the electrical signal. All cables are sensitive to interference,
    regardless of their use. Interference is the effect that happens when electrical
    signals cause a change in the electromagnetic field around them, which in turn
    can cause changes in other wires. In practice, you might notice errors if you
    have a long serial cable and leave that coiled up next to your device. The answer
    is to have shielded or shorter cables or ensure they are isolated from others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad cables**: Of course, even if you have a short, straight cable with no
    other cables nearby, you still might get errors. The cables might be damaged.
    The connectors might be faulty. The only way to test this is to use a metering
    device to check the cables and hardware. But even that does not always tell you
    all you need to know. Sometimes, the strains of copper are partially broken, meaning
    that sometimes they conduct the signals, and sometimes they don’t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorrect baud rates**: As explained earlier, the baud rate describes the
    number of signal changes per second. Both ends of the communication must use the
    same speed for their data. If you do not have that correctly set up, it might
    seem like everything works fine. However, you might get weird data streams instead
    of your expected valuable data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer overflows**: Data streams need to be processed. Sometimes, that processing
    takes too long, so the driver must buffer the incoming data stream. The idea is
    simple – the device driver puts all data into a buffer as it comes in and passes
    that data on when the application asks for it. However, the buffer fills up if
    the application cannot handle that amount of data in time. Ultimately, the buffer
    is full; there is no unlimited amount of memory it can use. That will trigger
    errors on a very low system level, and the buffer overflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Driver issues**: All hardware communicates through the driver. The driver
    is the last piece of software your commands or data pass through before they are
    translated into voltage differences. The driver is a piece of software written
    specifically for the hardware you have on your machine. It acts as a translator
    between the operating system and the hardware. But ultimately, it is software.
    And software can go wrong. Hence, drivers can also go wrong. If that happens,
    it is difficult to see why things do not work as expected. Drivers making mistakes
    are very hard to trace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port misconfiguration**: As we saw, we need to set up a connection in a certain
    way. We must inform the system about the parity, the number of bits in a data
    package, and the number of stop bits we want. If we mix these settings up, we
    get data that does not make sense. Not all vendors of the devices you want to
    use are good at specifying the format they expect. Therefore, you might have to
    play around before it all works as it should.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware failures**: Ultimately, everything between your software and the
    device you talk to consists of many hardware components. And all of them can go
    wrong for several reasons. The port may be bad, or the barcode scanner might not
    work correctly. There could be so many things that go wrong when dealing with
    hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrong data format**: Serial communication is very basic. You get a stream
    of bits, and they can be grouped into a set of bytes. But then what? What does
    that mean? The format in which the data is translated must be clear at both ends;
    otherwise, you cannot understand each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parity bit errors**: Parity is an excellent way of detecting errors. But
    what if two bits *flip*? Parity does not help you there; if the sender sends 4
    values of 1 over the wire, the parity bit might be set to 0 (if *parity = even*
    is used). But if one of these 1 values changes to 0, and a 0 value changes to
    1, you still have a valid parity. However, the data might not make sense at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cosmic radiation**: This one is improbable, but it has happened. Cosmic radiation
    is, as the name suggests, radiation from space. It is around us all the time.
    It does not cause harm, but sometimes, every now and then, it hits a piece of
    hardware. And when that happens, 0 might become 1, or vice versa. This is even
    more unlikely to happen inside your computer; there is a lot of protection around
    your processor and memory. But this might happen a bit more often with a cheap
    serial cable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are a lot of things that can go wrong, and most of them
    are hard to prevent in your code. OK, I agree that the cosmic radiation issue
    is not a regular occurrence, at least not regular enough to worry about it (unless
    you write software that cannot go wrong under any circumstances, such as that
    used for medical equipment).
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to harden your code so that it doesn’t suffer too much from these
    potential issues. Let’s investigate what we can do.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is very little you can do about failures on the hardware side. That just
    happens. But you can ensure your code doesn’t come to a screeching halt when the
    inevitable occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Try…Catch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `Try…Catch` is one of the best ways to make sure your system stays in
    a predictable and manageable state. Do not try to catch `Exception`; instead,
    be more specific about the kinds of exceptions you catch and how you handle them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, your code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Catch all sorts of exceptions separately and deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a robust connection loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I already mentioned this, but it is worth repeating – connections can get lost.
    Monitor the state of your connections, as we did earlier with the WMI objects.
    If something happens that should not have happened, deal with it and let the connection
    die gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring thread safety
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are accessing your serial connections from multiple threads, use mechanisms
    such as a lock or semaphores to make your code as thread-safe as possible. You
    must prevent concurrent readings and writings in a system initially designed for
    a single-thread communication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The use of CancellationToken
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For long-running operations such as serial communication, ensure all methods
    carry `CancellationToken`. Then, when handling the data streams, keep a close
    eye on that token to see whether the system wants to cancel the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You only have a limited number of virtual serial ports and even fewer physical
    ports in your system. That is why you must be very careful to release the handles
    on the devices if you do not need them anymore. The best way to do this is to
    be sure you clean up after you are done; implement the `IDisposable` pattern.
    Try to limit the time you use a device, and always ensure you release it.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, logging and monitoring are the best ways to keep track of what is
    going on. Without adequate logging, it is very hard or even impossible to trace
    what happens when things go wrong. Logging and monitoring are valuable tools to
    help you understand the specifics of an interaction with external hardware, especially
    during development. We discuss monitoring in [*Chapter 10*](B20924_11.xhtml#_idTextAnchor222),
    but remember that you need to do this, especially when dealing with external hardware.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, there are things you can do to make your software as robust as possible.
    But nothing comes for free; there is a performance overhead to all of this. But
    trust me – it is worth it. These days, software runs extremely fast, especially
    when compared to the slow speed at which most serial communications take place.
    You have plenty of time to check errors and ensure smooth communication. But do
    not make things too slow; as soon as you start getting buffer overflow errors,
    you are no longer helping a system. As always, test and measure before taking
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you enjoyed our little field trip to devices outside the realm of our
    computer. Connecting other hardware to a machine can be much fun. As I said before,
    dealing with external devices is a very likely scenario for system programmers.
    The likelihood of encountering older, serial-based communication mechanisms is
    pretty high in our world.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed what serial communications are and what devices use them.
    We examined their protocols, especially the parity, data packet size, and stop
    bits. We looked at an Arduino device that measured sounds and received data from
    that over a serial line. We also looked at what you can do if you do not have
    such a device at hand.
  prefs: []
  type: TYPE_NORMAL
- en: We made the software testable and discussed the disasters that can or will happen
    when dealing with serial devices. Finally, we looked at some tips you can use
    to make your software more resilient against these failures.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, we did a lot of exploring. I repeatedly mentioned how important
    it is to log what is happening and that you should monitor your software, especially
    when dealing with external hardware; logging and monitoring are sometimes the
    only ways to figure out what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: So, the next chapter is all about logging and monitoring. Are you ready for
    that?
  prefs: []
  type: TYPE_NORMAL
