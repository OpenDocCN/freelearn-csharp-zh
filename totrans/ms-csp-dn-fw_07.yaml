- en: Chapter 7. NoSQL Database Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to review an emerging database paradigm that totally
    remodels the structure of data, **NoSQL databases**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, I will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A historical context about NoSQL databases and their role in current development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available offers in this area and their main advantages and disadvantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architectural model followed by the distinct flavors of NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB as the NoSQL database of choice and its foundations and main features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll end with a review on how to integrate and use MongoDB from Visual Studio
    and manage CRUD operations within the IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last few years, companies such as Google, eBay, Facebook, Bosch, Forbes,
    LinkedIn, Marriot, PayPal, Ryan Air, Symantec, or Yammer have solutions that use
    these databases, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the statistics published by the specialized site DB-Engines,
    results showing utilization rates are pretty clear, where some no-SQL databases
    appear among the top 10 in use today (especially MongoDB):'
  prefs: []
  type: TYPE_NORMAL
- en: '![NoSQL Database Programming](img/image00554.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, there's a growing trend around these database systems, and it's especially
    meaningful that MongoDb shows up in the fourth position. The first five companies
    mentioned earlier use MongoDb for different purposes and scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: A brief historical context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the second half of the nineties, nobody would doubt that SQL and Relational
    Model databases were the *de facto* standard and a large majority of commercial
    implementations in use those days were based on this assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Historical examples are IBM, Oracle, SQL Server, Watcom, Gupta SQLBase, and
    so on. However, with time, some voices started to claim against what was already
    called *impedance mismatch*, the different representations of data and source
    code that happen when programming in object-oriented languages to these databases.
  prefs: []
  type: TYPE_NORMAL
- en: This is something that's clearly revealed when objects or class definitions
    have to be mapped in some fashion to databases (either tables or relational schemas).
  prefs: []
  type: TYPE_NORMAL
- en: Other problems arose from the different data types supported by both worlds,
    especially in scalar types and their operation semantics (for example, collations
    for different string interpretations), although OOP languages only consider this
    aspect in sort routines and strings are not treated as fixed, such as in RDBMS
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, there were structural and integrity differences between both, not to
    mention other operational dissimilarities in manipulation and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: So, new proposals were made about object-oriented databases, in which information
    would be stored in a such a way that it becomes simple and straightforward to
    make the correspondence between the two worlds. However, these proposals didn't
    reach the commercial arena, and actually, only some niche areas, such as engineering
    and spatial databases, high energy physics, some telecommunications projects,
    and molecular biology solutions, were actually using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: One of the problems, in the words of Martin Fowler, was that people were doing
    a lot of integration in classical databases, making it really hard to change this
    paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: The NoSQL world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As social media became huge, data requirements increased too. The need to store
    and retrieve large amounts of data immediately, led to some companies involved
    in the problem to think about possible alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, projects such as BigTable (Google) and Dynamo (Amazon) were among the first
    few attempts to find a solution to this problem. These projects encouraged a new
    movement that we now know as the NoSQL initiative, the term being proposed by
    Johan Oskarsson in a conference in California about these topics, for which he
    created the Twitter hashtag #NoSQL.'
  prefs: []
  type: TYPE_NORMAL
- en: We can define the NoSQL movement as a broad class of system-management databases
    that differ from the classical model of relational databases (RDBMS) in important
    facets, the most noticeable one being that they are not using SQL as the primary
    query language.
  prefs: []
  type: TYPE_NORMAL
- en: Stored data does not require fixed structures such as tables. The result? They
    don't support JOIN operations, and they do not fully guarantee **ACID** (**atomicity**,
    **consistency**, **isolation**, and **durability**) features, which are the soul
    of the relational model. Besides, they usually scale horizontally in a very efficient
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder: the four ACID features are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity**: This is key to the Relational Model; an operation consisting
    of more than one action shall not fail in the middle. Otherwise, data will be
    left in an inconsistent state. The whole set of operations is considered a unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: This extends to the previous and posterior state of the database
    after any action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: Along with the previous considerations, no collateral effects
    should be noticed after a transaction has finished in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability**: If an operation ends correctly, it will not be reversed by
    the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL systems are sometimes called *not only SQL* in order to underline the
    fact that they can also support query languages such as SQL, although this characteristic
    depends on the implementation and the type of database.
  prefs: []
  type: TYPE_NORMAL
- en: Academic researchers refer to these databases as structured storage databases,
    a term that also covers classical relational databases. Often, NoSQL databases
    are classified according to how they store data and include categories such as
    Key-Value (Redis), BigTable/Column Family (Cassandra, HBase), Document Databases
    (MongoDb, Couch DB, Raven DB), and Graph Oriented Databases (Neo4j).
  prefs: []
  type: TYPE_NORMAL
- en: With the growth of real-time websites, it became clear that an increase in processing
    power for large volumes of data was required. And the solution of organizing data
    in similar horizontal structures reached corporative consensus, since it can support
    millions of requests per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many attempts have been made to categorize the different offers now found in
    the NoSQL world according to various aspects: Scalability, Flexibility, Functionality,
    and so on. One of these divisions, established by Scofield and Popescu ([http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting](http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting)),
    categorizes NoSQL databases according to the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Performance | Scalability | Flexibility | Complexity | Functionality
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Key-value stores** | High | High | High | None | Variable (none) |'
  prefs: []
  type: TYPE_TB
- en: '| **Column stores** | High | High | Moderate | Low | Minimal |'
  prefs: []
  type: TYPE_TB
- en: '| **Document stores** | High | Variable (high) | High | Low | Variable (low)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Graph databases** | Variable | Variable | High | High | Graph theory |'
  prefs: []
  type: TYPE_TB
- en: '| **Relational databases** | Variable | Variable | Low | Moderate | Relational
    algebra |'
  prefs: []
  type: TYPE_TB
- en: Architectural changes with respect to RDBMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, the first point to clarify at the time of using one of these models is
    to identify clearly which model suits our needs better. Let''s quickly review
    these unequal approaches in architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The key/value proposal is similar to other lightweight storage systems used
    today on the Web, especially the `localStorage` and `sessionStorage` APIs. They
    allow read/write operations for a web page in the local system's dedicated area.
    Storage is structured in pairs, the left-hand side being the key we'll use later
    on to retrieve the associated value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These databases don't care about the type of information being saved as the
    value type (either numbers, documents, multimedia, and so on), although there
    might be some limitations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The document offer is made of simple documents, where a document can be a complex
    data structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, such data is represented using a JSON format, the most common format
    in use today, especially in web contexts.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture allows you to read even fragments of a document or change or
    insert other fragments without being constrained by any schema.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The absence of a schema, which—for many—is considered one of the best features
    of NoSQL databases, has a few drawbacks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the drawbacks is that when we recover some data, let's say from a person
    (a name or an account), you're assuming an *implicit schema*, as Fowler names
    it. It's taken for granted that a person has a name field or an account field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, most of implementations rely on the existence of an ID, which works
    like the key in a key/value store in practice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can think of these two approaches as similar and belonging to a type
    of aggregate oriented structure.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Column family model, the structure defines a single key (named a row
    key), and associated with it, you can store families of columns where each one
    is a set of related information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, in this model, the way to access information is using the row key and
    the column family name, so you need two values for data access, but still, the
    model reminds the idea of the aggregated model.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the graph-oriented model fragments information in even smaller units
    and relates those units in a very rich, connected manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They define a special language to allow complex interweaving to take place in
    a way that would be difficult to express in other types of databases, including
    RDBMs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned earlier, most NoSQL databases don't have the capacity of performing
    joins in queries. Consequently, the database schema needs to be designed in another
    way.
  prefs: []
  type: TYPE_NORMAL
- en: This has led to several techniques when relational data has to be managed in
    a NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Querying multiple queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This idea relies on the fast response feature typical of these databases. In
    lieu of getting all data in a simple request, several queries are chained in order
    to get the desired information.
  prefs: []
  type: TYPE_NORMAL
- en: If the performance penalty is not acceptable, other approaches are possible.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of nonnormalized data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The issue in this case is solved with a distinct approach: instead of storing
    foreign keys, the corresponding foreign values are stored together with the model''s
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine blog entries. Each one can also relate and save both username
    and user ID, so we can read the username without requiring an extra query.
  prefs: []
  type: TYPE_NORMAL
- en: The shortcoming is that when the username changes, the modification will have
    to be stored in more than one place in the database. So, this kind of approach
    is handy when the average of reads (with respect to write operations) is fairly
    substantial.
  prefs: []
  type: TYPE_NORMAL
- en: Data nesting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will see in the practices with MongoDB, a common practice is based on
    placing more data in a smaller number of collections. Translated into practice,
    this means that in the blogging application we imagined earlier, we could store
    comments in the same document as the blog's post document.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, a single query gets all the related comments. In this methodology,
    there's only a single document that contains all the data you need for a specific
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this practice has become a de facto practice given the absence of
    a fixed schema in these databases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In other words, the philosophy followed here is more or less *save your data
    in such a way that the number of storage units implied in a query is minimum*
    (optimally, only one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The terminology that''s used changes as well. The following table succinctly
    explains the equivalence in terms of relations between SQL and NoSQL databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SQL | MongoDB |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Database | Database |'
  prefs: []
  type: TYPE_TB
- en: '| Table | Collection |'
  prefs: []
  type: TYPE_TB
- en: '| Row | Document or BSON document |'
  prefs: []
  type: TYPE_TB
- en: '| Column | Field |'
  prefs: []
  type: TYPE_TB
- en: '| Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Table joins | Embedded documents (with linking) |'
  prefs: []
  type: TYPE_TB
- en: '| Primary key (unique column or column combinations) | Primary key (automatically
    set to the `_id` field in MongoDB) |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregation (for example, by group) | Aggregation pipeline |'
  prefs: []
  type: TYPE_TB
- en: About CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of MongoDB, which we'll use in this chapter, a read operation is
    a query that targets a specific collection of documents. Queries specify criteria
    (conditions) that identify which documents MongoDB has to return to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any query needs to express the fields required in the output. This is solved
    using a projection: a syntax expression that enumerates the fields indicating
    the matching documents. The behavior of MongoDB follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Any query is aimed for a single collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query syntax allows you to establish filters, ordering, and other related
    limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No predefined order is used unless the `sort()` method forms a part of the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All CRUD operations use the same syntax, with no difference between reading
    and modification operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries with a statistical character (aggregation queries) use the $match pipeline
    to allow access to the queries' structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditionally, even in the relational model, those operations that change information
    (create, update, or delete) have their own syntax (DDL or DML in que SQL world).
    In MongoDB, they are noted as data modification operations, since they modify
    data in a single collection. However, for update operations, a conceptual division
    is usually made in order to distinguish punctual updates (modifications) from
    totally changing updates (replacements). In this case, only the `_id` field is
    preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the operational offer can be resumed in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding information is performed with insert operations (either with new data
    to an existing collection or by adding a new document)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes adopt two forms: while updates modify the existing data, remove operations
    totally delete data from a given collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three operations don't affect more than one document in a single process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, update and remove can use different criteria to establish
    which documents are updated or removed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear similarity in the syntax used for these operations and the
    one used in pure reading queries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, some of these operations are piped, that is, linked to the previous
    query by chained calls
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in the case of MongoDB, we would have a schema like what is shown in below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About CRUD operations](img/image00555.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: MongoDB on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, if we want to follow the samples in this chapter, an installation
    of MongoDB is required on our local machine. You can do this from the official
    site ([https://www.mongodb.com](https://www.mongodb.com)), where you'll find the
    installation software for the most popular operating systems (Windows, Mac, Linux,
    and Solaris).
  prefs: []
  type: TYPE_NORMAL
- en: You'll also find different editions of the product, including an Enterprise
    version for different flavors of Mongo. For the purpose of this topic, we can
    use the popular Community Edition Server version and download and install it using
    the `.msi` file resulting from the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the documentation indicates, the installer includes all other software dependencies
    and will automatically upgrade any older version of MongoDB that''s previously
    been installed. The current version (at the time of writing this) is 3.2.6, and
    it changes periodically. The process only takes a few seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MongoDB on Windows](img/image00556.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: File structure and default configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a result of the installation, a set of files will appear in the `Program
    Files/MongoDB` directory, containing a number of utilities and tools, plus the
    server itself. The main files to keep track of are `mongod.exe`, which is the
    server executable, and the command-line utility (`mongo.exe`), which provides
    a set of interactive options and allows data operations as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you launch the server, a command window will show up, presenting some default
    configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a default data directory in `c:\data\db`, which is the default physical
    location of its internal data as well as the user's. Within this directory, a
    journal data file is created by default. It can be changed with a `mondod –dbpath
    U:\datapath` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another storing location is initialized in `c:\data\db\diagnostic.data`, especially
    dedicated to activity monitoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port `27017` is assigned to start listening for connections via TCP. You can
    change it in the configuration or by calling `Mongod.exe` with the `--port` [number]
    argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, you can start interacting with the database. To do this, in a
    command-line fashion, you should use `mongo.exe`. Once launched, you can ask for
    help, and an initial list of commands will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `show dbs` command will output, in my case, two databases that are
    present (previous databases of prior installations are not deleted, since they
    are located at another directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '![File structure and default configuration](img/image00557.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In order to connect to a given database, we can type `use <db_name>` as the
    capture shows. This command also allows the creation of a new database. Hence,
    if the database exists, MongoDB switches to it; otherwise, it creates a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more useful feature allows you to ask for help on a concrete database. For
    example, if our `Personal` database contains a `People` collection, we can ask
    for specific help with a commands such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another helpful utility is `mongoimport.exe`, which allows you to import data
    from a physical file we might have. We''ll use this tool to import a flat JSON
    file obtained from the Union Cicliste International ([http://www.uci.ch/road/ranking/](http://www.uci.ch/road/ranking/))
    with the stats for 2016\. Once we move the file to the `c:\data\db` directory
    (this can be done from another location anyway), we can use the following command
    to import this data into a new database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can start querying the database once we switch into it and find
    the first document in our collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File structure and default configuration](img/image00558.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the first command tells us the number of documents inserted,
    and the next one retrieves the first document. There's something to point out
    here, and that is the `_id` element in the document. It is automatically inserted
    by the importing process in order to uniquely identify each document in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Some useful commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, we can use the big collection of commands provided by Mongo to query
    the database in different ways. For example, if I want to list all cyclists from
    Great Britain, I can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in order to filter information, the `find()` method expects a criteria
    written using the object notation syntax, which is typical of JavaScript. However,
    we can also select one from the total number of results, indicating it with an
    array syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine, other options allow the projection of the required elements
    in a document instead of retrieving the whole one. For instance, we can ask for
    the names and ages of all the cyclists from Spain in this list using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The numbers associated with the fields to be retrieved only indicate presence
    required (we want them in the output list) if they're bigger than 0 or absence
    if they are 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we need the list of Italian cyclists with their names and teams
    and no other field. We can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Other combinations allow you to use JavaScript declarations to retrieve partial
    information that can be used later to get another result set. Here, we load the
    query into a variable and call it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The list of available operators in MongoDB is quite large, and they can be
    categorized according to the purpose in three main categories, as the official
    documentation shows:'
  prefs: []
  type: TYPE_NORMAL
- en: Query and projection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these categories contains a large number of options, so you can refer
    to the official documentation for more details ([https://docs.mongodb.com/manual/reference/operator/](https://docs.mongodb.com/manual/reference/operator/)).
    For the purpose of this chapter, we''ll use a few of the most common operators
    that appear in everyday work with MongoDB. The following table lists the most
    used operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$eq` | Matches values that are equal to a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$gt` | Matches values that are greater than a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$gte` | Matches values that are greater than or equal to a specified value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$lt` | Matches values that are less than a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$lte` | Matches values that are less than or equal to a specified value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$ne` | Matches all values that are not equal to a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$in` | Matches any of the values specified in an array |'
  prefs: []
  type: TYPE_TB
- en: '| `$nin` | Matches none of the values specified in an array |'
  prefs: []
  type: TYPE_TB
- en: 'Note that you can find some of these operators in different contexts or domain
    queries: for instance, most of the operators in the preceding table are also present
    in the set of operators linked to the Aggregation pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important clue is that these areas provide mechanisms to deal with
    information in many ways depending on the context. Actually, many of the operators
    that we find available in the SQL Server or Oracle RDBMS have an equivalent here,
    always preceded by the `$` sign. For example, you can use the arithmetic operators
    in the Aggregation pipeline to create calculated fields, or you can use some mathematical
    operators defined as MongoDB commands, that remind, even syntactically, those
    that we can find in the Math static class in C# or JavaScript: `$abs`, `$ceil`,
    `$log`, `$sqrt`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens with other typical RDBMS operators, such as the aggregation operators
    commonly used in statistical queries: `$sum`, `$avg`, `$first`, and so on. Other
    common families of operators that facilitate management operations are Date operators,
    String operators, Array operators, and Set operators.'
  prefs: []
  type: TYPE_NORMAL
- en: The way to use them always depends on the context of the operation to be performed.
    In queries, we can embed them as part of the expressions that serve as the filtering
    criteria. However, keep in mind that the operand and operator form an object expression
    criteria. Also, remember that several of these expressions can be indicated with
    comma separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we want the list of cyclists with more than 1,000 points
    and less than 1,300 points. We could express it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Observe that there's an implicit AND operator in the way we express the points
    limits (the minimum and maximum) separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OR operator can also be expressed in this manner (`$or`), but the syntax
    for some cases requires careful separation of concerns. Let''s imagine a case
    where we need to find a cyclist belonging to Commonwealth, for example. We need
    an `$or` operator to express this condition according to this syntax (we''re omitting
    other nations not present on the list for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Effectively, the results of such query would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Altering data – the rest of CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operations that modify the contents of our database are represented by
    three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add**: `insert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete**: `remove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify**: `update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the first case, we can express the insertion in a JavaScript
    variable and use that variable to pass it to to the `insert()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there's an extra line from Mongo, indicating that a new document
    has been inserted (also, an array can be passed for a multiple insertion).
  prefs: []
  type: TYPE_NORMAL
- en: Besides, there's another important factor we already mentioned, which has to
    do with flexibility. Let's say we want to include another important runner from
    the US, such as Tejay Van Garderen, but in this case, we have some extra information
    related to the details of his nation, such as `State` (`Washington`) and `City`
    (`Tacoma`) he was born in. We want to include this information in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will proceed in the same way, only assigning to the `Nation` value a complex
    value made of three fields: `Name`, `State`, and `City`. We can proceed in exactly
    the same way as earlier but with these changes included.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the process, a look at the content will show the information structure
    inserted, along with its new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The insertion went fine, but I made a (copy/paste) mistake and didn't change
    the name of the runner properly (the rest of the data is fine, but the name has
    to be modified). So, we can use the `update()` command in order to achieve this
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s simple; we just have to localize the target document as the first parameter
    and indicate the new data as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The results: one document found and one modified.'
  prefs: []
  type: TYPE_NORMAL
- en: Text indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we want to list all the cyclists from the United States in our collection.
    MongoDB provides an interesting possibility: create a text index to be used later
    in text searches. At creation time, we can indicate which text fields (along with
    their data types) need to be included in the index; for example, take a look at
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous code, we have indexed two fields, and the total number of
    indexes now is two (remember that the `_id` index is created automatically). This
    is perfect for practical usage, since we now can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the search was made without indicating the position of the string
    in the field. The output shows both documents with their different data structures
    for the `Nation` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t have any indexes, it is also possible to use other operators for
    search, such as `$in`, which uses the following syntax prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can rewrite a similar query containing all cyclists from France and
    Spain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For deletion, the procedure is pretty straightforward. Just remember that deletions
    affect one or more documents depending on the criteria defined for the operation.
    In this case, remember that there is no equivalent to the cascade behavior we
    might configure in the relational model.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB from Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find plenty of drivers for MongoDB directly on the MongoDB official
    site, including several versions for the C# language, which currently stands for
    version 2.2.3\. This driver provides support for the version of MongoDB I'm using
    in this book (v. 3.2).
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this version was created and tested in Visual Studio 2015, so that's
    another reason to use it here. You can find a whole page with explanations, links
    to other resources, videos, articles, community supported tools, presentations,
    and so on at the [https://docs.mongodb.com/ecosystem/drivers/csharp/](https://docs.mongodb.com/ecosystem/drivers/csharp/)
    address. This driver is the officially supported driver for MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'First demo: a simple query from Visual Studio'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several approaches for driver's installation, but you can install
    it using NuGet from Visual Studio, so we'll start by building a new Console project
    (ConsoleMongo1), and after that, select the NuGet Window interactive. Once there,
    typing `MongoDB` will show a bunch of libraries, including the official driver
    in the first position.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, three libraries are installed:
    two versions of MongoDB driver (core and standard) and Mongo.BSon, which contains
    a serialization infrastructure that you can use to build high-performance serializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First demo: a simple query from Visual Studio](img/image00559.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To work with MongoDB from C#, the driver offers a set of convenient objects,
    which in great part, represent those we have been using in the Mongo Command Window
    to perform previous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Before any operation, it's important to remember that NoSQL structures are flexible,
    but in order to work properly from the C# side, it's more useful to have a structure
    for our data (a data model or contract). To do this, we can copy and paste a single
    document from our database and use the **Paste as JSON** option, which will convert
    the structure to a set of classes containing the keys defined in the document
    as classes' fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the demos in this part, I''ve opted for another database source, which
    is more similar to what we would use in a real application. For this purpose,
    a possible source is the NorthWind JSON website, which offers JSON versions of
    the popular NorthWind database used for years in Microsoft Access and SQL Server
    as the demo database. You can find the database at [http://northwind.servicestack.net/customers?format=json](http://northwind.servicestack.net/customers?format=json).
    I''ve downloaded two tables from here: `Customers` and `Orders`. Remember that
    through the import process, a new field named `_id` will be generated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the **Paste as JSON** option, its `_id` field will be assigned
    to a string, but internally, it is really an `ObjectId` type. To avoid problems
    later, you can change it manually to have a definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s make a simple query that we can list in the Console window. To achieve
    this, we need to reference the previously mentioned libraries and follow the basic
    steps: connect to the NorthWind database, get a reference to a collection, define
    the query (we can use Linq and/or a generic functionality for this purpose), and
    present the results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An initial, simple approach would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you launch the application, a Console window will show the requested set
    of customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First demo: a simple query from Visual Studio](img/image00560.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's quickly review the process here. MongoClient represents a connection
    to the MongoDB server. It follows a reference to the required database. Once there,
    we get the Customers collection, but since we already know the customers type
    and its members, we can use generics to express that, indicating that the result
    of calling `GetCollection<Customer>("Customers")` is of that type (note that the
    collection is a plural name).
  prefs: []
  type: TYPE_NORMAL
- en: When the collection variable is ready, it can be used as any other generic collection,
    so we can use lambda expressions, LINQ, and all other resources just the same
    as we did in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note, though, that we've run a query in a synchronous mode. When the amount
    of data available (to search for) is high, asynchronous operations are recommended.
    Therefore, let's make the query a bit more complex and run it this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume that we need to know which customers from the United
    States or the United Kingdom are owners as well (the `CustomerTitle` field values
    `Owner`). So, we need a bit more complex filter. And we also want the process
    to be asynchronous, to avoid blocking errors or unresponsive user interfaces.
    Thus, we''ll use the `async`/`await` operators to build a method in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we perform the query asynchronously (in a non-blocking fashion), with
    just a few changes, getting a couple of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First demo: a simple query from Visual Studio](img/image00561.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that besides using the `async`/`await` operators, the end of the query
    varies a little. We now call the `toListAsync()` method from the `Result` object
    in order to get the final collection. The rest is like what is done in the previous
    (synchronous) method.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can imagine, CRUD operations are fully supported, especially when using
    this new version of the driver, which includes various new possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these operations are presented in two main families depending on whether
    you want to deal with only one or many documents in the collection. Consequently,
    we find methods such as `DeleteOne`/`DeleteMany, InsertOne`/`InsertMany`, `ReplaceOne`/`ReplaceMany`,
    and so on. In turn, they present synchronous and asynchronous versions for each
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For instance, in order to delete a single customer, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we're using a very convenient method, which allows us to find
    and delete a single document in a sole (atomic) operation (`FindOneAndDeleteAsync`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we''ve changed the `BasicQuery` method to receive a string with the country
    to be listed, and we call that method again just after the deletion to check whether
    everything was okay. Now there''s only one customer from that country:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deletion](img/image00562.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a note, remember that if no document is found, any possible exception thrown
    by the application, should be handled in the usual manner.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Insertion follows a similar pattern. We create a new customer following the
    contract definition and insert it asynchronously using a simple, straightforward
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything''s okay, we''ll be shown an output like what is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion](img/image00563.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Modifications and replacements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Working with document collections, it's common to distinguish between updates
    and replacements. In the first case, we're managing something similar to the `UPDATE`
    clause in standard SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: The second situation deals with a total replacement of a document, with an exception
    made of the `_id` field, which is immutable. In this case, since there's no fixed
    model to follow, the information replaced could be totally different from the
    previous one.
  prefs: []
  type: TYPE_NORMAL
- en: To replace content, it's handy to use static methods of the `Builders` class,
    which provides the C# driver. We can define a generic `Builder` class for our
    customers and use the `Filter` and `Update` methods to locate and replace a given
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does exactly that: it locates the previously inserted company
    and changes the `CompanyName` field to another string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note I have included another version of the `BasicQuery` method, called `BasicQueryByCompany`,
    in order to allow the returning of the modified field in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifications and replacements](img/image00564.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the case of replacements, you can use the `ReplaceOneAsync` and `ReplaceManyAsync`
    methods, just like what we did for the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, most typical operations you might be used to in SQL databases
    are present here as well: grouping, statistical results, security configuration,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adoption of NoSQL databases is another story: scalability, availability, previous
    knowledge of NoSQL, and the learning curve are only a few of the considerations
    you might ponder at the time of selecting one of these databases in a new project.
    Whatever the case may be, support from most of the available NoSQL databases from
    the .NET platform is guaranteed for the majority of implementations, so that shouldn''t
    be an issue.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along the course of this chapter, we went through the foundations and basics
    of NoSQL databases, starting with their historical evolution and the several types
    of architectures and peculiarities linked to this storage approach and a list
    of the most typical implementations we can find today.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the correct manner in which the CRUD operations should be managed
    in these contexts from a general-purpose point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to MongoDB, analyzing the details of its installation and
    management in a Windows system, prior to starting the use of a MongoDB instance
    by means of its default (command-line) tools in order to operate and import, manipulate,
    list, and modify its contents without any external tool in order to study the
    low-level mechanisms behind its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the C# driver available on the official MongoDB website in
    order to accomplish the same CRUD operations from a Console application, including
    the most typical actions required in LOB applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to use some of the—many—resources and
    projects available as Open Source, which are monitored and actively supported
    by Microsoft these days, and that includes the Roselyn services, the new TypeScript
    language, and others.
  prefs: []
  type: TYPE_NORMAL
