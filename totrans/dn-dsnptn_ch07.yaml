- en: Chapter 7. Patterns in the .NET Base Class Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on areas where the creators of the .NET Framework
    library have leveraged GoF design patterns for creating **Application Programming
    Interfaces** (**APIs**). This will give you an enormous insight into the usage
    of design patterns as a mechanism to expose well-defined software interfaces.
    Most developers consume design pattern-based software interfaces without knowing
    much about their underpinnings. This chapter will demystify API design based on
    patterns. As a reader, you will find real-world application of the following GoF
    patterns in the .NET Framework library:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter pattern (aka wrapper) translates one interface for a class into
    a compatible interface expected by the client. This allows objects to work together,
    which normally wouldn't because of incompatible interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is achieved by providing its cooperating interface to clients while using
    the original interface to invoke the core functionality provided by the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The amount of code necessary to do this is most often small. The adapter is
    also responsible for transforming data into appropriate forms expected by the
    library that implements the actual logic. The adapter can be a class adapter or
    an object adapter. The `SQLDataAdapter` class in .NET Framework represents a set
    of data commands (`select`, `update`, and `delete`) and a database connection
    that is used to fill the `DataSet` (in the case of select), or update the data
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Strategy pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy pattern (aka policy pattern) is a design pattern where we can choose
    algorithms depending upon the context. The pattern is intended to provide a means
    to define a family of algorithms encapsulated as an object to make them interchangeable.
    The strategy pattern lets the algorithms vary independently from the clients that
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Array` and the `ArrayList` classes provide the capability to sort objects
    contained in them through the `Sort` method. One can use different strategies
    to sort by leveraging the strategy design pattern-based API provided by the .NET
    BCL. The designers of .NET Framework have given us the `IComparer<T>` interface
    to provide a sorting strategy. `Array` and `ArrayList` provide the capability
    to sort the objects contained in the collection via the `Sort` method. Strategy
    design pattern is used with `Array` and `Arraylist` to enable sorting using different
    strategies, without changing any client code, via an `IComparable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort an `Employee` list, we need to create a class that implements the `IComparer<T>`
    interface. An instance of this class needs to be passed to the `Sort` routine
    of the `List<T>` instance. The `Compare` method of `IComparer<T>` should implement
    a `SIGNUM` function that returns `1`, `0`, or `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippets show how we can change sorting criteria depending
    on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort by name, we need to create another object implementing the same interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will leverage the `SortByName` class to sort the object based on the lexicographical
    order. We will also use the `StringBuilder` class to create a string object to
    be printed on the console. The `StringBuilder` class is an instance where the
    builder pattern is leveraged by the designers of .NET Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Builder pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The builder pattern is a creational pattern, which separates the construction
    of a complex object from its representation. Usually, it parses a complex representation
    to create one or more target objects. Most often, builders create composites.
    In the `System.Data.SqlClient` namespace, `SqlConnectionStringBuilder` helps one
    build connection strings for the purpose of connecting to an RDBMS engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The .NET BCL also contains a class that will help us create a URI by assembling
    its constituents. The following code snippet creates a secured HTTP (`https`)
    URL, which sends data to port `3333`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Decorator pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decorator pattern attaches additional responsibilities to an object dynamically.
    The inheritance is always not feasible, because it is static and applies to an
    entire class. Decorators provide a flexible alternative to sub-classing for extending
    functionality. The pattern helps add behavior or state to individual objects at
    runtime. The .NET Framework uses decorators in the case of stream processing classes.
    The hierarchy of stream processing classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.IO.Stream`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO.BufferedStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO.FileStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO.MemoryStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Net.Sockets.NetworkStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Security.Cryptography.CryptoStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippets show how one can use `FileStream` to read contents
    from an operating system disk file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `StreamReader` is a decorator object, which uses the additional functionality
    of buffering the avoid disk access to speed up operation.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility pattern in ASP.net
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chain of responsibility pattern is a design pattern consisting of a series
    of processing objects through which we pass a data stream for filtration or modification.
    Ultimately, the process terminates when the data stream passes the last processing
    object at the end of the chain. The ASP.NET pipeline is a wonderful example where
    the chain of responsibility pattern is leveraged to provide an extensible programming
    model. The ASP.NET infrastructure implements WebForms API, ASMX Web services,
    WCF, ASP.NET Web API, and ASP.NET MVC using HTTP modules and handlers. Every request
    in the pipeline passes through a series of modules (a class that implements `IHttpModule`)
    before it reaches its target handler (a class that implements `IHttpHandler`).
    Once a module in the pipeline has done its duty, it passes the responsibility
    of the request processing to the next module in the chain. Finally, it reaches
    the handler. The following code snippet shows how one can write an object that
    leverages the chain of responsibility pattern to create a module that filters
    an incoming request. These filters are configured as chains and will pass the
    request content to the next filter in the chain by the ASP.net runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure the preceding HTTP module in the `Web.config` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the ASP.NET pipeline, a request passes through a series of HTTP modules
    before it hits a handler. A simple HTTP handler routine is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure the handler as given next. Whenever we create an ASP.NET resource
    with the `.smp` extension, the handler will be `SimpleHttpHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding technique of leveraging the chain of responsibility pattern is
    available in other web technologies such as Java Servlets (called Servlet filters)
    and also available in IIS as ISAPI filters.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge pattern in the .NET RCW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Component Object Model** (**COM**) technology solutions packaged as libraries
    can be consumed through **Runtime Callable Wrapper** (**RCW**), available in the
    .NET platform. By allowing managed classes and COM components to interact, despite
    their interface disparity, RCWs are an example of bridge pattern (implemented
    as an adapter!). Please consult the documentation on **Com Callable Wrapper**
    (**CCW**) and RCW to understand how the bridge pattern is implemented to interoperate
    with components written in other languages (mostly C++/ATL). Technically speaking,
    even ADO.NET API also leverages the bridge pattern, to interact with ODBC and
    other native drivers implemented by respective database vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The factory design pattern has been used by `System.Data.Common` to create
    an instance of the provider, connection, command, or adapter objects in order
    to fetch data from a relational database. The following code snippets demonstrates
    the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Observer pattern in the WPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ObservableCollection` can be considered as a data structure, which leverages
    the observer pattern to provide notifications when items get added or removed,
    or when the whole list is refreshed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet creates an instance of an `Observableconnection` based
    `ObservableDataSource` class. When we add items to the class, we get a notification
    in the `OnCollectionDataChanged` method of the `ObservableDataSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Composite pattern in the .NET Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create complex UI screens, the .NET Framework leverages composite patterns
    extensively. The WPF, ASP.NET Web Forms, and Winforms are some of the key examples
    in this regard. In a UI scenario, one can have a frame class, which acts as a
    container for all the child controls. Typically, developers place panels to divide
    the physical screen to some kind of logical grouping and child controls are placed
    inside these panels. The controls like list, grid can embed other controls. Thus,
    these are wonderful examples of the composite pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Facade pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GoF facade pattern is used in scenarios where a lot of work happens in
    the background and the interfaces to those classes are exposed using a simple
    API. The `XMLSeralizer` class in the .NET BCL does quite a bit of its work behind
    the scenes and access to those routines are given using a very simple interface.
    The following code snippets create a `DataSet` to store a multiplication table
    for the number `42` (remember Douglas Adams!) and the `XMLSeralizer` class persists
    the table to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Iterator pattern in the .NET BCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The iterator pattern is so common that most platforms and frameworks provide
    a mechanism to support it. The .NET BCL has got `IEnumerable` and its generic
    variant , that is, `IEnumerable<T>` to implement custom iterators. To iterate,
    we have got the `foreach` loop construct in C#. Similar constructs are available
    in Java as well. The following program creates a custom list by leveraging the
    .NET fixed length array facility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how the designers of the .NET BCL leverage design
    patterns to expose a well-defined programming model and a flexible API for the
    same. You learned about how some important patterns are put to use by the designers
    of the .NET Framework. In the next chapter, you will learn about concurrent and
    parallel programming in the .NET platform.
  prefs: []
  type: TYPE_NORMAL
