- en: Chapter 6. Continuing the 2D Adventure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we started work on a 2D adventure game. On reaching
    this point, we''ve now created a controllable character that can navigate a level
    using physics and collision detection as well as gravity. This chapter completes
    the 2D game project by adding the remaining features. Specifically, this chapter
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving obstacles and features such as an elevator platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gun turrets to attack the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An NPC with a quest system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting project and assets can be found in the book companion files in
    the `Chapter06/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moving platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s refine the adventure further by adding a moving element to the existing
    scene; specifically, a moving platform object. This platform should move up and
    then down again on a loop, ping-ponging between extremes. The player will be able
    to jump onto the platform to hitch a ride, and the object will be constructed
    as a prefab, allowing it to be reused across scenes. See *Figure 6.1* for the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving platforms](img/figure_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Create a moving platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, select the platform texture in the **Project** panel, making sure
    that it''s specified as a **Sprite** (2D and UI) texture type in the **Object
    Inspector**. The **Sprite Mode** should be set to **Single**. Drag and drop the
    platform texture to the scene and set its **Scale** to (`0.7`, `0.5`, `1`). See
    *Figure 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving platforms](img/figure_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Building a moving platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the platform should be a solid object, the kind of thing with which the
    player can collide. Remember, the player should be able to stand on the platform.
    Consequently, a Collider must be added. In this case, a Box Collider 2D is appropriate.
    To add this, select the platform object in the scene and navigate to **Component**
    | **Physics 2D** | **Box Collider 2D** from the menu. See *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving platforms](img/figure_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Adding a collider to the platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the collider has been added to the platform, you may need to adjust its
    properties from the **Object Inspector**; specifically, its **Offset** and **Size**
    fields to make the collider match the size of the platform sprite closely. Then,
    finally, test the platform by entering the play mode and standing the player character
    on the platform. By doing so, the player should not fall through the platform!
    See *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving platforms](img/figure_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Testing platform collisions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The platform so far is static and motionless, and it should move up and down
    repeatedly. To fix this, we could create a predefined animation sequence using
    the **Animation Editor** via the **Window** | **Animation** menu option. However,
    instead, we''ll use a script file. Frequently, when making animations, you''ll
    often need to reach decisions about which option is best: *C# animations* or *Baked
    animations*. Typically, script should be chosen when an animation should be simple
    and must apply to many objects and vary for each. The following script file `PingPongMotion.cs`
    should be created and attached to the platform. See *Code Sample 6.1*, and code
    comments follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 6.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PingPongMotion` class is responsible for moving a `GameObject` back and
    forth from an original starting point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Awake` function uses the `OrigPos` variable to record the starting position
    of the `GameObject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Update` function relies on the `Mathf.PingPong` function to transition
    a value smoothly between a minimum and maximum. This function fluctuates a value
    between minimum and maximum repeatedly and continuously over time, allowing you
    move objects linearly. For more information, see the Unity online documentation
    at [http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html](http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The completed code should be attached to the platform object in the scene and
    can be reused easily for any other object that should move up and down regularly
    (or left and right).
  prefs: []
  type: TYPE_NORMAL
- en: Creating other scenes – levels 2 and 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the other games created in the book so far, our adventure game will
    span multiple scenes. That is, our game features several different screens, which
    the player may move between by walking off the edge of one screen and entering
    from the edge of another. Supporting this functionality introduces us to some
    new and interesting problems in Unity that are well worth exploring, as we''ll
    see later. For now, let''s make a second and third scene for the game, using the
    remaining background and foreground objects, and configuring collisions for each
    level, allowing the player prefab to work seamlessly with each environment. The
    details to create a level with collisions (Edge Colliders) are covered in depth
    in the previous chapter. The final, completed scenes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Level 2 is divided across two vertically arranged ledges with a set of moving
    platforms on the lower ledge. These are created from the moving platform prefab
    created in the previous section. The upper ledge is, for now, non-hazardous but
    this will be changed later as we add gun turrets that can shoot the player character.
    This level can be reached from the first original level by walking off the left
    edge of the screen. See *Figure 6.5*:![Creating other scenes – levels 2 and 3](img/figure_06_05.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 6.5: Scene 2 – dangerous ledges and moving platforms'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Level 3 is reached from the first original level by walking off the right edge
    of the screen. It consists of one ground-level plane featuring a house. It will
    be home to an NPC character whom the player can meet and receive a quest to collect
    an item. This character is created later in the chapter. See *Figure 6.6*:![Creating
    other scenes – levels 2 and 3](img/figure_06_06.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 6.6: Scene 3 – a lonely house for an NPC'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Both Levels 2 and 3 were created entirely with the techniques seen so far. However,
    to give each scene its own charm and character, some unique elements must be added—some
    of these are specific to each scene and some are more general. Let's now consider
    these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Kill zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scripted feature required by all scenes, but not yet implemented, is
    the **Kill Zone**. That is, the functionality to mark out a region of 2D space
    in the level that, when entered by the player, will kill them or damage them.
    This is especially useful to kill the player whenever they fall down a hole in
    the ground. Thus, the Kill Zone will be required in every level because every
    level created so far contains pits and holes in the ground. To implement this
    functionality, create a new and empty **GameObject** in any scene. (It doesn't
    matter which because we'll be making a prefab object that can be reused anywhere.)
    As mentioned, new **GameObjects** are created with the menu option, **GameObject**
    | **Create Empty**. Once created, name the object `KillZone`, then position it
    at the world origin (0,0,0), and finally, attach a Box Collider 2D component using
    the menu command, **Component** | **Physics 2D** | **Box Collider 2D**. The Box
    Collider will define the Kill Zone area. Remember to make sure that the **Box
    Collider 2D** is configured as a Trigger by checking the **Is Trigger** checkbox
    in the Inspector from the **Box Collider 2D** component. See *Figure 6.7*. A Trigger
    differs from a Collider; colliders prevent objects from passing through and Triggers
    detect when objects pass through, allowing you to perform custom behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Kill zones](img/figure_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Creating a Kill Zone object and Trigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new script file `KillZone.cs`, which should be attached to the
    Kill Zone object in the scene. This script file is responsible for damaging the
    player''s health for as long as they are in the Kill Zone. At this stage, there
    are several ways to approach kill zone implementation. One way is to destroy the
    player as soon as they enter the Kill Zone. The other is to damage the player
    for as long as they are in the Kill Zone. The second method is preferred here
    because of its versatility and contribution toward code reuse. Specifically, we
    get the option to damage the player by reducing their health at a particular speed
    (if we need to) as well as killing the player instantly simply by reducing their
    health by an increase in reduction speed. Let''s see this at work in the following
    *Code Sample 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 6.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KillZone` class is responsible for continually damaging the player health
    when a `GameObject`, tagged as `Player`, enters and remains within a Trigger Volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnTriggerStay2D` function is called automatically by Unity, once per frame,
    when an object with `RigidBody` enters and remains within a Trigger Volume. Thus,
    when a physics object enters the Kill Zone trigger, the `OnTriggerStay2D` function
    will be called as frequently as the `Update` function. More information on `OnTriggerStay2D`
    can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Damage` variable encodes the reduction of health for the player by adjusting
    the public static property, `Health`, which is part of the `PlayerControl` class.
    When `Health` reaches `0`, the player will be destroyed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, give the game a test run, marking out a Kill Zone in the scene and walking
    the Player into it during play mode. On entry, the player character should be
    destroyed or damaged. To ensure that the player is killed instantly, increase
    the damage to a very high number, such as `9000`! After testing, create a prefab
    from the Kill Zone by dragging and dropping it from the scene **Hierarchy** panel
    to the **Project** panel in the **Prefab** folder. Then, add the **Kill Zone**
    prefab to each level, adjusting and sizing the Collider as needed. See *Figure
    6.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 6.2](img/figure_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Configuring a Kill Zone to destroy on contact'
  prefs: []
  type: TYPE_NORMAL
- en: The UI health bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we introduced the first danger and hazard to the game;
    namely, a Kill Zone that can damage and potentially kill the player. As a result,
    their health has the potential to reduce from its starting state. It''s therefore
    useful both to us as developers and gamers to visualize the health status. For
    this reason, let''s focus on rendering player health to the screen as a UI health
    bar. This configuration of objects will also be made as a prefab, allowing reuse
    across multiple scenes This will prove a highly useful feature. *Figure 6.9* offers
    a glimpse of the future, displaying the result of our work to come:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Preparing to create player health'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a new GUI Canvas in the scene (any scene) by choosing
    **GameObject** | **UI** | **Canvas** from the application menu. Selecting this
    will automatically create an **EventSystem** object in the scene, if one does
    not exist already. This object is essential for proper use of the UI system. If
    you accidentally delete it, **EventSystem** can be recreated by choosing **GameObject**
    | **UI** | **Event System** from the application menu. The newly created Canvas
    object represents the surface on which the GUI will be drawn. See *Figure 6.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Creating a GUI Canvas and Event System'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a new and separate camera object for the UI, adding it
    as a child of the newly created Canvas. By creating a separate camera for UI rendering,
    we can apply camera effects and other image adjustments separately to the UI,
    if we need to. To create a Camera as a child, right-click on the **Canvas** object
    in the **Hierarchy** panel and, from the **Context** menu, choose **Camera**.
    This adds a new camera object to the scene as a child of the selected object.
    See *Figure 6.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Creating a camera child object'
  prefs: []
  type: TYPE_NORMAL
- en: Now, configure the UI camera to be an Orthographic camera. We saw how to do
    this in the previous chapter, as well as earlier chapters too. *Figure 6.12* displays
    the camera settings for an orthographic camera. Remember that an Orthographic
    camera is truly 2D insofar as it removes perspective and foreshortening effects
    from the render result, which is appropriate for GUIs and other objects that live
    and work in screen space. In addition, the camera **Depth** field, from the **Object
    Inspector**, should be higher than the main game camera to ensure that it renders
    on top of everything else. Otherwise, the GUI could potentially render beneath
    and be ineffectual in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Configuring an Orthographic camera for GUI rendering'
  prefs: []
  type: TYPE_NORMAL
- en: 'The created camera is almost ready to go! However, right now, it''s configured
    to render everything in the scene just like any other camera. This means that
    the scene is effectively being rendered twice by two separate cameras. This is
    not only wasteful and poor for performance, but it makes the second camera totally
    unnecessary. Instead, we want the first and original camera to show everything
    in the scene, in terms of characters and environments, but to ignore GUI objects,
    and likewise, the newly created GUI camera should show only GUI objects. To fix
    this, select the main game camera and, from the **Object Inspector**, click on
    the **Culling Mask** drop-down list in the **Camera** component. From here, remove
    the check mark for the UI layer. This drop-down list allows you to select layers
    to be ignored for the rendering from the selected camera. See *Figure 6.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Ignore the UI layer for the main camera'
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the GUI camera object and, for the **Culling Mask** field in the
    **Camera** component, select the **Nothing** option to deselect all options, and
    then enable the UI layer to render only UI layer objects. See *Figure 6.14*. Good
    work!
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Ignoring all layers except the UI layer for the GUI camera'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, any newly created Canvas is configured to work in the Screen Space
    Overlay mode, which means it renders on top of everything else in the scene that
    is not associated with any specific camera. In addition, all GUI elements will
    be sized and scaled on the basis of this. Consequently, to make our work simpler,
    let''s start creating the GUI by first configuring the **Canvas** object to work
    with the newly created GUI camera. To do this, select the **Canvas** object and,
    from the **Canvas** component in the **Object Inspector**, change the **Render
    Mode** from **Screen Space - Overlay** to **Screen Space - Camera**. Then, drag
    and drop the GUI camera object to the **Camera** field. See *Figure 6.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Configuring the Canvas component for camera rendering'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s configure the **Canvas Scaler** component, which is attached to
    the **Canvas** object. This component is responsible for how the GUI appears when
    the screen size is changed, from either up-scaling or down-scaling. In short,
    for our game, the GUI should up- and down-scale relatively to the screen size.
    For this reason, change the **UI Scale Mode** drop-down to **Scale With Screen
    Size**, and then enter the game resolution of `1024 x 600` in the **Reference
    Resolution** field. See *Figure 6.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Adjusting the Canvas Scaler for responsive UI design'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start adding GUI elements to the game, knowing that they will appear
    correctly when added to the scene. To display health, a representation of the
    player will be useful. Create a new **Image** object by right-clicking on the
    **Canvas** object from the **Hierarchy** panel and choosing **UI** | **Image**
    from the context menu. Once created, select the **Image** object and, from the
    **Object Inspector** (in the **Image** component), drag and drop the player head
    sprite from the **Project** panel to the **Source Image** field. Then, use the
    **Rect Transform** tool (*T* on the keyboard) to resize the image in place at
    the top-left corner of the screen. See *Figure 6.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Adding a head image to the GUI Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you cannot see the added head image, remember to assign the UI layer to render
    by the UI camera. In addition, you may need to offset the GUI camera back along
    the *Z* axis to include the head sprite within the **Camera Frustum** (Viewing
    Area).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, anchor the Head Sprite to the top-left of the screen by clicking on
    the **Anchor Preset** button in the **Rect Transform** component from the **Object
    Inspector**. Choose top-left alignment. This locks the head sprite to the screen
    top-left, ensuring that the interface would look consistent at multiple resolutions.
    See *Figure 6.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Anchoring the head position'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the health bar, add a new **Image** object to the GUI Canvas by right-clicking
    on the **Canvas** and selecting **UI** | **Image** from the context menu. For
    this object, leave the **Source Image** field empty and choose red for the **Color**
    field, **RGB (255,0,0)**. This will represent the background or *red status* for
    the health bar when it''s fully depleted. Then, use the **Rect Transform** tool
    to resize the bar as needed, anchoring to the top-left screen corner. See *Figure
    6.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Creating the red health status'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the health bar, we''ll need to use scripting. Specifically, we''re
    going to overlap two identical health bars on top of each other, one red and one
    green. We''ll scale the green bar as the health reduces so that it reveals the
    red bar underneath. Before scripting this behavior, further configuration is necessary.
    Specifically, let''s change the pivot of the health bar away from the center and
    to the middle-left point—the point from which the health bar should scale as it
    reduces and increases. To do this, select the **Health bar** object and, from
    the **Object Inspector**, enter a new **Pivot** value of `0` for **X** and `0.5`
    for **Y**. See *Figure 6.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: Repositioning the Pivot for the health bar'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the green overlay for the health, select the red health bar and duplicate
    it. Name the duplicate `Health_Green` and drag and drop it to appear beneath the
    red version in the **Hierarchy** panel. The ordering of objects in the hierarchy
    relates to the draw order for GUI elements—lower-order objects are rendered on
    top of higher-order objects. See *Figure 6.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI health bar](img/figure_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: Creating a duplicate green bar'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make a new script file linking the width of the green bar to
    the health of the player. This means that reductions in health will reduce the
    width of the green bar, revealing the red bar beneath. Create a new script file
    named `HealthBar.cs` and attach it to the green bar. The following is the *Code
    Sample 6.3* for the `HealthBar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 6.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `HealthBar` class is responsible for reducing the width of a green (on the
    top) health bar, based on the player health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SizeDelta` property of `RectTransform` is used to set the width of `RectTransform`.
    More information on this property can be found at the online Unity documentation
    at [http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html](http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mathf.MoveTowards` function is used to gradually and smoothly transition
    the health bar width from its existing width to its destination width over time.
    That is, as and when player health is reduced, the health bar will decrease gradually
    as opposed to instantly. More information can be found at the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html](http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, make a prefab of the UI objects by dragging and dropping the topmost
    **Canvas** object from the **Hierarchy** panel to the **Project** panel in the
    **Prefab** folder. This allows the UI system to be reused across multiple scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Ammo and hazards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Level 2 is a hazardous place. It should feature not only pits and holes leading
    to kill zones, but also fixed dangers such as gun turrets that can shoot the player.
    This section focuses on their creation. To get started, let's make a gun turret.
    Now, the course companion files don't include a texture or image for the gun turrets,
    but when using the dark silhouette style as we are here, we can easily make a
    consistent turret prop from primitives. In particular, create a new cube object
    (**GameObject** | **3D Object** | **Cube**), rescale it to approximate a gun turret,
    and then position it to the upper ledge in the scene where it will appear as part
    of the scenery. See *Figure 6.22*. Note that you can also use the **Rect Transform**
    tool to resize primitives!
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Creating a prop for a gun turret'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the gun turret created so far is a conspicuous and obvious grey
    color. To solve this, create a new black material. Right-click in the **Project**
    panel and choose **Create** | **Material** from the context menu. Assign the material
    a black color from the **Object Inspector** in the **Albedo** field, and then
    drag and drop the material from the **Project** panel to the **Turret** object
    in the scene. Make sure that the **Smoothness** field for the black material is
    reduced to `0` to prevent a shiny or glowing appearance. After the material is
    assigned, the turret will mix with the scene and its color scheme will be much
    better! See *Figure 6.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: Assigning a black material to the turret'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the turret must fire ammo. To achieve this, it''ll need an empty game
    object to spawn ammo. Let''s create this now by choosing **GameObject** | **Create
    Empty** and drag and drop the object in the **Hierarchy** panel to the Turret
    Cube in order to make it a child of the turret. Then, position the empty object
    to the tip of the cannon. Once positioned, assign an icon representation to the
    empty to make it visible in the viewport. Ensure that the empty is selected and,
    from the Inspector, click on the cube icon (beside the object name) to assign
    it a graphical representation. See *Figure 6.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: Assigning an icon to the Turret Spawn Point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving further with ammo spawning, we''ll actually need some ammo to
    spawn. That is, the turret must fire something, and now it''s time to create this
    something. The ammo should appear as a glowing and pulsating plasma ball. To build
    this, create a new particle system by choosing **GameObject** | **ParticleSystem**
    from the application menu. Remember that a particle system is useful to create
    special effects such as rain, fire, dust, smoke, sparkles, and more. When you
    create a new particle system from the main menu, a new object is created in the
    scene and is automatically selected. When selected, you can preview how the particle
    system works and looks in the **Scene** viewport. By default, the system will
    be spawning small blob-like particles. See *Figure 6.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.25: Creating a particle system'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, on creating a particle system for a 2D game, the particles themselves
    may not be visible because they appear behind other 2D objects in the scene, such
    as the background and characters. You can control the depth order of the particle
    system from the **Object Inspector**. Scroll down in the **Object Inspector**
    and click on the **Renderer** roll-out title to expand more options, bringing
    them into view. From the **Renderer** group, set the **Order In Layer** field
    to a higher value, above the order of other objects to render the particles in
    front. See *Figure 6.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: Controlling the render order of particles'
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent, we should now see particles in the viewport. Getting a particle
    system to look and behave correctly takes some tweaking and trial and error. It
    involves testing settings, previewing their effects in the viewport, making judgments
    about what is needed, and then tweaking and amending as needed. To start creating
    a more believable ammo object, I want particles to spawn slowly in multiple directions
    and not just one direction. To achieve this, expand the **Shape** field from the
    **Object Inspector** to control the shape of the spawn surface. Change the **Shape**
    from **Cone** to **Sphere** and set **Radius** to `0.01`. On doing this, particles
    will spawn and travel in all directions emitted from a Sphere surface. See *Figure
    6.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: Changing the shape of the particle system emitter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, adjust the main particle system properties to create the energy ball effect.
    From the **Object Inspector**, set **Start Lifetime** to `0.19`, **Start Speed**
    to `0.88`, and **Start Size** to `0.59`. Then, set **Start Color** to **teal (light
    blue)**. See *Figure 6.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.28: Configuring the particle system main properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! The particle system should now look just as we need it. However, if
    we press play on the toolbar, it doesn''t move. Ammo should, of course, hurtle
    through the air and collide with its target. So, let''s make a `Mover` script
    that should be attached to the object. The following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mover features nothing that we haven''t seen before many times already.
    It moves an object (the ammo) in direction of its forward vector. For this reason,
    as our game is two-dimensional, the particle system object may need to be rotated
    in order to turn the forward vector along the *X* axis. See *Figure 6.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.29: Aligning the forward vector to the X axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in addition to moving through the level, the ammo object must collide
    with and damage the player character on impact. To achieve this, several steps
    must be taken. First, a Rigidbody component must be attached to the ammo, allowing
    it to collide with other objects. To add Rigidbody, select the Ammo object in
    the scene and, from the application menu, choose **Component** | **Physics** |
    **Rigidbody2D**. Once added, enable the **Is Kinematic** checkbox from the Rigidbody
    component in the **Object Inspector**. This ensures that the object will travel
    based on the Mover script and still interact with physical objects without being
    affected by gravity. See *Figure 6.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: Marking Rigidbody with Is Kinematic'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for a Circle Collider to the ammo object to give the ammo some shape, form,
    and size in terms of physics, allowing collisions to be detected between the ammo
    and its target. To do this, choose **Component** | **Physics 2D CircleCollider**
    from the application menu. Once added, mark the collider as Trigger and change
    **Radius** until it approximates the size of the ammo object. See *Figure 6.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.31: Configuring the Circle Collider for the Ammo object'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ammo should support two final and additional behaviors. First, the ammo
    should damage and perhaps destroy any target it collides with, and second, the
    ammo should destroy itself, both after an elapsed time and if it collides with
    the target. To achieve this, two additional scripts will be created; specifically,
    `CollideDestroy.cs` and `Ammo.cs`. The following code lists the `Ammo.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code lists the `CollideDestroy.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code spanning across these files is functionality that we encountered before
    when making the Twin-stick Space Shooter. Both the files should be attached to
    the ammo object in the scene. Once completed, just drag and drop the ammo object
    from the scene viewport to the **Project** panel in the **Prefabs** folder. This
    makes an Ammo prefab, ready to add to any scene. See *Figure 6.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo and hazards](img/figure_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.32: Adding the Destroy and Ammo components to the Ammo and then making
    a prefab'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent work! You now have an ammo object that fires, moves, and collides
    with the player. By setting the **Damage** setting high enough, you will be able
    to destroy the player on impact. Give this a test now by adding an ammo object
    to the scene and pressing the play icon. Of course, right now, nothing in the
    scene actually fires the ammo. We'll explore that next.
  prefs: []
  type: TYPE_NORMAL
- en: Gun turrets and ammo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve now created an ammo object (a projectile) and we''ve started to engineer
    a gun turret object, but it doesn''t yet spawn ammo. Let''s create this functionality
    now. We have a spawn point positioned in front of the turret parented to it as
    a child object. We''ll attach a new script file called `AmmoSpawner.cs` to this
    object. This script is responsible for generating ammo at regular intervals. Refer
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code relies on the `Invoke` function called at random intervals
    using `Random.Range` in order to instantiate a new ammo prefab into the scene.
    This code could be improved using Object Pooling (or Caching), as discussed in
    the previous chapter with ammo, but in this case, the code performs acceptably.
    See *Figure 6.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gun turrets and ammo](img/figure_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.33: A time delay of (0,0) generates ammo continually in a beam. Increase
    the value to insert reasonable gaps between ammo spawns'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We've now created a gun turret that, like the ammo itself, can be
    turned into a prefab. Make sure that the **Time Delay** range (the time between
    ammo spawns) is set to a value higher than zero; otherwise, ammo will be continually
    generated and become practically impossible for the player to avoid. Go ahead
    and position more turrets, if needed, to balance the difficulty of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: NPCs and quests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NPC** stands for **Non-player Character** and typically refers to any friendly
    or neutral characters other than the player-controlled character. In our adventure,
    Level 3 should feature an NPC character standing outside their house, and they
    provide us with a quest; specifically, to collect a gem item from Level 2, which
    features many hazards, including pits and gun turrets, as we''ve seen. To create
    the NPC character, we''ll simply duplicate the player and adjust the character
    color, making them appear distinct. Thus, simply drag and drop the **Player**
    prefab from the **Project** panel to the Level 2 scene and position it near the
    house area. Then, remove all additional components (such as the Player Controller
    and Collider) to return this character back to a standard sprite that is not player-controlled.
    See *Figure 6.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NPCs and quests](img/figure_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.34: Creating an NPC from the player character prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s invert the character''s **X** scale to make him or her face left
    instead of right. Select the parent NPC object as opposed to its constituent limbs,
    such as hands and arms, and invert its **X** scale. All child objects will flip
    to face the direction of their parent. See *Figure 6.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NPCs and quests](img/figure_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.35: Flipping the X scale for a character NPC'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also change the color of the NPC from green to red to distinguish
    him from the player. Now, the character is a multipart object composed from several
    sprite renderers. We could select each object and change its color individually
    via the **Object Inspector**. However, it''s easier to select all the objects
    and change their color together; Unity 5 supports multi-object editing for common
    properties. See *Figure 6.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NPCs and quests](img/figure_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.36: Setting the NPC color'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NPC should talk to the player on approach. This means that when the player
    approaches the NPC, the NPC should display dialog text. The text to be displayed
    varies, depending on the status of their quest. On a first visit, the NPC will
    give the player a quest. On a second visit, the NPC will respond differently,
    depending on whether the quest has been completed in the meantime. To start creating
    this functionality, we need to determine when the player approaches the NPC. This
    is achieved using a Collider. Consequently, select the NPC object in the scene
    and then choose **Component** | **Physics 2D** | **Box Collider 2D** from the
    application menu. Size the collider not to approximate the NPC specifically, but
    to approximate the area around the NPC in which the player should enter to have
    a conversation. Be sure to mark the collider as a Trigger object, allowing the
    player to enter and pass through. See *Figure 6.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NPCs and quests](img/figure_06_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.37: Configuring the NPC Collider'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we need a GUI element to act as the conversation panel to display
    conversation text when the NPC speaks. This configuration simply consists of a
    GUI Canvas object with a Text object child. Both of these objects can be created
    from the application menu with **GameObject** | **UI** | **Canvas and GameObject**
    | **UI** | **Text** respectively. The Canvas object should also have a CanvasGroup
    component attached using the **Component** | **Layout** | **CanvasGroup** menu
    option. This lets you set the alpha transparency for the panel and child objects
    as one complete unit. The Alpha member can be changed from the **Object Inspector**.
    A value of `1` means fully visible and value of `0` means fully transparent. See
    *Figure 6.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NPCs and quests](img/figure_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.38: Adding a Canvas Group component to the GUI conversation panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent. We now have the ability, if we need to, to fade the panel in and
    out simply by animating the Alpha value from `0` to `1` over time. However, we
    still need functionality to maintain quest information to determine whether a
    quest has been assigned and to determine which text should be displayed in the
    conversation, based on the quest completion status. To do this, a new class must
    be created, `QuestManager.cs`. This class will allow us to create and maintain
    quest information. Refer to the *Code Sample 6.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 6.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QuestManager` maintains a list of all quests (`Quest`). That is, a list of
    all possible quests within the game and not a list of only assigned or completed
    quests. The `Quest` class defines the name and status for a single and specific
    quest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any single quest can be `UNASSIGNED` (meaning that the player hasn't collected
    it), `ASSIGNED` (the player has collected it but not completed it), and `COMPLETE`
    (the player has collected and completed it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetQuestStatus` function retrieves the completed status of the specified
    quest. The `SetQuestStatus` function assigns a new status to the specified quest.
    These are static functions, and so any script can set or get this data from any
    place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this object, create an instance in the scene (the first scene of the
    game), and then define all the quests that can be collected via the **Object Inspector**.
    In our game, there is only quest available: the quest given by an NPC character
    to collect a stolen gemstone from Level 2, the hazardous scene protected by gun
    turrets. See *Figure 6.39* for how I configured quests to work with **Quest Manager**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 6.8](img/figure_06_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.39: Defining in-game quests via QuestManager'
  prefs: []
  type: TYPE_NORMAL
- en: '`QuestManager` defines all the possible quests in the game, whether or not
    they''re collected by the player. However, the NPC still needs to assign the quest
    to the player on approach. This can be achieved with the script file, `QuestGiver.cs`.
    See the following code. This script file should be attached to anything that gives
    quests, such as the NPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After attaching this script to the NPC, give the game a test by pressing the
    play icon on the toolbar. Approach the NPC, and the GUI text should change to
    the specified quest as defined for the **QuestName** field for the **QuestGiver**
    component in the **Object Inspector**. This name should match **QuestName**, as
    defined in the `QuestManager` class. See *Figure 6.40*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 6.8](img/figure_06_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.40: Defining the QuestGiver component'
  prefs: []
  type: TYPE_NORMAL
- en: The assigned quest is to collect a gemstone, but our levels lack a stone. Let's
    now add one for the player to collect. To do this, drag and drop the GemStone
    texture from the project panel (`Texture` folder) to scene 2 on the topmost ledge
    so that the player has to climb to reach it (a challenge!). See *Figure 6.41*.
    Be sure to attach a **Circle Collider** trigger to the object, allowing it to
    collide with the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 6.8](img/figure_06_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.41: Creating a Quest object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll need a `QuestItem` script to set the quest status on the `QuestManager`
    class when the item is collected, allowing `QuestGiver` to determine whether the
    gem has been collected the next time the player visits. The `QuestItem` script
    should be attached to the Gem object. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is responsible for setting the quest status to completed
    when the gem (quest item) object is collected as the player enters the trigger
    volume. This happens through the `QuestManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent work! You now have a completed integrated quest system and an NPC
    character. The complete files for this project can be found in the `Chapter06/End`
    folder. I highly recommend checking them out and playing the game. See *Figure
    6.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 6.8](img/figure_06_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.42: The completed game!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great work! We''ve now completed the 2D adventure game. Some minor details
    were not covered in this chapter for the sake of clarity and conciseness because
    we''ve seen the methods or content already in earlier chapters. Hence, it''s important
    to open the course files and check out the completed project, seeing how the code
    works. Overall, in having reached this far in the book, you have three completed
    Unity projects to your name. So, in the next chapter, we''ll wrap up everything
    that we''ve seen so far and get started on the grand finale: the final, fourth
    project!'
  prefs: []
  type: TYPE_NORMAL
