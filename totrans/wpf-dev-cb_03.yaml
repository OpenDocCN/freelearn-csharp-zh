- en: Layouts and Panels
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a UI layout using a Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing elements in uniform cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically repositioning controls using a `WrapPanel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing controls in a Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning controls inside a Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping UI elements using a Border
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scrollable panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docking controls using a DockPanel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rescaling UI elements using a `ViewBox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a tabbed layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically adding/removing elements in a panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the drag and drop feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF provides a proper layout and positioning to provide interactive, user-friendly
    applications with a suitable container element that helps you to position the
    child UI elements. The parent container is usually the contents of a window. You
    can place child level containers and elements with proper margins, paddings, and
    alignments.
  prefs: []
  type: TYPE_NORMAL
- en: In WPF, `Panel` is the base class that provides layout support. There are plenty
    of derived panels in WPF that help you to create simple to complex layouts and
    all of them are defined in the `System.Windows.Controls` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `Panel` elements support sizing and positioning defined by the `FrameworkElement`.
    You can set the `Height`, `Width`, `Margin`, `Padding`, `HorizontalAlignment`,
    and `VerticalAlignment` properties to design your UI. The following diagram describes
    these important properties, which you will use everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8802f6b-9d70-42ba-b124-6dd86ceb6af1.png)'
  prefs: []
  type: TYPE_IMG
- en: A panel also exposes other properties such as `Background`, `Children`, `ZIndex`,
    and more. Since a window can contain only one child, a panel is often used to
    divide the space to hold another control or a panel. Picking the right panel is
    important to create the layout. In this chapter, we will learn various recipes
    to design your application layout using various panels.
  prefs: []
  type: TYPE_NORMAL
- en: Building a UI layout using a Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Grid` panel enables you to arrange child elements in tabular format, represented
    by cells in rows and columns. This is the default panel that you will see when
    you create a new WPF project and navigate to the `MainWindow.xaml` file. Visual
    Studio automatically adds this as the first container inside every window.
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful when you want to represent data in a tabular or matrix form.
    It is also useful when creating a form layout.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the `Grid` panel in detail, so that you can
    properly use it while designing your application layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with `Grid` as a layout panel, by creating a new project. Open Visual
    Studio and create a new project named `CH03.GridDemo`, by selecting the WPF application
    template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a sample `Grid` layout to host a few
    rectangles in each cell:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside Solution Explorer, open your `MainWindow.xaml` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a few rows and columns inside the default `Grid` panel, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add six rectangles inside the `Grid`, and place them properly by using the
    `Grid.Row` and `Grid.Column` attached properties. You can refer to the following
    sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application and you will see the following UI on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3dd41a5-1f08-41b6-8c66-9b6afe6ebf4e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Grid` works in cells, by creating the rows and columns. `<Grid.RowDefinitions>`
    and `<Grid.ColumnDefinitions>` define the structure of the `Grid`. It contains
    a collection of rows and columns, respectively. Here we have created two rows
    and three columns (`2x3` matrix) using `RowDefinition` and `ColumnDefinition`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we placed the rectangles inside the `Grid`, we positioned them in cells
    by specifying the row and column number by using the attached properties, `Grid.Row`
    and `Grid.Column`. As the index position starts at `0` (zero), the first rectangle
    placed in the first cell has row index = `0` and column index = `0`. Similarly,
    the sixth/last rectangle has the position `Row=1` and `Column=2`.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the `Height` of a `RowDefinition` and the `Width` of a `ColumnDefinition`
    by specifying an absolute value, a percentage value (star sizing), or an automatic
    sizing. In the preceding example, we used star sizing to define the row and column
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: An absolute value takes an integer to define fixed height/width. Star sizing
    is a relative based factor, that works like percentage value. When you mark the
    height/width as `*`, it takes as much space as possible after filling all other
    fixed and auto sized rows/columns. When you specify `Auto`, it takes as much space
    as required by the contained control.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's more to know about the star sized value. When there are two rows or
    two columns having height/width defined as `*`, they will occupy the available
    space by dividing it proportionally. Thus, in the preceding example, each of the
    two rows occupied 50% of the available space. Similarly, the three columns equally
    occupied a total of 100% of the available space.
  prefs: []
  type: TYPE_NORMAL
- en: You can also define them using `n*`. For example, if a `Grid` contains two rows,
    and among them, one of the rows has a height defined as `2*` and the other as
    `8*`, they will occupy 20% and 80% of the available space. Let's see this with
    a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Grid` inside a window and set its `ShowGridLines` property to `True`,
    so that the grid lines are visible on screen. By default, it is set to `False`.
    Now divide the entire `Grid` into five columns. Consider the following XAML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The width of the second column is set to `Auto`, which means it will take as
    much space as the width of the containing element. When the said column does not
    contain any element inside it, this will have `0` (zero) width. You can specify
    `MinWidth` to provide a minimum value.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth column has a fixed width of `40`. Both the second column and fourth
    column width will be calculated first, as they contain auto width and fixed width,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The other three columns, in the preceding example, will be calculated now based
    on the available space and will be calculated in the ratio of `2:1:3`. The third
    column in the example will take one-sixth of the space. The first and fourth columns
    will take `2x` and `3x` width, based on the width of the third column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run this UI, you will see the following output. Now resize the window
    to see how the resizing happens dynamically based on the given inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0acaa53b-2f8d-4a0b-ba57-999fe4ad9ddd.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a resizable Grid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to create a resizable `Grid` in WPF. You can use the `<GridSplitter/>`
    tag to create a `splitter` control, which can be used by the user to resize a
    specific column. Let''s consider the following XAML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `GridSplitter` control has been placed in the second column.
    When you run the application, you will see a vertical line inside the second column
    that you can drag to resize the grid column, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b73206bc-99f9-42fb-8f4e-b8f6492c52dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Spanning elements across multiple rows and/or columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not mandatory to place an item in a single cell only. You can span it across
    multiple rows and/or columns. The attached property `Grid.RowSpan` allows you
    to span the element across two or more grid row cells. Similarly, `Grid.ColumnSpan`
    allows you to span the element across two or more grid columns. You can use either
    or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, where the rectangle is spanned across
    two rows and two columns, starting at the (`0,0`) cell position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/789cd6df-57ac-4702-9d4d-0524e281899c.png)'
  prefs: []
  type: TYPE_IMG
- en: Placing elements in uniform cells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the `Grid` layout system in Windows Presentation Foundation, the `UniformGrid`
    control also provides the similar layout system, but only with a difference that
    the rows and columns are of same size. It equally divides the layout into cells,
    of the same size, based on the number of rows and columns. Thus, you will not
    have the choice to modify the height and width of the rows and columns explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn about the `UniformGrid` layout with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a sample application to demonstrate the `UniformGrid` control.
    Open your Visual Studio IDE and create a new WPF application project named `CH03.UniformGridDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, open the `MainWindow.xaml` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` panel with the following XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the project and run the application. You will see the following output
    on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d119589-b749-454d-a5ad-efbd4230cbb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now close the application and add a few more `Label` controls in the same `UniformGrid`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application once again and you will see that the row and column count
    automatically changed to accommodate the new elements, as seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29bb33aa-4a75-4b69-8f5b-a2f1eacaaec2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start placing controls inside an `UniformGrid` control, it automatically
    calculates the number of cells required to accommodate placing of the added controls.
    Based on that, it divides the available space into rows and columns to position
    the child elements sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a need to place more controls, it again breaks the space into
    an additional number of equal rows and columns, as shown in the second example.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many properties that `UniformGrid` provides us with, to customize
    the UI. We are now going to discuss some of the most important properties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the row and column count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UniformGrid` does not have any restriction on setting the number of rows and
    columns. You can set the numbers by assigning the `Rows` and `Columns` properties.
    For example, the following XAML will render the elements in a single row only,
    as we assigned `Rows="1"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9498e7-e1db-4c1a-b1e9-3d4f0c6951f5.png)'
  prefs: []
  type: TYPE_IMG
- en: If you set `Columns="2"`, all the elements will reposition themselves into two
    columns, but in multiple rows. You can also combine both the properties.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the first cell of the UniformGrid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a default nature of the `UniformGrid` panel to place the first element
    at the first cell (Row=`0`, Column=`0`), but it also offers to set the cell position
    explicitly. The first cell location must be in the first row, starting the index
    at `0` (zero).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how you can set the first element position
    by assigning the `FirstColumn` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding example, you will see the following output on the
    screen, where the Cell 1 label is positioned at the third column (index position
    is `2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98108e82-9c82-4133-a5da-f7505e833213.png)'
  prefs: []
  type: TYPE_IMG
- en: Filling elements from right to left
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default behavior of filling elements in `UniformGrid` is *left to right*.
    But you can fill them in *right to left* fashion. To do this, set the `FlowDirection`
    property to `RightToLeft` (the default is `LeftToRight`), as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, you will see a UI similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f95a1b11-7f8c-43b3-9139-538464936562.png)'
  prefs: []
  type: TYPE_IMG
- en: Automatically repositioning controls using WrapPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WrapPanel` in WPF is similar to `StackPanel`, but it does not stack the items
    in a single line; rather it wraps the items to a new line based on the available
    space. It also looks like a `UniformGrid` control, but it has odd cell size depending
    on the item dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover more about `WrapPanel` and how to reposition controls
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open Visual Studio IDE and create a new project named `CH03.WrapPanelDemo`.
    Make sure to select the WPF app template while creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example to add a few buttons in `WrapPanel`. Perform
    the following steps to design the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Visual Studio Solution Explorer, open the `MainWindow.xaml` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the existing `Grid` panel with a `WrapPanel` control and set its `Orientation`
    property to `Horizontal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a few button controls of diverse sizes. The entire XAML inside the window
    will look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build the project and run the application. You will see the following output
    on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ca7843f-6fdd-4bb3-a0b0-4db1d7612e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Resize the application UI to see how the buttons are placed within the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WrapPanel` works by stacking child elements in a line. Once the line is full
    and can''t hold to add more elements, it wraps there, and adds the new element
    in the next line and continues. Unlike `UniformGrid`, the `WrapPanel` does not
    have any fixed width for columns. So, items can be placed based on the available
    space.'
  prefs: []
  type: TYPE_NORMAL
- en: The button controls, which we added as child elements of the `WrapPanel`, get
    added in stack in the first row. When it's unable to accommodate within the same
    line, it wraps to the next line to give room for the next elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `Orientation` property of the `WrapPanel` decides whether you want to stack
    them horizontally or vertically.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we have seen that the items inside the `WrapPanel`
    have their individual size mentioned along with them. You can also set the size
    for all the items to a specific value by setting the `ItemWidth` and `ItemHeight`
    properties, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you won''t need to specify the size individually to each child
    element. When you run the preceding code, you will see the output similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1efc6d5-a819-41ac-a7c4-d492fdf6949d.png)'
  prefs: []
  type: TYPE_IMG
- en: Placing controls in a Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another simple and useful layout panel in WPF is a `StackPanel`. It works almost
    like a `WrapPanel`, but with a difference that it can't wrap the child elements
    to a new line. All items added inside it either get placed in horizontal or vertical
    stacks.
  prefs: []
  type: TYPE_NORMAL
- en: The `StackPanel` measures its children using either native or relative sizing,
    keeping the arrangement pass simple by laying out the items in order.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `Grid` uses complex combinations of child elements when proportional
    sizing or auto sizing is used. Thus, it makes the `Grid` layout have a slow to
    medium performance for the measure pass and the arrangement pass to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, wherever possible, the `StackPanel` preferable to over the `Grid`
    panel to reduce the rendering overhead.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how the `StackPanel` works, by using a very simple
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, let's open Visual Studio and create a new WPF application project
    named `CH03.StackPanelDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside Solution Explorer, navigate to the project and perform the following
    steps to create the sample UI with `StackPanel` containing a few button controls:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Window` tag, replace the default `Grid` with the following XAML
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build and run the application. You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae4d9d3d-f585-448a-bf85-810c5200049e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first `StackPanel` is used to hold the multiple inner `StackPanel`, stacked
    vertically by default. The first inner `StackPanel` control holds Button 1 - Button
    4\. These will be stacked horizontally, as we set the `Orientation` property of
    the panel to `Horizontal`.
  prefs: []
  type: TYPE_NORMAL
- en: The second inner `StackPanel` holds Button 5 - Button 8, stacked vertically,
    as we set the `Orientation` property to `Vertical`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `WrapPanel`, where the default orientation is `Horizontal`, `StackPanel`
    has its default orientation set to `Vertical`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StackPanel` stretches its child elements by default, but you can take control
    of how it will stretch. On a vertically oriented `StackPanel`, you can assign
    the `HorizontalAlignment` property of the child elements to `Left`, `Center`,
    `Right`, or `Stretch`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code example will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb5e1fbf-9f38-42c3-bae7-9874149398c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, you can assign the `VerticalAlignment` property of the child elements,
    placed in a horizontally oriented `StackPanel`. This property contains the following
    values—`Top`, `Center`, `Bottom`, and `Stretch`.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning controls inside a Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Canvas` is another simple panel in WPF, which allows you to place child
    elements at a specific coordinate position relative to the `Canvas`. It exposes
    four attached properties: `Left`, `Right`, `Top`, and `Bottom`, to handle the
    positioning of controls.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help you to understand the positioning of child elements in
    a `Canvas` panel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open the Visual Studio instance and create a new WPF application project
    named `CH03.CanvasDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a simple `Canvas` panel with a few label
    controls in it and position them to specific coordinate positions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Solution Explorer and navigate to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` file and replace the default `Grid` with the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application. It will show the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d46eeb27-e86e-4134-88a3-63e280ab2e8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now resize the window and observe the positioning of the labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Canvas.Left` property allows you to assign a value indicating the distance
    of the child element from the left edge of the `Canvas`. The `Canvas.Top` property
    allows you to assign a value indicating the distance of the child element from
    the top.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `Canvas.Right` and `Canvas.Bottom` properties allow you to assign
    the relative position from right and bottom, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding example, the first label is placed at the coordinate
    position (`70, 40`), whereas the second element is placed at the coordinate position
    (`220, 90`). If you resize the window, the position of the child elements will
    not change.
  prefs: []
  type: TYPE_NORMAL
- en: Points to note are that the vertical and horizontal alignments on child elements
    do not work. Also, if you set the `Left` property, the `Right` property does not
    work. Similarly, if you set the `Top` property, the `Bottom` property does not
    work.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Z*-order of a control, placed in a `Canvas` panel, determines whether the
    control is in front of or behind another overlapping control. You can use the
    `Canvas.ZIndex` property to play with the positioning of the *Z*-order.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `ZIndex` of the first element starts with `0` (zero) and gradually
    increases by `1` whenever you add a new element on the canvas. But in special
    cases, when you want to bring an overlapped control to the top, set its `ZIndex`
    higher than the `ZIndex` of the last element that is overlapping it.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping UI elements using a Border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Border` control in WPF is used as a `Decorator`, which you can use to draw
    a border around another control. As the WPF panels do not support adding a border
    around its edges, the `Border` control is used to achieve the same.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will guide you to add a border to a control. You can also use the
    same concept to decorate a group of controls placed inside a panel, by wrapping
    the panel with a `Border`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with an example, let's first create a new project. Open Visual Studio
    and create a WPF application project named `CH03.BorderDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following simple steps to add a border around `TextBlock`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file of your WPF project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now replace the default `Grid` with a `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a few TextBlocks inside it, wrapped by a Border. Here''s the complete XAML
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application. You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca3cfdbe-b597-41ef-a460-3e298795d48f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BorderThickness` property accepts an integer value to draw a border around
    the control. The property `BorderBrush` adds a color to it. You can use `SolidColorBrush`,
    `GradientColorBrush`, or any other brush type. The first `Border` control adds
    a thin `2px` border around the text.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the `CornerRadius` property has been set to `20` to add
    a 20-degree curve around the corners of the `Border` control.
  prefs: []
  type: TYPE_NORMAL
- en: The third example has a border with a background brush to wrap the `TextBlock`
    control. You can club both the `BorderThickness`, `BorderBrush`, and `Background`
    properties together to give such a look. Notice the small corner radius of `5`
    degrees!
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth example, we have provided a border to two sides of the text. The
    value of `BorderThickness` can have `1`, `2`, or `4` double values. The four doubles
    (`BorderThickness="5, 3, 5, 4"` or `BorderThickness="5 3 5 4"`) describes the
    `Left`, `Top`, `Right`, and `Bottom` sides in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: When you provide two double values (`BorderThickness="5, 3"` or `BorderThickness="5
    3"`), the first value describes `Left` and `Right`; the second value describes
    `Top` and `Bottom`, respectively. To provide thickness of the same amount in all
    the sides, assign only one double to the property (`BorderThickness="5"`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scrollable panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ScrollViewer` controls enable scrolling functionality in a WPF application
    and help you to host other controls. When there are more contents available to
    show, but the viewable area is smaller than that, `ScrollViewer` is used to help
    the user to scroll through the content.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a `ScrollViewer` inside a WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open Visual Studio and create a project named `CH03.ScrollViewerDemo`.
    Be sure to create the project based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s a quick step to surround a panel or control using the `ScrollViewer`.
    Perform the following steps to add a scrolling functionality to an `image` control:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the project, add an image named `demoImage.jpg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file from Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now replace the existing `Grid` with a `ScrollViewer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an image pointing to the `demoImage.jpg` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and you will see the following window with an image inside
    a `ScrollViewer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76ee6fd0-f232-488f-8bc9-a263dfb40e82.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the scroll bars to scroll left-right and/or up-down to see the entire image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ScrollViewer` exposes two major properties—`HorizontalScrollBarVisibility`
    and `VerticalScrollBarVisibility`. Both represent an enumeration named `ScrollBarVisibility`,
    having four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visible**: When the property is set to `ScrollBarVisibility.Visible`, the
    scroll bar will be visible all the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hidden**: When the property is set to `ScrollBarVisibility.Hidden`, the scrollbar
    will not be visible on screen and the user will not be able to scroll to see the
    complete content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: When it is set to `ScrollBarVisibility.Disabled`, the scrollbars
    will be disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto**: This is often used to make the scrolling thumbs visible only when
    they are needed. For this, set the property to `ScrollBarVisibility.Auto`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docking controls using the DockPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DockPanel` makes it easier to dock UI elements in the left, right, top, or
    bottom of the screen. This is often useful, mainly when you want to divide the
    window into specific areas. For example, a status bar is always kept at the bottom
    of the window, whereas a menu or a toolbar resides at the topmost position of
    the window.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help you to learn how to dock child elements in an application
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with a new project. Open Visual Studio and create a project named
    `CH03.DockPanelDemo`, based on the available WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to add a `DockPanel` with a few labels docked into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, navigate to the project and open `MainWindow.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the existing `Grid` panel with a `DockPanel` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add five labels inside it and dock them in various sides of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the complete XAML code for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application. You will see that the labels are positioned in
    different sides of the window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48aef2dc-b808-4a7c-b163-6952a4cf25f7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DockPanel.Dock` property determines the position of the element, based
    on the relative order. The property is of type `Dock` enumeration and it accepts
    the following values—`Dock.Left`, `Dock.Right`, `Dock.Top`, and `Dock.Bottom`.
    If you don't specify the property, by default, the first element will be docked
    to the left and the other elements will take the remaining space.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the labels are added inside the `DockPanel` in the
    following order, having the `DockPanel.Dock` property set to `Right`, `Top`, `Bottom`,
    and `Left`, respectively. The last label does not specify any `Dock` property
    and hence it takes the remaining space to accommodate itself inside it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a `DockPanel`, ordering of dock matters most. If you change the order of
    the example that we have created previously, you will notice how the `DockPanel`
    changes the position of the added labels.
  prefs: []
  type: TYPE_NORMAL
- en: Rescaling UI elements using a ViewBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are building an application, you don't know the screen resolution of
    the system where the application will be running. If you design the UI considering
    small or standard resolution in mind, the UI controls will look very small in
    a high-resolution monitor. If you do the reverse, with big screens in mind, the
    user won't see the parts of the screen, if executed on a low-resolution monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, there is a need to create an auto-scaling mechanism, which will take
    care of different screen resolutions. `ViewBox` is a very popular control in WPF,
    which helps you to scale the content to fit the available space based on the size.
    When you resize the parent, it automatically transforms the content to scale in
    proportion.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how it works, with a simple example, in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE and create a new WPF application project named `CH03.ViewBoxDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file from Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a smaller size of the `Window`. Let's set its height to `120` and width
    to `400`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the existing `Grid` panel with a `ViewBox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add text inside it, using the `TextBlock` control as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application. You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/305ea6a9-d82d-4433-98c9-38a4b91de736.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now resize the window and you will see that the text is automatically scaled
    based on the size of the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/885a9906-7323-411e-9373-76f0a27d5dbc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ViewBox` provides you with a way to adjust the content of a window automatically,
    based on the resolution of the screen. When you resize the `ViewBox`, it automatically
    adjusts the size and the relative position of the contents to fit on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the size of the window is set to `400x120`. The window
    has a `TextBlock` control with a text string, wrapped in a `ViewBox`. When you
    resize the window, the content also resizes by applying scale transform.
  prefs: []
  type: TYPE_NORMAL
- en: But if the aspect ratio of the `ViewBox` window does not fit in proportion,
    you will see a white space either at the left and right or top and bottom of the
    content.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ViewBox` control provides two properties to stretch the content. Those
    are `Stretch` and `StretchDirection`. When you don't specify the `Stretch` property
    to a `ViewBox`, it uses the default value for `Stretch`, which is `Uniform`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `Stretch` property is set to `Uniform`, and the `ViewBox` does not
    match the aspect ratio of the content, it adds a white margin to it. It can be
    either at the top and bottom or at the left and right sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When it is set to `Fill`, it causes the content to completely fill the space
    without obeying the aspect ratio. Thus, you may see a distortion in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you set the `Stretch` property to `UniformToFill`, it maintains the original
    aspect ratio and fills the window completely. You will not see any distortion
    in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t want to resize the content, set the `Stretch` property to `None`.
    When you set it as `None`, and resize the window to enlarge, the content will
    not scale and will remain in its original state surrounded by white space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `StretchDirection` property of the `ViewBox` is used to tell the `ViewBox`
    to stretch the content based on the `Stretch` property. When the `Stretch` property
    is set to `None`, the `StretchDirection` property has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: When `StretchDirection` is set to `UpOnly` or `DownOnly`, the content will be
    resized upward or downward, based on the `ViewBox` size. When it is set to `Both`,
    the content will be resized in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tabbed layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To accommodate more content in a window layout, tabbed user interfaces are mostly
    used. They allow users to open multiple pages in a single window. For example,
    most of the recent internet browsers use tabbed interface to let the user open
    multiple web pages simultaneously in a single window.
  prefs: []
  type: TYPE_NORMAL
- en: WPF provides `TabControl` to create the tabbed layout. In this recipe, we will
    learn the basics of tab interfaces, with a simple example to let you understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, make sure that you have opened Visual Studio IDE. Now create
    a new project named `CH03.TabControlDemo`, based on the available WPF application
    project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the UI interface to host a very basic tab control with a few
    tab items inside it. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer window, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the default `Grid` panel, add the `TabControl` with two `TabItem` controls
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now run this application and you will see the following UI, which contains two
    tabs inside it:![](img/d186bf82-0091-458c-a8c8-98f2b96f7640.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close the application and return to the XAML editor to add another `TabItem`
    inside the `TabControl`. Let''s change the template of the header to contain UI
    elements other than the plain text. Copy the following XAML after the second tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application once again and navigate to the third tab. You will see
    the following UI in the screen:![](img/43db2427-acaf-4df5-92fc-5a7ac4af14ea.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TabControl` derives from `Selector` to provide you an `ItemsControl` to
    host elements inside it. You can host only `TabItem` controls, which are actually
    `HeaderedContentControl` to provide a `Header` to each of the items.
  prefs: []
  type: TYPE_NORMAL
- en: The `Header` property is of type object, which will allow you to put any content
    inside it, be it a plain text or a different UI element.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the first two `TabItem` controls contain plain text
    as headers, whereas the third `TabItem` contains many different `UIElement` to
    give its header a customized look. When you switch from one tab to another, you
    will see its associated content, which you can programmatically access through
    its `Content` property.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically adding/removing elements in a panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to add static elements/contents in a `Panel` control.
    But it's not always useful, mainly when you are retrieving data from the backend
    and populating in the UI or dynamically based on the user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will discuss this topic. As all the panels perform similarly to
    add/remove elements, with a slight difference on the positioning, we will be demonstrating
    it with a simple `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with the coding, let's create a WPF application project first. Open
    Visual Studio and create a new project named `CH03.DynamicPanelDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a `Canvas` panel inside the window, and dynamically add squares
    at the current cursor position when the user clicks the `Canvas` panel. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page and replace the default `Grid` panel with a
    `Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it a name. In our example, let's give the name as `canvasPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set a background to the canvas panel and register a `MouseLeftButtonDown` event
    to it. Here''s the complete XAML code, for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now open its associated code-behind file `MainWindow.xaml.cs` and implement
    the event. Alternatively, you can place the cursor on top of the event name and
    press *F12* to generate the event and navigate to it directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `OnMouseLeftButtonDown` event implementation, retrieve the current
    cursor position and place the element at the same position on the canvas, where
    the user clicked. Here''s the code implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application. You will see a blank window with the same background
    color that we have set on the `Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Randomly click on the `Canvas` area and you will see the squares popping up
    on the screen, at the same place where you are left-clicking on the `Canvas`.
    The UI will look as follows:![](img/2e7e78d9-50c9-4c44-a724-31a49809c12f.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To remove the elements from the square, let''s register a `MouseRightButtonDown`
    event in the `Canvas` panel present in the XAML. Close the running application
    and replace the entire content of the `MainWindow.xaml` page with the following
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now navigate to the `MainWindow.xaml.cs` file to add the associated event implementation.
    Add the following snippet inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Run the application once again and randomly click inside the `Canvas` to add
    the squares inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the squares are in place, right-click on them to see the clicked ones disappear
    from the panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every panel exposes a property named `Children` to hold a collection of `UIElement`
    as `UIElementCollection`. To dynamically add an element to `UIElementCollection`,
    use its `Add` method; and to remove an element, pass the element to its `Remove`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when the user left-clicks on the `Canvas`, the `e.GetPosition`
    method provides the coordinate position (`X`, `Y`) of the click, relative to the
    panel where it was clicked. The `Canvas.SetLeft` and `Canvas.SetTop` methods are
    used to position the created element relative to the panel and then are added
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, to delete the element from the panel, the `e.Source` property is
    used to retrieve the element where the user right-clicked. If it is not `null`,
    remove it from the `Canvas` by calling the `Remove` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The coordinate positions are used to place elements in a `Canvas` panel. When
    you want to place an item in a `Grid`, set the `Row` and `Column` while placing
    it. For `StackPanel`, `WrapPanel`, and `UniformGrid` panels, you won't need to
    specify any other property as those will be stacked automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to dynamically add an element in a `Grid`,
    at a specific cell position, specified by the `Row` and `Column` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to span the element to multiple rows and multiple columns, you
    can do so by calling the `Grid.SetRowSpan` and `Grid.SetColumnSpan` methods, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the drag and drop feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to provide a rich experience to the user, you may want to use
    the dragging and dropping feature. You may also want to add a drag and drop feature
    in your application to access a local resource to upload it to the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn the basics of drag and drop implementation in
    WPF by using a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new WPF application named `CH03.DragAndDropDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a few elements inside a window
    and provide the option to drag and drop from one panel to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open `MainWindow.xaml` and replace the existing `Grid` with a `StackPanel`.
    Set its `Orientation` property to `Horizontal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two `WrapPanel` inside it and set their `Width`, `Margin`, `ItemHeight`,
    and `ItemWidth` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a name to both panels. Let's name the first wrap panel `sourcePanel` and
    the second wrap panel `targetPanel`. We will be using these name later from the
    code, while accessing them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a few labels to the first wrap panel. Set their `Content`, `Background`,
    and other text formatting properties. Here''s the complete markup code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you run this application, you will see two panels on the screen. As shown
    in the following screenshot, one of them will have five labels (Item 1 - Item
    5) and the other will be empty:![](img/ea19316b-0c08-4765-8c26-05fc2d86e577.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you now drag any element from the left panel and try to drop it to the right
    panel, you will see that it won't work. We have not yet added the drag and drop
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the dragging support to the first wrap panel (`sourcePanel`), register
    its `MouseLeftButtonDown` event property in the XAML as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An `OnDrag` event, registered in XAML, needs to be implemented in the code
    behind the file. Open `MainWindow.xaml.cs` and add the following event implementation,
    which will add the dragging support to the `sourcePanel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to enable the second wrap panel (`targetPanel`) as a droppable target
    and set its `AllowDrop` property to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also register its `Drop` event property, so that we can perform the `drop`
    operation. Here''s the entire mark-up for the second panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to implement the body of the `OnDrop` event to perform the desired
    `drop` operation. Navigate to `MainWindow.xaml.cs` once again and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application now. The same screen will appear with two panels.
    The first panel (left) will have a few elements in it. Position your cursor on
    one of them, click it to drag it to the other panel (right), and release it there.
    You will see that the item will be removed from the first and added to the right
    panel, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f443bef-960e-452f-8cac-74c8cbce75c0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AllowDrop="True"` property prepares the panel as drop enabled. When you
    start a drag by clicking on the element, the `DragDrop.DoDragDrop` method written
    in the `OnDrag` event initiates the drag and drop operation. It takes the first
    parameter as a reference to the dependency object, that is, the source of the
    data being dragged. The second parameter is the data object that contains the
    data being dragged. And the last parameter is a value that specifies the final
    effect (`DragDropEffects`) of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when the element is dropped to the drop target, the
    dragged data retrieved from the `DragEventArgs` parameter value is first removed
    from the source and then added to the drop target.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on your drag-and-drop requirement, you can change the effects by specifying
    the proper enum value of the `DragDropEffects`. The effects can be of six types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: When specified, the drop target will not accept any data and the
    cursor will change to an unavailable icon:![](img/5f7bfa5a-264d-49f6-b391-8298c304bfd9.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy**: When specified, the data is copied to the drop target and during
    the `drop` operation on the target, the cursor will look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/30eaf1fe-8751-4564-9f16-88719032c8de.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Move**: When specified, the data from the source is moved to the drop target.
    During the `drop` operation, the cursor will change to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/51a204dc-58fa-4089-a752-ea568d19e36a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Link**: When specified, the data from the source is linked to the drop target.
    During the `drop` operation on the target, the cursor will change to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/087a2a06-f58f-4c4a-9922-45f4e19b25d2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Scroll**: When specified, it defines whether the scrolling is about to start
    or currently happening on the drop target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All**: When specified, the data is copied and scrolled to the drop target
    after being removed from the source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
