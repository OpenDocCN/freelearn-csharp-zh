- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring Code Flow and Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While other chapters in *Part 1* focus on refactorings that can be applied to
    entire methods or classes, this chapter focuses on improving the readability and
    efficiency of individual lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Developers spend the majority of their time reading over individual lines of
    code and only a fraction of that time modifying code. So, it is important to make
    our lines of code as maintainable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the following topics related to improving small
    pieces of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling program flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring LINQ statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing and testing our refactored code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter03/Ch3BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the boarding app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter’s code focuses on a pair of applications for Cloudy Skies Airline:'
  prefs: []
  type: TYPE_NORMAL
- en: A *Boarding Status Display* app that tells the user if it’s time for them to
    board their flight based on the current boarding group and the person’s ticket,
    military status, and whether or not they need assistance getting down the jetway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *Boarding Kiosk* app that allows airline employees to view the passengers
    scheduled to be on the flight and provides information regarding whether each
    passenger has boarded. *Figure 3**.1* shows the application in action:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The Boarding Kiosk app](img/B21324_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The Boarding Kiosk app
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re exploring not one but two applications, we’ll meet the application
    code in small chunks as we progress through this chapter. However, feel free to
    peruse it yourself on GitHub if you’d like to orient yourself first.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter, we’ll take its existing functioning code and
    see how small refactoring steps can improve the maintainability of the code using
    various C# language features.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at how refactoring can improve the overall flow of code.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling program flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic things new developers learn is how programs execute lines
    of code in sequence and how **if statements** and other language features control
    what statements execute next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll focus on the `BoardingProcessor` class''s `CanPassengerBoard`
    method. The method starts simple enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CanPassengerBoard` takes in a `Passenger` object and returns a string.
    The method also declares a few local variables holding pieces of data from the
    object passed in.
  prefs: []
  type: TYPE_NORMAL
- en: These variables aren’t necessary and could be removed by performing an inline
    variable refactoring, which we’ll talk about later in this chapter. However, as
    they improve the readability of the code that follows, their existence is largely
    helpful. This is part of the reason why we sometimes introduce local variables,
    as we covered in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026).
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic that follows gets significantly harder to read, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This method primarily uses `if`/`else` statements with a few scattered variable
    declarations and periodic return statements. These are fundamental structures
    of computer programming, and yet it takes a moment to understand what this code
    truly does.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those not wanting to sort through the logic, this code follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the plane has departed, return `"``Flight Departed"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the plane is not yet boarding, return `"Boarding` `Not Started"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the plane is boarding and the passenger needs help or is active military,
    return `"Board Now via` `Priority Lane"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the plane is boarding and the passenger’s group is not boarding yet, return
    `"``Please Wait"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the passenger’s group can board, tell them to board either by the normal
    lane or via the priority lane if their boarding group is one of the priority groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the code is complex enough that puzzling out these rules can take a
    bit of time, and the complexity results in uncertainty, making it difficult for
    others to understand the rules in their entirety.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these rules is important if you’re going to maintain the code.
    So, improving the readability of this code is important to the code’s long-term
    success.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the quickest tricks to simplifying complex logic involving nested `if`
    statements can be to invert the `if` statement and return early.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our high-level logic looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By the time we get back to the `else` statement associated with the plane departed
    check, the reader has forgotten what the original `if` statement was to begin
    with!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, since the `else` branch is so simple and easy to understand, it’s helpful
    to invert the `if` statement by taking the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Swap the contents of the `if` block and the `else` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invert the boolean expression in the `if` statement. When inverting `==`, it
    becomes `!=` and vice versa. In cases where we do a `>` or `<` check, you flip
    the operand and toggle whether equality is included. Under these rules, `>=` becomes
    `<` and `>=` becomes `>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, we check that `Status != BoardingStatus.PlaneDeparted`. In this
    case, we’d change `!=` to `==` and wind up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These steps preserve the program’s existing behavior but change the order of
    the statements in the code. This can increase the readability of our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this sounds complicated, don’t worry, because Visual Studio has a **Quick
    Action** refactoring for it called **Invert if**, as shown in *Figure 3**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The Invert if Quick Action refactoring](img/B21324_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Invert if Quick Action refactoring
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing the refactoring here effectively changes our logic to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While this is easier to read since the reader no longer must remember what the
    `if` statement even pertains to 17 lines later, the code can be improved further.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping else statements after return statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the `return` statement always leaves the method immediately, you never
    explicitly *need* an `else` statement after a `return` statement because you know
    that if you get to the `return` statement, logic after the `if` block won’t execute.
  prefs: []
  type: TYPE_NORMAL
- en: This lets us remove the `else` keyword and its curly braces. Then, we can outdent
    the code that was previously in the `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting code keeps the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After this statement, the code that follows is now at the same indentation
    level as the original `if` statement and is easier to read and understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can repeat this refactoring a few more times if we want to since the code
    has a few more `if`/`return`/`else` sequences.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave those for the moment since there’s another refactoring I want to
    show you that can help with what we’re seeing here.
  prefs: []
  type: TYPE_NORMAL
- en: Restructuring if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking at the previous code, some of the logic stands out as repetitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an `if`/`else` chain where three different things are checking
    whether the flight is currently boarding. Although each of these three `if` statements
    is different, there’s enough overlap between them that it makes me question if
    we could be less repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option we could consider might be a simple *introduce local variable*
    refactoring, as we saw in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I find this code easier to read, even though we gained an extra line from the
    new local variable. However, let’s take a slightly different approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of introducing a variable, we can rearrange our if statements to have
    an additional layer of nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, pulling a common condition from a set of `if` statements into an outer
    `if` statement helped clarify those `if` statements, although it did so at the
    expense of an additional degree of nesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this simplification helps spot a few other refactoring opportunities,
    such as combining the `isMilitary` and `needsHelp` checks since they return the
    same value if either is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also drop the `else` statement after the `if`/`return` code to outdent
    our code a bit more, leaving just the boarding group logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like another place where we can invert `if` and drop the `else`
    statement to simplify the code even more. Remember that we must change `>=` to
    `<` to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is getting significantly easier to read as we simplify
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a step back and look at our conditional logic after these refactorings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code is now easier to read and harder to misinterpret. We could invert the
    Boarding status check to return early, but we'll do something else with here later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how we can reduce our line count even further through a more
    divisive language feature: the **ternary operator**.'
  prefs: []
  type: TYPE_NORMAL
- en: Using ternary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re a fan of the ternary operator, you may have noticed an opportunity
    to use one in the code as we’ve been refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: For those not familiar or not fully comfortable with the ternary conditional
    operator, think of it as a condensed *if my condition is true use this value,
    otherwise use this other value* type of an operator.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for ternary is `boolExpression ? trueValue :` `falseValue;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, you could write code without a ternary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the same code could be written using a ternary in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the ternary operator lets us take six lines of code and condense
    it down to a single line. This conciseness is a key factor for those who like
    using ternaries in their code.
  prefs: []
  type: TYPE_NORMAL
- en: Those who are less fond of ternary operators often point out that ternaries
    are difficult to read – particularly when trying to read through code quickly.
    In other words, while they make code more concise, this conciseness can slow you
    down in the long run by making the code less easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a small part of our code and see how a ternary could be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are checking if the current boarding group is a priority group and
    then telling the user to board with the priority lane or to board normally based
    on the result of the `Contains` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re returning a single value based on the result of a boolean expression,
    we could rewrite the code with a ternary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This chops five lines of code down to three lines of code or a single line of
    code if you want to put the `?` and `:` segments on the same line as the boolean
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that this refactoring now puts the whole block of code
    into a position where you could introduce another ternary based on the boarding
    group, `return "Please Wait"`, if that expression is true, and return the result
    of the earlier ternary expression if the expression is false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While this is valid C#, I can attest that if a coworker showed this to me in
    code review, I would be tempted to utter some not-very-nice words!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: fewer lines of code don’t always equate to greater maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: At a personal level, my preference is to avoid the ternary in many places and
    always avoid chaining ternaries together. However, I do sometimes use ternaries
    when I feel it is right for a piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, sometimes, a method is very simple and can be condensed to a single
    line of code if you use a ternary expression. This particular change lets you
    use the expression-bodied members feature, which we’ll talk about in [*Chapter
    4*](B21324_04.xhtml#_idTextAnchor072).
  prefs: []
  type: TYPE_NORMAL
- en: 'When I use a ternary, I format my ternary expressions on three separate lines,
    as shown earlier, with the first line containing the boolean expression. The second
    line will feature the `?` operator and the value to use if the expression was
    true, and the third line will feature the `:` operator and the value to use if
    the expression was false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I find that this approach strikes a happy medium between the benefits of more
    concise code from the ternary and the penalties of code becoming more difficult
    to read quickly and accurately when using a ternary.
  prefs: []
  type: TYPE_NORMAL
- en: Converting if statements into switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic of this method is now a lot easier to understand, and simplifying
    it down to this level highlights that we’re doing one of three things, depending
    on the current boarding status:'
  prefs: []
  type: TYPE_NORMAL
- en: Notifying the user the flight has departed if its status is `PlaneDeparted`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking military status, whether help boarding is needed, and the boarding
    group for `Boarding` status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying the user that boarding hasn’t started yet for other statuses (`NotStarted`
    is the only other status at the moment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with enumerated values, this kind of branching logic is common.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, our `enum` value only has three states:'
  prefs: []
  type: TYPE_NORMAL
- en: BoardingStatus.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In cases where you find yourself checking the same variable for different values,
    you can usually rewrite them to use a **switch** **statement** instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` statements are essentially a streamlined series of `if`/`else` `if`/`else`
    types of checks that all check the same value, as our code does with `Status`.
    We’ll see an example of a `switch` statement shortly, but if you’re not familiar
    with them, you can think of them as just a different way of writing a series of
    related `if`/`else` `if` statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done manually, or you can use a specific refactoring built into
    Visual Studio if your code is built in an `if`/`else` `if`/`else` type of structure,
    as the following code illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note here that I did add the `else` keyword (in bold in the previous snippet)
    to our earlier code to get into that `if`/`else` `if`/`else` structure, which
    lets Visual Studio identify the refactoring we’re about to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the code in this pattern, the `if` statement selected, as shown
    in *Figure 3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Convert to “switch” statement refactoring option](img/B21324_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Convert to “switch” statement refactoring option
  prefs: []
  type: TYPE_NORMAL
- en: 'This refactoring makes our status-based logic much more apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As someone reading this code, I find this a lot easier to scan and interpret
    compared to an `if`/`else if`/`else` chain, even though the logic functions identically.
    With an `if`/`else` `if`/`else` statement, I *may* notice that logic is comparing
    the same value several different times, while a `switch` statement makes it explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit you get with a `switch` statement is that it unlocks a built-in
    refactoring option when your switch compares an `enum` value (such as `BoardingStatus`)
    and you’re missing a case for one or more `enum` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This option shows up in the **Quick Actions** menu for the switch statement
    as **Add missing cases**, as shown in *Figure 3**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The Add missing cases refactoring option in the Quick Actions
    menu](img/B21324_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The Add missing cases refactoring option in the Quick Actions menu
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: I want to point out that the `NotStarted` status and has it break out of the
    switch instead of returning a value as it previously would have through the `default`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The C# compiler will flag this mistake for us in this case since the method
    won’t return a value for this path, but adding missing cases when a `default`
    case is present in a `switch` statement typically does introduce a change in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we can merge the `NotStarted` status with the default case and
    get a more explicit list of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code is now significantly easier to read than it was before, and the flow
    of logic by status is now readily apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real-world application, I might change the default case to throw an exception,
    explicitly telling me that a specific `Status` was not supported by this logic.
    This would look something like the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: I might also be tempted to perform *extract method* refactoring – as we saw
    in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026) – to move the logic for handling
    the boarding status into its own method. However, I’ll hold off on doing that
    to showcase switch expressions instead.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to switch expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Switch expressions** are an evolution of switch statements that rely on **pattern-matching**
    expressions to simplify and expand what’s possible inside switch statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` expressions are a relatively new feature in C# that was released as
    part of C# 8 in 2019\. While that’s more than a few years old at the time of writing,
    I still find switch expressions to be new enough that many C# developers are unfamiliar
    or unpracticed with them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `switch` expression looks a lot like a switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These `switch` expressions look very similar to switch statements except for
    the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: They start with the value you want to evaluate followed by the `switch` keyword
    instead of starting with `switch (value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t use the `case` or `break` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual cases have some condition that might be true on the left, an arrow
    notation (`=>`), and then the value to use on the right if the condition on the
    left is true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of the `default` keyword, we have `_`, indicating any other match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the nice things about `switch` expressions is that they’re extremely
    concise while still being somewhat readable. However, there’s more power to `switch`
    expressions than what I’ve shown you so far.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the sample `switch` expression I introduced a moment ago
    doesn’t adequately handle the logic for boarding. Specifically, we had rules for
    active military members, people who need assistance boarding, boarding groups,
    and priority lanes, and none of that is represented in the previous block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a `switch` expression that does handle these things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code is a bit different than the last `switch` expression we saw. Here,
    the `Boarding` status is repeated four times and sometimes accompanied by the
    `when` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: What this code is doing is using pattern matching to check not just that `Status`
    is `Boarding`, but that other conditions are true as well. Effectively, we’re
    able to check the status and optionally another boolean expression after the `when`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If both things are not true, the `switch` expression evaluates the next line
    in sequence. This makes `switch` expressions a set of matching rules that ensure
    the first rule evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching is a newer C# syntax that allows you to concisely check different
    properties and aspects of objects and variables. We’ll explore pattern-matching
    syntax more in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209), *Defensive Coding
    Techniques*, but this section serves as a good introduction to some of its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, this `switch` expression checks the following rules and reacts
    to the first one that is true:'
  prefs: []
  type: TYPE_NORMAL
- en: The plane has departed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boarding hasn’t started yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boarding has started and the passenger is active military or needs assistance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The passenger’s boarding group hasn’t been called yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The passenger’s group is boarding and it’s a priority lane group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The passenger’s group is boarding but they’re not in the priority boarding lane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any other status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`switch` expressions are concise and allow you to mix the structured clarity
    of `switch` statements with the power of pattern matching and the `when` keyword
    to make very readable ordered logic apparent.'
  prefs: []
  type: TYPE_NORMAL
- en: As with any tool in your programming toolbelt, `switch` expressions won’t be
    the solution to every problem and you and your team may not be as fond of reading
    `switch` expressions as I am. However, they remain a valuable tool in your toolbox
    for simplifying code while keeping it easy to read, maintain, and expand.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit some of the pattern-matching syntax in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    but let’s move on to looking at what we can do to improve working with collections
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve sufficiently improved our `CanPassengerBoard` method, let’s look
    at how we can create objects and see a few simple improvements you can make that
    will simplify object **instantiation** in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology notes
  prefs: []
  type: TYPE_NORMAL
- en: New developers are often tripped up by a handful of phrases that are commonly
    used by developers. For example, in this section, we will talk about instantiating
    objects. This is a common way of phrasing this for developers, but all it means
    is the process of creating a specific *instance* of a class using the `new` keyword.
    When you see the term instantiating, you can think of it simply as creating a
    specific instance of something.
  prefs: []
  type: TYPE_NORMAL
- en: This section’s code could come from anywhere, but we’ll focus on code found
    in a pair of methods in the `PassengerTests.cs` file in the test project that
    accompanies this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing var with explicit Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first line of code I want to focus on comes from one of our unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: PassengerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I’ve deliberately omitted the context of the code from the surrounding
    lines to reinforce a point, and the point is this: take a moment and try to determine
    what data type the `p` variable is.'
  prefs: []
  type: TYPE_NORMAL
- en: '`p` stores the result of `Build`, which takes in a pair of parameters named
    `first` and `last`, but we can’t make a confident assertion about what type of
    data `p` holds from this line alone.'
  prefs: []
  type: TYPE_NORMAL
- en: This is because `p` was declared with the `var` keyword. The `var` keyword is
    a shorthand way of saying “Hey, compiler, when you’re compiling this code, I want
    you to determine what data type this is going to be and replace the `var` keyword
    in the compiled code with the actual type of the data.”
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `var` is usually a shortcut for not typing out the full name
    of the data type in question. However, it comes with a small penalty in that it
    makes it harder to read what data type the variable contains.
  prefs: []
  type: TYPE_NORMAL
- en: This makes sense for when you have a complex data type such as `IDictionary<Guid,
    HashSet<string>>`, but it can get a little ridiculous for short type names such
    as `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Other uses of var
  prefs: []
  type: TYPE_NORMAL
- en: The `var` keyword does have other uses beyond what I’ve described here. For
    example, it can easily store `var` in most codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio does let you hover over the variable declaration and see the actual
    Type being used. In this case, `p` represents a `Passenger` object, but this still
    slows down your reading of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, I recommend that you take advantage of the built-in **Use explicit
    type instead of ‘var’** refactoring. See *Figure 3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Using explicit types](img/B21324_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Using explicit types
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes your code significantly easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course, `var` exists for a reason and it was introduced to solve certain
    problems, including redundancy in assignment statements. We’ll take a look at
    the **target-typed new** keyword next that offers a different solution to that
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying creation with target-typed new
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the things the `var` keyword was built to help with was lines such as
    the following variable instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we instantiate a new `Passenger` object and assign it to the new passenger
    variable, we repeat ourselves slightly on the left and right-hand sides of the
    assignment operator (`=`) by using the name of the `Passenger` class twice.
  prefs: []
  type: TYPE_NORMAL
- en: The `var` keyword allowed us to simplify the creation of this object down to
    the still readable syntax of `var passenger = new Passenger();`. Here, `var` allows
    us to simplify the left-hand side of this assignment statement by abbreviating
    the type that’s used for the new variable.
  prefs: []
  type: TYPE_NORMAL
- en: C# 9 introduced the **target-typed new** keyword, which lets us simplify the
    right-hand side of the assignment operator by effectively saying that the type
    of class we’re instantiating is the same as the variable that acts as the target
    of the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, target-typed new is a way of telling C# to create the same
    type as the variable we’ll store the value in. This allows us to avoid `var` and
    not repeat ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I love this syntax and tend to use it in all my code. It can cause small bits
    of confusion for other developers the first time they see the feature, but that’s
    a minor one-time penalty for something that keeps your code concise and readable
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio gives you a **Use ‘new(…)’** option in the **Quick Action** menu
    that will let you change a traditional object instantiation to the target-typed
    new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: While we’re talking about creating objects, let’s look at how **object initializers**
    can help set properties on objects as you create them.
  prefs: []
  type: TYPE_NORMAL
- en: Using object initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take another look at that `Build` method from the previous example while
    focusing on configuring the created passenger object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code isn’t bad at all, but it does repeat itself a little.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the code repeats the information of the object it configures each
    line by putting `passenger.` in front of each property before assigning a value
    to that property.
  prefs: []
  type: TYPE_NORMAL
- en: This is very minimal with only two properties. But imagine a larger object with
    10 or more properties you want to configure. This code would get very repetitive
    and might even distract from the names of the properties that are being configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using a constructor that takes in parameters representing property values
    is one solution (and one we’ll explore in the next chapter), another solution
    is to use an **object initializer**. As you’re likely guessing, Visual Studio
    provides a **Quick Actions** refactoring for this, though the name **Object initialization
    can be simplified** (shown in *Figure 3**.6*) is a bit unusual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Simplifying object initialization](img/B21324_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Simplifying object initialization
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this refactoring transforms our code into a sparser format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I love this syntax and it plays very nicely with the `init` and `required`
    properties, which we’ll explore in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    *Defensive Coding Techniques*. However, there is a downside to using object initializers:
    stack traces.'
  prefs: []
  type: TYPE_NORMAL
- en: When you have an object initializer that sets several different properties of
    an object and an exception occurs that calculates the value to store, the exception
    doesn’t indicate which line of code the error occurred on or which property was
    about to be updated, only that it occurred somewhere in the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you were using multiple lines setting individual properties,
    the exception details would identify the line in question. Of course, this might
    be an argument to avoid doing calculations in initializers that might produce
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit initializers more in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)
    when we discuss `init`, `required`, and `with` expressions, but for now, let’s
    move on to talking about collections.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start exploring collections, let’s go back to the `BoardingProcessor` class
    and look at its `DisplayPassengerBoardingStatus` method. We’ll explore this method
    a bit at a time, starting with its method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the method takes in a list of `Passenger` objects and,
    optionally, a nullable boolean `hasBoarded` parameter that can store `true`, `false`,
    or `null`. This `hasBoarded` parameter is used to optionally filter down our list
    of passengers based on its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`: Only include passengers who have boarded the plane'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`: Only include passengers who have not yet boarded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`: Do not filter by boarded status (default option)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This nullable filtering parameter is a common one I see while building search
    methods and we’ll explore it in more depth again in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101),
    *Object-oriented Refactoring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next portion of code in `DisplayBoardingStatus` deals with the filtering
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is the portion of code we’ll be focusing on for the rest of this section.
    It builds a new list of passengers that matches the filtering option the user
    selected by iterating over the passengers in `passengers.` and conditionally adds
    it to our new list of passengers.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology note
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterating** over something is another term that confuses new developers.
    It just means looping through each item in a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the method focuses on displaying passengers to the agent at
    the boarding kiosk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, for every passenger that we want to display, we write out their
    name, boarding group, and the message they see on their boarding app or `"Onboard"`
    if they’ve already boarded the plane.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this method is simple and comes in at less than 20 lines of code long,
    which tends to lead to easy-to-maintain code.
  prefs: []
  type: TYPE_NORMAL
- en: That said, let’s look at a few ways we could improve this code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing foreach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take another look at the code to filter the passenger list into a new list
    of passengers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: While this code isn’t very involved, one of the things that jumps out to me
    is that we’re using a `for` loop to enumerate through the passengers. Inside this
    loop, we’re not doing anything with our index variable, `i`, aside from getting
    a passenger out of the list by its index.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have a `for` loop like this that isn’t doing anything complex (for
    example, starting anywhere but the beginning of the list, looping in reverse,
    or skipping every other item), you can usually replace the loop with a `foreach`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a `for` loop into a `foreach` loop, you can select the `for` loop
    and then use the **Convert to ‘foreach’** refactoring feature that’s built into
    Visual Studio (*Figure 3**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions
    menu](img/B21324_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions
    menu
  prefs: []
  type: TYPE_NORMAL
- en: 'This moves to a `foreach` loop and gets rid of the variable declaration entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I use `foreach` wherever I can because not only does it remove a variable declaration
    and use of the indexer, but it makes the overall code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: '*Almost all* `for` loops start at 0 and loop up to the end of the collection
    one item at a time, but not every `for` loop does this. As a result, whenever
    I read a `for` loop, I need to check if it is a standard `for` loop or if there’s
    something special about it. With a `foreach` loop, I don’t need to do this because
    the syntax doesn’t support it. This increases reading comfort and speed and improves
    the maintainability of your code through simplicity.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a `foreach` loop can be used with anything that implements `IEnumerable`,
    while `for` loops require the collection they loop over to have an indexer. This
    means that `foreach` loops can loop over more types of collections than `for`
    loops can.
  prefs: []
  type: TYPE_NORMAL
- en: Collection interfaces
  prefs: []
  type: TYPE_NORMAL
- en: .NET provides several collection interfaces, including `IEnumerable`, `ICollection`,
    `IList`, `IReadOnlyList`, and `IReadOnlyCollection`. Knowledge of these collection
    types is helpful but not required to read this book. See the *Further reading*
    section at the end of this chapter for a link to more information on these interfaces,
    but for now, know that an `IEnumerable` interface is just a fancy way of referring
    to something that can be looped over in a foreach loop.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `foreach` loops are fantastic and my default loop in most cases, sometimes,
    you want to have a `for` loop for a little bit of added control. If you ever need
    to loop over a collection in a non-standard way or need to use the index variable
    for something other than reading a variable out of the collection, you usually
    will want to use a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio gives us a `foreach` loops into `for` loops for you. See *Figure
    3**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Converting a foreach loop back to a for loop](img/B21324_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Converting a foreach loop back to a for loop
  prefs: []
  type: TYPE_NORMAL
- en: I don’t find myself using this refactoring very much, but it’s handy when you
    need it.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s leave the code in a `foreach` loop and look at how LINQ can help
    us make it better.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that, in *Figure 3**.8*, there were a pair of suggestions
    to convert the `foreach` loop into LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: '`IEnumerable`. This allows you to perform quick aggregation, transformation,
    and filtering operations on that collection using arrow functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions (also called Lambda expressions) use “fat arrow” (`=>`) syntax
    to represent small methods in an abbreviated format. This book assumes a basic
    understanding of arrow functions. See the *Further reading* section of this chapter
    if you need more information or want a refresher on how arrow functions work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at what happens to our `foreach` loop when we use the `foreach`
    loop’s **Quick** **Actions** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Converting a foreach loop to use LINQ](img/B21324_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Converting a foreach loop to use LINQ
  prefs: []
  type: TYPE_NORMAL
- en: 'This refactoring transforms our `foreach` loop into just a tiny portion of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This code takes our `passengers` collection and calls the `Where` extension
    method. The `Where` method will create and return a new `IEnumerable` sequence
    of `passengers` and only includes `passengers` where the arrow function, `p =>
    !hasBoarded.HasValue || p.HasBoarded == hasBoarded`, returns a value of `true`
    for that passenger.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods are static methods defined in static classes that allow you
    to build syntax that looks like it adds new methods to existing types. LINQ relies
    heavily on extension methods attached to various interfaces. We’ll explore creating
    extension methods in [*Chapter 4*](B21324_04.xhtml#_idTextAnchor072).
  prefs: []
  type: TYPE_NORMAL
- en: This won’t modify our original collection, instead creating a new collection
    of `Passenger` objects that are then passed into the `filteredPassengers.AddRange`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: While this code is already very brief, we can improve it further by taking advantage
    of a constructor on the generic `List` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `List<T>` class has a constructor that takes in an `IEnumerable<T>` interface
    and allows you to efficiently create a new list around a sequence of elements.
    This will let us avoid needing the `AddRange` call and helps simplify our code
    down to a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to, we could also get rid of the `filteredPassengers` variable
    entirely by filtering passengers down and reassigning it back into itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we perform the `Where` call to generate an `IEnumerable<Passenger>` interface
    containing our passengers and then call the `ToList` method on that `IEnumerable`
    interface to convert it back into a `List` method so that it can be stored in
    the `passengers` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that any place that was using `filteredPassengers` before will need
    to be updated to use `passengers` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I love LINQ and find it to be invaluable for creating simple and maintainable
    applications, but it does take some getting used to if you’re not familiar with
    LINQ or not used to reading arrow function (`=>`) notation.
  prefs: []
  type: TYPE_NORMAL
- en: That said, I do see some common mistakes in LINQ code. So, let’s look at a few
    of those before we close out this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring LINQ statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section of this chapter, we’ll review a few of the more common
    optimizations with LINQ code by focusing on some common improvements most codebases
    that use LINQ will benefit from.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the correct LINQ method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ has several different ways of finding a specific item in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had an `IEnumerable<Passenger>` interface named `people` and wanted
    to find someone by their name, you might write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: LinqExamples.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the LINQ `FirstOrDefault` method, which searches the collection
    until it finds the first value that the arrow function evaluates as true. In this
    example, it’d find the first person with `FullName` set to `"Matt Eland"`, return
    that value from the `FirstOrDefault` method, and store it in the `Passenger` variable
    named `matt`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if no items returned `true` from the arrow function, `FirstOrDefault`
    will use the default value of the `Passenger` type, which would be null for a
    reference type such as a class.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, the default value of `bool` is `false`, numeric types such as `int`
    and `float` default to `0`, and reference types including `string`, `List`, and
    other classes default to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this `FirstOrDefault` call will find Matt if he exists in passengers
    and return him or return `null` if he doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that the very next line attempts to read the value
    of `matt.BoardingGroup`. This is fine if we found the element, but if we didn’t,
    this code will get a `NullReferenceException` error upon trying to access `BoardingGroup`,
    which is likely not what its author intended.
  prefs: []
  type: TYPE_NORMAL
- en: Note that how we fix this code depends on what our expectations are.
  prefs: []
  type: TYPE_NORMAL
- en: 'With LINQ, when you are looking for an element in a collection, you need to
    decide on two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Am I okay with more than one item matching my arrow function or do I need to
    make sure that *at most* one item returns true?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Am I okay with the item I’m looking for not being present at all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first decision governs whether you are making a call to `First` or `Single`.
    With `First`, the logic will find the first element that matches the query and
    return it. However, with `Single`, the logic will keep going past the first match
    to determine if any other element in the collection matches that expression as
    well. If one does match the expression, an `InvalidOperationException` error is
    thrown, telling you that the sequence contains more than one matching element.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers don’t like seeing exceptions when they’re running their code.
    However, sometimes, you need to know if there’s more than one match to your query.
    In general, it’s better to fail early than fail later in a more confusing spot
    that hides where the program first got off track.
  prefs: []
  type: TYPE_NORMAL
- en: The second decision you make when finding an element in a collection involves
    being okay with objects not being present that match the query. If that’s fine,
    then you will generally want to make a call to `FirstOrDefault` or `SingleOrDefault`
    (depending on your decision earlier on whether multiple matches are permissible).
    However, if it is never acceptable to not have a match, then you’ll use `First`
    or `Single` instead of `FirstOrDefault` or `SingleOrDefault`.
  prefs: []
  type: TYPE_NORMAL
- en: '`First` and `Single` will both throw an `InvalidOperationException` error if
    the sequence contains no matching element. If you use `First` or `Single` and
    nothing in the collection returns `true` from the arrow function, the exception
    will be thrown. This makes it impossible to deal with `null` values with the result
    of `First` or `Single`, which can be very helpful for simplifying your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Having an `InvalidOperationException` error thrown at the exact position your
    code encounters a problem can be immensely more helpful than encountering a `NullReferenceException`
    error 30 lines later in your code and having to figure out how a value got where
    it was supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: '`NullReferenceException` error from occurring. We’ll explore this in more depth
    in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on and discuss ways of combining LINQ methods.
  prefs: []
  type: TYPE_NORMAL
- en: Combining LINQ methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the nice things about LINQ is that it lets you “chain together” different
    methods by calling a LINQ method on the result of another LINQ method. This lets
    you do things such as filter down to a subset of items using `Where`, reorder
    the results with `OrderBy`, and transform them into new objects via `Select`.
  prefs: []
  type: TYPE_NORMAL
- en: However, as .NET has evolved, LINQ has grown a few more specialized overloads
    of its existing methods, which makes some of these chained-together methods unnecessary
    or even inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this block of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this code looks fine. Each of these three variable assignments
    is filtering down and then looking at the results of that filtering option. Sure,
    there’s an opportunity to introduce a local variable for `people.Where(p => p.HasBoarded)`,
    but otherwise, the code often looks fine at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: However, LINQ offers overloaded versions of `Any`, `Count`, `First`, and a few
    other methods that take in a **predicate** (which is just a fancy word for an
    arrow function).
  prefs: []
  type: TYPE_NORMAL
- en: 'These overloaded versions allow you to combine `Where` methods and other methods
    into a more concise format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Not only is this way of writing things more concise, but these overloads can
    be more efficient in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, before, when we were doing `people.Where(p => p.HasBoarded).Any()`,
    this code evaluated left to right, filtering down a large list of items into a
    smaller list of items. Once the entire list had been filtered down, the `Any`
    method call occurred, which returned `true` if at least one item was found in
    that resulting list.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this to the `people.Any(p => p.HasBoarded)` version. This method loops
    over the items and as soon as it sees any element that returns `true` from the
    arrow function, it knows it can stop evaluating because its ultimate result is
    going to be true.
  prefs: []
  type: TYPE_NORMAL
- en: Always look for opportunities to use these specialized LINQ overloads as they
    can result in very concise and even more performant code.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming with Select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you wanted to create a list of strings for all the passengers who
    hadn’t boarded the plane yet. For each name, you want it formatted with the person’s
    name and then their boarding group. So, a sample entry might be `"``Priya Gupta-7"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could write this code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: However, LINQ has a method named `Select` that allows you to transform items
    from one form into another, which would be perfect for this case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For those of you with a JavaScript background, `Select` is similar to the `Map`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Select` version of this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Where` call filtered the results down to non-boarded passengers and
    the `Select` call transformed those objects from `Passenger` objects into strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`Select` isn’t limited to just strings. You can select whatever data type is
    relevant for you, including integers, other objects, lists, or even **anonymous
    types** or **tuples**.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, whenever you have a collection of objects in one shape and you need
    those same objects but in a different form, `Select` is a great method to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and testing our refactored code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we didn’t modify a lot of code in this chapter, the code we did change
    shrunk in size, thus becoming easier to read, understand, and modify in the process.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we refactor. Refactoring should actively improve the maintainability
    of our applications and pay down strategic pieces of technical debt that threaten
    to introduce bugs and delays in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Refactored code
  prefs: []
  type: TYPE_NORMAL
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-Csharp](https://github.com/PacktPublishing/Refactoring-with-Csharp)
    repository inside the `Chapter03/Ch3RefactoredCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Since the art of refactoring involves changing the form of code without changing
    its functionality, we must test the application before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk more about manual and automated tests in [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133),
    but for now, run the tests by selecting the **Test** menu at the top of Visual
    Studio and then clicking **Run** **All Tests**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will show **Test Explorer** and a sea of green check marks, as shown in
    *Figure 3**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Passing tests for this chapter’s code](img/B21324_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Passing tests for this chapter’s code
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s summarize what we’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored refactoring techniques to help better control program
    flow, instantiate objects, iterate over collections, and write more efficient
    code through LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Each refactoring technique we covered is one tool in your toolbelt that might
    improve the readability and maintainability of your code in the right circumstances.
    As you practice refactoring more, you’ll learn more about when to apply which
    refactoring to improve the code you’re working with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll move on from improving individual lines of code and
    focus on a slightly bigger picture as we work to refactor entire methods of C#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it more important to have concise code or readable code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll through a file of code in a project you are working on. What do you notice
    about the `if` statements in your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How frequently are nested `if` statements used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is any logic repeated frequently in conditions of your `if` statements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see any places where inverting the `if` statement or switching to a `switch`
    statement or `switch` expression could improve things?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you think your team has been using LINQ to its fullest potential when working
    with collections? What opportunities for improvement do you see?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about the materials discussed in this chapter
    by reading the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Switch* *Expressions*: [https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression](https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Differences between .NET Collection* *Interfaces*: [https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/](https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query Syntax and Method Syntax in* *LINQ*: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Explore Ranges of* *Data*: [https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Arrow Functions and the Lambda* *Operator*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
