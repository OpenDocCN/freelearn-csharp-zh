- en: Becoming Proficient with Data Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll investigate the data binding syntax that is used to connect
    our data sources to our UI controls. We'll examine how to declare Dependency Properties,
    along with all of the various options that we have when doing that. We'll find
    out about the scope of declared bindings and unravel the finer details of data
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: It is the data binding in WPF that enables it to work so well with the MVVM
    pattern. It provides the connection for two-way communication between the View
    and the View Models components. Yet this abstraction can often lead to confusion
    and make tracking down problems more difficult than when using traditional methods
    of UI to business logic communication.
  prefs: []
  type: TYPE_NORMAL
- en: As data binding is such an important part of the MVVM pattern, we'll cover this
    topic thoroughly, from the basics to advanced concepts, and we'll ensure that
    we are able to fulfill any binding requirements that we may receive.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WPF, we use the `Binding` class to create our bindings. In general, it is
    fair to say that every binding will contain four constituent parts. Let''s take
    a look at them now:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the binding source; typically, this will be one of our View Models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the path to the property from the source object that we would
    like to data bind to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is the binding target; this will typically be a UI control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth is the path to the property of the binding target that we want to
    data bind to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one of our bindings does not work, it is most likely that one of these four
    things has not been set correctly. It is important to stress that the target property
    will typically be from a UI control, because there is a data binding rule that
    states that the binding target must be a Dependency Property. The properties of
    most UI controls are Dependency Properties, and so, this rule simply enforces
    that data normally travels in the direction from our View Model data sources to
    the binding target UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: We'll examine the direction of data bound data traversal later in the chapter,
    but let's first focus on the syntax that is used to specify the value of the `Binding.Path`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Binding path syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bindings can be declared either in longhand, defining an actual `Binding` element
    in the XAML, or in shorthand, using the markup language that is translated to
    a `Binding` element for us by the XAML. We'll primarily focus on the shorthand
    notation, as that is what we will predominantly use throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: The `Binding.Path` property is of type `PropertyPath`. This type supports a
    unique syntax that can be expressed in XAML using a XAML markup extension. While
    it can be confusing at times, there are specific rules that we can learn to make
    it easier. Let's investigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s understand that the binding path is relative to the binding
    source and that the binding source is typically set by the `DataContext` property,
    or by the path itself. In order to bind to the whole binding source, we can specify
    our binding like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be specified like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Most simply, we can specify our binding like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that explicitly declaring the `Path` property name in this syntax is optional
    when the path value is declared first. The three preceding examples are all equal.
    We will omit the `Path` property declaration in the bindings in this book for
    brevity. Let's now see the remaining property path syntax mini-language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To data bind to most property paths, we use the same notation as we use in
    code. For example, when binding directly to the property of a data bound object,
    we just use the property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To data bind to the property of an object that is directly referenced by a
    property of our binding source, we again use the same syntax that we do in code.
    This is known as **indirect property targeting**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when data binding to an item in a collection, or a property of a
    collection item, we use the indexing notation from code. For example, this is
    how we access a property from the first item in our data bound binding source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if we want to access the second item, we use a key of `1` and use
    a key value of `2` if we want the third item and so on. Likewise, to indirectly
    target a property of a collection item, where the collection is a property of
    our binding source, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are freely able to combine these various syntactical options
    to generate more complex binding paths. Multi-dimensional collections are also
    accessed in the same way as we refer to them in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While discussing data binding to collections, note that there is a special
    forward slash (`/`) syntax that we can use to access the selected item at any
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular example would bind to the `PropertyName` property of the current
    item of the collection specified by the `CollectionPropertyName` property. Let''s
    take a quick look at a more practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this basic example using our `UsersViewModel`, we data bind the `Users` collection
    to a listbox. Underneath, we output the value of the `Name` property from the
    currently selected item. Note the setting of the `IsSynchronizedWithCurrentItem`
    property, as without it, this forward slash binding would not work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Try removing the `IsSynchronizedWithCurrentItem` property from the example and
    running the application again and you will see that the current user's name will
    be output initially, but not updated after changes to the selected item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting this property to `True` will ensure that the `ItemCollection.CurrentItem`
    property from the `ListBox.Items` collection is updated each time the selection
    changes. Note that we could also achieve this same output using the `ListBox.SelectedItem`
    property instead of this forward slash notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `IsSynchronizedWithCurrentItem` property is now not needed to update the
    selected user's name in the `TextBlock`, because the `SelectedItem` property will
    take care of that. However, setting it to `True` in this case will ensure that
    the first item in the `ListBox` is selected and that the `TextBlock` will initially
    output the name of that item's user. Let's continue looking at the forward slash
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are trying to data bind to a property of an item in a collection, where
    the collection is itself an item of a parent collection, we can use the forward
    slash notation multiple times in a single binding path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To clarify, this path would bind to the `PropertyName` property of the selected
    item of the collection specified by the `InnerCollectionPropertyName` property,
    which itself is the selected item of the collection specified by the `CollectionPropertyName`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on from collections now, to Attached Properties. In order to data
    bind to an Attached Property, we need to use a slightly different syntax from
    that used in code; we need to enclose the property name in parenthesis, along
    with the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when the Attached Property is a custom-declared property, we must
    include the XAML namespace prefix inside the parenthesis with its separating colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, when binding to Attached Properties, we also need to specify the
    binding target as well as the target property. The binding target will generally
    either be the object that the binding is set on, or another UI element, so we
    tend to see the `RelativeSource` or `ElementName` properties being used in these
    situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll see an extended version of this example later in the book, but in short,
    it binds to the `TextBoxProperties.Label` Attached Property of the parent control
    of type `TextBox`. It is called from within a `ControlTemplate` and so, the parent
    textbox is the templated parent of the control that is being data bound.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping invalid characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `PropertyPath` syntax mini-language, there may be the odd occasion
    when we need to escape certain characters that are used in the syntax. In general,
    the backslash (`\`) is used as the escape character and the only characters that
    we need to escape are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The most common character that we may need to escape in our bind paths is the
    closing curly bracket (`}`), which signals the end of a markup section. Also,
    if you need to use an actual backslash in your binding path, then you must escape
    it by preceding it with another backslash.
  prefs: []
  type: TYPE_NORMAL
- en: The only two other characters that we need to escape are the equals sign (`=`)
    and the comma character (`,`), which are both used to define binding paths. All
    other characters that we are likely to use in a binding path are deemed to be
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a special character to use if we need to escape a character
    when inside an indexer binding expression. In these cases, instead of using the
    backslash character, we need to use the caret character (`^`) as the escape character.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that when explicitly declaring bindings in XAML, we need to escape
    the ampersand (`&`) and the greater than sign (`>`) by replacing them with their
    XML Entity forms. If you need to use these characters, then replace the ampersand
    with `&amp;` and replace the greater than sign with `&gt;`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Binding class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Binding` class has more properties than we have space to discuss here,
    but we'll cover the most important ones in detail shortly, and briefly look at
    other notable properties momentarily. The `Binding` class is the top-level class
    in each binding, but internally it uses a lower-level class that maintains the
    connection between the binding source and binding target.
  prefs: []
  type: TYPE_NORMAL
- en: The `BindingExpression` class is that underlying object. When using MVVM, developers
    do not typically access this inner class, as we tend to keep our functionality
    in our View Models. However, if we are writing custom controls, then it can be
    useful to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: It can be used to programmatically update the associated binding source in certain
    circumstances and we'll find out about that later in the chapter. For now, let's
    focus on what the `Binding` class can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 4.5, a great new property was added to the `Binding` class. The `Delay`
    property enables us to specify an amount of time in milliseconds with which to
    delay the update of the binding source after a change has been made to the binding
    target property value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is really useful if we are performing some heavy computational validation
    or other processing dependent upon the user''s input in a `TextBox` element for
    example. To clarify this functionality further, this delay is actually restarted
    each time the data bound property value changes, or each key press in our example.
    It is typically used to update the binding source in chunks, each time the user
    pauses, or completes typing, somewhat like buffering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `FallbackValue` property is another useful property when it comes to performance.
    In order to return a value from each binding, the WPF Framework does up to four
    things. The first is to simply validate the target property type with the data
    bound value. If successful, it will then try to resolve the binding path.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, this will work, but if not, it will then attempt to find a
    converter to return the value. If it can't find one, or the located converter
    returns the `DependencyProperty.UnsetValue` value, it will then look to see if
    the `FallbackValue` property has a value to provide it with. If there is no fallback
    value, then a lookup is required to find the default value of the target Dependency
    Property.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the `FallbackValue` property, we can do two things to improve performance,
    albeit in a slight way. The first is that, it will stop the WPF Framework from
    performing the lookup of the default value of the target Dependency Property.
    The second is that it will prevent trace statements from being fed to the Output
    window in Visual Studio and to any other trace outputs that have been setup.
  prefs: []
  type: TYPE_NORMAL
- en: The `TargetNullValue` property is similar to the `FallbackValue` property in
    that it enables us to provide some output when there is no data bound value from
    the binding source. The difference is that the `FallbackValue` property value
    is output when a data bound value cannot be resolved, while the `TargetNullValue`
    property value is used when the successfully resolved data bound value is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this functionality to display a more humanized value than `null`,
    or even to provide a default message in our textbox controls for example. To do
    this, we could set our data bound `string` properties to `null` and set a suitable
    value to the `TargetNullValue` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this message will actually appear in the `TextBox` control, so it's
    not an ideal way of providing this functionality. We'll see a better example of
    this later in the book, but now, let's continue our exploration of the `Binding`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have any properties in our View Model that access their data asynchronously,
    or if they are calculated by a heavy computational process, then we need to set
    the `IsAsync` method to `True` on the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This stops the UI from being blocked while waiting for the data bound property
    to be calculated, or otherwise resolved. Until the binding source is resolved,
    the fallback value is used, if set, or the default value will be used otherwise.
    In this example, we are providing a default image to be displayed until the actual
    image is downloaded from the internet and the binding source is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful property of the `Binding` class is the `StringFormat` property.
    As the name hints, this uses the `string.Format` method internally to format our
    data bound text output. There are, however, a few caveats to using this functionality.
    The first is that we can only use a single format item, that is represented by
    the single data bound value in a normal binding. We'll find out how to use multiple
    values later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we need to declare our format carefully, as curly brackets are used
    by the markup extensions and we cannot use the double quote characters (`"`),
    as the binding is already declared within double quotes. One solution is to use
    single quotes to surround our format string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to escape the format by preceding it with a pair of curly
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Most of the useful binding properties have now been discussed here, but it should
    be noted that there are a number of properties in the `Binding` class that are
    not typically used when building a WPF application with MVVM. This is because
    they involve event handlers and we do not normally implement event handlers when
    using MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the three `NotifyOnSourceUpdated`, `NotifyOnTargetUpdated` and
    `NotifyOnValidationError` properties relate to the raising of the `Binding.SourceUpdated`,
    `Binding.TargetUpdated` and `Validation.Error` Attached Events.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the three `ValidatesOnDataErrors`, `ValidatesOnExceptions`, `ValidatesOnNotifyDataErrors` and
    `ValidationRules` properties all relate to the use of the `ValidationRule` class.
    This is a very UI-related way of validating, but this puts our business logic
    right into our Views component.
  prefs: []
  type: TYPE_NORMAL
- en: When using MVVM, we want to avoid this blending of components. We therefore
    tend to work with data elements rather than UI elements, and so we perform these
    kind of duties in our Data Model and/or View Model classes instead. We'll see
    this in [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml), *Implementing
    Responsive Data Validation*, later in the book, but now let's take a deeper look
    at the most important properties of the `Binding` class.
  prefs: []
  type: TYPE_NORMAL
- en: Directing data bound traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The direction of data traversal in each binding is specified by the `Binding.Mode`
    property. There are four distinct directional instances declared in the `BindingMode`
    enumeration, plus an additional value. Let's first take a look at the directional
    values and what they represent.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most common value reflects the most common situation, where data
    flows from the binding source, say, one of our View Models, to the binding target,
    represented by a UI control. This binding mode is called **One-Way** and is specified
    by the `OneWay` enumeration instance. This mode is used primarily for display
    only, or read-only purposes, and situations where the data bound values cannot
    be altered in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The next most common direction of travel is represented by the `TwoWay` enumeration
    instance and signifies that data is free to travel both from our View Models to
    the UI controls and also in the opposite direction. This is the most commonly
    used mode when data binding to form controls, when we want the users' changes
    to be reflected in our View Models.
  prefs: []
  type: TYPE_NORMAL
- en: The third directional enumeration instance is the `OneWayToSource` instance
    and is the opposite to the `OneWay` instance. That is, it specifies that data
    can only travel from the binding target, represented by a UI control, to the binding
    source, for example, one of our View Models. This mode is also useful for capturing
    user inputted date, when we don't need to alter the data bound values.
  prefs: []
  type: TYPE_NORMAL
- en: The final directional instance is similar to the `OneWay` instance, except that
    it only works once and is represented by the `OneTime` instance. While this mode
    will indeed only work one time, upon instantiation of its containing control,
    it will actually also update its value each time the `DataContext` property of
    the relevant binding is set. However, its purpose is that it provides better performance
    than the `OneWay` member and is only suitable for binding to non-changing data,
    so if the data will be updated, this is not the correct directional instance to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: The final instance is named `Default` and as the name hints, is the default
    value of the `Binding.Mode` enumeration. It directs the binding to use the binding
    mode that was declared from the specified target property. When each Dependency
    Property is declared, we can specify whether a One or **Two-Way** binding mode
    should be used by default. If this is not specifically declared, then the property
    will be assigned a One-Way mode. We'll see this explained in more detail later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to different sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We generally set the binding source using the `FrameworkElement.DataContext`
    property. All UI controls extend the `FrameworkElement` class, so we can set our
    binding sources on any of them. This must be set for a binding to work, although
    it can be specified in the `Path` property, or inherited from ancestor controls,
    so it does not have to be explicitly set. Take a look at this simple example,
    which assumes that a suitable binding source has been correctly set on the parent
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the binding source of the first `TextBlock` to a `User` object
    and the path to the `Name` property from that source. The second is set likewise,
    but with the binding source path pointing to the `Age` property instead. Note
    that we have set the `DataContext` property to a `User` object on each `TextBox`
    control individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is perfectly valid XAML, you can imagine how tiresome it would be
    to do this on every control that we want to data bind to in a large form. As such,
    we tend to take advantage of the fact that the `DataContext` property can inherit
    its value from any of its ancestor controls. In this way, we can simplify this
    code by setting the `DataContext` on the parent control instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In fact, when developing each `Window` or `UserControl`, it is customary to
    set the `DataContext` on these top-level controls, so that every contained control
    will have access to the same binding source. This is why we create a View Model
    for each `Window` or `UserControl` and specify that each View Model is responsible
    for providing all of the data and functionality that its related View requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few alternative ways of specifying a binding source, other than
    setting the `DataContext` property. One way is to use the `Source` property of
    the binding and this enables us to explicitly override the binding source that
    is inherited from the parent `DataContext`, if one was set. Using the `Source`
    property, we are also able to data bind to resources, as we saw in our View Model
    Locator example, or static values, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Another way involves the use of the `RelativeSource` property of the binding.
    Using this incredibly useful property of type `RelativeSource`, we can specify
    that we want to use the target control, or a parent of that control as the binding
    source.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also enables us to override the binding source from the `DataContext` and
    is often essential when trying to data bind to View Model properties from `DataTemplate`
    elements. Let''s adjust the earlier `DataTemplate` for our `User` Data Model to
    output a property from its normal `DataContext` that is set by the `DataTemplate`,
    and one from the View Model that is set as the `DataContext` of the parent control,
    using the `AncestorType` property of the `RelativeSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that setting the `Mode` property, that specifies the relative position
    of the binding source compared to the binding target, is optional here. Using
    the `AncestorType` property implicitly sets the `Mode` property to the `FindAncestor`
    instance, so we can declare the same binding without it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mode` property is of the `RelativeSourceMode` enumeration type, which
    has four members. We''ve already seen an example of one instance, the `FindAncestor`
    member, although this can be extended using the related `RelativeSource.AncestorLevel`
    property, which specifies which level of ancestor in which to look for the binding
    source. This property is only really useful if a control has multiple ancestors
    of the same type, as in this following simplified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `TextBox` in this example will output the word `"Outer"` at runtime because
    we have declared that the binding source should be the second ancestor of type
    `StackPanel`. If the `AncestorLevel` property had been set to one or omitted from
    the binding, then the `TextBox` would output the word `"Inner"` at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `RelativeSourceMode` enumeration instance is `Self`, which specifies
    that the binding source is the same object as the binding target. Note that when
    using the `RelativeSource``.Self` property, the `Mode` property is implicitly
    set to the `Self` instance. We could use this property to data bind one property
    of a UI control to another, as in this following example, which sets the control''s
    width value to its `Height` property to ensure that it remains a square regardless
    of the width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RelativeSource.TemplatedParent` property is only used to access the properties
    of controls from inside a `ControlTemplate`. The templated parent refers to the
    object that has the `ControlTemplate` applied to it. When using the `TemplatedParent`
    property, the `Mode` property is implicitly set to the `TemplatedParent` instance
    of the `RelativeSourceMode` enumeration. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the templated parent is the instance of the `ProgressBar` that
    will have this template applied to it and so, using the `TemplatedParent` property,
    we are able to access the various properties of the `ProgressBar` class from within
    the `ControlTemplate`. Furthermore, any binding source that is data bound to the
    `Value` property of the templated parent will also be data bound to the `Text`
    property of this internal `TextBox` element.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the final `RelativeSource` property, `PreviousData` is only really
    useful when defining a `DataTemplate` for items in a collection. It is used to
    set the previous item in the collection as the binding source. While not often
    used, there can be situations where we need to compare values between neighboring
    items in a collection and we'll see a full example of this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although a far simpler option, the `ElementName` property of the `Binding`
    class also enables us to override the binding source set by the `DataContext`.
    It is used to data bind the property of one UI control to either the property
    of another control, or another property on the same control. The only requirement
    to use this property is that we need to name the element that we want to data
    bind to in our current control. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `CheckBox` element and a `TextBlock` element. The
    `Visibility` property of the `TextBlock` element is data bound to the `IsChecked`
    property of the `CheckBox` element and we make use of the `BoolToVisibilityConverter`
    class that we saw earlier to convert the `bool` value to a `Visibility` instance.
    Therefore, when the user checks the `CheckBox` element, the `TextBlock` element
    will become visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ElementName` property can also be used as a shortcut to access the parent
    control''s `DataContext`. If we name our View `This` for example, then we can
    use the `ElementName` property from within a data template to data bind to a property
    from the parent View Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When specifying these alternative binding sources, it is important to know that
    we can only use one of these three different methods at once. If we were to set
    more than one of the binding `Source`, `RelativeSource`, or `ElementName` properties,
    then an exception would be thrown from the binding.
  prefs: []
  type: TYPE_NORMAL
- en: Binding with priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the odd occasion, we may need to specify a number of source binding paths
    and want to map them to a single binding target property. One way that we can
    do this is to use the `MultiBinding` class and we'll see an example of this in
    the last section of this chapter. However, there is an alternative class that
    we can use that provides us with some additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The `PriorityBinding` class enables us to specify multiple bindings and gives
    each a priority, with the bindings that are declared first having the highest
    priority. The special functionality of this class is that it will display the
    value from the first binding that returns a valid value and if that is not the
    binding with the highest priority, it will then update the display with the value
    from the highest priority binding when it is successfully resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify further, this enables us to specify a binding to a normal property
    that will resolve immediately, while the actual value that we want to data bind
    to is being downloaded, calculated, or otherwise being resolved over time. This
    enables us to supply a default image source while the actual required image is
    being downloaded, or to output a message until a calculated value is ready for
    display. Let''s look at a simple XAML example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set the `PriorityBinding` on the `TextBlock.Text`
    property and inside, specify two bindings. The first has the higher priority and
    has the actual property value that we want to display. Note that we set the `IsAsync`
    property to `True`, to specify that this binding will take some time to resolve
    and that it should not block the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second binding is data bound to a normal property using a One-Way binding
    that simply outputs a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By using the `PriorityBinding` element, this message will be output instantly
    and then updated with the actual value from the `SlowString` property when it
    is ready. Let's now move on and investigate one further type of `Binding` class.
  prefs: []
  type: TYPE_NORMAL
- en: Binding from within control templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `TemplateBinding` is a particular type of binding that is used within `ControlTemplate`
    elements in order to data bind to the properties of the type that is being templated.
    It is very similar to the `RelativeSource.TemplatedParent` property that we discussed
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example from earlier that we have edited slightly, we see that declaring
    a `TemplateBinding` is far more straightforward and less verbose than performing
    the same binding using the `RelativeSource.TemplatedParent` property. Let''s remind
    ourselves what that looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If possible, it is generally preferable to use a `TemplateBinding` instead of
    the `RelativeSource.TemplatedParent` property and although they perform the same
    connection in the binding, there are a few differences between them. For example,
    a `TemplateBinding` is evaluated at compile time, which enables faster instantiation
    of control templates, whereas a `TemplatedParent` binding is not evaluated until
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is a simpler form of binding and is missing a number of the
    `Binding` class properties, such as `StringFormat` and `Delay`. In addition, it
    places the extra constraints on the user, that it is permanently set to have a
    binding mode of `OneWay` and both binding target *and* binding source must be
    Dependency Properties. It was designed to be used in a single place with a single
    purpose and in that situation, it does its job well and more efficiently than
    its counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Binding source changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we may need to make changes to our binding sources and have those
    changes propagate to the binding target controls. We may want to set default values
    on a new form, clear old form values, or even set form labels from our View Models.
    In order to do this, our View Models *must* implement the `INotifyPropertyChanged`
    interface and this is why we build this implementation into our base View Model
    class.
  prefs: []
  type: TYPE_NORMAL
- en: When we data bind a binding source to a control in the UI, an event handler
    is attached to the `PropertyChanged` event of the source object. When a notification
    of a change to the property that is specified by the binding source property path
    is received, the control is updated with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the `PropertyChanged` event of the binding source will
    be `null` if no handler has specifically been attached and none of its properties
    have been data bound to UI controls. It is for this reason that we must always
    check for `null`, before raising this event.
  prefs: []
  type: TYPE_NORMAL
- en: All of the binding modes work in the direction of binding source to binding
    target, except for the `OneWayToSource` instance. However, only this and the `TwoWay`
    instance of the `Binding.Mode` enumeration propagate changes in the direction
    of the binding target to the binding source.
  prefs: []
  type: TYPE_NORMAL
- en: When the binding is working in either of these modes, it attaches a handler
    to the target control to listen for changes to the target property. When it receives
    notification of a change to the target property, its behavior is determined by
    the value of the binding's `UpdateSourceTrigger` property.
  prefs: []
  type: TYPE_NORMAL
- en: This property is of the enumeration type `UpdateSourceTrigger`, which has four
    members. The most common is the `PropertyChanged` instance and this specifies
    that the source property should be updated as soon as the target property has
    changed. This is the default value for most controls.
  prefs: []
  type: TYPE_NORMAL
- en: The `LostFocus` member is the next most common value and this specifies that
    the binding should update the binding source when the user moves focus from the
    data bound control. This option can be useful when we want to trigger validation
    once the user has completed entry in each textbox, rather than as they type.
  prefs: []
  type: TYPE_NORMAL
- en: The `Explicit` instance will not update the binding source without explicit
    instruction to do so. As we need to programmatically call the `UpdateSource` method
    of the internal `BindingExpression` object in order to propagate the changes to
    the binding source, this option is not generally used in our normal Views.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, if used at all, we would find it in our `CustomControl` classes. Note
    that calling the `UpdateSource` method will do nothing if the binding mode is
    not set to one of the `OneWayToSource` or `TwoWay` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had an instance of a textbox and we wanted to explicitly update the binding
    source that was data bound to its `Text` property, we can access the lower-level
    `BindingExpression` object from the `BindingOperations.GetBindingExpression` method
    and call its `UpdateSource` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if our binding target control class extends the `FrameworkElement`
    class and most do, then we can simply call the `GetBindingExpression` method on
    it directly and pass in the Dependency Property key that we want to update the
    binding from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The last member of the `UpdateSourceTrigger` enumeration is the `Default` instance.
    This is similar to the `Default` instance of the `Binding.Mode` enumeration in
    that it uses the value specified by each target Dependency Property and is the
    default value of the `UpdateSourceTrigger` property. Again, we'll find out how
    to set the metadata for Dependency Properties later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data bound values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when developing a WPF application, when we need to convert
    a data bound property value to a different type. For example, we might want to
    control the visibility of some UI elements with a `bool` property in our View
    Model, so that we can avoid having the UI-related `Visibility` enumeration instance
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might want to convert different enumeration members to different `Brush`
    objects, or collections to `string` representations of the contained collection
    items. We''ve already seen a number of examples of the `IValueConverter` interface,
    but let''s now take a bit more of a thorough look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we've already seen, the `value` input parameter of type `object` is the data
    bound value of the binding. The `object` return type relates to the converted
    value that we want to return. The `targetType` input parameter specifies the type
    of the binding target property and is typically used to validate the input value
    to ensure that the converter is being used with the expected type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `parameter` input parameter is optionally used to pass an additional value
    through to the converter. If used, its value can be set using the `Binding.ConverterParameter`
    property. Finally, the `culture` input parameter provides us with a `CultureInfo`
    object to correctly format textual output, when working in a culturally-sensitive
    application. We''ll return to this in a moment, but let''s first look at an example
    of a converter that uses the `parameter` input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The idea of this converter is that we can data bind an enumeration property
    to a `RadioButton` or `CheckBox` control that specifies the name of a particular
    member. If the value of the data bound property matches the specified member,
    then the converter will return true and check the control. For all other enumeration
    members, the control will be unchecked. We could then specify a different member
    in each of a group of `RadioButton` controls, so that each member could be set.
  prefs: []
  type: TYPE_NORMAL
- en: In the class, we start by specifying the data types that are involved in the
    implementation of the converter in the `ValueConversion` attribute. Next, we see
    the `IsInverted` property that we saw in the `BaseVisibilityConverter` class that
    enables us to invert the output of the converter.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Convert` method, we first check the validity of our `value` and `parameter`
    input parameters, and return the `DependencyProperty.UnsetValue` value if either
    are invalid. For valid values, we convert both parameters to their `string` representations.
    We then create a `bool` value by comparing the two `string` values. Once we have
    our `bool` value, we use it in conjunction with the `IsInverted` property to return
    the output value.
  prefs: []
  type: TYPE_NORMAL
- en: As with our other enumeration converter example, the `ConvertBack` method implementation
    is a little different again, as we are unable to return the correct enumeration
    instance for a false value; it could be any value except the value specified by
    the `parameter` input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we are only able to return the specified enumeration instance if the
    data bound value is true and the `IsInverted` property is false, or if it is false
    and the `IsInverted` property is true. For all other input values, we simply return
    the `DependencyProperty.UnsetValue` property, which is preferred by the property
    system rather than the `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of this in use, with the `BitRate` enumeration that we
    saw in the previous chapter. Let''s first look at the simple View Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This class just contains a collection of type `BitRate`, which will hold all
    possible members and a selection property of type `BitRate`, which we will data
    bind to the various `RadioButton` elements using our new converter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the use of the `FillWithMembers` Extension Method in the constructor.
    Let''s see that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the `FillWithMembers` Extension Method, we first check that the collection
    that the method is called on is of an enumeration type and throw an `ArgumentException`
    if it's not. We then clear the collection, in case it has any pre-existing items
    in it. Finally, we iterate through the result of the `Enum.GetNames` method, parsing
    each `string` name to the relevant enumeration member and casting it to the correct
    type, before adding it to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the XAML for the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this View, we set up the `Converters` XAML namespace prefix and then declare
    an instance of the `EnumToBoolConverter` class in the `Resources` section. We
    then declare a `StackPanel` containing three `RadioButton` elements inside a `GroupBox`.
    Each `RadioButton` element is data bound to the same `BitRate` property from our
    View Model, using the converter from the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each button specifies a different enumeration member in its binding''s `ConverterParameter`
    property and this is passed through to the converter in the `parameter` input
    parameter. If a `RadioButton` is checked, its true value is passed to the converter
    and converted to the value specified by its `ConverterParameter` value and the
    `BitRate` property is updated with that value. The output of this code looks like
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1662d27-2e6f-465f-8a7a-c4f855859850.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that if we had a large number of enumeration members, or the members were
    changed regularly, declaring each one manually in the UI like this example might
    not be such a good idea. In these cases, we could generate the same UI with less
    work, utilizing a `DataTemplate` object. We'll see an example of this later in
    this chapter, but for now, let's return to the input parameters of our converter.
  prefs: []
  type: TYPE_NORMAL
- en: The final input parameter in the `Convert` and `ConvertBack` methods is the
    `culture` parameter of type `CultureInfo`. In non-international applications,
    we can simply ignore this parameter, however if globalization plays a part in
    your application, then using this parameter is essential.
  prefs: []
  type: TYPE_NORMAL
- en: It enables us to correctly format any textual output that we may have in our
    converter using the `object.ToString` method and keep it in line with the rest
    of the text in the application. We can also use it in the various `Convert` class
    methods to ensure that numerals are also correctly output in the right format.
    Globalization is beyond the scope of this book and so we'll move on now.
  prefs: []
  type: TYPE_NORMAL
- en: Binding multiple sources to a single target property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, there is another, more common way to data bind to multiple binding sources
    at once and to perform some sort of conversion from the various values to a single
    output value. In order to achieve this, we need to use a `MultiBinding` object
    in conjunction with a class that implements the `IMultiValueConverter` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `MultiBinding` class enables us to declare multiple binding sources and
    a single binding target. If the `Mode` or `UpdateSourceTrigger` properties of
    the `MultiBinding` class are set, then their values are inherited by the contained
    `binding` elements, unless they have different values set explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The values from the multiple binding sources can be combined in one of two ways;
    their `string` representations can be output using the `StringFormat` property,
    or we can use a class that implements the `IMultiValueConverter` interface to
    generate the output value. This interface is very similar to the `IValueConverter`
    interface, but works with multiple data bound values instead.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing the `IMultiValueConverter` interface, we do not set the `ValueConversion`
    attribute that we are accustomed to setting in the `IValueConverter` implementations
    that we have created.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Convert` method that we need to implement, the `value` input parameter
    of type `object` from the `IValueConverter` interface is replaced by an `object`
    array named `values`, which contains our input values.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ConvertBack` method, we have an array of type `Type` for the types of
    the binding targets and one of type `object` for the return types. Apart from
    these slight differences, these two interfaces are the same. Let's look at an
    example to help clarify the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where a healthcare application needs to display a patient's
    weight measurements over time. It would be helpful if we could output an indicator
    of whether each consecutive measurement was higher or lower than the previous
    one, to highlight any unhealthy trends.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be implemented using the `RelativeSource.PreviousData` property mentioned
    earlier, a `MultiBinding` object and an `IMultiValueConverter` class. Let''s first
    take a look at how we implement the `IMultiValueConverter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We start our implementation with the customary validation of the input values.
    In this specific converter, we are expecting two values of type `int`, and so
    we use C# 6.0 Pattern Matching to verify that before continuing. If valid, we
    compare our two pre-cast values, returning the appropriate `string`-based direction
    arrow, dependent on the result of the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `ConvertBack` method is not required for our example, we simply return
    an `object` array that contains two `DependencyProperty.UnsetValue` values. Let''s
    take a quick look at our View Model next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a very simple View Model, with just one field and property pair.
    We''ve just hardcoded a few test values to demonstrate with. Let''s now take a
    look at our View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After the `Converters` XAML namespace prefix and the declared `HigherLowerConverter`
    element in the `Resources` section, we have a bordered `ItemsControl` that is
    data bound to the `Weights` property of the View Model that is set as the `DataContext`
    of this View. Next, we see a horizontal `StackPanel` element being used as the
    `ItemsPanelTemplate` in the `ItemsControl.ItemsPanel` property. This simply makes
    the collection control display items horizontally instead of vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the following `DataTemplate` object, we need to specify the data
    type and so need to import the `System` namespace from the `mscorlib` assembly
    to reference the `Int32` type. The binding to the `Text` property in the first
    `TextBlock` specifies that it is binding to the whole data source object, which
    is simply an integer in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding to the `Text` property in the second `TextBlock` is where we are
    using our `MultiBinding` and `IMultiValueConverter` elements. We set our `HigherLowerConverter`
    class to the `Converter` property of the `MultiBinding` object and inside this,
    we specify two `Binding` objects. The first is again binding to the integer value
    and the second uses the `RelativeSource.PreviousData` property to data bind to
    the previous integer value. Let''s now see the output of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09b903b2-9263-430e-ad92-7534edfe58ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Each value after the first have an arrow displayed underneath, that specifies
    whether it is higher or lower than the previous value. While the visual output
    of this example could be improved, it does still highlight the worrying trend
    of the weight measurements continually increasing towards the end of the sample
    data. This useful technique can be used in any situation when we need to compare
    current data values with previous values, such as when displaying share prices,
    or stock levels.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen some examples of Dependency Properties in previous chapters,
    but now let''s take a more thorough look. We have a large number of options that
    we can use when declaring these properties, with some more commonly used than
    others. Let''s investigate the standard declaration first, by defining an `Hours`
    property of type `int` in a class named `DurationPicker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As with all Dependency Properties, we start by declaring the property as static
    and `readonly` because, we only want a single, immutable instance of it. This
    also enables us to access it without an instance of our class.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike normal CLR properties, we do not store the values of our Dependency Properties
    in private fields that back the properties. Instead, default values are stored
    directly within the metadata of each `DependencyProperty` object and altered values
    are stored in a separate array in the `DependencyObject` instance that the Dependency
    Property value was set on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's clarify this a little further and remember that all of the built-in controls
    extend the `DependencyObject` class. This means that the altered values of the
    `TextProperty` Dependency Property for example, which was declared in the `TextBox`
    class, are stored in the actual `TextBox` instance that the property value was
    changed on. This is the main reason why  bindings can only be set on a Dependency
    Property of a Dependency Object.
  prefs: []
  type: TYPE_NORMAL
- en: An array of values exists in each `DependencyObject` instance and contains the
    values of all of its declared Dependency Properties that have been explicitly
    set on it. This is a very important point. This means that by default, with no
    changed values, the array is empty and therefore, the memory footprint is very
    small.
  prefs: []
  type: TYPE_NORMAL
- en: This is converse to a CLR class, where each property has a memory footprint,
    whether it is set or not. The result of this arrangement is that it saves a huge
    amount of memory, because only Dependency Property values that have been explicitly
    set will be stored in the array of values, while default values are read directly
    from the Dependency Property objects instead.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that this array of changed values exists in the `DependencyObject` class explains
    why we need to call its `GetValue` and `SetValue` methods to access and set the
    values of our Dependency Properties. Our `HoursProperty` here is merely the identifier, known
    as the **Dependency Property Identifier**, whose `GlobalIndex` property value
    is used to access the relevant value from that array.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the values in this array are of type `object`, so that it can work
    with any object type. This explains why we need to cast the return value of the
    `GetValue` method from `object` to the appropriate type in the getter of our CLR
    wrapper property. Let's now examine what happens internally when we declare a
    Dependency Property.
  prefs: []
  type: TYPE_NORMAL
- en: In the `DependencyProperty` class, there is a private static `Hashtable` named `PropertyFromName`,
    which holds references to every registered Dependency Property in the application
    and is shared among all instances of the class. To declare each property and create
    our key to the `Hashtable`, we use the `Register` method of the `DependencyProperty`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This method has a number of overloads, but all of them require the following
    information; the name and type of the property and the type of the declaring class,
    or *owner type* as Microsoft prefer to call it. Let's look into this process in
    a bit more depth.
  prefs: []
  type: TYPE_NORMAL
- en: When we register a Dependency Property using one of the `Register` methods,
    the provided metadata is first validated and replaced with default values, if
    required. Then a private `RegisterCommon` method is called and inside it, a class
    named `FromNameKey` is used to generate the unique key from the name and owner
    type of the Dependency Property to create. It does this by creating a unique hash
    code, by combining the results from calling the `object.GetHashCode` method on
    both the name and owner type passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: After the `FromNameKey` object has been created, the `PropertyFromName` collection
    is checked for this key and an `ArgumentException` is thrown if one already exists
    within it. If it is unique, then the default metadata and default value are validated
    and set from input parameters, or automatically generated if missing.
  prefs: []
  type: TYPE_NORMAL
- en: After this step, the actual `DependencyProperty` instance is created using the
    `new` keyword and a private constructor. This internal instance is then added
    to the `PropertyFromName` `Hashtable`, using the `FromNameKey` object as the unique
    key, and then returned to the caller of the `Register` method, to be stored locally
    in the public static `readonly` Dependency Property Identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the overloaded `Register` methods both have an additional input parameter
    of type `PropertyMetadata` and we'll investigate this in the next section. For
    now, let's focus on the last overload, which also enables us to attach a `ValidateValueCallback`
    handler to our property.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, this is solely used for validation purposes and we cannot
    alter the data bound value in this method. Instead, we are simply required to
    return `true` or `false` to specify the validity of the current value. Let''s
    see how we can attach this handler to our property and what its method signature
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ValidateValueCallback` delegate does not provide us with any
    reference to our class and so, we cannot access its other properties from this
    static context. In order to compare the current value with other property values,
    or to ensure that certain conditions are met, we can use another overload of the
    `PropertyMetadata` input parameter of the `DependencyProperty.Register` method
    and we'll see this shortly. But let's now return to focus on the `PropertyMetadata`
    input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the overloads of the `PropertyMetadata` constructor, we can optionally
    set a default value for the property and attach handlers to be called when the
    value changes, or when it is being re-evaluated. Let''s update our example to
    attach a `PropertyChangedCallback` handler now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that our `PropertyChangedCallback` handler must also be declared as static
    in order to be used from the static context of the declared `DependencyProperty`
    as shown in the preceding code. However, we may have a situation where we need
    to call an instance method rather than a static method and in these cases, we
    can declare an anonymous method that calls our instance method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Anonymous methods comprised of Lambda expressions can appear confusing, so
    let''s first extract the relevant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be re-written to make the example somewhat clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now we can clearly see the input parameters of the `PropertyChangedCallback`
    handler, followed by the anonymous method body. Inside this method, we simply
    cast the `dependencyObject` input parameter to the type of the declaring class
    and then call the non-static method from the cast instance of the class, passing
    the input parameters through, if required.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the [Chapter 2](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml), *Debugging
    WPF Applications*, the CLR properties that provide convenient access to our Dependency
    Properties will not be called by the WPF Framework when their values change. Using
    this `PropertyChangedCallback` handler is how we are able to perform actions upon
    value changes, or to debug the changing values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last overload of the `PropertyMetadata` constructor additionally enables
    us to set a `CoerceValueCallback` handler, which provides the platform for us
    to ensure that our values remain within valid ranges. Unlike the `PropertyChangedCallback`
    delegate, it requires us to return the output value of the property, so this enables
    us to alter the value before returning it. Here is a simple example that shows
    how we can adjust our property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example, we first cast the `dependencyObject` input parameter,
    so that we can access its `MaximumValue` property. Let's assume that our `DurationPicker`
    control can work with either twelve or twenty-four hour time formats and so we
    need to determine the current upper hour limit. We can therefore constrain our
    `Hours` property value to be between one and this upper limit.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `CoerceValueCallback` handler, there is a special case that enables
    us to effectively cancel a change in value. If your code detects what your requirements
    specify to be a wholly invalid value, then you can simply return the `DependencyProperty.UnsetValue`
    value from the handler.
  prefs: []
  type: TYPE_NORMAL
- en: This value signals to the property system that it should discard the current
    change and return the previous value instead. You could even use this technique
    to selectively block changes to a property until a certain condition is met elsewhere
    in the class, for example.
  prefs: []
  type: TYPE_NORMAL
- en: That sums up the useful but fairly limited options that we have with our `PropertyMetadata`
    object, although it should be noted that there are a number of classes that derive
    from this class that we can use in its place and each have their own benefits.
    The `UIPropertyMetadata` class directly extends the `PropertyMetadata` class and
    adds the ability to disable all animations of the property value via its `IsAnimationProhibited`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `FrameworkPropertyMetadata` class further extends the `UIPropertyMetadata`
    class and provides us with the ability to set property inheritance, the default
    `Binding.Mode` and `Binding.UpdateSourceTrigger` values of the property, and a
    variety of `FrameworkPropertyMetadataOptions` flags that affect layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of the `FrameworkPropertyMetadataOptions` members.
    If we think that most users will want to use Two-Way data binding with our property,
    then we can declare it with the `BindsTwoWayByDefault` instance. This has the
    effect of switching the `Binding.Mode` from the default `OneWay` member to the
    `TwoWay` member on all bindings to our property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Another commonly used flag is the `Inherits` instance, which specifies that
    the property value can be inherited by child elements. Think of the `FontSize`
    or `Foreground` properties that can be set on a `Window` and inherited by each
    control inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we want to create a Dependency Property using this `Inherits` member,
    then we should declare it as an Attached Property, as property value inheritance
    works better with Attached Properties. We will find out more about this soon,
    in a subsequent section, but now let's continue. Next is the `SubPropertiesDoNotAffectRender`
    member, which can be used to streamline performance, and we'll find out more about
    this particular instance in [Chapter 12](8fc90c0b-ca68-49ef-a77f-75173ca49f31.xhtml),
    *Deploying Your Masterpiece Application*.
  prefs: []
  type: TYPE_NORMAL
- en: The last commonly used options are the `AffectsArrange`, `AffectsMeasure`, `AffectsParentArrange` and
    `AffectsParentMeasure` members. These are typically used with Dependency Properties
    that have been declared in custom panels, or other UI controls, where the property
    value affects the look of the control and changes to it need to cause a visual
    update.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should also be noted that this `FrameworkPropertyMetadataOptions` enumeration
    is declared with the `FlagsAttribute` attribute, which signifies that we can also
    allocate a bitwise combination of its instance values, and therefore set multiple
    options for each of our Dependency Properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to set the default value for the `Binding.UpdateSourceTrigger` property,
    we need to use the most heavily populated constructor, passing all six input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is perfectly fine to pass `null` values for the callback handlers,
    if we don't need to use them. The `false` after the `CoerceValueCallback` handler value
    sets the `IsAnimationProhibited` property of the `UIPropertyMetadata` class. The
    `UpdateSourceTrigger` value set here will be used on all bindings to this property
    that have not explicitly set the `UpdateSourceTrigger` property on the binding,
    or have set the `UpdateSourceTrigger.Default` member to the binding property.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have fully investigated the various options that we have when we
    declare Dependency Properties using the `Register` method of the `DependencyProperty`
    class, let's take a look at the another registration method from this class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring read-only Dependency Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, read-only Dependency Properties are most commonly found in custom
    controls in situations where we need to data bind to a value, but do not want
    it to be publicly accessible. It might be a property that holds some relation
    to an on screen visual, a mid calculation point, or previous value, but generally,
    we don't want the users of our framework to be able to data bind to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a scenario where we want to create a button that will enable
    us to set a tooltip message to display when the control is disabled, in addition
    to the normal tooltip message. In this case, we could declare one Dependency Property
    to hold the disabled tooltip message and another to store the value of the original
    tooltip when displaying the disabled tooltip. This original tooltip property is
    a perfect candidate to be a read-only Dependency Property. Let''s see what this
    property looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use a different syntax to declare read-only Dependency Properties.
    Instead of returning the `DependencyProperty` identifier that is returned from
    the `Register` method, the `RegisterReadOnly` method returns a `DependencyPropertyKey`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: This object is typically declared with a `private` access modifier, to stop
    it from being externally used with the `DependencyObject.SetValue` method. However,
    this method can be used within the class that registered the read-only property
    to set its value.
  prefs: []
  type: TYPE_NORMAL
- en: The `DependencyProperty` property of the `DependencyPropertyKey` object is used
    to return the actual `DependencyProperty` identifier that is used to access the
    property value from the dictionary that we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The input parameters of the `RegisterReadOnly` methods offer the same options
    as those of the standard `Register` method, although there is one less overload.
    Unlike the `Register` method, when calling the `RegisterReadOnly` methods, we
    always need to provide the `PropertyMetadata` object, although we can pass a `null`
    value if we do not need what it provides.
  prefs: []
  type: TYPE_NORMAL
- en: One very important point to note is that when data binding to a read-only Dependency
    Property, we *must* set the binding `Mode` property to the `OneWay` enumeration
    member. Failure to do so will result in an error at runtime. We've now covered
    the creation of normal Dependency Properties in some detail, so let's move on
    to take a look at a different kind Dependency Property.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Attached Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DependencyProperty` class enables us to register one further, special type
    of Dependency Property. These properties are like the Extension Methods of XAML,
    as they enable us to extend existing classes with our own functionality. They
    are of course, Attached Properties.
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen some examples of them earlier in this book and we'll see
    further examples later, but in this chapter, we'll cover their registration. We
    can declare Attached Properties in exactly the same ways that we can create Dependency
    Properties and have all of the same various options of setting metadata and attaching
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several overloads of the `RegisterAttached` and `RegisterAttachedReadOnly`
    methods that mirror the `Register` and `RegisterReadOnly` methods in input parameters
    and functionality. However, instead of declaring a CLR wrapper for our Attached
    Properties, we are required to declare a pair of getter and setter methods to
    access and set their values. Let''s see another example from the `TextBoxProperties`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the declaration of a `bool` Attached Property named `IsFocused`
    with a `PropertyMetadata` element that specifies a default value and a `PropertyChangedCallback`
    handler. Like the CLR property wrappers for Dependency Properties, these getter
    and setter methods will not be called by the WPF Framework. They are typically
    declared both public and static.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one situation where we do not need to declare these methods
    as public. If we want to create a Dependency Property whose value can be inherited
    by its children, then we should declare it using the `RegisterAttached` method,
    even if we don't require an Attached Property. In this situation, we are not required
    to publicly expose our property getter and setter.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can specify the `FrameworkPropertyMetadataOptions.Inherits` metadata
    option upon the declaration of Dependency Properties and their value inheritance
    might work in some situations, it is not guaranteed in other situations. As Attached
    Properties are global properties in the property system, we can be assured that
    their property value inheritance will work in all situations.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our example, our `PropertyChangedCallback` handler is a simple
    affair. It casts the `dependencyObject` property to the type of control that the
    property is attached to, in this case, a `TextBox`. It then verifies that the
    data bound `bool` value has been set from `false` to `true` and that the control
    is not already focused. If these conditions are verified, the control is then
    focused.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Attached Property can be data bound to a `bool` property in a View Model
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The attached `TextBox` control can then be focused from the View Model at any
    time using this following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to ensure that the variable is `false` before setting it to
    `true`, as it is the actual changing of the value that will trigger the control
    to become focused. Now that we know how to declare our own custom Dependency Properties,
    let's turn our attention to the rules that govern the way they are set.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing value setting sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen, there are a number of ways of setting the values of
    Dependency Properties; we can set them directly in code, locally in XAML, or through
    the use of our `CoerceValueCallback` handlers for example. However, there are
    many more ways that they can be set. For example, they can also be set in styles,
    animations, or through property inheritance to name but a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we data bind our View Model properties to Dependency Properties and find
    that the displayed value is not what we are expecting, one reason for this can
    be because another method of setting the property has a higher precedence and
    so, overrides our expected value. This is because all the methods of setting the
    values of Dependency Properties are ordered in terms of importance in a list called
    the Dependency Property Setting Precedence List. Let''s take a look at that now:'
  prefs: []
  type: TYPE_NORMAL
- en: Property system coercion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animated properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Template properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implicit style (only applies to the `Style` property)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style triggers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Template triggers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style setters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Default (theme) style
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Default value from Dependency Property metadata
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Last on the list, with the lowest precedence at position eleven, are the default
    values that are specified in the Dependency Property declarations. Next up the
    list are changes caused by property inheritance. Remember that this can be defined
    in our Dependency Properties using the `Inherits` instance of the `FrameworkPropertyMetadataOptions`
    enumeration in the `FrameworkPropertyMetadata` input parameter of the `DependencyProperty.Register`
    method. Let''s see an example of this to highlight this order of precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this first example, the `TextBlock` control in the outer `StackPanel` has
    its `Foreground` color set to black by the default value that was set in the data
    bound `Text` property. However, the `TextBlock` control inside the inner `StackPanel`
    has its default `Foreground` property value overridden by the `TextElement.Foreground`
    Attached Property value that is set on its parent control. It inherits the value
    of this property from the `StackPanel` and this demonstrates that properties set
    through property inheritance have a higher precedence than properties set with
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, default property values that are set in theme styles follow on the
    precedence list, with the next lowest priority, and override property values set
    through inheritance. As it is quite difficult to come up with a short XAML example
    for this, we''ll skip over this item and move onto the next. At number eight on
    the list, we have property values that have been set by style setters. Let''s
    adjust our earlier example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `TextBlock` control in the outer `StackPanel` still has
    its `Foreground` color set to black by the default value of the data bound `Text`
    property. The top `TextBlock` control inside the inner `StackPanel` still has
    its default `Foreground` property value overridden by the `TextElement.Foreground`
    value from its parent control. However, now we can also see that values that are
    set in a `Style` will override inherited property values. This is the output of
    this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfd1682a-3687-49e2-90ba-7fcc62032f68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, at number seven on the precedence list, we have template triggers, which
    override property values that are set with style setters and all other previously
    mentioned methods of setting values. Note that this specifically deals with triggers
    that are declared within templates, such as the `ControlTemplate`, and does not
    relate to triggers that are declared within any `Style.Triggers` collections.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have declared a button and overridden its `ControlTemplate`,
    defining a new, minimal markup for it. In the style, we have set the `Foreground`
    property value to green in a setter. However, in our `ControlTemplate`, we have
    a `Trigger` that will override this value and set it to blue when its condition
    is met. Note that if we changed the trigger condition to `false` or removed the
    whole trigger, the button text would then become green, as set by the style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up the list at position six are triggers that are declared within `Style.Triggers`
    collections. One important point to note here is that this only relates to styles
    that are either declared inline locally, in the current control''s `Resources`
    section, or in the application resources file and not to default styles, which
    have a lower precedence value. We can extend our previous example by adding a
    new trigger into the `Style.Triggers` collection to highlight this new priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When running this example, our text is now orange. The `Foreground` property
    value that is set by the trigger in the `Triggers` collection of the style has
    overridden the value set by the template trigger, which itself has overridden
    the value set by the style setter. Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'At number five on the list, we have implicit styles. Note that this special
    level of precedence only applies to the `Style` property and no others. A style
    can be implicitly set to all members of a type by specifying the target type and
    being declared without an `x:Key` directive set. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The relevant style must either be declared in the current XAML page, or the
    `Application.Resources` section of the `App.xaml` file. Styles from themes are
    not included here, as they have a lower value precedence. Note that this special
    position in the list was only added in .NET 4 and is omitted from the .NET 3 documentation
    on the [docs.microsoft.com](http://docs.microsoft.com) website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up the list at position four are properties that are set within either
    a `ControlTemplate` or a `DataTemplate`. If we set a property directly on any
    element within a template, that value will override all values set by methods
    with lower precedence. For example, if we directly set the `Foreground` property
    on the `ContentPresenter` from our previous example, then its value will override
    all other settings in that example and the button text will be red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'At position three on the list, we have locally set values. To demonstrate this,
    we could just set the `Foreground` property on the actual button from the last
    full example, but instead let''s highlight an extremely common mistake that a
    lot of developers make. Imagine a situation where we want to output a value predominantly
    in one color, but in another color under certain circumstances. Some developers
    might try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running this example, some might expect this to work and be stumped when
    it doesn''t. The reason why this doesn''t work is because local property settings
    have a higher value setting precedence than properties set by style triggers.
    The solution to correcting this mistake is to use our new found knowledge of this
    value setting precedence list and move the local property setting to a style setter,
    which has a lower precedence than the trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `TextBlock.Foreground` property will be set to green from the style
    setter and overridden by the trigger when the condition is true, as expected.
    Let''s continue up the list to position two. In the penultimate position, we have
    property values that are set by animations. A very simple example can demonstrate
    this nicely for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the animation overrides the locally set value of the `Width`
    property and the rectangle grows and shrinks as planned. If we think logically
    about this, then it is clear that the animation system had to feature at a very
    high position on the property setting precedence list. Otherwise, if it was much
    lower down the list, we wouldn't be able to animate anything.
  prefs: []
  type: TYPE_NORMAL
- en: However, properties that are set by animations are at number two of the list,
    which means that there is one place that a property can be set that will override
    even values set by animations. At number one on the list of Dependency Property
    Setting Precedence, with the absolutely highest priority setting, is the property
    coercion system that we discussed in the *Dependency Properties* section.
  prefs: []
  type: TYPE_NORMAL
- en: This could only really happen if we built a custom control that animated a custom
    Dependency Property that had particular requirements placed upon it, such as specifying
    that it should have a certain maximum or minimum value. In this case, we could
    enforce these rules in a `CoerceValueCallback` handler that is attached to the
    Dependency Property.
  prefs: []
  type: TYPE_NORMAL
- en: If we had these requirements that were enforced by the property coercion system,
    yet wanted to animate them in the UI, it again makes perfect sense that we would
    want our coerced values to override the values set by the animation. In this way,
    we could rest assured that our coerced property values will remain within the
    bounds that we set for them at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Data templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen a number of simple examples of the `DataTemplate`, but they
    are such an important part of WPF that we're going to have a much more thorough
    look at them now. In short, we use a `DataTemplate` to define how we want particular
    data objects to be rendered in the UI*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to data bind a particular type of object to a UI control without
    providing a `DataTemplate` for it, the WPF Framework would not know how to display
    it. Let''s highlight this with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In these cases, the best job that the WPF Framework can do is to display a
    `string` representation of each object. It achieves this by calling the `object.ToString`
    method on the data object and setting that value to the `Text` property of a `TextBlock`,
    which it uses to display the object. If this method has not been overridden in
    the object''s class, this will result in the name of the type of the object being
    displayed in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57fd0723-8636-47a6-81ee-773a778a5d4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Knowing that the WPF Framework will call the `ToString` method on our data
    objects before displaying them enables us to take a shortcut, or a simple alternative
    to defining a `DataTemplate`, if we only need a textual output in the UI. Therefore,
    it is always a good idea for us to override the `object.ToString` method to output
    some meaningful display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/459b78b3-b320-44cd-88c1-39d554163a39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that Visual Studio IntelliSense also calls the `ToString` method on our
    data objects before displaying them, so the benefit of providing a custom implementation
    for it is doubled. As such, we often add an abstract method into our base class
    to ensure that all derived classes will implement this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to the topic of data templates now, let''s first take a look at a
    better example for our `User` objects and then investigate where we can declare
    our data templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we simply output the user''s name in one `TextBlock` and their
    age in another. Note the use of the `StringFormat` property to surround the age
    in brackets in the output. Let''s now see how this `DataTemplate` renders our
    `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2d76956-d8f4-4a09-969e-ebab45a86e9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Primarily, we can declare our data templates in one of four main places. The
    first is in line with the control that the related data object or objects will
    be displayed in. We have two main options for this too, depending on the number
    of data objects that we have to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a single object to display, we can utilize the `ContentControl`
    element to display it and the `ContentControl.ContentTemplate` property to define
    the `DataTemplate` element that it should use to render the data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in a collection control, or `ItemsControl`, such as the `ListBox`
    control, we can declare our `DataTemplate` directly in the `ItemTemplate` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The next place that we can declare our data templates is in the `Resources`
    section of the control that will display the data object or objects. Here is our
    `ContentControl` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare our data templates in the `Resources` section of the `Window`
    or `UserControl` that contains the control that displays the data objects. If
    we have multiple data objects, then we can set our data template like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The last place that we can define our data templates is in the `Application.Resources`
    section of the `App.xaml` file. When the WPF framework searches for a data template
    for particular data type, it first searches the local `Resources` section of the
    control that is applying the template.
  prefs: []
  type: TYPE_NORMAL
- en: If it finds no match for the type, it then searches the `Resources` collection
    of the parent control and then the parent of that control and so on. If it still
    does not find a data template with a matching type, then it will search through
    the `Application.Resources` section of the `App.xaml` page.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this order of lookup to our advantage. We often declare our default
    data templates in the `Application.Resources` section of the `App.xaml` page,
    as these resources are available application wide. If we need to override our
    default data templates, to display a particular output in a particular View, we
    can declare a new data template with the same `x:Key` directive locally in the
    View's `Resources` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the local `Resources` section is searched before the application resources,
    it will use the locally declared data template instead of the default one. Another
    way of overriding our default templates is to declare them without setting their
    `x:Key` directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Resources that are declared in this way are implicitly applied to all data objects
    of the appropriate type that do not have a data template explicitly applied. Therefore,
    in order to override these default data templates, we can simply declare a new
    data template and explicitly set it to the relative template property using its
    `x:Key` directive. Let's now look at one further way of specifying a data template.
  prefs: []
  type: TYPE_NORMAL
- en: Taking complete control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we might want to display different objects of the same type in different
    ways, depending on the values of their properties. For example, with a collection
    of objects that represent vehicles, you might want to have different displays
    for different types of vehicle, as trucks have different specifications to motor
    boats. The `DataTemplateSelector` class enables us to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: When extending the `DataTemplateSelector` class, we can override its single
    `SelectTemplate` method. In this method, we are provided with both the data object
    and the data bound object and can select different data templates to return, dependent
    on the data object's property values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a very simple example, where we return one of two data templates
    based on the `User`''s age. We''ll first need to declare another `DataTemplate`
    for our `User` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In this template, we have simply inverted the colors of the background and
    foreground from those in the first template. Let''s now see our `DataTemplateSelector`
    class that will reference both this and the other `DataTemplate` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first defensively cast the `container` input parameter to
    an object of type `FrameworkElement`, using the `as` keyword. We then perform
    the standard `null` checks for this new object and the other input parameter and
    use the `is` keyword to pattern match the correct type and automatically cast
    the `item` parameter to a `User` object, if it's of the right type. If it is,
    then we call the `FindResource` method on our `FrameworkElement` object, to return
    the appropriate data template, dependent upon the value of the `Age` property.
    Otherwise, we return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FrameworkElement.FindResource` method first searches the calling object
    for the data template and then its parent element, and so on, up the logical tree.
    If it doesn't find it in any parent element in the application window, it then
    looks through the `App.xaml` file. If it still does not find it there, it then
    searches in the themes and system resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `container` input parameter is used to access the `FindResource` method.
    Note that it will typically be of type `ContentPresenter` if we're using a normal
    collection control, so we could have cast it to that type in order to access the
    data templates.
  prefs: []
  type: TYPE_NORMAL
- en: However, the default container could be overridden to use one of the parent
    classes that the `ContentPresenter` class is derived from. Therefore, to avoid
    the possibility of exceptions, it is safer to cast it to the `FrameworkElement`
    class that actually declares the `FindResource` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use this class now. First, we need to add the XAML namespace
    prefix for our `DataTemplateSelectors` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to add an instance of our `UserAgeDataTemplateSelector` class
    to a `Resources` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set our resource selector to the `ItemTemplateSelector` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the application now, we''ll see this new output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c08a911-2fd2-477b-b651-e246c3c4ca71.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that `DataTemplateSelector` classes are typically used with very different
    templates, such as those that make up the different editing or viewing modes of
    a custom control. Slight differences like those in our simple example can be far
    easier achieved using style triggers and we'll find out more about triggers and
    styles in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying hierarchical data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one class in the .NET Framework that extends the `DataTemplate` class
    in order to support UI controls that extend the `HeaderedItemsControl` class.
    As it sounds, the `HeaderedItemsControl` class represents a particular kind of
    `ItemsControl` element that has a header. Examples include the `MenuItem`, `TreeViewItem`,
    and `ToolBar` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `HierarchicalDataTemplate` class was created to display hierarchical Data
    Models. To clarify a little further, a hierarchical data Model is a data Model
    that contains a collection property with items of the same type as the parent
    object. Think of the folder view in the Windows Explorer window; each folder can
    contain further folders.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the `HierarchicalDataTemplate` and the `DataTemplate`
    class is that the `HierarchicalDataTemplate` class has an `ItemsSource` property
    that we can use to bind the children of each item to.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `ItemsSource` property, there are a number of other item-related
    properties, such as the `ItemContainerStyle`, `ItemStringFormat` and `ItemTemplate`
    properties. We'll find out more about what these other properties do in the next
    chapter, but for now, let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of `HierarchicalDataTemplate` examples that demonstrate the
    use of `TreeViewItem` elements to be found online, so for this example, we''ll
    see how we can build an application menu using data binding. First, we''ll need
    a View Model to data bind to each `MenuItem` control. Let''s take a look at our
    `MenuItemViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this simplified example, our View Model only declares three properties to
    data bind to the `MenuItem` control's properties. In a real application, we would
    typically add further properties, so that we could define the icon, or maybe the
    style of each menu item as well. However, continuing the example with our View
    Model, let's look at the class that would declare these View Models.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an application has a menu control, it would typically reside in the `MainWindow.xaml`
    file. Therefore, the data bound `MenuItemViewModel` elements would be declared
    in the View Model that is data bound to the data context of that View. Let''s
    look at the required properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative to programmatically declaring the various menu item View Models
    would be to define the items in an XML file, read it in and generate the items
    from that at runtime. However, for the purpose of this simple example, let''s
    just hard code some values to use, omitting the commands for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'While this code is somewhat difficult to read, it is far more compact than
    declaring each child item separately and then building up the hierarchy afterwards.
    The end result is the same, so let''s now see what the required XAML looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare a `Menu` control and data bind our `MenuItems` collection to
    its `ItemsSource` property. The `ItemContainerStyle` enables us to define the
    style of the UI container that surrounds each of our data items. In this case,
    that control is a `MenuItem` control.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do in this style is to bind the `Command` property of our View
    Model to the `Command` property of the menu item. If we had declared any other
    properties in our View Model to map to the `MenuItem` class properties, then this
    style would be the place to data bind them.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, the `ItemTemplate` property enables us to provide a data
    template, or in this case, our `HierarchicalDataTemplate` element, that will define
    how each item will be rendered. In the template declaration, we state the type
    of our data items and specify the collection property that contains the child
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the template, we simply output the value of the `Header` property in
    a `TextBlock` element. This will represent the name of each menu item. Let''s
    see what this will all look like when the application is running now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77f1568d-4b49-4677-a0a9-3d6d3491e813.png)'
  prefs: []
  type: TYPE_IMG
- en: Data binding to enumeration collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen a number of examples of data binding to enumeration instances.
    We've seen converters that we can use to convert our enumeration values and Extension
    Methods that we can use to extract additional information from each member. Earlier
    in this chapter, we even saw a full but basic example using our `BitRate` enumeration.
    Now, with our new found knowledge, let's see how we can improve that earlier example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, in the previous example, we manually declared a `RadioButton` control
    for each of our enumerations. While that is fine for our three member enumeration,
    it wouldn''t make so much sense to use this method if we had a large number of
    members. Instead, let''s think about how we could use a `DataTemplate` to declare
    how each member should be rendered. Let''s remind ourselves how we declared each
    `RadioButton` in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we notice is the hardcoded `Content` value. Obviously,
    we can''t do this in a `DataTemplate`, otherwise every member would be given the
    same label. This is a perfect place for us to use the `EnumToDescriptionStringConverter`
    converter that we created earlier, so let''s update that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we see that we have also hardcoded the `Sixteen` enumeration member to
    the `ConverterParameter` property, so we''ll need to change that in our data template
    too. Our first attempt might be to simply data bind the whole data context from
    the data template, which in our case, is one of the enumeration instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we do this and run the application, we will receive the following
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we cannot data bind to the `ConverterParameter` property, as
    it was not declared as a Dependency Property. As we cannot data bind to this property
    from within our data template and no longer use the `EnumToBoolConverter` class
    to specify the selected enumeration instance, this will complicate our example
    somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: 'One trick that we can use is to utilize the `SelectedItem` property of the
    `ListBoxItem` class to hold the value of our selected enumeration member instead.
    We can achieve this by data binding this property to the `IsChecked` property
    of each `RadioButton` using a `RelativeSource.FindAncestor` binding in our `DataTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that each data item in a collection control will be implicitly wrapped
    in a UI container element. In our case, we'll use a `ListBox` control and so our
    enumeration instances will be wrapped in `ListBoxItem` elements, but if we had
    chosen a `ComboBox` for example, then our items' containers would be `ComboBoxItem`
    elements. We'll find out more about this in the next chapter, but for now, let's
    continue looking at this example.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have data bound the `Content` property of the `RadioButton` to the
    description of each member from the `DescriptionAttribute` attribute declared
    in the enumeration and the `IsChecked` property to the `IsSelected` property of
    the `ListBoxItem` element. However, we have lost the connection to our selected
    enumeration property from the View Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to restore this connection, we can data bind the `BitRate` property
    to the `SelectedItem` property of the `ListBox` control. The WPF Framework implicitly
    connects this property with the `IsSelected` property of each `ListBoxItem` element
    and so our connection between the `BitRate` property and the `IsChecked` property
    of each button is now restored. Let''s see the updated XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: To update our earlier example, we need to add the new `Enums` XAML namespace
    prefix, so that we can specify our `BitRate` enumeration type in the data template.
    Next, we need to update the content of our `GroupBox` element. Now we're using
    a `ListBox` control so that we can take advantage of its item selection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We data bind our `BitRates` collection to the `ItemsSource` property and our
    selected `BitRate` property to the `SelectedItem` property of the `ListBox`. The
    one problem with this method is that as we''re now using a `ListBox` element in
    our example, we can see it and its contained `ListBoxItem` objects. This is not
    how radio buttons are typically displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/880d4dbb-c489-4263-b391-86639919ed7a.png)'
  prefs: []
  type: TYPE_IMG
- en: It's not a terrible problem and it can be easily fixed by declaring a few styles.
    We'll return to this example in the following chapter and demonstrate how we can
    style the `ListBox` element and its items to completely hide their use from the
    end users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of important information in this chapter, from examining
    the binding path syntax mini-language to exploring a number of different binding
    scenarios. We've investigated the plethora of options that we're afforded when
    declaring our own Dependency Properties and looked into the creation of Attached
    Properties, using some interesting examples. Finally, we examined the finer details
    of data templating and explored a number of ways of data binding to enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll have an in-depth look at the various UI elements
    in the WPF Framework and their most relevant properties. We'll investigate when
    to customize them and when we need to create our own controls. We'll then explore
    the various ways of modifying existing controls in WPF and finally, take a detailed
    look at how to create our own custom controls.
  prefs: []
  type: TYPE_NORMAL
