- en: '*Chapter 13*: Working with the Blazor WebAssembly UI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用Blazor WebAssembly UI'
- en: Blazor is a relatively new **Single-Page Application** (**SPA**) framework for
    building interactive web applications using C# instead of JavaScript. Blazor is
    one of the built-in UI options provided by ABP Framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor是一个相对较新的使用C#而不是JavaScript构建交互式网页应用的**单页应用程序（SPA**）框架。Blazor是ABP框架提供的内置UI选项之一。
- en: In this chapter, I will briefly discuss what Blazor is and the main pros and
    cons of using this new framework. I will then continue by explaining how you can
    create new ABP solutions using the Blazor UI option. At the end of the chapter,
    you will have understood the architecture and design of the ABP Blazor integration
    and learned about the essential ABP services that you will use in your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将简要讨论Blazor是什么以及使用这个新框架的主要优缺点。然后，我将继续解释如何使用Blazor UI选项创建新的ABP解决方案。到本章结束时，你将了解ABP
    Blazor集成的架构和设计，并了解你将在应用程序中使用的基本ABP服务。
- en: 'This chapter consists of the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: What is Blazor?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Blazor？
- en: Getting started with the ABP Blazor UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用ABP Blazor UI
- en: Authenticating the user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户身份
- en: Understanding the theming system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解主题系统
- en: Working with menus
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用菜单
- en: Using the basic services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本服务
- en: Using the UI services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UI服务
- en: Consuming HTTP APIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费HTTP API
- en: Working with global scripts and styles
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局脚本和样式
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development. We will use the ABP CLI at some points,
    so you need to install the ABP CLI, as explained in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026),
    *Getting Started with ABP Framework*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随本章中的示例，你需要一个支持ASP.NET Core开发的IDE/编辑器。在某些地方，我们将使用ABP CLI，因此你需要安装ABP CLI，具体请参考[*第2章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)，“ABP框架入门”。
- en: 'You can download the example application from the following GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples given in this chapter.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下GitHub仓库下载示例应用程序：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)。它包含本章中给出的一些示例。
- en: What is Blazor?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Blazor？
- en: As I indicated in the introduction, Blazor is an SPA framework used to build
    interactive web applications, just like other SPA frameworks such as Angular,
    React, and Vue.js. However, it has one important difference – we can use C# to
    build the application instead of JavaScript, which means we can run .NET in browsers.
    Blazor uses the .NET core runtime to execute the .NET code in the browser (for
    Blazor WebAssembly).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在引言中指出的，Blazor是一个用于构建交互式网页应用的SPA框架，就像其他SPA框架（如Angular、React和Vue.js）一样。然而，它有一个重要的区别——我们可以使用C#来构建应用而不是JavaScript，这意味着我们可以在浏览器中运行.NET。Blazor使用.NET核心运行时在浏览器中执行.NET代码（对于Blazor
    WebAssembly）。
- en: 'Running .NET in browsers is not a new idea. Microsoft has done it before with
    Silverlight. To run Silverlight applications, we had to install a plugin on the
    browser. Blazor, on the other hand, runs natively on the browser, thanks to **WebAssembly**
    technology, which is defined as the following on [https://webassembly.org](https://webassembly.org):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行.NET并不是一个新想法。微软之前已经通过Silverlight做到了这一点。要运行Silverlight应用程序，我们不得不在浏览器上安装一个插件。另一方面，Blazor通过**WebAssembly**技术原生地在浏览器上运行，该技术定义如下[https://webassembly.org](https://webassembly.org)：
- en: '"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
    virtual machine. Wasm is designed as a portable compilation target for programming
    languages, enabling deployment on the web for client and server applications."'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '"WebAssembly（简称Wasm）是一种基于栈的虚拟机的二进制指令格式。Wasm被设计为编程语言的便携式编译目标，使得客户端和服务器应用程序能够在网络上部署。"'
- en: A higher-level language, such as C#, can be compiled into WebAssembly and run
    natively in the browser. WebAssembly is supported by all major web browsers, so
    we don't need to install any custom plugin. If you're wondering whether Blazor
    is the new Silverlight, I can simply say, no, it is not.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一种高级语言，如C#，可以被编译成WebAssembly并在浏览器中本地运行。WebAssembly被所有主流的网页浏览器支持，因此我们不需要安装任何自定义插件。如果你想知道Blazor是否是新的Silverlight，我可以简单地说，不是的。
- en: 'As .NET developers, Blazor brings incredible opportunities to us:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET开发者，Blazor为我们带来了难以置信的机会：
- en: We can use our existing C# skills to develop applications by harnessing the
    full power of the language and the runtime.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用语言和运行时的全部功能，使用我们现有的C#技能来开发应用程序。
- en: We can use existing .NET libraries, such as our favorite NuGet packages.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用现有的.NET库，例如我们最喜欢的NuGet包。
- en: We can share code (such as DTO classes, application service contracts, localization,
    and validation code) between the server and the client.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在服务器和客户端之间共享代码（例如DTO类、应用程序服务合约、本地化和验证代码）。
- en: We can use the familiar Razor syntax to build UI pages and components.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用熟悉的Razor语法来构建UI页面和组件。
- en: Besides using C#, Blazor provides JavaScript interoperability to call JavaScript
    code from C# and vice versa. That means that we can use existing JavaScript libraries
    and write our JavaScript code whenever we need to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用C#，Blazor还提供了JavaScript互操作性，可以从C#调用JavaScript代码，反之亦然。这意味着我们可以在需要时使用现有的JavaScript库并编写我们的JavaScript代码。
- en: Writing C# and sharing code between server and client applications is a huge
    advantage for a .NET developer. ABP also takes advantage of this and shares the
    infrastructure between the MVC/Razor Pages UI and Blazor UI as much as possible.
    You will see that many services are very similar to the MVC/Razor Pages UI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器和客户端应用程序之间编写C#和共享代码对于.NET开发者来说是一个巨大的优势。ABP也利用了这一点，尽可能地在MVC/Razor Pages UI和Blazor
    UI之间共享基础设施。您会发现许多服务与MVC/Razor Pages UI非常相似。
- en: 'As a .NET developer and a software company manager, I am very impressed by
    Blazor and will use it in future projects. However, that doesn''t mean it has
    no drawbacks:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET开发者和软件公司经理，我对Blazor印象深刻，并将将其用于未来的项目。然而，这并不意味着它没有缺点：
- en: The bundle size, initial load time, and runtime performance are worse than its
    JavaScript competitors, such as Angular and React. However, Microsoft is investing
    in Blazor and working hard to improve its performance. For example, **Ahead-of-Time**
    (**AOT**) compilation has been introduced with .NET 6.0.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包大小、初始加载时间和运行时性能比其JavaScript竞争对手，如Angular和React，更差。然而，微软正在投资Blazor并努力提高其性能。例如，.NET
    6.0引入了**即时编译**（**AOT**）。
- en: The UI components and ecosystem are not mature yet since Blazor is still in
    the early stages.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Blazor还处于早期阶段，UI组件和生态系统尚未成熟。
- en: Debugging is not so straightforward yet.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试目前还不是那么直接。
- en: If these drawbacks are tolerable for your projects, you can definitely start
    using Blazor today.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些缺点对您的项目可以容忍，您今天就可以开始使用Blazor。
- en: Interestingly, Blazor has two kinds of runtime models. Until now, I have mostly
    talked about **Blazor WebAssembly**. The second model is called **Blazor Server**.
    While the component development model is identical, the hosting logic and the
    runtime model are completely different.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Blazor有两种运行时模型。到目前为止，我主要谈论的是**Blazor WebAssembly**。第二种模型称为**Blazor Server**。虽然组件开发模型是相同的，但托管逻辑和运行时模型完全不同。
- en: With Blazor WebAssembly, .NET code runs in the browser on the Mono runtime,
    and we don't have to run .NET on the server side. A small initializer JavaScript
    code downloads the standard .NET **Dynamic Link Libraries** (**DLLs**) and runs
    them in the browser. This model is similar to, and a direct competitor of, Angular
    and React because it runs the client-side logic completely in the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blazor WebAssembly，.NET代码在浏览器上的Mono运行时中运行，我们不必在服务器端运行.NET。一小段初始化JavaScript代码下载标准的.NET
    **动态链接库**（**DLL**）并在浏览器中运行。这种模式类似于，并且是Angular和React的直接竞争对手，因为它在浏览器中完全运行客户端逻辑。
- en: On the other hand, Blazor Server runs .NET code completely on the server. It
    establishes a real-time SignalR connection between the client and the server.
    The browser runs JavaScript and communicates to the server over that SignalR connection.
    It sends events to the server, and the server executes the necessary .NET code
    and sends **Document Object Model** (**DOM**) changes to the browser. Finally,
    the browser applies the DOM changes to the UI.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Blazor Server在服务器上完全运行.NET代码。它建立了客户端和服务器之间的实时SignalR连接。浏览器运行JavaScript并通过该SignalR连接与服务器通信。它向服务器发送事件，服务器执行必要的.NET代码并将**文档对象模型**（**DOM**）更改发送到浏览器。最后，浏览器将DOM更改应用到UI上。
- en: The Blazor Server model has a pretty faster initial load time compared to Blazor
    WebAssembly. However, it communicates to the server for all events and DOM changes,
    so we need a good and stable connection between the server and the client.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与Blazor WebAssembly相比，Blazor Server模型具有更快的初始加载时间。然而，它需要与服务器通信以处理所有事件和DOM更改，因此我们需要服务器和客户端之间有一个良好且稳定的连接。
- en: My purpose in this book is not to provide a complete introduction, overview,
    and use cases of Blazor but to give a short enough introduction to understanding
    what it is. Also, this chapter will focus on Blazor WebAssembly, but most of the
    topics are applicable to Blazor Server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中的目的不是提供Blazor的完整介绍、概述和使用案例，而是提供一个足够简短的介绍，以便理解它是什么。此外，本章将重点介绍Blazor WebAssembly，但大多数主题都适用于Blazor
    Server。
- en: Now, we can start ABP's Blazor integration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始ABP的Blazor集成。
- en: Getting started with the ABP Blazor UI
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用ABP Blazor UI
- en: 'There are two ways to start a new project using ABP''s startup solution templates.
    You can either download it from [https://abp.io/get-started](https://abp.io/get-started)
    or create it using the ABP CLI. I will use the CLI approach in this book. If you
    haven''t installed it yet, open a command-line terminal and execute the following
    command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ABP的启动解决方案模板启动新项目有两种方式。您可以从[https://abp.io/get-started](https://abp.io/get-started)下载它，或者使用ABP
    CLI创建它。本书中我将使用CLI方法。如果您尚未安装它，请打开命令行终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can create a new solution using the `abp new` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`abp new`命令创建一个新的解决方案：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`DemoApp` is the solution name in this example. I''ve passed the `-u blazor`
    parameter to specify Blazor WebAssembly. If you want to use Blazor Server, you
    can specify the parameter as `-u blazor-server`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemoApp`是本例中的解决方案名称。我已通过传递`-u blazor`参数来指定Blazor WebAssembly。如果您想使用Blazor
    Server，可以将参数指定为`-u blazor-server`。'
- en: 'I haven''t specified a database provider, so it uses Entity Framework Core
    by default (specify the `-d mongodb` parameter if you want to use MongoDB). After
    creating the solution, we need to create the initial database migration. As a
    first step, we should execute the following command in the `src/DemoApp.DbMigrator`
    directory:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我尚未指定数据库提供程序，因此默认使用Entity Framework Core（如果想要使用MongoDB，请指定`-d mongodb`参数）。在创建解决方案后，我们需要创建初始数据库迁移。作为第一步，我们应该在`src/DemoApp.DbMigrator`目录中执行以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command creates the initial code-first migration and applies against the
    database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建初始的代码优先迁移并将其应用于数据库。
- en: 'The solution contains two applications:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案包含两个应用程序：
- en: The first one is the server (backend) application that hosts the HTTP APIs and
    provides the authentication UI.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个服务器（后端）应用程序，它托管HTTP API并提供身份验证UI。
- en: The second application is the frontend Blazor WebAssembly application that contains
    the application UI and communicates to the server.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个应用程序是包含应用程序UI并与服务器通信的前端Blazor WebAssembly应用程序。
- en: So, we first run the `DemoApp.HttpApi.Host` server application for this example.
    Then, we can run the `DemoApp.Blazor` Blazor application to run the UI. You can
    click on the `admin` as the username and `1q2w3E*` as the password to log in to
    the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先运行此示例的`DemoApp.HttpApi.Host`服务器应用程序。然后，我们可以运行`DemoApp.Blazor` Blazor应用程序来运行UI。您可以使用`admin`作为用户名和`1q2w3E*`作为密码登录到应用程序。
- en: I won't dig into the details of the application, since we've done it already
    in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting Started with
    ABP Framework*. The next section explains how the user is authenticated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨应用程序的细节，因为我们已经在[*第2章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)中做了介绍，即*使用ABP框架入门*。下一节将解释用户是如何进行身份验证的。
- en: Authenticating the user
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: '**OpenID Connect** (**OIDC**) is Microsoft''s suggested way to authenticate
    Blazor WebAssembly applications. ABP follows that suggestion and provides it as
    preconfigured in the startup solution.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID Connect**（**OIDC**）是Microsoft建议用于身份验证Blazor WebAssembly应用程序的方法。ABP遵循这一建议，并在启动解决方案中预先配置了它。'
- en: The Blazor application doesn't contain login, register, or other authentication-related
    UI pages. It uses the **Authorization Code** flow with **Proof Key for Code Exchange**
    (**PKCE**) enabled to redirect the user to the server application. The server
    handles all the authentication logic and redirects the user back to the Blazor
    application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor应用程序不包含登录、注册或其他与身份验证相关的UI页面。它使用启用了**证明密钥用于代码交换**（**PKCE**）的**授权代码**流将用户重定向到服务器应用程序。服务器处理所有身份验证逻辑并将用户重定向回Blazor应用程序。
- en: 'The authentication configuration is stored in the `wwwroot/appsettings.json`
    file of the Blazor application. See the following example configuration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证配置存储在Blazor应用程序的`wwwroot/appsettings.json`文件中。请参阅以下示例配置：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `Authority` is the backend server application's root URL. `ClientId` is
    the name of the Blazor application that is known by the server. Finally, `ResponseType`
    specifies the authorization code flow.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Authority`是后端服务器应用程序的根URL。`ClientId`是服务器所知的Blazor应用程序的名称。最后，`ResponseType`指定了授权代码流。
- en: 'This configuration is used in the module class, the `DemoAppBlazorModule` class
    for this example, as shown in the following code block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置在模块类中使用，例如本例中的`DemoAppBlazorModule`类，如下面的代码块所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`AuthServer` is the key that matches the configuration key. If you want to
    customize the authentication options, these are the points you need to start from.
    For example, you can revise the requested scopes or change the OIDC configuration.
    For more information about Blazor WebAssembly authentication, please refer to
    Microsoft''s documentation: [https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthServer`是匹配配置密钥的关键。如果您想自定义身份验证选项，这些就是您需要从这些点开始的地方。例如，您可以修改请求的作用域或更改OIDC配置。有关Blazor
    WebAssembly身份验证的更多信息，请参阅Microsoft的文档：[https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/)。'
- en: In the next section, I will introduce the theming system for the Blazor UI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将介绍Blazor UI的主题系统。
- en: Understanding the theming system
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解主题系统
- en: ABP provides a theming system for the Blazor UI, as explained when we covered
    the MVC/Razor Pages UI in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*. The theme system brings flexibility, so we can
    develop our applications and modules without depending on a particular UI theme/style.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ABP为Blazor UI提供了一套主题系统，正如我们在介绍MVC/Razor Pages UI时所述[*第12章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)，*使用MVC/Razor
    Pages*。主题系统带来了灵活性，因此我们可以开发我们的应用程序和模块，而无需依赖于特定的UI主题/样式。
- en: All of the ABP themes for the Blazor UI use a set of base libraries. The fundamental
    base library is Bootstrap, whose components are designed to work with JavaScript.
    Fortunately, some component libraries wrap the Bootstrap components and provide
    a simpler .NET API, which is more suitable for use in Blazor applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有ABP Blazor UI主题都使用一组基础库。基本基础库是Bootstrap，其组件旨在与JavaScript一起使用。幸运的是，一些组件库封装了Bootstrap组件，并提供了一个更简单的.NET
    API，这更适合在Blazor应用程序中使用。
- en: One of these component libraries is **Blazorise**. It is actually an abstraction
    library and can work with multiple providers such as Bootstrap, Bulma, and Ant
    Design. ABP startup templates use the Bootstrap provider of the Blazorise library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件库之一是**Blazorise**。实际上，它是一个抽象库，可以与多个提供者（如Bootstrap、Bulma和Ant Design）一起工作。ABP启动模板使用Blazorise库的Bootstrap提供者。
- en: 'You can learn more about Blazorise and see the components in action on its
    website: [https://blazorise.com](https://blazorise.com). The following figure
    is a screenshot from the form components demo:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其网站上了解更多关于Blazorise的信息，并查看组件的实际应用：[https://blazorise.com](https://blazorise.com)。以下图是表单组件演示的截图：
- en: '![Figure 13.1 – Blazorise demo: form components'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – Blazorise演示：表单组件'
- en: '](img/Figure_13.01_B17287.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.01_B17287.jpg)'
- en: 'Figure 13.1 – Blazorise demo: form components'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Blazorise演示：表单组件
- en: Besides the Blazorise library, the ABP Blazor UI uses **Font Awesome** as the
    CSS font icon library. So, any module or application can use these libraries on
    their pages without an explicit dependency.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Blazorise库之外，ABP Blazor UI还使用**Font Awesome**作为CSS字体图标库。因此，任何模块或应用程序都可以在其页面上使用这些库，而无需显式依赖。
- en: The UI theme is responsible for rendering the layout, including the header,
    menu, toolbar, page alerts, and footer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: UI主题负责渲染布局，包括页眉、菜单、工具栏、页面警报和页脚。
- en: In the next section, we will see how to add new items to the main menu.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何向主菜单添加新项目。
- en: Working with menus
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用菜单
- en: Menu management in the ABP Blazor UI is very similar to the ABP MVC/Razor Pages
    UI, which was covered in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ABP Blazor UI中的菜单管理与ABP MVC/Razor Pages UI中的菜单管理非常相似，这在[*第12章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)中有所介绍，即*使用MVC/Razor
    Pages*。
- en: 'We use `AbpNavigationOptions` to add contributors to the menu system. ABP executes
    all the contributors to build the menu dynamically. The startup solution includes
    a menu contributor and is added to `AbpNavigationOptions` as per the following
    example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AbpNavigationOptions`向菜单系统添加贡献者。ABP执行所有贡献者以动态构建菜单。启动解决方案包括一个菜单贡献者，并按照以下示例添加到`AbpNavigationOptions`中：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`DemoAppMenuContributor` is a class that implements the `IMenuContributor`
    interface. The `IMenuContributor` interface defines the `ConfigureMenuAsync` method,
    which we should implement as shown in the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemoAppMenuContributor`是一个实现`IMenuContributor`接口的类。`IMenuContributor`接口定义了`ConfigureMenuAsync`方法，我们应该按照以下示例实现：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are two standard menu names defined as constants in the `StandardMenus`
    class (in the `Volo.Abp.UI.Navigation` namespace):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StandardMenus`类（在`Volo.Abp.UI.Navigation`命名空间中）中定义了两个标准菜单名称作为常量：
- en: '`Main`: The main menu of the application.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main`：应用程序的主菜单。'
- en: '`User`: The user context menu. It is opened when you click your username on
    the header.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：用户上下文菜单。当您在页眉上点击您的用户名时，它会打开。'
- en: 'So, the preceding example checks the menu name and adds items only to the main
    menu. The following code block adds a new menu item to the main menu:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的示例检查菜单名称，并且只向主菜单添加项目。以下代码块向主菜单添加一个新菜单项：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can resolve services from dependency injection using the `context.ServiceProvider`
    object. The `context.GetLocalizer` method is a shortcut to resolve an `IStringLocalizer<T>`
    instance. Similarly, we can use the `context.IsGrantedAsync` shortcut method to
    check the permission of the current user, as shown in the following code block:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`context.ServiceProvider`对象从依赖注入中解析服务。`context.GetLocalizer`方法是一个用于解析`IStringLocalizer<T>`实例的快捷方式。同样，我们可以使用`context.IsGrantedAsync`快捷方法来检查当前用户的权限，如以下代码块所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Menu items can be nested. The following example adds a `Crm` menu item and
    an `Orders` menu item under it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项可以嵌套。以下示例在`Crm`菜单项下添加了一个`Orders`菜单项：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I've called `AddItem` on the first `ApplicationMenuItem` object to add a child
    item. You can do the same for the `Orders` menu item to build deeper menus.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第一个`ApplicationMenuItem`对象上调用`AddItem`以添加子项。您可以为`Orders`菜单项做同样的事情以构建更深的菜单。
- en: We've used localization and authorization services while creating menu items.
    In the next section, we will see how to use these services in other parts of our
    Blazor application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建菜单项时使用了本地化和授权服务。在下一节中，我们将看到如何在Blazor应用程序的其他部分中使用这些服务。
- en: Using the basic services
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本服务
- en: In this section, I will show you how to use some fundamental services in Blazor
    applications. As you will see, they are almost the same as the server-side services
    that we covered in earlier chapters. Let's start with the authorization service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何在Blazor应用程序中使用一些基本服务。正如您将看到的，它们几乎与我们在早期章节中介绍的服务器端服务相同。让我们从授权服务开始。
- en: Authorizing the users
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权用户
- en: We typically use authorization in Blazor applications to hide/disable some pages,
    components, and functionalities on the user interface. While the server always
    checks the same authorization rules for security, client-side authorization checks
    provide a better user experience.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在Blazor应用程序中使用授权来隐藏/禁用一些页面、组件和功能。虽然服务器始终检查相同的授权规则以确保安全，但客户端授权检查提供了更好的用户体验。
- en: '`IAuthorizationService` is used to programmatically check permissions/policies,
    as on the server side. You can inject and use its methods, as shown in the following
    example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAuthorizationService`用于以编程方式检查权限/策略，就像在服务器端一样。您可以根据以下示例注入和使用其方法：'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`AuthorizationService` has different ways to work. Please refer to the *Working
    with authorization and permission systems* section of [*Chapter 7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213),
    *Exploring Cross-Cutting Concerns*, to learn more about the authorization system.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationService`有不同的工作方式。请参阅[*第7章*](B17287_07_Epub_AM.xhtml#_idTextAnchor213)中关于*与授权和权限系统一起工作*的部分，以了解更多关于授权系统的信息。'
- en: The component in the preceding example is inherited from the `AbpComponentBase`
    class. We can directly use the `AuthorizationService` property without manual
    injection since the `AbpComponentBase` class pre-injects it for us. The `AuthorizationService`
    property type is `IAuthorizationService`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，该组件是从`AbpComponentBase`类继承的。由于`AbpComponentBase`类为我们预先注入了它，我们可以直接使用`AuthorizationService`属性而无需手动注入。`AuthorizationService`属性类型是`IAuthorizationService`。
- en: 'If you don''t inherit from the `AbpComponentBase` class, you can inject it
    using the `[Inject]` attribute:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有从`AbpComponentBase`类继承，你可以使用`[Inject]`属性来注入它：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can use the same `IAuthorizationService` on the view side of your Razor
    components when you need it. However, there are some alternative ways to make
    your application code cleaner. For example, you can use the `[Authorize]` attribute
    on a component to make it available only for authenticated users:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要时，你可以在Razor组件的视图侧使用相同的`IAuthorizationService`。然而，有一些替代方法可以使你的应用程序代码更简洁。例如，你可以在组件上使用`[Authorize]`属性，使其仅对认证用户可用：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `[Authorize]` attribute works similarly to the server side. You can pass
    a policy/permission name to check for a specific permission, as shown in the following
    example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Authorize]`属性与服务器端类似。你可以在以下示例中传递策略/权限名称来检查特定权限：'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is typical to show a part of the UI if the user has a specific permission.
    The following example uses the `AuthorizeView` element to show a message if the
    current user has permission to edit orders:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户具有特定的权限，通常会显示UI的一部分。以下示例使用`AuthorizeView`元素，如果当前用户有权限编辑订单，则显示消息：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this way, you can conditionally render the action buttons or other parts
    of the UI.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以有条件地渲染操作按钮或其他UI部分。
- en: 'ABP is 100% compatible with Blazor''s authorization system, so you can refer
    to Microsoft''s documentation to see more examples and details: [https://docs.microsoft.com/en-us/aspnet/core/blazor/security](https://docs.microsoft.com/en-us/aspnet/core/blazor/security).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ABP与Blazor的授权系统100%兼容，因此你可以参考Microsoft的文档来查看更多示例和详细信息：[https://docs.microsoft.com/en-us/aspnet/core/blazor/security](https://docs.microsoft.com/en-us/aspnet/core/blazor/security)。
- en: In the next section, we will learn how to use the localization system, another
    common UI service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用本地化系统，这是另一个常见的UI服务。
- en: Localizing the user interface
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化用户界面
- en: Blazor applications share the same API for localizing texts. We can inject and
    use the `IStringLocalizer<T>` service to get the localized texts for the current
    language.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor应用程序使用相同的API进行文本本地化。我们可以注入并使用`IStringLocalizer<T>`服务来获取当前语言的本地化文本。
- en: 'The following Razor component uses the `IStringLocalizer<T>` service:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Razor组件使用了`IStringLocalizer<T>`服务：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the standard `@inject` directive and specify the localization resource
    type in the generic `IStringLocalizer<T>` interface. The same interface can also
    be injected and used in any service in your application. Please refer to the *Localizing
    the user interface* section of [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*, to learn about working with the localization
    system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标准的`@inject`指令，并在泛型`IStringLocalizer<T>`接口中指定本地化资源类型。相同的接口也可以注入并用于应用程序中的任何服务。请参阅[*第8章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)的*本地化用户界面*部分，*使用ABP的功能和服务*，了解如何与本地化系统一起工作。
- en: Next, we will learn to get information about the current user in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在下一节学习如何获取当前用户的信息。
- en: Accessing the current user
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问当前用户
- en: 'You sometimes may need to know the current user''s username, email address,
    and other details in your application. We use the `ICurrentUser` service to access
    the current user, as on the server side. The following example component renders
    a welcome message by the current user''s name:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时可能需要在应用程序中知道当前用户的用户名、电子邮件地址和其他详细信息。我们使用`ICurrentUser`服务来访问当前用户，就像在服务器端一样。以下示例组件通过当前用户的名称渲染欢迎信息：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In addition to standard properties such as `Name`, `Surname`, `UserName`, and
    `Email`, you can use the `ICurrentUser.FindClaimValue(...)` method to get custom
    claims issued by the server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Name`、`Surname`、`UserName`和`Email`等标准属性外，你还可以使用`ICurrentUser.FindClaimValue(...)`方法来获取服务器颁发的自定义声明。
- en: I've introduced the basic ABP Blazor services typically used by all the applications.
    I kept them short since the APIs are almost the same with the server side, and
    we've already covered them in detail in previous chapters. In the next section,
    I will continue with the UI services used to inform the user.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了所有应用程序通常使用的ABP Blazor基本服务。我使它们保持简短，因为API几乎与服务器端相同，而且我们已经在之前的章节中详细介绍了它们。在下一节中，我将继续介绍用于通知用户的UI服务。
- en: Using the UI services
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI服务
- en: It is common in every application to show messages, notifications, and alerts
    to users to inform or warn them. In the next sections, I will introduce ABP's
    built-in APIs for these services.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序中，向用户显示消息、通知和警报以通知或警告他们是很常见的。在接下来的部分中，我将介绍ABP为这些服务内置的API。
- en: Showing message boxes
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示消息框
- en: Message boxes are used to show blocking messages or confirmation dialogs to
    the user. The user clicks on the **Ok** button to disable the message or clicks
    the **Yes** or **Cancel** buttons to make a decision on configuration dialogs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框用于向用户显示阻塞消息或确认对话框。用户点击**确定**按钮来禁用消息，或者点击**是**或**取消**按钮来对配置对话框做出决定。
- en: 'There are five types of messages – `Info`, `Success`, `Warn`, `Error`, and
    `Confirm`. The following example shows a `Success` message sent to the user:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种类型的消息 – `信息`、`成功`、`警告`、`错误`和`确认`。以下示例显示了发送给用户的`成功`消息：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Message` property, in this example, is coming from the `AbpComponentBase`
    class (`DemoAppComponentBase` inherits it), and its type is `IUiMessageService`.
    Alternatively, you can inject `IUiMessageService` manually for your components,
    pages, or services. All the `IUiMessageService` methods can take an extra `title`
    parameter and an `options` action to customize the dialog.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`Message`属性来自`AbpComponentBase`类（`DemoAppComponentBase`继承自它），其类型为`IUiMessageService`。或者，您可以为您的组件、页面或服务手动注入`IUiMessageService`。所有`IUiMessageService`方法都可以接受额外的`title`参数和`options`操作来自定义对话框。
- en: 'The following figure shows the result of the preceding example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面示例的结果：
- en: '![Figure 13.2 – A simple success message without a title'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – 一个没有标题的简单成功消息'
- en: '](img/Figure_13.02_B17287.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.02_B17287.jpg)'
- en: Figure 13.2 – A simple success message without a title
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 一个没有标题的简单成功消息
- en: 'The following example shows a confirmation dialog sent to the user and takes
    action if the user clicks the **Yes** button:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了发送给用户的确认对话框，如果用户点击**是**按钮，则采取行动：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Confirm` method returns a `bool` value, so you can see whether the user
    has accepted the dialog message. The following figure shows the result of this
    example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Confirm`方法返回一个`bool`值，因此您可以看到用户是否接受了对话框消息。以下图显示了此示例的结果：'
- en: '![Figure 13.3 – A confirmation dialog'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – 确认对话框'
- en: '](img/Figure_13.03_B17287.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.03_B17287.jpg)'
- en: Figure 13.3 – A confirmation dialog
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 确认对话框
- en: The next section explains how to show a non-blocking information message to
    the user.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解释如何向用户显示非阻塞的信息消息。
- en: Showing notifications
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示通知
- en: Messages boxes focus users on the message. They should click the **Ok** button
    to return to the application UI. On the other hand, notifications are non-blocking
    informative messages. They are shown in the bottom-right corner of the screen
    and automatically disappear after a few seconds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框将用户的注意力集中在消息上。他们应该点击**确定**按钮返回到应用程序UI。另一方面，通知是非阻塞的信息消息。它们显示在屏幕的右下角，并在几秒钟后自动消失。
- en: 'There are four types of notifications – `Info`, `Success`, `Warn`, and `Error`.
    The following example shows a confirmation dialog and shows a `Success` notification
    if the user accepts the confirmation message:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的通知 – `信息`、`成功`、`警告`和`错误`。以下示例显示了一个确认对话框，如果用户接受确认消息，则显示`成功`通知：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Notify` property comes from the `AbpComponentBase` base class. You can
    inject the `IUiNotificationService` interface and use it anywhere to show notifications
    on the UI. All the notification methods can take an extra `title` parameter and
    an `options` action to customize the dialog. The following figure shows the result
    of the `Notify.Success` method used in the preceding code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notify`属性来自`AbpComponentBase`基类。您可以将`IUiNotificationService`接口注入并用于任何地方来在UI上显示通知。所有通知方法都可以接受额外的`title`参数和`options`操作来自定义对话框。以下图显示了在前面代码块中使用的`Notify.Success`方法的结果：'
- en: '![Figure 13.4 – An example notification message'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 – 一个示例通知消息'
- en: '](img/Figure_13.04_B17287.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.04_B17287.jpg)'
- en: Figure 13.4 – An example notification message
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 一个示例通知消息
- en: The next section introduces alerts, another way to show a message to the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分介绍了警报，这是向用户显示消息的另一种方式。
- en: Showing alerts
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示警报
- en: Using alerts is a sticky way to show a non-blocking message to the user. The
    user, optionally, can dismiss the alert.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用警报是一种粘性的方式来向用户显示非阻塞消息。用户可以选择忽略警报。
- en: 'There are four types of alerts – `Info`, `Success`, `Warning`, and `Danger`.
    The following example shows a `Success` alert sent to the user:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的提示信息 – `Info`、`Success`、`Warning`和`Danger`。以下示例展示了发送给用户的`Success`提示信息：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, I've used the `Alerts` property coming from the base class.
    You can always inject the `IAlertManager` service and use it like `IAlertManager.Alerts.Success(…)`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了来自基类的`Alerts`属性。你总是可以注入`IAlertManager`服务并像`IAlertManager.Alerts.Success(…)`一样使用它。
- en: 'All of the alert methods take `text` (required), a `title` (optional), and
    `dismissible` (optional and default – `true`) parameters. If an alert is dismissible,
    then the user can make it disappear by clicking the **X** button. The following
    figure shows the alert created in the preceding example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的提示方法都接受`text`（必需）、`title`（可选）和`dismissible`（可选，默认为`true`）参数。如果一个提示信息是可关闭的，那么用户可以通过点击**X**按钮使其消失。以下图显示了前面例子中创建的提示信息：
- en: '![Figure 13.5 – A Success alert message'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 – 成功提示消息'
- en: '](img/Figure_13.05_B17287.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.05_B17287.jpg)'
- en: Figure 13.5 – A Success alert message
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 成功提示消息
- en: Alerts are rendered by the theme on top of the page content. Besides the standard
    `Info`, `Success`, `Warning`, and `Danger` methods, you can use the `Add` method
    by specifying `AlertType` to use all Bootstrap styles, such as `Primary`, `Secondary`,
    or `Dark`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提示信息是通过主题在页面内容上方渲染的。除了标准的`Info`、`Success`、`Warning`和`Danger`方法外，你可以通过指定`AlertType`来使用所有Bootstrap样式，如`Primary`、`Secondary`或`Dark`。
- en: You've now learned three ways to show information messages to the user. In the
    next section, we will investigate how the Blazor application consumes the HTTP
    APIs of the server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了三种向用户展示信息消息的方法。在下一节中，我们将探讨Blazor应用程序如何消费服务器的HTTP API。
- en: Consuming HTTP APIs
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费HTTP API
- en: You can use the standard `HttpClient` to manually set up and perform an HTTP
    request to the server. However, ABP provides C# client proxies to call HTTP API
    endpoints easily. You can directly consume your application services from the
    Blazor UI and let ABP Framework handle the HTTP API calls for you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的`HttpClient`手动设置和执行对服务器的HTTP请求。然而，ABP提供了C#客户端代理，可以轻松调用HTTP API端点。你可以直接从Blazor
    UI消费你的应用服务，并让ABP框架为你处理HTTP API调用。
- en: 'Let''s assume that we have an application service interface, as shown in the
    following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用服务接口，如下例所示：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Application service interfaces are defined in the `Application.Contracts` project
    (the `DemoApp.Application.Contracts` project for the example solution I've created).
    The Blazor application has a reference to that project. This way, we can use the
    `ITestAppService` interface on the client side.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务接口定义在`Application.Contracts`项目中（对于我创建的示例解决方案，是`DemoApp.Application.Contracts`项目）。Blazor应用程序引用了这个项目。这样，我们就可以在客户端使用`ITestAppService`接口。
- en: 'Application services are implemented in the `Application` project (the `DemoApp.Application`
    project for the example solution I''ve created). We can simply implement the `ITestAppService`
    interface, as shown in the following code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务在`Application`项目中实现（对于我创建的示例解决方案，是`DemoApp.Application`项目）。我们可以简单地实现`ITestAppService`接口，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can directly inject `ITestAppService` into any page/component, as with
    any other local service, and call its methods, just like a standard method call:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接将`ITestAppService`注入到任何页面/组件中，就像注入任何其他本地服务一样，并调用其方法，就像标准的函数调用一样：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, I used the standard `[Inject]` attribute on top of the `TestAppService`
    property to tell Blazor to inject it for me. Then, I've overridden it in the `OnInitializedAsync`
    method to call the `GetDataAsync` method. As we know, the `OnInitializedAsync`
    method is called just after the component/page is initially rendered and ready
    to work.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在`TestAppService`属性上方使用了标准的`[Inject]`属性来告诉Blazor为我注入它。然后，我在`OnInitializedAsync`方法中重写了它来调用`GetDataAsync`方法。正如我们所知，`OnInitializedAsync`方法是在组件/页面最初渲染并准备好工作后立即被调用的。
- en: 'It''s that easy. When we call the `GetDataAsync` method, ABP actually makes
    an HTTP API call to the server by handling all the complexity, including authentication,
    error handling, and JSON serialization. It reads the server''s root URL from the
    `RemoteServices` configuration in the `wwwroot/appsettings.json` file of the Blazor
    project. An example configuration is shown in the following code block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到这种程度。当我们调用 `GetDataAsync` 方法时，ABP 实际上通过处理所有复杂性（包括身份验证、错误处理和 JSON 序列化）向服务器发出
    HTTP API 调用。它从 Blazor 项目的 `wwwroot/appsettings.json` 文件中的 `RemoteServices` 配置中读取服务器的根
    URL。以下是一个示例配置代码块：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this section, I've used ABP's dynamic C# client proxy approach to consume
    HTTP APIs from the Blazor application. We will return to this topic in [*Chapter
    14*](B17287_14_Epub_AM.xhtml#_idTextAnchor429), *Building HTTP APIs and Real-Time
    Services*, by also introducing the static C# client proxies.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我使用了 ABP 的动态 C# 客户端代理方法来从 Blazor 应用程序中消费 HTTP API。我们将在[*第 14 章*](B17287_14_Epub_AM.xhtml#_idTextAnchor429)
    *构建 HTTP API 和实时服务*中回到这个话题，同时介绍静态 C# 客户端代理。
- en: The next section will explore how we can add script and style files to our Blazor
    applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨我们如何将脚本和样式文件添加到我们的 Blazor 应用程序中。
- en: Working with global scripts and styles
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理全局脚本和样式
- en: Importing script and style files for the Blazor Server UI is the same as the
    MVC/Razor Pages UI for ABP Framework. You can refer to [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, to learn how to use it. This section is based
    on Blazor WebAssembly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Blazor Server UI 的脚本和样式文件与 ABP 框架的 MVC/Razor Pages UI 相同。您可以参考[*第 12 章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)
    *使用 MVC/Razor Pages*来了解如何使用它。本节基于 Blazor WebAssembly。
- en: 'Blazor WebAssembly is a Single-Page Application and it has a single entry point
    by default. The `index.html` file is in the `wwwroot` folder, as shown in the
    following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 是一个单页应用程序，默认情况下只有一个入口点。`index.html` 文件位于 `wwwroot` 文件夹中，如下所示：
- en: '![Figure 13.6 – The index.html file in the wwwroot folder'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.6 – wwwroot 文件夹中的 index.html 文件'
- en: '](img/Figure_13.06_B17287.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.06_B17287.jpg)'
- en: Figure 13.6 – The index.html file in the wwwroot folder
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – wwwroot 文件夹中的 index.html 文件
- en: '`index.html` is a plain HTML file. The server sends it to the browser without
    any processing. Remember that a simple static file server can serve a Blazor WebAssembly
    application. The browser first loads the `index.html` document and then loads
    the styles and scripts imported by this document.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 是一个纯 HTML 文件。服务器在未经任何处理的情况下将其发送到浏览器。请记住，一个简单的静态文件服务器可以提供 Blazor
    WebAssembly 应用程序。浏览器首先加载 `index.html` 文档，然后加载此文档导入的样式和脚本。'
- en: 'If you open the `index.html` document, you will see a part within the `ABP:Styles`
    comments, as shown in the following code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开 `index.html` 文档，您将看到 `ABP:Styles` 注释内的一部分，如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code part (including the comments) is automatically created (and then
    updated) by the ABP CLI when you execute the following command in the root folder
    of the Blazor project:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码（包括注释）是由 ABP CLI 在您在 Blazor 项目的根目录中执行以下命令时自动创建（并更新）的：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you execute this command, it creates (or regenerates) the global style
    bundle. This bundle contains all the necessary styles, including the .NET runtime,
    Blazor, and other used libraries, in a minified format. Whenever you add a new
    Blazor-related ABP NuGet package/module into your application, you rerun the `abp
    bundle` command and it regenerates the bundle with the necessary dependencies
    included.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此命令时，它创建（或重新生成）全局样式包。这个包包含所有必要的样式，包括 .NET 运行时、Blazor 和其他使用的库，以压缩格式。每次您将新的与
    Blazor 相关的 ABP NuGet 包/模块添加到您的应用程序中时，您都需要重新运行 `abp bundle` 命令，并包含必要的依赖项重新生成包。
- en: 'ABP''s `bundle` command does a great job. When installing a module, you don''t
    need to know its global script files or extra dependencies. Just run this command,
    and you have the updated, production-ready global bundle file. Every module contributes
    its own dependencies into that bundle, and then ABP generates the bundle by respecting
    the module dependency order. To manipulate the bundle, you should define a class
    that implements the `IBundleContributor` interface. The Blazor project in the
    startup solution template already contains a bundle contributor, as shown in the
    following code block:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的 `bundle` 命令做得很好。当安装一个模块时，您不需要知道它的全局脚本文件或额外依赖项。只需运行此命令，您就有了一个更新后的、生产就绪的全局包文件。每个模块都会将其自己的依赖项贡献到该包中，然后
    ABP 通过尊重模块依赖顺序来生成包。要操作包，您应该定义一个实现 `IBundleContributor` 接口的类。启动解决方案模板中的 Blazor
    项目已经包含了一个包贡献者，如下面的代码块所示：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`AddScripts` and `AddStyles` methods are used to add JavaScript and CSS files
    to the global bundles. You can also remove or change an existing file (which was
    added by a package your application depends on) using the `context.BundleDefinitions`
    collection, but that''s rarely needed. Here, the `excludeFromBundle` parameter
    adds the `main.css` file separately from the global bundle. You can remove that
    parameter to include it in the `global.css` bundle file.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddScripts` 和 `AddStyles` 方法用于向全局包添加 JavaScript 和 CSS 文件。您还可以使用 `context.BundleDefinitions`
    集合删除或更改现有文件（由您的应用程序依赖的包添加），但这很少需要。在这里，`excludeFromBundle` 参数将 `main.css` 文件单独添加到全局包之外。您可以移除该参数以将其包含在
    `global.css` 包文件中。'
- en: 'Similar to the style bundle, the `index.html` file contains an `ABP:Scripts`
    part, as shown in the following code block:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于样式包，`index.html` 文件包含一个 `ABP:Scripts` 部分，如下面的代码块所示：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, this code part is created (and updated) by the ABP CLI with the `abp
    bundle` command. If you want to include files, you can do it inside the `AddScripts`
    method of your bundle contributor class. The paths of the files are considered
    relative to the `wwwroot` folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这段代码部分是由 ABP CLI 使用 `abp bundle` 命令创建（并更新）的。如果您想包含文件，可以在您的包贡献者类的 `AddScripts`
    方法中完成。文件的路径被认为是相对于 `wwwroot` 文件夹的相对路径。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a quick introduction to the ABP Framework Blazor UI to understand
    its architecture and the services you will frequently use in your applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了 ABP 框架的 Blazor UI，以了解其架构以及您将在应用程序中频繁使用的服务。
- en: Authentication is one of the most challenging aspects of an application, and
    ABP provides an industry-standard solution that you can directly use in your applications.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是应用程序中最具挑战性的方面之一，ABP 提供了一个行业标准解决方案，您可以直接在您的应用程序中使用。
- en: We've learned about the services to get the current user's identity information,
    check the user's permissions, and localize the user interface. We also explored
    the services to show message boxes, notifications, and alerts to the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了获取当前用户身份信息的服务、检查用户的权限以及本地化用户界面的服务。我们还探索了向用户显示消息框、通知和警报的服务。
- en: ABP's dynamic C# client proxy system makes it super-easy to consume server-side
    HTTP APIs. Finally, you've learned how to use the global bundling system to handle
    bundling and minification in your Blazor applications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的动态 C# 客户端代理系统使得消费服务器端 HTTP API 变得非常容易。最后，您已经学习了如何使用全局打包系统来处理 Blazor 应用程序中的打包和压缩。
- en: I intentionally didn't cover two topics in this chapter. The first one is Blazor
    itself. It is a very detailed topic to cover in a single chapter of a book. I
    advise you to read Microsoft's documentation ([https://docs.microsoft.com/en-us/aspnet/core/blazor](https://docs.microsoft.com/en-us/aspnet/core/blazor))
    or purchase a dedicated book if you are new to the Blazor framework. Check out
    the book *Web Development with Blazor*, by *Jimmy Engström*, from *Packt Publishing*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意在本章中没有涵盖两个主题。第一个是 Blazor 本身。在本书的单章中涵盖这个非常详细的主题是不够的。如果您是 Blazor 框架的新手，我建议您阅读微软的文档（[https://docs.microsoft.com/en-us/aspnet/core/blazor](https://docs.microsoft.com/en-us/aspnet/core/blazor)）或购买一本专门的书籍。您可以查看由
    Packt Publishing 出版的由 Jimmy Engström 编写的《Web Development with Blazor》一书。
- en: 'The second topic I haven''t covered in this chapter is complex UI components,
    such as data tables, modals, and tabs. They are so specific to the UI kit you
    are using. ABP comes with the Blazorise library, and you can refer to its documentation
    to learn its components: [https://blazorise.com/docs](https://blazorise.com/docs).
    I also suggest going through ABP Framework''s Blazor UI tutorial to understand
    the fundamental development model with the most-used components, data tables,
    and modals: [https://docs.abp.io/en/abp/latest/Getting-Started](https://docs.abp.io/en/abp/latest/Getting-Started).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我尚未涉及的第二主题是复杂的用户界面组件，例如数据表、模态框和标签页。这些组件非常特定于你使用的UI工具包。ABP自带Blazorise库，你可以参考其文档来学习其组件：[https://blazorise.com/docs](https://blazorise.com/docs)。我还建议你通过ABP框架的Blazor
    UI教程来了解使用最常用组件（数据表和模态框）的基本开发模型：[https://docs.abp.io/en/abp/latest/Getting-Started](https://docs.abp.io/en/abp/latest/Getting-Started)。
- en: In the next chapter, we will focus on building HTTP APIs and consuming them
    in client applications. We will also look at using the SignalR library for real-time
    communication between a client and a server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于构建HTTP API并在客户端应用程序中消费它们。我们还将探讨使用SignalR库来实现客户端和服务器之间的实时通信。
