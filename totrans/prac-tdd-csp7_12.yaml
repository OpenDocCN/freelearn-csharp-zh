- en: The Legacy Problem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史代码问题
- en: This chapter is all about legacy code. If you have never had to deal with legacy
    code, count yourself lucky and know that it is coming. Some of you may be permanently
    stuck in maintenance development. Your life is legacy code. Whatever the situation,
    this chapter is all about dealing with legacy code. We want to either prevent
    legacy code from happening, or fight it back to the depths from which it came.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于历史代码。如果你从未处理过历史代码，那么你很幸运，并且知道它终将到来。有些人可能永远被困在维护开发中。你的生活就是历史代码。无论情况如何，本章都是关于处理历史代码的。我们希望要么防止历史代码的产生，要么将其反击到它起源的深处。
- en: 'In this chapter, we discuss:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论：
- en: What makes code legacy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么因素使代码成为历史代码
- en: The issues that legacy code can create
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史代码可能引发的问题
- en: How legacy code can inhibit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史代码如何阻碍测试
- en: What we can do to deal with and fight back against the legacy problem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以采取哪些措施来应对和反击历史代码问题
- en: What is legacy code?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是历史代码？
- en: Most of you have probably had to work on a dreaded legacy project. Working on
    that project is no fun; the code is a mess, and you want to find whoever wrote
    it and find out what they were thinking when they wrote it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的大多数人可能都不得不处理过令人讨厌的历史代码项目。在那个项目中工作并不有趣；代码一团糟，你想要找到编写它的人，并想知道他们在编写代码时在想什么。
- en: At some point in your career, you have been or will be that person to someone
    else. We all write code that we will not be proud of later. But why does the code
    get so bad? When does a project become legacy? Lastly, what can be done to prevent
    this?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的职业生涯中，你曾经或将会成为别人眼中的那个人。我们都会编写出自己以后不会感到自豪的代码。但为什么代码会变得如此糟糕？一个项目何时会变成历史代码？最后，我们可以做些什么来防止这种情况发生？
- en: Why does code go bad?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么代码会变坏？
- en: In short, code goes bad because we are afraid to change it. Why would the code
    not changing cause it to be bad? You would hope that, when the code was written,
    it was the best code that developer was capable of producing at the time. So,
    that code should have been good, right? This is a complicated answer, but assume,
    for the moment, that the code was something to be proud of when it was originally
    written. That still begs the question, how did it go bad?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，代码变坏是因为我们害怕改变它。为什么代码的不改变会导致它变坏？你希望，当代码被编写时，它是当时开发者能够编写出的最好的代码。所以，那应该是一段好的代码，对吧？这是一个复杂的问题，但暂时假设，当代码最初被编写时，它是一段值得骄傲的代码。但这仍然提出了一个问题，它是如何变坏的？
- en: The answer is staring you in the face. The only reason you are seeing this code
    is because it needs to change. Chances are, you are not the first person that
    has needed to make a change in this code. So, this is not the code that was written
    by a developer doing his or her best to write good code. This code was written
    by many developers. Still, each of those developers should have been doing their
    best to write good code. So, again, how did this code go bad?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 答案就在你的面前。你之所以看到这段代码，是因为它需要改变。很可能，你不是第一个需要修改这段代码的人。所以，这并不是一个开发者尽力编写好代码所编写的代码。这段代码是由许多开发者编写的。尽管如此，每个开发者都应该尽力编写好代码。那么，这段代码又是如何变坏的？
- en: This is where the fear comes in, because we are afraid to change the code. When
    we have to change it, we generally try to change the code as little as possible
    to get the requested update working. After all, we don't want to force ourselves
    or QA to do a full regression test because we refactored the whole thing, do we?
    So, we modify the code; we change the way it is expected to work. But we can't
    change the structure, and we can't modify the decisions of the developer who originally
    wrote the code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为我们害怕改变代码，所以才会产生恐惧。当我们不得不改变代码时，我们通常尽量只做最小的改动，以使所需的更新能够正常工作。毕竟，我们不想因为重构了整个代码而强迫自己或QA团队进行全面回归测试，对吧？因此，我们修改代码；我们改变它预期的工作方式。但我们不能改变其结构，也不能修改最初编写代码的开发者的决策。
- en: Over time, making these small changes and being afraid to modify the structure
    and architectural decisions of the original developer causes severe code rot.
    Soon, the code will have massive conditional statements and methods that no longer
    fit on the page. The class containing the code will grow to tens of methods and
    the file will be thousands of lines long.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，进行这些小的改动并害怕修改原始开发者的结构和架构决策，会导致严重的代码退化。很快，代码将包含大量的条件语句和方法，这些语句和方法已经无法在页面上显示。包含这些代码的类将增长到包含数十个方法，而文件长度也将达到数千行。
- en: When does a project become legacy?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个项目何时会变成历史代码？
- en: This is a question that is answered by many people in many different ways. Generally,
    an application has become legacy when no one wants to work on it anymore.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很多人以很多不同方式回答的问题。通常，当一个应用程序不再有人愿意对其进行工作时，它就变成了遗留代码。
- en: In the beginning, applications are built with a small and defined purpose. Over
    time, the scope and breadth of a system may grow beyond its original intent. When
    any change to the application causes the developer to work against what the application
    was designed for, it will cause friction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，应用程序是按照一个小而明确的目的来构建的。随着时间的推移，系统的范围和广度可能会超出其原始意图。当任何对应用程序的更改导致开发者与应用程序的设计背道而驰时，它将引起摩擦。
- en: As mentioned previously, the application design is not simply changed because
    of the fear a developer might have that the application will break. So, more and
    more cruft is added to the system. Okay, so how long does it take for this to
    happen? When do we stop hacking new modifications into the existing application
    and just rewrite it?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序的设计并不是因为开发者担心应用程序会崩溃而简单地改变。因此，越来越多的冗余代码被添加到系统中。好吧，那么这需要多长时间？我们何时停止将新的修改硬塞到现有应用程序中，而只是重新编写它？
- en: Honestly, the cruft starts getting added by the original developer as he or
    she is writing the application for the first time. When you start to work on a
    new application, or even just a new feature in an existing application, you start
    with a preliminary design in mind. Everyone does this. Some developers whiteboard
    the design or make complete **UML** (**Unified Modeling Language**) diagrams.
    Other developers just have an idea in their head to guide decisions. Either way,
    you have a design you want when you sit down to develop an application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，冗余代码是从原始开发者第一次编写应用程序时就开始添加的。当你开始开发一个新应用程序，或者甚至在现有应用程序中开发一个新功能时，你开始有一个初步的设计在心中。每个人都是这样做的。一些开发者会在白板上绘制设计或制作完整的**UML**（**统一建模语言**）图。其他开发者只是有一个在头脑中的想法来指导决策。无论如何，当你坐下来开发应用程序时，你都有一个想要的设计。
- en: How long is it before you discover an issue with your design and have to start
    modifying it? You might get one line of code in before you have to change your
    design, or you might get 75% of the way through before you discover an issue.
    This is largely determined by the complexity of the problem you are solving and
    how detailed your planning was. Regardless of the thoroughness of your planning,
    you will find an issue and have to start changing your design before the first
    QA review.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现设计问题并开始修改它需要多长时间？你可能写了一行代码就不得不改变你的设计，或者你可能完成了75%的工作才发现了问题。这很大程度上取决于你正在解决的问题的复杂性和你的计划的详细程度。无论你的计划多么周密，你都会发现一个问题，并在第一次质量审查之前开始改变你的设计。
- en: The second you make that change, you are adding cruft, so almost all of the
    time, you are working in a system that was not designed for the code that is being
    forced into it. In other words, you will probably be writing legacy code the next
    time you are at work, even if you are working on a new application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你一做出改变，就是在添加冗余代码，所以几乎所有的时候，你都在一个没有为强制放入其中的代码而设计的系统中工作。换句话说，即使你正在开发一个新应用程序，你下一次工作时可能也会编写遗留代码。
- en: Cruft, in software, is any code that is unnecessary or needlessly complex.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，冗余代码是指任何不必要的或过于复杂的代码。
- en: What can be done to prevent legacy decay?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们能做些什么来防止遗留代码的退化？
- en: 'There must be something that can be done to prevent this decay, right? The
    answer is probably predictable, given the topic of this book. But let me answer
    with a quote from Michael Feathers on the definition of legacy code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 真的必须做些什么来阻止这种退化，对吧？考虑到这本书的主题，答案可能很容易预测。但让我用迈克尔·费瑟斯关于遗留代码定义的引言来回答：
- en: To me, legacy code is simply code without tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，遗留代码就是没有测试的代码。
- en: '- Michael Feathers, Working Effectively with Legacy Code'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '- 迈克尔·费瑟斯，《与遗留代码有效工作》'
- en: As we discussed in earlier chapters, tests allow you to refactor. The ability
    to change the structure of the code is precisely what can prevent the rot and
    decay that is legacy code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的那样，测试允许你重构。改变代码结构的能力正是可以防止遗留代码的腐烂和退化。
- en: While tests can allow you to prevent legacy code from forming, be aware that
    they themselves do not prevent the legacy problem. It takes the dedication of
    every person on the team understanding that building cruft into a system is a
    negative behavior and must be avoided. If you feel yourself working against the
    design of the system, then it is your responsibility to refactor the application
    into a design that works for today's needs and is flexible enough for tomorrow's
    needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试可以防止遗留代码的形成时，请注意，它们本身并不能防止遗留问题的出现。这需要团队中每个人的奉献精神，理解将冗余引入系统是一种负面行为，必须避免。如果你感觉自己正在与系统的设计作对，那么将应用程序重构为适合今天需求且足够灵活以适应明天需求的设计就是你的责任。
- en: Making a system flexible is not as hard as you might think. Following the SOLID
    principles (discussed in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195),  *Setting
    up a JavaScript Environment*) will help to produce a maintainable and flexible
    system. Even with a flexible system, it takes discipline and determination to
    maintain a standard of recognizing and fixing friction in the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使系统灵活并不像你想象的那么困难。遵循SOLID原则（在第3章中讨论，[设置JavaScript环境](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195)），将有助于产生可维护和灵活的系统。即使是一个灵活的系统，也需要纪律和决心来维持识别和修复应用程序中摩擦的标准。
- en: The process of finding that friction could be considered **PDD** (**Pain Driven
    Development**). This concept means to do the simplest thing to solve your existing
    problem and actively recognize any friction that arises during future modifications
    to the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找这种摩擦的过程可以被认为是**PDD**（**痛苦驱动开发**）。这个概念意味着做最简单的事情来解决你现有的问题，并积极识别在将来对应用程序进行修改时出现的任何摩擦。
- en: PDD can be applied to any system, including the application, your team, and
    your personal life. Following this strategy, you will become obsessed with removing
    friction in all things, and can get a little carried away. So, it is important
    to keep in mind that you might be the only one looking for this friction, and
    the rest of the world might be ignorant to the pain they are causing themselves.
    Also, keep in mind that people do not, generally, enjoy having their ignorance
    pointed out.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PDD可以应用于任何系统，包括应用程序、你的团队和你的个人生活。遵循这个策略，你将痴迷于消除所有事物的摩擦，可能会有些过分。因此，重要的是要记住，你可能是在寻找这种摩擦的唯一一个人，而其他人可能对自身造成的痛苦一无所知。此外，记住人们通常不喜欢有人指出他们的无知。
- en: Typical issues resulting from legacy code
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由遗留代码引起的典型问题
- en: There is a reason we fear working on legacy code. But, what is it that we fear
    when working on legacy code? It's not the code itself; the code cannot harm us.
    Instead, what we fear is hearing that we have introduced a bug. The most dreaded
    word that a developer can hear. A bug means that we have failed and that we will
    have to work on the legacy code again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们害怕处理遗留代码是有原因的。但是，我们在处理遗留代码时害怕的是什么？不是代码本身；代码不会伤害我们。相反，我们害怕的是听到我们引入了错误。这是开发者最害怕听到的词。错误意味着我们失败了，我们不得不再次处理遗留代码。
- en: Exploring the types of issues we might run into while working on legacy code,
    we find several. Firstly, because we don't know the code, a change to one part
    might cause unintended side effects in a different part of the application. Another
    issue is the code could be over-optimized or written by someone who was trying
    to be clever when they wrote it. Lastly, tight coupling can make updating the
    code difficult.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 探索在处理遗留代码时可能遇到的问题类型，我们发现有几个。首先，因为我们不了解代码，对某一部分的更改可能会在应用程序的另一个部分产生意外的副作用。另一个问题是代码可能过度优化，或者是由试图在编写时显得聪明的人编写的。最后，紧密耦合可能会使更新代码变得困难。
- en: Unintended side effects
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意外的副作用
- en: With all the changes that push an application towards the legacy realm, often
    the methods or functions in the application will be used in unexpected places,
    far away from the code that you are changing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在推动应用程序走向遗留领域的所有变化中，通常应用程序中的方法或函数会在意想不到的地方被使用，远离你正在更改的代码。
- en: There are two primary violations of the SOLID principles that have led to this
    issue, and the same two can help you to avoid it going forward. The first is the
    **OCP** (**Open Closed Principle**), and the second is the **LSP** (**Liskov Substitution
    Principle**).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的SOLID原则违反导致了这个问题，而且同样的两个原则可以帮助你避免未来发生。第一个是**OCP**（**开放封闭原则**），第二个是**LSP**（**里氏替换原则**）。
- en: Open Closed Principle and legacy code
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放封闭原则与遗留代码
- en: As discussed previously, the Open Closed Principle states that code should be
    open for extension yet closed for modification. This principle is designed to
    prevent the issues with legacy code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，开放封闭原则指出代码应该易于扩展但不易于修改。这个原则旨在防止遗留代码的问题。
- en: If the modification that has been requested of you is one that will change the
    behavior of a specific piece of the application, then try to instead clone the
    method in question and modify the clone. Then the part of the application that
    needs the change can call the clone instead. This will prevent the change from
    affecting any parts of the application except the parts you are intending to affect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被要求进行的修改将改变应用程序特定部分的行为，那么尝试克隆相关的方法并修改克隆。然后，需要变更的应用程序部分可以调用克隆，这样就可以防止变更影响除了你打算影响的部分以外的任何应用程序部分。
- en: Until we know for sure that the code we just avoided is not being used elsewhere
    in the application, we can't delete it. Eventually, once we are sure that the
    old code is truly orphaned and not used, we want to clean up and delete the unused
    method to maintain a code base with just a little less cruft.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确定我们刚刚避免的代码没有在其他地方被应用程序使用之前，我们不能删除它。最终，一旦我们确定旧代码确实是孤立的并且没有被使用，我们希望清理并删除未使用的方法，以保持一个稍微少一些冗余的代码库。
- en: On the other hand, if the change is for a bug, then the fix is a little more
    complicated. You must first determine whether the bug should be fixed everywhere
    that this code might be used, or whether the bug is relative only to a specific
    portion of the application. When in doubt, fall back to cloning the method and
    only affecting intentional parts of the application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果变更是为了修复一个错误，那么修复过程就稍微复杂一些。你必须首先确定这个错误是否应该在代码可能被使用的所有地方修复，或者这个错误是否仅与应用程序的特定部分相关。如果有疑问，可以回退到克隆方法，只影响应用程序的有意部分。
- en: Liskov Substitution Principle and legacy code
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov替换原则和遗留代码
- en: How do you determine whether change should affect the entire application or
    just a slice? One way is to employ the LSP. Simply put, LSP says that a class
    should do what it sounds like it does. Any behavior change that would change that
    should be a different dependency.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定变更应该影响整个应用程序还是仅仅影响一个部分呢？一种方法就是采用LSP（里氏替换原则）。简单来说，LSP表示一个类应该做它听起来应该做的事情。任何会改变这种行为的变更都应该是一个不同的依赖。
- en: That is, any change that changes behavior should probably be a new method or
    a new class with the appropriate method in it. This will prevent accidental side
    effects in the rest of the application and keep your code cleaner.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，任何改变行为的变更可能应该是一个新的方法或一个新的类，其中包含适当的方法。这将防止在应用程序的其他部分产生意外的副作用，并保持你的代码更干净。
- en: Over-optimization
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度优化
- en: It has been said that premature optimization is a bad thing. What is optimization,
    though? Generally, to optimize is to reduce the number of steps from point A to
    point B. In a computer program, that means to reduce the number of cycles required
    to compute a result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，过早的优化是件坏事。那么，优化究竟是什么呢？一般来说，优化就是减少从A点到B点的步骤数量。在计算机程序中，这意味着减少计算结果所需的循环次数。
- en: An unfortunate side effect of optimizing code is that the code usually becomes
    much more difficult to read and comprehend. Optimizations tend to obfuscate the
    code in such a way that the only person who can understand it is the person who
    wrote it, and after some time, they may not be able to understand it either.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码的一个不幸副作用是代码通常变得难以阅读和理解。优化往往会以这种方式使代码变得晦涩难懂，以至于只有编写它的人才能理解它，而且经过一段时间，他们可能也无法理解它了。
- en: It is a fact that hard to understand code is code that is hard to change. This
    is the reason why optimizations that happen before they are needed are a bad thing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，难以理解的代码是难以更改的代码。这就是为什么在需要之前发生的优化是坏事的原因。
- en: So, when is an optimization needed? An optimization is needed when it is clear
    that the current implementation will not be able to meet the demands on the system
    within a reasonable timeframe in the future.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时需要优化呢？当明确当前实现未来无法在合理的时间内满足系统需求时，就需要进行优化。
- en: What makes a timeframe reasonable depends on the complexity of the needed optimization
    and the speed of the business. When a business is growing quickly, demand will
    follow along the same curve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的时间框架取决于所需优化的复杂性和业务的速度。当业务快速增长时，需求将沿着相同的曲线增长。
- en: A slower moving company may require several months of planning and preparation
    before assigning work to a developer. In this situation, it is reasonable to plan
    for optimizations several months before they are needed. It is important to monitor
    the performance of an application so that these needs can be predicted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个行动较慢的公司可能需要几个月的时间来规划和准备，才能将工作分配给开发者。在这种情况下，提前几个月规划优化是合理的。重要的是要监控应用程序的性能，以便预测这些需求。
- en: Overly clever code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过于聪明的代码
- en: Most developers start writing code because they enjoy it. It is not common to
    find a developer that came into the field simply because they heard they could
    make lots of money. Working for a company writing the same boring code all the
    time can cause developers to want to have some fun once in a while.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者开始编写代码是因为他们喜欢这样做。很少能找到一个进入这个领域仅仅是因为他们听说可以赚很多钱的开发者。一直为公司编写同样的无聊代码可能会导致开发者偶尔想要找点乐趣。
- en: When developers get bored, they come up with interesting and often overly complicated
    solutions that are simply not required. Sometimes, developers will come up with
    the cleverest solution they can figure out to solve a problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者感到无聊时，他们会想出有趣且往往过于复杂的解决方案，而这些解决方案实际上并不需要。有时，开发者会想出他们能想到的最聪明的解决方案来解决问题。
- en: The problem with clever solutions is that to fix a problem, you have to be more
    skilled than the person who fixed it. So, if you write the cleverest code you
    can write, then you are no longer qualified to debug the code, and you bring your
    own, and everyone else's, progress to a halt.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明解决方案的问题是，为了修复一个问题，你必须比修复它的人更有技能。所以，如果你写了你能写的最聪明的代码，那么你就不再有资格调试代码了，你带来的，以及每个人的，进步都会停滞。
- en: Tight coupling to third-party software
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与第三方软件的紧密耦合
- en: Everyone uses some third-party plugin or library. In the software community,
    it is inevitable that you will have to depend on someone else's code. What you
    don't know when you use that code is the quality, stability, and ability to meet
    your future needs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都会使用一些第三方插件或库。在软件社区中，不可避免地，你将不得不依赖他人的代码。当你使用那段代码时，你不知道的是其质量、稳定性以及满足你未来需求的能力。
- en: With that in mind, it is a bad idea to rely directly on the classes and interfaces
    presented to you by that third-party. Instead, use a hexagonal architecture, also
    known as ports and adapters. For anyone doing C#, this includes abstracting the
    .NET framework.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，直接依赖第三方提供的类和接口是个坏主意。相反，使用六边形架构，也称为端口和适配器。对于任何使用C#的开发者来说，这包括抽象.NET框架。
- en: Any code that you and your team did not write should be abstracted to protect
    your code from the potential external changes. This includes code written at your
    company but by a different team. If it is outside your control, put it behind
    an abstraction. The preferred abstraction is one or more interfaces that provide
    the desired functionality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你和你的团队没有编写的代码都应该被抽象化，以保护你的代码免受潜在的外部变化的影响。这包括在公司内部由不同团队编写的代码。如果它不在你的控制之下，就将其放在抽象层后面。首选的抽象方式是一个或多个提供所需功能的接口。
- en: Issues that prevent adding tests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻碍添加测试的问题
- en: Deadlines are tight. The scope is ever changing. We just don't have time to
    write tests. It's more important to get functionality out the door. We've all
    been there. Whatever the case may be, sometimes you will find yourself working
    on a project that was not written with testing in mind.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 截止日期很紧张。范围不断变化。我们根本没有时间写测试。把功能推出门更重要。我们都有过这样的经历。无论情况如何，有时你会发现自己在从事一个没有考虑到测试的项目。
- en: There never seems to be enough time to do it right, but there's always time
    to do it over.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总是觉得时间不够用来做正确的事，但总有时间来重做。
- en: So, what are the issues you might face that would prevent you from adding tests
    to a legacy application?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会遇到哪些问题，阻止你向遗留应用程序添加测试？
- en: When a system wasn't written with testing in mind, it can be quite difficult
    to go back and add tests at a later date. Classes with concrete dependencies and
    tight coupling make software applications difficult to test. Things such as large
    classes and functions, Law of Demeter violations, global state, and static methods
    can also make for a system that can be very difficult to test.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个系统没有考虑到测试时，在稍后添加测试可能会非常困难。具有具体依赖和紧密耦合的类会使软件应用程序难以测试。像大型类和函数、Demeter法则违反、全局状态和静态方法等问题也会使系统变得非常难以测试。
- en: Much like building a house by starting with a shaky foundation, untestable code
    begets untestable code. Unless pieces of the system can be decoupled from the
    rest of the application, the untestable trend will likely continue, and often
    does.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从摇摇晃晃的基础开始建造房屋一样，不可测试的代码会滋生出更多不可测试的代码。除非系统的某些部分可以从应用程序的其他部分中解耦，否则不可测试的趋势很可能会持续下去，而且通常就是这样。
- en: Direct dependence on framework and third-party code
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接依赖框架和第三方代码
- en: As was covered in a previous chapter, dependency on framework and third-party
    code makes for a tightly coupled system. Any time that the *new* operator in C#,
    for example, is invoked, then a direct dependency is made to that particular class.
    We want to minimize those dependencies as much as possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，对框架和第三方代码的依赖会导致紧密耦合的系统。例如，每次在C#中调用`new`运算符时，都会对该特定类产生直接依赖。我们希望尽可能减少这些依赖。
- en: Remember that even framework dependencies should be avoided, or, at the very
    least, abstracted as much as possible. Think back to the `DateTime` example, where
    we were able to supply our own `DateTime` value for testing purposes in the sample
    application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，甚至框架依赖也应该避免，或者至少尽可能抽象化。回想一下`DateTime`的例子，在示例应用程序中，我们能够为测试目的提供自己的`DateTime`值。
- en: Any `using` or `import` statement at the top of a class or file should be carefully
    considered and avoided if at all possible. Instead, ensure that your code is dependent
    on an *interface* whose definition is directly under your control. That way, you
    can minimize the coupling and isolate the functionality within your own classes
    and methods. This will help you write cleaner, more testable code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在类或文件顶部出现的任何`using`或`import`语句都应该仔细考虑，并在可能的情况下避免。相反，确保你的代码依赖于一个定义直接在你控制下的*接口*。这样，你可以最小化耦合，并在你自己的类和方法中隔离功能。这将帮助你编写更干净、更易于测试的代码。
- en: Law of Demeter
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 德米特法则
- en: 'The Law of Demeter, in its simplest form, states that, *Each unit should have
    only limited knowledge about other units: only units "closely" related to the
    current unit*. Further, *Each unit should only talk to its friends; don''t talk
    to strangers*. Simply put, *Only talk to your immediate friends*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 德米特法则在其最简单形式中表明，*每个单元应该只对其他单元有有限的知识：只有与当前单元“紧密”相关的单元*。进一步来说，*每个单元应该只与其朋友交流；不要与陌生人交流*。简单来说，*只与你的直接朋友交流*。
- en: When a class or function has knowledge of the inner workings of something outside
    its immediate control, then there is some tight coupling happening there. In order
    to test a method that has one or more Law of Demeter violations, the amount of
    setup involved is often fairly substantial. In order to test a method of one class
    that violates the Law of Demeter, you must set up the other class or method, or
    provide a reasonable fake implementation in order to test effectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类或函数了解其直接控制之外的某个事物的内部工作时，那么那里就存在一些紧密耦合。为了测试一个违反德米特法则的方法，所需的设置量通常相当大。为了测试一个违反德米特法则的类的方法，你必须设置另一个类或方法，或者提供一个合理的模拟实现，以便有效地进行测试。
- en: Remember, keep your test methods small and nimble so that they run quickly and
    are easy to understand. If you follow this rule, your production code will likely
    also be similarly simple and easy to follow. This will pay off in the long run,
    as it will be easier to maintain in the future.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，保持你的测试方法小巧灵活，这样它们就能快速运行，并且易于理解。如果你遵循这个规则，你的生产代码可能也会同样简单且易于遵循。从长远来看，这将是有益的，因为将来维护起来会更容易。
- en: Work in the constructor
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数中的工作
- en: When a new instance of a class is created that has logic in the constructor,
    it is often very difficult to test that class. If, for some reason, you need to
    set up a test scenario that requires different values or behavior than that which
    is set up in the constructor, it will be quite difficult to proceed. It would
    be best to minimize the work done in the constructor and extract helper methods
    or some other scenario more easily tested and better implemented elsewhere.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个具有构造函数逻辑的新类实例时，通常很难测试该类。如果由于某种原因，你需要设置一个需要不同值或行为而不是构造函数中设置的测试场景，那么进行测试将会非常困难。最好是尽量减少构造函数中的工作，并提取辅助方法或某些其他更容易测试和在其他地方更好地实现的情况。
- en: Keep in mind that particular patterns may prove to be better alternatives to
    setting up a specific class or function. You should familiarize yourself with
    common software patterns and how to best implement them. This will help you grow
    an application by working to solve similar problems that have been resolved by
    others before you. By utilizing known software patterns, you can more easily communicate
    your intent with the code within the system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，特定的模式可能证明是设置特定类或函数的更好替代方案。你应该熟悉常见的软件模式以及如何最好地实现它们。这将帮助你通过解决其他人之前已经解决的问题来增长应用程序。通过利用已知的软件模式，你可以更容易地在系统内的代码中传达你的意图。
- en: The builder pattern, for example, might be employed to construct an object with
    the proper values set that would otherwise be added to the constructor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，构建器模式可能被用来构建具有适当值的对象，否则这些值将添加到构造函数中。
- en: 'Take the following example of the `Car` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下`Car`类的例子为例：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You could easily write a builder class to construct a specific type of car,
    such as a `ToyotaCamryBuilder` or `FordMustangBuilder`. Creating a new instance
    of either a Toyota Camry or a Ford Mustang would be quite easy, simple, and clean.
    Not to mention, it would be quite easy to test.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地编写一个构建器类来构建特定类型的汽车，例如`ToyotaCamryBuilder`或`FordMustangBuilder`。创建丰田凯美瑞或福特野马的新实例将非常容易、简单和干净。更不用说，这将非常容易进行测试。
- en: Global state
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局状态
- en: Global state is prone to the side effects from parts of the application far
    away. These side effects will change the results of the code you run. Functional
    programming has caught on in recent years, as one of the tenants is to reduce
    side effects, as they can cause unpredictable and undesirable behavior in a system.
    Instead, you should strive to break down your code into what are known as pure
    functions. Pure functions take an input and produce an output. For any given input,
    the output will always be the same.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态容易受到应用程序远处部分的副作用的影响。这些副作用将改变你运行代码的结果。近年来，函数式编程已经流行起来，因为其一个原则是减少副作用，因为它们可能导致系统中的不可预测和不受欢迎的行为。相反，你应该努力将你的代码分解成所谓的纯函数。纯函数接受输入并产生输出。对于任何给定的输入，输出总是相同的。
- en: Static methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: Static methods are not in and of themselves bad, but they do hint at a misplaced
    responsibility code smell. Static anything tells you that you have put the code
    in the wrong place. It doesn't share anything in common with the rest of the code
    in the scope and should probably be removed and put somewhere with its friends.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法本身并不坏，但它们确实暗示了责任错位的代码异味。静态任何事物都告诉你，你把代码放在了错误的地方。它不与作用域内其他代码共享任何共同点，可能应该被移除并放在与其朋友在一起的地方。
- en: Large classes and functions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大类和函数
- en: Does class size really matter? What's the problem with having a large method
    or function? Large classes and functions often scream complexity. Remember the
    SOLID principles and what each letter in the acronym represents. A large class
    or method is likely violating one or more of the principles.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类的大小真的重要吗？拥有一个大方法或函数有什么问题？大类和函数通常意味着复杂性。记住SOLID原则以及每个字母代表的意义。一个大类或方法很可能会违反一个或多个原则。
- en: We want our classes and functions to be small and have only one reason to change
    (*Single Responsibility Principle*). A large class is likely hiding logic that
    can and should be broken into two or more separate and distinct classes. A large
    method or function likewise often hides two or more methods. Look for ways to
    keep your methods simple and keep an eye out for possible logical boundaries with
    which to break out smaller helpers, classes, and utilities.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的类和函数小而只有一个改变的理由（*单一职责原则*）。一个大类很可能会隐藏可以并且应该分解成两个或更多独立且不同的类的逻辑。一个大方法或函数同样经常隐藏两个或更多方法。寻找保持你的方法简单的方法，并留意可能的逻辑边界，以便将较小的辅助程序、类和实用工具分离出来。
- en: Classes and functions should be divided and grouped logically. The purpose of
    a system should be easily understood by the names and groupings of the files associated
    with the application. The structure of the system should be simple and make sense
    to those in charge of enhancing and maintaining the application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类和函数应该逻辑上划分和分组。系统的目的应该通过与应用程序相关的文件名称和分组容易理解。系统的结构应该是简单且对负责增强和维护应用程序的人来说有意义的。
- en: Dealing with legacy problems
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理遗留问题
- en: We have been discussing all the issues with legacy code. Now it is time to tackle
    solving those issues. The first thing we must do is bring sanity to the targeted
    legacy code, and then we can begin testing and eventually fix the code and bring
    it back from death.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论遗留代码的所有问题。现在是我们解决这些问题的时候了。我们必须做的第一件事是使目标遗留代码恢复理智，然后我们可以开始测试，最终修复代码，让它从死亡中复活。
- en: Safe refactoring
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的重构
- en: The term refactoring is often used incorrectly. When refactoring, you are merely
    changing the structure of the code. If the logic and/or signature of the code
    in question changes, then this does not qualify as refactoring. This is a change;
    most likely a breaking change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 术语重构经常被错误地使用。当你重构时，你只是在改变代码的结构。如果代码的逻辑和/或签名发生变化，那么这不算是重构。这是一个变化；很可能是破坏性的变化。
- en: If I'm changing the structure of the code (refactoring), then I don't ever change
    its behavior at the same time. If I'm changing the interface by which some logic
    is invoked, I never change the logic itself at the same time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在更改代码的结构（重构），那么我永远不会同时更改其行为。如果我在更改调用某些逻辑的接口时，我永远不会同时更改逻辑本身。
- en: – Kent Beck
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: – Kent Beck
- en: A safe refactoring is one that is guaranteed to not accidentally break the code.
    Other changes that aren't intended to actually change the behavior of the code
    but could do it accidentally are considered unsafe refactoring. These usually
    involve changes to the private areas of the code that aren't directly exposed
    to consumers of your application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的重构是指保证不会意外破坏代码的重构。其他不是有意改变代码行为但可能意外改变行为的更改被认为是不可安全的重构。这些通常涉及对代码的私有区域的更改，这些区域没有直接暴露给应用程序的消费者。
- en: Converting values to variables
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值转换为变量
- en: One of the first and easiest things that can be done is to extract any hard-coded
    values to be represented by variables. Having a variable allows for a quicker
    and more consistent update. It also helps to convey intent.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以做的第一件简单的事情之一是将任何硬编码的值提取出来，由变量来表示。拥有变量可以更快、更一致地更新。这也有助于传达意图。
- en: When creating the variables, make sure the name is descriptive enough for the
    scope of the variable. Variables with a short scope can have a short name. On
    the other hand, variables with a long scope must have a longer, more descriptive
    name. The further a variable is from its usages, the more descriptive it needs
    to be so that the context it represents isn't lost.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建变量时，确保变量的名称足够描述性，以适应变量的作用域。作用域短的变量可以有短名称。另一方面，作用域长的变量必须有更长、更描述性的名称。变量与其使用地点的距离越远，就需要越多的描述性，以便不会丢失它所代表的上下文。
- en: Check the scope of your variables and make sure they do not have a larger scope
    than is necessary. Also, check for variables that should have a larger scope but
    are instead passed between private methods instead of being class members.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 检查变量的作用域，确保它们的作用域不大于必要的范围。还要检查那些本应具有更大作用域但被传递给私有方法而不是作为类成员的变量。
- en: It is not recommended at this time to update the private and protected methods
    that depend on variables that could be moved to a class scope. Instead, make note
    of them and move them around after tests have been added.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不建议更新依赖于可能移动到类作用域的变量的私有和受保护的方法。相反，注意它们，并在添加了测试之后移动它们。
- en: Extracting a method
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取方法
- en: Working with legacy code often involves working with very large methods. A large
    method is any method that is longer than twenty lines. Preferably, methods are
    kept as small as possible, even down to just a few lines.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与遗留代码一起工作通常涉及处理非常长的代码。任何超过二十行的代码都可以被认为是长的。最好将方法保持得尽可能小，甚至只有几行。
- en: A large method can mean that the code is violating the Single Responsibility
    Principle. What needs to be done is to find the seams in the method. Seams can
    be found by commenting the different sections of the method. Once you have commented
    the sections, you have identified the seams.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大的方法可能意味着代码违反了单一职责原则。需要做的事情是找到方法中的缝隙。可以通过注释方法的不同部分来找到缝隙。一旦你注释了部分，你就已经识别出了缝隙。
- en: Seam
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 缝隙
- en: In code, this is the location where two pieces of business logic meet. Normally,
    you might refer to the location where the private method is called by a public
    method as a seam in the public method. The code has been stitched together at
    that location. In this case, there are no private methods, so we are identifying
    where we want the seams to be.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这是两段业务逻辑相遇的位置。通常，你可能将私有方法被公共方法调用的位置称为公共方法中的“接缝”。代码在那个位置已经被缝合在一起。在这种情况下，没有私有方法，所以我们正在确定我们想要接缝的位置。
- en: Each one of those seams is probably a lower order method that can be extracted.
    In most editors and IDEs, highlight the code you want and use the extract method
    refactoring provided through either a right-click, context, menu, or via the menu
    bar.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那些接缝中的每一个可能都是一个可以提取的低级方法。在大多数编辑器和IDE中，突出显示你想要提取的代码，然后使用通过右键单击、上下文菜单或菜单栏提供的提取方法重构功能。
- en: Extracting a class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取一个类
- en: Just like methods, sometimes a large method should really be a class. While
    extracting methods, if you extract three or more methods, then you have probably
    found a class that needs to be extracted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像方法一样，有时一个大的方法实际上应该是一个类。在提取方法的过程中，如果你提取了三个或更多的方法，那么你很可能发现了一个需要提取的类。
- en: Extracting a class is similar to extracting a method and is likely supported
    by your editor or IDE. Group and highlight the code you want to extract, then
    use the extract class menu option.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提取类与提取方法类似，并且很可能被你的编辑器或IDE支持。分组并突出显示你想要提取的代码，然后使用提取类菜单选项。
- en: If your editor does not support extracting a class, all is not lost. Instead,
    highlight and cut all the methods you extracted that should be in the class. Create
    a new class file and paste those methods into the new class. Lastly, replace the
    calls to those methods in the original method with the instantiation and calling
    of the new class and methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编辑器不支持提取类，并不意味着一切都完了。相反，突出显示并剪切出你想要放入类中的所有提取方法。创建一个新的类文件，并将这些方法粘贴到新类中。最后，用新类和方法的实例化和调用替换原始方法中对这些方法的调用。
- en: Abstracting third-party libraries and framework code
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象第三方库和框架代码
- en: Now that we have variables, methods, and classes abstracted, it is time to abstract
    third-party libraries, framework code, and those classes we just created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经抽象了变量、方法和类，是时候抽象第三方库、框架代码以及我们刚刚创建的类了。
- en: Firstly, let's start with framework details. Things like `DateTime`, `Random`,
    and `Console` are best hidden behind classes that you design to fit the needs
    of your application. There are several reasons for this; most importantly, putting
    these in their own classes will allow for testing. Without abstracting these to
    a separate class, it is almost impossible to test with things like `DateTime`
    that change values on their own.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从框架细节开始。像`DateTime`、`Random`和`Console`这样的东西最好隐藏在你设计的适合你应用程序需求的类后面。这样做有几个原因；最重要的是，将这些放入它们自己的类中将允许进行测试。如果不将这些抽象为单独的类，几乎不可能使用像`DateTime`这样的会自行更改值的对象进行测试。
- en: Next up are the third-party libraries. Anywhere the code is calling to create
    a new class from a third-party, you need to abstract that to a new class specifically
    for the purpose of utilizing that third-party library. For the moment, replace
    the call that instantiates the third-party library with a call that instantiates
    your class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第三方库。任何代码调用第三方库以创建新类的位置，你都需要将其抽象为一个新类，专门用于利用那个第三方库。目前，用实例化你的类来替换实例化第三方库的调用。
- en: Lastly, we can now deal with the calls to `new` that are left in the code. Everywhere
    that the code is calling `new` needs to be replaced with dependency injection.
    This will allow for testing and make the code cleaner and more flexible in the
    future.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在可以处理代码中留下的对`new`的调用。代码中任何调用`new`的地方都需要用依赖注入来替换。这将允许进行测试，并使代码在未来更加干净和灵活。
- en: 'To create the dependency injection without modifying the signature of the class,
    we will be using a pattern called poor man''s dependency injection, also known
    as property injection. Below is an example of property injection in C#. The same
    process can be done in JavaScript with almost no modifications:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不修改类签名的情况下创建依赖注入，我们将使用一种称为“穷人依赖注入”的模式，也称为属性注入。下面是一个C#中属性注入的示例。几乎不需要修改就可以在JavaScript中完成相同的操作：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using this pattern, it is possible to allow the class to create its dependency
    lazily, when asked for it. It is also possible to set the dependencies value for
    tests or other purposes. Although not shown in this quick example of the pattern,
    it is better to have the property and backing variable be of an interface type.
    This will make the injection of some other value easier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，可以在需要时让类懒加载其依赖项。也可以为测试或其他目的设置依赖项的值。尽管在这个模式的快速示例中没有展示，但最好让属性和后置变量是接口类型。这将使注入其他值更容易。
- en: Early tests
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 早期测试
- en: If an application of any significant size and complexity isn't properly segmented,
    it can be quite a daunting task to know how and where to begin writing tests.
    With a little practice in testing legacy systems it will become easier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个大型且复杂的应用程序没有被正确分割，那么知道如何以及在哪里开始编写测试可能是一项相当艰巨的任务。通过在测试遗留系统方面进行一些实践，这将会变得更容易。
- en: The *when* to write tests within a legacy system can easily be answered with,
    "When it makes sense to." It would be difficult to sell the idea to any business
    owner that time (and money) should be spent going back to write tests to cover
    the existing functionality of a legacy system. It makes much more sense to add
    tests as enhancements are added to the application or when defects are being addressed.
    As you're working in the code and have immediate context surrounding the functionality
    that you wish to test, that is the optimal time to begin to test parts of a legacy
    application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗留系统中何时编写测试可以很容易地回答：“当它有意义时。”向任何企业主推销这个想法，即应该花费时间（和金钱）回头编写测试来覆盖遗留系统的现有功能，可能会很困难。在添加增强功能或解决缺陷时添加测试要合理得多。当你正在代码中工作，并且立即有关于你希望测试的功能的上下文时，这就是开始测试遗留应用程序部分的最佳时机。
- en: So, how do you begin to write tests against a legacy system? Isolate small functions
    that can be easily tested. Extract methods and smaller classes as needed. Ensure
    that functionality is not being modified, but that code is simply being reorganized
    in order to facilitate testability.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何开始为遗留系统编写测试呢？隔离那些可以轻松测试的小函数。根据需要提取方法和更小的类。确保功能没有被修改，但代码只是被重新组织以方便测试性。
- en: It may be necessary to change a private method to be protected so that it may
    be tested.  Changing the scope of the method does make it more available and can
    reduce the effective abstraction, but if the change is required to aid in testing,
    the trade-off is almost always worth it. You might also consider that private
    methods made public might better belong to a different utility or helper class,
    and so can remain public. It depends on the method in question, but there are
    certainly options available to help you make a legacy system more testable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要将私有方法更改为受保护的，以便可以进行测试。改变方法的范围确实使其更易于访问，并可能减少有效抽象，但如果这种改变是为了帮助测试，那么这种权衡几乎总是值得的。你也可能考虑，使私有方法公开可能更适合不同的实用程序或辅助类，因此可以保持公开。这取决于具体的方法，但确实有可用的选项可以帮助使遗留系统更具可测试性。
- en: Gold standard tests
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黄金标准测试
- en: Gold standard tests, or characterization tests, are those tests that simply
    define the expected functionality of a method. If you were to add tests to a legacy
    system, you would likely begin by writing gold standard tests to define the "happy
    path" through the system. You might run the application to determine what values
    a given method returns based on a given input, and then write a test to duplicate
    the results.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金标准测试，或称特征测试，是那些仅定义方法预期功能的测试。如果你要向遗留系统添加测试，你可能会首先编写黄金标准测试来定义系统的“快乐路径”。你可能运行应用程序以确定给定方法基于给定输入返回的值，然后编写一个测试来复制这些结果。
- en: Gold standard tests are used because they provide a shortcut. Normally, to test
    legacy code, you would have to abstract third-party libraries and set up dependency
    injections of some sort. You may also have to refactor the code significantly
    just to get to the point where you can test anything. By using a gold standard
    test, most of this work can, temporarily, be bypassed. The only abstractions needed
    are screen output, date/time, and random. Just about everything else can be used
    as is.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用黄金标准测试是因为它们提供了捷径。通常，为了测试遗留代码，你可能需要抽象第三方库并设置某种类型的依赖注入。你可能还必须对代码进行重大重构，才能达到可以测试任何东西的程度。通过使用黄金标准测试，大部分这项工作可以暂时绕过。唯一需要的抽象是屏幕输出、日期/时间和随机。几乎所有其他东西都可以直接使用。
- en: This would provide a baseline for a suite of tests and help ensure that expected
    functionality does not change with future refactoring or modifications. Gold standard
    tests do not validate correctness; they merely confirm that the system does what
    the system did.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为测试套件提供一个基线，并有助于确保预期的功能在未来的重构或修改中不会发生变化。黄金标准测试并不验证正确性；它们只是确认系统做了系统应该做的事情。
- en: As a basis, gold standard tests provide a certain level of comfort to guard
    against any unwanted behavior changes. These likely will not be enough to provide
    adequate code coverage and should have additional tests added to cover edge cases
    and alternate paths through the system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基础，黄金标准测试提供了一定程度的安慰，以防止任何不希望的行为变化。这些可能不足以提供足够的代码覆盖率，并且应该添加额外的测试来覆盖边缘情况和系统中的替代路径。
- en: As the test suite grows and the coverage becomes more meaningful and complete,
    it may prove wise to remove the original gold standard tests. Again, you want
    your test suite to be able to execute quickly so that it is run always and often.
    Removing tests that may be superfluous will help minimize the feedback cycles
    when running your tests. In other words, you will know if you have broken something
    faster and will be more likely to run the tests if the tests complete faster.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试套件的成长和覆盖率的提高和完整性，可能证明删除原始黄金标准测试是明智的。再次强调，你希望你的测试套件能够快速执行，以便始终运行并经常运行。删除可能多余的测试将有助于在运行测试时最小化反馈周期。换句话说，如果你知道你破坏了某些东西，测试完成得更快，你更有可能运行测试。
- en: Testing all potential outcomes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试所有潜在结果
- en: It's not necessarily important to test for all possible values for an individual
    method. As in the example of gold standard tests, you certainly don't want to
    run the application with all possible values in order to write tests for each
    of the possibilities. It is far more important to test for every path of execution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个方法的所有可能值并不一定很重要。例如，在黄金标准测试的例子中，你当然不希望用所有可能的值运行应用程序，以便为每种可能性编写测试。测试执行路径的每个路径要重要得多。
- en: 'If a method is small enough and its potential outcomes limited in scope, it
    should be quite trivial to write a handful of tests to cover all potential scenarios.
    Take the following method as an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法足够小，其潜在结果范围有限，那么编写一些测试来覆盖所有潜在场景应该是相当简单的。以下方法为例：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What are the potential paths through this method? What tests might you write
    to ensure adequate coverage?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此方法有哪些潜在路径？你可能编写哪些测试来确保充分的覆盖？
- en: First, you might consider writing a test in the case that the *maximum* input
    parameter is equal to `0`. This should cover the `DivideByZeroException` in this
    scenario.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能考虑编写一个测试，假设*最大值*输入参数等于`0`。这应该涵盖此场景中的`DivideByZeroException`。
- en: Next, you might write a test where the *current* parameter is `0`, ensuring
    that the result of this method is always zero, assuming *maximum* is non-zero.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可能编写一个测试，其中*当前*参数为`0`，确保此方法的结果始终为零，假设*最大值*非零。
- en: Finally, you would want to write one or more tests to validate that the algorithm
    above is indeed calculating the percentage correctly, based on inputs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想要编写一个或多个测试来验证上述算法确实根据输入正确地计算百分比。
- en: At this point, it may be tempting to add tests for things like negative values
    or to check the rounding that C# is doing, but remember that we are working with
    legacy code and, as far as the business is concerned, this code is working as
    is. You don't have a record of the business requirements that spawned this code,
    so it would be unnecessary, and possibly irresponsible, to test more than what
    this code is telling you. So, if you believe the code is flawed in that it doesn't
    cover certain business criteria, or that it could produce incorrect values, discuss
    these things with your business and make a determination together. Any change
    to the code would have to be through either a bug or new work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想添加测试来检查负值或检查C#正在进行的舍入，但请记住，我们正在处理遗留代码，并且从业务的角度来看，这段代码是按原样工作的。你没有关于产生此代码的业务需求的记录，因此测试超过代码告诉你的内容是不必要的，甚至可能是不负责任的。所以，如果你认为代码在它没有覆盖某些业务标准或可能产生不正确值方面有缺陷，与你的业务讨论这些问题，并共同做出决定。任何对代码的更改都必须通过错误或新工作来实现。
- en: Moving forward
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前进
- en: Once the legacy system has been sufficiently refactored and a comprehensive
    suite of tests has been added, you may begin to think of the application as non-legacy,
    current, or a present-day system. It should now be trivial to add new features
    and squash any newly discovered defects. From this point forward, any new feature
    requested should be easily added with the confidence that other parts of the system
    will not be negatively affected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遗留系统已经足够重构，并且添加了一个全面的测试套件，你就可以开始将应用程序视为非遗留、当前或当代系统。现在，添加新功能和平息任何新发现的缺陷应该变得非常简单。从这一点开始，任何新请求的功能都应该能够轻松添加，并且有信心其他系统部分不会受到负面影响。
- en: The legacy application is no longer legacy. With a comprehensive suite of tests,
    you are now safe to proceed in Test-Driven Development fashion and write tests
    as every new feature is added. Remember to keep your tests as clean and well-refactored
    as any part of the production system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留应用程序不再被视为遗留。有了全面的测试套件，你现在可以安全地以测试驱动开发的方式继续前进，并在添加每个新功能时编写测试。记住，要像生产系统中的任何部分一样保持你的测试干净和重构良好。
- en: Taking the `GetPercent` example above, how might you modify this in order to
    return two decimal places? Why, by writing new tests, of course! Start by creating
    a test to return two decimal places based on the input value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以上面的`GetPercent`示例为例，你该如何修改它以返回两位小数？当然是通过编写新的测试来实现！首先创建一个基于输入值返回两位小数的测试。
- en: 'Your test might look something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试可能看起来像这样：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, modify the existing method to return only two decimal places. We'll leave
    this as an exercise for the reader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改现有的方法以只返回两位小数。我们将把这个作为练习留给读者。
- en: Fixing bugs
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复错误
- en: Fixing bugs in a legacy system is a dangerous endeavor. Remember that any existing
    behavior may be accounted for in other parts of your system, or by external consumers
    of your application. By fixing a bug, you may be breaking functionality, albeit
    wrong, that someone else is depending on. So, a change to the execution results
    of code should be considered carefully before being done.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗留系统中修复错误是一项危险的任务。请记住，任何现有行为可能已经在系统的其他部分或由应用程序的外部消费者考虑在内。通过修复错误，你可能会破坏其他人依赖的功能，尽管是错误的。因此，在执行之前，应该仔细考虑代码执行结果的任何更改。
- en: Free to do unsafe refactoring
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自由地进行不安全的重构
- en: Refactoring is, by definition, modifying the structure of the code without modifying
    its behavior. Safe refactoring includes variable injection, method extraction,
    and so on. Unsafe refactoring would affect the architecture of the code, the way
    the code interacts with the rest of the system, and more. By having a fully tested
    section of code, you can now modify the architecture and be assured that this
    section still does what it is supposed to do.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重构，按照定义，是在不修改其行为的情况下修改代码的结构。安全的重构包括变量注入、方法提取等。不安全的重构将影响代码的架构，代码与系统其他部分交互的方式，等等。通过拥有一个完全测试过的代码部分，你现在可以修改架构并确信这部分仍然在做它应该做的事情。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how we define legacy code and the issues that
    legacy code can create. Legacy code can inhibit testing, but now you should know
    how to fight back against the legacy problem.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何定义遗留代码以及遗留代码可能引起的问题。遗留代码可能会阻碍测试，但现在你应该知道如何反击遗留问题。
- en: In [Chapter 13](part0418.html#CEKB40-d186949d2da74f5c95dd1712efae1195), *Unraveling
    a Mess*, we'll explore a rather extreme example of the types of things you might
    encounter in a legacy system. We'll explore safe refactoring and how to best unravel
    a mess into well structured, testable code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](part0418.html#CEKB40-d186949d2da74f5c95dd1712efae1195)，“解开混乱”，我们将探讨在遗留系统中可能会遇到的一些相当极端的例子。我们将探讨安全的重构以及如何最好地将混乱解开成结构良好、可测试的代码。
