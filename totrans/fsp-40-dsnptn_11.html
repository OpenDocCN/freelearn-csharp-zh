<html><head></head><body>
<div><div><div><div><h1 class="title"><a id="ch11"/>
 Chapter 11. F# Expert Techniques</h1>
</div>
</div>
</div>
<p>So far in the book, we've dealt mostly with customary F# facilities that constitute the core of successful F# idiomatic use in diverse application fields. The common sign of (almost) all of the related usage patterns is that they are straightforward and ordinary. Their mastery is a must for any intermediate level F# practitioner.</p>
<p>In this chapter, I'm going to step out of the regular space where expressions always yield results, calculations take place sequentially, and code must be first written in order to be later used. I will walk you through some of expert level F# techniques, the area of exciting usage patterns that is often considered overcomplicated and error-prone in nonfunctional paradigms.</p>
<p>In this chapter I will cover the following topics in the context of F# idiomatic use:</p>
<div><ul class="itemizedlist">
<li class="listitem">Type providers</li>
<li class="listitem">Concurrent programming</li>
<li class="listitem">Reactive programming</li>
<li class="listitem">Metaprogramming</li>
</ul>
</div>
<p>I will approach each of these subjects by giving a brief overview accompanied with a concise usage sample taken from the enterprise trenches. I will attempt to show that these features are not really mind-bending and usually offer developers a strong safety net. However, please do not expect any sort of deep dive into these subjects. Consider the contents of this chapter more a roadmap to become skillful in these F# use patterns, as stimuli and practical application teasers.</p>
<div><div><div><div><h1 class="title" id="toc_1"><a id="ch11lvl1sec66"/>
 A note on custom computation expressions</h1>
</div>
</div>
</div>
<p>I've decided not to cover arbitrary 
<strong>F# Computation Expressions</strong>

 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions</a>
 ) in this book despite F# itself having this mechanism baked in under the hood of significant language features, such as 
<em>sequence expressions</em>

 (covered in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , 
<em>Sequences - The Core of Data Processing Patterns</em>

 ), 
<em>query expressions</em>

 (covered in <a class="link" title="Chapter 9. More Data Crunching" href="text00068.html#ch09">Chapter 9</a>
 , 
<em>More Data Crunching</em>

 ), and 
<em>asynchronous expressions</em>

 (to be addressed in this chapter). Although custom computation expressions allow crafting very elegant code in some cases, I feel that covering this feature here may divert us from the practicality path we are pursuing.</p>
<div><h3 class="title" id="toc_2"><a id="note15"/>
 Note</h3>
<p>Those of you interested in a solid understanding and mastery of the F# computation expressions may turn to this excellent detailed reading on the subject by Scott Wlaschin: 
<strong>The "Computation Expressions" series</strong>

 (<a class="ulink" href="https://fsharpforfunandprofit.com/series/computation-expressions.html">https://fsharpforfunandprofit.com/series/computation-expressions.html</a>
 ).</p>
</div>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch11lvl1sec67"/>
 Exploring type providers</h1>
</div>
</div>
</div>
<p>Frankly, I consider 
<strong>type providers</strong>

 as one of the most exciting, powerful, and pragmatic F# features. Ability to apply type providers is, in my opinion, among the strongest arguments for the usage of F# in enterprise software development.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch11lvl2sec120"/>
 The feature review</h2>
</div>
</div>
</div>
<p>Type providers in F# represent a pretty unique 
<em>practical</em>

 pattern of manipulating various data sources in a strongly typed manner. This manipulation is accomplished via types, methods, and properties that were derived from the data source features and built at compile-time in a fully automated fashion. The developer is not required to author and/or maintain these automatically 
<em>provided</em>

 data manipulation means.</p>
<p>The idea of automatic code generation itself is as old as pyramids, but what makes the difference is versatility, ease of usage, and a painless experience. Those who've ever wrestled with 
<strong>SqlMetal</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx</a>
 ) or 
<strong>WSDLTool</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx">https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx</a>
 ) would appreciate the way of type providers a lot.</p>
<p>It is also true that 
<em>creating</em>

 a useful type provider of production quality may require a lot of skill and effort. Nevertheless, once created, the type provider component can be used without any limits, so the usage benefits overweigh the construction pains by many times.</p>
<p>It is also worth mentioning that since the introduction of type providers in F# 3.0, many valuable data source kinds have already been covered. Since the initial wave of type provider construction mentioned in 
<strong>Twelve F# type providers in action</strong>

 (<a class="ulink" href="https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/">https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/</a>
 ), the available providers have gotten significantly more mature, providing a slick and smooth usage experience.</p>
<p>Enough talking; let's first take a look at the big picture of F# type provider workings. This is shown in the following figure:</p>
<div><img src="img/Image00053.jpg" alt="The feature review"/>
<div><p>F# type provider workings</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Without pretending to cover all potential external data sources, I am mentioning the following ones here:</p>
<div><ul class="itemizedlist">
<li class="listitem">Files of many specific formats (Excel, comma-separated, JSON, and so on) frequently utilized in enterprise development</li>
<li class="listitem">Database engines (Microsoft SQL Server, Oracle, MySQL, and so on)</li>
<li class="listitem">A variety of web APIs implementing different protocols and data presentation formats</li>
<li class="listitem">A variety of application engines (Python, R, MatLab, and so on) that can be remotely controlled in order to implement the desired processing and yielding results being given input data</li>
</ul>
</div>
<p>The magic begins at compile-time, when the developer references code type(s) that are expected to be provided from the given data source(s) within the F# application: results of a given query against a database, tabular data from some Excel file, clustering results of certain data; you name it. The F# compiler needs the corresponding type provider(s) to be available in the form of library packages. Reaching out to given data sources for the required metadata at compile-time, the type provider in concert with the F# compiler builds provided types, methods, and properties that allow you to treat external data on the fly in a strongly typed manner.</p>
<p>For example, 
<strong>SQLClient type provider</strong>

 (<a class="ulink" href="http://fsprojects.github.io/FSharp.Data.SqlClient">http://fsprojects.github.io/FSharp.Data.SqlClient</a>
 ) takes compile-time connection strings, connects 
<em>during compilation</em>

 to the given data engine instance, and having the text of the given query in T-SQL on hand uses certain system stored procedures in order to find types associated with the columns of the to-be-returned result set. This type information translates into a built-on-the-fly type associated with the query. As a result, if we are compiling under Visual Studio, we are getting Intellisense with regard to the fields associated with the result set that is present as the F# sequence of the compiler-provided type.</p>
<p>If at run-time we shoot the same query against 
<em>some other</em>

 data engine that has data with table schemas similar to the table(s) participating in the compiled query, the provided data access type will still be good for data transformations.</p>
<p>It is important to understand that the correspondence between database schemas and the query associated with the provided type is kept under static typing scrutiny; if any part of this equation (either the query expression or the involved schemas) changes, the code simply does not compile.</p>
<p>This is simultaneously a fault and a blessing as it reliably protects from potential mishaps between the application code and the data layer. However, the necessity of having access to the SQL data engine at compile-time complicates arrangements such as builds, continuous integration, and so on.</p>
<p>Personally, I am a big fan of the aforementioned type provider and found it interesting that often, people do not realize the delineation that exists between compile-time and run-time and effectively confining the possibilities.</p>
<div><h3 class="title" id="toc_2"><a id="tip16"/>
 Tip</h3>
<p>Some developers ask from time to time whether the query associated with the provided type can be changed at run-time. Apparently, the answer is a big 
<em>no</em>

 as that would require you to change the already generated type-specific code. At the same time, it is just fine (and expected) to change the connection string at run-time in order to access the target data engine where the data to be processed resides. Usually, the latter may be achieved with the provided type constructor having the run-time connection string as an argument.</p>
</div>
<p>I'm going to use this type provider for demo purposes later in this chapter, so you will have a chance to check your understanding.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch11lvl2sec121"/>
 The demo problem</h2>
</div>
</div>
</div>
<p>When picking a demo problem for type provider subject, I was initially doubtful whether it's feasible to delve into the type provider creation process or whether this book's format limits me to using only the existing type providers. I even solicited an opinion from a group of colleagues on whether it's possible to implement a practically sound type provider not exceeding 20 lines of F# code. The answer turned out to be affirmative, thanks to one of the authors of the aforementioned SQLClient type provider, who pointed out the interesting side problem this provider brought to light: the relationship between SQL code and the F# code.</p>
<p>From the separation of concerns standpoint, it is not an impeccable proposition to have T-SQL queries belonging to an application embedded into the F# code as literals. Ideally, it would be great to keep these queries separately from the F# code in a separate SQL script directory, having designated <code class="literal">.sql</code>
 file per each query. But how can such an arrangement be possible if we need the contents of these files to be represented as string literals in the application code at compile-time?</p>
<p>Eureka! The way out would be using just another type provider!</p>
<p>An internal "file reader" type provider may associate a corresponding 
<em>provided</em>

 type with the SQL query text stored there as a literal field with each SQL query file at compile-time. The literal field does not anyhow differ from the literal string constant in the text. Such an elegant approach indeed!</p>
<p>Taking into account an apparent didactic value behind this clear delineation between compile-time and run-time considerations, I decided to come up with something similar.</p>
<p>Imagine that we want to protect the execution of an application with a secret key but do not want to have the key value present anywhere in the source code. Instead, the secret may be kept in a key vault of some sort and be associated with the application only during the build. The deficiency of such protection is apparent as the secret value would be still present somewhere in the compiled application assembly. But that is not the point of the exercise. The requirement is this: there should be no secret key value in the source code.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch11lvl2sec122"/>
 The demo solution</h2>
</div>
</div>
</div>
<p>Our solution would be to create a type provider that, given a reference to the external repository that contains the secret key, would provide a type with the <code class="literal">string</code>
 secret value extracted from the repository and stored as a literal field. This means that such a field can be used as a case value in the <code class="literal">match...with</code>
 F# expression without revealing the underlying value in any manner. Also, you would acquire a firm understanding of the inner type provider workings as well as a sticky pattern to recall each time when in doubt about what activity happens when in type providing scenarios.</p>
<p>I'm ready to jump upon the implementation. Writing a type provider in 2016 is a breeze compared to how it was in 2012, when the feature was first delivered to the masses. Thanks to the open source effort of the amazing F# community for assembling together and packaging a sort of SDK in the form of the NuGet package for the creation of F# type providers, namely 
<strong>FSharp.TypeProviders.StarterPack </strong>

 (<a class="ulink" href="https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack">https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack</a>
 ). Bear with me. Just perform the following steps:</p>
<div><ol class="orderedlist arabic">
<li class="listitem">Shoot out a new Visual Studio project to create the F# library named 
<strong>KeyTypeProvider</strong>

 .</li>
<li class="listitem">Get rid of the two generated files with the <code class="literal">.fs</code>
 and <code class="literal">.fsx</code>
 extensions.</li>
<li class="listitem">Using 
<strong>Package Manager Console</strong>

 , add the Type Provider Starter Pack NuGet package to the just created project, issuing the <code class="literal">Install-Package FSharp.TypeProviders.StarterPack</code>
 command and observing a bunch of source code files added to the project (<code class="literal">ProvidedTypes.fsi</code>
 , <code class="literal">ProvidedTypes.fs</code>
 , and <code class="literal">DebugProvidedTypes.fs</code>
 ).</li>
<li class="listitem">Add a new F# source code file named <code class="literal">KeyTypeProvider.fs</code>
 and place it 
<em>below</em>

 the last of injected files listed in the previous bullet (remember that the order in which the F# source code files are introduced to the compiler matters a lot).</li>
</ol>
<div></div>
<p>That's it; we are ready to craft the type provider code into the latter file. I am placing the snippet with the corresponding code as follows (<code class="literal">KeyTypeProvider.fs</code>
 ):</p>
<pre class="programlisting">namespace FSharp.IO.DesignTime 
 
#nowarn "0025" 
 
open System.Reflection 
open System.IO 
open Microsoft.FSharp.Core.CompilerServices 
open ProviderImplementation.ProvidedTypes 
 
[&lt;TypeProvider&gt;] 
type public KeyStringProvider(config : TypeProviderConfig) as this =  
    inherit TypeProviderForNamespaces() 
 
    let nameSpace = "FSharp.IO" 
    let assembly = Assembly.LoadFrom(config.RuntimeAssembly) 
    let providerType = ProvidedTypeDefinition(assembly, nameSpace,
        "SecretKey", baseType = None, HideObjectMethods = true) 
 
    do 
        providerType.DefineStaticParameters( 
            parameters = [ ProvidedStaticParameter("Path", 
                typeof&lt;string&gt;) ], 
            instantiationFunction = fun typeName [| :? string as path 
              |] -&gt; 
                let t = ProvidedTypeDefinition(assembly, nameSpace,
                  typeName, baseType = Some typeof&lt;obj&gt;,
                  HideObjectMethods = true) 
                let fullPath = if Path.IsPathRooted(path) then path  
                  else Path.Combine(config.ResolutionFolder, path) 
                let content = File.ReadAllText(fullPath) 
                t.AddMember &lt;| ProvidedLiteralField("Key",
                    typeof&lt;string&gt;, content)
                t
            ) 
 
        this.AddNamespace(nameSpace, [ providerType ]) 
 
[&lt;assembly:TypeProviderAssembly()&gt;] 
do() 
</pre>
<p>That's not exactly 20 lines of code, but it's quite close. I will just outline the purpose of the bits and pieces in the preceding snippet.</p>
<div><h3 class="title" id="toc_5"><a id="note17"/>
 Note</h3>
<p>Those of you willing to tinker with the code of such sort may walk through 
<strong>Tutorial: Creating a Type Provider</strong>

 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider</a>
 ) as a supplementary helper.</p>
</div>
<p>After referring the pertinent libraries, the definition of our <code class="literal">KeyStringProvider</code>
  
<em>type provider type</em>

 (yes, type provider has its own type, sure thing) follows decorated with the <code class="literal">[&lt;TypeProvider&gt;]</code>
 attribute and inherited from the <code class="literal">TypeProviderForNamespaces</code>
 type, which is defined elsewhere in these auto-inserted code files.</p>
<p>The next three lines of code define the name and location of the provided type: <code class="literal">FSharp.IO.SecretKey</code>
 and the run-time assembly.</p>
<p>The body of the following <code class="literal">do</code>
 expression is the meat of the implementation. It defines that the provided type will have a single <code class="literal">Path</code>
 static parameter of type <code class="literal">string</code>
 , and most importantly, upon instantiation, the provider will read the text contained in the file referred by the <code class="literal">Path</code>
 and make the ingested string the value of the provided type's literal static field named <code class="literal">Key</code>
 . Right, I agree that the local text file is not the most reliable of key vaults, but this design choice is taken for brevity; the way the secret is kept is completely irrelevant to the subject. This part may be implemented in principle in any other manner.</p>
<p>The final <code class="literal">do()</code>
 expression decorated with the <code class="literal">[&lt;assembly:TypeProviderAssembly()&gt;]</code>
 attribute is just a type provider-specific assembly marker for the .NET assembly-loading machinery.</p>
<p>We are done. Building our project should produce <code class="literal">KeyTypeProvider.dll</code>
 in the target <code class="literal">bin</code>
 directory. Our type provider is ready to be put to work.</p>
<p>I've created the following short F# script for this purpose (<code class="literal">Ch11_2.fsx</code>
 ):</p>
<pre class="programlisting">#r @"C:\code\packtbook\KeyTypeProvider\bin\Debug\KeyTypeProvider.dll" 
open FSharp.IO 
open System 
 
type Vault = SecretKey&lt; @".\Secret.txt"&gt; 
 
let unlock = function 
| Vault.Key -&gt; true 
| _ -&gt; false 
 
while Console.ReadLine() |&gt; unlock |&gt; not do 
    printfn "Go away, Hacker!" 
 
printfn "Please proceed, Master!" 
</pre>
<p>In order for this script to compile, it is required that you put the <code class="literal">Secret.txt</code>
 file referred in the type declaration of <code class="literal">Vault</code>
 using our demo provided type, <code class="literal">FSharp.IO.SecretKey</code>
 , into the project directory side by side with the preceding script in the file system. As soon as we do this, Intellisense in Visual Studio begins working, which is reflected in the following figure:</p>
<div><img src="img/Image00054.jpg" alt="The demo solution"/>
<div><p>Local file contents packaged as a type's static field literal value</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Note that the type provider revealed the contents of the secret (the <code class="literal">ABigSecret</code>
 string line) at compile-time via Intellisense. Nevertheless, the secret is not present in the source code whatsoever. Also, having the secret referred to as a <code class="literal">Vault.Key</code>
 case of the <code class="literal">function</code>
 expression without any objections from the F# compiler clearly indicates that the compiler fully buys into it being a genuine literal string!</p>
<p>Now, it is time to see how all this plays outside of the type provider development environment, within a separate FSI session. The results are presented in the following screenshot and are fully aligned with the expectations. Just recollect the workings of this fun F# type provider application every time you feel any confusion about the type provider pattern applicability and abilities it should help you sort things out.</p>
<div><img src="img/Image00055.jpg" alt="The demo solution"/>
<div><p>Using the SecretKey type provider from the FSI script</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Wrapping up, F# type providers represent a rather unique idiomatic feature of automatic types generation that may deliver significant boosts in productivity and code quality.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch11lvl1sec68"/>
 Exploring concurrent computations</h1>
</div>
</div>
</div>
<p>To a great extent, the reinvigorated industrial attention on functional programming after many years of increased academic interest stems from the achieved capacities of electronics. On the one hand, the capabilities of contemporary computers make computer science findings considered more of a pure science savor thirty years ago quite practical today owing to an enormous increase in the speed and capacity of calculations. On the other hand, at the silicon level, the science has hit the physical limit for the further speeding-up of a single processor core operation. So the practical computation speed-up is happening along the lines of splitting a given amount of calculations between a group of processors working in a close concert.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch11lvl2sec123"/>
 The feature review</h2>
</div>
</div>
</div>
<p>The thing is that the brave new world of cheap multicore processors cannot afford expensive, error-prone, mentally onerous methods of programming. It is demanding the concurrency taming abstractions of a much higher level than the programming primitives for it that were developed by computer science in the era of the extensive growth of computing power.</p>
<p>These primitives have played their role in exposing the major problem behind concurrent calculations - such calculations are much less deterministic than we are accustomed to by dealing with sequential calculations. If the indeterminism in sequential calculations is usually associated with the imperfections of ambient physical environment materializing the former, the lack of determinism in concurrent calculations is intrinsic. This means that error-prone manipulation of programming primitives for synchronization between multiple co-executed calculations offers plenty of ways to shoot yourself in the foot.</p>
<p>The most prominent example of self-imposed indeterminism is 
<strong>deadlock</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Deadlock">https://en.wikipedia.org/wiki/Deadlock</a>
 ) when concurrent program parts lacking proper synchronization over shared resources may, under some conditions, mutually lock each other.</p>
<p>Much trickier (and potentially much more dangerous) are cases where the concurrent code may misbehave only under extremely rare conditions. This may be really dangerous because such conditions may not introduce themselves during quality assurance and user acceptance testing. Then, the defective code basically carrying a "bomb" gets released into production, and in full accordance with Murphy's Law, blows up at the most inappropriate obstacles.</p>
<p>The functional programming promise for better quality concurrent programs is so dear to the industry today that many mainstream programming languages are getting supplied with add-on functional features.</p>
<p>Before we look deeper into what F# offers to tame concurrency indeterminism, let's take a look at the distinctive facets under the common concurrency umbrella that are important to recognize:</p>
<div><ul class="itemizedlist">
<li class="listitem">

<strong>Synchronous and asynchronous</strong>

 : The first one, given a few expressions to evaluate, does not start the evaluation of the next expression before the previous one has been evaluated. The second one allows you to move between some half-evaluated expressions.</li>
<li class="listitem">

<strong>Concurrent and parallel</strong>

 : Parallelism assumes simultaneous evaluation of more than one expression using multiple processing units, while concurrency may be asynchronous partial evaluation of a few expressions by a single processing unit.</li>
<li class="listitem">

<strong>Interactive and reactive</strong>

 : The former drives the external environment, while the latter responds to external environment demands.</li>
</ul>
</div>
<p>F# offers usage patterns taming concurrency using a uniform mechanism of 
<strong>asynchronous expressions/workflows</strong>

 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows</a>
 ). Concisely, an asynchronous expression, which is a particular specific form of the computation expression mentioned earlier, is written in this form:</p>
<pre class="programlisting">async { expression } 
</pre>
<p>It has the generic type of <code class="literal">Async&lt;'T&gt;</code>
 . In turn, the <code class="literal">Async</code>
 class has a bunch of functions that trigger actual asynchronous evaluation of the preceding expression following a few scenarios.</p>
<p>This is a very elegant and straightforward mechanism indeed. It allows you to conceal the fact that evaluation is going to be concurrent behind familiar forms of function composition. For example, take into account this innocuous code snippet:</p>
<pre class="programlisting">[ for i in 91..100 -&gt; async { return i * i }] // Async&lt;int&gt; list 
|&gt; Async.Parallel // Async&lt;int []&gt; 
|&gt; Async.RunSynchronously // int []  
</pre>
<p>It performs a rather loaded function composition with intermediary types presented as line comments, where the first line using a list comprehension expression yields a <code class="literal">list</code>
 of <code class="literal">Async&lt;int&gt;</code>
 , which then with the help of the <code class="literal">Async.Parallel</code>
 combinator fans out into <code class="literal">Async&lt;int []&gt;</code>
 parallel calculations that, in turn, with another <code class="literal">Async.RunSynchronously</code>
 combinator, join their asynchronously calculated expressions into the <code class="literal">int []</code>
 array of results, yielding 10 numbers:</p>
<pre class="programlisting">val it : int [] = 
  [|8281; 8464; 8649; 8836; 9025; 9216; 9409; 9604; 9801;
    10000|] 
</pre>
<p>I will not attempt to prove to you that the preceding snippet will allow you to demonstrate performance gains from calculation parallelization. The preceding evaluation is so simple that the parallel snippet must in fact be 
<em>slower</em>

 than just sequential calculation analog:</p>
<pre class="programlisting">[for i in 91..100 -&gt; i * i] 
</pre>
<p>This is because the parallel CPU asynchronous arrangement should introduce an overhead in comparison with a straightforward sequential list comprehension evaluation.</p>
<p>However, it all changes when we step into territory that is dear to enterprise development, namely begin dealing with parallel I/O. Performance gains from the I/O parallelization are going to be the subject of the following demo problem illustrating the design pattern enabled by F# asynchronous calculations.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch11lvl2sec124"/>
 The demo problem</h2>
</div>
</div>
</div>
<p>Let me build an I/O-bound application that would allow the demonstration of a really overwhelming speedup when F# parallel I/O async pattern is applied. A good use case for this would be SQL Server with its scaling capabilities allowing you to reach persuasive improvements in comparison with multiple demos of concurrent web requests that F# authors and bloggers usually provide.</p>
<p>As an asynchronous concurrency vehicle, I'll be using the feature of the <code class="literal">FSharp.Data.SqlClient</code>
 type provider's 
<strong>SQLCommandProvider</strong>

 (<a class="ulink" href="https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs">https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs</a>
 ), which allows asynchronous querying with the help of the <code class="literal">AsyncExecute()</code>
 method.</p>
<p>I will create synchronous and asynchronous implementations of the same task of extracting data from SQL Server and then carrying out a performance comparison to detect and measure gains secured by F# asynchronous I/O usage pattern application.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch11lvl2sec125"/>
 The demo solution</h2>
</div>
</div>
</div>
<p>For the sake of conciseness, the SQL-related part is going to be extremely simple. Executing the following T-SQL script against the instance of the <code class="literal">(localdb)\ProjectsV12</code>
 database engine accompanying the installation of Visual Studio 2013 or any other Microsoft SQL Server installation available to you, given it fulfills the type provider 
<strong>system requirements</strong>

 (<a class="ulink" href="http://fsprojects.github.io/FSharp.Data.SqlClient/">http://fsprojects.github.io/FSharp.Data.SqlClient/</a>
 ), will create the necessary database components from scratch (<code class="literal">Ch11_1.sql</code>
 ):</p>
<pre class="programlisting">CREATE DATABASE demo --(1) 
GO 
 
Use demo  
GO  
 
SET ANSI_NULLS ON 
GO 
 
SET QUOTED_IDENTIFIER ON 
GO 
 
CREATE PROCEDURE dbo.MockQuery --(2) 
AS 
BEGIN 
  SET NOCOUNT ON; 
  WAITFOR DELAY '00:00:01' 
  SELECT 1 
END 
GO 
</pre>
<p>Here, the part marked <code class="literal">(1)</code>
 creates and prepares for use the instance of the <code class="literal">demo</code>
 database, and the part marked <code class="literal">(2)</code>
 puts the <code class="literal">dbo.MockQuery</code>
 stored procedure into this database. This stored procedure, which lacks input arguments, implements an extremely simple query. Specifically, first, it introduces a time delay of 1 second, mocking some data search activity and then it returns a single data row with the integer <code class="literal">1</code>
 as the execution result.</p>
<p>Now, I turn to commenting the F# script for the demo solution (<code class="literal">Ch11_1.fsx</code>
 ):</p>
<pre class="programlisting">#I __SOURCE_DIRECTORY__ 
#r @"../packages/FSharp.Data.SqlClient.1.8.1/lib/net40/FSharp.Data.SqlClient.dll" 
open FSharp.Data 
open System.Diagnostics 
 
[&lt;Literal&gt;] 
let connStr = @"Data Source=(localdb)\ProjectsV12;Initial Catalog=demo;Integrated Security=True" 
 
type Mock = SqlCommandProvider&lt;"exec MockQuery", connStr&gt; 
 
let querySync nReq = 
    use cmd = new Mock() 
    seq { 
        for i in 1..nReq do 
            yield (cmd.Execute() |&gt; Seq.head) 
        } |&gt; Seq.sum 
 
let query _ = 
    use cmd = new Mock() 
    async { 
        let! resp = cmd.AsyncExecute() 
        return (resp |&gt; Seq.head) 
    } 
 
let queryAsync nReq = 
    [| for i in 1..nReq -&gt; i |] 
    |&gt; Array.map query 
    |&gt; Async.Parallel 
    |&gt; Async.RunSynchronously 
    |&gt; Array.sum 
 
let timing header f args = 
    let watch = Stopwatch.StartNew() 
    f args |&gt; printfn "%s %s %d" header "result =" 
    let elapsed = watch.ElapsedMilliseconds 
    watch.Stop() 
    printfn "%s: %d %s %d %s" header elapsed "ms. for" args       "requests" 
</pre>
<div><h3 class="title" id="toc_4"><a id="tip18"/>
 Tip</h3>
<p>Consider that the preceding F# code taken literally will not compile because of a few line wraps introduced by typesetting. Instead, use the code part accompanying the book as the source of working F# code.</p>
</div>
<p>After loading the type provider package and opening the required libraries, the <code class="literal">connStr</code>
 value decorated with the <code class="literal">[&lt;Literal&gt;]</code>
 attribute signifies both design-time and execution-time SQL server connection strings. This line might require modifications if you are using some other version of database engine.</p>
<p>The next line delivers the type provider magic by introducing the <code class="literal">SqlCommandProvider</code>
 provided type <code class="literal">Mock</code>
 ensuring statically typed access to the results of the wrapped query that is represented by the stored procedure call, <code class="literal">exec MockQuery</code>
 , over our <code class="literal">connStr</code>
 connection string.</p>
<p>The following <code class="literal">querySync</code>
 function ensures sequential execution of the <code class="literal">cmd</code>
 command represented by the instance of the provided <code class="literal">Mock</code>
 type given the number of times <code class="literal">nReq</code>
 yields a sequence of query results (each is just <code class="literal">1</code>
 from the single row of the result set) and then aggregates this sequence with <code class="literal">Seq.sum</code>
 . If we evaluate the <code class="literal">querySync 10</code>
 expression, we may expect a bit above a 10 second delay in getting back a single number, <code class="literal">10</code>
 .</p>
<p>So far, so good. The following <code class="literal">query</code>
 function takes any argument and returns an asynchronous computation of type <code class="literal">Async&lt;int&gt;</code>
 . I put this function within the combined expression wrapped into the <code class="literal">queryAsync</code>
 function, effectively representing the concurrent variant of <code class="literal">querySync</code>
 . Specifically, the array of <code class="literal">nReq</code>
 numbers is mapped into an <code class="literal">Async&lt;int&gt;</code>
 array of the same size, and then they are all fanned out by <code class="literal">Async.Parallel</code>
 , joined back after completion with <code class="literal">Async.RunSynchronously</code>
 and eventually aggregated by <code class="literal">Array.sum</code>
 into a single number.</p>
<p>The last piece is an instrumentation higher-order <code class="literal">timing</code>
 function that just measures and outputs the evaluation of the <code class="literal">f args</code>
 computation duration in milliseconds.</p>
<p>Alright; now, it is time to take our script for a spin. I put the code into FSI and measure the duration of executing <code class="literal">querySync</code>
 and <code class="literal">queryAsync</code>
 100 times. You can see the measurement results in the following screenshot:</p>
<div><img src="img/Image00056.jpg" alt="The demo solution"/>
<div><p>Measuring synchronous versus asynchronous SQL querying</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Are you as impressed as I am? Results show that I/O parallelization in the case of SQL queries allowed improved performance approximately 100-fold!</p>
<p>This demo is quite persuasive and I strongly recommend that you master and use this and other F# idiomatic concurrency patterns in your practical work.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch11lvl1sec69"/>
 Exploring reactive computations</h1>
</div>
</div>
</div>
<p>Reactive computations are the part of concurrent computations' scope. They just stress a slightly different matter, namely the processing of general events. The processing of events may be genuinely concurrent, when one or more of simultaneously occurring events are processed without any sort of serialization or genuinely sequential if a new event is not processed until the processing of the previous one has finished.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch11lvl2sec126"/>
 The feature review</h2>
</div>
</div>
</div>
<p>Usually, the event processing view akin to concurrency takes roots at the development of the systems that have 
<strong>user interface</strong>

 (
<strong>UI</strong>

 ) component(s) when sluggish processing of data coming from input devices and/or data reflecting the visual state of graphic UI components is simply unacceptable as it creates a terrible 
<strong>user experience</strong>

 (
<strong>UX</strong>

 ).</p>
<p>This is all good and true, but let's concentrate on an aspect not directly related to UI/UX, namely the conceptual consideration of 
<strong>event processing</strong>

 taking place. As this consideration is tied to F#, I will limit the review with .NET boundaries.</p>
<p>Historically, the development of interactive operating systems such as Windows coined the concept of 
<strong>callback</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">https://en.wikipedia.org/wiki/Callback_(computer_programming)</a>
 ), which brought to consideration 
<strong>events</strong>

 and 
<strong>event handlers</strong>

 . This is the lowest conceptual level of reactive programming, where the developer's responsibility is to provide the handlers for each event class.</p>
<p>The next abstraction level in reactive computations came with object-oriented programming and is manifested by the 
<strong>Observer design pattern</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Observer_pattern">https://en.wikipedia.org/wiki/Observer_pattern</a>
 ). Now, the developer may think of a specific event type processing flow as an interaction between the event type (in other words, 
<strong>subject</strong>

 ) source named 
<strong>Observable</strong>

 and zero or more parties interested in the processing of this subject event named 
<strong>Observers</strong>

 . Observers manifest their interest in the subject by dynamically 
<strong>registering</strong>

 and 
<strong>unregistering</strong>

 with the corresponding Observable. As soon as the next event belonging to the subject comes into existence, all Observers registered at the moment with the corresponding Observer get notified about the chance of processing the event and then continue waiting for the next one.</p>
<p>Finally, the conceptual quintessence for reactive computations took place with the seminal work of a group headed by computer scientist 
<strong>Erik Meijer</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)">https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)</a>
 ), who created 
<strong>Reactive Extensions (Rx) for .NET</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx">https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx</a>
 ).</p>
<p>The key idea behind Rx is concentrating on 
<strong>pushing</strong>

 versus 
<strong>pulling</strong>

 data sequences by introducing a fundamental <code class="literal">IObservable</code>
 interface that is a reversal of <code class="literal">IEnumerable</code>
 in the way it exposes the event data stream. This is similar to how "normal" data sequences, after being enumerated, can be pulled-composed by higher-order functions and queried using LINQ--and observable event sequences (event streams) may be received--composed with higher-order functions and processed by LINQ.</p>
<p>F# supports all three of the preceding abstractions, throwing in some improvements in comparison with other programming languages of the .NET platform.</p>
<div><h3 class="title" id="toc_2"><a id="note19"/>
 Note</h3>
<p>This subject matter is very well documented and I refer you to related F#-specific documentation on the <code class="literal">Microsoft.FSharp.Control</code>
 namespace pieces and <code class="literal">Reactive Extensions (Rx)</code>
 for details: 
<strong>Event module</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d</a>
 ). 
<strong>Observable module</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d</a>
 ). 
<strong>Reactive Extensions</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/en-us/data/gg577609.aspx">https://msdn.microsoft.com/en-us/data/gg577609.aspx</a>
 ).</p>
</div>
<p>Instead of retelling the preceding documentation, I will take F# reactive computation features for a spin, implementing a relevant practical task. I will try to make the implementation self-contained.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch11lvl2sec127"/>
 The demo problem</h2>
</div>
</div>
</div>
<p>Let's consider the following 
<strong>integration pattern </strong>

 ( <a class="ulink" href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/">http://www.enterpriseintegrationpatterns.com/patterns/messaging/</a>
 ) that is quite typical for the enterprise: document message exchange over two point-to-point channels. We are a client of an external service that communicates with us using a pair of dedicated channels. If we need to send a document message, we just push it into the outbound channel and the remote service somehow consumes it. If the service sends a message(s) back to us, they are delivered into the inbound channel. As soon as we pull a document message from the inbound channel, it gets removed from there. The following figure illustrates this interaction.</p>
<div><img src="img/Image00057.jpg" alt="The demo problem"/>
<div><p>Enterprise two-way document exchange</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Those of you who get involved in Enterprise LOB development have perhaps already recognized a typical case of peer-to-peer 
<strong>Electronic Data Interchange (EDI)</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer">https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer</a>
 ). Often, providers are quite conservative in choosing specific transfer protocols and prefer sticking to "old but gold" technologies such as 
<strong>SSH File Transfer Protocol (SFTP)</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol">https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol</a>
 ) for a reasonably inexpensive way of integration when data security is a requirement. As an enterprise may be involved into EDI with multiple remote service providers, the amount of such arrangements may be quite significant.</p>
<p>Nevertheless, I'm not going to concentrate on building a configurable library that allows the addition of a new EDI provider with a few lines of code. Instead, I will address the semantics layer that usually stands outside of architectural considerations, namely relations that may need to be enforced between bidirectional document message exchanges that, for SFTP transfer, translate into pushing and pulling formatted files to/from the service provider.</p>
<p>To be a bit more specific, I offer to your attention a real case from the 
<strong>Jet.com</strong>

 (<a class="ulink" href="https://jet.com/">https://jet.com/</a>
 ) Finance realm, where I at the moment write F# code for a living. Let's consider the payment system as a client and the bank as a service provider. The service gist is to execute payment advices and deliver remittances to the bank accounts of legal and physical entities with whom Jet.com gets into temporary "I owe you" relations: suppliers and vendors, merchants of the marketplace, employees with outstanding reimbursable business expenses and the like.</p>
<p>Now, let's assume that we have built our communication code around SFTP, which pushes remittances to the bank, gets back statements, originations and the like, all retries are in place, and all wheels are rotating smoothly. Are we doing fine?</p>
<p>Turns out the answer is "not really". We silently assume at this point that the bank's implementation is free of problems based on a whole slew of fallacies, such as "it's about finance", "the bank would not survive if it had bugs", "it is too big to allow failures" and similar. However, the bank's software is just software and is susceptible to all kinds of human errors. We may expect its reliability to be overall higher than in a random start-up minimal viable product code constituting a web application implementing a hot business idea and written in a garage during few hackathons. On the other hand, each bank's software release carries the next "last bug" in it, doesn't it?</p>
<p>It so happened one day that Jet's bank client software did not provision for the following scenario: what if the bank correctly accepts and executes each payment advice, but once in a while it does not communicate the deferred final payment status back to us? The payment recipients are all happy with remittance cash hitting their accounts and no communication errors taking place. If we take the successful outcome of our deliverable payment advices for granted, this bug may stay there forever! This is a low probability scenario but not absolutely improbable. In fact, a similar defect went unnoticed in Jet's payment arrangement for a short time until marketplace reports started showing a growing amount of deferred payments. That was embarrassing!</p>
<p>Can we fix this by being proactive with our "pull" data transfer part? Keep reading for the outline of the potential solution.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch11lvl2sec128"/>
 The demo solution</h2>
</div>
</div>
</div>
<p>One of the (overly simplified) potential solutions would be to mix the flow of "heartbeat" events with the flow of guarded events. As the generalization of guarding a single event of a certain type to any number events of a similar type is not challenging, let me consider a single guarded event of a type for brevity.</p>
<p>Within this guarded event flow mix, we establish a threshold upon how many heartbeats are considered healthy between the start of guarding the event and the actual occurrence of the guarded event. For example (the specific numbers do not anyhow coincide with real ones), we may say that if the ACH payment is being sent and after following three heartbeat events, <code class="literal">ACHOrigination</code>
 event is still not received, this should be the indication of a problem and the responsible personnel must be alerted of the deviation.</p>
<p>Now let me implement the preceding using Reactive Extensions (<code class="literal">Ch11_3.fsx</code>
 ):</p>
<pre class="programlisting">#I __SOURCE_DIRECTORY__ 
#r "../packages/FSharp.Control.Reactive.3.4.1/lib/net45/FSharp.Control.Reactive.dll" 
#r "../packages/Rx-Core.2.2.5/lib/net45/System.Reactive.Core.dll" 
#r "../packages/Rx-Interfaces.2.2.5/lib/net45/System.Reactive.Interfaces.dll" 
#r "../packages/Rx-Linq.2.2.5/lib/net45/System.Reactive.Linq.dll" 
 
open System.Reactive.Subjects 
 
type PaymentFlowEvent = 
| HeartBeat 
| ACHOrigination 
| GuardOn 
 
type GuardACHOrigination(flow: Subject&lt;PaymentFlowEvent&gt;, alerter: Subject&lt;string&gt;) = 
    let threshold = 3 
    let mutable beats = 0 
    let mutable guardOn = false 
 
    member x.Guard() = 
        beats &lt;- 0 
        guardOn &lt;- false 
        flow.Subscribe(function 
            | HeartBeat -&gt; if guardOn then beats &lt;- beats + 1; 
                printfn "Heartbeat processed"; 
                if beats &gt; threshold &amp;&amp; guardOn
                    then alerter.OnNext "No timely ACHOrigination" 
            | ACHOrigination -&gt; beats &lt;- 0; 
                guardOn &lt;- false 
                printfn "ACHOrigination processed" 
            | GuardOn -&gt; beats &lt;- 0; guardOn &lt;- true;
                printfn "ACHOrigination is guarded") 
 
let paymentFlow = new Subject&lt;PaymentFlowEvent&gt;() 
let alerter = new Subject&lt;string&gt;() 
let notifier = alerter.Subscribe(fun x -&gt; printfn "Logged error %s" x) 
 
ignore &lt;| GuardACHOrigination(paymentFlow,alerter).Guard() 
</pre>
<p>After loading a slew of required components from the corresponding NuGet libraries, I introduce the <code class="literal">PaymentFlowEvent</code>
 type reflecting the mix of the previously mentioned three events.</p>
<p>Next, the <code class="literal">GuardACHOrigination</code>
 class combines the stream of <code class="literal">PaymentFlowEvent</code>
 events set by argument <code class="literal">flow</code>
 , which is also known as <code class="literal">Subject</code>
 , <code class="literal">alerter</code>
 for the carrying out of notifications, and business logic combining all these parts together. 
<strong>Subject</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx">https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx</a>
 ) is a combination of the observable sequence and Observer, and it plays the central role in the preceding implementation.</p>
<p>The <code class="literal">Guard()</code>
 method takes <code class="literal">flow</code>
 , and with the help of its <code class="literal">Subscribe</code>
 method, sets a simple state machine tracking of what is going on upon the arrival of each instance of flowing through events of type <code class="literal">PaymentFlowEvents</code>
 . Given that the abnormality is recognized, the diagnostics notification is pushed into <code class="literal">alerter</code>
 .</p>
<p>Now, I create the required bits and pieces: <code class="literal">paymentFlow</code>
 representing the event stream of interest, <code class="literal">alerter</code>
 to receive notifications within <code class="literal">Guard()</code>
 , <code class="literal">notifier</code>
 to act upon notification events from <code class="literal">alerter</code>
 , and finally, fireup everything to life with <code class="literal">GuardACHOrigination(paymentFlow,alerter).Guard()</code>
 .</p>
<p>Great; now it's time to push a stream of events into the built arrangement and observe the reactive behavior in FSI. The following screenshot reflects that the code behavior is completely aligned with the expected: timely guarded events pass smoothly, overdue guarded events trigger alerts, and unguarded events get disregarded:</p>
<div><img src="img/Image00058.jpg" alt="The demo solution"/>
<div><p>Guarding the event flow with the F# reactive code</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The demonstrated pattern of applying F# in a reactive manner is an important tool belt skill that should be mastered by enterprise practitioners.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch11lvl1sec70"/>
 Exploring quotations and metaprogramming</h1>
</div>
</div>
</div>
<p>The last feature I want to cover among the advanced patterns of F# use is 
<strong>Code Quotations</strong>

  (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations</a>
 ). This feature is quite mind-bending, allowing you to work with the program code as if it is data, and evaluate these "program as data" pieces when needed and in the needed manner.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch11lvl2sec129"/>
 The feature review</h2>
</div>
</div>
</div>
<p>Looking at this feature from the more operational angle, a program piece may be represented as an expression tree representing the code but without running the code generation off this representation. This allows for arbitrary execution behavior when the expression tree is to be evaluated. It can be evaluated as F# code or as source to generate JavaScript code or even as GPU-executed code or in any other feasible manner.</p>
<p>The cool thing about quoted expressions is that they are typed, they can be spliced together from parts, or they can be decomposed into parts using active patterns, among other features. Without delving into too much detail, I want to demonstrate that if required, F# offers this extra layer of flexibility by allowing you to tweak the program code and evaluate the tweaked code programmatically. For this purpose, I will be using 
<strong>F# Quotations Evaluator</strong>

 (<a class="ulink" href="http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html">http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html</a>
 ).</p>
<p>A very brief demonstration of the feature abilities is as follows (<code class="literal">Ch11_4.fsx</code>
 ):</p>
<div><ul class="itemizedlist">
<li class="listitem">Get the required library support:<pre class="programlisting">        #I __SOURCE_DIRECTORY__ 
        #r 
         "../packages/FSharp.Quotations.Evaluator.1.0.7/lib
         /net40/FSharp.Quotations.Evaluator.dll" 
        open FSharp.Quotations.Evaluator 
</pre>
</li>
<li class="listitem">Create a <code class="literal">mutable</code>
 quoted <code class="literal">divider</code>
 value:<pre class="programlisting">        let mutable divider = Quotations.Expr.Value (5) 
</pre>
</li>
<li class="listitem">Create and compile a function with <code class="literal">divider</code>
 spliced into this:<pre class="programlisting">        let is5Divisor = &lt;@ fun x -&gt; x % %%divider = 0 @&gt; 
           |&gt; QuotationEvaluator.Evaluate 
</pre>
</li>
<li class="listitem">Apply the compiled <code class="literal">is5Divisor</code>
 function to a few arguments:<pre class="programlisting">        is5Divisor 14 // false 
        is5Divisor 15 // true 
</pre>
</li>
<li class="listitem">Change the spliced <code class="literal">divider</code>
 value:<pre class="programlisting">        divider &lt;- Quotations.Expr.Value (7) 
</pre>
</li>
<li class="listitem">Note that <code class="literal">is5Divisor</code>
 workings did not change:<pre class="programlisting">        is5Divisor 14 // false 
</pre>
</li>
<li class="listitem">Recompile the spliced <code class="literal">divider</code>
 value into another function:<pre class="programlisting">        let is7Divisor = &lt;@ fun x -&gt; x % %%divider = 0 @&gt; 
           |&gt; QuotationEvaluator.Evaluate 
</pre>
</li>
<li class="listitem">Apply the newly compiled <code class="literal">is7divisor</code>
 function:<pre class="programlisting">        is7Divisor 14 // true 
</pre>
</li>
</ul>
</div>
<p>Equipped with some understanding of how quotations work, let me now apply the feature to a sizable demo problem.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch11lvl2sec130"/>
 The demo problem</h2>
</div>
</div>
</div>
<p>While looking for a demo problem, I turn to the finance space again. Let's look at the matter of invoice total adjustment based on the timeliness of payment. Paying an outstanding invoice early may bring some savings, while being late on it may impose penalties. When a vendor or supplier establishes payment terms, any combination of premiums and/or penalties may be set: neither premium nor penalty, just a premium, just a penalty, and both premium and penalty. It would be great to have an arrangement that would allow you to easily and naturally handle this variety. In other words, an adjustment is sought - for that, when applied to the invoice total and the payment date, finds out what the actual payment amount aligned with the payment terms would be.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch11lvl2sec131"/>
 The demo solution</h2>
</div>
</div>
</div>
<p>Here is the script implementing the sought adjustment object (<code class="literal">Ch11_4.fsx</code>
 ):</p>
<pre class="programlisting">#I __SOURCE_DIRECTORY__ 
#r "../packages/FSharp Quotations.Evaluator.1.0.7/lib/net40/FSharp.Quotations.Evaluator.dll" 
open FSharp.Quotations.Evaluator 
open System.Collections.Generic 
open System 
 
type Adjustment = 
| Absent 
| Premium of TimeSpan * decimal 
| Penalty of TimeSpan * decimal 
 
type Terms(?premium: Adjustment, ?penalty: Adjustment) = 
    let penalty = defaultArg penalty Absent 
    let premium = defaultArg premium Absent 
           
    member x.Adjust() = 
        match premium,penalty with 
        | Absent,Absent -&gt; None 
        | Absent,Penalty (d,m) -&gt; Some(&lt;@ fun ((date:DateTime),amount) -&gt; if DateTime.UtcNow.Date - date.Date &gt; d then Decimal.Round(amount * (1M + m),2) else amount @&gt; |&gt; QuotationEvaluator.Evaluate) 
        | Premium(d,m),Absent -&gt; Some(&lt;@ fun ((date:DateTime),amount) -&gt; if DateTime.UtcNow.Date - date.Date &lt; d then Decimal.Round(amount * (1M - m),2) else amount @&gt; |&gt; QuotationEvaluator.Evaluate) 
        | Premium(d',m'),Penalty (d,m) -&gt; Some(&lt;@ fun ((date:DateTime),amount) -&gt; 
            if DateTime.UtcNow.Date - date.Date &gt; d then Decimal.Round(amount * (1M + m),2) 
            elif DateTime.UtcNow.Date - date.Date &lt; d' then Decimal.Round(amount * (1M - m'),2) 
            else amount @&gt; |&gt; QuotationEvaluator.Evaluate) 
        | _,_ -&gt; None 
</pre>
<p>The first thing to note is that the the necessary library is loaded.</p>
<p>Then the <code class="literal">Adjustment</code>
 type is defined, which is either <code class="literal">Absent</code>
 or <code class="literal">Premium</code>
 /<code class="literal">Penalty</code>
 with the structure of the <code class="literal">System.TimeSpan*decimal</code>
 tuple, where the <code class="literal">TimeSpan</code>
 part defines the amount of time between invoice issuance and payment dates and <code class="literal">decimal</code>
 sets the adjustment multiplier. For <code class="literal">Premium</code>
 , the tuple is interpreted as "if the number of days between the invoice issuance and payment is less or equal to <code class="literal">TimeSpan</code>
 , then the amount of payment should be decreased by the <code class="literal">decimal</code>
 multiplier". For <code class="literal">Penalty</code>
 , it is "if the number of days between the invoice issuance and payment is greater or equal to <code class="literal">TimeSpan</code>
 , then the amount of payment should be increased by the <code class="literal">decimal</code>
 multiplier".</p>
<p>The <code class="literal">Terms</code>
 type captures the adjustment terms within the <code class="literal">Adjust</code>
 method. Using F# quotations, it defines payment adjustment functions for each potential combination of terms, and then it either implements the prescribed adjustment or it doesn't.</p>
<p>Now, in order to see how it would work, we need a test bed. Let's define a record representing invoice:</p>
<pre class="programlisting">type Invoice = { total:decimal ; date:System.DateTime; } 
</pre>
<p>Let's also define test list of invoices:</p>
<pre class="programlisting">let invoices = [ 
    { total=1005.20M; date=System.DateTime.Today.AddDays(-3.0) } 
    { total=5027.78M; date=System.DateTime.Today.AddDays(-29.0) } 
    { total=51400.49M; date=System.DateTime.Today.AddDays(-36.0) } 
] 
</pre>
<p>The function deriving the amount of payment due is now based on terms, and the invoice may look like the following:</p>
<pre class="programlisting">let payment (terms: Terms) invoice = let adjust = terms.Adjust() in if adjust.IsSome then (adjust.Value) (invoice.date, invoice.total) else invoice.total 
</pre>
<p>Now, it is time to define a full variety of the possible terms:</p>
<pre class="programlisting">let terms = Terms(penalty=Penalty(TimeSpan.FromDays(31.),0.015M),
  premium=Premium(TimeSpan.FromDays(5.),0.02M)) 
let termsA = Terms() 
let termsB = Terms(Premium(TimeSpan.FromDays(4.),0.02M)) 
let termsC = Terms(penalty=Penalty(TimeSpan.FromDays(30.),0.02M)) 
</pre>
<p>And finally, we can observe in the following screenshot how all this plays together after being applied to test invoices by applying each payment term to the same invoice group:</p>
<div><img src="img/Image00059.jpg" alt="The demo solution"/>
<div><p>Using F# quotations</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch11lvl1sec71"/>
 Summary</h1>
</div>
</div>
</div>
<p>In this chapter, we assayed a few features of advanced F# usage category. I hope I was able to demonstrate that even for the advanced features, F# continues to keep the promise of "solving complex problems with simple code".</p>
<p>Now is a good time to pay further attention to the subject constituting this book's title. The content so far did not in any way cross the traditional view of design patterns usually associated with the contents of 
<strong>Gang of Four Book</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns</a>
 ). In the next chapter, I will justify the taken approach by observing the "classic" design patterns and principles from a functional-first view point.</p>
</div>
</body></html>