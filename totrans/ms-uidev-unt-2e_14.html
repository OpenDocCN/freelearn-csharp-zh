<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-192"><a id="_idTextAnchor292" class="pcalibre pcalibre1 calibre6"/>11</h1>
<h1 id="_idParaDest-193" class="calibre5"><a id="_idTextAnchor293" class="pcalibre pcalibre1 calibre6"/>UI Images and Effects</h1>
<p class="calibre3">We’ve worked with UI Images in the previous chapters, but now we’ll learn more about the component’s specific properties, as well as how to access the component via code. We’ll also look at some of the UI effect components that we can apply to our UI objects for visual appeal. While we will look at the components thoroughly, the majority of this chapter focuses on specific worked-out examples of UI functionality that you will find in video games, particularly mobile video games.</p>
<p class="calibre3">In this chapter, we will discuss the following topics:</p>
<ul class="calibre16">
<li class="calibre14">Creating UI Images and setting their properties</li>
<li class="calibre14">Using the various UI effects components to further customize our graphical UI</li>
<li class="calibre14">Implementing horizontal and circular progress bars</li>
<li class="calibre14">How to create Buttons that swap sprites without using the built-in transitions, like a mute/unmute Button</li>
<li class="calibre14">Adding a press-and-hold/long-press functionality</li>
<li class="calibre14">Creating an onscreen four-directional virtual D-Pad</li>
<li class="calibre14">Creating a floating eight-directional virtual analog stick</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">All the examples shown in the sections before the <em class="italic">Examples</em> section can be found within the Unity project provided in the code bundle. They can be found within the scene labeled <strong class="source-inline1">Chapter11</strong>.</p>
<p class="callout">Each example figure has a caption stating the example name within the scene.</p>
<p class="callout">In the scene, each example is on its own Canvas, and some of the Canvases are deactivated. To view an example on a deactivated Canvas, simply select the checkbox next to the Canvas’ name in the Inspector. Each Canvas is also given its own Event System. This will cause errors if you have more than one Canvas activated at a time.</p>
<h1 id="_idParaDest-194" class="calibre5"><a id="_idTextAnchor294" class="pcalibre pcalibre1 calibre6"/>Technical requirements</h1>
<p class="calibre3">You can find the relevant codes and asset files of this chapter here: <a href="https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011" class="pcalibre pcalibre1 calibre6">https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011</a></p>
<h1 id="_idParaDest-195" class="calibre5"><a id="_idTextAnchor295" class="pcalibre pcalibre1 calibre6"/>UI Image component properties</h1>
<p class="calibre3">We’ve created a UI Image before, but<a id="_idIndexMarker629" class="pcalibre pcalibre1 calibre6"/> let’s look at its properties and components.</p>
<p class="calibre3">You can create a new UI Image object using <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Image</strong>.</p>
<p class="calibre3">The UI <code>Image</code> object contains the <strong class="bold">Rect Transform</strong> and <strong class="bold">Canvas Renderer</strong> components as well as the <strong class="bold">Image</strong> component. We’ve looked at the <strong class="bold">Rect Transform</strong> and <strong class="bold">Canvas Renderer</strong> components extensively; now, let’s look at the <strong class="bold">Image</strong> component.</p>
<p class="calibre3">The first setting on the <strong class="bold">Image</strong> component is the <strong class="bold">Source Image</strong> property, which represents the sprite that will be rendered. The <strong class="bold">Color</strong> property represents the base color of the sprite being rendered. Leaving the color at white will make the Image appear exactly as the sprite, but changing the color will add a tinted color overlay to the Image. You can also change the transparency of the Image by reducing the alpha value. The <strong class="bold">Material</strong> property allows you to add a material to the Image.</p>
<p class="calibre3">The <strong class="bold">Raycast Target</strong> and <strong class="bold">Raycast Padding</strong> properties work the same way they do on the <strong class="bold">Text</strong> component, by specifying whether the Image will block clicks on UI objects behind it or not and if there is any padding to the block. The <strong class="bold">Maskable</strong> property determines if the Image can be affected by masks or not.</p>
<p class="calibre3">When a sprite is assigned to the <strong class="bold">Source Image</strong> slot, new options appear in the <strong class="bold">Image</strong> component under <strong class="bold">Image Type</strong>, as shown in the following figure:</p>
<div><div><img alt="Figure 11.1: The UI Image component and all its properties" src="img/B18327_11_01.jpg" class="calibre351"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.1: The UI Image component and all its properties</p>
<p class="calibre3">Let’s look at the various <a id="_idIndexMarker630" class="pcalibre pcalibre1 calibre6"/>options for <strong class="bold">Image Type</strong> and how they affect a sprite.<a id="_idTextAnchor296" class="pcalibre pcalibre1 calibre6"/></p>
<h2 id="_idParaDest-196" class="calibre7"><a id="_idTextAnchor297" class="pcalibre pcalibre1 calibre6"/>Image Type</h2>
<p class="calibre3">The <strong class="bold">Image Type</strong> property determines<a id="_idIndexMarker631" class="pcalibre pcalibre1 calibre6"/> how the sprite specified by <strong class="bold">Source Image</strong> will appear. There are four options: <strong class="bold">Simple</strong>, <strong class="bold">Sliced</strong>, <strong class="bold">Tiled</strong>, and <strong class="bold">Filled</strong>. Let’s take a look at them.<a id="_idTextAnchor298" class="pcalibre pcalibre1 calibre6"/></p>
<h3 class="calibre9">Simple</h3>
<p class="calibre3">An Image with its <strong class="bold">Image Type</strong> property set to <strong class="bold">Simple</strong> scales evenly across the sprite. This is the default type. When <strong class="bold">Simple</strong> is selected <a id="_idIndexMarker632" class="pcalibre pcalibre1 calibre6"/>as the <strong class="bold">Image Type</strong>, a toggle labeled <strong class="bold">Use Sprite Mesh</strong>, a toggle labeled <strong class="bold">Preserve Aspect</strong>, and a button labeled <strong class="bold">Set Native Size</strong> become available.</p>
<p class="calibre3">Selecting the <strong class="bold">Use Sprite Mesh</strong> toggle will have the Image use the sprite mesh created by the <strong class="bold">TextureImporter</strong>. By default, this property is deselected, and the sprite’s mesh is a quad. You will select this property if you don’t want the Image represented by a rectangle, but instead want it to have a mesh that fits tightly around the visible area of the Image.</p>
<p class="calibre3">When the <strong class="bold">Preserve Aspect</strong> property is checked, the sprite will display with its portions preserved and may not appear to fill the entire area of the Rect Transform. Selecting this property ensures that your sprites look as originally intended and are not stretched out.</p>
<p class="calibre3">Selecting the <strong class="bold">Set Native Size</strong> button <a id="_idIndexMarker633" class="pcalibre pcalibre1 calibre6"/>sets the dimensions of the Image to the pixel dimensions of the spri<a id="_idTextAnchor299" class="pcalibre pcalibre1 calibre6"/>te.</p>
<h3 class="calibre9">Sliced</h3>
<p class="calibre3"><strong class="bold">Sliced</strong> Images are split into nine areas. When a <strong class="bold">Sliced</strong> Image is scaled, all areas of the Image are scaled, except the corners. This <a id="_idIndexMarker634" class="pcalibre pcalibre1 calibre6"/>allows you to scale an Image without distorting its corners. This works particularly well with sprites that have rounded corners that you want to be able to stretch into rounded rectangles.</p>
<p class="calibre3">When an image is set to <strong class="bold">Sliced</strong>, the <strong class="bold">Fill Center</strong> and <strong class="bold">Pixels Per Unit Multiplier</strong> properties appear. The following figure shows a rounded rectangle with five alternate versions of it being stretched. You can see how selecting <strong class="bold">Sliced</strong> allows the rounded rectangle to stretch in a way that maintains the rounded rectangle shape while leaving the <strong class="bold">Image Type</strong> at <strong class="bold">Simple</strong> causes a distortion in the edges of the Image when it is scaled.</p>
<div><div><img alt="Figure 11.2: Sliced Image Type Example in the Chapter11 scene" src="img/B18327_11_02.jpg" class="calibre352"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11<a id="_idTextAnchor300" class="pcalibre pcalibre1 calibre6"/>.2: Sliced Image Type Example in the Chapter11 scene</p>
<p class="calibre3">You must specify where the nine areas will be, within the <strong class="bold">Sprite Editor</strong> of the sprite or sprite sheet. If you have not specified the regions, a message will appear within the <strong class="bold">Image</strong> component.</p>
<p class="calibre3">To specify the area in the <strong class="bold">Sprite Editor</strong>, you need to drag the green boxes on the edges of the sprite to the desired position. As you can see from the following screenshot, you want to drag the <a id="_idIndexMarker635" class="pcalibre pcalibre1 calibre6"/>green lines so that they stop surrounding the curves of the edges:</p>
<div><div><img alt="Figure 11.3: Specifying the nine areas of a sprite in the Sprite Editor" src="img/B18327_11_03.jpg" class="calibre353"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.3: Specifying the nine areas of a sprite in the Sprite Edi<a id="_idTextAnchor301" class="pcalibre pcalibre1 calibre6"/>tor</p>
<p class="calibre3">Next, let’s talk about the <strong class="bold">Tiled</strong> option under the <strong class="bold">Image Type</strong>.</p>
<h3 class="calibre9">Tiled</h3>
<p class="calibre3">Selecting <strong class="bold">Tiled</strong> for <strong class="bold">Image Type</strong> will cause <a id="_idIndexMarker636" class="pcalibre pcalibre1 calibre6"/>the Image to repeat to fill the stretched area. The following figure demonstrates how selecting <strong class="bold">Simple</strong> and <strong class="bold">Tiled</strong> for <strong class="bold">Image Type</strong> affects the scaled Images:</p>
<div><div><img alt="Figure 11.4: Tiled Image Type Example in the Chapter11 scene" src="img/B18327_11_04.jpg" class="calibre354"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.4: Tiled Image Type Example in the Chapter11 scene</p>
<p class="calibre3">Next, let’s talk about the <strong class="bold">Filled</strong> option <a id="_idIndexMarker637" class="pcalibre pcalibre1 calibre6"/>under the <strong class="bold">Image T<a id="_idTextAnchor302" class="pcalibre pcalibre1 calibre6"/>ype</strong>.</p>
<h3 class="calibre9">Filled</h3>
<p class="calibre3">Images with <strong class="bold">Filled</strong> selected for their <strong class="bold">Image Type</strong> will fill in <a id="_idIndexMarker638" class="pcalibre pcalibre1 calibre6"/>a percentage of the sprite, starting at an origin in a specified direction. Any part of the sprite past the designated percentage will not be rendered. When <strong class="bold">Filled</strong> is selected, new properties are displayed:</p>
<div><div><img alt="Figure 11.5: Properties for a Filled Image" src="img/B18327_11_05.jpg" class="calibre355"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.5: Properties for a Filled Image</p>
<p class="calibre3">The <code>0.75</code> or 75 percent:</p>
<div><div><img alt="Figure 11.6: Filled Image Type Example in the Chapter11 scene" src="img/B18327_11_06.jpg" class="calibre356"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.6: Filled Image Type Example in the Chapter11 scene</p>
<p class="calibre3">The <strong class="bold">Horizontal</strong> and <strong class="bold">Vertical</strong> <strong class="bold">Fill Method</strong> options are somewhat self-explanatory when you see them in action, but it’s a little more difficult to determine exactly how the three radial methods work just from looking at them. <strong class="bold">Radial 90</strong> places the center of the radial at one of the corners, <strong class="bold">Radial 180</strong> places the center of the radial at one of the edges, and <strong class="bold">Radial 360</strong> places the center of the radial in the center of the sprite.</p>
<p class="calibre3">The <strong class="bold">Filled</strong> <strong class="bold">Image Type</strong> option also has the <strong class="bold">Set Native </strong><strong class="bold">Size</strong> property.</p>
<p class="calibre3">Now that we’ve explored the UI Image <a id="_idIndexMarker640" class="pcalibre pcalibre1 calibre6"/>component, we can look at some UI effect compon<a id="_idTextAnchor303" class="pcalibre pcalibre1 calibre6"/>ents.</p>
<h1 id="_idParaDest-197" class="calibre5"><a id="_idTextAnchor304" class="pcalibre pcalibre1 calibre6"/>UI effect components</h1>
<p class="calibre3">Three effects components allow you to add special <a id="_idIndexMarker641" class="pcalibre pcalibre1 calibre6"/>effects to your Text and Image objects: <strong class="bold">Shadow</strong>, <strong class="bold">Outline</strong>, and <strong class="bold">Position as UV1</strong>. They can all be found under <strong class="bold">Add Component</strong> | <strong class="bold">UI</strong> | <strong class="bold">Effects</strong>. Let’s look at each one individually, starting with the Shadow comp<a id="_idTextAnchor305" class="pcalibre pcalibre1 calibre6"/>onent.</p>
<h2 id="_idParaDest-198" class="calibre7"><a id="_idTextAnchor306" class="pcalibre pcalibre1 calibre6"/>Shadow</h2>
<p class="calibre3">The <strong class="bold">Shadow</strong> component adds a <a id="_idIndexMarker642" class="pcalibre pcalibre1 calibre6"/>simple shadow to your Text or Image object.</p>
<div><div><img alt="Figure 11.7: The Shadow component" src="img/B18327_11_07.jpg" class="calibre357"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.7: The Shadow component</p>
<p class="calibre3">You can change the color and transparency of the shadow with the <code>0</code>, rendering it invisible, the shadow would remain visible based on the alpha specified on the <strong class="bold">Effect </strong><strong class="bold">Color</strong> property.</p>
<p class="calibre3">The following figure shows a few examples of the <strong class="bold">Shadow</strong> component in action:</p>
<div><div><img alt="Figure 11.8: Shadow Component Example in the Chapter11 scene" src="img/B18327_11_08.jpg" class="calibre358"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.8: Shadow Component Example in the Chapter11 scene</p>
<p class="calibre3">All four bananas have the same alpha value set on their <code>0</code>, but since <strong class="bold">Use Graphic Alpha</strong> is not selected on the <strong class="bold">Shadow</strong> component, the shadow did not dim with the banana and remains at its designated alpha <a id="_idTextAnchor307" class="pcalibre pcalibre1 calibre6"/>value.</p>
<h2 id="_idParaDest-199" class="calibre7"><a id="_idTextAnchor308" class="pcalibre pcalibre1 calibre6"/>Outline</h2>
<p class="calibre3">The <strong class="bold">Outline</strong> component simulates an<a id="_idIndexMarker644" class="pcalibre pcalibre1 calibre6"/> outline around the graphic by creating four shadows around it at specified distances.</p>
<div><div><img alt="Figure 11.9: The Outline component" src="img/B18327_11_09.jpg" class="calibre359"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.9: The Outline component</p>
<p class="calibre3">The <strong class="bold">Outline</strong> component will create two shadows to the left and right of the original graphic based on <strong class="bold">Effect Distance X</strong> and two shadows to the top and bottom of the original graphic based on <strong class="bold">Effect Distance Y</strong>. Unlike the <strong class="bold">Shadow</strong> component, there is no difference in a negative or positive value for these two distances because the two shadows created for each axis are mirrored.</p>
<p class="calibre3">Setting the <code>-3</code> essentially just switches the positions of the two horizontal shadows, but the<a id="_idIndexMarker645" class="pcalibre pcalibre1 calibre6"/> effect looks the same, as shown in the following figure:</p>
<div><div><img alt="Figure 11.10: Outline Component Example 1 in the Chapter11 scene" src="img/B18327_11_10.jpg" class="calibre360"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.10: Outline Component Example 1 in the Chapter11 scene</p>
<p class="calibre3">The <strong class="bold">Use Graphic Alpha</strong> property works identically on this component as it does on the <strong class="bold">Shadow</strong> component, as shown:</p>
<div><div><img alt="Figure 11.11: Outline Component Example 2 in the Chapter11 scene" src="img/B18327_11_11.jpg" class="calibre361"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.11: Outline Component Example 2 in the Chapter11 scene</p>
<p class="calibre3">Next, let’s look at the <strong class="bold">Position As </strong><strong class="bold">UV1</strong> compo<a id="_idTextAnchor309" class="pcalibre pcalibre1 calibre6"/>nent.</p>
<h2 id="_idParaDest-200" class="calibre7"><a id="_idTextAnchor310" class="pcalibre pcalibre1 calibre6"/>Position As UV1</h2>
<p class="calibre3">The <strong class="bold">Position As UV1</strong> component<a id="_idIndexMarker646" class="pcalibre pcalibre1 calibre6"/> allows you to change the UV channel that the Canvas renders on. This is used if you want to create custom shaders that utilize baked light maps.</p>
<div><div><img alt="Figure 11.12: The Position As UV1 component" src="img/B18327_11_12.jpg" class="calibre362"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.12: The Position As UV1 component</p>
<p class="calibre3">Sadly, custom shaders are a pretty heavy topic and go past the scope of this text, so I won’t go any further into the usage of this component.</p>
<p class="calibre3">Now that we’ve reviewed the UI Image component and some UI effect components, let’s look at some examples of ways we can use these compon<a id="_idTextAnchor311" class="pcalibre pcalibre1 calibre6"/>ents.</p>
<h1 id="_idParaDest-201" class="calibre5"><a id="_idTextAnchor312" class="pcalibre pcalibre1 calibre6"/>Examples</h1>
<p class="calibre3">In this chapter, we’ll expand on the scene we’ve been building further by adding some new UI elements. We’ll also look at some mobile/touchscreen UI and interactions.</p>
<p class="calibre3">Some of these examples may seem better suited for the chapter on Buttons, but since they include access to the Image component’s properties, I placed them here.</p>
<p class="callout-heading">Note</p>
<p class="callout">We have created two scenes that load into the scene we’ve been building upon: a start screen and an intro scene. Since I’ve been duplicating our main scene to make progress from each chapter easy to track, our intro sScene will not navigate to the updates we make in this and future chapters unless we keep updating the <strong class="bold">Next Scene</strong> variable on our <strong class="bold">Dialogue Boxes</strong> component in the intro sScene and including the new scene in our <strong class="bold">Build Settings</strong>.</p>
<p class="callout">I will not be including this update in the steps since scene navigation is no longer a focus of these examples. However, it will be included in the packages I include in each chapter’s completed sc<a id="_idTextAnchor313" class="pcalibre pcalibre1 calibre6"/>enes.</p>
<h2 id="_idParaDest-202" class="calibre7"><a id="_idTextAnchor314" class="pcalibre pcalibre1 calibre6"/>Horizontal and circular health/progress meters</h2>
<p class="calibre3">Let’s get back to our main scene. Duplicate the <code>Chapter10-Examples</code> scene to create a <code>Chapter11-Examples</code> scene.</p>
<p class="calibre3">In this section, we’ll cover how to create two types of progress meters, a horizontal one and a circular one, as shown in the following screenshot:</p>
<div><div><img alt="Figure 11.13: Example of horizontal and vertical progress bars" src="img/B18327_11_13.jpg" class="calibre363"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.13: Example of horizontal and vertical progress bars</p>
<p class="calibre3">We’ll hook up the circular and horizontal progress meters so that they both display the progress of the same variable, and we can watch them both change at the same time.</p>
<p class="calibre3">The circular progress meter doesn’t really fit in the main scene that we’ve been building, and we’ll hide it after this chapter, but circular progress bars are common game elements, so I thought it was important to include an example of how to do them in this chap<a id="_idTextAnchor315" class="pcalibre pcalibre1 calibre6"/>ter.</p>
<h3 class="calibre9">Horizontal health bar</h3>
<p class="calibre3">There are a few different ways that a <a id="_idIndexMarker647" class="pcalibre pcalibre1 calibre6"/>horizontal health bar can be created, but the quickest and easiest way is to scale a single axis based on percentage. When setting up a horizontal health bar in this way, it is important to ensure that the anchor is set at a position that represents a completely depleted bar.</p>
<p class="calibre3">Remember that back in <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 6</em></a>, we set the anchor of the health bar to the left, so we have already set the anchor correctly. We also scaled the health bar in the <em class="italic">x</em> direction to show what the bar would look like as it depleted.</p>
<div><div><img alt="" role="presentation" src="img/B18327_11_14.jpg" class="calibre364"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.14: The Health Bar’s Rect Transform component</p>
<p class="calibre3">Now, all we need to do is tie the percentage to the <strong class="bold">X Scale</strong> value of the health bar.</p>
<p class="calibre3">To tie the fill of the health <a id="_idIndexMarker648" class="pcalibre pcalibre1 calibre6"/>bar to an actual value, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a new C# script in your <code>Scripts</code> folder and name it <code>ProgressMeters.cs</code>.</li>
<li class="calibre14">In the <code>ProgressMeters</code> script, initialize the following four variables:<pre class="source-code">
public uint health;
[SerializeField] uint totalHealth;
[SerializeField] float percentHealth;
[SerializeField] RectTransform healthBar;</pre><p class="calibre3">The <code>health</code> variable represents the current health of the player, and the <code>totalHealth</code> variable represents the total health the player can obtain. As it doesn’t make sense for these values to be negative, they have been initialized at the <code>uint</code> type or a positive integer. I have made the <code>health</code> variable <code>public</code> so that it can be accessed via other scripts and seen within the Inspector. I made <code>totalHealth</code> a private <code>SerializeField</code> so that it cannot be accessed via other scripts but still be seen and assigned via the Inspector.</p><p class="calibre3">The <code>percentHealth</code> variable will be calculated based on the quotient of the <code>health</code> and <code>totalHealth</code> variables. I made this value private and serialized, not so that we can edit it in the Inspector but so that we can easily see its value change in the Inspector.</p><p class="calibre3">The <code>healthBar</code> variable stores the <code>RectTransform</code> component of the <code>Health Bar</code> UI Image<a id="_idIndexMarker649" class="pcalibre pcalibre1 calibre6"/> within our scene.</p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">Since <strong class="source-inline1">RectTransform</strong> inherits from <strong class="source-inline1">Transform</strong>, we could have declared <strong class="source-inline1">healthBar</strong> as a <strong class="source-inline1">Transform</strong> and the following code would still work.</p>
<ol class="calibre13">
<li value="3" class="calibre14">Return to the Unity Editor and drag the <code>ProgessMeters</code> script onto <code>HUD Canvas</code> &gt; <code>Top Left Panel</code>. Assign the value <code>500</code> to both the <code>Health Bar</code> UI Image into the <strong class="bold">Health Bar</strong> slot. Any value you try to type into the <strong class="bold">Percent Health</strong> slot will be overridden by the code we write in the next step. Your component should look as follows:</li>
</ol>
<div><div><img alt="Figure 11.15: The Progress Meters component" src="img/B18327_11_15.jpg" class="calibre365"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.15: The Progress Meters component</p>
<ol class="calibre13">
<li value="4" class="calibre14">We want any changes made to our <code>health</code> value to automatically update the <code>percentHealth</code> value and the scale of our <code>healthBar</code>. To do that, we can put the following code in the <code>Update()</code> function:<pre class="source-code">
void Update()
{
    // Cap health
    if (health &gt; totalHealth)
    {
        health = totalHealth;
    }
    // Calculate health percentage
    percentHealth = (float)health / totalHealth;
    // Update horizontal health bar
    healthBar.localScale = new Vector2(percentHealth, 1f);
}</pre><p class="calibre3">Declaring our <code>health</code> and <code>totalHealth</code> variables with the <code>uint</code> type stopped them from becoming negative, but we still need to put an upper cap on our <code>health</code> variable. It doesn’t make sense for it to exceed the <code>totalHealth</code> variable.</p><p class="calibre3">While <code>percentHealth</code> is a <code>float</code> variable, performing a division between two <code>uint</code> variables will result in a <code>uint</code> type, so adding <code>(float)</code> at the beginning of the integer division provides a <code>float</code> result from the division.</p><p class="calibre3">The last part of the code sets the <code>localScale</code> value of the <code>healthBar</code>. When you scale a UI object, you have to use <code>localScale</code>. This scales the object locally, meaning relative to<a id="_idIndexMarker650" class="pcalibre pcalibre1 calibre6"/> its parent object.</p></li> <li class="calibre14">Now, we can test the code easily in the Editor. Play the game and hover your mouse over the word <strong class="bold">Health</strong> in the <strong class="bold">Progress Meters</strong> component until the mouse displays two arrows around it, as shown in the following figure:</li>
</ol>
<div><div><img alt="Figure 11.16: The Progress Meters component’s effect on the meter" src="img/B18327_11_16.jpg" class="calibre366"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.16: The Progress Meters component’s effect on the meter</p>
<p class="calibre3">When these arrows appear, clicking and dragging will manipulate the values of the variable based on your mouse position. You’ll see, as you do this, that as the <code>Health Bar</code> in the scene changes size. You’ll note that you cannot set the value of <code>0</code> or above <code>500</code>.</p>
<p class="calibre3">As you can see, setting up a horizontal health bar isn’t terribly difficult. Duplicating this process in a game where the health reduces by Events won’t require a lot of steps to achieve. Just ensure that you set the anchor of the health bar correctly. This process will work similarly for a vertical<a id="_idIndexMarker651" class="pcalibre pcalibre1 calibre6"/> healt<a id="_idTextAnchor316" class="pcalibre pcalibre1 calibre6"/>h bar.</p>
<h3 class="calibre9">Circular progress meter</h3>
<p class="calibre3">Horizontal health bars didn’t take a lot of work to set up. The work to make a circular progress meter is just about as easy and can be completed with only two more lines of code. Since we don’t already have a circular progress bar in our scene, we will have to start with a bit of setup first.</p>
<p class="calibre3">To create a circular progress bar, complete the <a id="_idIndexMarker652" class="pcalibre pcalibre1 calibre6"/>following steps:</p>
<ol class="calibre13">
<li class="calibre14">From the code bundle, drag the <code>circularMeter.png</code> sprite into the <code>Sprites</code> folder of your project.</li>
<li class="calibre14">Set the <code>circularMeter.png</code> sprite to <strong class="bold">Multiple</strong> and automatically slice it in the <strong class="bold">Sprite Editor</strong>.</li>
<li class="calibre14">Select the <code>Top Left Panel</code> within the Hierarchy and give it a new UI Image child. Name the Image <code>Progress Holder</code>.</li>
<li class="calibre14">Similar to how we set up the health bar, there will be a holder and a fill. Drag the <code>circularMeter_0</code> sub-sprite into the <code>Progress Holder</code>.</li>
<li class="calibre14">It’s important that we get the right proportions for our holder and fill Images. So, to ensure that the Image is correctly proportioned, hit the <strong class="bold">Set Native Size</strong> button on the <strong class="bold">Image</strong> component.</li>
<li class="calibre14">Now, add a child UI Image to <code>Progress Holder</code> called <code>Progress Meter</code>.</li>
<li class="calibre14">Set the anchor preset of <code>Progress Meter</code> to middle center. Do not stretch it.</li>
<li class="calibre14">Add <code>circularMeter_1</code> to the <code>Progress Meter</code>.</li>
<li class="calibre14">Hit the <code>Progress Meter</code> <strong class="bold">Image</strong> component as well. After completing this step, you should see the following:
<div><div><img alt="Figure 11.17: The progress on the Progress Meter" src="img/B18327_11_17.jpg" class="calibre367"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.17: The progress on the Progress Meter</p>
<p class="calibre3">If the pink fill is not perfectly <a id="_idIndexMarker653" class="pcalibre pcalibre1 calibre6"/>nestled inside the blue holder, you may have forgotten to hit the <code>Progress Meter</code> does not have its anchor preset set to middle center.</p></li>
</ol>
<ol class="calibre13">
<li value="10" class="calibre14">Let’s move this meter and scale it a bit. Select <code>Progress Holder</code> and move it so that it is positioned in the scene below <code>Character Holder</code>. Set the <code>Progress Holder</code> to <code>0.8</code> to make it a little smaller.</li>
</ol>
<div><div><img alt="Figure 11.18: Repositioning the circular progress meter" src="img/B18327_11_18.jpg" class="calibre368"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.18: Repositioning the circular progress meter</p>
<ol class="calibre13">
<li value="11" class="calibre14">The last thing to do to the code is to change the <code>Progress Meter</code>. Change <a id="_idIndexMarker654" class="pcalibre pcalibre1 calibre6"/>the <strong class="bold">Image Type</strong> to <strong class="bold">Filled</strong> with a <strong class="bold">Radial 360 Fill Method</strong>. Change the <strong class="bold">Fill Origin</strong> to <strong class="bold">Top</strong>. Adjust the scroll bar on the <strong class="bold">Fill Amount</strong> to preview the meter filling:</li>
</ol>
<div><div><img alt="Figure 11.19: Adjusting the fill amount on the circular progress meter" src="img/B18327_11_19.jpg" class="calibre369"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.19: Adjusting the fill amount on the circular progress meter</p>
<ol class="calibre13">
<li value="12" class="calibre14">Now, we’re ready to write some code. As you have probably guessed from adjusting the <code>fillAmount</code> value to the <code>percentHealth</code> variable in our code. First, we need to create a variable with which we can access the Image component of our <code>Progress Meter</code>. Declare the following variable at the top of your code:<pre class="source-code">
[SerializeField] Image progressMeter;</pre></li> <li class="calibre14">Now, add the following at the end of the <code>Update()</code> function:<pre class="source-code">
// Circular progress meter
progressMeter.fillAmount = percentHealth;</pre></li> <li class="calibre14">The last thing we need <a id="_idIndexMarker655" class="pcalibre pcalibre1 calibre6"/>to do is hook the <code>Progress Meter</code> UI Image to the <code>progressMeter</code> variable. Drag the <code>Progress Meter</code> into the <strong class="bold">Progress </strong><strong class="bold">Meter</strong> slot.</li>
</ol>
<div><div><img alt="Figure 11.20: The Progress Meter component’s updates" src="img/B18327_11_20.jpg" class="calibre370"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.20: The Progress Meter component’s updates</p>
<ol class="calibre13">
<li value="15" class="calibre14">Play the game and adjust the <strong class="bold">Health</strong> value in the Inspector as you did earlier, and watch the two meters move in unison.</li>
</ol>
<div><div><img alt="Figure 11.21: Result of the Progress Meter" src="img/B18327_11_21.jpg" class="calibre371"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.21: Result of the Progress Meter</p>
<p class="calibre3">As you can see, making a circular progress meter is really not more difficult than making a horizontal one!</p>
<p class="callout-heading">Note</p>
<p class="callout">In the same way we used the fill amount for the circular progress bar, we could have used the fill amount for the horizontal health bar. Setting the <strong class="bold">Image Type</strong> property to <strong class="bold">Filled</strong> and <strong class="bold">Horizontal</strong> and then affecting the <strong class="bold">Fill Amount</strong> value rather than the scale would have had a similar effect.</p>
<p class="calibre3">Because this circular progress meter <a id="_idIndexMarker656" class="pcalibre pcalibre1 calibre6"/>wasn’t part of the original UI plan and was only placed in the scene for demonstration purposes, I am going to disable it in all future figures and screen<a id="_idTextAnchor317" class="pcalibre pcalibre1 calibre6"/><a id="_idTextAnchor318" class="pcalibre pcalibre1 calibre6"/>shots.</p>
<h2 id="_idParaDest-203" class="calibre7"><a id="_idTextAnchor319" class="pcalibre pcalibre1 calibre6"/>Mute Buttons with sprite swap</h2>
<p class="calibre3">Now, let’s look at an example where we swap the <a id="_idIndexMarker657" class="pcalibre pcalibre1 calibre6"/>sprite of a Button based on a pre-defined state. This is different than a sprite swap transition, which we discussed in <a href="B18327_09.xhtml#_idTextAnchor213" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 9</em></a>, because it won’t use the states of highlighted, pressed, selected, or disabled. It’s included in this chapter rather than the Buttons chapter since it involves affecting the Image component, not the Button component.</p>
<p class="calibre3">In the scene, we have a <code>Pause Panel</code> that pops up when the <em class="italic">P</em> key is hit on the keyboard. On this Panel, we will place two mute Buttons, one for music and one for sound, which will toggle between muted and unmuted states. The Panel will appear as shown in the following screenshot:</p>
<div><div><img alt="Figure 11.22: The Pause Panel with new mute Buttons" src="img/B18327_11_22.jpg" class="calibre372"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.22: The Pause Panel with new mute Buttons</p>
<p class="calibre3">To add the music and sound Buttons<a id="_idIndexMarker658" class="pcalibre pcalibre1 calibre6"/> shown in the preceding screenshot, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">First, we need to bring in a new art asset. The Button sprites on the sprite sheet we imported previously are a bit too small and don’t contain a muted version. So, I edited them a bit and provided a new sprite for you. In the book’s source files, you should find an <code>.png</code> file named <code>muteUnmute.png</code>:
<div><div><img alt="Figure 11.23: The muteUnmute.png sprite" src="img/B18327_11_23.jpg" class="calibre373"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.23: The muteUnmute.png sprite</p>
<p class="calibre3">Import this <code>.png</code> file into your project’s <code>Assets/Sprites</code> folder.</p></li>
</ol>
<ol class="calibre13">
<li value="2" class="calibre14">Slice the sprite into mu<a id="_idTextAnchor320" class="pcalibre pcalibre1 calibre6"/>ltiple sub-sprites by changing its <strong class="bold">Sprite Mode</strong> to <strong class="bold">Multiple</strong>, opening its <strong class="bold">Sprite Editor</strong>, and applying the automatic slice type. Multiple sprites should<a id="_idIndexMarker659" class="pcalibre pcalibre1 calibre6"/> appear as follows:</li>
</ol>
<div><div><img alt="Figure 11.24: The muteUnmute.png sprite sliced" src="img/B18327_11_24.jpg" class="calibre374"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.24: The muteUnmute.png sprite sliced</p>
<ol class="calibre13">
<li value="3" class="calibre14">Create two new Buttons as children of the <code>Pause Panel</code> and name them <code>Music Button</code> and <code>Sound Button</code>. Delete their text children because we do not need them.</li>
</ol>
<div><div><img alt="Figure 11.25: The current view of the Hierarchy" src="img/B18327_11_25.jpg" class="calibre375"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.25: The current view of the Hierarchy</p>
<ol class="calibre13">
<li value="4" class="calibre14">Give the two new Buttons<a id="_idIndexMarker660" class="pcalibre pcalibre1 calibre6"/> the following <strong class="bold">Rect Transform</strong> and <strong class="bold">Image</strong> properties:
<div><div><img alt="Figure 11.26: The Rect Transform of the two Buttons" src="img/B18327_11_26.jpg" class="calibre376"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.26: The Rect Transform of the two Buttons</p>
<p class="calibre3">Your Panel should now look just like the one at the beginning of this example:</p>
<div><div><img alt="Figure 11.27: The Pause Panel" src="img/B18327_11_27.jpg" class="calibre377"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.27: The Pause Panel</p></li>
</ol>
<ol class="calibre13">
<li value="5" class="calibre14">Now, let’s write some code to make these Buttons swap sprites that will represent the sound and <a id="_idIndexMarker661" class="pcalibre pcalibre1 calibre6"/>music toggling on and off. Create a new script called <code>MuteUnmute.cs</code> in your <code>Assets/Scripts</code> folder.<p class="calibre3">Replace the code of <code>MuteUnmute</code> with the following:</p><pre class="source-code">
public class MuteUnmute : MonoBehaviour
{
    [SerializeField] Button musicButton;
    private Image musicImage;
    [SerializeField] private Sprite[] musicSprites = new Sprite[2];
    private bool musicOn = true;
    [SerializeField] Button soundButton;
    private Image soundImage;
    [SerializeField] private Sprite[] soundSprites = new Sprite[2];
    private bool soundOn = true;
    void Awake()
    {
        musicImage = musicButton.GetComponent&lt;Image&gt;();
        soundImage = soundButton.GetComponent&lt;Image&gt;();
    }
    public void ToggleMusic()
    {
        musicOn = !musicOn;
        musicImage.sprite = musicSprites[Convert.ToInt32(musicOn)];
    }
    public void ToggleSound()
    {
        soundOn = !soundOn;
        soundImage.sprite = soundSprites[Convert.ToInt32(soundOn)];
    }
}</pre></li> </ol>
<p class="calibre3">As you can see, this code contains two main functions: <code>ToggleMusic()</code> and <code>ToggleSound()</code>. These two function identically by simply swapping the sprite on the specified Button based on the <code>musicOn</code> and <code>soundOn</code> Boolean values.</p>
<p class="calibre3">To swap the sprite, the script first finds the Image component on the two Buttons specified as <code>musicButton</code> and <code>soundButton</code>, within the <code>Awake()</code> function. These Buttons will be assigned in the Inspector. It then swaps the sprite of the Image component to the correct sprite<a id="_idIndexMarker662" class="pcalibre pcalibre1 calibre6"/> from an array of sprites. The sprites for the mute and unmute states will be assigned in the Inspector in a future step.</p>
<p class="callout-heading">Note</p>
<p class="callout">Sadly, this book does not cover adding sound and music to a Unity project. The code provided here doesn’t actually mute and unmute audio; it simply swaps sprites. You will simply need to include two audio sources: one for playing music and one for playing sounds that have the <strong class="bold">Music</strong> and <strong class="bold">Sound</strong> tags, respectively.</p>
<ol class="calibre13">
<li class="calibre14">Go back to the Unity Editor and attach the <code>MuteUnmute.cs</code> script to the <code>Pause Panel</code> by dragging it into its <strong class="bold">Inspector</strong>:</li>
</ol>
<div><div><img alt="Figure 11.28: The Mute Unmute component" src="img/B18327_11_28.jpg" class="calibre378"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.28: The Mute Unmute component</p>
<ol class="calibre13">
<li value="2" class="calibre14">Now, we want to assign the appropriate Buttons and sprites to the slots. Drag the <code>Music Button</code> and <code>Sound Button</code> into their designated slots from the Hierarchy. Drag and drop<a id="_idIndexMarker663" class="pcalibre pcalibre1 calibre6"/> the audio Button sprites from the project view to their appropriate slots, making sure to put the muted sprite in the 0 element of the array.</li>
</ol>
<div><div><img alt="Figure 11.29: The updated Mute Unmute component" src="img/B18327_11_29.jpg" class="calibre379"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.29: The updated Mute Unmute component</p>
<ol class="calibre13">
<li value="3" class="calibre14">Now, we just need to hook up the Buttons to call the appropriate functions. Select the <code>Music Button</code>. Select the <code>OnClick()</code> Event list of the <code>MuteUnmute.cs</code>, is on the <code>Pause Panel</code>, so drag the <code>Pause Panel</code> into the object slot. Now, from the function dropdown menu, select <strong class="bold">MuteUnmute</strong> | <strong class="bold">ToggleMusic</strong>.</li>
<li class="calibre14">Perform the same actions <a id="_idIndexMarker664" class="pcalibre pcalibre1 calibre6"/>as you did in the previous step for the <code>Sound Button</code>, but this time select <strong class="bold">MuteUnmute</strong> | <strong class="bold">ToggleSound</strong> from the function dropdown list.</li>
</ol>
<p class="calibre3">Now, play the game, press <em class="italic">P</em> to bring up the <code>Pause Panel</code>, and you will see the Buttons toggle back and forth between their two different s<a id="_idTextAnchor321" class="pcalibre pcalibre1 calibre6"/>prites.</p>
<p class="calibre3">Now that we’ve looked at how to implement progress meters and sprite swap Buttons, let’s look at how to implement a few different mobile-specific interactions.</p>
<h2 id="_idParaDest-204" class="calibre7"><a id="_idTextAnchor322" class="pcalibre pcalibre1 calibre6"/>Adding press-and-hold/long-press functionality</h2>
<p class="calibre3">Press-and-hold is utilized frequently in mobile games. Many games that use right-click on a PC or the web use press-and-hold when they are converted to the mobile platform.</p>
<p class="calibre3">To demonstrate how to<a id="_idIndexMarker665" class="pcalibre pcalibre1 calibre6"/> implement press-and-hold functionality, we will create a Button that has a growing ring that represents hold time. Once a specified amount of time has passed, a function will fire:</p>
<div><div><img alt="Figure 11.30: Press-and-hold Button example" src="img/B18327_11_30.jpg" class="calibre380"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.30: Press-and-hold Button example</p>
<p class="calibre3">When working on this example, it is important to remember that even though the code is referencing a pointer, this functionality does not work exclusively with a mouse. Placing a finger on a touchscreen functions in the same way as a pointer down, and picking up the finger works the same as a pointer up.</p>
<p class="calibre3">To create a Button with a growing ring that represents hold time, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a new scene named <code>Chapter11-Examples-Buttons1</code> in the <code>Assets/Scenes</code> folder and open the new scene.</li>
<li class="calibre14">Select <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Button</strong> to create a new Button in the scene.</li>
<li class="calibre14">Set the Button’s <strong class="bold">Transition</strong> type on the <strong class="bold">Button</strong> component to <strong class="bold">None</strong>.</li>
<li class="calibre14">Change the text on the Button to say <code>Press </code><code>and Hold</code>.</li>
<li class="calibre14">Right-click the <code>Button</code> in the Hierarchy and select <code>Image</code> child to the <code>Button</code>.</li>
<li class="calibre14">Change the <code>Image</code>’s <code>50</code>.</li>
<li class="calibre14">Assign the <code>circularMeter_1</code> sprite to the <strong class="bold">Source Image</strong> property of the <strong class="bold">Image</strong> component.</li>
<li class="calibre14">Change the <code>0</code>.</li>
<li class="calibre14">To create press-and-hold functionality on the <code>Button</code>, we will utilize the <code>Button</code> object.</li>
<li class="calibre14">Select <strong class="bold">Add New Event Type</strong> and select <strong class="bold">PointerDown</strong>.</li>
<li class="calibre14">Select <strong class="bold">Add New Event Type</strong> and select <strong class="bold">PointerUp</strong>.</li>
<li class="calibre14">Now, we need to actually write the functions that will be called by the Event Triggers we set up in the previous <a id="_idIndexMarker666" class="pcalibre pcalibre1 calibre6"/>steps. Create a new script in the <code>Assets/Scripts</code> folder called <code>LongPressButton</code>.</li>
<li class="calibre14">Before opening the script, go ahead and attach it as a component to <code>Button</code>.</li>
<li class="calibre14">Add the <code>UnityEngine.UI</code> namespace to the top of the script with the following:<pre class="source-code">
using UnityEngine.UI;</pre></li> <li class="calibre14">To check how long the Button is being pressed, we will use a Boolean variable that checks to see if the Button is being held and a few different variables related to time. Add the following variable declaration to your script:<pre class="source-code">
private bool buttonPressed = false;
private float startTime = 0f;
private float holdTime = 0f;
[SerializeField] private float longHoldTime = 1f;</pre><p class="calibre3">The <code>buttonPressed</code> variable will be set to <code>true</code> with the <code>startTime</code> variable will be set to the current time when the <code>holdTime</code> variable will determine how much time has passed since <code>startTime</code>. The <code>longHoldTime</code> variable is the amount of time the Button must be held down before the long press is complete. It is serialized so that it can be easily customized.</p></li> <li class="calibre14">The last variable we need will represent the radial filling Image. Add the following variable <a id="_idIndexMarker667" class="pcalibre pcalibre1 calibre6"/>declaration to your code:<pre class="source-code">
[SerializeField] private Image radialFillImage;</pre></li> <li class="calibre14">Now, we need to write a function that will be called by both the <strong class="bold">Pointer Down</strong> and <strong class="bold">Pointer </strong><strong class="bold">Up</strong> Events:<pre class="source-code">
public void PressAndRelease(bool pressStatus)
{
    buttonPressed = pressStatus;
    if (!buttonPressed)
    {
        holdTime = 0;
        radialFillImage.fillAmount = 0;
    }
    else
    {
        startTime = Time.time;
    }
}</pre><p class="calibre3">This function accepts a Boolean variable from the Event Trigger. It then sets the value of <code>buttonPressed</code> to the passed value.</p><p class="calibre3">When the Button is released, a value of <code>false</code> will be passed to the function. If the value passed is <code>false</code>, the amount of time that has passed, <code>holdTime</code>, is reset to <code>0</code>, and the <code>radialFillImage</code> Image is reset to have a <code>fillAmount</code> value of <code>0</code>.</p><p class="calibre3">When the Button is pressed, the <code>startTime</code> value will be set to the current time.</p></li> <li class="calibre14">Create a function that will be called once the full amount of time needed for the long press, specified by <code>longHoldTime</code>, has completed:<pre class="source-code">
public void LongPressCompleted()
{
    radialFillImage.fillAmount = 0;
    Debug.Log("Do something after long press");
}</pre><p class="calibre3">This function doesn’t really do anything but reset the filling Image and print out a <code>Debug.Log</code>. However, you can later reuse this code and replace the <code>Debug.Log</code> line with more interesting and meaningful actions.</p></li> <li class="calibre14">The <code>Update()</code> function can be used to make the timer count upward. Adjust the <code>Update()</code> function <a id="_idIndexMarker668" class="pcalibre pcalibre1 calibre6"/>as follows:<pre class="source-code">
void Update()
{
    if (buttonPressed)
    {
        holdTime = Time.time - startTime;
        if (holdTime &gt;= longHoldTime)
        {
            buttonPressed = false;
            LongPressCompleted();
        }
        else
        {
            radialFillImage.fillAmount = holdTime / longHoldTime;
        }
    }
}</pre><p class="calibre3">This code makes the value of <code>holdTime</code> tick upward if the <code>buttonPressed</code> value is set to <code>true</code>. Remember—<code>buttonPressed</code> will be set to <code>true</code> with a <code>false</code> with a <code>holdTime</code> value reaches the value specified by <code>longHoldTime</code>, the timer will stop ticking up, because <code>buttonPressed</code> will be reset to <code>false</code>. Additionally, the <code>LongPressCompleted()</code> function is called. If <code>longHoldTime</code> has not yet been reached, the Image’s radial fill will update to represent the percentage of total required time that has transpired.</p></li> <li class="calibre14">Now that the script is completed, we can hook up the <code>PressAndRelease()</code> function with the Event Triggers on the Button. Add the <code>PressAndRelease</code> function from the static list to both the <code>PressAndRelease()</code> function accepts a Boolean variable, there is a checkbox representing the Boolean value that should be passed. Select the checkbox for the <code>true</code>) but not for the <code>false</code>).</li>
</ol>
<div><div><img alt="Figure 11.31: The Event Trigger component" src="img/B18327_11_31.jpg" class="calibre381"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.31: The Event Trigger component</p>
<ol class="calibre13">
<li value="21" class="calibre14">Now, we need to assign the <code>Image</code> to the <strong class="bold">Radial Fill Image</strong> slot on the <strong class="bold">Long </strong><strong class="bold">Press</strong> component.</li>
</ol>
<div><div><img alt="Figure 11.32: The Long Press component" src="img/B18327_11_32.jpg" class="calibre382"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.32: The Long Press component</p>
<p class="calibre3">Playing the game now will <a id="_idIndexMarker669" class="pcalibre pcalibre1 calibre6"/>demonstrate the Image radially filling when you hold the Button and printing <code>Do something after long press</code> in the console. If you release the Button before the fill has completed, it will go away and reset for when you start clicking again.</p>
<p class="calibre3">Press-and-hold is a pretty common functionality, and while it isn’t a pre-installed Event in the Unity Event library, luckily it isn’t too difficult to hook up. I recommend holding on to that script so that you can reuse it in the<a id="_idTextAnchor323" class="pcalibre pcalibre1 calibre6"/> future.</p>
<p class="calibre3">Creating a static four-directional virtual D-Pad</p>
<p class="calibre3">A D-Pad is simply four Buttons on a directional pad. To create a D-Pad for a mobile game, you just need to create a<a id="_idIndexMarker670" class="pcalibre pcalibre1 calibre6"/> graphic that contains four Buttons on the directions.</p>
<p class="calibre3">The art used in this example was obtained from <a href="https://opengameart.org/content/onscreen-controls-8-styles" class="pcalibre pcalibre1 calibre6">https://opengameart.org/content/onscreen-controls-8-styles</a>.</p>
<p class="calibre3">To create a virtual D-Pad, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a new scene named <code>Chapter11-Examples-Buttons2</code> in the <code>Assets/Scenes</code> folder and open the new scene.</li>
<li class="calibre14">Import the <code>dPadButtons.png</code> sprite sheet into the <code>Assets/Sprites</code> folder.</li>
<li class="calibre14">Change the newly imported sprite’s <strong class="bold">Sprite Mode</strong> to <strong class="bold">Multiple</strong> and automatically slice it.</li>
<li class="calibre14">Create a new Canvas with <code>D-Pad Canvas</code>.</li>
<li class="calibre14">The size of a D-Pad is incredibly important on mobile devices. Even if the screen gets smaller, you’ll probably want the D-Pad to be about the same size. If it gets too small, the game can be unplayable or uncomfortable. Therefore, set the <strong class="bold">Canvas Scaler</strong> component’s <strong class="bold">UI Scale Mode</strong> value to <strong class="bold">Constant </strong><strong class="bold">Physical Size</strong>.</li>
<li class="calibre14">Add a new Image as a child of <code>D-Pad Canvas</code> with <code>D-Pad Background</code>.</li>
<li class="calibre14">Set the <code>dPadButtons_4</code>.</li>
<li class="calibre14">Set its anchor and pivot to the lower-left corner of the screen, and set its <code>30</code>.</li>
<li class="calibre14">Set its <code>200</code>:</li>
</ol>
<div><div><img alt="Figure 11.33: The D-Pad positioned correctly" src="img/B18327_11_33.jpg" class="calibre383"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.33: The D-Pad positioned correctly</p>
<ol class="calibre13">
<li value="10" class="calibre14">Right-click on <code>D-Pad Background</code> and add a new Button as a child with <code>Up</code>.</li>
<li class="calibre14">Remove its child <code>Text</code> object.</li>
<li class="calibre14">Set the <code>Up</code> Button to <code>0</code>, <code>65</code>, <code>60</code>, and <code>60</code>, respectively. This will <a id="_idIndexMarker671" class="pcalibre pcalibre1 calibre6"/>create a square over just the up position of the D-Pad Image.</li>
</ol>
<div><div><img alt="Figure 11.34: The D-Pad with an Up Button" src="img/B18327_11_34.jpg" class="calibre384"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.34: The D-Pad with an Up Button</p>
<ol class="calibre13">
<li value="13" class="calibre14">Duplicate the <code>Up</code> Button three times and rename the duplicates <code>Right</code>, <code>Left</code>, and <code>Down</code>.</li>
<li class="calibre14">Set the <code>Right</code> Button’s <code>65</code> and <code>0</code>, respectively.</li>
<li class="calibre14">Set the <code>Left</code> Button’s <code>-65</code> and <code>0</code>, respectively.</li>
<li class="calibre14">Set the <code>Down</code> Button’s <code>0</code> and <code>-65</code>, respectively. You should now have <a id="_idIndexMarker672" class="pcalibre pcalibre1 calibre6"/>four Buttons positioned as follows:
<div><div><img alt="Figure 11.35: The D-Pad with all of its Buttons" src="img/B18327_11_35.jpg" class="calibre385"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.35: The D-Pad with all of its Buttons</p>
<p class="calibre3">These four Buttons cover the entire area of the arms of the directional pad. They will act as the hit area for the directions.</p></li>
</ol>
<ol class="calibre13">
<li value="17" class="calibre14">We only really want these four Buttons for their hit area and don’t want to actually have them visible in the UI. Select all four of the Buttons in the Hierarchy and set the alpha value on the <code>0</code>.</li>
<li class="calibre14">Since the directional pad Image is static and not split into four separate Buttons, any transitions applied to it would cover the whole Image. However, we can make the individual directions look as if they are being pressed and have some sort of color transition by adding sub-Images for the arrows on the directions. Right-click the <code>Up</code> Button and add an Image as a child with <code>Arrow</code>.</li>
<li class="calibre14">Assign the <code>dPadButtons_5</code> sprite to the <strong class="bold">Source Image</strong> on its <strong class="bold">Image</strong> component and select <strong class="bold">Preserve Aspect</strong>.</li>
<li class="calibre14">Scale and move the Image so that it is appropriately lined up with the arrow displayed on the D-Pad background Image:</li>
</ol>
<div><div><img alt="Figure 11.36: The Up Arrow of the D-Pad" src="img/B18327_11_36.jpg" class="calibre386"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.36: The Up Arrow of the D-Pad</p>
<ol class="calibre13">
<li value="21" class="calibre14">Select the <code>Arrow</code> Image component and use the eye dropper tool to grab the color of the arrows from the <code>D-Pad Background</code> Image. This will make it a light gray instead of white.</li>
<li class="calibre14">Create <code>Arrow</code> children<a id="_idIndexMarker673" class="pcalibre pcalibre1 calibre6"/> for each of the other three Buttons, and size, position, and color them appropriately. Make sure to also use the correct sub-Image of the <code>dPadButtons</code> sprite sheet. Once completed, your D-Pad and Hierarchy should appear as follows:</li>
</ol>
<div><div><img alt="Figure 11.37: All Arrows on the D-Pad" src="img/B18327_11_37.jpg" class="calibre387"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.37: All Arrows on the D-Pad</p>
<ol class="calibre13">
<li value="23" class="calibre14">Now, so that the D-Pad will react visually when the four directions are pressed, we will set the four <code>Arrow</code> children to have color tint Button <code>Arrow</code> child into the <strong class="bold">Target Graphic</strong> slot on its <strong class="bold">Button</strong> component. Now, when you press the individual Buttons, you will see a slight change in the color of the arrows, indicating which direction is<a id="_idIndexMarker674" class="pcalibre pcalibre1 calibre6"/> pressed. You may wish to change the pressed color to something a bit more drastic than the default gray if you are having difficulty telling that a change is occurring.</li>
<li class="calibre14">Add the script named <code>DPad.cs</code> from the book’s code bundle to the <code>Assets/Scripts</code> folder. This is an incredibly simple script that contains four functions that only write to the console. Hooking up these four functions to the individual directional Buttons won’t do anything fun, but it will allow us to see logs in the console that let us know the Buttons are performing as they should.</li>
<li class="calibre14">Attach the script to the <code>D-Pad </code><code>Background</code> object.</li>
<li class="calibre14">Select each of the four directional Buttons and, with all of them selected, add an <strong class="bold">On Click ()</strong> Event to the <strong class="bold">Button</strong> component.</li>
<li class="calibre14">Now, drag the <code>D-Pad Background</code> object into the object slot of the <strong class="bold">On Click ()</strong> Event.</li>
<li class="calibre14">Select each Button individually and assign the appropriate functions, <code>PressUp</code>, <code>PressDown</code>, <code>PressLeft</code>, and <code>PressRight</code>, to their <strong class="bold">On Click ()</strong> Events.</li>
</ol>
<p class="calibre3">Playing the game and selecting the four directional Buttons should result in the appropriate message being displayed <a id="_idIndexMarker675" class="pcalibre pcalibre1 calibre6"/>on the console.</p>
<p class="calibre3">Many D-Pads actually accept nine inputs: the four directs, the four diagonals (corners), and the center. If you want to accept diagonal inputs as well as a center-click for your D-Pad, I’d suggest using a grid layout group to evenly space your nine Buttons.</p>
<p class="calibre3">Since D-Pads tend to allow press-and-hold, you may want to combine the process used in this example with actions similar to those described in the previous example. Instead of using the <code>OnPointerDown</code> and <code>OnPointerUp</code> Events. These Events could then set a Boolean variable to <code>true</code> and <code>false</code>. For example, on the <code>Right</code> Button, you could have the <code>OnPointerDown</code> Event set a variable called <code>moveRight</code> to <code>true</code> and the <code>OnPointerUp</code> Event set <code>moveRight</code> to <code>false</code>.</p>
<h2 id="_idParaDest-205" class="calibre7"><a id="_idTextAnchor324" class="pcalibre pcalibre1 calibre6"/>Creating a floating eight-directional virtual analog stick</h2>
<p class="calibre3">In this example, we will create a floating eight-directional <a id="_idIndexMarker676" class="pcalibre pcalibre1 calibre6"/>virtual analog stick. First, we will create an eight-directional D-Pad that simulates a control stick that moves in the direction the player drags:</p>
<div><div><img alt="Figure 11.38: The positions of the floating analog stick" src="img/B18327_11_38.jpg" class="calibre388"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.38: The positions of the floating analog stick</p>
<p class="calibre3">Then, we will expand the eight-directional D-Pad so that it is floating, which means it will not be visible in the scene until the player presses somewhere in the screen. Then, it will appear where the player’s<a id="_idIndexMarker677" class="pcalibre pcalibre1 calibre6"/> thumb is located and perform the eight-direction movement based on the player’s thumb<a id="_idTextAnchor325" class="pcalibre pcalibre1 calibre6"/> dragging.</p>
<p class="calibre3">Setting up the eight-directional virtual analog stick</p>
<p class="calibre3">To create an analog stick that moves in eight<a id="_idIndexMarker678" class="pcalibre pcalibre1 calibre6"/> directions, as shown in the previous figure, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a new scene named <code>Chapter11-Examples-Buttons3</code> in the <code>Assets/Scenes</code> folder and open the new scene.</li>
<li class="calibre14">Create a new Image with <code>Stick Base</code>.</li>
<li class="calibre14">Add the <code>dPadButtons_15</code> sprite to the <strong class="bold">Source Image</strong> slot of its <strong class="bold">Image</strong> component.</li>
<li class="calibre14">Resize it so that it has a <code>200</code> and give it a <code>0</code>.</li>
<li class="calibre14">Right-click <code>Stick Base</code> in the Hierarchy and select <code>Image</code> child to the <code>Stick Base</code>. Name the child <code>Stick</code>.</li>
<li class="calibre14">Resize the <code>Stick</code> Image to match the <code>Stick Base</code> by setting its <strong class="bold">Rect Transform</strong> stretch and anchor to stretch fully across both directions.</li>
<li class="calibre14">Add the <code>dPadButtons_0</code> sprite to the <code>Stick</code> Image component.</li>
<li class="calibre14">Set the <code>10</code> to give some padding around the edges of the <code>Stick</code>.</li>
<li class="calibre14">Now, set the pivot and <a id="_idIndexMarker679" class="pcalibre pcalibre1 calibre6"/>position to <code>Stick</code> will not move around appropriately on the <code>Stick Base</code>.</li>
</ol>
<div><div><img alt="Figure 11.39: The Rect Transform component of the Stick" src="img/B18327_11_39.jpg" class="calibre389"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.39: The Rect Transform component of the Stick</p>
<ol class="calibre13">
<li value="10" class="calibre14">That’s all there is for the setup to get our virtual analog stick working. We’ll just leave it in the center of the screen for now. Now, we need to write some code. Create a new script in the <code>Assets/Script</code> folder and name it <code>FloatingAnalogStick</code>.</li>
<li class="calibre14">Add the <code>UnityEngine.UI</code> namespace to the top of the script with the following:<pre class="source-code">
using UnityEngine.UI;</pre></li> <li class="calibre14">To make the stick wiggle<a id="_idIndexMarker680" class="pcalibre pcalibre1 calibre6"/> around on top of the base, we need the following variables:<pre class="source-code">
[SerializeField] private RectTransform theStick;
private Vector2 mouseStartPosition;
private Vector2 mouseCurrentPosition;
[SerializeField] private int dragPadding = 30;</pre><p class="calibre3">The first three variables should be pretty self-explanatory. The <code>dragPadding</code> variable will be used to determine how far the player has to drag the stick before it actually registers as being moved.</p></li> <li class="calibre14">Before we write the code that checks how far the player has dragged their finger, let’s add a few dummy functions that would allow this analog stick to actually control something in the future. Add the following functions to your script:<pre class="source-code">
public void MovingLeft()
{
    Debug.Log("move left");
}
public void MovingRight()
{
    Debug.Log("move right");
}
public void MovingUp()
{
    Debug.Log("move up");
}
public void MovingDown()
{
    Debug.Log("move down");
}</pre></li> <li class="calibre14">The <code>Stick</code> will move outward when the player moves their finger from their starting finger-down position. So, let’s create a function that will find the starting position when the player begins dragging their finger. Add the following function to your script:<pre class="source-code">
public void StartDrag()
{
    mouseStartPosition = Input.mousePosition;
}</pre><p class="calibre3">Remember—when working with a touchscreen, <code>Input.mousePosition </code>will give the value of the touch position.</p></li> <li class="calibre14">Now, let’s create a function that checks how far the player has dragged their finger and moves the <code>Stick</code> based on that information. Add the following function to your script:<pre class="source-code">
public void Dragging()
{
    float xPos;
    float yPos;
    mouseCurrentPosition = Input.mousePosition;
    if (mouseCurrentPosition.x &lt; mouseStartPosition.x - dragPadding)
    {
        MovingLeft();
        xPos = -10;
    }
    else if (mouseCurrentPosition.x &gt; mouseStartPosition.x + dragPadding)
    {
        MovingRight();
        xPos = 10;
    }
    else
    {
        xPos = 0;
    }
    if (mouseCurrentPosition.y &gt; mouseStartPosition.y + dragPadding)
    {
        MovingUp();
        yPos = 10;
    }
    else if (mouseCurrentPosition.y &lt; mouseStartPosition.y - dragPadding)
    {
        MovingDown();
        yPos = -10;
    }
    else
    {
        yPos = 0;
    }
    theStick.anchoredPosition = new Vector2(xPos, yPos);
}</pre></li> <li class="calibre14">The last piece we need to add is something that will reset the stick to its original position once the player <a id="_idIndexMarker681" class="pcalibre pcalibre1 calibre6"/>stops dragging or lifts up their finger. Add the following function to your script to do so:<pre class="source-code">
public void StoppedDrag()
{
    theStick.anchoredPosition = Vector2.zero;
}</pre></li> <li class="calibre14">Now, we need to hook this script and these functions to the items within the scene. Add the <code>FloatingAnalogStick</code> script to the <code>Stick </code><code>Base</code> Image.</li>
<li class="calibre14">Add the <code>Stick</code> Image to the <strong class="bold">Stick</strong> property in the <strong class="bold">Floating Analog </strong><strong class="bold">Stick</strong> component.</li>
<li class="calibre14">Add an <code>Stick Base</code> object with <strong class="bold">Add Component</strong> | <strong class="bold">Events</strong> | <strong class="bold">Event Trigger</strong>. This will allow the user to use Event Types other than <strong class="bold">On Click()</strong>.</li>
<li class="calibre14">Add the <strong class="bold">Begin Drag</strong>, <strong class="bold">Drag</strong>, and <strong class="bold">End Drag</strong> Event Types with the <strong class="bold">Add New Event </strong><strong class="bold">Type</strong> button.</li>
<li class="calibre14">Add the appropriate functions on the <code>FloatingAnalogStick</code> script attached to the <code>Stick Base</code> to the Events:</li>
</ol>
<div><div><img alt="Figure 11.40: The Event Trigger component" src="img/B18327_11_40.jpg" class="calibre390"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.40: The Event Trigger component</p>
<p class="calibre3">If you play the game now, you should see the eight-directional analog stick responding appropriately. Clicking on it and<a id="_idIndexMarker682" class="pcalibre pcalibre1 calibre6"/> dragging in any direction will cause the stick to move in the direction<a id="_idTextAnchor326" class="pcalibre pcalibre1 calibre6"/> of the drag.</p>
<h3 class="calibre9">Making the eight-directional virtual analog stick float</h3>
<p class="calibre3">If all you want is an eight-directional analog stick, you’re good to go! But if you want the analog stick to float—appear where the players press on the screen and disappear when they lift their finger—you have to do a little bit more work.</p>
<p class="calibre3">To make the analog stick appear <a id="_idIndexMarker683" class="pcalibre pcalibre1 calibre6"/>where the player clicks, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">First, we need to create an area where the player will click to bring up the analog stick. Right-click <code>Canvas</code> in the Hierarchy and select <code>Button</code> child to the <code>Canvas</code>. Rename the <code>Button</code> child <code>Click Area</code>.</li>
<li class="calibre14">Remove the <code>Text</code> child object from the <code>Click Area</code>.</li>
<li class="calibre14">Stretch the <code>Click Area</code> to fill the whole <code>Canvas</code>.</li>
<li class="calibre14">Add some padding to the sides of <code>Click Area</code> by changing the <code>50</code>. I have added this padding so that the player cannot click on the very edge of the screen and have the analog stick appear mostly off-screen.</li>
<li class="calibre14">In the Hierarchy, move <code>Click Area</code> so that it is above <code>Stick Base</code>. Now, <code>Click Area</code> will render<a id="_idIndexMarker684" class="pcalibre pcalibre1 calibre6"/> behind the analog stick:</li>
</ol>
<div><div><img alt="Figure 11.41: The Hierarchy showing Click Area and Stick Base" src="img/B18327_11_41.jpg" class="calibre391"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.41: The Hierarchy showing Click Area and Stick Base</p>
<ol class="calibre13">
<li value="6" class="calibre14">Open up your <code>FloatingAnalogStick</code> code so that we can add some functionality to it.</li>
<li class="calibre14">To make the position of our analog stick more easily hook to the position of the mouse on the screen, we should move our stick base so that it is centered at the lower-left corner of the <code>Canvas</code>. Set the anchor and position to the <strong class="bold">bottom left</strong> anchor preset.</li>
<li class="calibre14">Now, set the <code>0.5</code>.</li>
<li class="calibre14">Set the <code>0</code>. This should place the analog stick at the lower-left corner of the Canvas (or screen) with its pivot point set to its center:</li>
</ol>
<div><div><img alt="Figure 11.42: The Hierarchy showing Click Area and Stick Base" src="img/B18327_11_42.jpg" class="calibre392"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.42: The Hierarchy showing Click Area and Stick Base</p>
<ol class="calibre13">
<li value="10" class="calibre14">We need two more variables now to get the analog stick to appear where we want it to in the scene. Add <a id="_idIndexMarker685" class="pcalibre pcalibre1 calibre6"/>the following variable to your script to assign the stick and track if it has been added:<pre class="source-code">
[SerializeField] private RectTransform theBase;
[SerializeField] private bool stickAdded = false;</pre></li> <li class="calibre14">Now, create the following function to add the stick to the scene:<pre class="source-code">
public void AddTheStick()
{
    theBase.anchoredPosition = Input.mousePosition;
    theStick.anchoredPosition = Vector2.zero;
    mouseStartPosition = Input.mousePosition;
    stickAdded = true;
}</pre></li> <li class="calibre14">Add the following <code>Update()</code> function to determine when the stick will appear:<pre class="source-code">
void Update()
{
    if (stickAdded == true)
    {
        Dragging();
        if (Input.GetMouseButtonUp(0))
        {
            // ToggleBaseCanvasGroup(false);  // This line is commented out as ToggleBaseCanvasGroup is not defined in the provided code
            stickAdded = false;
            StoppedDrag();
        }
    }
}</pre></li> <li class="calibre14">Add <code>Stick Base</code> to the <strong class="bold">The </strong><strong class="bold">Base</strong> slot:</li>
</ol>
<div><div><img alt="Figure 11.43: The Floating Analog Stick component" src="img/B18327_11_43.jpg" class="calibre393"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.43: The Floating Analog Stick component</p>
<ol class="calibre13">
<li value="14" class="calibre14">Add the <code>Click Area</code>.</li>
<li class="calibre14">Add the following <code>Click Area</code>:
<div><div><img alt="Figure 11.44: The Event Trigger component" src="img/B18327_11_44.jpg" class="calibre394"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.44: The Event Trigger component</p>
<p class="calibre3">Playing the game now will have the analog stick appear where you click and move around with your dragging.</p></li>
</ol>
<ol class="calibre13">
<li value="16" class="calibre14">Now, let’s make it so that the analog stick is only visible when the player is touching the screen. Add a <code>Stick Base</code>.</li>
<li class="calibre14">Set <code>0</code>, <code>false</code>, and <code>false</code>.</li>
<li class="calibre14">Add the following variable to your <code>FloatingAnalogStick</code> script to keep track of the <code>CanvasGroup</code>:<pre class="source-code">
private CanvasGroup theBaseVisibility;</pre></li> <li class="calibre14">Add the following <code>Awake()</code> function to initialize the <code>theBaseVisibility</code> variable:<pre class="source-code">
void Awake()
{
    theBaseVisibility = theBase.GetComponent&lt;CanvasGroup&gt;();
}</pre></li> <li class="calibre14">Create a new function called <code>ToggleBaseCanvasGroup()</code> to toggle the <code>CanvasGroup</code>’s properties on and off:<pre class="source-code">
public void ToggleBaseCanvasGroup(bool visible)
{
    theBaseVisibility.alpha = Convert.ToInt32(visible);
    theBaseVisibility.interactable = visible;
    theBaseVisibility.blocksRaycasts = visible;
}</pre></li> <li class="calibre14">Add the following<a id="_idIndexMarker687" class="pcalibre pcalibre1 calibre6"/> to the <code>AddTheStick()</code> function to turn on the <code>CanvasGroup</code>:<pre class="source-code">
ToggleBaseCanvasGroup(true);</pre></li> <li class="calibre14">Add the following to the innermost <code>if</code> statement within the <code>Update()</code> function to turn off the <code>CanvasGroup</code>:<pre class="source-code">
ToggleBaseCanvasGroup(false);</pre></li> </ol>
<p class="calibre3">Now, the analog stick will appear when the player presses down, move in the direction of their finger, and disappear when the player lifts their finger.</p>
<h1 id="_idParaDest-206" class="calibre5"><a id="_idTextAnchor327" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
<p class="calibre3">UI Images are one of the core components of the Unity UI system and manipulating them is essential to creating visually interactive user interfaces. This chapter culminated all the skills we have learned in the preceding chapters by letting us create interesting interfaces that utilized Events, Buttons, and Images.</p>
<p class="calibre3">In the next chapter, we’ll look at how to create masks and scroll views so that we can hold even more child objects within our Panel containers.</p>
</div>
</div></body></html>