- en: Functional Programming Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程实践
- en: The previous chapter ([Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml),
    *Concurrent Programming in .NET Core*) introduced concurrent programming in .NET
    Core, and the aim of the chapter was to take advantage of `async`/`await` and
    parallelism, to make our program more performant.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章（[第 8 章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)，.NET Core 中的并发编程）介绍了
    .NET Core 中的并发编程，本章的目标是利用 `async`/`await` 和并行性，使我们的程序更高效。
- en: In this chapter, we will get a taste of functional programming, using the C#
    language. We will also dive deeper into the concepts that show you how to leverage
    C# in .NET Core to perform functional programming. The aim of this chapter is
    to help you understand what functional programming is and how we can use it using
    the C# language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用 C# 语言来体验函数式编程，并更深入地探讨如何利用 C# 在 .NET Core 中进行函数式编程的概念。本章的目的是帮助您了解函数式编程是什么，以及我们如何使用
    C# 语言来使用它。
- en: Functional programming was inspired by mathematics, and it solves problems in
    a functional way. In mathematics, we have formulas and, in functional programming,
    we use math in the form of various functions. The best part of functional programming
    is that it helps to implement concurrency seamlessly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程受到数学的启发，并以函数式的方式解决问题。在数学中，我们有公式，在函数式编程中，我们以各种函数的形式使用数学。函数式编程的最好之处在于它有助于无缝地实现并发。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: The inventory application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存应用程序
- en: Strategy patterns and functional programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式和函数式编程
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts of functional
    programming. The code is kept simple and is just for demonstration purposes. Most
    of the examples involve a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，用于解释函数式编程的概念。代码保持简单，仅用于演示目的。大多数示例涉及使用 C# 编写的 .NET Core 控制台应用程序。
- en: 'The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在以下链接获取：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9)。
- en: 'To run and execute the code, the prerequisites are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，需要以下先决条件：
- en: Visual Studio 2019 (a Visual Studio 2017 update 3 or later can also be used
    to run the application).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（Visual Studio 2017 更新 3 或更高版本也可以用于运行应用程序）。
- en: Setting up .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: SQL server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 服务器（本章使用的是 Express 版本）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: 'To run these code examples, you need to install Visual Studio 2017 (or a later
    version such as 2019). To do so, follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装 Visual Studio 2017（或更高版本，如 2019）。为此，请按照以下说明操作：
- en: 'Download Visual Studio from the following download link, which includes installation
    instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下下载链接下载 Visual Studio，其中包含安装说明：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明进行操作。
- en: Multiple versions are available for the Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 安装有多种版本。在这里，我们使用 Windows 版本的 Visual Studio。
- en: Setting up .NET Core
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您未安装 .NET Core，请按照以下说明操作：
- en: Download .NET Core for Windows at [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)
    下载 Windows 版本的 .NET Core。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多个版本和相关库，请访问 [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 SQL Server
- en: 'If you do not have SQL Server installed, you need to follow these instructions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您未安装 SQL Server，请按照以下说明操作：
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: 'Find the installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装说明请在此处查找：[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)。
- en: 'For troubleshooting and more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故障排除和更多信息，请参阅以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: Understanding functional programming
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: 'In simple terms, **functional programming** is an approach to symbolic computation
    that is done in the same way as solving mathematical problems. Any functional
    programming is based on mathematical functions and its coding style. Any language
    that supports functional programming works for solutions for the following two
    questions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**函数式编程**是一种与解决数学问题相同的方式进行符号计算的途径。任何函数式编程都基于数学函数及其编码风格。任何支持函数式编程的语言都适用于解决以下两个问题：
- en: What does it need to solve?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要解决什么问题？
- en: How does it solve it?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是如何解决这个问题的？
- en: 'Functional programming is not a new invention. This language has existed in
    the industry for a long time. The following are some well-known programming languages
    that support functional programming:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并非是一项新发明。这种语言在业界已经存在很长时间了。以下是一些支持函数式编程的知名编程语言：
- en: Haskell
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell
- en: Scala
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala
- en: Erlang
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erlang
- en: Clojure
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure
- en: Lisp
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp
- en: OCaml
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCaml
- en: In 2005, Microsoft released the first version of F# (pronounced *EffSharp—*[https://fsharp.org/](https://fsharp.org/)).
    This is a functional programming language that has a lot of good features that
    any functional programming should have. In this chapter, we are not going to discuss
    much F#, but we will be discussing functional programming and its implementation
    using the C# language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2005 年，Microsoft 发布了 F#（发音为 *EffSharp—*[https://fsharp.org/](https://fsharp.org/))
    的第一个版本。这是一种具有许多任何函数式编程都应该拥有的良好功能的函数式编程语言。在本章中，我们不会过多地讨论 F#，但我们将讨论函数式编程及其使用 C#
    语言实现。
- en: 'Pure functions are the ones that strengthen functional programming by saying
    that they''re pure. These functions work on two levels:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数通过声明它们是纯的来加强函数式编程。这些函数在两个层面上工作：
- en: The end result/output will always remain the same for the provided parameters.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于提供的参数，最终结果/输出将始终保持相同。
- en: They will not impact the behavior of the program or the execution path of the
    application, even when they are being called a hundred times.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使它们被调用一百次，也不会影响程序的行为或应用程序的执行路径。
- en: 'Consider the following example from our FlixOne inventory application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自我们 FlixOne 库应用的一个示例：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we have a `PriceCalc` class with two extension methods: `Discount`
    and `PriceAfterDiscount`. These functions could be called pure functions; both
    the `PriceCalc` function and the `PriceAfterDiscount` function are meeting the
    criteria to be `Pure` function; the `Discount` method will calculate the discount
    based on the current price and discount. In this case, the output of the method
    will never change for the supplied parameter values. In this way, the product
    with a price of `190.00` and a discount of `10.00` will be calculated in this
    way: `190.00 * 10.00 /100`, and this will return `19.00`. Our next method—`PriceAfterDiscount`—with
    the same parameter values will calculate `190.00 - 19.00` and return the value
    of `171.00`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个名为 `PriceCalc` 的类，它包含两个扩展方法：`Discount` 和 `PriceAfterDiscount`。这些函数可以是纯函数；`PriceCalc`
    函数和 `PriceAfterDiscount` 函数都符合成为 `Pure` 函数的标准；`Discount` 方法将根据当前价格和折扣计算折扣。在这种情况下，该方法对于提供的参数值将不会改变输出。这样，价格为
    `190.00` 且折扣为 `10.00` 的产品将按以下方式计算：`190.00 * 10.00 /100`，这将返回 `19.00`。我们的下一个方法——`PriceAfterDiscount`——使用相同的参数值将计算
    `190.00 - 19.00` 并返回 `171.00`。
- en: 'One more important point in functional programming is that functions are pure
    and convey complete information (also called **functional honesty**). Consider
    the `Discount` method from the previous code; this is a pure function that is
    also honest. So, if someone accidentally supplies a negative discount or a discount
    that is more than its actual price (more than 100%), will this function remain
    pure and honest? To handle this scenario, our mathematics function should be written
    in such a way that if someone enters `discount <= 0 or discount > 100`, then the
    system will not entertain it. Consider the following code with this approach:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个重要点是函数是纯净的，并且传达完整的信息（也称为**函数诚实性**）。考虑前一段代码中的 `Discount` 方法；这是一个既纯净又诚实的函数。所以，如果有人意外地提供了一个负折扣或超过其实际价格（超过100%）的折扣，这个函数是否会保持纯净和诚实？为了处理这种情况，我们的数学函数应该编写得这样，如果有人输入
    `discount <= 0 or discount > 100`，则系统将不予接受。以下是一个采用这种方法的代码示例：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, our `Discount` function has a parameter type named `ValidDiscount`,
    which validates the input we have discussed. In this way, our function is now
    an honest function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 `Discount` 函数有一个名为 `ValidDiscount` 的参数类型，它验证了我们之前讨论的输入。这样，我们的函数现在就是一个诚实的函数。
- en: These functions are as simple as functional programming, but working with functional
    programming still requires a lot of practice. In the upcoming sections, we will
    discuss advanced concepts of functional programming, including functional programming
    principles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与函数式编程一样简单，但使用函数式编程仍然需要大量的实践。在接下来的章节中，我们将讨论函数式编程的高级概念，包括函数式编程原则。
- en: 'Consider the following code, where we are checking whether the discount value
    is valid:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，其中我们正在检查折扣值是否有效：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code snippet, we have a field named `_validDiscount`. Let''s
    look at what this is doing: `Func` accepts `decimal` as an input and returns `bool`
    as an output. From its name, you can see that `field` stores only valid discounts.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有一个名为 `_validDiscount` 的字段。让我们看看它在做什么：`Func` 接受 `decimal` 作为输入并返回
    `bool` 作为输出。从其名称中，你可以看出该 `field` 只存储有效的折扣。
- en: '`Func` is a type of delegate that points to a method of one or more arguments
    and returns a value. The general declaration of `Func` is `Func<TParameter, TOutput>`,
    where `TParameter` is the input parameter of any valid datatype and `TOutput`
    is the return value of any valid datatype.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func` 是一种委托类型，指向一个或多个参数的方法并返回一个值。`Func` 的一般声明为 `Func<TParameter, TOutput>`，其中
    `TParameter` 是任何有效数据类型的输入参数，而 `TOutput` 是任何有效数据类型的返回值。'
- en: 'Consider the following code snippet, where we are using the `_validDiscount`
    field in a method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中我们正在一个方法中使用 `_validDiscount` 字段：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have the `FilterOutInvalidDiscountRates` method. This
    method is self-explanatory and indicates that we are filtering out invalid discount
    rates. Let's analyze the code now.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有 `FilterOutInvalidDiscountRates` 方法。这个方法名本身就说明了我们的意图，即过滤掉无效的折扣率。现在让我们分析一下代码。
- en: 'The `FilterOutInvalidDiscountRates` method returns a collection of `DiscountViewModel`
    class for the products that have a valid discount. The following code is of our
    `DiscountViewModel` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterOutInvalidDiscountRates` 方法返回一个包含具有有效折扣的 `DiscountViewModel` 类的集合。以下是我们
    `DiscountViewModel` 类的代码：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our `DiscountViewModel` class contains the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `DiscountViewModel` 类包含以下内容：
- en: '`ProductId`: This represents the ID of a product.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductId`: 这代表产品的ID。'
- en: '`ProductName`: This represents the name of a product.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductName`: 这代表产品的名称。'
- en: '`Price`: This contains the actual price of the product. The actual price is
    before any discount, taxes, and so on.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格`: 这包含产品的实际价格。实际价格是在任何折扣、税费等之前的。'
- en: '`Discount`: This contains the percentage of a discount such as 10 or 3\. A
    valid discount rate should not be negative, equal to zero, or more than 100% (in
    other words, it should not be more than the actual cost of the product).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`折扣`: 这包含折扣的百分比，例如10或3\. 合法的折扣率不应为负数，等于零，或超过100%（换句话说，不应超过产品的实际成本）。'
- en: '`Amount`: This contains the product value after any discount, taxes, and so
    on.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数量`: 这包含任何折扣、税费等之后的商品价值。'
- en: Now, let's jump back to our `FilterOutInavlidDiscountRates` method and take
    a look at `viewModels.Select(x => x.Discount).Where(_vallidDiscount)`. Here, you
    might notice that we are selecting discount rates from our `viewModels` list.
    This list contains discount rates that are valid as per the `_validDiscount` field.
    In the next line, our method is returning records with valid discount rates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的`FilterOutInavlidDiscountRates`方法，看看`viewModels.Select(x => x.Discount).Where(_vallidDiscount)`。在这里，你可能注意到我们正在从`viewModels`列表中选择折扣率。这个列表包含根据`_validDiscount`字段有效的折扣率。在下一行，我们的方法返回具有有效折扣率的记录。
- en: In functional programming, these functions are also known as **first-class functions**.
    These are the functions whose values can be used as an input or output for any
    other function. They can also be assigned to variables or stored in collections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，这些函数也被称为**一等函数**。这些是可以作为任何其他函数的输入或输出的函数值。它们也可以分配给变量或存储在集合中。
- en: 'Go to Visual Studio and open the `FlixOne` inventory application. From here,
    run the application and you will see the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Visual Studio并打开`FlixOne`库存应用程序。从这里运行应用程序，你将看到以下截图：
- en: '![](img/a92e6211-c9db-44ae-8dde-6c0cff7213f5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a92e6211-c9db-44ae-8dde-6c0cff7213f5.png)'
- en: The previous screenshot is the Product Listing page that is showing all the
    available products. This is a simple page; you can also call it the Product Listing
    dashboard, where you'll find all the products. From Create New Product, you can
    add a new product, and Edit will give you the facility to update an existing product.
    In addition, the Details page will show the complete details of a specific product.
    By clicking Delete, you can remove the existing product from the listing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图是产品列表页面，显示了所有可用的产品。这是一个简单的页面；你也可以称之为产品列表仪表板，在这里你可以找到所有产品。从“创建新产品”可以添加新产品，而“编辑”将提供更新现有产品的功能。此外，详情页面将显示特定产品的完整详情。通过点击“删除”，你可以从列表中移除现有产品。
- en: 'Please refer to our `DiscountViewModel` class. We have the option to have multiple
    discount rates for a product with a business rule, which establishes that only
    one discount rate is active at a time. To view all the discount rates for a product,
    click on a discount rate from the preceding screen (Product Listing). This will
    show the following screen:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考我们的`DiscountViewModel`类。我们有一个选项，可以为具有业务规则的产品设置多个折扣率，该规则规定一次只能有一个折扣率处于活动状态。要查看产品的所有折扣率，请从上一个屏幕（产品列表）中选择一个折扣率。这将显示以下屏幕：
- en: '![](img/70619b88-ea6e-4cbd-814b-22c43ab44ae0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70619b88-ea6e-4cbd-814b-22c43ab44ae0.png)'
- en: The preceding screen is Product Discount Listing that shows the discount listing
    for the product name Mango. This has two discount rates, but only the Seasonal
    Discount rate is active. You might have noticed the remarks column; this is marked
    as an invalid discount rate because, as per `_validDiscount`—which is discussed
    in the previous section—this discount rate does not match the criteria for a valid
    discount rate.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕是产品折扣列表，显示了产品名称Mango的折扣列表。这里有两条折扣率，但只有季节性折扣率是活动的。你可能已经注意到备注列；这被标记为无效折扣率，因为根据前面章节中讨论的`_validDiscount`，这个折扣率不符合有效折扣率的标准。
- en: '`Predicate` is also a delegate type, similar to `Func` delegates. This represents
    a method that validates the set of criteria. In other words, `Predicate` returns
    the type of `Predicate <T>`, where `T` is a valid datatype. It works if the criteria
    matches and returns a value of type `T`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`也是一个委托类型，类似于`Func`委托。它表示一个验证一组标准的方法。换句话说，`Predicate`返回类型为`Predicate
    <T>`的值，其中`T`是一个有效的数据类型。如果条件匹配，它将返回类型为`T`的值。'
- en: 'Consider the following code, where we are validating the Product Name to be
    valid as sentence case:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，其中我们正在验证产品名称是否为有效句子大小写：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we are using the `Predicate` keyword, and this analyzes
    the condition to validate `ProductName` using `TitleCase` keyword. If the criteria
    matches, the result will be `true`. If not, the result will be `false`. Consider
    the following code snippet, where we are using `_isProductNameTitleCase`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`Predicate`关键字，并且使用`TitleCase`关键字来分析条件以验证`ProductName`。如果条件匹配，结果将是`true`。如果不匹配，结果将是`false`。考虑以下代码片段，其中我们使用了`_isProductNameTitleCase`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have the `FilterOutInvalidProductNames` method. The
    aim of this method is to pick the products with a valid product name (a `TitleCase`
    product name only).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`FilterOutInvalidProductNames`方法。这个方法的目标是选择具有有效产品名称的产品（仅限`TitleCase`格式的产品名称）。
- en: Enhancing our inventory application
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的库存应用程序
- en: The project is for a hypothetical situation where a company, FlixOne, wants
    to enhance an inventory management application to manage its growing collection
    of products. This is not a new application, as we have already started the development
    of this application and discussed the initial stage in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns - Basics Part 1*, where we have started developing
    a console-based inventory system. From time to time, stakeholders will review
    the application and try to meet end users' requirements. The enhancement is important,
    as this application will be used by both staff (to manage the inventory) and by
    customers (to browse and create new orders). The application will need to be scalable,
    and is an essential system for the business.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是一个假设情景，其中一家公司，FlixOne，希望增强其库存管理应用程序以管理其不断增长的产品集合。这不是一个新应用程序，因为我们已经开始了这个应用程序的开发，并在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，《实现设计模式
    - 基础部分1》中讨论了初始阶段，我们开始开发基于控制台的库存系统。不时，利益相关者将审查应用程序并尝试满足最终用户的需求。增强是重要的，因为这个应用程序将由员工（用于管理库存）和客户（用于浏览和创建新订单）使用。该应用程序需要可扩展，并且是业务的一个基本系统。
- en: As this is a technical book, we will mostly discuss the various technical observations
    from the development team's perspective and discuss the patterns and practices
    used to implement the inventory management application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本技术书籍，我们将主要从开发团队的角度讨论各种技术观察，并讨论用于实现库存管理应用程序的模式和实践。
- en: Requirements
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: There is a need to enhance the application, and this cannot be achieved in one
    day. This will require a lot of meetings and discussions. Over the course of several
    meetings, the business and the development teams discussed the requirements of
    the new enhancements to the inventory management system. Progress toward defining
    a clear set of requirements was slow, and the vision of the final product was
    not clear. The development team decided to pare down the enormous list of requirements
    to just enough functionality so that a key individual could start to record some
    inventory information. This would allow for simple inventory management and provide
    a basis that the business could extend upon. We will work on the requirement and
    take a **Minimal Viable Product** (**MVP**) approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要增强应用程序，这不可能在一天内完成。这需要很多会议和讨论。在多次会议的过程中，业务团队和开发团队讨论了新增强的库存管理系统的需求。明确需求定义的进展缓慢，最终产品的愿景并不清晰。开发团队决定将庞大的需求列表缩减到仅包含足够的功能，以便关键个人可以开始记录一些库存信息。这将允许进行简单的库存管理，并为业务扩展提供一个基础。我们将对需求进行工作，并采用**最小可行产品**（**MVP**）的方法。
- en: MVP is the smallest set of features of an application that can still be released
    and have enough value for a user base.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MVP是应用程序中最小的一组功能，仍然可以发布并具有足够的用户价值。
- en: 'After several meetings and discussions between management and business analysts,
    a list of requirements was produced to enhance our `FlixOne` web application.
    The high-level requirements are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理层和业务分析师之间进行了多次会议和讨论后，产生了一份需求列表以增强我们的`FlixOne`网络应用程序。高级需求如下：
- en: '**Implementation of pagination**: Currently, all page listings are not paginated.
    It is really challenging to view items with large page counts by scrolling down
    or scrolling up the screen.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页实现**：目前，所有页面列表都没有分页。通过滚动屏幕上下查看具有大量页面计数的项目非常具有挑战性。'
- en: '**Discount Rates**: Currently, there is no provision to add or see the various
    discount rates for a product. The business rules for discount rates are as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折扣率**：目前，没有提供添加或查看产品各种折扣率的规定。折扣率的业务规则如下：'
- en: A product can have more than one discount rate.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品可以有多个折扣率。
- en: A product can only have one active discount rate.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品只能有一个有效的折扣率。
- en: A valid discount rate should not be a negative value and should not be more
    than 100%.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的折扣率不应为负值，且不应超过100%。
- en: Back to FlixOne
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回 FlixOne
- en: 'In the previous section, we discussed what is required in order to enhance
    an application. In this section, we will implement these requirements. Let''s
    first revisit the file structure of our project. Take a look at the following
    snapshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了增强应用程序所需的内容。在本节中，我们将实现这些要求。让我们首先回顾一下我们项目的文件结构。看看下面的快照：
- en: '![](img/fb23aa69-1daf-4775-b51f-5afe3c7d9bc9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb23aa69-1daf-4775-b51f-5afe3c7d9bc9.png)'
- en: 'The previous snapshot is depicting our FlixOne web application, having a folder
    structure as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的快照展示了我们的 FlixOne 网络应用程序，其文件夹结构如下：
- en: '**wwwroot**: This is the folder that comes with static contents, such as CSS
    and jQuery files, which are required for the UI project. This folder comes with
    the default template provided by Visual Studio.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wwwroot**：这是包含静态内容（如 CSS 和 jQuery 文件）的文件夹，这些内容对于 UI 项目是必需的。这个文件夹包含 Visual
    Studio 提供的默认模板。'
- en: '**Common**: This contains all the common files and operations related to business
    rules and more.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**：这包含所有与业务规则相关的通用文件和操作。'
- en: '**Contexts**: This contains `InventoryContext`, which is a `DBContext` class
    that provides `Entity Framework Core` capabilities.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这包含 `InventoryContext`，它是一个 `DBContext` 类，提供了 `Entity Framework Core`
    功能。'
- en: '**Controllers**: This contains all the controller classes of our `FlixOne`
    application.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这包含我们 `FlixOne` 应用程序的所有控制器类。'
- en: '**Migration**: This contains the `InventoryModel` snapshot and initially created
    entities.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移**：这包含 `InventoryModel` 快照和最初创建的实体。'
- en: '**Models:** This contains data models, `ViewModels`, that are required for
    our application.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含我们应用程序所需的数据模型和 `ViewModels`。'
- en: '**Persistence:** This contains the `InventoryRepository` and its operations.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化**：这包含 `InventoryRepository` 及其操作。'
- en: '**Views**: This contains all the views/screens of the application.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这包含应用程序的所有视图/屏幕。'
- en: 'Consider the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code contains an `IHelper` interface that is holding two methods.
    We will implement this interface in the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含一个 `IHelper` 接口，它包含两个方法。我们将在以下代码片段中实现此接口：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Helper` class implements the `IHelper` interface. In this class, we have
    two main, and important, methods: one is to check for a valid discount and the
    other is to check for a valid `ProductName` attribute.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Helper` 类实现了 `IHelper` 接口。在这个类中，我们有两个主要且重要的方法：一个是检查有效折扣，另一个是检查有效的 `ProductName`
    属性。'
- en: 'Before we use this functionality in our application, we should add this to
    our `Startup.cs` file, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用此功能之前，我们应该将其添加到我们的 `Startup.cs` 文件中，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we have a written statement, `services.AddTransient<IHelper,
    Helper>();`. With this, we are adding a transient service to our application.
    We have already discussed the *Inversion of control* section in [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml),
    *Implementing Design Patterns - .Net Core*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个语句，`services.AddTransient<IHelper, Helper>();`。通过这个语句，我们向应用程序添加了一个瞬态服务。我们已经在
    [第五章](fd71001a-4673-4391-a10b-2490e07f135e.xhtml) 的 *实现设计模式 - .Net Core* 部分讨论了
    *控制反转* 部分。
- en: 'Consider the following code, where we are using the `IHelper` class by taking
    leverage of Inversion of control:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，其中我们通过利用控制反转（Inversion of control）使用 `IHelper` 类：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code contains the `InventoryRepository` class, where we can see
    the use of a proper **Dependency Injection** (**DI**):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含 `InventoryRepository` 类，我们可以看到正确使用 **依赖注入**（**DI**）的情况：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is the `GetDiscountBy` method of the `InventoryRepository`
    class that is a returning collection of the discount model for the `active` or
    `de-active` records. Consider the following code snippet that is used for the
    `DiscountViewModel` collection:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是 `InventoryRepository` 类的 `GetDiscountBy` 方法，它返回 `active` 或 `de-active`
    记录的折扣模型集合。考虑以下用于 `DiscountViewModel` 集合的代码片段：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code that uses a collection of `DiscountViewModel` is filtering
    out the products that do not have a valid discount as per the business rule we
    discussed previously. The `GetValidDiscountProducts` method returns the collection
    of `DiscountViewModel`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DiscountViewModel` 集合的上述代码根据我们之前讨论的业务规则过滤掉没有有效折扣的产品。`GetValidDiscountProducts`
    方法返回 `DiscountViewModel` 集合。
- en: 'If we forget to define `IHelper` in our project `startup.cs` file, we will
    meet an exception, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在项目 `startup.cs` 文件中忘记定义 `IHelper`，我们将遇到异常，如下面的截图所示：
- en: '![](img/18dae3fc-bf2b-4296-be43-c0447ffc8d47.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18dae3fc-bf2b-4296-be43-c0447ffc8d47.png)'
- en: The preceding screenshot is clearly saying that the `IHelper` service is not
    resolved. In our case, we will not face this exception, as we have already added
    `IHelper` to the `Startup` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图清楚地表明`IHelper`服务没有被解析。在我们的情况下，我们不会遇到这个异常，因为我们已经将`IHelper`添加到了`Startup`类中。
- en: 'Until now, we have added helper methods to fulfill our new requirement for
    discount rates and to validate them. Now, let''s add a controller and subsequent
    action methods. To do so, add a new `DiscountController` controller from Solution
    Explorer. After this, our `FlixOne` web solution will look similar to the following
    snapshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经添加了辅助方法来满足我们对折扣率的新的要求，并对其进行验证。现在，让我们添加一个控制器和后续的动作方法。要做到这一点，从解决方案资源管理器中添加一个新的`DiscountController`控制器。之后，我们的`FlixOne`
    Web解决方案将类似于以下快照：
- en: '![](img/8c9cb2fd-c823-4cd2-bcac-143a3fd6ff2c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c9cb2fd-c823-4cd2-bcac-143a3fd6ff2c.png)'
- en: 'In the preceding snapshot, we can see that our `Controller` folder now has
    one additional controller, which is `DiscountController`. The following code is
    from `DiscountController`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的快照中，我们可以看到我们的`Controller`文件夹现在多了一个控制器，即`DiscountController`。以下代码来自`DiscountController`：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Execute the application and, from the main screen, click on Products and then
    click on Product Discount Listing. From here, you will get the following screen:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，从主屏幕点击产品，然后点击产品折扣列表。从这里，您将看到以下屏幕：
- en: '![](img/b228c14a-47b4-427b-9f13-b4bff9507521.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b228c14a-47b4-427b-9f13-b4bff9507521.png)'
- en: The preceding snapshot is depicting Product Discount Listing for all the available
    products. The Product Discount Listing has a lot of records; therefore, it requires
    scrolling up or scrolling down to view items on the screen. To handle this difficult
    situation, we should implement paging.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的快照描述了所有可用产品的产品折扣列表。产品折扣列表有很多记录，因此需要向上或向下滚动以在屏幕上查看项目。为了处理这种困难的情况，我们应该实现分页。
- en: Strategy pattern and functional programming
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式和函数式编程
- en: During the first four chapters of this book, we discussed patterns and practices
    a lot. The strategy pattern is one of the important patterns of **Gang of Four**
    (**GoF**) patterns. This falls under the behavioral patterns category and is also
    known as a policy pattern. This is a pattern that is usually implemented with
    the help of classes. This is also an easier one to implement using functional
    programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前四章中，我们讨论了很多模式和最佳实践。策略模式是**四人帮**（**GoF**）模式中的重要模式之一。这属于行为模式类别，也被称为策略模式。这是一个通常需要通过类来实现的模式。这也是使用函数式编程实现起来较为简单的一个模式。
- en: Jump back to the *Understanding functional programming* section of this chapter
    and reconsider the paradigm of functional programming. Higher-order functions
    are one of the important paradigms of functional programming; using this, we can
    easily implement a strategy pattern in a functional way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本章的*理解函数式编程*部分，重新考虑函数式编程的范式。高阶函数是函数式编程的重要范式之一；使用它，我们可以轻松以函数式的方式实现策略模式。
- en: '**Higher-order functions** (**HOFs**) are the functions that take parameters
    as functions. They can also return functions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶函数**（**HOFs**）是接受函数作为参数的函数。它们也可以返回函数。'
- en: 'Consider the following code that shows the implementation of HOFs in functional
    programming:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它展示了在函数式编程中高阶函数的实现：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is a simple implementation of the `Where` clause, in which
    we used `LINQ Query`. In this, we are iterating a collection and returning an
    item if it meets the criteria. The preceding code can be further simplified. Consider
    the following code for a more simplified version of the preceding code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是`Where`子句的一个简单实现，其中我们使用了`LINQ查询`。在这里，我们正在迭代一个集合，如果项目满足标准，则返回一个项。前面的代码可以进一步简化。考虑以下代码，这是前面代码的一个更简化的版本：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the `SimplifiedWhere` method produces the same result as the
    previously discussed `Where` method. This method is criteria-based and has a strategy
    to return results, and this criterion executes at runtime. We can easily call
    the preceding function in a subsequent method to take advantage of functional
    programming. Consider the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`SimplifiedWhere`方法产生的结果与之前讨论的`Where`方法相同。这是一个基于标准的，有策略返回结果的方法，并且这个标准在运行时执行。我们可以轻松地在后续方法中调用前面的函数，以利用函数式编程。考虑以下代码：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have a method called `GetProductsAbovePrice`. In this method, we are providing
    the price. This method is self-explanatory, and it works on a collection of `ProductViewModel`
    with a criteria to list the products that have a product price that is more than
    the parameter price. In our `FlixOne` inventory application, you can find further
    scope to implement functional programming.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`GetProductsAbovePrice`的方法。在这个方法中，我们提供了价格。这个方法很直观，它在一个`ProductViewModel`集合上工作，根据产品价格是否高于参数价格来列出产品。在我们的`FlixOne`库存应用程序中，您可以找到进一步实现函数式编程的更多空间。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Functional programming is all about functions and, predominantly, mathematical
    functions. Any language that supports functional programming always works on the
    solution with two main questions: what needs to be solved and how can this be
    solved? We saw functional programming and its easy implementation using the C#
    programming language.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程全部关于函数，主要是数学函数。任何支持函数式编程的语言总是围绕两个主要问题来解决问题：需要解决什么以及如何解决这个问题？我们看到了使用C#编程语言实现的函数式编程及其简单性。
- en: We also learned about `Func`, `Predicate`, LINQ, `Lambda`, anonymous functions,
    closures, expression trees, currying, closures, and recursion. Finally, we looked
    into the implementation of the strategy pattern using functional programming.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了`Func`、`Predicate`、LINQ、`Lambda`、匿名函数、闭包、表达式树、柯里化、闭包和递归。最后，我们探讨了使用函数式编程实现策略模式的方法。
- en: In the next chapter ([Chapter 10](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml),
    *Reactive Programming Patterns and Techniques*), we will discuss reactive programming
    as well as its model and principles. We will also discuss **reactive extensions**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第10章](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml)，*响应式编程模式和技巧*）中，我们将讨论响应式编程及其模型和原则。我们还将讨论**响应式扩展**。
- en: Questions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: What is functional programming?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: What is referential transparency in functional programming?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程中的引用透明性是什么？
- en: What is a pure function?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是纯函数？
