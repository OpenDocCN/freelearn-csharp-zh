- en: Pluggable Protocols in .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的可插拔协议
- en: In the previous chapters, we covered a wide breadth of topics related to general
    network programming concepts, challenges, and patterns. With this chapter, we'll
    see how to work on that knowledge to define our own application layer protocols
    within .NET Core. We'll learn about the concept of a **pluggable protocol**. We'll
    see how .NET Core gives you the ability to extend the `WebRequest` class to define
    your own standards and expectations for network interactions. We'll look at how
    to register your new protocol for use by the `WebRequest` factory methods. Finally,
    we'll discuss the advantages of doing so, and when you should consider using it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们涵盖了与一般网络编程概念、挑战和模式相关的大量主题。在本章中，我们将看到如何利用这些知识在.NET Core中定义自己的应用层协议。我们将了解**可插拔协议**的概念。我们将看到.NET
    Core如何让您扩展`WebRequest`类以定义自己的网络交互标准和期望。我们将探讨如何注册您的新协议以便由`WebRequest`工厂方法使用。最后，我们将讨论这样做的好处，以及何时应该考虑使用它。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding pluggable protocols
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可插拔协议
- en: How to implement a sub-class of the `WebRequest` class from the `System.Net`
    namespace
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现`System.Net`命名空间中`WebRequest`类的子类
- en: The support infrastructure, which allows custom communication protocols to be
    leveraged in .NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持基础设施，允许在.NET Core中使用自定义通信协议
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the code samples in this chapter, or open them up and modify
    them for your own purposes, you'll need an IDE or code editor (Visual Studio or
    Visual Studio Code, of course) as well as the source code, which can be found
    here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter
    17](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2017).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的代码示例，或者打开它们并根据自己的目的进行修改，你需要一个集成开发环境（IDE）或代码编辑器（当然，Visual Studio或Visual
    Studio Code），以及源代码，可以在以下位置找到：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2017](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2017).
- en: Additionally, we'll continue to take advantage of our preferred REST client,
    so be ready with either PostMan ([https://www.getpostman.com/downloads/](https://www.getpostman.com/downloads/))
    or the Insomnia REST client [(](https://www.getpostman.com/downloads/)[https://insomnia.rest/](https://insomnia.rest/)[)](https://www.getpostman.com/downloads/)[.](https://insomnia.rest/)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将继续利用我们偏好的REST客户端，所以请准备好PostMan ([https://www.getpostman.com/downloads/](https://www.getpostman.com/downloads/))
    或Insomnia REST客户端 [(](https://www.getpostman.com/downloads/)[https://insomnia.rest/](https://insomnia.rest/)[)](https://www.getpostman.com/downloads/)[.](https://insomnia.rest/)
- en: Understanding pluggable protocols
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可插拔协议
- en: To understand how best to leverage pluggable protocols, and when they might
    be valuable in your software, we first have to understand what they are. We need
    to know the problems they were designed to solve and how they seek to solve them.
    So, we'll start with a simple definition of what pluggable protocols are, and
    then look at why we might want to use them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何最好地利用可插拔协议，以及它们在您的软件中可能何时有价值，我们首先必须了解它们是什么。我们需要知道它们旨在解决什么问题以及它们是如何寻求解决这些问题的。因此，我们将从对可插拔协议的简单定义开始，然后探讨为什么我们可能想要使用它们。
- en: What exactly is a pluggable protocol?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是可插拔协议？
- en: A **pluggable protocol** is an implementation of a custom, application-layer
    communication protocol, written to be integrated with the .NET Core `WebRequest`
    model for processing network interactions. Or, put more simply, it's a how .NET
    Core supports non-standard communication protocols. That's it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**可插拔协议**是一种自定义的应用层通信协议的实现，旨在与.NET Core的`WebRequest`模型集成以处理网络交互。或者，更简单地说，这是.NET
    Core如何支持非标准通信协议。就是这样。'
- en: In [Chapter 5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)*, Generating Network
    Requests with C#*, we saw how powerful the simple request/response pattern can
    be for facilitating source-agnostic network communications in our app. Moreover,
    we saw how well the .NET Core framework reduces the complexity of those kinds
    of interactions by supporting out-of-the-box `WebRequest` sub-classes to support
    the most common application-layer protocols in our source code. However, where
    the framework itself provides us with out-of-the-box implementations of common
    protocols, the pluggable protocols implementation pattern gives us an entry point
    through which we can extend that system for less-common, or custom, protocols.
    It gives us the ability to define our own implementations and configure them to
    be used just as easily and reliably as the framework classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)*生成C#网络请求*中，我们看到了简单的请求/响应模式在促进我们应用中与源无关的网络通信方面的强大功能。此外，我们还看到了.NET
    Core框架如何通过支持开箱即用的`WebRequest`子类来减少这些类型交互的复杂性，这些子类支持我们源代码中最常见的应用层协议。然而，尽管框架本身为我们提供了常见协议的开箱即用实现，但可插拔协议实现模式为我们提供了一个入口点，通过它可以扩展该系统以支持较少见或定制的协议。它赋予我们定义自己的实现并将其配置为与框架类一样容易和可靠地使用的功能。
- en: Why use pluggable protocols?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用可插拔协议？
- en: Let's imagine for a second that you want to streamline communication between
    two critical resources in your software ecosystem. To facilitate this, you've
    devised a highly optimized packet structure and interaction mechanism. The headers
    are only exactly as large as is necessary to communicate details about the proprietary
    application packets. Let's also assume that this protocol uses a brief negotiation
    phase that takes place between hosts to facilitate data transfer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一下，你想要简化你软件生态系统中的两个关键资源之间的通信。为了实现这一点，你已经设计了一个高度优化的数据包结构和交互机制。头部的大小仅恰好足够以传达关于专有应用数据包的详细信息。让我们再假设这个协议使用一个简短的协商阶段，这个阶段发生在主机之间以促进数据传输。
- en: Since this is proprietary, you could just hand-roll your interactions between
    the two hosts in each of their respective applications. However, this approach
    doesn't exactly scale with the potential growth of users of your protocol. What
    if another team decides that they also want to leverage your optimized protocol?
    You'd be responsible for communicating the specific details of your program's
    interactions with them, introducing a time and productivity cost to anyone involved
    in the knowledge transfer process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是专有的，你可以在每个应用中手动实现两个主机之间的交互。然而，这种方法并不完全随着你协议用户潜在增长而扩展。如果另一个团队决定他们也想利用你的优化协议，你将负责与他们沟通你程序交互的具体细节，这会给知识转移过程中的任何人都带来时间和生产力的成本。
- en: Alternatively, how durable would such an approach be against turnover on your
    own teams? If you lose original members of your team that had intimate knowledge
    of your protocol's design and use, you'll need to on-board new team members to
    fill the gaps. Having to code a proprietary interaction mechanism between two
    network hosts increases the time to on-board new members.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种做法在你自己的团队人员流动方面有多大的持久性？如果你失去了对协议设计和使用有深入了解的原始团队成员，你需要让新团队成员加入以填补空缺。在两个网络主机之间编写专有交互机制需要增加新成员的入职时间。
- en: What if, instead of requiring the use of bespoke interaction mechanisms for
    any consumers of your protocol, you could encapsulate it behind a pattern with
    which new users are already familiar? With pluggable protocols, you can do exactly
    that. The only prerequisite to leveraging the conventions and simplicity of the
    `WebRequest` and `WebResponse` classes is that the interactions of your protocol
    can be reduced, at their most basic conceptual level, to the well-understood request/response
    pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，你不需要为你的协议的任何消费者使用定制的交互机制，而是可以将其封装在一个新用户已经熟悉的模式后面，会怎么样？使用可插拔协议，你就可以做到这一点。利用`WebRequest`和`WebResponse`类的约定和简单性的唯一先决条件是，你的协议的交互在最基本的概念层面上可以简化为人们已经理解的请求/响应模式。
- en: By encompassing the operations of our custom protocol behind the conventions
    of the `WebRequest` and `WebResponse` classes, we can mitigate all of the challenges
    introduced by a proprietary protocol. New teams no longer have to be concerned
    with the intricacies of your header structure, or figure out the handshake that's
    necessary to initiate a data transfer. You can simply implement those components
    within your custom `WebRequest` subclass, and expose the resulting data stream
    after you've successfully acquired a response. Additionally, on-boarding new team
    members requires no additional overhead in learning the intricacies of your protocol.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们自定义协议的操作封装在`WebRequest`和`WebResponse`类的约定之下，我们可以减轻由专有协议引入的所有挑战。新的团队不再需要担心您头部结构的复杂性，或者找出启动数据传输所需的手势。您只需在您的自定义`WebRequest`子类中实现这些组件，并在成功获取响应后暴露生成的数据流。此外，引入新的团队成员不需要学习您协议复杂性的额外开销。
- en: Defining a pluggable protocol
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个可插拔协议
- en: While it may be obvious what benefits you'll reap by encapsulating custom communication
    protocols, behind the `WebRequest` and `WebResponse` classes, you might be surprised
    to learn that it's also a fairly simple goal to achieve. The biggest challenge
    you'll face is simply learning the methods and properties you'll need to override
    or implement as you create your subclass. But, at a high level, creating a pluggable
    protocol is fairly straightforward. Let's look at the steps you'll need to follow,
    and then we'll take those steps in the next section as we implement our own pluggable
    protocol.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管封装自定义通信协议可能带来的好处可能很明显，但在`WebRequest`和`WebResponse`类背后，您可能会惊讶地发现实现这个目标其实相当简单。您将面临的最大挑战是简单地学习在创建子类时需要覆盖或实现的方法和属性。但从高层次来看，创建一个可插拔协议相当直接。让我们看看您需要遵循的步骤，然后我们将在下一节中按照这些步骤实现我们自己的可插拔协议。
- en: Defining your schema
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义您的模式
- en: As I mentioned earlier in this section, pluggable protocols represent a custom
    application-layer protocol for web interactions. Requests that are sent between
    two applications over this protocol will need to be handled in a unique way. To
    distinguish requests that are transmitted over your custom protocol from other,
    more common protocols, you'll need to define the schema for it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前在本节中提到的，可插拔协议代表了一种针对Web交互的自定义应用层协议。通过此协议在两个应用程序之间发送的请求需要以独特的方式进行处理。为了将您自定义协议中传输的请求与其他更常见的协议区分开来，您需要为其定义模式。
- en: 'As you may remember from [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml),
    *DNS and Resource Location*, the schema component of a URL is how routers and
    web hosts determine how to attempt to parse headers of request packets. Using
    the `http` or `https` schemas indicates to the recipient host that the message
    details can be derived by parsing the incoming byte stream according to the partitioning
    and delineating standards of an HTTP header. So, a host receiving a request with
    the schema specified as `http://` in the request URI will expect the first bytes
    of the incoming stream to specify the HTTP verb, the specific resource path, and
    the version, followed by a line-terminal character, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从[第二章](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml)“DNS和资源定位”中记得的，URL的模式组件是路由器和Web主机确定如何尝试解析请求数据包的头部的方式。使用`http`或`https`模式表示接收主机，消息细节可以通过解析传入的字节流，根据HTTP头部的分区和界定标准来推导。因此，接收带有在请求URI中指定为`http://`的模式请求的主机将期望传入流的前几个字节指定HTTP动词、特定的资源路径和版本，之后是一个行终止字符，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, suppose your protocol is designed to do away with those HTTP-specific
    message details. Let''s say you''re designing a message queue that accepts an
    arbitrary number of records with fields of a single fixed length. Now, let''s
    say that the request messages for your protocol are formatted with a header composed
    of pipe-delimited values noting various details about the structure of the packet,
    such as the 0-indexed packet length, the number of optional details specified
    in the headers, and the byte-size of each field in the records of your message,
    so that your message header looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设您的协议旨在去除那些HTTP特定的消息细节。比如说，您正在设计一个接受任意数量的记录，记录字段具有单个固定长度的消息队列。现在，假设您的协议的请求消息以一个由管道分隔的值组成的头部进行格式化，这些值说明了数据包结构的各种细节，例如0索引的数据包长度、在头部中指定的可选细节的数量以及消息记录中每个字段的字节大小，这样您的消息头部看起来就像这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you sent a message using the `http://` schema and its first line of incoming
    bytes contained those details, the consuming application would simply respond
    with a `401 - Bad Request` status. It wouldn''t be able to parse the information
    in the header because it wouldn''t have the proper context for doing so. That''s
    what a schema provides to remote hosts: the initial context for parsing its messages.
    To that end, it''s important that you define a schema that you''re certain will
    be unique from other custom protocols or schemas (and certainly distinct from
    any standardized protocols, such as HTTP or FTP). Your schema will need to be
    uniquely identifiable so that there''s no failure to parse your messages on any
    hosts that leverage it.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`http://`方案发送消息，并且其接收到的第一行字节包含这些详细信息，消费应用会简单地响应一个`401 - Bad Request`状态。它无法解析头部的信息，因为它没有进行解析的正确上下文。这就是方案为远程主机提供的内容：解析其消息的初始上下文。因此，定义一个与其他自定义协议或方案（当然也与任何标准化协议，如HTTP或FTP）不同的唯一方案非常重要。你的方案需要具有唯一可识别性，以确保在任何使用它的主机上都不会出现解析消息失败的情况。
- en: Implementing your protocol interactions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现你的协议交互
- en: As I've alluded to at least a few times in this section, your first task for
    implementing your protocol as a pluggable protocol is to encapsulate its interactions
    into the most basic request/response pattern. You'll need to do this inside a
    class that defines itself as a sub-class of the `WebRequest` base class. Within
    this sub-class, your first order of business will be to override the `GetResponse()`
    and `GetResponseAsync()` methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节中至少提到过几次的那样，将你的协议作为可插拔协议实现的第一项任务是将其交互封装到最基本的请求/响应模式中。你需要在定义自身为`WebRequest`基类子类的类内部完成这项工作。在这个子类中，你的首要任务是覆盖`GetResponse()`和`GetResponseAsync()`方法。
- en: These methods are where you'll be defining any protocol-specific interactions
    for your custom `WebRequest`, including defining the transport layer over which
    your messages will be sent, and any protocol header parsing that should happen
    prior to your clients receiving the response stream. When you intend to create
    a sub-class of the `WebRequest` object, writing your own implementations of these
    classes is the minimum required step you'll need to take in order to write a conventional
    pluggable protocol.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是你定义任何自定义`WebRequest`特定交互的地方，包括定义消息发送的传输层，以及客户端接收到响应流之前应该发生的任何协议头部解析。当你打算创建`WebRequest`对象的子类时，编写这些类的自己的实现是你需要采取的最小步骤，以便编写传统的可插拔协议。
- en: If your protocol specification has any additional features or aspects that you
    need to account for, such as authentication mechanisms, or response caching, you'll
    need to override those aspects of the `WebRequest` class as well. Additionally,
    anything that isn't captured by the public interface of the `WebRequest` class
    that is specific to your protocol will need to be exposed through some methods
    or properties that are specific to your protocol.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的协议规范有任何额外的功能或方面需要考虑，例如认证机制或响应缓存，你还需要覆盖`WebRequest`类的这些方面。此外，任何不属于`WebRequest`类公共接口、特定于你的协议的内容，都需要通过一些特定于你的协议的方法或属性来暴露。
- en: Registering your schema
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册你的方案
- en: Now that you understand how we can distinguish incoming messages from our protocol
    from those of other application-layer protocols, you'll need to notify your application
    context to do so. Once you've defined your schema, you can register a handler
    with the `WebRequest` class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何区分来自我们协议的消息与其他应用层协议的消息，你需要通知应用程序上下文这样做。一旦你定义了你的方案，你就可以通过`WebRequest`类注册一个处理程序。
- en: You might remember from [Chapter 5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)*,
    Generating Network Requests in C#*, in the *The Sub-Classes of WebRequest *section,
    I mentioned that the `WebRequest` create method will provide default sub-class
    implementations for a request based on its specified schema. So, if you were to
    call `WebRequest.Create("http://somedomain.com")`, the `WebRequest` instance returned
    to you would be an instance of the `HttpWebRequest` type (though, as we already
    saw in that section, and throughout all of [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml),* HTTP
    in .NET*, the `HttpWebRequest` class should be considered obsolete at this point).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在[第5章](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)*，在C#中生成网络请求*中，在*WebRequest的子类*部分，我提到`WebRequest`的创建方法将为基于其指定方案的请求提供默认的子类实现。所以，如果你调用`WebRequest.Create("http://somedomain.com")`，返回给你的`WebRequest`实例将是`HttpWebRequest`类型的实例（尽管，正如我们在该节中以及在整个[第9章](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)，*在.NET中的HTTP*中已经看到的，到这一点上，`HttpWebRequest`类应该被认为是过时的）。
- en: By registering our custom sub-class of the `WebRequest` class, and specifying
    the schema for which it should be used, we can get that same behavior. Users wouldn't
    need to create a specific instance of our class to use it; they could just call
    `WebRequest.Create(<url>)` and pass in a URL whose schema segment identifies our
    protocol. At that point, the `WebRequest` class simply returns an instance of
    whatever class we've specified to handle that schema.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注册我们自定义的`WebRequest`类子类，并指定它应该使用的方案，我们可以获得相同的行为。用户不需要创建我们类的特定实例来使用它；他们可以直接调用`WebRequest.Create(<url>)`并传入一个URL，其方案部分标识我们的协议。到那时，`WebRequest`类只是简单地返回一个我们指定的、用于处理该方案的类的实例。
- en: Now that we know what it takes to implement and incorporate a pluggable protocol
    in our .NET Core apps, it's time to see it in action.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了在.NET Core应用中实现和集成可插拔协议所需的内容，是时候看到它实际应用了。
- en: Building our custom subclasses
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的自定义子类
- en: The first thing we'll want to do is define the interaction mechanisms for our
    custom protocol. These interactions will be how we distinguish our protocol from
    alternative application-layer protocols. You might recall when I said in [Chapter
    10](ec99753c-1004-4a9f-b651-8d4bb467a879.xhtml), *FTP and SMTP*, that each application-layer
    protocol is designed to optimize a specific business-layer application task. This
    principle should hold true with any custom protocols you've implemented as well.
    To that end, we'll define our protocol to meet a very specific business need.
    Of course, since this is still entirely for demonstration purposes, we won't concern
    ourselves with whether or not it's the most optimum design for our business need,
    but only that it is well-defined in its interactions. Once we have that in place,
    we can implement that specification within our `WebRequest` sub-class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是定义我们自定义协议的交互机制。这些交互将是我们区分我们的协议与其他应用层协议的方式。你可能还记得我在[第10章](ec99753c-1004-4a9f-b651-8d4bb467a879.xhtml)中提到的*FTP和SMTP*，每个应用层协议都是设计来优化特定业务层应用任务的。这个原则也适用于你实现的任何自定义协议。为此，我们将定义我们的协议以满足一个非常具体的业务需求。当然，由于这完全是出于演示目的，我们不会关心它是否是我们业务需求的最优设计，但只关心它在交互中是否定义良好。一旦我们有了这个基础，我们就可以在我们的`WebRequest`子类中实现这个规范。
- en: Defining our protocol
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的协议
- en: For the demonstrations in this chapter, we'll be using a new protocol optimized
    for sending a list of records to a database server. Because we can call our protocol
    whatever we want, and I find it amusing to do so, we'll call it the **DwayneTheRockJohnson**
    protocol, or just the **Rock** protocol for short, and it will use `dtrj://` as
    its schema specification in request URIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的演示中，我们将使用一个针对向数据库服务器发送记录列表进行优化的新协议。因为我们可以随意命名我们的协议，而且我觉得这样做很有趣，所以我们将它称为**DwayneTheRockJohnson**协议，或者简称为**Rock**协议，它将在请求URI中使用`dtrj://`作为其方案指定。
- en: 'Request messages in our protocol will be sent, targeting a specific table in
    a database, and will have a body consisting of an arbitrary number of updates
    to make to that table. We''ll define three verbs for requests in our protocol:
    DELETE, INSERT, and UPDATE. A request message that''s sent with any given verb
    can only perform the specified update on the table, and the records in the body
    will consist of an array of pipe-delimited fields. For our purposes, our message
    header will consist of pipe-delimited fields in the following format:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的协议中，请求消息将针对数据库中的特定表发送，其正文将包含对那个表进行任意数量更新的更新。我们将为我们的协议中的请求定义三个动词：DELETE，INSERT和UPDATE。带有任何给定动词的请求消息只能对表执行指定的更新，正文中的记录将是一个以管道符分隔的字段数组。为了我们的目的，我们的消息头部将包含以下格式的管道符分隔字段：
- en: '**VERB**: A 2-bit verb indicator: `00 = DELETE`, `01 = INSERT`, `10 = UPDATE`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VERB**：一个2位动词指示器：`00 = DELETE`，`01 = INSERT`，`10 = UPDATE`。'
- en: '**SIZE**: A 30-bit field indicating the total size of the message, including
    all header values, in bytes (providing for a maximum size of 134 MB messages).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIZE**：一个30位字段，表示包括所有头部值在内的消息总大小，以字节为单位（提供最大134 MB的消息大小）。'
- en: '**FIELDS**: A 28-byte field indicating how many fields are in each record,
    allowing for a maximum field count greater than could ever possible be reached
    by any existing database system. We''re only choosing that for a consistent alignment
    of our headers against the typical word length of 16 bits.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIELDS**：一个28字节的字段，表示每条记录中有多少字段，允许的最大字段数大于任何现有数据库系统可能达到的。我们之所以选择这个，是为了使我们的头部与典型的16位字长保持一致的对齐。'
- en: '**CHECKSUM**: A 32-byte secure hash of the message body, to prevent tampering.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CHECKSUM**：消息正文的32字节安全哈希，以防止篡改。'
- en: 'After this 64-byte header, the rest of the body is presumed to be a sequence
    of pipe-delimited records, which our target hosts will be able to parse based
    on the **FIELDS** value of the header, and the convention of the pipe-delimiter.
    Taken together, the structure of our Rock message will look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个64字节的头部之后，其余的正文假定是一系列以管道符分隔的记录，我们的目标主机将能够根据头部中的**FIELDS**值和管道符分隔的约定来解析这些记录。综合来看，我们的Rock消息的结构将如下所示：
- en: '![](img/3f082c2e-ff16-48df-a395-9229e177fb03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f082c2e-ff16-48df-a395-9229e177fb03.png)'
- en: 'When a server has successfully received a message, its response, assuming everything
    was processed accordingly, will include the following headers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器成功接收到一条消息时，其响应（假设一切处理得当），将包括以下头部：
- en: '**STATUS**: A 2-bit message indicating the success of the update attempt against
    the data source: `00 = SUCCESS`, `01 = PARTIAL SUCCESS`, and `10 = FAILURE`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STATUS**：一个2位消息，表示对数据源更新尝试的成功情况：`00 = SUCCESS`，`01 = PARTIAL SUCCESS`，和`10
    = FAILURE`'
- en: '**TIMESTAMP**: A 14-bit timestamp indicating when the updates were successfully
    committed to the database'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TIMESTAMP**：一个14位时间戳，表示更新成功提交到数据库的时间'
- en: '**SIZE**: A 16-bit field indicating the size of the message included, along
    with the rest of the response'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIZE**：一个16位字段，表示包含在消息中的大小，包括所有头部值，以字节为单位（提供最大134 MB的消息大小）。'
- en: 'This 32-bit header will be followed by any status message that''s included
    along with the status code provided in the header, which may include information
    about which records were successfully updated, or why some or all records failed
    to update. With this, our response will look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个32位头部将跟随任何包含在头部中的状态消息，以及头部中提供的状态代码，这可能包括有关哪些记录成功更新或为什么某些或所有记录未能更新的信息。有了这个，我们的响应将如下所示：
- en: '![](img/0bcb8e7a-4767-4a07-991d-5b5a55766edd.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bcb8e7a-4767-4a07-991d-5b5a55766edd.png)'
- en: There would obviously be a lot more thought to defining a communication protocol
    than what we've put forth here, but this will be sufficient for the purposes of
    learning how to implement them in our .NET Core projects. So, now that we know
    what our schema definition will look like, and how our protocols should be composed
    and parsed, let's get to work defining our `WebRequest` sub-class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在定义一个通信协议时，需要考虑的不仅仅是这里所提出的，但这对我们在.NET Core项目中实现它们已经足够了。因此，既然我们已经知道了我们的模式定义将是什么样子，以及我们的协议应该如何组成和解析，那么我们就开始定义我们的`WebRequest`子类。
- en: Implementing our protocol
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的协议
- en: 'Our first order of business will be creating a `WebRequest` subclass with a
    constructor that accepts a `URI` instance, or a simple URI string as its input.
    This is what''s used by the `WebRequest.Create()` method to instantiate our specific
    class whenever it is given a URI with our schema. We''ll be implementing this
    class in a simple console app, so first create your application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是创建一个具有接受 `URI` 实例或简单 URI 字符串作为输入的构造函数的 `WebRequest` 子类。这是 `WebRequest.Create()`
    方法在给定具有我们方案的 URI 时用来实例化我们的特定类的。我们将在一个简单的控制台应用程序中实现这个类，所以首先创建你的应用程序：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, create a class for our `WebRequest` subclass, and define its constructors.
    For this example, I''ll be creating a `RockWebRequest` class, with a constructor being
    used to set the `URI` instance that''s used when sending our request out to the
    target host:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个用于我们的 `WebRequest` 子类的类，并定义其构造函数。在这个例子中，我将创建一个 `RockWebRequest` 类，其构造函数用于设置用于向目标主机发送请求时使用的
    `URI` 实例：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, it's important to note that a `WebRequest` instance (or an instance of
    any of its subclasses) is intended to only ever be used once. Subsequent requests
    require additional instances of the class. This is why the `RequestUri` field
    (which is derived from the parent class, but must be implemented by our subclass
    to be used) is read-only and only ever written to upon initialization of a new
    instance. It won't, and shouldn't, change after the request is created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重要的是要注意，`WebRequest` 实例（或其任何子类的实例）旨在仅使用一次。后续请求需要额外的类实例。这就是为什么 `RequestUri`
    字段（它从父类派生，但必须由我们的子类实现才能使用）是只读的，并且仅在初始化新实例时写入。它不会，也不应该，在请求创建后改变。
- en: 'The next thing we''ll need to do is give users of our `WebRequest` class a
    mechanism by which they can define the records being sent over, as well as the
    message verb to be used on those records. This will give our users an opportunity
    to configure their message accordingly, prior to requesting a response. To do
    this, we''ll define a couple of properties for our header and for our request
    body. We could use the `Method` property that is derived from the `WebRequest`
    class to define our message verb, but I''d prefer to enforce things a little more
    strictly in our component. We''ll create a new property, whose type will be an
    `enum` that defines our three possible verbs. Using an `enum` will also give us
    the benefit of mapping the user-provided value to its underlying 2-bit representation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要为我们的 `WebRequest` 类的用户提供一个机制，使他们能够定义要发送的记录以及那些记录上要使用的信息动词。这将使用户有机会在请求响应之前相应地配置他们的消息。为此，我们将为我们的报头和请求体定义几个属性。我们可以使用从
    `WebRequest` 类派生的 `Method` 属性来定义我们的信息动词，但我更愿意在我们的组件中强制执行得更严格一些。我们将创建一个新的属性，其类型将是一个
    `enum`，用于定义我们的三个可能的动词。使用 `enum` 也将给我们带来将用户提供的值映射到其底层 2 位表示的优点：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we're representing our 2-bit codes as the most significant bits of a 32-bit
    integer value to make it especially easy to perform a bit-wise `OR` operation
    with our `size` header value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用 32 位整数的最高有效位来表示我们的 2 位代码，以便特别容易与我们的 `size` 报头值执行位运算 `OR`。
- en: 'Next, we''ll define the corresponding property on our `RockWebRequest`. Additionally,
    we''ll define an `IEnumerable` for the records that will be sent in any given
    request, with an `int` to store the number of fields in each record. Since we
    want our protocol to handle arbitrary record definitions, but we don''t want to
    spend too much time writing sufficient serialization code and generic object parsers,
    we''ll just define our records to be strings, and leave it to a consumer to generate
    a pipe-delimited format for their record list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的 `RockWebRequest` 上定义相应的属性。此外，我们还将定义一个 `IEnumerable` 用于任何给定请求中要发送的记录，以及一个
    `int` 用于存储每条记录中的字段数。由于我们希望我们的协议能够处理任意的记录定义，但又不想花费太多时间编写足够的序列化代码和泛型对象解析器，因此我们将定义我们的记录为字符串，并让消费者为他们的记录列表生成一个管道分隔的格式：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we'll default our `Verb` to `Insert`. For the purposes of this demonstration,
    we'll say that `Update` operations will only work if and only if there isn't an
    existing record with same the key as the record to be inserted. With this rule
    in place, `Insert` is the only operation that is safe to perform, since it can't
    ever incidentally override existing data. Given that, it will suit us well for
    our default `Verb` value. Once this is in place, however, we're ready to implement
    our `GetResponse()` and `GetResponseAsync()` methods. Each other property of our
    header can be derived without input from the user, so we'll do so in these methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将默认我们的`Verb`为`Insert`。为了演示的目的，我们将说`Update`操作只有在没有与要插入的记录具有相同键的现有记录时才会工作。有了这个规则，`Insert`是唯一安全执行的操作，因为它永远不会意外地覆盖现有数据。鉴于这一点，它非常适合我们的默认`Verb`值。然而，一旦这个值就位，我们就准备好实现我们的`GetResponse()`和`GetResponseAsync()`方法。我们的头部的其他属性可以在不使用用户输入的情况下推导出来，因此我们将在这两个方法中这样做。
- en: Implementing the request pipeline
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现请求管道
- en: The next, and final, step to implement our pluggable protocol is to define the
    request and response behavior for our messages. We'll start by overriding the
    synchronous `GetResponse()` method. This method will be responsible for building
    a byte stream with the appropriate values for our header specification, and submitting
    over the transport protocol of our choice. For this demo, we'll be using TCP,
    since we've already seen how to do so in [Chapter 11](a4847953-41ef-48ee-aa39-75f920467992.xhtml),* The
    Transport Layer – TCP, UDP, and Multicasting*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的可插拔协议的下一步，也是最后一步，是为我们的消息定义请求和响应行为。我们将首先重写同步的`GetResponse()`方法。此方法将负责构建具有适当值的字节流，以符合我们的头规范，并通过我们选择的传输协议提交。对于这个演示，我们将使用TCP，因为我们已经在[第11章](a4847953-41ef-48ee-aa39-75f920467992.xhtml)，“传输层
    – TCP、UDP和多播”中看到了如何这样做。
- en: Always put as much consideration and thought as you can into deciding what transport-layer
    protocol you'll use to support any custom application layer protocols you may
    write. The performance and specific use cases of any transport layer protocol
    can have as much of an impact on the performance of your custom protocol as any
    other aspect of your design. Always try to use the right tool for the job at hand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用哪种传输层协议来支持您可能编写的任何自定义应用层协议时，请尽可能多地考虑和思考。任何传输层协议的性能和特定用例都可能对您自定义协议的性能产生与设计中的任何其他方面一样大的影响。始终尝试使用适合手头工作的正确工具。
- en: As with all of our demonstrations, we'll be assuming that consumers of our software
    always use it appropriately, and so we'll forego any sort of pre-request validations.
    We'll just assume that we have some records configured for our message body, and
    that our verb has been defined appropriately.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有的演示一样，我们将假设我们的软件的消费者始终适当地使用它，因此我们将放弃任何请求前的验证。我们只假设我们为消息体配置了一些记录，并且我们的动词已经适当地定义。
- en: At this point, it would serve us well to examine the high-level workflow of
    building and sending a message according to our protocol. Since we're assuming
    that we have records available prior to attempting to send a request (and that
    our server will assume the responsibility of validating our data), we'll build
    out our message body by concatenating each record (which our users have already
    conveniently serialized into pipe-delimited strings of all fields in each record),
    and separate each record with a pipe. Next, we'll convert the concatenated string
    into a byte array. From that, we'll build our checksum hash, as well as define
    the size of our message. Then, we'll build a completed byte array with our headers
    and message body, and write them to a `TcpClient` stream targeting the designated
    host URI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，根据我们的协议检查构建和发送消息的高级工作流程对我们来说将大有裨益。由于我们假设在尝试发送请求之前我们有记录可用（并且我们的服务器将承担验证我们数据的责任），我们将通过连接每个记录（我们的用户已经方便地将每个记录的所有字段序列化为以管道分隔的字符串）来构建我们的消息体，并且用管道分隔每个记录。接下来，我们将连接的字符串转换为字节数组。从那里，我们将构建我们的校验和哈希，以及定义我们的消息大小。然后，我们将构建包含我们的头和消息体的完整字节数组，并将它们写入针对指定主机URI的`TcpClient`流。
- en: 'Putting that into action, we''ll start by generating our message byte array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将其付诸实践，我们首先生成我们的消息字节数组：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following code, the actual concatenation happens in a separate, private
    method, to aid the readability of our code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，实际的连接操作发生在单独的私有方法中，以帮助提高我们代码的可读性：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we're using the same pipe delimiter between records that we're
    using to separate fields in a record. We have the freedom to do this because our
    `fields` header notifies the server of how many individual fields should be parsed
    per-record. Using the same delimiter for records that we're using for fields saves
    the server from having to look for an exceptional case for the end of a record.
    It can simply look for the next instance of the delimiter character and proceed
    accordingly, starting a new record when the field count has been reached for the
    previous one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用与我们在记录中分隔字段相同的管道分隔符来分隔记录。我们有这样的自由，因为我们的`fields`报头通知服务器每条记录应解析多少个单独的字段。使用与字段相同的分隔符来记录可以节省服务器寻找记录结束的异常情况。它只需查找分隔符字符的下一个实例，并据此进行操作，当上一个记录的字段计数达到时，开始新的记录。
- en: 'Next, we''ll compute our checksum based on our requests'' body content. If
    you were truly defining your own protocol for a business purpose, you would likely
    allow clients to specify hashing algorithms from among those they have implementations
    for. However, for our purposes, we''ll just say it''s always going to be computed
    using SHA-256\. Once we''ve computed our hash, we can set our `VERB` bits based
    on the value provided by the client. Next, we''ll determine the size of our packet
    (the 64 byte header, plus the length of our message byte array), and write all
    of our bytes to a binary stream. In our `GetResponse()` method, that will simply
    read as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据我们的请求体内容计算校验和。如果你真正定义了自己的协议用于商业目的，你可能会允许客户端从他们有实现的哈希算法中选择。然而，对于我们来说，我们只需说它总是使用SHA-256进行计算。一旦我们计算出了哈希值，我们就可以根据客户端提供的值设置我们的`VERB`位。接下来，我们将确定我们的数据包大小（64字节头加上我们的消息字节数组的长度），并将所有字节写入二进制流。在我们的`GetResponse()`方法中，这简单地如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `GetHeaderBytes(message.Length)` method is used to convert the binary value
    of our `Verb`, the given message size, and the `Fields` property, into the 32-byte
    header that precedes the 32 byte checksum. The method is relatively straightforward
    and merely applies some bit-manipulation of the appropriate values, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHeaderBytes(message.Length)`方法用于将我们的`Verb`的二元值、给定消息的大小和`Fields`属性转换为32字节头，该头位于32字节校验和之前。该方法相对简单，只是对适当的值应用了一些位操作，如下所示：'
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once that header value is computed, we can apply it, followed by the checksum,
    followed by the byte array of our request message, to our output byte stream.
    Finally, since we''ve declared that our protocol will use TCP as its underlying
    transport mechanism, we''ll create our `TcpClient` instance, connecting to the
    host and port specified by the `RequestUri` field. Once again, we''ll be making
    a lot of assumptions about our ability to connect to the specified URI. In realistic
    circumstances, you''d be implementing your `TcpClient` connections with more robust
    error handling and connection validation, as we did in [Chapter 11](a4847953-41ef-48ee-aa39-75f920467992.xhtml),
    *The Transport Layer - TCP and UDP*. For now, though, we''ll simply assume our
    connection succeeded, write our bytes to our `NetworkStream` instance, and then
    pass it along to our `RockWebResponse` instance, which we''ll return from our
    method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出了该报头值，我们就可以将其应用于输出字节流，随后是校验和，然后是我们的请求消息的字节数组。最后，由于我们已经声明我们的协议将使用TCP作为其底层传输机制，我们将创建我们的`TcpClient`实例，连接到由`RequestUri`字段指定的主机和端口。再次强调，我们将对能够连接到指定的URI做出很多假设。在现实情况下，你将实现你的`TcpClient`连接，并具有更健壮的错误处理和连接验证，正如我们在第11章中所述，*传输层
    - TCP和UDP*。然而，现在，我们只需假设我们的连接成功，将我们的字节写入我们的`NetworkStream`实例，然后将它传递给我们的`RockWebResponse`实例，并从我们的方法中返回它：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This completes our implementation of the `GetResponse()` method. Obviously,
    implementing the `GetResponseAsync()` method will look extremely similar in practice,
    but we will use the asynchronous programming patterns we established in [Chapter
    6](b5d28c0a-6e7c-4547-855d-e6c6d1842bd6.xhtml),* Streams, Threads, and Asynchronous
    Data Transfer*. I'll leave it as an exercise for you to implement that specific
    method in our `RockWebRequest` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`GetResponse()`方法的实现。显然，在实践上实现`GetResponseAsync()`方法将看起来非常相似，但我们将使用我们在第6章中建立的异步编程模式，*流、线程和异步数据传输*。我将把它留给你作为练习，在我们的`RockWebRequest`类中实现这个特定的方法。
- en: Deriving from the WebResponse class
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`WebResponse`类派生
- en: As you may have noticed, the `GetResponse()` method of our `RockWebRequest`
    returns an instance of a `RockWebResponse` class. This is the other side of the
    implementation coin for writing a pluggable protocol. You have to define a handler
    that can strip away and validate any protocol specific meta-data or header information
    from the response stream and store them in read-only properties in your custom
    `WebResponse` class, prior to returning the response stream back to the method
    that invoked it. One of the key benefits users will expect from your pluggable
    protocols is that they will abstract away all of the details of parsing and manipulating
    that protocol-specific information out of the response byte stream.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们的 `RockWebRequest` 的 `GetResponse()` 方法返回一个 `RockWebResponse` 类的实例。这是编写可插拔协议的实现硬币的另一面。您必须定义一个处理程序，可以从响应流中剥离和验证任何特定于协议的元数据或头信息，并将它们存储在您自定义的
    `WebResponse` 类的只读属性中，然后再将响应流返回给调用它的方法。用户期望从您的可插拔协议中获得的一个关键好处是，它们将抽象出从响应字节流中解析和操作特定于协议信息的所有细节。
- en: 'Our implementation for this demo will be extremely simple. We''re only seeking
    to illustrate the conceptual steps you''ll need to take if you undertake this
    task in the future. However, because of the highly specific nature of a pluggable
    protocol, anything more than that high-level, conceptual approach would ultimately
    prove futile. Given that, our full `RockWebResponse` class is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此演示的实施方案将非常简单。我们只是试图说明如果你未来承担这个任务时需要采取的概念性步骤。然而，由于可插拔协议的高度特定性，任何超出这一高级概念性方法的内容最终都将证明是徒劳的。鉴于这一点，我们的完整
    `RockWebResponse` 类如下所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we do is define public properties for each of the relevant header
    values that a user might be concerned with. Here, we've defined a simple `RockStatus`
    enum to capture our three possible status states, and we represent the timestamp
    header value as `DateTime`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了用户可能关心的每个相关头值的公共属性。在这里，我们定义了一个简单的 `RockStatus` 枚举来捕获我们三种可能的状态，并将时间戳头值表示为
    `DateTime`。
- en: The crux of the class definition is in the constructor for it. Here, our `RockWebResponse`
    instance is responsible for parsing the header values out of the response stream,
    and populating its instance properties with their corresponding values. Note that
    we read the first 4 bytes from the stream, which corresponds to our 32-bit header
    definition. Once that's done, we pass the byte array along to our header validation
    function, and return our new instance (of course, in production code, you would
    throw an error on validation failure, instead of returning a new instance). Since
    we've read the header information out of our response stream prior to returning
    an instance to our consumers, the call to `GetResponseStream()` will return a
    stream containing only the response body.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的核心在于其构造函数。在这里，我们的 `RockWebResponse` 实例负责从响应流中解析头值，并用它们对应的值填充其实例属性。请注意，我们从流中读取了前4个字节，这对应于我们的32位头定义。一旦完成，我们就将字节数组传递给我们的头验证函数，并返回我们的新实例（当然，在生产代码中，您会在验证失败时抛出错误，而不是返回一个新实例）。由于我们在将实例返回给消费者之前已经从响应流中读取了头信息，因此对
    `GetResponseStream()` 的调用将返回只包含响应体的流。
- en: By defining this protocol-specific response handler, we've (conceptually) completed
    our pluggable protocol implementation. There are a number of other methods you'll
    have to override if you truly want to create a valid subclass of `WebRequest`,
    and there is substantial information in the Microsoft documentation on specifically
    what is required. However, following the model we've established here, you should
    be in the right mindset to tackle those tasks when it becomes necessary to do
    so. At this point, the only thing left for us to do is expose it to other engineers
    through the `WebRequest` factory methods, which we'll look at in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义这个特定于协议的响应处理程序，我们（在概念上）完成了可插拔协议的实现。如果您真正想要创建一个有效的 `WebRequest` 子类，您还必须重写许多其他方法，并且微软文档中有大量关于具体需要什么的信息。然而，按照我们在这里建立的模式，当需要这样做时，您应该处于正确的思维状态来处理这些任务。到目前为止，我们唯一剩下的事情就是通过
    `WebRequest` 工厂方法将其暴露给其他工程师，我们将在下一节中探讨这一点。
- en: Leveraging a custom protocol
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用自定义协议
- en: Defining our pluggable protocol is really about defining the protocol-specific
    interactions of our custom protocol in the context of the `WebRequest` and `WebResponse`
    paradigms. Now that we've done that, though, we have to notify the `WebRequest`
    class that we've satisfied the requirements for use by any consumers seeking to
    use our schema. That means we'll need to define a factory class that creates instances
    of our derived classes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们的可插拔协议实际上是在`WebRequest`和`WebResponse`范式下定义我们自定义协议的特定交互。现在我们已经做到了这一点，但我们必须通知`WebRequest`类我们已经满足了任何寻求使用我们方案的消费者使用的要求。这意味着我们需要定义一个工厂类来创建我们派生类的实例。
- en: Implementing the IWebRequestCreate interface
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`IWebRequestCreate`接口
- en: We want to register our class with the `WebRequest` class so that instances
    of `RockWebRequest` will be returned when the `WebRequest.Create(<uri>)` method
    is called with the appropriate schema. To do that, though, we'll need to provide
    `WebRequest` with a factory class that can build well-formed instances of our
    `RockWebRequest` class on demand. This behavior is defined by the `IWebRequestCreate`
    interface, and that's the interface we'll need to implement in our factory class
    to register it for use with `WebRequest`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的类与`WebRequest`类注册，以便当使用适当的方案调用`WebRequest.Create(<uri>)`方法时，返回`RockWebRequest`的实例。然而，为了做到这一点，我们需要向`WebRequest`提供一个工厂类，该类可以按需构建我们`RockWebRequest`类的良好格式实例。这种行为由`IWebRequestCreate`接口定义，这就是我们需要在我们的工厂类中实现以注册其与`WebRequest`一起使用的接口。
- en: 'The footprint of this interface is, thankfully, extremely simple. In fact,
    it''s only one method. Our whole implementation is fewer than a dozen lines long:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的足迹，幸运的是，极其简单。实际上，它只有一个方法。我们整个实现不到一打行代码：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this, though, we can register our custom protocol class for use whenever
    our schema shows up in a URI given to the `WebRequest.Create(<uri>)` method. Simply
    invoke the `RegisterPrefix()` method in the startup of your application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以将我们的自定义协议类注册为在`WebRequest.Create(<uri>)`方法中给出的URI中出现我们的方案时使用。只需在应用程序启动时调用`RegisterPrefix()`方法即可：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, your custom `WebRequest` class will be freely available to respond to URIs
    with the designated schema.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的自定义`WebRequest`类将可以自由地响应具有指定方案的URI。
- en: Going beyond WebRequest
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越`WebRequest`
- en: At the time of writing this book, the Microsoft documentation for the `WebRequest`
    class explicitly advises against using `WebRequest` or any of its subclasses.
    The recommendation is for developers writing new software to instead use `HttpClient`,
    or similar classes. So, what does that mean for the value or use of pluggable
    protocols?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Microsoft对`WebRequest`类的文档明确建议不要使用`WebRequest`或其任何子类。建议开发人员编写新软件时使用`HttpClient`或类似类。那么，这对可插拔协议的价值或用途意味着什么呢？
- en: Simply put, it means your work isn't done quite yet. As I mentioned in [Chapter
    5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml), *Generating Network Requests in
    C#*, the `WebRequest` and `WebResponse` classes still operate, in some form or
    other, under the hood of the `HttpClient` class. Defining your protocol interactions
    through these classes is still very much an essential part of implementing custom
    protocols in .NET Core. Deriving from these classes gives you the flexibility
    to parse and process application headers directly out of the `NetworkStream` of
    whichever transport protocol you choose to use. In fact, even the ability to specify
    your transport protocol is something that cannot be done with the `HttpClient`
    class. This sort of control over your raw protocol requests can only be leveraged
    with something such as `WebRequest` or `WebResponse`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着你的工作还没有完全完成。正如我在[第五章](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)中提到的，*在C#中生成网络请求*，`WebRequest`和`WebResponse`类仍然以某种形式在`HttpClient`类的底层运行。通过这些类定义你的协议交互仍然是实现.NET
    Core中自定义协议的一个基本部分。从这些类派生出来为你提供了直接解析和处理你选择的任何传输协议的`NetworkStream`中的应用头部的灵活性。实际上，甚至指定你的传输协议这样的功能也无法使用`HttpClient`类来实现。这种对你原始协议请求的控制只能通过像`WebRequest`或`WebResponse`这样的工具来实现。
- en: However, as new developers consistently move away from the conventions of `WebRequest`
    and `WebResponse`, you'll need to define more modern abstractions to keep your
    protocol library relevant. To that end, if you find yourself needing to define
    custom protocol interactions, consider defining a standardized client implementation
    instead. Your client can (and perhaps *should*) continue to leverage a pluggable
    protocol derived from the `WebRequest` and `WebResponse` classes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着新开发者持续地远离`WebRequest`和`WebResponse`的约定，你需要定义更多现代的抽象来保持你的协议库的相关性。为此，如果你发现自己需要定义自定义协议交互，考虑定义一个标准化的客户端实现。你的客户端可以（也许*应该*）继续利用从`WebRequest`和`WebResponse`类派生的可插拔协议。
- en: However, by defining a clean abstraction for working with those requests and
    responses, you present an easier-to-use, and easier-to-understand, tool for your
    library's users. If and when you find yourself writing any custom communication
    protocols, keep this in mind if you want to see it adopted by a wider audience
    in the .NET community.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过为处理这些请求和响应定义一个干净的抽象，你为你的库用户提供了一个更容易使用、更容易理解的工具。如果你发现自己正在编写任何自定义通信协议，如果你想看到它在.NET社区中得到更广泛的采用，请记住这一点。
- en: With that, we can wrap up our discussion of pluggable protocols. In the next
    chapter, we'll continue down the path of advanced, lower-level subjects. There,
    we'll explore network analysis and packet sniffing strategies for a deeper understanding
    of the wider context your network software exists within.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以结束对可插拔协议的讨论。在下一章中，我们将继续探讨高级、低级主题。在那里，我们将探讨网络分析和数据包嗅探策略，以更深入地了解你的网络软件存在的更广泛环境。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took an extremely in-depth look at the very narrow topic of pluggable
    protocols in .NET Core. We learned that a pluggable protocol is really just an
    in-framework representation of any custom, application-layer communication protocol
    you want to define. As we established this understanding, we considered why we
    should take the time to implement new communication protocols as pluggable protocols
    in our code. We saw how the alternative—using custom, protocol-specific code throughout
    our application—introduced a time and productivity cost that could be all but
    eliminated by simply implementing custom subclasses of the `WebRequest` and `WebResponse`
    classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了.NET Core中可插拔协议的非常狭窄的主题。我们了解到，可插拔协议实际上只是任何你想要定义的自定义应用层通信协议在框架中的表示。在我们建立这种理解的基础上，我们考虑了为什么我们应该花时间在我们的代码中将新的通信协议实现为可插拔协议。我们看到了另一种选择——在我们的整个应用程序中使用自定义、特定协议的代码——引入了时间和生产力成本，这可以通过简单地实现`WebRequest`和`WebResponse`类的自定义子类来几乎完全消除。
- en: After we established the case for *using* pluggable protocols, we looked at
    *how* we could do so in our own projects. We learned about the three core steps
    we would have to follow to implement a pluggable protocol. As we did, we learned
    how each step served to create a clean, convention-based abstraction for our custom
    protocols. Finally, we looked at how to implement the different protocols in our
    software. We designed our own test protocol, and then took the necessary steps
    to implement `WebRequest` and `WebResponse` subclasses that handled interactions
    for that test protocol.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确立了使用可插拔协议的理由之后，我们研究了在我们的项目中如何实现这一点。我们了解了实现可插拔协议必须遵循的三个核心步骤。在我们这样做的时候，我们了解到每个步骤都服务于创建我们自定义协议的干净、基于约定的抽象。最后，我们研究了如何在我们的软件中实现不同的协议。我们设计了自己的测试协议，然后采取了必要的步骤来实现处理该测试协议交互的`WebRequest`和`WebResponse`子类。
- en: Finally, we looked at how to incorporate our new classes directly into the `WebRequest`
    and `WebResponse` framework for a seamless transition for new developers, who
    may want to take advantage of our work. As we wrapped up, we learned about the
    next steps we should take to stay consistent with more modern patterns of abstracting
    interactions behind protocol-specific `Client` classes. In the next chapter, we'll
    be looking at how we can analyze the state of network interfaces and network traffic
    on our host machines, and what sort of applications that capability opens up for
    us.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何将我们的新类直接集成到`WebRequest`和`WebResponse`框架中，以便为新开发者提供一个无缝的过渡，他们可能想利用我们的工作。在我们结束的时候，我们了解了我们应该采取的下一步，以保持与更现代的抽象模式的一致性，即在特定协议的`Client`类后面抽象交互。在下一章中，我们将探讨如何分析我们宿主机的网络接口和网络流量状态，以及这种能力为我们打开了哪些类型的应用程序。
- en: Questions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a pluggable protocol?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是可插拔协议？
- en: What are the advantages of implementing a protocol as a pluggable protocol?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将协议实现为可插拔协议有哪些优势？
- en: What steps are necessary for building a pluggable protocol in .NET Core?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Core中构建可插拔协议需要哪些步骤？
- en: Why is accurate schema definition important for a listening server to process
    a request?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么精确的架构定义对于监听服务器处理请求很重要？
- en: What is the minimum footprint of `WebRequest` methods you'll have to override
    to implement a pluggable protocol?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要覆盖`WebRequest`方法的最低占用空间是多少来实现可插拔协议？
- en: What additional interface must you provide to register your pluggable protocol
    for use by the `WebRequest.Create()` method?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须提供哪些额外的接口来注册你的可插拔协议，以便由`WebRequest.Create()`方法使用？
- en: What additional steps should you take to make adoption of your pluggable protocol
    easier and more consistent with modern conventions?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该采取哪些额外步骤来使你的可插拔协议的采用更加容易且与现代惯例保持一致？
- en: Further reading
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: This being a rather niche subject in a vast framework, there isn't much to recommend
    in terms of further reading on the specific topic of pluggable protocols themselves.
    However, if you're curious to learn more about the contexts and architectures
    that might motivate the need for custom protocol implementation, I would recommend
    checking out the *Serverless Programming Cookbook* by *Heartin Kanikathottu*.
    Its discussion of various network interactions from cloud platform-hosted source
    code paints a compelling picture for new, optimized communication paradigms. It
    can be found from Packt, here: [https://www.packtpub.com/application-development/serverless-programming-cookbook](https://www.packtpub.com/application-development/serverless-programming-cookbook)[.](https://www.packtpub.com/application-development/serverless-programming-cookbook)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个在广泛框架中相对小众的主题，关于可插拔协议本身的特定主题，没有太多推荐的阅读材料。然而，如果你对可能促使需要自定义协议实现的环境和架构感兴趣，我建议查看*Heartin
    Kanikathottu*的《Serverless Programming Cookbook》。它从云平台托管源代码的各种网络交互讨论中，描绘了一个令人信服的新、优化的通信范例图景。你可以在Packt找到它：[https://www.packtpub.com/application-development/serverless-programming-cookbook](https://www.packtpub.com/application-development/serverless-programming-cookbook)[.](https://www.packtpub.com/application-development/serverless-programming-cookbook)
