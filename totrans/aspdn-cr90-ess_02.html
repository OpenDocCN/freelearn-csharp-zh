<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-31">
    <a id="_idTextAnchor031">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-32">
    <a id="_idTextAnchor032">
    </a>
    
     Building Dynamic UIs with Razor Pages, MVC, and Blazor
    
   </h1>
   <p>
    
     ASP.NET Core 9 has a complete UI framework to suit different types of approaches and applications that allow the use of page rendering strategies on both the client side and server side.
    
    
     In this chapter, we will learn about the options available in the ASP.NET Core UI framework, in addition to understanding how to define the best option for
    
    
     
      each scenario.
     
    
   </p>
   <p>
    
     Initially, we will understand some important concepts and then continue with a practical approach so that we are able to exercise the
    
    
     
      concepts learned.
     
    
   </p>
   <p>
    
     In this approach, we will initially understand what the ASP.NET Core UI framework is, learning about the different approaches to rendering applications both on the server, using Razor Pages and ASP.NET MVC, and rendering on the client, using JavaScript frameworks.
    
    
     Finally, we will understand the power of merging different technologies into a hybrid solution that uses the best of both the client and
    
    
     
      the server.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Learning about the ASP.NET
     
     
      
       Core UI
      
     
    </li>
    <li>
     
      Implementing a UI server render model with Razor Pages and
     
     
      
       ASP.NET MVC
      
     
    </li>
    <li>
     
      Exploring UI client rendering with Blazor and
     
     
      
       JavaScript frameworks
      
     
    </li>
    <li>
     
      Working with
     
     
      
       hybrid solutions
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-33">
    <a id="_idTextAnchor033">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You can find all code examples and other materials used in this chapter in the following
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials
      
     
    </a>
   </p>
   <h1 id="_idParaDest-34">
    <a id="_idTextAnchor034">
    </a>
    
     Learning about the ASP.NET Core UI
    
   </h1>
   <p>
    
     Dynamic web-based applications
    
    <a id="_idIndexMarker051">
    </a>
    
     have a flow that basically involves two
    
    <a id="_idIndexMarker052">
    </a>
    
     distinct “worlds” the frontend and the backend.
    
    
     In general, the
    
    <a id="_idIndexMarker053">
    </a>
    
     frontend deals with the mechanisms that are
    
    <a id="_idIndexMarker054">
    </a>
    
     visualized and allow interaction between users and the various functionalities proposed by the solution.
    
    
     Therefore, a frontend is made up of buttons, texts, lists, menus, images, and other aspects that together form the UI.
    
    
     The backend is the representation of the mechanisms used to allow dynamism to the frontend, according to user interaction.
    
    
     We will discuss more about backend-related aspects in
    
    <a href="B21788_03.xhtml#_idTextAnchor044">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Each of the terms expressed in the previous paragraph works in different contexts.
    
    
     The
    
    <em class="italic">
     
      frontend
     
    </em>
    
     usually runs on the client, which translates into the user’s browser.
    
    <em class="italic">
     
      Client
     
    </em>
    
     is a generic term
    
    <a id="_idIndexMarker055">
    </a>
    
     that can express other types of user interaction.
    
    
     But in this case, we will talk about the client as the browser of your choice.
    
    
     The
    
    <em class="italic">
     
      backend
     
    </em>
    
     runs on the server, whether in a data center or even a cloud provider such
    
    
     
      as Azure.
     
    
   </p>
   <p>
    
     Through user interactions in the UI, the user must communicate with the backend and subsequently be able to adapt to the server’s responses to deliver some type of response and interaction, again , to
    
    
     
      the user.
     
    
   </p>
   <p>
    
     The browser basically uses three technologies: HTML, CSS, and JavaScript.
    
    
     HTML
    
    <a id="_idIndexMarker056">
    </a>
    
     is static; that is, it is interpreted by the browser and then rendered in the form of a UI.
    
    
     CSS is
    
    <a id="_idIndexMarker057">
    </a>
    
     responsible for making visual elements more attractive, defining colors, shadows, and formatting, among other design aspects.
    
    
     JavaScript is used to make static elements dynamic, and this includes, for example, making a call to a server, and depending on the result, modifying the user’s UI to adapt to the response of the processing carried out.
    
    
     JavaScript
    
    <a id="_idIndexMarker058">
    </a>
    
     is responsible for increasing the ability of web-based applications to become dynamic and interactive.
    
    
     However, it can be complex to create and manipulate elements through JavaScript code and, in addition, to manage calls on the server.
    
    
     There are several excellent JavaScript frameworks available, such as Angular
    
    <a id="_idIndexMarker059">
    </a>
    
     or React
    
    <a id="_idIndexMarker060">
    </a>
    
     that allow you to develop richly dynamic
    
    
     
      UI solutions.
     
    
   </p>
   <p>
    
     It is essential to have knowledge of UI technologies; however, in addition, we can benefit from an integrated development model that allows us to work on both the UI and the backend in a
    
    
     
      rich way.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 has a complete UI framework to meet any UI requirement for web applications and is fully integrated with the .NET platform, using best practices for separation of responsibilities, management, and maintenance, among other important aspects.
    
    
     Despite this, ASP.NET Core
    
    <a id="_idIndexMarker061">
    </a>
    
     is not restricted to the use of the UI renderers proposed by the platform; it also integrates well with JavaScript frameworks and even allows you to use the best of the available options by adopting a
    
    
     
      hybrid approach.
     
    
   </p>
   <p>
    
     However, before we move on to a more specific understanding of the options available in ASP.NET Core 9, let’s learn about important aspects related to web
    
    
     
      systems architecture.
     
    
   </p>
   <h2 id="_idParaDest-35">
    <a id="_idTextAnchor035">
    </a>
    
     Rendering the UI
    
   </h2>
   <p>
    
     There are different approaches to
    
    <a id="_idIndexMarker062">
    </a>
    
     developing web-based solutions when it comes to the UI layer, even before talking
    
    
     
      about technologies.
     
    
   </p>
   <p>
    
     There are basically two models, client-side and server-side, with their respective pros and cons.
    
    
     There is also a third possibility, which would be to use a
    
    
     
      hybrid approach.
     
    
   </p>
   <p>
    
     In the client-side model, processing is done locally in the browser.
    
    
     In this way, all the HTML, CSS, JavaScript, and other assets are processed by the browser, responding to user stimuli.
    
    
     Interactions with users are handled locally through scripts containing UI-related logic without the need to request
    
    
     
      the server.
     
    
   </p>
   <p>
    
     However, this approach depends on server resources, such as access to data, among other things, and so it is necessary to make frequent calls to the server in order to obtain information based on the user’s needs, which is then processed and presented in
    
    
     
      the UI.
     
    
   </p>
   <p>
    
     In the server-side approach, all the processing is delegated to the server, which returns a customized HTML page ready to be rendered in the browser.
    
    
     The server processes all the necessary information, allows access to data, manages business logic, has the ability to abstract sensitive information using secrets, and delegates minimal processing to the client.
    
    
     However, if the server is not available, it will not be possible to use
    
    
     
      the system.
     
    
   </p>
   <p>
    
     In the hybrid approach, there is a combination of the best of “
    
    
     
      both worlds.”
     
    
   </p>
   <p>
    
     There are many JavaScript frameworks prepared to make web-based systems dynamic, providing a great user experience by processing resources on the client and, likewise, having the ability to interact with the server, delegating the processing of only relevant information to the UI rather than the entire processing of
    
    
     
      a page.
     
    
   </p>
   <p>
    
     Fortunately, ASP.NET Core 9 is
    
    <a id="_idIndexMarker063">
    </a>
    
     prepared for the development of web-based solutions in the different approaches mentioned.
    
    
     We’ll start to understand the first UI development model, using Razor Pages, in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-36">
    <a id="_idTextAnchor036">
    </a>
    
     Implementing a UI server render model with Razor Pages and ASP.NET MVC
    
   </h1>
   <p>
    
     ASP.NET Core 9 offers two powerful server-render models: Razor Pages
    
    <a id="_idIndexMarker064">
    </a>
    
     and MVC.
    
    
     They are similar models, but MVC
    
    <a id="_idIndexMarker065">
    </a>
    
     is more elaborate and implements the Model-View-Controller architectural design pattern—we’ll talk more about this in the
    
    <em class="italic">
     
      ASP.NET Core MVC
     
    </em>
    
     section.
    
    
     For now, let’s start learning about
    
    
     
      Razor Pages.
     
    
   </p>
   <h2 id="_idParaDest-37">
    <a id="_idTextAnchor037">
    </a>
    
     ASP.NET Core Razor Pages
    
   </h2>
   <p>
    
     Razor Pages is
    
    <a id="_idIndexMarker066">
    </a>
    
     a server-rendered framework that implements a page-based model.
    
    
     The page-based model basically contextualizes the implementation of a specific page, taking into account the UI and business logic, but correctly
    
    
     
      segregating responsibilities.
     
    
   </p>
   <p>
    
     Razor
    
    <a id="_idIndexMarker067">
    </a>
    
     is a markup language that acts similarly to a template engine and combines its use with HTML and
    
    
     
      C# code.
     
    
   </p>
   <p class="callout-heading">
    
     Razor’s origins
    
   </p>
   <p class="callout">
    
     Razor’s development began in June 2010, but it was only released in January 2011 with MVC 3, as part of Microsoft Visual Studio 2010.
    
    
     Razor is a simple-syntax
    
    
     
      visualization engine.
     
    
   </p>
   <p>
    
     This page-based development model brings great advantages, such as ease of creating and updating the UI; it’s testable, keeps UI and business logic separate, and although it has similarities to ASP.NET Core MVC, it’s simpler.
    
    
     Taking all these advantages into consideration, let’s create our first project using
    
    
     
      Razor Pages.
     
    
   </p>
   <h3>
    
     Creating our first project with Razor Pages
    
   </h3>
   <p>
    
     To create a
    
    <a id="_idIndexMarker068">
    </a>
    
     Razor Pages project, you can use Visual Studio or
    
    <a id="_idIndexMarker069">
    </a>
    
     the
    
    <strong class="source-inline">
     
      dotnet
     
    </strong>
    
     
      CLI tool.
     
    
   </p>
   <p>
    
     Creation using Visual Studio is very simple; just open the IDE, select
    
    <strong class="bold">
     
      Create a new project
     
    </strong>
    
     , and then select the
    
    <strong class="bold">
     
      ASP.NET Core Web App
     
    </strong>
    
     template, as shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.1 – Selecting a project template" src="img/B21788_02_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.1 – Selecting a project template
    
   </p>
   <p>
    
     Both Visual Studio and the CLI tool work with the concept of templates.
    
    
     With the .NET platform, it is possible to develop different types of projects, whether for web, Windows, or mobile.
    
    
     Each template creates a basic
    
    
     
      project structure.
     
    
   </p>
   <p>
    
     Throughout the rest of the book, we will use the CLI tool to create projects, as well as other needs that we will discuss later.
    
    
     From now on, we will use the .NET CLI tool to create a Razor Pages project, as this tool offers us several benefits that we will discuss in the rest of
    
    
     
      the book.
     
    
   </p>
   <p>
    
     When you install the .NET 9 SDK, a number of tools are available.
    
    
     The main tool we will use in this book
    
    
     
      is
     
    
    
     <strong class="source-inline">
      
       dotnet
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      dotnet
     
    </strong>
    
     CLI tool also has a concept of templates.
    
    
     To test this functionality, open your operating system’s Command
    
    <a id="_idIndexMarker070">
    </a>
    
     Prompt and run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet --version</pre>
   <p>
    
     After running the preceding command, the current version of the tool will be displayed.
    
    
     This time, still at the prompt, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet new</pre>
   <p>
    
     After running the preceding command, you will see
    
    
     
      the following:
     
    
   </p>
   <div><div><img alt="Figure 2.2 – dotnet CLI tool templates" src="img/B21788_02_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.2 – dotnet CLI tool templates
    
   </p>
   <p>
    
     As can
    
    <a id="_idIndexMarker071">
    </a>
    
     be seen in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     , some templates and examples of use were listed.
    
    
     Each model has a set of parameters that are used to customize project creation.
    
    
     If you want to know more about the parameters of each template, just type the following command; for example, for the
    
    <strong class="source-inline">
     
      webapp
     
    </strong>
    
     template, you’d type
    
    
     
      this command:
     
    
   </p>
   <pre class="console">
dotnet new webapp –h</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      -h
     
    </strong>
    
     (help) parameter will provide a list of parameters and documentation for the
    
    
     
      desired template.
     
    
   </p>
   <p>
    
     Depending on the installation on your machine, there may be other templates.
    
    
     Run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet new list</pre>
   <p>
    
     You will
    
    <a id="_idIndexMarker072">
    </a>
    
     see a list containing many types of
    
    <a id="_idIndexMarker073">
    </a>
    
     project templates; we will focus on the projects highlighted in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.3 – All available project templates" src="img/B21788_02_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.3 – All available project templates
    
   </p>
   <p>
    
     Now that we’ve understood templates, let’s finally create a new Razor Pages project via the command line.
    
    
     To do this, open Command Prompt, create a new folder called
    
    <strong class="source-inline">
     
      NewRazorPages
     
    </strong>
    
     , and run the following command on
    
    
     
      this folder:
     
    
   </p>
   <pre class="console">
dotnet new razor -n MySecondWebRazor</pre>
   <p>
    
     The previous command is composed of the
    
    <strong class="source-inline">
     
      new
     
    </strong>
    
     command, to create a new project, then
    
    <strong class="source-inline">
     
      razor
     
    </strong>
    
     , representing the short name of the desired template, and finally the
    
    <strong class="source-inline">
     
      -n
     
    </strong>
    
     parameter, which defines the name of
    
    
     
      the project.
     
    
   </p>
   <p>
    
     After executing the command, a new folder containing the project will
    
    
     
      be created.
     
    
   </p>
   <p class="callout-heading">
    
     Command details
    
   </p>
   <p class="callout">
    
     Each of the commands available in the CLI tool can have a set of parameters.
    
    
     To find out more about these parameters, simply add the
    
    <strong class="source-inline">
     
      -h
     
    </strong>
    
     option after a command; for example,
    
    <strong class="source-inline">
     
      dotnet
     
    </strong>
    
     <strong class="source-inline">
      
       new -h
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout">
    
     You can also consult the
    
    <a id="_idIndexMarker074">
    </a>
    
     tool’s documentation at the following
    
    
     
      link:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet">
     
      
       https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet
      
     
    </a>
   </p>
   <p>
    
     For the rest of the book, we will consider creating projects via the command line.
    
    
     Now, let’s go into more detail about the Razor Pages project
    
    
     
      we’ve created.
     
    
   </p>
   <h3>
    
     Understanding the Razor Pages project
    
   </h3>
   <p>
    
     The Razor Pages project has a very
    
    <a id="_idIndexMarker075">
    </a>
    
     simple directory structure and configurations compared to ASP.NET Core MVC.
    
    
     However, many of the concepts used in this project serve as a basis for the MVC project, so we’ll take advantage of all
    
    
     
      the content.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     shows the structure of the project created in the previous section and has been expanded to express each important item that we will discuss in
    
    
     
      more detail:
     
    
   </p>
   <div><div><img alt="Figure 2.4 – Razor Pages project structure" src="img/B21788_02_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.4 – Razor Pages project structure
    
   </p>
   <p>
    
     Razor Pages has a simple structure that can basically be divided into four
    
    
     
      important items:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       wwwroot folder
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker076">
     </a>
     
      folder contains the application’s static files, such as JavaScript, CSS, libraries, and images.
     
     
      By default, three subdirectories are configured, such as
     
     <strong class="source-inline">
      
       css
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       js
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       lib
      
     </strong>
     
      , used to contain JavaScript files from external libraries, such as jQuery, among others.
     
     
      You can also create other directories to contain files such as images, fonts, and
     
     
      
       so on.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Pages folder
      
     </strong>
     
      : This folder
     
     <a id="_idIndexMarker077">
     </a>
     
      contains the application’s pages, subdivided into a pair of files with the
     
     <strong class="source-inline">
      
       cshtml
      
     </strong>
     
      extension that contain the HTML code and C# code using Razor syntax, and
     
     <strong class="source-inline">
      
       cshtml.cs
      
     </strong>
     
      , which contains the C# code responsible for handling
     
     
      
       page events.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
     
      : This is a
     
     <a id="_idIndexMarker078">
     </a>
     
      file in
     
     <strong class="bold">
      
       JSON
      
     </strong>
     
      format that is used to maintain application settings centrally, as well as database connection strings, API keys, and other parameters.
     
     
      We’ll talk more about settings in
     
     <a href="B21788_09.xhtml#_idTextAnchor146">
      
       <em class="italic">
        
         Chapter 9
        
       </em>
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      : This is
     
     <a id="_idIndexMarker079">
     </a>
     
      the most important file in the Razor Pages project, written in C# and containing all the execution settings for the entire
     
     
      
       application flow.
      
     
    </li>
   </ul>
   <p>
    
     Some other details and configurations related to the project will be seen in the other chapters of the book as we add more features and concepts to the learning process.
    
    
     For now, it’s very important to understand some of the
    
    
     
      project’s premises.
     
    
   </p>
   <p>
    
     Let’s look at the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file to
    
    <a id="_idIndexMarker080">
    </a>
    
     understand
    
    
     
      some details:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
var app = builder.Build();
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapRazorPages();
app.Run();</pre>
   <p>
    
     The following points explain the
    
    
     
      preceding code:
     
    
   </p>
   <ul>
    <li>
     
      The first line of the file creates an instance of an ASP.NET Core web application, using some standard configurations, such as adding middleware, between
     
     <em class="italic">
      
       lines 9
      
     </em>
     
      and
     
     <em class="italic">
      
       13
      
     </em>
     
      , that acts on the application flow and convention configurations for generating routes, among other aspects provided by the
     
     
      
       framework itself.
      
     
    </li>
    <li>
     
      Next, we have the execution of the
     
     <strong class="source-inline">
      
       builder.services.AddRazorPages
      
     </strong>
     
      line, which is responsible for configuring the web application with the characteristics of the Razor Pages project.
     
     
      This project has dependencies on certain classes that are used by the platform when running
     
     
      
       the application.
      
     
    </li>
    <li>
     
      Between
     
     <em class="italic">
      
       lines 4
      
     </em>
     
      and
     
     <em class="italic">
      
       8
      
     </em>
     
      , there is a
     
     <a id="_idIndexMarker081">
     </a>
     
      check related to the environment in which the application is running.
     
     
      This block ensures that if there are any errors not dealt with by the application, the user will be redirected to a generic error page, preventing details of the application from being exposed.
     
     
      The
     
     <strong class="source-inline">
      
       app.UseHsts()
      
     </strong>
     
      code aims to force communication via the
     
     <strong class="bold">
      
       HTTP Strict Transport Security
      
     </strong>
     
      (
     
     <strong class="bold">
      
       HSTS
      
     </strong>
     
      ) protocol
     
     <a id="_idIndexMarker082">
     </a>
     
      to add security and the use
     
     
      
       of HTTPS.
      
     
    </li>
    <li>
     
      On
     
     <em class="italic">
      
       line 9
      
     </em>
     
      , we guarantee the use of the
     
     
      
       HTTPS protocol.
      
     
    </li>
    <li>
     <em class="italic">
      
       Line 10
      
     </em>
     
      is necessary for the Razor Pages application to take into account static files, localization, and the use
     
     
      
       of HTTPS.
      
     
    </li>
   </ul>
   <p>
    
     It is important to consider, at this point, that the code described in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file will affect how the application will behave at runtime.
    
    
     We must also consider the order of each of the methods located in
    
    
     
      the file.
     
    
   </p>
   <p>
    
     Further details and configuration variations will be discussed later in the book.
    
    
     We are already familiar with the Razor Pages project structure, so let’s learn more about the syntax used in HTML pages and how to interact with
    
    
     
      C# code.
     
    
   </p>
   <h3>
    
     Working with pages
    
   </h3>
   <p>
    
     Razor acts as
    
    <a id="_idIndexMarker083">
    </a>
    
     a powerful templating engine, allowing you to create pages using HTML, CSS, JavaScript, and C# code in the same file.
    
    
     This approach brings great flexibility in generating
    
    
     
      dynamic pages.
     
    
   </p>
   <p>
    
     Let’s look at an example of the
    
    
     <strong class="source-inline">
      
       Index.html
      
     </strong>
    
    
     
      page:
     
    
   </p>
   <pre class="source-code">
@page
@model IndexModel
@{
    ViewData["Title"] = "Home page";
}
&lt;div class="text-center"&gt;
    &lt;h1 class="display-4"&gt;Welcome&lt;/h1&gt;
    &lt;p&gt;Learn about &lt;a
      href="https://learn.microsoft.com/aspnet/core"&gt;
      building Web apps with ASP.NET Core&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</pre>
   <p>
    
     The first lines of code refer to page-related settings, and then we have the pure
    
    
     
      HTML code.
     
    
   </p>
   <p>
    
     Let’s understand the main components described in
    
    
     
      the file:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directive must be the first directive in a Razor page view.
     
     
      It indicates that the page will function as an
     
     
      
       action handler.
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       @model
      
     </strong>
     
      directive indicates which type of model will be passed to the page.
     
     
      Razor Pages has a set of two files that make up a page,
     
     <strong class="source-inline">
      
       .cshtml
      
     </strong>
     
      
       and
      
     
     
      <strong class="source-inline">
       
        .cshtml.cs
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ViewData["Title"]
     
    </strong>
    
     code is a dictionary, which represents another way of passing data to pages.
    
    
     In general,
    
    <strong class="source-inline">
     
      ViewData
     
    </strong>
    
     is used to pass small amounts of data.
    
    
     In the case of the preceding code,
    
    <strong class="source-inline">
     
      ViewData
     
    </strong>
    
     is being used to pass information from the page title to the
    
    
     
      HTML template.
     
    
   </p>
   <p>
    
     The first
    
    <a id="_idIndexMarker084">
    </a>
    
     concerns HTML; as with the previous example,
    
    <strong class="source-inline">
     
      .cshtml.cs
     
    </strong>
    
     refers to the C# code of the page handler, which contains the model or information that will be used on the page.
    
    
     Thus, the
    
    <strong class="source-inline">
     
      Index.cshtml
     
    </strong>
    
     file has an association with the
    
    
     <strong class="source-inline">
      
       index.cshtml.cs
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     In the following code, we have the
    
    <strong class="source-inline">
     
      IndexModel
     
    </strong>
    
     class that represents the model that will be used on
    
    
     
      the page:
     
    
   </p>
   <pre class="source-code">
public class IndexModel : PageModel
 {
     private readonly ILogger&lt;IndexModel&gt; _logger;
     public IndexModel(ILogger&lt;IndexModel&gt; logger)
     {
         _logger = logger;
     }
     public void OnGet()
     {
     }
 }</pre>
   <p>
    
     As we noted in the example, the
    
    <strong class="source-inline">
     
      Index.cshtml
     
    </strong>
    
     page does not have the entire structure of an HTML page.
    
    
     This is because Razor Pages allows the concept of Layout.
    
    
     That is, pages can often share a similar structure.
    
    
     This way, we can reuse the code to both generate common Layouts and create shared
    
    
     
      View blocks.
     
    
   </p>
   <p>
    
     In the project structure, Layouts are kept within the
    
    <strong class="source-inline">
     
      Pages/Shared
     
    </strong>
    
     folder.
    
    
     By convention, shared views start with an underscore.
    
    
     The
    
    <strong class="source-inline">
     
      _Layout.cshtml
     
    </strong>
    
     file has a common HTML structure and, in addition, a special
    
    
     
      directive,
     
    
    
     <strong class="source-inline">
      
       @RenderBody()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;!-- The rest of the code has been omitted for
      readability. --&gt;
    &lt;title&gt;@ViewData["Title"] - MyFirstRazorWebApp&lt;/title&gt;
    &lt;!-- The rest of the code has been omitted for
      readability. --&gt;
&lt;div class="container"&gt;
    &lt;main role="main" class="pb-3"&gt;
        @RenderBody()
    &lt;/main&gt;
&lt;/div&gt;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      RenderBody()
     
    </strong>
    
     method specifies the location where views will be rendered after server processing.
    
    
     In the case of the
    
    <strong class="source-inline">
     
      index.cshtml
     
    </strong>
    
     page, all HTML will be rendered between the main tags, in the
    
    <strong class="source-inline">
     
      _Layout.cshtml
     
    </strong>
    
     file.
    
    
     Also, note the use of
    
    <strong class="source-inline">
     
      ViewData["Title"]
     
    </strong>
    
     , which will display the value set on a page, as done in the
    
    
     <strong class="source-inline">
      
       index.cshtml
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     There are two
    
    <a id="_idIndexMarker085">
    </a>
    
     other special files that, by convention, should be located in the
    
    
     <strong class="source-inline">
      
       Pages
      
     </strong>
    
    
     
      folder:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       _ViewStart.cshtml
      
     </strong>
     
      : This is a file that allows us to define code that must be executed before displaying each Views.
     
     
      In this case, this file has a code where it defines which Layout file will be used
     
     
      
       for Views.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       _ViewImports.cshtml
      
     </strong>
     
      : This file is used to define the namespace and import features into the page, in a common way.
     
     
      This way, there is no need to declare namespaces and other features on
     
     
      
       each page.
      
     
    </li>
   </ul>
   <p>
    
     Now that we understand the entire project structure and how Razor pages are managed in the project, let’s add some customizations to the
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     page and the
    
    <strong class="source-inline">
     
      IndexModel
     
    </strong>
    
     model and learn how to use Razor syntax and interact with
    
    
     
      C# code.
     
    
   </p>
   <h3>
    
     Interacting with the Razor syntax and C# model
    
   </h3>
   <p>
    
     As explained previously, Razor pages
    
    <a id="_idIndexMarker086">
    </a>
    
     have two files, one responsible for rendering
    
    <a id="_idIndexMarker087">
    </a>
    
     the UI and the other responsible for containing the page’s business logic.
    
    
     Furthermore, there is the possibility of using C# code together with HTML, meaning that the page can be generated during processing time on the server, according to
    
    
     
      user interactions.
     
    
   </p>
   <p>
    
     We will make some changes to the
    
    <strong class="source-inline">
     
      index.cshtml
     
    </strong>
    
     file, adding some controls as shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    
     <em class="italic">
      
       .5
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.5 – Customizing the index.cshtml file using Razor syntax" src="img/B21788_02_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.5 – Customizing the index.cshtml file using Razor syntax
    
   </p>
   <p>
    
     Open the
    
    <strong class="source-inline">
     
      index.cshtml
     
    </strong>
    
     file in Visual Studio or Visual Studio Code to make the changes and follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Between the
     
     <strong class="source-inline">
      
       @{}
      
     </strong>
     
      instance, add the
     
     
      
       following code:
      
     
     <pre class="source-code">
string subtitle = "It's funny";</pre>
    </li>
    <li>
     
      Now, change all the
     
     <a id="_idIndexMarker088">
     </a>
     
      content between the
     
     <strong class="source-inline">
      
       div
      
     </strong>
     
      tags, which
     
     <a id="_idIndexMarker089">
     </a>
     
      contain the page content, to the
     
     
      
       following code:
      
     
     <pre class="source-code">
&lt;h1 class="display-4"&gt;Welcome&lt;/h1&gt;
  &lt;p&gt;Learn about &lt;a
    href="https://learn.microsoft.com/aspnet/core"&gt;
    building Web apps with ASP.NET Core&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;@Model.Message&lt;/h2&gt;&lt;br /&gt;
&lt;h3&gt;@subtitle&lt;/h3&gt;
  &lt;a asp-page-handler="DefineColor"
    asp-route-id="1"&gt;Red&lt;/a&gt;
  &lt;a asp-page-handler="DefineColor"
    asp-route-id="2"&gt;Green&lt;/a&gt;
  &lt;div style="width: 200px;height:200px;
    background-color:@Model.Color"&gt;&lt;/div&gt;
  &lt;form method="post"&gt;
    &lt;label&gt;Total:&lt;/label&gt;&lt;input type="text"
      name="quantity"/&gt;
    &lt;input type="submit" value="Load Products"
      name="btn" /&gt;
  &lt;/form&gt;
  &lt;table class="table"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Id&lt;/th&gt;
            &lt;th&gt;Nome&lt;/th&gt;
            &lt;th&gt;Preço&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        @foreach (var product in Model.Products)
        {
            &lt;tr&gt;
                &lt;td&gt;@product.Id&lt;/td&gt;
                &lt;td&gt;@product.Name&lt;/td&gt;
                &lt;td&gt;@product.Price.ToString("C")&lt;/td&gt;
            &lt;/tr&gt;
        }
    &lt;/tbody&gt;
  &lt;/table&gt;</pre>
     <p class="list-inset">
      
       The preceding code creates formatting for the
      
      <strong class="source-inline">
       
        Price
       
      </strong>
      
       property so that it is displayed in currency format.
      
      
       This formatting will take into account your browser’s regional settings.
      
      
       In the case of the example run in this book, the formatting will display the price in
      
      <strong class="source-inline">
       
        en-US
       
      </strong>
      
       
        culture format.
       
      
     </p>
    </li>
    <li>
     
      To
     
     <a id="_idIndexMarker090">
     </a>
     
      ensure that the property is displayed in a specific
     
     <a id="_idIndexMarker091">
     </a>
     
      format, a new property can
     
     
      
       be created:
      
     
     <pre class="source-code">
public string FormattedPrice
    {
        get { return price.ToString("C",
          CultureInfo.GetCultureInfo("en-US")); }
    }</pre>
    </li>
    <li>
     
      This way, we can update the existing code for price display to
     
     
      
       the following:
      
     
     <pre class="source-code">
&lt;td&gt;@product.FormattedPrice&lt;/td&gt;</pre>
    </li>
    <li>
     
      However, we
     
     <a id="_idIndexMarker092">
     </a>
     
      can define the application culture globally, avoiding
     
     <a id="_idIndexMarker093">
     </a>
     
      the need to create a new property.
     
     
      To make this change, add the following code to the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file below the
     
     <strong class="source-inline">
      
       var app =
      
     </strong>
     
      <strong class="source-inline">
       
        builder.Build()
       
      </strong>
     
     
      
       line:
      
     
     <pre class="source-code">
app.UseRequestLocalization(new
  RequestLocalizationOptions
{
  DefaultRequestCulture = new RequestCulture("en-US"),
  SupportedCultures = new List&lt;CultureInfo&gt;
  {
    new CultureInfo("en-US")
  }
});</pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     For more information about managing
    
    <a id="_idIndexMarker094">
    </a>
    
     cultures in ASP.NET Core 9, see the following
    
    
     
      link:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0
      
     
    </a>
   </p>
   <p>
    
     Some elements that use inline C# code have been added, in addition to some calls to the server code.
    
    
     At the moment, it is important to understand how Razor syntax can be used together with HTML.
    
    
     Let’s understand all the elements added to the UI and how they interact
    
    
     
      with C#.
     
    
   </p>
   <p>
    
     The first snippet added on
    
    <em class="italic">
     
      line 5
     
    </em>
    
     ,
    
    <strong class="source-inline">
     
      string subtitle = "It's funny"
     
    </strong>
    
     , is C# code, declaring a variable of
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       string
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Note that all the code is enclosed between
    
    <strong class="source-inline">
     
      @{ and }
     
    </strong>
    
     symbols, as per the example between
    
    <em class="italic">
     
      lines 3
     
    </em>
    
     and
    
    <em class="italic">
     
      6
     
    </em>
    
     of the
    
    <strong class="source-inline">
     
      index.cshtml
     
    </strong>
    
     file.
    
    
     This syntax allows the addition of a block of code
    
    <a id="_idIndexMarker095">
    </a>
    
     capable of
    
    <a id="_idIndexMarker096">
    </a>
    
     containing C# and
    
    
     
      HTML instructions.
     
    
   </p>
   <p class="callout-heading">
    
     Combining C# and HTML code and a block
    
   </p>
   <p class="callout">
    
     Within a C# code block, it is also possible to add HTML tags.
    
    
     Using this strategy brings great advantages, such as determining what type of HTML tag will be rendered, according to an
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statement, as in the
    
    
     
      following example:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      @{
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      if (total &gt;
     
    </strong>
    
     <strong class="source-inline">
      
       0)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      &lt;h1&gt;The available amount
     
    </strong>
    
     <strong class="source-inline">
      
       is: @total&lt;/h1&gt;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       else
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      &lt;h2&gt;There is no
     
    </strong>
    
     <strong class="source-inline">
      
       amount available&lt;/h2&gt;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p>
    
     In addition to the code block, the use of the
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     symbol allows the addition of C# code in one line, as in the example of the preceding code, which will display the value of the
    
    <strong class="source-inline">
     
      Message
     
    </strong>
    
     property of the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object and display the value of the
    
    <strong class="source-inline">
     
      subtitle
     
    </strong>
    
     variable,
    
    
     
      previously defined:
     
    
   </p>
   <pre class="source-code">
  &lt;h2&gt;@Model.Message&lt;/h2&gt;&lt;br /&gt;
  &lt;h3&gt;@subtitle&lt;/h3&gt;</pre>
   <p>
    
     Razor Pages provides directives, which are features added to HTML tags.
    
    
     The following code adds two anchors to
    
    
     
      the page:
     
    
   </p>
   <pre class="source-code">
&lt;a asp-page-handler="DefineColor" asp-route-id="1"&gt;Red&lt;/a&gt;
&lt;a asp-page-handler="DefineColor"
  asp-route-id="2"&gt;Green&lt;/a&gt;
    &lt;div style="width: 200px;height:200px;
      background-color:@Model.Color"&gt;&lt;/div&gt;</pre>
   <p>
    
     Note that there are two attributes,
    
    <strong class="source-inline">
     
      asp-page-handler
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      asp-route-id
     
    </strong>
    
     .
    
    
     These are directive Razor pages, which determine, respectively, the name of the event handler when the link is clicked and the value that will be sent as a parameter to
    
    
     
      the handler.
     
    
   </p>
   <p>
    
     Also, note
    
    <a id="_idIndexMarker097">
    </a>
    
     that the
    
    <strong class="source-inline">
     
      div
     
    </strong>
    
     style has the
    
    <strong class="source-inline">
     
      @Model.Color
     
    </strong>
    
     code, inserted
    
    <a id="_idIndexMarker098">
    </a>
    
     as the value of the
    
    <strong class="source-inline">
     
      background-color
     
    </strong>
    
     property.
    
    
     The color of the
    
    <strong class="source-inline">
     
      div
     
    </strong>
    
     tag will be set dynamically, according to
    
    
     
      the link.
     
    
   </p>
   <p>
    
     For the rest of the controls created on the page, we have a purely HTML form and a table that lists randomly generated products.
    
    
     The form does not have the
    
    <strong class="source-inline">
     
      action
     
    </strong>
    
     attribute, used to determine the page or script that will process the posting of data.
    
    
     This attribute was omitted because Razor Pages follows a convention, which in this case is to infer the action to the form
    
    
     
      page itself.
     
    
   </p>
   <p>
    
     The following code generates the rows and columns of the
    
    
     
      product table:
     
    
   </p>
   <pre class="source-code">
@foreach (var product in Model.Products)
 {
     &lt;tr&gt;
         &lt;td&gt;@product.Id&lt;/td&gt;
         &lt;td&gt;@product.Name&lt;/td&gt;
         &lt;td&gt;@product.Price.ToString("C")&lt;/td&gt;
     &lt;/tr&gt;
 }</pre>
   <p>
    
     The preceding
    
    <a id="_idIndexMarker099">
    </a>
    
     code is a mix of HTML and C# code.
    
    
     After executing
    
    <a id="_idIndexMarker100">
    </a>
    
     the
    
    <strong class="source-inline">
     
      foreach
     
    </strong>
    
     statement, the columns and rows of the product table are defined.
    
    
     Products are generated in the
    
    <strong class="source-inline">
     
      Products
     
    </strong>
    
     property of the
    
    
     <strong class="source-inline">
      
       Model
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p class="callout-heading">
    
     Remember to separate responsibilities
    
   </p>
   <p class="callout">
    
     As we can see, it is possible to add any C# code to an HTML page using Razor Pages.
    
    
     However, use this approach to manipulate UI elements, but it is important to separate responsibilities correctly, avoiding multiple implementations of business rules together with UI
    
    
     
      manipulation rules.
     
    
   </p>
   <p>
    
     All the elements we need at this point have been added, and we now know how to add C# code to manipulate our UI.
    
    
     Let’s finalize the
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     page, adding the necessary code for its operation in the
    
    
     <strong class="source-inline">
      
       index.cshtml.cs
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <h3>
    
     Working with the page model
    
   </h3>
   <p>
    
     For the previously created
    
    <a id="_idIndexMarker101">
    </a>
    
     UI to work correctly, we must add some properties and methods to the page model.
    
    
     Open the
    
    <strong class="source-inline">
     
      index.cshtml.cs
     
    </strong>
    
     file so that we can add the
    
    
     
      necessary functionality.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     page model is, in fact, a C# class that has an inheritance from the
    
    <strong class="source-inline">
     
      PageModel
     
    </strong>
    
     class, which is an abstraction of several properties and methods used by models in
    
    
     
      Razor Pages.
     
    
   </p>
   <p>
    
     Let’s make changes to the
    
    <strong class="source-inline">
     
      IndexModel
     
    </strong>
    
     class and understand each piece of
    
    
     
      code added:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="source-inline">
      
       Message
      
     </strong>
     
      property to the
     
     <strong class="source-inline">
      
       Index.cshtml.cs
      
     </strong>
     
      file.
     
     
      It will be used to define a message that will be displayed in
     
     
      
       the UI:
      
     
     <pre class="source-code">
public string Message { get; set; }</pre>
    </li>
    <li>
     
      In the project root, create a folder named
     
     <strong class="source-inline">
      
       Models
      
     </strong>
     
      and then add a class called
     
     <strong class="source-inline">
      
       Product.cs
      
     </strong>
     
      .
     
     
      This class must have the
     
     
      
       following code:
      
     
     <pre class="source-code">
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}</pre>
    </li>
    <li>
     
      Go back to the
     
     <strong class="source-inline">
      
       Index.cshtml.cs
      
     </strong>
     
      file and add a
     
     <strong class="source-inline">
      
       Products
      
     </strong>
     
      property that will contain a list of objects that will be listed in the table created in the
     
     
      
       UI previously:
      
     
     <pre class="source-code">
public List&lt;Product&gt; Products { get; set; }</pre>
    </li>
    <li>
     
      Also, add a
     
     
      <strong class="source-inline">
       
        Color
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
public string Color { get; set; }</pre>
    </li>
    <li>
     
      The basic properties have been created.
     
     
      Now, let’s create a method that randomly generates a list of products.
     
     
      Add the
     
     <strong class="source-inline">
      
       GenerateProduct
      
     </strong>
     
      method as per the
     
     <a id="_idIndexMarker102">
     </a>
     
      
       following code:
      
     
     <pre class="source-code">
private List&lt;Product&gt; GenerateProduct(int quantity)
{
    var random = new Random();
    var products = Enumerable.Range(1,
      quantity).Select(i =&gt; new Product
    {
        Id = i,
        Name = $"Product {i}",
        Price = (decimal)(random.NextDouble() * 100.0)
    });
    return products;
}</pre>
    </li>
    <li>
     
      We will change the class constructor and add default values for the
     
     <strong class="source-inline">
      
       Products
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Message
      
     </strong>
     
      properties.
     
     
      This way, as soon as the page is displayed, we will have a randomly generated list of products and an
     
     <strong class="bold">
      
       I’m using the Razor
      
     </strong>
     
      <strong class="bold">
       
        Syntax
       
      </strong>
     
     
      
       message:
      
     
     <pre class="source-code">
public IndexModel(ILogger&lt;IndexModel&gt; logger)
{
    _logger = logger;
    Products = GenerateProduct(10);
    Message = "I'm using the Razor Syntax.";
}</pre>
    </li>
    <li>
     
      The method that generates the products is being used in the constructor to generate an initial listing.
     
     
      However, we want to interact through the UI and generate a list based on a value that will be entered in the form.
     
     
      To do this, we will create an
     
     <strong class="source-inline">
      
       OnPost
      
     </strong>
     
      method.
     
     
      This method generates a new list, based on the quantity entered in the
     
     
      
       UI form:
      
     
     <pre class="source-code">
public void OnPost(int quantity)
{
    Products = GenerateProduct(quantity);
}</pre>
    </li>
    <li>
     
      Finally, let’s
     
     <a id="_idIndexMarker103">
     </a>
     
      define a last method that will be responsible for setting the value of the
     
     
      <strong class="source-inline">
       
        Color
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
public void OnGetDefineColor(int id)
{
    Color = id == 1 ? "#FF0000" : "green";
}</pre>
    </li>
   </ol>
   <p>
    
     Our model is ready to interact with the UI.
    
    
     But before running the application, let’s understand a simple concept of Razor
    
    
     
      Pages convention.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      OnPost
     
    </strong>
    
     method has this name, following a convention, and is related to the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     HTTP verbs.
    
    
     This way, by defining methods such as
    
    <strong class="source-inline">
     
      OnGet
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      OnPost
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      OnDelete
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      OnPut
     
    </strong>
    
     , they will be able to handle page events, according to the HTTP verb.
    
    
     The
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     page UI has a form with the
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method.
    
    
     Therefore, when clicking on the
    
    <strong class="bold">
     
      Load Products
     
    </strong>
    
     button, Razor Pages will automatically call the
    
    <strong class="source-inline">
     
      OnPost
     
    </strong>
    
     method on the
    
    
     <strong class="source-inline">
      
       IndexModel
      
     </strong>
    
    
     
      model.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      OnGetDefineColor
     
    </strong>
    
     method has this name to follow the convention, but there is no obligation to use the
    
    <strong class="source-inline">
     
      OnGet
     
    </strong>
    
     prefix in the method name.
    
    
     In HTML, we do not define the link handler as
    
    <strong class="source-inline">
     
      OnGetDefineColor
     
    </strong>
    
     ; this is because, by convention, Razor Pages will infer the prefix from the method name, and also because a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request is performed.
    
    
     But if you wish to provide your full name, there will be no problem.
    
    
     The
    
    <strong class="source-inline">
     
      OnGetDefineColor
     
    </strong>
    
     method has another important characteristic: its
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     parameter.
    
    
     The
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     parameter receives the value defined in the directive added in the HTML link, as shown in the following
    
    
     
      code example:
     
    
   </p>
   <pre class="source-code">
&lt;a asp-page-handler="DefineColor" asp-route-id="1"&gt;Red&lt;/a&gt;</pre>
   <p>
    
     This action is called
    
    <a id="_idIndexMarker104">
    </a>
    
     binding, which means that when passing the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     parameter, Razor Pages sets the values of the method arguments according to the name of
    
    
     
      each parameter.
     
    
   </p>
   <p class="callout-heading">
    
     Directive tip
    
   </p>
   <p class="callout">
    
     Passing parameters in the previously defined HTML link is done using the
    
    <strong class="source-inline">
     
      asp-route
     
    </strong>
    
     directive together with the name of the parameter expected in the method—in this case,
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     .
    
    
     This way, the complete directive is defined by
    
    <strong class="source-inline">
     
      asp-route-id
     
    </strong>
    
     .
    
    
     If there were another argument called
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     , for example, the directive would
    
    
     
      be
     
    
    
     <strong class="source-inline">
      
       asp-route-name
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now that you know the entire implementation of the
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     page, run the application and interact with the controls
    
    
     
      created previously.
     
    
   </p>
   <p>
    
     So far, we have learned how to use Razor Pages to create dynamic pages using the server-side approach.
    
    
     With each interaction with the controls created on the
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     page, a call will be made to the server, which will manipulate the information, interpret the Razor page code implemented in the UI, and later return an HTML output with
    
    
     
      the result.
     
    
   </p>
   <p>
    
     This approach is quite similar to ASP.NET Core MVC, which we will learn about in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-38">
    <a id="_idTextAnchor038">
    </a>
    
     ASP.NET Core MVC
    
   </h2>
   <p>
    
     ASP.NET Core MVC is also a
    
    <a id="_idIndexMarker105">
    </a>
    
     very powerful server-side framework that implements the MVC design pattern.
    
    
     Let’s understand how the MVC design pattern works and then learn how to benefit from this approach by creating a
    
    
     
      new project.
     
    
   </p>
   <h3>
    
     MVC pattern
    
   </h3>
   <p>
    
     MVC is an architectural design
    
    <a id="_idIndexMarker106">
    </a>
    
     pattern that works on the separation of responsibilities
    
    
     
      or context:
     
    
   </p>
   <div><div><img alt="Figure 2.6 – MVC pattern" src="img/B21788_02_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.6 – MVC pattern
    
   </p>
   <p>
    
     As you can see
    
    <a id="_idIndexMarker107">
    </a>
    
     in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     , the
    
    <strong class="bold">
     
      Controller
     
    </strong>
    
     acts
    
    <a id="_idIndexMarker108">
    </a>
    
     as an orchestrator, responding to user interactions through
    
    <a id="_idIndexMarker109">
    </a>
    
     the
    
    <strong class="bold">
     
      View
     
    </strong>
    
     , and delegating actions to the
    
    <strong class="bold">
     
      Model
     
    </strong>
    
     , which
    
    <a id="_idIndexMarker110">
    </a>
    
     represents the application state and business rules.
    
    
     Subsequently, the Controller returns the result, defining which View will be responsible for displaying the UI to the
    
    
     
      end user.
     
    
   </p>
   <p>
    
     The View and the Controller have a dependency on the Model, but the Model is agnostic, allowing the separation of responsibilities and the use of good code practices, such as the use of unit tests, as there is independence from the
    
    
     
      visual presentation.
     
    
   </p>
   <p>
    
     ASP.NET Core MVC is based on the MVC pattern, adapting the project model and conventions.
    
    
     Let’s understand how this pattern is implemented in this type
    
    
     
      of project.
     
    
   </p>
   <h3>
    
     The ASP.NET Core MVC project structure
    
   </h3>
   <p>
    
     Creating the ASP.NET Core MVC project
    
    <a id="_idIndexMarker111">
    </a>
    
     is very simple, and we use the CLI tool, in addition to Visual Studio Code as
    
    
     
      an editor.
     
    
   </p>
   <p>
    
     Follow the
    
    
     
      next instructions:
     
    
   </p>
   <ol>
    <li>
     
      Open your operating system’s Command Prompt and access a directory of your choice where the project will
     
     
      
       be created.
      
     
    </li>
    <li>
     
      Enter the following command to create
     
     
      
       the project:
      
     
     <pre class="source-code">
<strong class="bold">dotnet new mvc --name MyFirstMVCApp</strong></pre>
     <p class="list-inset">
      
       The preceding command uses the
      
      <strong class="source-inline">
       
        dotnet
       
      </strong>
      
       CLI tool, where we specify the action of creating a new project through the
      
      <strong class="source-inline">
       
        new
       
      </strong>
      
       command.
      
      
       Then, we define which type of project will be created.
      
      
       In this case, we inform that the template will be
      
      <strong class="source-inline">
       
        mvc
       
      </strong>
      
       , and a
      
      <strong class="source-inline">
       
        --name
       
      </strong>
      
       parameter has been added, whereby we inform the name of
      
      
       
        the project.
       
      
     </p>
    </li>
    <li>
     
      A folder will be created with the name of the application.
     
     
      Access this folder and then open Visual Studio Code by running the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">cd MyFirstMVCApp</strong>
<strong class="bold">code.</strong></pre>
     <p class="list-inset">
      
       The preceding command will open up
      
      
       
        the following:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 2.7 – ASP.NET MVC project structure" src="img/B21788_02_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.7 – ASP.NET MVC project structure
    
   </p>
   <p>
    
     When looking at the structure of the MVC project created, we will notice a similarity with
    
    
     
      Razor Pages.
     
    
   </p>
   <p>
    
     There are three
    
    <a id="_idIndexMarker112">
    </a>
    
     main
    
    
     
      project folders:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       Views
      
     </strong>
     
      : It has the same characteristics as the
     
     <strong class="source-inline">
      
       Pages
      
     </strong>
     
      folder in Razor Pages; that is, it is the application’s UI.
     
     
      It has
     
     <strong class="source-inline">
      
       .cshtml
      
     </strong>
     
      files, and these are organized into subfolders that represent a page and contain all the UIs that can be used as responses to actions.
     
     
      However, there are no
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        cshtml.cs
       
      </strong>
     
     
      
       files.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Controller
      
     </strong>
     
      : The controller has a similar role to the class defined in the Razor Pages
     
     <strong class="source-inline">
      
       .cshtml.cs
      
     </strong>
     
      file.
     
     
      As mentioned, it is an orchestrator that has methods to manipulate events executed in Views.
     
     
      In MVC, each controller method is called
     
     <strong class="source-inline">
      
       actions
      
     </strong>
     
      and can return Views, redirections, or
     
     
      
       even data.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Models
      
     </strong>
     
      : This folder is used to manage the business classes and models that will be used to exchange information between Views
     
     
      
       and HTML.
      
     
    </li>
   </ul>
   <p>
    
     This structure follows a convention, which, in a way, facilitates development in this approach.
    
    
     However, the platform allows us to make customizations
    
    
     
      if necessary.
     
    
   </p>
   <p>
    
     The MVC project also presents a small difference in the settings defined in the
    
    <strong class="source-inline">
     
      program.cs
     
    </strong>
    
     file in relation to Razor Pages.
    
    
     Before executing the
    
    <strong class="source-inline">
     
      app.Run()
     
    </strong>
    
     line, there is a call to the
    
    <strong class="source-inline">
     
      app.MapControllerRoute
     
    </strong>
    
     method.
    
    
     This method is responsible for configuring all of
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Routes define what will be accessed and how it should be accessed through
    
    
     
      application requests.
     
    
   </p>
   <p>
    
     As shown in the
    
    <a id="_idIndexMarker113">
    </a>
    
     following code, a default route is configured, called
    
    <strong class="source-inline">
     
      default
     
    </strong>
    
     , which has the
    
    <strong class="source-inline">
     
      controller
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      action
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      parameter
     
    </strong>
    
     pattern.
    
    
     Furthermore, the controller and action have a default value,
    
    <strong class="source-inline">
     
      Home
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     , respectively, while the parameter
    
    
     
      is optional:
     
    
   </p>
   <pre class="source-code">
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");</pre>
   <p>
    
     This is a standard MVC convention and can be easily changed.
    
    
     In this model, if access to the application does not have a definition of the controller and which action should be executed, then the default controller,
    
    <strong class="source-inline">
     
      Home
     
    </strong>
    
     , and the
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     action will be defined as the response to
    
    
     
      the request.
     
    
   </p>
   <p>
    
     It is interesting to note that we are referring to Controllers and not pages.
    
    
     This is because the MVC pattern allows the Controller to orchestrate the request, according to the desired action, and then return a result or
    
    
     
      a View.
     
    
   </p>
   <p>
    
     As we progress through the chapters of the book, we will have other examples of
    
    
     
      using routes.
     
    
   </p>
   <h3>
    
     Understanding patterns and conventions
    
   </h3>
   <p>
    
     The MVC project follows a
    
    <a id="_idIndexMarker114">
    </a>
    
     convention that benefits the file structure
    
    
     
      presented previously.
     
    
   </p>
   <p>
    
     As we learned, the Controller acts as an orchestrator between the Model and the View.
    
    
     This way, instead of using a concept of pages, there is the idea
    
    
     
      of actions.
     
    
   </p>
   <p>
    
     Given the user’s intention or interaction, it triggers an action.
    
    
     This action is captured by a Controller, which then performs the processing and returns either a value or a View, as shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    
     <em class="italic">
      
       .8
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.8 – MVC request flow" src="img/B21788_02_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.8 – MVC request flow
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     class
    
    <a id="_idIndexMarker115">
    </a>
    
     is a C# class, which has attributes and methods.
    
    
     The
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     class’s public methods are
    
    
     
      called actions.
     
    
   </p>
   <p>
    
     Imagine a registry of people.
    
    
     We would then have the
    
    
     
      following class:
     
    
   </p>
   <pre class="source-code">
public class PersonController : Controller
{
    public IActionResult Index()
    {
        return View();
    }
    public JsonResult GetPeople()
    {
        var model = new List&lt;PersonModel&gt;() {
            new PersonModel("Person 1",
              new DateTime(1980, 12, 11)),
            new PersonModel("Person 2",
              new DateTime(1983, 12, 15))
        };
        return Json(model);
    }
    public IActionResult Register(PersonModel personModel)
    {
        return RedirectToAction("Result",
          new { message =  $"The {personModel.Name}
          was registered successfully." });
    }
    public IActionResult Result(string message)
    {
        ViewData["Message"] = message;
        return View();
    }
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      PersonController
     
    </strong>
    
     class
    
    <a id="_idIndexMarker116">
    </a>
    
     follows the name convention, adopting the
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     suffix at the end of the class name.
    
    
     Furthermore, this class has an inheritance from the
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     class, which is a base class that already has some utility methods responsible for processing and returning data and information through
    
    
     
      the controller.
     
    
   </p>
   <p>
    
     Next, we have a method called
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     , which just returns a View, executing the
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     <strong class="source-inline">
      
       View()
      
     </strong>
    
    
     
      command.
     
    
   </p>
   <p class="callout-heading">
    
     Which View is returned?
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      View()
     
    </strong>
    
     method takes into account the Asp.NET Core MVC convention.
    
    
     So, when executed, the view that is instantiated considers the following path:
    
    <strong class="source-inline">
     
      /Views/&lt;ControllerName&gt;/Action.cshtml
     
    </strong>
    
     .
    
    
     This means that in the case of the
    
    <strong class="source-inline">
     
      PersonController
     
    </strong>
    
     class, calling the
    
    <strong class="source-inline">
     
      Index
     
    </strong>
    
     method will return a
    
    
     
      View:
     
    
    
     <strong class="source-inline">
      
       Views/Person/Index.cshtml
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      View()
     
    </strong>
    
     method has other overloads, making it possible to pass an object that will be used as a Model into the View or even define a Controller View that should
    
    
     
      be displayed.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      GetPeople()
     
    </strong>
    
     method just returns a list of people in JSON format, as shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    
     <em class="italic">
      
       .9
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.9 – JSON with a list of people" src="img/B21788_02_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.9 – JSON with a list of people
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Register()
     
    </strong>
    
     method
    
    <a id="_idIndexMarker117">
    </a>
    
     processes the form request and returns an object to the
    
    <strong class="source-inline">
     
      Result
     
    </strong>
    
     View.
    
    
     However, in this case, it is making the call to an action from the
    
    <strong class="source-inline">
     
      PersonController
     
    </strong>
    
     controller, executing the
    
    <strong class="source-inline">
     
      RedirectToAction
     
    </strong>
    
     method, called
    
    <strong class="source-inline">
     
      Result
     
    </strong>
    
     , which expects a string as a parameter.
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     demonstrates the display of the action result after registering
    
    
     
      a person:
     
    
   </p>
   <div><div><img alt="Figure 2.10 – Register Person view" src="img/B21788_02_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.10 – Register Person view
    
   </p>
   <p class="callout-heading">
    
     Base Controller class
    
   </p>
   <p class="callout">
    
     The abstract
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     class has some utility methods that allow you to work on the communication flow between the Controller and
    
    
     
      the View.
     
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      Json()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      View()
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      RedirectToAction()
     
    </strong>
    
     methods are some of the resources that are commonly used in a
    
    
     
      controller class.
     
    
   </p>
   <p>
    
     The MVC model and Razor Pages have similarities, but a big difference is the use of actions instead of pages.
    
    
     In this way, the controller has the ability to decide what type of View or information should be returned, in relation to some user interaction, orchestrating the
    
    
     
      processing flow.
     
    
   </p>
   <p>
    
     The Controller
    
    <a id="_idIndexMarker118">
    </a>
    
     responds to user events, and the View is an important aspect of this type of project.
    
    
     Based on the
    
    <strong class="source-inline">
     
      PersonController
     
    </strong>
    
     example, we will understand how the View was created and learn how the interaction with the Controller’s actions works in the
    
    
     
      next section.
     
    
   </p>
   <h3>
    
     Working with Views on ASP.NET MVC
    
   </h3>
   <p>
    
     The concept of Views in ASP.NET MVC
    
    <a id="_idIndexMarker119">
    </a>
    
     is the same as that used in Razor Pages, using the Razor syntax.
    
    
     As we can see in the following code, there is a form tag, using Razor directives, defining which Controller and action will process
    
    
     
      the registration:
     
    
   </p>
   <pre class="source-code">
@model MyFirstMVCApp.Models.PersonModel
@{
    ViewData["Title"] = "Home Page";
}
&lt;div class="text-center"&gt;
    &lt;h1 class="display-4"&gt;Person View&lt;/h1&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;form method="post" asp-controller="Person"
      asp-action="Register"&gt;
        @Html.LabelFor(p =&gt; p.Name)
        @Html.TextBoxFor(p =&gt; p.Name)
        &lt;br/&gt;
        @Html.LabelFor(p =&gt; p.DateOfBirth)
        @Html.TextBoxFor(p =&gt; p.DateOfBirth)
        &lt;input type="submit" value="Register" /&gt;
    &lt;/form&gt;
&lt;/div&gt;</pre>
   <p>
    
     The preceding file was created in the
    
    <strong class="source-inline">
     
      Views/Person/Index.cshtml
     
    </strong>
    
     directory structure.
    
    
     Following the convention, for the
    
    <strong class="source-inline">
     
      PersonController
     
    </strong>
    
     controller, there must be a
    
    <strong class="source-inline">
     
      Person
     
    </strong>
    
     folder, a subfolder of Views, which will contain all the Views that will be displayed through the
    
    
     <strong class="source-inline">
      
       PersonController
      
     </strong>
    
    
     
      controller.
     
    
   </p>
   <p class="callout-heading">
    
     The view index is a good practice
    
   </p>
   <p class="callout">
    
     It is good practice to have an
    
    <strong class="source-inline">
     
      Index.cshtml
     
    </strong>
    
     file and an
    
    <strong class="source-inline">
     
      Index()
     
    </strong>
    
     action in each controller.
    
    
     Following the route pattern, defined in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file, by default, when an action is not specified, an
    
    <strong class="source-inline">
     
      Index()
     
    </strong>
    
     action will be executed.
    
    
     In this case, having a View and Action Index will avoid usability problems in
    
    
     
      your application.
     
    
   </p>
   <p>
    
     To create the
    
    <a id="_idIndexMarker120">
    </a>
    
     labels and inputs used in the form,
    
    <strong class="bold">
     
      tag helpers
     
    </strong>
    
     were
    
    <a id="_idIndexMarker121">
    </a>
    
     used.
    
    
     Tag helpers are Razor Pages methods that basically render HTML.
    
    
     The difference, in the preceding code presented, is that there is a connection with
    
    
     
      the Model.
     
    
   </p>
   <p>
    
     In the first line of the
    
    <strong class="source-inline">
     
      Index.csthml
     
    </strong>
    
     page, a Model was defined, using the
    
    <strong class="source-inline">
     
      @model MyFirstMVCApp.Models.PersonModel
     
    </strong>
    
     code.
    
    
     This makes the Model strongly typed.
    
    
     By using a tag helper, together with a Lambda expression, we are implementing good practice in relation to the MVC
    
    
     
      binding model.
     
    
   </p>
   <p>
    
     As a result, the HTML generated by tag helpers for the form will have the correct names in relation to the model properties, following the flow
    
    
     
      outlined next:
     
    
   </p>
   <ol>
    <li>
     
      The data is the name and date of birth informed in
     
     
      
       the inputs.
      
     
    </li>
    <li>
     
      The user clicks the
     
     
      <strong class="bold">
       
        Register
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      The ASP.NET framework makes a request to the
     
     
      <strong class="source-inline">
       
        Result
       
      </strong>
     
     
      
       action.
      
     
    </li>
    <li>
     
      The ASP.NET framework identifies that the
     
     <strong class="source-inline">
      
       Result
      
     </strong>
     
      action has a
     
     <strong class="source-inline">
      
       PersonModel
      
     </strong>
     
      object as a parameter and then creates
     
     
      
       an instance.
      
     
    </li>
    <li>
     
      The ASP.NET framework binds the data posted by the form and sets the values in the corresponding properties of the
     
     
      
       instantiated object.
      
     
    </li>
    <li>
     
      The ASP.NET framework executes the
     
     
      <strong class="source-inline">
       
        Result
       
      </strong>
     
     
      
       action.
      
     
    </li>
   </ol>
   <p>
    
     As the bind is
    
    <a id="_idIndexMarker122">
    </a>
    
     done through property names, if any name is typed incorrectly, some properties will not have
    
    
     
      a value.
     
    
   </p>
   <p>
    
     The use of the tag helpers approach also helps in other aspects such as attributes added to the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     class that allow validations, among other aspects.
    
    
     We will discuss more about attributes and bind during
    
    <em class="italic">
     
      Chapters 3
     
    </em>
    
     
      and
     
    
    
     <em class="italic">
      
       5
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     The MVC pattern provides us with several benefits, especially in more complex projects where there is a need to control different business flows and return dynamic Views according to
    
    
     
      the need.
     
    
   </p>
   <p>
    
     There are other approaches to working with UIs in ASP.NET Core 9.
    
    
     Let’s learn a little more about other options, such as using Blazor and integrations with JavaScript frameworks, in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-39">
    <a id="_idTextAnchor039">
    </a>
    
     Exploring UI client rendering with Blazor and JavaScript frameworks
    
   </h1>
   <p>
    
     ASP.NET Core 9 has several frameworks that provide the creation of UIs with high quality and good user experience, using client-side and
    
    
     
      server-side approaches.
     
    
   </p>
   <p>
    
     We will talk about the newest technology that
    
    <a id="_idIndexMarker123">
    </a>
    
     uses the
    
    <strong class="bold">
     
      WebAssembly
     
    </strong>
    
     standard, called Blazor, which is a powerful and flexible UI framework.
    
    
     However, if you are used to JavaScript frameworks, you can also benefit from the .
    
    
     
      NET platform.
     
    
   </p>
   <h2 id="_idParaDest-40">
    <a id="_idTextAnchor040">
    </a>
    
     Rich UIs with Blazor
    
   </h2>
   <p>
    
     Just as with Razor Pages and
    
    <a id="_idIndexMarker124">
    </a>
    
     MVC, Blazor
    
    <a id="_idIndexMarker125">
    </a>
    
     offers a
    
    <strong class="bold">
     
      single-page application
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SPA
     
    </strong>
    
     ) framework on the .NET platform, running both client-side and server-side, using all the power
    
    
     
      of C#.
     
    
   </p>
   <h3>
    
     Blazor WebAssembly
    
   </h3>
   <p>
    
     The client-server version of Blazor runs on the
    
    <a id="_idIndexMarker126">
    </a>
    
     WebAssembly platform, which is a compact bytecode with an optimized format, fast to download, and provides great performance when running on the client side, creating rich
    
    
     
      UI experiences.
     
    
   </p>
   <p>
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .11
     
    </em>
    
     , Blazor is an abstraction of ASP.NET Core for WebAssembly.
    
    
     This way, the Blazor code will generate application assemblies, which require the .NET runtime for execution, also allowing interaction between WebAssembly and the
    
    
     
      HTML document.
     
    
   </p>
   <p class="callout-heading">
    
     WebAssembly
    
   </p>
   <p class="callout">
    
     WebAssembly is a web
    
    <a id="_idIndexMarker127">
    </a>
    
     standard, and you can learn more about it at the official
    
    
     
      website:
     
    
    <a href="https://webassembly.org/">
     
      
       https://webassembly.org/
      
     
    </a>
   </p>
   <div><div><img alt="Figure 2.11 – WebAssembly and Blazor" src="img/B21788_02_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.11 – WebAssembly and Blazor
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker128">
    </a>
    
     WebAssembly platform uses an interoperability model, which allows it to interact with all browser APIs, running in a sandbox, providing security against malicious actions, and also allowing the execution of .
    
    
     
      NET code.
     
    
   </p>
   <p>
    
     All page code developed is compiled into .NET assemblies.
    
    
     Thus, when accessing the page through the browser, both the assemblies and the .NET runtime are downloaded.
    
    
     Then, with the support of WebAssembly, the application runs and uses JavaScript interop to
    
    <a id="_idIndexMarker129">
    </a>
    
     handle
    
    <strong class="bold">
     
      DOM
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Document Object Model
     
    </strong>
    
     ) manipulation and browser
    
    
     
      API calls.
     
    
   </p>
   <p>
    
     Blazor is
    
    <a id="_idIndexMarker130">
    </a>
    
     a flexible framework that also allows you to create projects with the benefits of server-side processing, offering an excellent
    
    
     
      client-side experience.
     
    
   </p>
   <h3>
    
     Blazor Server
    
   </h3>
   <p>
    
     Blazor also allows for a
    
    <a id="_idIndexMarker131">
    </a>
    
     server-side UI rendering approach.
    
    
     However, unlike what happens with Razor Pages and MVC, instead of rendering the entire HTML for each client request and returning a complete document as a response, Blazor creates a graph, which represents the page components, considering properties
    
    
     
      and state.
     
    
   </p>
   <p>
    
     Then, with each interaction, Blazor performs an evaluation of the graph and produces a binary representation, which is sent back to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     Blazor’s server-side approach
    
    <a id="_idIndexMarker132">
    </a>
    
     uses
    
    <strong class="bold">
     
      SignalR
     
    </strong>
    
     technology, which allows you to update the UI through a direct connection to the server, bringing better usability and a rich user experience.
    
    
     We will cover SignalR in
    
    <a href="B21788_04.xhtml#_idTextAnchor061">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Blazor Server brings great benefits in the development of web-based solutions, with C# as a common language, bringing security, reliability,
    
    
     
      and performance.
     
    
   </p>
   <p>
    
     Let’s understand the development approach
    
    
     
      using Blazor.
     
    
   </p>
   <h3>
    
     Blazor components and structure
    
   </h3>
   <p>
    
     Just as with some JavaScript
    
    <a id="_idIndexMarker133">
    </a>
    
     frameworks, such as Angular, Blazor works with a
    
    
     
      component structure.
     
    
   </p>
   <p>
    
     A component is one or more UI elements developed with a specific objective, according to the needs of the application.
    
    
     This component can be reused throughout the application, enabling separation of responsibilities, reusability,
    
    
     
      and flexibility.
     
    
   </p>
   <p>
    
     All Blazor components have the
    
    <strong class="source-inline">
     
      .razor
     
    </strong>
    
     extension and use both the Razor syntax and all the benefits
    
    
     
      of C#.
     
    
   </p>
   <p>
    
     To create a Blazor project, simply use the
    
    <strong class="source-inline">
     
      dotnet
     
    </strong>
    
     CLI, with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet new blazor --name MyFirstBlazorApp</pre>
   <p class="callout-heading">
    
     Interactivity Render Mode
    
   </p>
   <p class="callout">
    
     ASP.NET Core 9 introduces the render interactive mode
    
    <a id="_idIndexMarker134">
    </a>
    
     on Blazor Apps.
    
    
     The interactive render mode feature enhances the way Blazor apps handle rendering, introducing a mode where the server-rendered static HTML is progressively enhanced into a fully interactive
    
    
     
      client-side application.
     
    
   </p>
   <p class="callout">
    
     The goals of this
    
    
     
      feature are:
     
    
   </p>
   <p class="callout">
    
     Progressive Enhancement: When a Blazor app is initially loaded, the server pre-renders the HTML, providing a fully functional page for users to interact with immediately.
    
    
     This allows the app to seamlessly transition from this static HTML to a fully interactive Blazor app once the Blazor framework is loaded on the
    
    
     
      client side.
     
    
   </p>
   <p class="callout">
    
     Seamless Transition: ensures the app appears interactive even while the client-side Blazor runtime is being initialized and users can start interacting with the app before the complete Blazor runtime is ready, making the user
    
    
     
      experience smoother.
     
    
   </p>
   <p class="callout">
    
     Improved Performance: optimizes the time-to-interactivity by reducing the noticeable delay that users might experience in traditional Blazor Server or Blazor
    
    
     
      WebAssembly apps.
     
    
   </p>
   <p class="callout">
    
     Enhanced User Experience: minimizes interruptions or loading indicators during transitions, giving users a better perception
    
    
     
      of speed.
     
    
   </p>
   <p class="callout">
    
     If you create a Blazor app using
    
    
     
      the command:
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      dotnet new blazor --
     
    </strong>
    
     <strong class="bold">
      
       name MyFirstBlazorApp
      
     </strong>
    
   </p>
   <p class="callout">
    
     The default interactive mode is Server.
    
    
     In case you want to leverage the new feature, use the
    
    
     
      following command:
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      dotnet new blazor --name MyFirstBlazorApp --
     
    </strong>
    
     <strong class="bold">
      
       interactivity Auto
      
     </strong>
    
   </p>
   <p class="callout">
    
     To learn more about this new
    
    <a id="_idIndexMarker135">
    </a>
    
     feature, access the following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0
      
     
    </a>
   </p>
   <p>
    
     After creating the project, just open the
    
    <strong class="source-inline">
     
      Pages
     
    </strong>
    
     folder, and you will then find some components as shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    
     <em class="italic">
      
       .12
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.12 – The Blazor project structure" src="img/B21788_02_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.12 – The Blazor project structure
    
   </p>
   <p>
    
     There are
    
    <a id="_idIndexMarker136">
    </a>
    
     components that are defined as pages and therefore have the
    
    <strong class="source-inline">
     
      @pages
     
    </strong>
    
     directive, where a route to access the page is defined.
    
    
     There are also components that are added
    
    
     
      to pages.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Counter.razor
     
    </strong>
    
     file is a page component and has the
    
    
     
      following content:
     
    
   </p>
   <pre class="source-code">
@page "/counter"
@attribute [RenderModeServer]
&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;
&lt;h1&gt;Counter&lt;/h1&gt;
&lt;p role="status"&gt;Current count: @currentCount&lt;/p&gt;
&lt;button class="btn btn-primary"
  @onclick="IncrementCount"&gt;Click me&lt;/button&gt;
@code {
    private int currentCount = 0;
    private void IncrementCount()
    {
        currentCount++;
    }
}</pre>
   <p>
    
     Note that there
    
    <a id="_idIndexMarker137">
    </a>
    
     is use of Razor and HTML syntax, as we learned in the Razor Pages and MVC approaches.
    
    
     There is also C# code between the
    
    <strong class="source-inline">
     
      @code {}
     
    </strong>
    
     
      tags.
     
    
   </p>
   <p>
    
     The C# code defined in the preceding file has the functionality to increment a counter when the user clicks on the
    
    <strong class="bold">
     
      Click
     
    </strong>
    
     <strong class="bold">
      
       me
      
     </strong>
    
    
     
      button.
     
    
   </p>
   <p>
    
     The HTML button tag has the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     attribute, which is defined with the name defined in the C#
    
    
     
      code block.
     
    
   </p>
   <p>
    
     For simple components, the approach of using HTML and C# code in the same file may be valid.
    
    
     However, it is good practice to separate business rules from the UI.
    
    
     Therefore, Blazor allows a file to be created containing the component’s
    
    
     
      C# code.
     
    
   </p>
   <p>
    
     In the preceding code example, there would be two files:
    
    <strong class="source-inline">
     
      Counter.razor
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Counter.razor.cs
     
    </strong>
    
     .
    
    
     All C# code could be moved to the new file generating the
    
    
     
      following class:
     
    
   </p>
   <pre class="source-code">
namespace MyFirstBlazorApp.Pages;
public partial class CounterPartialClass
{
    private int currentCount = 0;
    private void IncrementCount()
    {
        currentCount++;
    }
}</pre>
   <p>
    
     Blazor is very flexible and offers a huge range of possibilities for developing rich web-based applications, integrated with HTML, CSS, and JavaScript and using the most modern technologies.
    
    
     It would take an exclusive book to talk about Blazor, however; this book will focus on approaches based on Razor Pages
    
    
     
      and MVC.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 is very flexible when it comes to developing UIs, featuring different frameworks.
    
    
     But if you are familiar with Angular, React, or Vue.js, you can benefit from the power of the .
    
    
     
      NET platform.
     
    
   </p>
   <h2 id="_idParaDest-41">
    <a id="_idTextAnchor041">
    </a>
    
     ASP.NET Core 9 and JavaScript frameworks
    
   </h2>
   <p>
    
     As we learned during the other topics
    
    <a id="_idIndexMarker138">
    </a>
    
     in this chapter, ASP.NET Core 9 offers several approaches to building a UI, interacting with C# code.
    
    
     There are several related benefits, including the use of a common development model, using the Razor syntax, and all the benefits of the .
    
    
     
      NET platform.
     
    
   </p>
   <p>
    
     However, if you are used to using a framework for building SPAs, such as Angular, Vue.js, and React, the .NET platform has some templates available for
    
    
     
      this purpose:
     
    
   </p>
   <div><div><img alt="Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template" src="img/B21788_02_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      React and ASP.NET Core
     
    </strong>
    
     template
    
    <a id="_idIndexMarker139">
    </a>
    
     creates two projects, one for the frontend and the other for the
    
    
     
      application’s backend.
     
    
   </p>
   <p>
    
     SPAs use the approach where the UI is developed independently of the backend, which is generally an external service
    
    
     
      or application.
     
    
   </p>
   <p>
    
     When using the model offered by ASP.NET Core, there is also a clear separation between the UI and the backend.
    
    
     The project is already configured for integration with the web API developed in .NET.
    
    
     One of the great benefits of this is the convenience of publishing the UI and backend project in a single simple unit,
    
    
     
      facilitating publication:
     
    
   </p>
   <div><div><img alt="Figure 2.14 – ASP.NET Core React standalone project structure" src="img/B21788_02_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.14 – ASP.NET Core React standalone project structure
    
   </p>
   <p>
    
     Using project templates for
    
    <a id="_idIndexMarker140">
    </a>
    
     frameworks such as Angular, Vue.js, or React is completely optional.
    
    
     Even if the UI project is created independently, we can benefit from ASP.NET Core by developing web APIs to serve the UI.
    
    
     We’ll talk about creating web APIs in
    
    <a href="B21788_03.xhtml#_idTextAnchor044">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     As we can see, the platform offers several approaches for developing high-quality web-based systems.
    
    
     Each ASP.NET Core UI framework has several benefits that can be combined to generate even more powerful solutions, and we will look at these solutions in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-42">
    <a id="_idTextAnchor042">
    </a>
    
     Working with hybrid solutions
    
   </h1>
   <p>
    
     One of the great benefits of
    
    <a id="_idIndexMarker141">
    </a>
    
     working on a powerful platform such as ASP.NET Core is having the ability to integrate between technologies.
    
    
     Therefore, we can combine all the power of Razor Pages, MVC, and Blazor in the
    
    
     
      same project.
     
    
   </p>
   <p>
    
     In the case of integration with Blazor, there is the benefit of using
    
    <strong class="source-inline">
     
      .razor
     
    </strong>
    
     components,
    
    
     
      providing reusability.
     
    
   </p>
   <p>
    
     Blazor
    
    <a id="_idIndexMarker142">
    </a>
    
     integration into Razor Pages or MVC projects must be configured according to the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In the project root, add a file named
     
     <strong class="source-inline">
      
       _Imports.razor
      
     </strong>
     
      .
     
     
      This file will be responsible for importing the namespaces necessary for
     
     
      
       the project:
      
     
     <pre class="source-code">
@using System.Net.Http
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web
  .Virtualization
@using Microsoft.JSInterop
@using {CHANGE_FOR_THE_NAMESPACE_OF_YOUR_PROJECT}</pre>
     <p class="list-inset">
      
       Note that at the end of the file, there is a
      
      <strong class="source-inline">
       
        {CHANGE_FOR_THE_NAMESPACE_OF_YOUR_PROJECT}
       
      </strong>
      
       tag.
      
      
       Change this value to your
      
      
       
        project namespace.
       
      
     </p>
    </li>
    <li>
     
      Now, it will be necessary to change the
     
     <strong class="source-inline">
      
       _Layout.cshtml
      
     </strong>
     
      file, located in
     
     <strong class="source-inline">
      
       Pages/Shared
      
     </strong>
     
      directory in the case of the Razor Pages project or in the
     
     <strong class="source-inline">
      
       Views/Shared
      
     </strong>
     
      directory for MVC projects.
     
     
      Add the following code in the
     
     
      
       head element:
      
     
     <pre class="source-code">
&lt;base href="~/" /&gt;
&lt;component type="typeof(Microsoft.AspNetCore
  .Components.Web.HeadOutlet)"
    render-mode="ServerPrerendered" /&gt;</pre>
     <p class="list-inset">
      
       The purpose of defining
      
      <strong class="source-inline">
       
        &lt;base href="~/"/&gt;
       
      </strong>
      
       is to define the base path of the application, while the
      
      <strong class="source-inline">
       
        component
       
      </strong>
      
       tag is used to render the contents of the Razor components in the HTML
      
      
       
        head element.
       
      
     </p>
    </li>
    <li>
     
      Add the
     
     <a id="_idIndexMarker143">
     </a>
     
      following script before the
     
     <strong class="source-inline">
      
       @await RenderSection(...)
      
     </strong>
     
      
       render section:
      
     
     <pre class="source-code">
&lt;script src="img/blazor.server.js"&gt;&lt;/script&gt;</pre>
     <p class="list-inset">
      
       Don’t worry about the script path, much less creating it.
      
      
       This will be done automatically by
      
      
       
        the framework.
       
      
     </p>
    </li>
    <li>
     
      Now, open the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file to make some modifications.
     
     
      First, we must register the Blazor services so that they are available while the application is running.
     
     
      Add the
     
     
      
       following code:
      
     
     <pre class="source-code">
builder.Services.AddServerSideBlazor();</pre>
    </li>
    <li>
     
      You also need to add the Blazor route mapping control.
     
     
      Add the following line below the
     
     <strong class="source-inline">
      
       MapRazorPages
      
     </strong>
     
      call (in the case of a Razor Pages project) or the
     
     <strong class="source-inline">
      
       MapControllerRoute
      
     </strong>
     
      call (in the case of an
     
     
      
       MVC project):
      
     
     <pre class="source-code">
app.MapBlazorHub();</pre>
    </li>
   </ol>
   <p>
    
     Now that the project is integrated with Blazor, let’s create a component with the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a file called
     
     <strong class="source-inline">
      
       technology.razor
      
     </strong>
     
      in the
     
     <strong class="source-inline">
      
       Pages/Shared
      
     </strong>
     
      (Razor Pages) or
     
     <strong class="source-inline">
      
       Views/Shared
      
     </strong>
     
      (MVC) folder and add the
     
     
      
       following code:
      
     
     <pre class="source-code">
&lt;h1&gt;Load Technologies&lt;/h1&gt;
&lt;button class="btn btn-primary"
  @onclick="LoadTechnologies"&gt;Load&lt;/button&gt;
@if (technologies != null)
{
    &lt;ul&gt;
        @foreach(var tech in technologies)
        {
            &lt;li&gt;@tech&lt;/li&gt;
        }
    &lt;/ul&gt;
}
@code {
    private int currentCount = 0;
    private string[]? technologies;
    private void LoadTechnologies()
    {
        technologies = new[] { "Razor Pages",
          "MVC", "Blazor"};
    }
}</pre>
     <p class="list-inset">
      
       The preceding
      
      <a id="_idIndexMarker144">
      </a>
      
       code creates a
      
      <strong class="bold">
       
        Load
       
      </strong>
      
       button with a click event that will load a list of technologies.
      
      
       This list of technologies was created in the
      
      <strong class="source-inline">
       
        @code{}
       
      </strong>
      
       session, using an array of strings.
      
      
       When running the application, the screen will be similar to
      
      
       <em class="italic">
        
         Figure 2
        
       </em>
      
      
       <em class="italic">
        
         .15
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 2.15 – Page/View using the Blazor component" src="img/B21788_02_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.15 – Page/View using the Blazor component
    
   </p>
   <ol>
    <li value="2">
     
      To
     
     <a id="_idIndexMarker145">
     </a>
     
      use this component, add the following code to any MVC Razor page
     
     
      
       or View:
      
     
     <pre class="source-code">
&lt;component type="typeof(Counter)"
  render-mode="ServerPrerendered" /&gt;</pre>
    </li>
   </ol>
   <p>
    
     When running the application, simply use the component to obtain the expected result, as shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .16
     
    </em>
    
     .
    
    
     This component is reusable and can be added to any page or view, bringing greater flexibility and power to
    
    
     
      UI development:
     
    
   </p>
   <div><div><img alt="Figure 2.16 – Using a Blazor component with Razor Pages and MVC" src="img/B21788_02_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.16 – Using a Blazor component with Razor Pages and MVC
    
   </p>
   <p>
    
     Combining ASP.NET Core UI frameworks can bring benefits during the web-based application development process, using the best of
    
    
     
      each approach.
     
    
   </p>
   <h1 id="_idParaDest-43">
    <a id="_idTextAnchor043">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, you’ve delved into the rich world of the ASP.NET Core UI, gaining valuable insights into the available tools for crafting dynamic and engaging UIs.
    
    
     You’ve not only understood the key concepts and tools required for implementing a server-side UI, but you’ve also discovered the remarkable benefits of WebAssembly through Blazor, enabling you to create powerful SPAs in conjunction with ASP.NET Core.
    
    
     As you wrap up this chapter, you’ve learned how to seamlessly combine ASP.NET Core UI solutions.
    
    
     Now, with a solid foundation in place, I invite you to embark on the next exciting journey in
    
    <a href="B21788_03.xhtml#_idTextAnchor044">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     , where we’ll explore the world of web APIs and their pivotal role in delivering outstanding services.
    
    
     Get ready to take your skills to the
    
    
     
      next level!
     
    
   </p>
  </div>
 </body></html>