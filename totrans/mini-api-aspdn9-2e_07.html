<html><head></head><body>
  <div id="_idContainer045">
   <h1 class="chapter-number" id="_idParaDest-91">
    <a id="_idTextAnchor119">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     7
    </span>
   </h1>
   <h1 id="_idParaDest-92">
    <a id="_idTextAnchor120">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Dependency Injection in Minimal APIs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In any software project, developers rarely craft the application entirely from scratch.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     At some level, generic libraries and toolsets will be absorbed into the application to accelerate and optimize the project.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.4.1">
      ASP.NET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     as a
    </span>
    <a id="_idIndexMarker230">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     framework is no different.
    </span>
    <span class="koboSpan" id="kobo.6.2">
     In fact, it requires that developers take on dependencies; third-party or independently created code that plays a key role in the smooth running of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.7.1">
      the system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.8.1">
     The result is a (hopefully) finely tuned and well-designed architecture, formed of modules and components, some of which run code that was written by developers on the project, and the rest being more generic, boilerplate code that was written and pre-compiled before the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      project started.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.10.1">
     Keeping track of dependencies
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.11.1">
     is one of the classic problems facing software developers, and the problems that arise from this can progress to a point that results in what the industry refers to as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.12.1">
      dependency hell
     </span>
    </strong>
    <span class="koboSpan" id="kobo.13.1">
     – a
    </span>
    <a id="_idIndexMarker232">
    </a>
    <span class="koboSpan" id="kobo.14.1">
     nightmarish scenario in which developers are retracing their steps, trying to figure out where a dependency was introduced, and finding ways that they can overcome the challenge of conflicting dependencies across a potentially massive
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      code base.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.16.1">
      Dependency injection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.17.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.18.1">
      DI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.19.1">
     ) is a
    </span>
    <a id="_idIndexMarker233">
    </a>
    <span class="koboSpan" id="kobo.20.1">
     way of standardizing and simplifying the experience of consuming dependencies in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.21.1">
      software projects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     In this chapter, we are going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.23.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       Understanding DI
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      Configuring DI in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       minimal APIs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.27.1">
      DI
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.28.1">
       best practices
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     By the end of the chapter, you will have improved your understanding of DI principles, as well as the benefits they can bring to minimal APIs and ASP.NET projects
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      in general.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     You will also have gained practical experience in the configuration of DI containers and registration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      of services.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     Let us start by improving our understanding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      of DI.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-93">
    <a id="_idTextAnchor121">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     Understanding DI
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     DI
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     started out as a design pattern in software development, aimed at centralizing common dependencies and making them available to consumers in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      consistent manner.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     Using this approach, common development tasks such as testing, swapping out dependencies, modification of dependency logic, centralization of dependencies, and so on, can be easily achieved through one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      straightforward system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     Over time, .NET made DI more of a feature rather than just a design pattern.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     In ASP.NET, there is a robust DI toolset that is simple to use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      and understand.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Developers can register their dependencies in a centralized location, making them available to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.44.1">
      inject
     </span>
    </em>
    <span class="koboSpan" id="kobo.45.1">
     into the constructors of classes as arguments when they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      are instantiated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     With DI, dependencies live within a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.48.1">
      container
     </span>
    </em>
    <span class="koboSpan" id="kobo.49.1">
     , making them centrally available to consuming classes.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     But what is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      a container?
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor122">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     The DI container
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     On the startup of your application, dependencies are registered in the container.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.53.1">
      container
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     is simply
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.55.1">
     a group of dependencies that have been registered for DI.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     Each of the dependencies has a lifetime specification that defines how they are instantiated when injected into a
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     consuming class.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     We’ll explore dependency lifetimes in more detail later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      the chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     When a class that has a dependency is instantiated, it reaches out to the container, which takes care of the business of resolving the dependency and instantiating it according to the lifetime setting that was configured when the dependency
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.59.1">
      was registered.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     It might sound like this is an extra layer of complexity for something as simple as using a class within another, but there is good reason for mandating the use of DI as a best practice.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     Let us explore this in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      more detail.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-95">
    <a id="_idTextAnchor123">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     The case for DI
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     Think back to your
    </span>
    <a id="_idIndexMarker237">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     career to date as a software engineer.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     Whether you’re still at the beginning, or you’ve been doing this for a while, you may have spent considerable time
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.65.1">
      newing up
     </span>
    </em>
    <span class="koboSpan" id="kobo.66.1">
     dependencies in the form
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      of classes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     Let’s say you’re building an API endpoint that needs to reach into a SQL database.
    </span>
    <span class="koboSpan" id="kobo.68.2">
     (I’m deliberately not using Entity Framework for this example for simplicity.) You may have already created a class that abstracts away the specifics (we’ll call it
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.69.1">
      SqlHelper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     ), such as creating an instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      SqlConnection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     , opening the connection, building
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.73.1">
      SqlCommand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.74.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     What do you think you’ll need to do each time you realize that you need this
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.75.1">
       SqlHelper
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      class?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     The first thing you’ll notice is that you have to create a new instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      SqlHelper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     at any point that the need for interaction with your SQL Server arises.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     On the face of it, this sounds harmless enough, but from a design perspective, it’s problematic.
    </span>
    <span class="koboSpan" id="kobo.79.3">
     Let’s look at the potential pitfalls of this approach a little
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      more closely:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.81.1">
       Tight coupling
      </span>
     </strong>
     <span class="koboSpan" id="kobo.82.1">
      : Without
     </span>
     <a id="_idIndexMarker238">
     </a>
     <span class="koboSpan" id="kobo.83.1">
      DI, you create a concrete implementation of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.84.1">
       SqlHelper
      </span>
     </strong>
     <span class="koboSpan" id="kobo.85.1">
      each time you use it.
     </span>
     <span class="koboSpan" id="kobo.85.2">
      Whenever you have a concrete implementation of a class, you run the risk of being forced to change each class that consumes it if you need to significantly change
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.86.1">
       SqlHelper
      </span>
     </strong>
     <span class="koboSpan" id="kobo.87.1">
      .
     </span>
     <span class="koboSpan" id="kobo.87.2">
      This means that your consuming classes become tightly coupled
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.88.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.89.1">
        SqlHelper
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.90.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.91.1">
       Difficulties in testing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.92.1">
      : Being able to mock dependencies is critical to effective testing.
     </span>
     <span class="koboSpan" id="kobo.92.2">
      Without DI, you will have to be more hands-on in ensuring that dependencies are properly instantiated, mocked, and then accessible for each test.
     </span>
     <span class="koboSpan" id="kobo.92.3">
      The added need for manual instantiation increases the potential for mistakes in setting up the tests.
     </span>
     <span class="koboSpan" id="kobo.92.4">
      This is problematic because it can make your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.93.1">
       tests unreliable.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.94.1">
       Resource management issues
      </span>
     </strong>
     <span class="koboSpan" id="kobo.95.1">
      : When dependencies are using resources as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.96.1">
       SqlHelper
      </span>
     </strong>
     <span class="koboSpan" id="kobo.97.1">
      is (it will have a connection to a SQL Server), there is always the risk that those resources are not managed effectively.
     </span>
     <span class="koboSpan" id="kobo.97.2">
      In the case of something like a SQL connection, spinning up a lot of these connections over time without adequate disposal could exhaust the connections, leading to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.98.1">
       performance issues.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.99.1">
       Violation of single responsibility, open-closed principle, Liskov substitution, interface segregation principle, dependency inversion principle (SOLID) principles
      </span>
     </strong>
     <span class="koboSpan" id="kobo.100.1">
      : We’ve not yet explored SOLID principles in this book, but they are an important part of any object-oriented software system.
     </span>
     <span class="koboSpan" id="kobo.100.2">
      One of the guiding principles of SOLID
     </span>
     <a id="_idIndexMarker239">
     </a>
     <span class="koboSpan" id="kobo.101.1">
      is
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.102.1">
       single responsibility
      </span>
     </em>
     <span class="koboSpan" id="kobo.103.1">
      , in which we
     </span>
     <a id="_idIndexMarker240">
     </a>
     <span class="koboSpan" id="kobo.104.1">
      are expected to ensure that classes have a primary responsibility.
     </span>
     <span class="koboSpan" id="kobo.104.2">
      In the case of a class consuming
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.105.1">
       SqlHelper
      </span>
     </strong>
     <span class="koboSpan" id="kobo.106.1">
      , their primary responsibility is to the logic that is requesting or manipulating data.
     </span>
     <span class="koboSpan" id="kobo.106.2">
      Forcing the class to instantiate
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.107.1">
       SqlHelper
      </span>
     </strong>
     <span class="koboSpan" id="kobo.108.1">
      means you’re giving it a new responsibility; a responsibility of managing its own dependencies.
     </span>
     <span class="koboSpan" id="kobo.108.2">
      DI removes this added responsibility, simply passing the
     </span>
     <a id="_idIndexMarker241">
     </a>
     <span class="koboSpan" id="kobo.109.1">
      dependencies into the class when the class
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.110.1">
       is constructed.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     Hopefully, this breakdown has painted a picture of how not using DI can make your code base inconsistent and messy.
    </span>
    <span class="koboSpan" id="kobo.111.2">
     Now, let us explore how DI is achieved
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      in ASP.NET.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor124">
    </a>
    <span class="koboSpan" id="kobo.113.1">
     Configuring DI in minimal APIs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.114.1">
     As standard, ASP.NET
    </span>
    <a id="_idIndexMarker242">
    </a>
    <span class="koboSpan" id="kobo.115.1">
     offers a way for us to
    </span>
    <a id="_idIndexMarker243">
    </a>
    <span class="koboSpan" id="kobo.116.1">
     declare that a class we have created can be registered as a service.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     Converting a class into a service means it can be reused via DI.
    </span>
    <span class="koboSpan" id="kobo.116.3">
     For example, say you’ve got a piece of logic that calculates overtime pay for any given employee.
    </span>
    <span class="koboSpan" id="kobo.116.4">
     That logic is the same, but you’ll need it in many other areas of the code base.
    </span>
    <span class="koboSpan" id="kobo.116.5">
     To avoid writing the same logic again, it’s obvious that you would simply call on the same logic, but as we’ve already discussed, creating a new instance of the class to get to this logic whenever you need it is messy; so, by registering the class as a service, we can cleanly inject it into any other class that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      needs it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     Moreover, DI allows us to control the life cycle of the service when it is injected.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     In essence, we can dictate how the dependency is instantiated on each injection and how long it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      should exist.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     There are three built-in lifetime options
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      in ASP.NET:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.122.1">
       Singleton
      </span>
     </strong>
     <span class="koboSpan" id="kobo.123.1">
      : The service is created once, as a single instance.
     </span>
     <span class="koboSpan" id="kobo.123.2">
      This instance is then shared across the code
     </span>
     <a id="_idIndexMarker244">
     </a>
     <span class="koboSpan" id="kobo.124.1">
      base.
     </span>
     <span class="koboSpan" id="kobo.124.2">
      This can be useful when you need to maintain state on a global scale.
     </span>
     <span class="koboSpan" id="kobo.124.3">
      Logging is a good use case for this, as all log entries can be channeled through one single service that has access to the relevant output resource.
     </span>
     <span class="koboSpan" id="kobo.124.4">
      For example, a  logging service that creates logs in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.125.1">
       a file.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.126.1">
       Scoped
      </span>
     </strong>
     <span class="koboSpan" id="kobo.127.1">
      : The
     </span>
     <a id="_idIndexMarker245">
     </a>
     <span class="koboSpan" id="kobo.128.1">
      service is created once for every incoming request.
     </span>
     <span class="koboSpan" id="kobo.128.2">
      This means that when a client makes a request to the API, a service is created when needed and that instance is in use for the duration of the request.
     </span>
     <span class="koboSpan" id="kobo.128.3">
      This is ideal when you need to manage state within a request.
     </span>
     <span class="koboSpan" id="kobo.128.4">
      It is also favorable if you do not want to share the same service between
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.129.1">
       different requests.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.130.1">
       Transient
      </span>
     </strong>
     <span class="koboSpan" id="kobo.131.1">
      : The service
     </span>
     <a id="_idIndexMarker246">
     </a>
     <span class="koboSpan" id="kobo.132.1">
      has an instance created every time it is injected.
     </span>
     <span class="koboSpan" id="kobo.132.2">
      This means that regardless of the request being made to the API, each time a service is injected, that service will be a new instance.
     </span>
     <span class="koboSpan" id="kobo.132.3">
      This is ideal for scenarios where state does not need to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.133.1">
       be maintained.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.134.1">
     Let’s set up a new minimal API project to use as an example of how we can benefit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.135.1">
      from DI.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Please note, if you haven’t read them already, refer to the first two chapters to understand how you can create a new minimal API project.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     This will allow you to follow along with the examples in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      this chapter.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-97">
    <a id="_idTextAnchor125">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     Setting up a scoped DI project
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.139.1">
     For our new API project, we’re
    </span>
    <a id="_idIndexMarker247">
    </a>
    <span class="koboSpan" id="kobo.140.1">
     going to use the example of an order-processing API.
    </span>
    <span class="koboSpan" id="kobo.140.2">
     It will contain a series of products or services that can be put together to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      an order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     First, we need models to represent products and orders.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     Create two classes,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      Order
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     .
    </span>
    <span class="koboSpan" id="kobo.146.2">
     In the first code, we create the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.147.1">
       Product
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.149.1">
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public float RRP { get; set; }
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.150.1">
     In the following code, we create the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.151.1">
       Order
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.153.1">
    public class Order
    {
        public int Id { get; set; }
        public List&lt;Product&gt; Products { get; set; }
        public decimal DiscountAmount { get; set; }
        public DateTime DeliveryDate { get; set; }
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     We need to be able to refer to a collection of available products.
    </span>
    <span class="koboSpan" id="kobo.154.2">
     Ordinarily, we would store this information in a database and then use either
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.155.1">
      SqlConnection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     or an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.157.1">
      Object Relational Mapping
     </span>
    </strong>
    <span class="koboSpan" id="kobo.158.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.159.1">
      ORM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.160.1">
     ) framework, such as  Microsoft’s Entity Framework, to
    </span>
    <a id="_idIndexMarker248">
    </a>
    <span class="koboSpan" id="kobo.161.1">
     access
    </span>
    <a id="_idIndexMarker249">
    </a>
    <span class="koboSpan" id="kobo.162.1">
     the database, mapping the data to the models (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      Order
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     ) we’ve created.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     However, database connections are not within the scope of this chapter and will be covered later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.167.1">
      the book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.168.1">
     For now, and for simplicity, we will simply create a JSON file containing an array of objects that can be read into the project as text and deserialized into the strongly typed object,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.169.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     .
    </span>
    <span class="koboSpan" id="kobo.170.2">
     I’ve created an example of five products that can be saved in JSON format, in the following code.
    </span>
    <span class="koboSpan" id="kobo.170.3">
     Feel free to copy my examples or create your own.
    </span>
    <span class="koboSpan" id="kobo.170.4">
     Whatever you do, save the products in a file called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      Products.json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     in an accessible location.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     Ensure that each project is a JSON object contained within a single JSON array and that the values you use match the data types of the properties in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.173.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     ; otherwise, it will not be possible to deserialize
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      the JSON:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.176.1">
[
    {
        "Id": 1,
        "Name": "Laptop",
        "Description": "A high-performance laptop suitable
                       for all your computing needs.",
        "RRP": 999.99
    },
    {
        "Id": 2,
        "Name": "Smartphone",
        "Description": "A latest generation smartphone with
                       a stunning display and excellent
                       camera.",
        "RRP": 799.99
    },
    {
        "Id": 3,
        "Name": "Headphones",
        "Description": "Noise-cancelling headphones with
                       superior sound quality.",
        "RRP": 199.99
    },
    {
        "Id": 4,
        "Name": "Smartwatch",
        "Description": "A smartwatch with fitness tracking
                       and health monitoring features.",
        "RRP": 299.99
    },
    {
        "Id": 5,
        "Name": "Tablet",
        "Description": "A lightweight tablet with a vibrant
                       display, perfect for entertainment
                       on the go.",
        "RRP": 399.99
    }
]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     Now, let’s create a means of bringing these objects into memory when they are needed.
    </span>
    <span class="koboSpan" id="kobo.177.2">
     (Again, not the most efficient example as we’re not using a database, but we will be covering database usage later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      the book.)
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     For this example, we’ll
    </span>
    <a id="_idIndexMarker250">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     do this by creating a class, called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     .
    </span>
    <span class="koboSpan" id="kobo.182.2">
     This class can be used to access a list of objects of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      type
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.184.1">
       Product
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     Add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     class as per the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      example here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.190.1">
public class ProductRepository
{
    public List&lt;Product&gt; Products { get; private set; }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     As you can see, this
    </span>
    <a id="_idIndexMarker251">
    </a>
    <span class="koboSpan" id="kobo.192.1">
     is a very simple class that just holds a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     .
    </span>
    <span class="koboSpan" id="kobo.194.2">
     We need to somehow populate this list with the JSON objects we’ve saved as text.
    </span>
    <span class="koboSpan" id="kobo.194.3">
     We could very easily just fetch the items when we instantiate the class, but we want to do this using an injected service, so we’ll come back to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     shortly.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     Before that, let’s create a service that will have the responsibility of retrieving the products from the text file.
    </span>
    <span class="koboSpan" id="kobo.196.3">
     We’ll call
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      it
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.198.1">
       ProductRetrievalService
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.199.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.200.1">
    public class ProductRetrievalService
    {
        private const string _dataPath =
            @"C:/Products.json";
        public List&lt;Product&gt; LoadProducts()
        {
            var productJson = File.ReadAllText(_dataPath);
            return JsonSerializer
                .Deserialize&lt;List&lt;Product&gt;&gt;(
                    productJson
                );
        }
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.201.1">
     This simple service reads the contents of the JSON file and uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      JsonSerializer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     class found within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      System.Text.Json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     to convert, or deserialize, the JSON content into the strongly typed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     type, putting each
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      the list.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.211.1">
     Permissions on C:/
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.212.1">
     If you have trouble writing or reading from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      C:/
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     , you may not have permission to do so.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     You can work around this by creating a folder in a location to which you do have read/write permissions, and then change the path in the code to match the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      new one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     At this point, the products have been retrieved.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     This means that we can simply call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      LoadProducts()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     and we will always get the latest data.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     However, how do we access
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     to do this?
    </span>
    <span class="koboSpan" id="kobo.220.2">
     Our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     class will need this logic in order to populate its
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.223.1">
       Product
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      list.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     Here is where DI becomes useful.
    </span>
    <span class="koboSpan" id="kobo.225.2">
     We can inject an instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     any time we use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     .
    </span>
    <span class="koboSpan" id="kobo.229.2">
     To make this possible, we first need to register
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      ProductRetreivalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      a service.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.233.1">
     The following code
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.234.1">
     demonstrates registration of this service for DI
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      within
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.236.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.238.1">
public static void Main(string[] args)
{
    var builder = WebApplication.CreateBuilder(args);
    builder.Services.AddScoped&lt;ProductRetrievalService&gt;();
    var app = builder.Build();
    app.Run();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     By adding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.240.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.241.1">
     as a scoped service, an instance will be created for the duration of the incoming request.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     Now that it is registered, we can inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     when we instantiate it, via its constructor.
    </span>
    <span class="koboSpan" id="kobo.245.2">
     Let us look at an example of this in an API
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.246.1">
      endpoint example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.247.1">
     Create a new HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     method, mapped onto the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      getProductById
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     route, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.253.1">
    app.MapGet("/getProductById/{id}", (int id) =&gt;
    {
    });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     The endpoint takes an integer parameter in the form of the product ID.
    </span>
    <span class="koboSpan" id="kobo.254.2">
     We can now use this to get the product with the matching ID.
    </span>
    <span class="koboSpan" id="kobo.254.3">
     First things first, let’s add a new instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.255.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.256.1">
     to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      the endpoint:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.258.1">
  app.MapGet("/getProductById{id}", (int id) =&gt;
  {
      var productRepository = new ProductRepository();
  });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     We have a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.260.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.261.1">
     instance now, which has a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     , but this list is empty.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     We need
    </span>
    <a id="_idIndexMarker253">
    </a>
    <span class="koboSpan" id="kobo.264.1">
     to modify
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     to inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.267.1">
      ProductRetreivalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.268.1">
     , to populate that list.
    </span>
    <span class="koboSpan" id="kobo.268.2">
     The following code shows an example of how the service can be injected into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.269.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.270.1">
     via the constructor before being used to populate the products held within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      a
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.272.1">
       List&lt;Product&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.274.1">
public class ProductRepository
{
    public List&lt;Product&gt; Products { get; private set; }
    public ProductRepository(
        ProductRetrievalService productRetrievalService
    )
    {
        Products = productRetrievalService.LoadProducts();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.275.1">
     Now, we should be able to use some logic in the endpoint to get the relevant product from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.276.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.277.1">
     .
    </span>
    <span class="koboSpan" id="kobo.277.2">
     However, we have a problem.
    </span>
    <span class="koboSpan" id="kobo.277.3">
     If we try to instantiate a new instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     in the endpoint, we will see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      an error.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.281.1">
     The reason we see an error is that we have changed the way
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.282.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.283.1">
     is instantiated.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     It now requires a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     to be passed as an argument to the constructor, but how are we supposed to get hold
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      of this?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     This is where minimal APIs allow us to, within an endpoint, take advantage of services registered within the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      DI container.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      ProductRetreivalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     can be passed as an argument within the parameters we pass into the lambda expression within the body of the endpoint.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     This makes it the same as the ID parameter passed in by the client, except it’s not coming from the client, it’s coming from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      DI container.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.292.1">
     To make this possible, you
    </span>
    <a id="_idIndexMarker254">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     need to prefix the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     argument with an attribute that indicates that it was injected.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     This attribute
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      is
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.297.1">
       [FromServices]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     Injecting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.300.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     with this attribute will now allow us to pass the required
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.302.1">
      ProductRetrievalService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     to the constructor of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.304.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.305.1">
     , as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.307.1">
app.MapGet("/getProductById/{id}",
    (
        int id,
        [FromServices] ProductRetrievalService
            productRetrievalService
    ) =&gt;
    {
    var productRepository = new ProductRepository(
        productRetrievalService
    );
    return Results.Ok(
        productRepository.Products
            .FirstOrDefault(x =&gt; x.Id == id)
    );
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     It is also worth
    </span>
    <a id="_idIndexMarker255">
    </a>
    <span class="koboSpan" id="kobo.309.1">
     noting that the instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      ProductRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     we created in this example could itself be injected into the class
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      using DI.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.313.1">
     Let’s move on to our next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      example now.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor126">
    </a>
    <span class="koboSpan" id="kobo.315.1">
     Creating a singleton DI project
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     Let’s look at another example, but
    </span>
    <a id="_idIndexMarker256">
    </a>
    <span class="koboSpan" id="kobo.317.1">
     this time, we’ll use a different life cycle for the dependency.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     In this use case, we will create an endpoint for creating an order.
    </span>
    <span class="koboSpan" id="kobo.317.3">
     The incoming
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      Order
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     object will have a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     that can be used to submit a new customer order into the system.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     However, we also need to establish a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      delivery date.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.323.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.324.1">
     To avoid repeating ourselves, we can for this example, simply use a collection such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      List&lt;DateTime&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     rather than feeding them in from a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      JSON file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.328.1">
     Let’s imagine that there is a feed of upcoming available dates that are centrally managed.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     We could create a service that has the available context to be able to choose the next available date.
    </span>
    <span class="koboSpan" id="kobo.328.3">
     This decouples the logic from the endpoint and can be reused in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      other endpoints.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.330.1">
     The code shows an example of this kind
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.331.1">
      of service:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.332.1">
public class DeliveryDateBookingService
{
    private ConcurrentQueue&lt;DateTime&gt;
        _availableDates = new ConcurrentQueue&lt;DateTime&gt;();
    public DeliveryDateBookingService()
    {
        _availableDates.Enqueue(DateTime.Now.AddDays(1));
        _availableDates.Enqueue(DateTime.Now.AddDays(2));
        _availableDates.Enqueue(DateTime.Now.AddDays(3));
        _availableDates.Enqueue(DateTime.Now.AddDays(4));
        _availableDates.Enqueue(DateTime.Now.AddDays(5));
    }
    public DateTime GetNextAvailableDate()
    {
        if(_availableDates.Count == 0)
        {
            throw new Exception("No Dates Available");
        }
        var dequeuedDate = _availableDates
            .TryDequeue(out var result);
        if (dequeuedDate == false)
        {
            throw new Exception("An error occured");
        }
        return result;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     This service allows requests to get the next available date, throwing an exception if there is no date available.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     We have a queue to hold the available dates so they can be removed as they are retrieved to ensure that the same date is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.334.1">
      offered twice.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     We also must consider thread safety here.
    </span>
    <span class="koboSpan" id="kobo.335.2">
     You could have multiple requests all trying to get an available date, which is very likely to lead to a race condition, where two requests end up dequeuing the same available date.
    </span>
    <span class="koboSpan" id="kobo.335.3">
     To avoid this, we are using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      ConcurrentQueue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     , which will handle the business of ensuring thread safety
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      between requests.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     We now need to register this
    </span>
    <a id="_idIndexMarker257">
    </a>
    <span class="koboSpan" id="kobo.340.1">
     as a service that can be injected into the endpoint that posts the order.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     With multiple requests in mind, we want to ensure that all requests are retrieving dates from the same list.
    </span>
    <span class="koboSpan" id="kobo.340.3">
     Therefore, we will register the service using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.341.1">
      AddSingleton()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.342.1">
     , which will ensure that only one instance of the service is used between threads and requests
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.343.1">
      during injection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.344.1">
     Once the service has been registered in this way,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     should look like the code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.348.1">
public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication
                .CreateBuilder(args);
            builder.Services
                .AddScoped&lt;ProductRetrievalService&gt;();
            builder.Services
                .AddSingleton&lt;DeliveryDateBookingService&gt;()
                ;
            var app = builder.Build();
            app.MapGet("/getProductById/{id}",
                (int id,
                [FromServices] ProductRetrievalService
                productRetreivalService) =&gt;
            {
                var productRepository = new
                    ProductRepository(
                        productRetreivalService
                );
                return Results.Ok(
                    productRepository.Products
                        .FirstOrDefault(
                            x =&gt; x.Id == id)
                );
            });
            app.Run();
        }
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.349.1">
     Now that the API has our second service registered, it is time to create the endpoint for creating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.350.1">
      an order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     Seeing as we are creating a new record, we should use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.352.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     method to achieve our goal.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.354.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.355.1">
     method will take in a JSON object, which is implicitly parsed into an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.356.1">
      Order
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     object within the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.358.1">
      endpoint parameter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.359.1">
     Following this, we indicate
    </span>
    <a id="_idIndexMarker258">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     that we are injecting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      DeliveryDateBookingService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      the request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.364.1">
     Once this is done, we can complete the endpoint by adding the relevant logic to the body of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      lambda expression.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     The endpoint with logic for fetching the next delivery date is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.368.1">
  app.MapPost(
      "/order",
      (Order order,
       [FromServices] DeliveryDateBookingService
       deliveryDateBookingService) =&gt;
  {
      order.DeliveryDate =
          deliveryDateBookingService.GetNextAvailableDate()
          ;
      // save order to repository
  });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     Whilst we created a repository for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.370.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     , we have not yet created one for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.372.1">
      Order
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     .
    </span>
    <span class="koboSpan" id="kobo.373.2">
     Furthermore, we did not demonstrate saving entities to their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.374.1">
      respective repositories.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.375.1">
     This kind of logic will be covered later in the book as we explore design patterns (such as the repository pattern) and data sources, but for now, here is an example of how you can save the new order in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.376.1">
      preceding endpoint:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.377.1">
      Create an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.378.1">
       OrderRetreivalService
      </span>
     </strong>
     <span class="koboSpan" id="kobo.379.1">
      class so we stay consistent in using a service to retrieve entities (as we did
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.380.1">
       for products):
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.381.1">
public class OrderRetrievalService
{
    private const string _dataPath =
        @"C:/Orders.json";
    public List&lt;Order&gt; LoadOrders()
    {
        var ordersJson = File.ReadAllText(_dataPath);
        return JsonSerializer
            .Deserialize&lt;List&lt;Order&gt;&gt;(ordersJson);
    }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.382.1">
      Register
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.383.1">
       OrderRetrievalService
      </span>
     </strong>
     <span class="koboSpan" id="kobo.384.1">
      as a scoped service in the DI container
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.385.1">
       within
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.386.1">
        Program.cs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.387.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.388.1">
            builder.Services
                .AddScoped&lt;OrderRetrievalService&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.389.1">
      Create an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.390.1">
       OrderRespository
      </span>
     </strong>
     <span class="koboSpan" id="kobo.391.1">
      class that follows the same style as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.392.1">
       ProductRespository
      </span>
     </strong>
     <span class="koboSpan" id="kobo.393.1">
      .
     </span>
     <span class="koboSpan" id="kobo.393.2">
      The added difference is that a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.394.1">
       SaveOrder()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.395.1">
      method is added to allow
     </span>
     <a id="_idIndexMarker259">
     </a>
     <span class="koboSpan" id="kobo.396.1">
      for saving the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.397.1">
       Order
      </span>
     </strong>
     <span class="koboSpan" id="kobo.398.1">
      from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.399.1">
       POST
      </span>
     </strong>
     <span class="koboSpan" id="kobo.400.1">
      endpoint.
     </span>
     <span class="koboSpan" id="kobo.400.2">
      Also, the collection being used to hold the orders is
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.401.1">
       ConcurrentQueue&lt;Order&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.402.1">
      rather than a list.
     </span>
     <span class="koboSpan" id="kobo.402.2">
      This is because we expect orders to be saved from multiple concurrent requests and we need to allow for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.403.1">
       thread safety:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.404.1">
public class OrderRepository
{
    public ConcurrentQueue&lt;Order&gt;
        Orders { get; private set; }
    public OrderRepository(
        OrderRetrievalService orderRetrievalService)
    {
        var retrievedOrders =
            orderRetrievalService.LoadOrders();
        foreach (var order in retrievedOrders)
        {
            Orders.Enqueue(order);
        }
    }
    public void SaveOrder(Order order)
    {
        Orders.Enqueue(order);
    }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.405.1">
      Register
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.406.1">
       OrderRepository
      </span>
     </strong>
     <span class="koboSpan" id="kobo.407.1">
      as a singleton service in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.408.1">
       Program.cs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.409.1">
      so that we can always add to it on a single
     </span>
     <a id="_idIndexMarker260">
     </a>
     <span class="koboSpan" id="kobo.410.1">
      instance regardless of how many requests are
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.411.1">
       saving orders:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.412.1">
            builder.Services
                .AddSingleton&lt;OrderRepository&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.413.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.414.1">
       POST
      </span>
     </strong>
     <span class="koboSpan" id="kobo.415.1">
      endpoint
     </span>
     <a id="_idIndexMarker261">
     </a>
     <span class="koboSpan" id="kobo.416.1">
      can now be updated to inject
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.417.1">
       OrderRepository
      </span>
     </strong>
     <span class="koboSpan" id="kobo.418.1">
      and to use it for saving the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.419.1">
       incoming order:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.420.1">
  app.MapPost(
      "/order",
      (Order order,
       [FromServices] DeliveryDateBookingService
       deliveryDateBookingService,
       [FromServices] OrderRepository
       orderRepository) =&gt;
      {
          order.DeliveryDate =
              deliveryDateBookingService
                  .GetNextAvailableDate();
          orderRepository.SaveOrder(order);
  });</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.421.1">
     Now that you have some experience creating dependencies as services and registering them for injection, let’s go over some basic best practices for using DI in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.422.1">
      minimal APIs.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor127">
    </a>
    <span class="koboSpan" id="kobo.423.1">
     DI best practices
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     DI is integral to
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.425.1">
     most ASP.NET projects, and minimal APIs are
    </span>
    <a id="_idIndexMarker263">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     often particularly reliant on them.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     As a result, it’s important to ensure that we are following best practices when it comes to dependencies and the methods of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      accessing them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     There are some simple rules of thumb when it comes to implementing DI in minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.428.2">
     We look at these rules in the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      few sections.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor128">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     Avoiding the service locator pattern
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     There is an anti-pattern in minimal
    </span>
    <a id="_idIndexMarker264">
    </a>
    <span class="koboSpan" id="kobo.432.1">
     APIs known as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.433.1">
      service locator pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     .
    </span>
    <span class="koboSpan" id="kobo.434.2">
     In this pattern, instead of explicitly injecting your
    </span>
    <a id="_idIndexMarker265">
    </a>
    <span class="koboSpan" id="kobo.435.1">
     dependency, you inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.436.1">
      IServiceProvider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     containing the dependency, and then you fish the service out of it within the body of your method
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      or function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.439.1">
     An example of the service locator pattern is shown in the following code, in which the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.440.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.441.1">
     method we made for creating orders is altered to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.442.1">
      use
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.443.1">
       IServiceProvider
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.444.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.445.1">
  app.MapPost(
      "/order",
      (Order order,
       IServiceProvider provider) =&gt;
      {
          var deliveryDateBookingService =
              provider.GetService
                  &lt;DeliveryDateBookingService&gt;();
          order.DeliveryDate =
              deliveryDateBookingService
                  .GetNextAvailableDate();
      // save order to repository in same way we did for
      // Product using ProductRepository
  });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     A significant drawback to this practice is that it makes the code harder to read.
    </span>
    <span class="koboSpan" id="kobo.446.2">
     It is less obvious from the parameter that you are injecting specific services, and you have to write extra lines of code to get the service
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.447.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.448.1">
       IServiceProvider
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.449.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     It also makes it more difficult to write unit tests for your endpoints, because it is less clear which objects you need to instantiate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      for mocking.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     Probably the
    </span>
    <a id="_idIndexMarker266">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     most destructive aspect of this anti-pattern is the potential for runtime failures to be hard to diagnose.
    </span>
    <span class="koboSpan" id="kobo.453.2">
     When injecting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      IServiceProvider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.455.1">
     , the compiler doesn’t know if the service you actually need is registered, whereas if you
    </span>
    <a id="_idIndexMarker267">
    </a>
    <span class="koboSpan" id="kobo.456.1">
     attempt to explicitly inject your service and it isn’t registered, it will become apparent much more quickly, allowing for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      easier debugging.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-101">
    <a id="_idTextAnchor129">
    </a>
    <span class="koboSpan" id="kobo.458.1">
     Registering services with an extension method
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     You can make your
    </span>
    <a id="_idIndexMarker268">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     code more readable by creating an extension
    </span>
    <a id="_idIndexMarker269">
    </a>
    <span class="koboSpan" id="kobo.461.1">
     method on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.462.1">
      IServiceCollection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     .
    </span>
    <span class="koboSpan" id="kobo.463.2">
     This means that within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     , you can register all your services with just one line of code or group your services together in an appropriate way and register
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.466.1">
      each group.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.467.1">
     Here is an example of how you can write such an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.468.1">
      extension method:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.469.1">
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddMyServices(
        this IServiceCollection services)
    {
        services.AddScoped&lt;IMyService, MyService&gt;();
        services.AddSingleton&lt;IOtherService,
            OtherService&gt;();
        return services;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.470.1">
     After implementing the extension method, you can simply write the following in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     to register
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      all services:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.474.1">
builder.Services.AddMyServices();</span></pre>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor130">
    </a>
    <span class="koboSpan" id="kobo.475.1">
     Using sensible service lifetimes
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.476.1">
     When registering services, it is
    </span>
    <a id="_idIndexMarker270">
    </a>
    <span class="koboSpan" id="kobo.477.1">
     important to consider the lifetime you are assigning to them.
    </span>
    <span class="koboSpan" id="kobo.477.2">
     Here are some examples of when you would use each
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.478.1">
      service lifetime:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.479.1">
       Transient
      </span>
     </strong>
     <span class="koboSpan" id="kobo.480.1">
      : Use
     </span>
     <a id="_idIndexMarker271">
     </a>
     <span class="koboSpan" id="kobo.481.1">
      this lifetime if your service is lightweight, stateless, and is only to be used for a short period
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.482.1">
       of time.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.483.1">
       Scoped
      </span>
     </strong>
     <span class="koboSpan" id="kobo.484.1">
      : Use this lifetime when your service must maintain state within a single request, and the state
     </span>
     <a id="_idIndexMarker272">
     </a>
     <span class="koboSpan" id="kobo.485.1">
      needs to be unique to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.486.1">
       current request.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.487.1">
       Singleton
      </span>
     </strong>
     <span class="koboSpan" id="kobo.488.1">
      : Use this lifetime
     </span>
     <a id="_idIndexMarker273">
     </a>
     <span class="koboSpan" id="kobo.489.1">
      when your service must maintain state across the whole application.
     </span>
     <span class="koboSpan" id="kobo.489.2">
      It is also useful for situations where you need to create heavy services that are costly to create.
     </span>
     <span class="koboSpan" id="kobo.489.3">
      Creating them once reduces
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.490.1">
       the overhead.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     Making the
    </span>
    <a id="_idIndexMarker274">
    </a>
    <span class="koboSpan" id="kobo.492.1">
     effort to follow best practices when creating and managing dependencies is a long-term investment, and is a selfless act, ensuring that the code base is easy to maintain for other developers in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.493.1">
      the future.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.494.1">
     Let’s summarize what we’ve covered in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.495.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor131">
    </a>
    <span class="koboSpan" id="kobo.496.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     We started the chapter by exploring DI from a high level, gaining an understanding of the benefits it brings to minimal APIs by encouraging good design, loose coupling, and reusability across the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      code base.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     We then looked at how dependencies can be created in the form of services, before being registered for injection, using the example of an order
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      processing API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     It was demonstrated that parameter attributes can be used within a minimal API endpoint to inject services into the scope of an endpoint’s execution, and we covered the various lifetimes available to services when they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.502.1">
      are registered.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     Finally, some best practices were outlined, helping you to ensure that your use of DI is productive, efficient, sustainable, and testable, whilst also being easy to read for other developers who may be less familiar with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      the project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.505.1">
     DI is a fundamental aspect of not only minimal APIs but software engineering in general.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     Having a good grounding in it will be essential for your success as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      a developer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     In this chapter, we also used some pretty unorthodox methods of storing and reading in data for use within the example API endpoints.
    </span>
    <span class="koboSpan" id="kobo.507.2">
     There is good reason for this.
    </span>
    <span class="koboSpan" id="kobo.507.3">
     Normally, we would use more standardized data sources to host and retrieve entities, which is something we are going to explore in detail in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.508.1">
      next chapter.
     </span>
    </span>
   </p>
  </div>
 </body></html>