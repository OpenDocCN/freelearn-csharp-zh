- en: Chapter 8. Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xamarin.Forms is an extension module to Xamarin compiler technologies; an abstraction
    layer on top of the native UI components on target platforms. This chapter will
    focus on the various features and extensibility options of Xamarin.Forms that
    help developers create cross-platform application user interfaces that can then
    be compiled into Xamarin projects, increasing the code-sharing quality markers,
    and making cross-platform application development projects more manageable and
    unified. This chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, Xamarin, being a cross-platform development framework,
    provides developers the toolset to create applications that depend on and use
    the same code base. The shared amount of code is directly proportional to the
    manageability in these types of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms adds an abstraction layer on top of the mono runtime on Android
    and the pre-compiler .NET stack on iOS platforms. This abstraction layer's sole
    responsibility is to provide the Xamarin compilers with the necessary instructions
    to normalize the code or markup for GUI elements to render native controls in
    Xamarin apps. Since the platform language for Xamarin is C#, **Extensible Application
    Markup Language** (**XAML**) is the design markup language of choice. Xamarin.Forms
    provides the same abstraction as a runtime library for Windows Store applications.
  prefs: []
  type: TYPE_NORMAL
- en: The abstraction layer provided by Xamarin.Forms makes use of the similar UI
    elements and layout patterns which were illustrated in the previous chapter (see
    [Chapter 7](ch07.html "Chapter 7. View Elements"), *View Elements*). In this context,
    Xamarin.Forms only provides controls and views that are common to all three platforms
    and omits platform-specific UI elements. It is important to understand that Xamarin.Forms
    is not a replacement for a native user interface implementation, but more of a
    foundation to build upon while creating cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Under the hood](img/B04693_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Xamarin.Forms abstraction layer'
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms not only provides a uniform native UI development framework, but
    also additional features that are generally associated with loosely-coupled UI
    development, such as data binding, dependency injection, and messenger infrastructure.
    To a certain extent, these features render third-party MVVM libraries used in
    various mobile application projects obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of Xamarin.Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Forms libraries are distributed through NuGet packages and can be freely
    included in cross-platform development projects.
  prefs: []
  type: TYPE_NORMAL
- en: Whilst the NuGet package for iOS does not present any dependencies, the Android
    and Windows Phone versions depend on several support libraries (that is, WPToolKit
    for Windows Phone; and several design and compatibility packages for Android).
  prefs: []
  type: TYPE_NORMAL
- en: The Xamarin.Forms.Core library contains the UI elements and the necessary XAML
    declarations together with additional features related to data binding and similar
    operations. This assembly can be included in portable class library projects that
    provide the view implementation to platform-specific projects. Native client projects,
    in return, should reference Xamarin.Forms.Core and the platform-specific assemblies
    of Xamarin.Forms (for example, Xamarin.Forms.Platform.iOS). Xamarin.Forms platform
    libraries contain the so-called renderer implementations that are responsible
    for rendering Xamarin.Form elements using native controls. In other words, these
    platform assemblies provide the mapping between native elements and their Xamarin.
    Forms counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a Xamarin.Forms application project targeting iOS, Android,
    and/or Windows Phone 8, it is sufficient to use one of the project templates located
    in the **Cross-Platform** section. While the portable library project template
    makes use of a PCL to create the Xamarin.Forms application boilerplate, the shared
    project template creates a shared project with file references linked to the native
    client app projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/B04693_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Xamarin.Forms project templates'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Project templates can be found in the **Mobile Apps** section in older versions
    of Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is initialized, by selecting the **Blank App (Xamarin.Forms
    Portable)** project template, the created solution will include four projects,
    one project carrying the same name as the entered project name and three platform-specific
    projects with the platform suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/B04693_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Xamarin.Forms solution main view and project scopes'
  prefs: []
  type: TYPE_NORMAL
- en: One caveat of using this project template for Xamarin.Forms is the fact that
    other platforms that are actually supported by this framework (for example, Windows
    Phone 8.1 and Windows 10) are not included in this multi-project template. These
    projects can be created manually, and the NuGet package for Xamarin.Forms can
    be added using the NuGet package manager. It is also important to mention that
    the NuGet package referenced in the project template might not be the latest version
    of Xamarin.Forms and therefore can be updated using the NuGet package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/B04693_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: The latest NuGet package for Xamarin.Forms'
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the generated code in the portable library, `App.cs`,
    and the platform-specific projects, the implementation pattern immediately becomes
    apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Xamarin.Forms implementation contains the application class implementation
    as the root node. This application is initialized and invoked by the generated
    code in the app delegates in platform-specific projects (similar to the following
    code excerpt from the Xamarin.Forms iOS application sample):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization code for the app in the template boilerplate creates a content
    page with a single label in a `StackLayout` element and designates this view as
    the main page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Xamarin.Forms application structure is made up of controls
    wrapped in different layout configurations that are presented through various
    page types.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin.Forms components can be categorized into three main groups according
    to their position in the view hierarchy and their usage.
  prefs: []
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conceptually, pages are navigational elements. They provide a general hierarchical
    organization of the view elements whilst also acting as a container for the layouts.
    There are various page types that can be inherited and implemented or designed
    using XAML markups.
  prefs: []
  type: TYPE_NORMAL
- en: Tabbed page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When discussing the top-level navigation pages in the previous chapter, we mentioned
    several controls that can provide horizontal navigation throughout top-level pages.
    Using Xamarin.Forms, `TabbedPage` allows developers to create these horizontal
    navigational view elements. `TabbedPage` generates a tabbed action bar and associated
    activities on Android. On Windows Phone, the generated view contains a pivot control.
    Finally on iOS, generated view contains a tab bar and associated views.
  prefs: []
  type: TYPE_NORMAL
- en: '`TabbedPage` contains the navigation pages as its children (that is, the `Children`
    property accepts different page implementations), and the page titles of the child
    elements are used as navigation links.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the tabbed view example from the previous chapter for our TravelTrace
    application would look similar to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The same implementation can be done using XAML and creating a `TabbedPage`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning the newly created `MainTabView` class instance to `MainPage` in `App.cs`
    would result in the same view as the code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tabbed page](img/B04693_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: TabbedPage view'
  prefs: []
  type: TYPE_NORMAL
- en: It is important here to mention that the `Icon` property provided for individual
    peers in a `TabbedPage` implementation only applies to the iOS platform. Icons
    in tab and pivot views are not supported by Xamarin and it is not an accepted
    design approach for Android and Windows Phone.
  prefs: []
  type: TYPE_NORMAL
- en: The MasterDetail page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example with the tabbed view satisfies the horizontal navigation requirements
    of our design, but we also need a navigation drawer and associated main menu navigation
    items for our Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`MasterDetailPage` provides a structure in which the master page selection
    menu can initiate a navigation request on the detail page. Moreover, if the content
    of the `Detail` page is encapsulated in a `NavigationPage`, the generated view
    is added to the navigation stack so that the previously displayed pages can easily
    be pulled into the master view using the event methods. In order to include an
    additional layer of navigation and a global menu, we can now use the `MasterDetailPage`
    class to create the desired navigation structure.'
  prefs: []
  type: TYPE_NORMAL
- en: The first step of the implementation is to create our master view. The master
    view in this case will include a simple list view with menu and a profile display
    as the list header. When the list view content items are selected, we can either
    bubble up the event to the `MasterDetailPage` or pass the parent page as a parameter
    to the menu page we are implementing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we are using a `Tuple` with three parameters for the
    label, tag, and icon of the menu item. It would, of course, be better to implement
    a class to contain these data values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can construct our `MasterDetailPage` by setting the `Master` and `Detail`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`MasterBehavior` can be adjusted according to the platform. In this example,
    we will be using the popover behavior, which displays a flyout and a toggle button
    in the main app bar on Android and creates a navigation command icon to open the
    flyout on other platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MasterDetail page](img/B04693_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Navigation flyout on Android and Windows Phone'
  prefs: []
  type: TYPE_NORMAL
- en: When using `MasterDetailPage`, it is important to anticipate the outcome of
    the design decisions made in Xamarin.Forms markups so that final applications
    for the target platforms still follow the design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: NavigationPage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NavigationPage` is the most abstract implementation of the `Page` class. The
    main purpose of using NavigationPage is to create a navigational stack in the
    application context. This navigational context is supported natively on Windows
    Phone. However, other platforms do not create a stack for previously viewed pages.
    Using `NavigationPage`, one can utilize the items in the navigational history
    and manipulate the stack using push and pop methods.'
  prefs: []
  type: TYPE_NORMAL
- en: CarouselPage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CarouselPage` is another horizontal navigation implementation that the user
    can use to navigate through the peer pages using swipe or flick gestures. `CarouselPage`
    is very similar to the panorama view and pivot controls from the Windows Phone
    7 platform, except for the fact that `CarouselPage` has strict snap points (that
    is, when the free scrolling view snaps to the borders of a control or a page)
    and it does not have an endless loop of items, in contrast with pivot control,
    but instead has more linear navigation. Behaviorally, it resembles and uses a
    similar navigation strategy as the `FlipView` control from Windows Runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to initiate a carousel-type navigation structure, either XAML or code-behind
    can be used. A simple carousel view with three content page implementations would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The resulting view would be a container for touch-initiated horizontal navigation
    between peers.
  prefs: []
  type: TYPE_NORMAL
- en: '![CarouselPage](img/B04693_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Carousel view'
  prefs: []
  type: TYPE_NORMAL
- en: ContentPage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ContentPage` is a simple page implementation used generally in cooperation
    with previously described page structures. It can be described as the actual content
    presenter. Child views in other navigation implementations are generally made
    up of `ContentPage` implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to set the content to be visualized on the user interface, you can
    use the `Content` property, which accepts a list of view objects. Layout elements
    are generally used as the direct children of `ContentPage` and other user controls
    are appended to this visual tree.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Layouts are structural design elements that allow developers to organize the
    UI controls using various strategies. We can classify layouts into two groups
    according to their class inheritance hierarchy: single view and multiple view.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/B04693_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Layout classes'
  prefs: []
  type: TYPE_NORMAL
- en: Single view layouts are direct descendants of the base layout implementation
    and they are capable of displaying only a single view item (they can also be a
    branch of a visual tree). Examples of this category are `ContentView`, `Frame`,
    and `ScrollView`. `ContentView` and `Frame` elements are rarely used and can be
    helpful while dealing with fewer content elements and/or an application with an
    active screen pattern (for example, a drawing application would use a single canvas
    implementation with absolute positioning; drawn geometry items would be the children
    of the canvas).
  prefs: []
  type: TYPE_NORMAL
- en: '`ScrollView`, on the other hand, is one of the most popular controls and can
    be used together with another layout element, such as `StackLayout`. When used
    with `StackLayout`, if the calculated height of `StackLayout` is greater than
    the client area, the parent control, `ScrollView`, makes it possible to change
    the viewport of the child control. Even though it is not very common, `ScrollView`
    can still be used with simple controls such as `Label` or `Image`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we were to implement the primary content of the `TabbedPage`
    created in the previous section, we can use a `ScrollView` to display the `StackLayout`
    that is displaying the recently uploaded items from the TravelTrace server. The
    markup for this implementation would look similar to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It would be displayed almost like a scrolling `ListView`:.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/B04693_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: ScrollView visualizations'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under normal circumstances, when dealing with a long list of data items, `ListView`
    should be the main control to be used. This implementation is only for demonstration
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-page layouts category consists of `AbsoluteLayout`, `Grid`, `RelativeLayout`,
    and, as seen in the previous example, `StackLayout`. Each layout is used for a
    specific scenario for various design-related requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '`Grid`, similar to the `Grid` in Windows Presentation Foundation, is used to
    organize child elements in a grid structure. The initial step of creating a grid
    is to define `ColumnDefinitions` and `RowDefinitions`, which describe the cells
    that are going to be used to render the elements. After this step, view elements
    can be added to the grid using the attached properties of `Grid`, such as `Grid.Row`,
    `Grid.Column`, `Grid.RowSpan`, and `Grid.ColumnSpan`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the example cells from the previous implementation, we could have a classic
    cell view with two lines of text and an image on the right-most section of the
    cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`AbsoluteLayout` provides a rendering mechanism in which the child elements
    are organized in floating rectangles. Placement geometry (that is, the `LayoutBounds`
    property) defines the X and Y coordinates of the element and the size of the bounding
    rectangle. The `LayoutBounds` property can accept device units or proportional
    units. The notion used for proportional units is similar to the "%" system used
    in HTML layouts. These values have to be in the range of 0-1 to designate an element
    on the screen area. The `AbsoluteLayoutFlags` enumeration can be used to define
    the bounding rectangle values that follow the proportional unit system or otherwise
    (for example, `PositionProportional`, `HeightProportional`, `SizeProportional`,
    or `All`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`RelativeLayout` is conceptually similar to relative layouts on the Android
    and Windows 10 platforms. It also uses a similar constraint mechanism as iOS auto-layout
    implementation. In a relative layout, elements can be positioned in a bounding
    rectangle similar to an absolute layout. However, values for this bounding rectangle
    are defined in reference to the parent element (`RelativeToParent`) or another
    control in the visual tree (`RelativeToView`). Developers are also allowed to
    use constant values without referencing another control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In relative layouts, if the arrangement is being created in code-behind, constraints
    are defined using a lambda expression or anonymous functions. For instance, in
    order to add an image element to the center of the page of size (100,100), we
    would use the `RelativeToParent` constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to insert a label 10 units underneath the image in the center, it
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/B04693_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Relative layouts'
  prefs: []
  type: TYPE_NORMAL
- en: A similar implementation using the markup extensions in XAML can be employed.
    Even though the constraint expression options are limited by factor and constant
    values (that is, using relative layout, factor multiplies the value of the selected
    property and constant is used for offset values), it can prove useful in data-bound
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `StackLayout`, similar to `StackPanel` on the Windows platform and
    `LinearLayout` on the Android platform, provides a flow layout where child views
    (that is, controls) are arranged automatically according to the orientation set
    and the calculated or requested dimensions of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User interface controls in Xamarin.Forms are referred to as views. Views are
    abstractions of controls or widgets in Xamarin target platforms, and each of them
    is rendered with a native control on the respective platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'For text-related scenarios, there are three controls: `Editor`, `Entry`, and
    `Label`. The `Editor` and `Entry` views provide multi-line and single-line editing
    capabilities to the user interface respectively. On the other hand, the label
    view can be used in either scenario as a read-only control.'
  prefs: []
  type: TYPE_NORMAL
- en: For dropdown-related scenarios, the `Picker` view can be used. More specialized
    implementations of pickers are `TimePicker` and `DatePicker`. `Stepper` and `Slider`
    are other views that can provide a constraint value, such as an integer within
    a certain range. For option scenarios, the only available control is the `Switch`
    view. The `Switch` view renders a `Switch` control on Android and iOS and a `ToggleButton`
    on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: For process feedback implementation, there are two views available, namely `ProgressBar`
    and `ActivityIndicator`. `ProgressBar` provides a determinate progress indicator,
    and `ActivityIndicator` is rendered as an indeterminate progress ring on target
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: For web resource-related scenarios, `WebView` can be utilized. In a similar
    fashion to embedded web view native controls on target platforms, `WebView` can
    be used to display either a local (that is, a web element constructed from application
    resources or a text value) or a remote web page. It provides access to the navigation
    stack and navigation events of the displayed web document.
  prefs: []
  type: TYPE_NORMAL
- en: 'For collection views, there are two main controls in Xamarin.Forms: `ListView`
    and `TableView`. `ListView`, undoubtedly, is the most specialized control to display
    a collection of content items. It supports data binding scenarios together with
    more specialized actions such as pull-to-refresh, context-related commands, and
    selections. `TableView`, on the other hand, is used for scenarios where the content
    items are more heterogeneous and instead of a data-bound source, fixed UI element
    declarations are required. It can be used for a menu display of selections, configuration
    values, or as an input form.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `ListView` and `TableView` consist of cells. Cells are visual templates
    used to render content elements in these collection views. While `TableView` is
    generally associated with default templates such as `SwitchCell` and `EntryCell`,
    which are used to create form elements in a table, `ListView` generally uses a
    templated implementation of `ViewCell`. For simpler implementation scenarios,
    built-in cell implementations, such as `TextCell` and `ImageCell`, can also be
    used with the `ListView` control.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For `TableView` collection control, the iOS platform currently does not support
    the `HasUnevenRows` property and automatic layout of the cells. This is a known
    platform limitation that was recently fixed for the `ListView` control. Developers
    are expected to either define a fixed `RowHeight` for `TableView` or define a
    `Height` value for each cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate the `ListView` utilization, we can make use of the
    previous implementation in which we used `StackLayout` together with `ScrollView`.
    In the previous scenario, we created hard-coded UI elements that were defined
    as `Grid` items. In this implementation, let us assume that we have a data source
    that can be set as the data provider for the `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this provider, we are using a three value `Tuple` that provides the display
    name, description, and image values for the content entries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Tuple` values are accessed using Item1, Item2… properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView` can contain three visual templates defining the respective sections
    of the collection view: `HeaderTemplate`, `FooterTemplate`, and `ItemTemplate`.
    A header and footer can also be set directly using a view element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`ItemTemplate` defines how the content elements are to be rendered in the collection
    view. If `ItemTemplate` is not defined, the list renderer will try to convert
    the content elements to a string and display them as `TextCells`. Re-using the
    grid implementation from the previous example(s), we can define `DataTemplate`
    for the `ItemTemplate` property of `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation will be displayed in a scroll-enabled list container similar
    to the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Views](img/B04693_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: ListView with item source'
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement context-related functions, the item data template, view
    cell, can be edited to include context menu elements. It is also possible to modify
    view cell in the code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following XAML snippet can be used to create two context menu actions:
    `Favourite` and `Remove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `Remove` command is marked as destructive. The `IsDestructive`
    flag is used to create the slide-to-delete behavior on iOS. On other platforms,
    destructive actions are rendered similar to other commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![Views](img/B04693_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Context menu actions'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView` also has a flag called `IsPullToRefreshEnabled`. This property can
    be used to support the pull-to-refresh behavior. `RefreshCommand` can be used
    to bind the action required to refresh the list.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the Xamarin.Forms framework provides an extensive set of customizable
    UI elements, in certain scenarios you might want to change how a certain control
    looks or behaves. Moreover, at times, providing an application-wide customization
    scheme can provide consistency and decrease redundancy. XAML markup infrastructure
    used in Xamarin.Forms provides various custom implementation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When implementing certain UI patterns, view elements have to be declared independent
    of each other, and yet they have to carry the same design attributes, such as
    typography, layout properties, colors, and so on. Styles can be used in this situation
    to organize and re-use the element attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ListView`, the only view container defined would be the item data template,
    and the content items loaded from the data source will be rendered using the same
    template. However, if the view requirement is to use `Grid`, `StackLayout`, or
    `TableView`, each view item would have to be defined separately.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, it might become quite cumbersome to create a settings view for
    Xamarin.Forms applications using the `TableView` control. In this implementation,
    if we cannot use the standard cell views, such as `EntryCell` or `SwitchCell`,
    because of requirements, the markup becomes even more redundant with each control
    having to declare similar fonts and colors that make up the theme of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Styles](img/B04693_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: TableView used for a settings view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom cell views in this implementation were used to create a description
    element for each setting. If we look at the markup file, you can see the repeating
    styles for each text element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each label is defining at least `TextColor`, `FontSize`, `VerticalTextAlignment`,
    and `HorizontalOptions`. There is one pattern for setting labels and another one
    for description elements. Vertical and horizontal alignment options, however,
    apply to all text elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we can simplify the markup by creating an implicit style that will
    apply to all `Label` elements. Implicit styles do not define a resource key, hence
    they apply to all targeted controls, such as `TargetType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create additional styles to set item labels and descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, this does not work as we expected it to. The outcome demonstrates that
    the implicit styles were overridden by more specific style descriptions. It is
    important to realize that there is no implicit cascading between the styles defined
    for the same target controls. XAML is not HTML/CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Styles](img/B04693_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: Implicit style is overridden with assigned styles'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a cascading scheme, we need to base the `SettingLabel` and
    `SettingDescription` styles on the initial implicit style. For this purpose, we
    need to define a key for our base style and reference this base in the derived
    style declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `SettingDescription` style uses the `BasedOn` declaration (similar
    to the WPF implementation), while `SettingLabel` uses the `BaseResourceKey` property.
    Both of these references can be used in Xamarin.Forms implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers and behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At times, implementation requires style-related or behavioral changes of controls
    in accordance with changes of the same or any other control's properties or data,
    as well as certain events (for example, disabling a certain control according
    to the data input value changes). Under normal circumstances, implementations
    utilize data bindings where the data change event is routed to the presenter and
    the presenter changes the view, providing a trivial solution. However, if the
    UI event should trigger another UI change, the cost of data binding would be an
    overhead. Instead, the Xamarin.Forms markup offers triggers and behaviors that
    add complexity to intrinsic controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the settings view that we previously created for our application
    requires certain business rules. The first setting value, UserLocation, is a dependency
    of the UseGeofences setting. In other words, technically it is not possible to
    create geofences without using location services. For this specific scenario,
    we could create a data binding from the `IsToggled` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation works as expected since the `IsToggled` and `IsEnabled`
    values are both using `Boolean` as the value type. If we were to change any other
    property of the target UI element, we would have to implement a value converter.
    Moreover, multiple property changes would require multiple bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers provide an easy solution for this type of scenario. There are four
    types of trigger that can be used to initiate either a setter action or a custom
    implementation of a trigger action. Property triggers are used to create a visual
    state on a user control according to the value of a property of the same control.
    Data triggers are used in a similar fashion but in this case, the cause for the
    trigger is defined by data binding. Event triggers are bound to user control events
    and multi triggers can encompass and invoke an action that is dependent on multiple
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same scenario from the previous example can, in this case, be implemented
    with a `DataTrigger`. Iterating on the scenario, the implementation can set the
    enabled and text color properties on the associated description label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us also implement a notification when the main control is disabled, warning
    the user about other settings being disabled. For this implementation, we will
    need an event trigger and a trigger action implementation. A trigger action implementation
    consists of implementing the `TriggerAction<T>` class and the virtual `Invoke`
    method: (see the *Dependency injection* section for the implementation of `INotificationService`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will need to declare the namespace containing the implementation in
    the root node of the page''s markup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we can add the event trigger to the main setting control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Triggers and behaviors](img/B04693_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: Notification triggered using EventTrigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want this trigger to be applied to multiple controls (for example, the
    notification settings section in the example), we can create a new style for the
    main setting values and add the trigger to the style declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The same type of result could have been achieved with a behavior implementation
    for the `Switch` control. Behaviors are a more generic type of extension mechanism
    that allow developers to extend existing user controls without having to create
    derivatives of these controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we were to use the same scenario (that is, when the switch
    control is toggled off, a notification window should be shown to the user), we
    would need to implement the base class, `Behavior`, with a type argument for `Switch`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In a custom behavior implementation class, an `OnAttachedTo` method is used
    as the initialization function where the control can be customized. Similarly,
    `OnDetachingFrom` is used to clean up the customizations and any existing event
    handlers that might have been attached to the control. Even though it's technically
    possible, it is not advisable to modify the binding context using behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom behavior can be included either in styles targeting the same type
    of control or with in-place markup elements added to the specific control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Custom renderers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Forms provides the developers with a uniform markup and implementation
    framework to create native UI views for all Xamarin target platforms. The abstractions
    of provided UI elements are then used by the framework to render native controls.
    Similar to the Xamarin.Forms solution anatomy, each view/control in the Xamarin.Forms
    platform is a composite implementation. While the behaviors for the abstracted
    control logic are implemented and can be derived in portable class libraries,
    the renderers associated with each control for various platforms are implemented
    by platform-specific libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom renderers](img/B04693_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: Custom renderer implementation'
  prefs: []
  type: TYPE_NORMAL
- en: In order to customize a control, one must first create a derived class for the
    abstracted control. After this implementation, the custom control can be referenced
    with a `clr-namespace` declaration (similar to `TriggerAction` and `Behaviors`)
    and can be used in the view markup.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the custom implementation of the control would use the default
    renderer for the base class. In order to change the way that native controls are
    rendered on a specific platform, we would need to provide a custom renderer implementation
    and register it using the `ExportRenderer` attribute on the same platform.
  prefs: []
  type: TYPE_NORMAL
- en: Custom renderers provide a powerful way to customize how the common view implementations
    with Xamarin.Forms should look on platform-specific views.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss several implementation patterns and tools that
    developers generally resort to while developing Xamarin.Forms applications. Messaging
    and dependency injection features will be discussed further in [Chapter 9](ch09.html
    "Chapter 9. Reusable UI Patterns"), *Reusable UI Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an ideal implementation of the **Model-View-ViewModel** (**MVVM**) or **Model-View-Presenter**
    (**MVP**) pattern, each screen is self-contained; the screen modules for the view,
    model, and the mitigation components communicate with each other using various
    communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: However, in complex applications, there is sometimes the need for a communication
    channel between these self-contained elements, since the result of an action on
    one of the screens should be propagated to other unrelated section(s) of the application
    with a shared interest in the result of this very action. As a solution to this
    problem, in MVVM frameworks such as MVVMCross, Prism, or MVVM Light, it is common
    to see an implementation of the Event Aggregator pattern providing a loosely coupled,
    multicast-enabled publisher/subscriber messaging infrastructure. Event Aggregator
    can be described as the eventing hub, which receives multiple types of strongly
    typed messages and delivers these messages to multiple subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xamarin.Forms, the Event Aggregator is called the `MessagingCenter`. It
    exposes three groups of methods: `Subscribe`, `Unsubscribe`, and `Send`. The `Subscribe`
    and `Unsubscribe` methods are used by the event observers, and the `Send` method
    is used by the publisher.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this paradigm, the subscriber is responsible for providing the instance
    and/or the type of the sender together with the expected type of the message (that
    is, a simple text parameter defining the message). The message type or name is
    an identifier for the message and together with the message signature (the sender
    type and the arguments type), it makes up the decision criteria for the subscribers.
    Finally, the last provided parameter is the callback delegate, which can have
    the sender, and possibly the event arguments, as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The publisher is responsible for providing the message with the same message
    name and signature. On the publisher''s side, the message signature is made up
    of the message name and the message argument parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: MessagingCenter can prove to be very utile, providing simple solutions/workarounds
    for architectural problems (especially scenarios where a Separation of Concerns
    is in question) in Xamarin.Forms applications, and creating a decoupled communication
    channel between components.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, one of the biggest drawbacks of using **Portable Class
    Libraries** (**PCLs**) to implement common cross-platform libraries is the fact
    that the platform-specific features cannot be accessed directly since the platform-dependent
    modules cannot be referenced by these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most effective and elegant solutions to this problem is using dependency
    injection (aka IoC - Inversion of Control). Using dependency injection, platform-specific
    functionality should be abstracted into segregated interfaces, and these interfaces
    can later be used to access the implementation modules injected with the provided
    dependency containers.
  prefs: []
  type: TYPE_NORMAL
- en: '`DependencyService` in Xamarin.Forms allows applications to use platform-specific
    implementation through the abstraction interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: In a common scenario, the first step would be to define the abstraction (in
    the common portable forms library) that is going to be used by the common application
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a demonstration, let us implement a module that uses the native messaging
    methods to display a notification for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement this interface in platform-specific projects. In the Xamarin.Android
    project, we can implement this using a toast notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the iOS platform, we can create a local notification message and present
    it using the shared application infrastructure. However, local notifications for
    foreground applications are automatically dismissed (only at the UI level can
    one still implement an event delegate for a notification received event and display
    an alert instead). Hence, we will use the `UIAlertController` class and present
    it using the current window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, for the Windows Phone platform, we can only use the local toast
    notifications with the currently running applications on Windows Phone 8.1 and
    Windows 10 mobile. For other versions, similar to the iOS scenario, local toast
    notifications are not allowed for foreground applications. For this reason, we
    can implement a simpler notification dialog using the `MessageBox` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use the `INotificationService` interface in the portable class
    library that implements the Xamarin.Forms application, we need to resolve the
    interface to create an instance of one of the platform-appropriate implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that in this sample implementation, the `Dependency`
    assembly attribute was used to register the platform-dependent implementation
    classes. It is also possible to use the `Register` method of `DependencyService`
    to create dependency containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `Register` method has to be invoked after the initialization of Xamarin.Forms
    (that is, the `Forms.Init` method) and before any dependent module is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Shared project versus portable project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Forms extensions introduce two types of multi-project solution templates.
    Each template contains platform-specific projects as well as a common project
    to implement platform-agnostic components for these native applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples we were using the PCL project template, which creates
    three platform-specific projects, each referencing a cross-platform portable class
    library. Platform-specific projects delegate the application initialization to
    the portable class library that initializes Xamarin.Forms and renders the pages
    implemented using Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: The second project template creates a shared project that is included and compiled
    into the platform-specific projects. In this scenario, since we are technically
    not dealing with a platform-agnostic implementation (that is, implementations
    in the shared project are directly compiled into the referencing projects), developers
    are free to use platform-specific features, given that the compilation conditions
    are used for appropriate platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to demonstrate the difference between the two approaches would
    be to re-implement the notification service from the previous section without
    dependency injection. In the previous example, we needed to create an abstraction
    of the notification feature to be used in common views and inject the implementation
    from platform-specific projects in the runtime. In the case of a shared project,
    we can implement the same feature using conditional compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, each platform compilation uses a specific section of the function.
    We can also use other types of abstraction and partial classes or methods to create
    elegant implementations according to the requirements of the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific fine-tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In spite of, or even because of, the fact that Xamarin.Forms tries to provide
    a uniform implementation layer and then translates this layer into native controls,
    at times developers are faced with the challenge of implementing retouches for
    specific platforms. These modifications vary from small changes, such as font
    size (because of device- and platform-dependent pixel measures) or background
    color, to more systematic problems, such as not having the auto-layout implementation
    for `TableViews` on the iOS platform. There are various ways to deal with this
    type of situation, and the `Device` class is generally the access point to these
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with common typographic controls, such as a `Label` or an `Entry`
    field, the simplest way to comply with the design or accessibility requirements
    of a specific device is to use the built-in styles available in the `Device.Styles`
    class. There are several style elements, such as `BodyStyle`, `SubtitleStyle`,
    and `CaptionStyle`, that can be used to solve common implementation problems.
    The style elements in this class are calculated for the current platform/device
    in the runtime, hence they have to be referenced by a `DynamicResource` XAML markup
    extension when dealing with markup rather than code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple label using the `TitleStyle` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be declared in the markup file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful platform-specific typography-related utility is the `NamedSize`
    enumeration. The `NamedSize` enumeration can be used with the `Device.GetNamedSize`
    method to choose the most suitable font size in the target platform for a text
    field. The enumeration provides four built-in options for different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A built-in converter can also be used to include the font size in XAML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For more general implementation requirements, `Device.Idiom` and `Device.OS`
    provide valuable target platform information related to the type of device (desktop,
    phone, tablet, and so on) and the operating system of the device (Android, iOS,
    Windows, or Windows Phone) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, Windows Phone 8.1 and Windows Phone Silverlight versions cannot be
    differentiated using the `Device.OS` property. Conditional compilation can be
    used as a replacement for this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `Device.OnPlatform` function and its XAML extension counterpart
    can help developers implement platform-specific styles. The `OnPlatform` function
    uses three values for each platform and returns the appropriate value according
    to the `Device.OS` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualizing a label using the `OnPlatform` function would look similar to the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, using the XAML markup extension, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Device.OnPlatform` function has another overload that can be used to execute
    certain actions according to current operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Briefly, Xamarin.Forms provides the toolset to increase code-sharing between
    platform-specific projects and provide developers with a uniform experience when
    developing UI components for these projects. The Xamarin.Forms framework, in general,
    proves to be indispensable, especially for cross-platform implementation where
    platform-dependent feature requirements are minimal.
  prefs: []
  type: TYPE_NORMAL
- en: This uniform abstraction layer is responsible for rendering the platform-specific
    UI controls and creating native experience for the users. This layer can also
    be extended using various features and patterns, some of which were discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will be focusing on more re-usable view elements and implementation patterns
    in the next chapter. Xamarin.Forms will again be referenced in this context.
  prefs: []
  type: TYPE_NORMAL
