- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a 2D Adventure Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058), you were introduced to Cinemachine
    for creating a quick but powerful camera-follow system. We learned how to implement
    a game mechanic for collecting items and displaying game progression with Unity
    UI, and how to approach game balance while considering win-and-lose conditions.
  prefs: []
  type: TYPE_NORMAL
- en: By completing the collection game, the previous chapters provided foundational
    knowledge that we’ll continue to build upon in this chapter as we start to make
    a 2D adventure game. We’ll explore importing artwork and creating assets to build
    out a 2D side-on environment and level design using additional Unity 2D tooling,
    namely **Sprite Shape**.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll finish the chapter by adding dynamic moving platforms and triggers that
    will provide secondary actions to create a more engaging player experience, and
    some optimization techniques to keep the game performant and polished for increased
    immersion.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover the following main topics.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the **Game Design Document** (**GDD**) – Introducing the 2D adventure
    game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing assets to use with Sprite Shape – A different kind of 2D environment
    builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level and environment design – Guiding the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving platforms and triggers – Creating a dynamic interactable environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding polish to our environment to immerse the player and optimizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have another example of a GDD to use for
    your projects and be able to import and use original artwork to create an environment
    that guides the player while designing a level using Sprite Shape. You’ll also
    be able to create an interactive and dynamic moving environment that is optimized
    and visually polished.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along in this chapter with the same artwork created for the project
    in the book, download the assets from the GitHub link provided in this section.
    To follow along with your own artwork, you’ll need to create similar artwork using
    Adobe Photoshop, or a graphics program that can export layered Photoshop PSD/PSB
    files (for example, Gimp, MediBang Paint, or Krita).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, to follow along with the player input section, you’ll want a compatible
    game controller for your system (although this is optional since keyboard input
    will also be provided).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Extending the GDD – Introducing the 2D adventure game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re continuing with the next game concept now – while continuing with the
    overall theme for the projects in the book – so let’s go ahead and update the
    GDD and extend upon it where needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first update the following overview sections that we’ve previously covered;
    this will also serve as your introduction to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** **of game** | Outer World |'
  prefs: []
  type: TYPE_TB
- en: '| **Describe the gameplay, the core loop,** **and progression.** | Find your
    way to the habitat station while searching for parts of the key required to gain
    access to the entryway and neutralize infected robots that attempt to halt your
    mission. |'
  prefs: []
  type: TYPE_TB
- en: '| **What is the core game mechanic for the** **adventure game?** | The player
    will repeatedly engage in battle with infected robots that impede progress to
    the habitat station. |'
  prefs: []
  type: TYPE_TB
- en: '| **What is the secondary game mechanic for the** **adventure game?** | The
    player will search the environment for hidden parts of a key. The pieces will
    need to be combined correctly as input to gain access to the entryway of the habitat
    station. |'
  prefs: []
  type: TYPE_TB
- en: '| **What systems need to be implemented to support the** **game mechanics?**
    | The player movement, equipping a weapon with ammo reloading and shooting capabilities,
    a pickup with inventory, puzzle solver, health, and damage |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – The GDD for the adventure game
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a new section to the end of the preceding table that takes the game
    mechanic details a step further into the *development requirements* realm. With
    some systems defined, we can start thinking about the code architecture and what
    *problems need solving* – this is where we can apply some design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of a nerf, this time, let’s add a buff for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **What is a buff mechanic for the player in the** **adventure game?** | The
    player will be able to collect energy shards (*water diamonds*) scattered throughout
    the environment, which, when a certain quantity has been collected, will give
    a power-up state to all of the weapons (increasing damage dealt). |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – Adding a buff to the GDD
  prefs: []
  type: TYPE_NORMAL
- en: 'Our player character and the enemies in the game will be much further developed
    compared to the collection game. Let’s add sections in the GDD for these characters’
    bios and details about the player’s challenge structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Main character:****Describe the main character of the game and how they
    drive the story. Who is this** **player character?** | **Type**: Kryk’zylx race
    of humanoids.**Backstory**: The people of Kryk’zylx have outgrown their home planet
    and are searching the galaxy for suitable planets to colonize. Scouts are sent
    to establish habitat stations on planet surfaces with the potential to sustain
    life.**Goals**: Establish and maintain a habitat station with an automated crew
    of construction and maintenance robots.**Skills**: Power suit jumping and charging.**Weaknesses**:
    Atmosphere not breathable. |'
  prefs: []
  type: TYPE_TB
- en: 'Kryk’zylx scouts must wear power suits to survive the planet’s hostile atmosphere
    outside of the habitat station. Here is an example of a power suit helmet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Power suit helmet](img/B18347_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Power suit helmet
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, we’ll continue by adding the sections for the details of the player’s
    challenge structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **What is the main character’s** **challenge structure?** | Navigate platforms,
    make their way past infected robots, and solve the critical puzzle. |'
  prefs: []
  type: TYPE_TB
- en: '| **Enemy A:****Describe the first enemy in the game and how they drive the
    story. Who is** **this enemy?** | **Type**: Construction Robot, Biped**Backstory**:
    Robot deployed on pre-colonization missions for habitat station construction and
    maintenance.**Goals**: Construction and maintenance.**Skills**: High mobility,
    including onrough terrain.**Weaknesses**: Long charging. |'
  prefs: []
  type: TYPE_TB
- en: '| **Enemy B:****Describe the second enemy in the game and how they drive the
    story. Who is** **this enemy?** | **Type**: Maintenance Robot, Wheeled**Backstory**:
    Robot deployed on pre-colonization missions for habitat maintenance and support.**Goals**:
    Maintenance and personnel support.**Skills**: Quick charging.**Weaknesses**: Limited
    mobility. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – Adding character and enemy bios
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take the document further and introduce a section that gives the environment
    some attention. The description here will help maintain the game’s visual direction
    while the environment and level are being designed and the art assets are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Describe the environment in which the game takes place. What does it look
    like, who inhabits it, and what are the points** **of interest?** | The game takes
    place on the surface of a prospective planet to colonize, even though this particular
    planet does not have a breathable atmosphere. The planet comprises areas of purple-red
    rock and thick vegetation (which moves in such a way as to suggest it may have
    the capacity to think). |'
  prefs: []
  type: TYPE_TB
- en: '| **Describe the** **game level(s).** | The game level is a combination of
    static and moving platforms with obstacles needing to be overcome or avoided by
    the player as they make their way to the habitat station. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – Environment and level
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a section on the input controls. Previously, we used the keyboard
    and mouse for the collection game, but this time, we’ll also be adding support
    for input from a game controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Define the input/control** **methods actions.** | **Keyboard**: *W*, *A*,
    *S*, and *D* keys to move; the space bar to jump; the mouse to aim, the left mouse
    button to shoot the primary weapon, and the right mouse button hold/release to
    launch the secondary weapon while aiming with the mouse (the left mouse button
    to cancel); and the *E* key to interact with things.**Game Controller**: The left
    stick/D pad to move; *X* to jump; the right stick to aim and the right trigger
    or *Y* to shoot; the right shoulder hold/release to launch the secondary weapon
    while aiming with the right stick (the right trigger to cancel); and button *A*
    to interact. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – Input/control methods actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s define how all the pieces interact to make a complete game experience
    for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **How do all the** **pieces interact?** | The player interacts with the environment
    through exploration, discovering what is required to reach and enter the habitat
    station using parts of a puzzle key found throughout the level while fending off
    robots that have become infected by the strange plants that cover the planet’s
    surface. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.6 – Putting all the pieces together
  prefs: []
  type: TYPE_NORMAL
- en: Full GDD for the 2D adventure game
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the full GDD document for the 2D adventure game, visit the project
    GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/GDD](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/GDD)'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the GDD any time you are unsure about what comes next. So long as you’re
    following what you’ve written, the next steps should come as a natural progression
    you can iterate upon. However, don’t feel like you’re locked into what you’ve
    written as your first draft of the GDD – as a living document, let ideas organically
    change as you work through them, and new ideas come to light (just as I have done
    throughout writing this book!).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to extend upon our GDD to include additional
    details for the main characters in the game and describe the game world and how
    everything works together to create an immersive experience for the player. We’ll
    continue importing original artwork to start building the game level with Sprite
    Shape in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing assets to use with Sprite Shape – A different kind of 2D environment
    builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The artwork that we’ll be using for the 2D adventure game is an original artwork
    and the result of a collaboration with the artist, Nica Monami. The art assets
    have all been created specifically for this project in the book. Nica has lent
    her talent for creating fantastic painterly-looking art to create a unique environment
    for the game, and I am very excited to be working with these assets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Original game artwork](img/B18347_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Original game artwork
  prefs: []
  type: TYPE_NORMAL
- en: Adventure game 2D art assets
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along in this chapter, download the art assets from the project GitHub
    here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Art-Assets)'
  prefs: []
  type: TYPE_NORMAL
- en: Nica Monami has permitted the use of the provided game art for learning purposes
    only; commercial use is strictly prohibited. Nica’s portfolio can be viewed on
    ArtStation at [https://www.artstation.com/dnanica213](https://www.artstation.com/dnanica213)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Sprite Shape – the 2D feature we’ll be using to build out most
    of the adventure game’s level – we’ll cover most of the tooling provided by the
    **2D Animation package**. We’ll first cover importing and performing any required
    prep for the artwork to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and preparing the artwork
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a new Unity project for the adventure game, again using
    the 2D **Universal Render Pipeline** (**URP**) Core template. We’ll continue exploring
    different gameplay styles by making the 2D adventure game a side-on orthographic
    game view (similar in style to many other Mario Bros or Metroid-inspired platformer
    games).
  prefs: []
  type: TYPE_NORMAL
- en: Once the project opens, import the artwork under a new `Assets/Sprites` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Dutiful organizational reminder
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining an adequately named folder structure can help keep things sorted
    and easy to find and work with later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing all of the imported Sprite assets – in the event you did lose track
    of something or work with many assets at once – is easily accomplished with the
    **Search by Type** option in the project window’s **Search** tool, as seen in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Filtering on Sprite in the project window](img/B18347_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Filtering on Sprite in the project window
  prefs: []
  type: TYPE_NORMAL
- en: 'The image assets imported will serve different purposes and use additional
    Sprite tooling. Here is a quick overview of how we’ll be working with the imported
    assets, by folder, throughout the remainder of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assets/Sprites/Sprite Shapes`: Images in this folder will be used with Unity’s
    2D **Sprite Shape** tool. Sprite Shape is a spline-based tool that provides the
    ability to make open-ended paths or enclosed shapes that can be used as parts
    of the level that the player character can walk on, adding background elements
    or quickly decorating the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*2D Sprite* *Shape:* [https://docs.unity3d.com/Packages/com.unity.2d.spriteshape%409.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.spriteshape%409.0/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assets/Sprites/Sprite Skins`: Images in this folder will be used with Unity’s
    2D `SpriteSkin` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Sprite* *Skin*: [https://docs.unity3d.com/Packages/com.unity.2d.animation%409.0/manual/SpriteSkin.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation%409.0/manual/SpriteSkin.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assets/Sprites/Tilemap`: Images in this folder will be used to create a **Tilemap**;
    we are already familiar with this 2D feature from building the collection game
    in [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Sprites/Background`: Images in this folder will be used to create our
    game environment’s layered background. We won’t use any particular Unity feature
    this time, but we will use a script to add parallax movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background parallax
  prefs: []
  type: TYPE_NORMAL
- en: Parallax is a technique applied to background images that moves images further
    away from the camera across the frame more slowly than foreground images, creating
    a sense of depth in 2D scenes. This technique was popularized in 2D video games
    starting in the early 1980s (although it was limited in the number of background
    planes due to hardware limitations of the time – thankfully, we’re not stuck with
    the limitations of those that came before us because we have no such limitations
    today).
  prefs: []
  type: TYPE_NORMAL
- en: '`Assets/Sprites/Background/Clouds`: Images in this folder will be used to create
    clouds that continuously scroll and loop across the sky in the background of the
    game environment, furthering the sense of depth and immersion. We’ll use Unity’s
    **Spline** package and the corresponding **Spline Animate** component to make
    this quick and easy work (similar to the moving platforms mentioned earlier).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/Sprites/Object Elements`: Images in this folder will be used to detail
    the environment and provide some possible special areas of interest. There is
    nothing special here, just the Sprite Renderer and 2D colliders to facilitate
    interactions with the player character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the fundamental review of the imported assets by folder finished, let’s
    do the prep work for the sprites that require it before usage.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the artwork for Sprite Shape
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sprite Shape feature creates dynamic and *flexible* shapes that can either
    be open paths or closed and filled areas. The sprite that is assigned for the
    Sprite Shape’s spline path is tiled and deformed along the defined outline. Because
    of the tiling, we need to take some special steps to prepare the sprite used here
    by adding a border at the locations on the left and right edges where it will
    tile seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps while referring to *Figure 4**.4* to ensure that the sprite
    will be compatible and work well with Sprite Shape:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the sprite in the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Import Settings (Inspector)**, click the **Sprite** **Editor** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the image and drag in both the left and right sides by using the green
    boxes or typing in values into the **L** and **R** fields of **Border** in the
    **Sprite** dialog – for the tileable position in the sprite. Click **Apply** when
    finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Mesh Type** to **Full Rect** (this is required for use with Sprite
    Shape and will produce a warning on the Sprite Shape asset if not set accordingly).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Sprite Editor for Sprite Shape art](img/B18347_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Sprite Editor for Sprite Shape art
  prefs: []
  type: TYPE_NORMAL
- en: Package Manager samples
  prefs: []
  type: TYPE_NORMAL
- en: Most packages in the Unity Package Manager have additional content as additional
    installations on their respective Package Manager pages. In Sprite Shape’s case,
    samples and extras that demonstrate many of its capabilities can be imported.
    I encourage you to check out the package samples for additional learning.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing artwork for Sprite Skin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sprite Skin feature is commonly used to create rigged limbed characters
    and is imported from a layered Photoshop PSB/PSD file (using the **PSD Importer**
    package). We’ll use this 2D animation package feature in [*Chapter 5*](B18347_05.xhtml#_idTextAnchor096),
    when we create the adventure game’s player character. Still, for now, in this
    chapter, we’re just going to add some movement to some environmental elements.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be animating individual PNG images imported into the `Sprites/Sprite Skins`
    folder. Aside from keeping these as separate images (for the sake of simplicity),
    there is nothing extra we need to do with the import settings.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing artwork for Tilemap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We used Tilemap extensively in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041);
    you should be a pro with it by now! Let’s quickly recap the image preparation
    process by creating a new Tile Palette for the `Tilemap-01` sprite sheet image
    imported to `Sprites/Tilemap`, as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Slicing the Sprite Sheet for Tilemap tiles](img/B18347_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Slicing the Sprite Sheet for Tilemap tiles
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to prepare the artwork for use with Tilemap:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the sprite sheet image in the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Import Settings (Inspector)**, set **Sprite Mode** to **Multiple**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the changes and click the **Sprite** **Editor** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Slice** dropdown menu and then select **Grid By Cell Size** for
    **Type** of slicing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The supplied Tilemap image uses a 64x64 pixel size grid (same as the collection
    game), so verify the correct size and click **Slice**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply**, or close **Sprite Editor** and save, and that’s it for the
    Tilemap prep work!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normal maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Normal map** is a special type of image where encoding in the RGB channels
    represents the direction a pixel faces. It’s easy to add fake volume and details
    to achieve a simulated 3D effect using a sprite’s pixels and 2D lights with URP.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to use special third-party software to create normal maps outside
    of Unity, as the following figure shows for a rock that we’ll use in the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Normal map image of a rock in Laigter](img/B18347_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Normal map image of a rock in Laigter
  prefs: []
  type: TYPE_NORMAL
- en: Normal maps generation software
  prefs: []
  type: TYPE_NORMAL
- en: The program used to create all of the 2D sprite normal maps for the 2D adventure
    game’s artwork is Laigter (available for free at [https://azagaya.itch.io/laigter](https://azagaya.itch.io/laigter)).
    Other programs that can export 2D normal maps include Photoshop, SpriteIlluminator,
    Sprite Dlight, and Sprite Lamp.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when importing 2D sprite normal maps, **Texture Type** for the image
    import settings will be **Sprite (2D and UI,)** and not **Normal Map** – because
    sprites that will be affected by 2D lights need to have the normal map texture
    assigned in the Sprite Editor (2D lights will also need to have normal maps enabled
    for affecting the sprites).
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the images provided in the example 2D adventure game project have accompanying
    normal maps. For your own images, go ahead and generate the normal maps and then
    assign them to the sprites by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the sprite in the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Sprite Editor** button in **Import** **Settings (Inspector)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Sprite Editor** dropdown menu, select **Secondary Texture**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Secondary Texture** dialog that opens, select **_NormalMap** from the
    **Name** dropdown menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the sprite’s normal map image by dragging it into the **Texture** field
    from the project window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the preceding *Figure 4**.4* for an example of the **Secondary** **Texture**
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve successfully prepared the project’s imported art assets to
    be used with the 2D tooling used in the coming sections. In the next section,
    we’ll take another look at level design before putting the art to use in creating
    different types of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Level and environment design – Guiding the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a quick break from the technical aspects of the project and talk
    about some game design concepts again before moving on to the features we’ll use
    to build the game level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the GDD is great, but it doesn’t provide any concrete visuals for communicating
    the theme and style of the game. Art can quickly elicit emotional responses and
    build excitement that is hard to compare to the written words of a GDD. For example,
    have a look at this concept art created for the *Outer* *World* game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Original “Outer World” environment concept art](img/B18347_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Original “Outer World” environment concept art
  prefs: []
  type: TYPE_NORMAL
- en: You should immediately have a sense of what it would be like to be a player
    in this environment! Games are often marketed early on with an artist’s rendering
    for visualizing concepts to gain interest and excitement for a project. They are
    also used internally to inspire the production team to build the product.
  prefs: []
  type: TYPE_NORMAL
- en: With excitement buzzing, let’s introduce a new game design principle to guide
    players and get them to explore this unique environment.
  prefs: []
  type: TYPE_NORMAL
- en: Signposting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve discussed guiding the player in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041),
    by introducing shapes to nudge the player in the desired direction. The game design
    principle we’ll present here is focal points in the environment, which is called
    **signposting**. Signposting helps the player know what they should do or tells
    them their destination.
  prefs: []
  type: TYPE_NORMAL
- en: We want the player to have a goal in mind as they are playing – the player should
    hardly ever experience the feeling of being lost in the game (only when they are
    spending a long time not progressing, point them in the right direction to avoid
    player frustration or worse, leaving the game). This type of signposting is also
    referred to as a **journey**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The journey we’re setting our player on in the adventure game can be seen in
    the following figure, where a habitat station is visible in the distance in the
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Signposting the habitat station for the player](img/B18347_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Signposting the habitat station for the player
  prefs: []
  type: TYPE_NORMAL
- en: The player has a goal now. Always consider designing the level with a purpose…
    what do we want the player to try to do, what should the player accomplish, or
    where should the player get to?
  prefs: []
  type: TYPE_NORMAL
- en: Keep these things in mind when designing your level using the tools we’ll introduce
    in the following sections, starting with adding the platforms that the player
    will walk on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can’t have a platformer game without platforms! Unity’s 2D tooling provides
    different tools for building platforms for 2D games. We’ve already used Tilemap
    to create a rigid and grid-based level design for the collection game. While we’ll
    still use Tilemap for sections of the adventure game level, we’ll start by creating
    platforms without the same constraints using Sprite Shape.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a closed Sprite Shape profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use two types of shapes when creating with Sprite Shape: open and closed
    shapes. An open shape provides a sprite outline of the spline path, whereas a
    closed shape includes a fill texture for creating an enclosed shape where both
    sides and a bottom sprite can also be defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start the level design with a closed Sprite Shape platform where the
    player will spawn. To do so, we’ll start by creating the Sprite Shape profile
    asset in the project before adding the platform to the scene by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project window, within the `Assets/Sprites/Sprite Shapes` folder, select
    **Create** | **2D** | **Sprite Shape Profile** and name it *Platform* *Closed
    1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the sprite for the top edge of the platform by, first, clicking on the
    blue border of the circle that defines **Angle Ranges**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the `45` and an `-45`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the region for the top edge now defined, assign the `sprite_strip_rock`
    sprite by dragging it from the project window and into the `SpriteShapeEdge` placeholder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for both the left and right sides of the Sprite Shape, using `45`
    and `135` for the angles, respectively, and `sprite_side_rock` as the sprite,
    as seen in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Closed Sprite Shape asset properties (top, left, and right)](img/B18347_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Closed Sprite Shape asset properties (top, left, and right)
  prefs: []
  type: TYPE_NORMAL
- en: The last step for creating a closed Sprite Shape is to assign the fill texture,
    so assign the `sprite_fill_rock` sprite to the **Fill** | **Texture** field (replacing
    **Sprite Shape** fill placeholder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the size of the sprites assigned is not to your liking, you can revisit the
    sprite import settings and change the **Pixels Per Unit** value to something that
    looks better (this can be adjusted at any time). The images being used for Sprite
    Shape are high resolution, so you have the flexibility to change the size without
    a loss in display quality.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can adjust the scale of the fill texture, but we’ll do that on
    the `SpriteShapeController` component when added to the scene – use the **Fill**
    | **Pixels Per Unit** field to adjust the fill texture scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the profile asset created, we can now make the first platform for our player
    by clicking **GameObject** | **2D Object** | **Sprite Shape** | **Closed Shape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the Sprite Shape asset `SpriteShapeController` component. Adjust the
    spline shape by manipulating and adding or removing knots, as seen in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Closed Sprite Shape platform in the scene](img/B18347_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Closed Sprite Shape platform in the scene
  prefs: []
  type: TYPE_NORMAL
- en: The last step required to make this closed Sprite Shape a walkable platform
    for the player character is to add a collider. For Sprite Shape platforms, we
    use the `edge`.
  prefs: []
  type: TYPE_NORMAL
- en: Once added, select **Sprite Shape Controller** | **Collider** | **Updated Collider**
    to enable it. Then, adjust the **Offset** value to line up with the top edge sprite
    – this can also be adjusted later when the player character is added to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Sprite Shape API allows you to change the spline nodes at runtime.
    If you don’t require runtime changes, you can bake or cache the geometry of the
    spline for a performance boost. So, if you don’t need to modify the spline at
    runtime, select **Sprite Shape Controller**, enable **Edit Spline**, and click
    *Cache Geometry* to bake the mesh. Otherwise, install the Burst package (version
    1.3 or later) from the Package Manager to improve performance when modifying the
    spline at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that Sprite Shape’s Renderer works like any other Sprite
    Renderer component and utilizes **Sorting Layers**. We’ll be using **Sorting Layers**
    throughout the project to properly layer the different artwork that will make
    up the level’s platforms and overall environment. We’ll keep all the level’s platforms
    on the default layer, so we have nothing to change.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Shape can also be used to distribute a variety of sprites along an updateable
    spline path. Explore Sprite Shape’s features to discover how you can decorate
    the platforms with the *vine* and *toxins* assets provided.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned how to create flexible shaped platforms using Sprite
    Shape, we’ll have a quick review of setting up a Tile Palette to use for drawing
    platforms with Tilemap before moving on to creating dynamic and interactive features
    in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Tilemap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will be a quick refresher for creating platforms in our level design
    using Tilemap since we’ve covered this topic extensively in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the tiles to be used for painting using the Tile Palette, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Tile Palette by going to **Window** | **2D** | **Tile Palette**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Environment` while using the default properties for a Rectangle Grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Assets/Sprites/Tilemap/Tile Palettes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Asset/Sprites/Tilemap` folder, click and drag the `Tilemap-01` image
    into the `Assets/Sprites/Tilemap/Tiles` folder when prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the tiles we’ll use for the Tilemap portion of our level are created,
    let’s go ahead and make a platform to the right of the Sprite Shape platform using
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, create a new Tilemap by using the **Create** or
    **GameObject** menu and selecting **2D Object** | **Tilemap** | **Rectangular**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll use the same **Default** Sorting Layer on **Tilemap Renderer** as we did
    for the Sprite Shape Renderer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Draw the platform using the brush and flood fill tools while using the correct
    tiles for the top, sides, bottom, and corners, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Tilemap platform added to the scene](img/B18347_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Tilemap platform added to the scene
  prefs: []
  type: TYPE_NORMAL
- en: As a last step, add a **Tilemap Collider 2D** component to the Tilemap object,
    so it’s walkable by the player character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have two different styles of platforms we can use to create visually
    distinct areas in the level. In the next section, we’ll take platforms to the
    next level by introducing movement and triggering interactions in the environment
    with a C# script.
  prefs: []
  type: TYPE_NORMAL
- en: Moving platforms and triggers – Creating a dynamic interactable environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding moving platforms to our game’s level adds to the visual interest and
    provides additional challenges for the player. Unity again provides tooling that
    makes creating moving platforms a simple and straightforward task right in the
    scene View and without needing to write any code.
  prefs: []
  type: TYPE_NORMAL
- en: We previously used Sprite Shape to make a closed platform, but Sprite Shape
    also allows the creation of open shapes, and that will be perfect here for making
    a small platform that we can move.
  prefs: []
  type: TYPE_NORMAL
- en: Moving a Sprite Shape platform with Splines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced for the Unity 2022 tech stream, we have a new 2D package called `Spline`
    component is used. And the `Sprite Animate` component is used for moving a platform
    along the spline path and doing so without using any code. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: Splines
  prefs: []
  type: TYPE_NORMAL
- en: Smooth shapes can be created with splines by having a generated line pass through
    any arbitrary number of control points. Different approaches for interpolating
    the line and providing adjustments between hard edges and rounded corners are
    available, such as Catmull-Rom (helpful in calculating a curve that passes through
    all control points), Bézier curves (which provide handles to adjust the tangents
    of the line in relation to points), and B-Splines (similar to Catmull-Rom splines
    but the generated line does not necessarily pass through the control points).
  prefs: []
  type: TYPE_NORMAL
- en: The Unity 2022 **Splines** package specifically supports Linear, Catmull-Rom,
    and Bézier types.
  prefs: []
  type: TYPE_NORMAL
- en: To use Splines in our project, we’ll need to verify that the package is installed.
    Open `splines` or find **Splines** in the **Packages** list to select and install.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of creating a moving platform is creating the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an open Sprite Shape profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already had an introduction to Sprite Shape when we created the closed platform
    in the *Creating a closed Sprite Shape profile* section. Creating an open Sprite
    Shape is even easier!
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following few steps to create an open Sprite Shape profile asset:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project window, within the `Assets/Sprites/Sprite Shapes` folder, select
    **Create** | **2D** | **Sprite Shape Profile** and name it *Platform* *Open 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `sprite_strip_rock` sprite by dragging it from the project window
    and into the `SpriteShapeEdge` placeholder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Open Sprite Shape asset properties](img/B18347_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Open Sprite Shape asset properties
  prefs: []
  type: TYPE_NORMAL
- en: With the profile asset created, we can now add our first open Sprite Shape moving
    platform to the scene by clicking **GameObject** | **2D Object** | **Sprite Shape**
    | **Open Shape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the `SpriteShapeController` component’s **Profile** field, then use
    the **Shape** editing tool in the scene Toolbar overlay to make a small straight
    platform (as seen in *Figure 4**.13*). Hint: Use only two knots with **Tangent
    Mode** set to **Linear**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, the last step required to make this open Sprite Shape a walkable
    platform for the player character is to add a collider – we also use the `edge`.
  prefs: []
  type: TYPE_NORMAL
- en: Once added, ensure the **Sprite Shape Controller** | **Collider** | **Updated
    Collider** field is enabled, then adjust the **Offset** value to line up with
    the top edge sprite (this can be adjusted at any time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, let’s keep our moving platforms on the same Sorting Layer as all the
    other platforms in the level: **Default**.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step in creating the moving platform is setting the path it will take.
  prefs: []
  type: TYPE_NORMAL
- en: Spline path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like how we work with splines to create the Sprite Shape platforms, we
    can use Unity’s **Splines** feature tooling to create generic spline paths for
    any number of gameplay reasons. Here, we’re simply building a path for a platform
    to move between two points (it could be more, but we’re only creating a simple
    vertical or horizontal moving platform).
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, use the **Create** menu or click **GameObject**
    | **3D Object** | **Spline** | **Draw Spline Tool…** to add a new Spline to the
    scene (rename it or hit *Enter* to accept the default). Yes, Splines are considered
    3D objects because the spline path’s knots are Vector3 positions (relative to
    the GameObject’s transform position, so they are in **Local Space**). We’ll be
    using them solely in 2D (*X* and *Y* axes) for this project, so just be mindful
    that the *Z* axis should always have a zero value.
  prefs: []
  type: TYPE_NORMAL
- en: With the `0`, `0`, `0`) – the **Spline** object position will be set to the
    clicked position).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click to add a second knot some distance below the first one and use the **Sprite
    Inspector** overlay to set its *X* position value to zero so the knots are vertically
    aligned, as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Working with Bezier Splines for an open Sprite Shape platform](img/B18347_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Working with Bezier Splines for an open Sprite Shape platform
  prefs: []
  type: TYPE_NORMAL
- en: Note that the **Spline Inspector** overlay may be docked to the side of the
    scene View when the Spline tool is selected and as shown in *Figure 4**.13*. You
    can click on the icon in the overlay toolbar or drag it into the scene View window
    to work with the selected Spline knot’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to edit the position, or the knot’s **Tangent Mode**, use the **Spline
    Transform** tool, and for adding knots to the spline, use the **Draw Splines**
    tool (both are available in the **Toolbar** overlay when a Spline object is selected
    in **Hierarchy**).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation | New in Unity 2022
  prefs: []
  type: TYPE_NORMAL
- en: '**Splines**: [https://docs.unity3d.com/Packages/com.unity.splines%401.0/manual/getting-started-with-splines.xhtml](https://docs.unity3d.com/Packages/com.unity.splines%401.0/manual/getting-started-with-splines.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to get things moving!
  prefs: []
  type: TYPE_NORMAL
- en: Spline Animate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Splines` package provides additional components covering some common use
    cases for spline paths. We will use one of them here – the **Spline** **Animate**
    component.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of housekeeping is in order to make our moving platform not only easy
    to animate and work with but also so that we can create a prefab that will make
    it quick and easy work to add additional moving platforms throughout the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we have an open Sprite Shape platform object and a Spline path object
    at the root of the hierarchy. To make this a reusable prefab, where we have the
    most control over the position of the spline path and platform, we’ll want to
    end up with this object hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Hierarchy relationships](img/B18347_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Hierarchy relationships
  prefs: []
  type: TYPE_NORMAL
- en: Use the **Create Empty** or **Create Empty Parent** options available in the
    **Hierarchy** window’s **Create** menu to accomplish this – empty GameObjects
    are a great way to organize or provide an additional way to manipulate objects!
  prefs: []
  type: TYPE_NORMAL
- en: Just be sure the Spline and platform object’s transform positions are at (`0`,
    `0`, `0`) since we should be using the root object (`Moving Platform 1`) transform
    position to place the platform in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the reason for creating the object hierarchy this way was to add the
    object we’ll move with the **Sprite Animate** component – the **Platform Mover**
    object. Add the **Spite Animate** component now by selecting **Platform Mover**
    and clicking **Add Component** in the **Inspector** window. Assign the **Spline**
    object to the **Spline** field, select **Spline Object** in the **Align To** field,
    then set **Loop Mode** to **Ping Pong** (so the platform moves back and forth
    between the spline knots).
  prefs: []
  type: TYPE_NORMAL
- en: Adjust **Duration** and **Easing** to your liking using the following figure
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Moving the platform with Spline Animate](img/B18347_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Moving the platform with Spline Animate
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! I said it would be easy to get our platform moving… it just required
    a bit of setup. You can preview the movement of the platform right in the scene
    View without having to enter **Play Mode**. Use the **Play**, **Pause**, and **Reset**
    controls to adjust the duration, type of easing, position of the spline knots,
    and offset position of **Platform Open 1** until you’re satisfied with the positioning
    and movement.
  prefs: []
  type: TYPE_NORMAL
- en: Finish up by dragging the `Moving Platform 1` object to the `Assets/Prefabs`
    folder in the project window to create the prefab asset.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering actions in the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Games often have interactions that are triggered in the environment when the
    player moves into a specific area or touches something– think rocks falling, doors
    opening, alerting the enemy, turning lights on/off, transitioning to a cutscene,
    or whatever your game requires. This is pretty trivial to add if we leverage the
    Unity physics engine similar to how we previously performed collecting items in
    the collection game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first add a sprite for the object to our game level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a collider volume around the object to define a trigger area – using
    the least expensive 2D collider type, the better (e.g., `CircleCollider2D`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **IsTrigger** on the collider so that it does not physically interact
    with any other objects in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a component that will invoke an event when the Unity physics message, `OnTriggerEnter2D()`,
    is called when the player enters the collider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re also going to take a designer-friendly approach and make the action assignable
    in the **Inspector** window so we won’t have to create a custom script for every
    type of triggered event. This will make the triggered event component reusable
    anywhere in the game we want the player to trigger an interaction. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: UnityEvent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The event delegate type we’ll use here is **UnityEvent** – we’ve previously
    used **UnityAction**. The difference is that **UnityEvent** is serialized and
    becomes available in the **Inspector** to assign public methods.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*UnityEvent*: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityEvent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityEvent.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: In Unity 2022, the **UnityEvent** list in the **Inspector** is now reorderable!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works by creating a new script named `TriggeredEvent`, with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down, especially since there are several new items worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: The class declaration is decorated with the `RequireComponent` attribute. This
    means that when the `TriggeredEvent` script is added as a component to a GameObject,
    it will require that the specified type exists as a sibling component on the GameObject.
    If possible, the required component will be added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, we only specified the base `Collider2D` type that all of the 2D
    colliders inherit from – this allows us to add any type of collider as a trigger
    volume for the triggered event. If we try to add the script to a GameObject that
    does not already have a 2D collider added, we’ll receive this error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Can’t add script for the required component](img/B18347_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Can’t add script for the required component
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to add a 2D collider (appropriate for the player interaction
    scenario) to the GameObject before adding the `TriggeredEvent` script. For this
    example, we’ve added a `CircleCollider2D`, placed and sized it in front of a peculiar
    rock formation, and triggered a particle system to start playing (as seen in *Figure
    4**.16*).
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `IsTriggeredByPlayer` Boolean that we’ll set in the **Inspector**.
    A few lines below it will be used to determine whether only the player can trigger
    the interaction. This field is optional but a quick and easy addition that could
    provide some exciting behavior if, say, enemies or other objects enter the collider
    (think outside the box here for all the different things that could be triggered
    in the environment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As just discussed, the `UnityEvent` declaration is what allows us, as the developer
    and designer, to add the specific interaction – one or many – in the **Inspector**
    that is invoked when triggered (as seen in the **Inspector** under the darker
    gray **On Triggered ()** section in *Figure 4**.16*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `if` block determines whether we’ll continue running the triggered code
    or not if we require the event only to be triggered by the player. So if `IsTriggeredByPlayer`
    is set to `true,` the conditional AND operator (`&&`) will evaluate whether the
    object collided is tagged `Player`. And if not, it will stop executing this method’s
    code (by using the `return` statement).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '&& (C#)'
  prefs: []
  type: TYPE_NORMAL
- en: The conditional AND (**&&**) operator means both statements must logically equate
    to **true** for executing the code in the block. Note that this has “short-circuiting”
    logic, meaning that if the first expression evaluates to **false**, then the second
    expression will not be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to note here is that `Tags.Player` will give you a compiler
    error because the `Tags` type has not been defined yet (identified by a red squiggly
    underline). Let’s fix that now. We’ll use the built-in refactoring tooling in
    the IDE by either right-clicking on the word **Tags** (or clicking anywhere on
    **Tags** and pressing *Alt* + *Enter*, or *Ctrl* + *.*, depending on your IDE).
  prefs: []
  type: TYPE_NORMAL
- en: In the dialog that opens, select **Refactoring...** | **Generate type ‘Tags’**
    | **Generate class ‘Tags’ in a** **new file**.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: For performance reasons, you should always use **CompareTag()** over evaluating
    the **.tag** property of a GameObject with the **==** operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new file created, add a constant for the `Player` tag string like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that this class does not inherit from `MonoBehaviour` because we won’t
    be adding it to a GameObject in the scene. It will be used solely when we need
    to specify an object’s tag anywhere in our code – minimizing the use of string
    literals throughout the code, issues related to simple spelling mistakes that
    are easy to overlook, and providing CodeLens references for everywhere it’s being
    used. Anytime you need to reference a tag for any other object in the game, just
    add it here.
  prefs: []
  type: TYPE_NORMAL
- en: Const (C#)
  prefs: []
  type: TYPE_NORMAL
- en: A variable declared as a constant is an immutable value that does not change
    for the program’s life (that is, known at compile time). A **const** (**string**,
    **int**, **float**, etc.) declared with a public accessor is available to other
    classes without an instance reference – similar to how a static variable would
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: The last line invokes the event(s) assigned in the `OnTriggered?.Invoke();`
    – note that the `?.` (null-conditional) operator is optional here, but I always
    include it for invoked member types for code consistency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, with the setup shown in the following figure, when the player enters the
    collider, particles will spawn from the rock!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – TriggerEvent collider with scene View icon](img/B18347_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – TriggerEvent collider with scene View icon
  prefs: []
  type: TYPE_NORMAL
- en: With this kind of reusable component for triggering any type of event, it is
    now trivial to add interactions throughout the game level by both developers and
    designers working on the project. Easy-peasy!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve now finished up with all the 2D feature tooling used
    to create all the walkable platforms, including those moving, as well as interactivity
    in the level. In the next section, we’ll look at finalizing the game’s environment,
    adding polish, and optimizing the draw calls for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding polish to our environment to immerse the player and optimizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the tools and techniques introduced in the previous sections, you should
    now explore building out your level design. Closed Sprite Shapes for the primary
    platforms, open Sprite Shapes for platforms that are both static and moving, and
    Tilemap platforms mixed in for a particular area of the level – all used to give
    the player an experience and challenge on their journey to the habitat station
    we provide a signpost for in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Platforms on a blank screen are rather dull. Let’s add some polish to the level
    by adding a background and some movement.
  prefs: []
  type: TYPE_NORMAL
- en: Polishing the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With your game level now well on its way to being defined (we’ll, of course,
    be making plenty of adjustments once we add the player character and can start
    play-testing the level), let’s have a look at finishing and polishing the environment,
    starting with adding the background and foreground elements to more fully flesh
    out the game design – providing immersion and setting the tone for the player
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Background parallax effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, we’ll be applying a relatively old 2D game design technique
    called parallax to layered images in the background to create depth and a sense
    of immersion in the environment. We’ll accomplish this with a custom C# script
    since Unity does not provide a 2D feature specifically geared toward tackling
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a new C# script in the `Assets/Scripts` folder and name
    it `ParallaxLayers`. This script will be a reusable component that we can use
    to add parallax movement to any number of layered images. In the 2D adventure
    game, we’ll use this for the background and a few foreground elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code item by item:'
  prefs: []
  type: TYPE_NORMAL
- en: The first public variable declared is a list of the images we’ll use for the
    parallax layers that will be moved at different speeds based on their depth (this
    is how the parallax effect is achieved; objects in the distance appear to move
    slower than nearby objects). We use C# `List<T>` specifying `Layer` as the type,
    where `Layer` is a custom class [object] we declare to hold the reference for
    a specific image and the depth value assigned to it for calculating its movement
    speed relative to the camera movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List (C#)
  prefs: []
  type: TYPE_NORMAL
- en: '**List<T>** is a collection of strongly typed objects that can be added, accessed
    by index, or returned by methods it provides for searching. Methods are also provided
    for sorting and manipulating objects in different ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional reading: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1'
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `Layer` nested class declaration with public fields for `Image`
    with a type of `Renderer` (all sprites, meshes, lines, trails, and particles are
    drawn with a component derived from the `Renderer` class) and `ZDepth`, which
    is an `int` value for the image’s distance away from the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ZDepth` variable declaration is also decorated with the `Tooltip` and `Range`
    attributes (these can be comma delimited in a single `[]` statement). The `Tooltip`
    attribute displays the specified message text when the mouse hovers over the field
    label in the `Range` attribute will limit the values valid for the field between
    the range specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Attributes*: [https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Layer` class declaration itself is decorated with the `System.Serializable`
    attribute. A class declaration is not available in the `Layers` accessor is public,
    that alone is not enough to serialize the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The private `_camera` member is used to cache the main camera reference because
    we’re getting values from it multiple times in our calculation, and we want this
    to be performant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LateUpdate()` is executed after `Update()` and after the internal animation
    update is processed. After everything in the game loop has been updated, we can
    use `LateUpdate()` to affect those updates further. In this case, we want to move
    the background layers only after the camera movement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*LateUpdate*: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.LateUpdate.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.LateUpdate.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order of execution for event** **functions**: [https://docs.unity3d.com/2022.3/Documentation/Manual/ExecutionOrder.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/ExecutionOrder.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Did the camera move? A quick evaluation on the `_cameraLastScreenPosition` Boolean
    value will tell – if not, don’t execute further (using the `return` statement).
    Don’t run code that you don’t have to!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is where the magic happens… using the `foreach` iterator, we’ll go through
    each of the `Layer` items added in the **Inspector** and move it the calculated
    distance relative to how far the camera moved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`parallaxSpeed`: we start by getting a ratio for the depth of the image from
    the camera position (order of operations for math), returning the absolute value
    (a positive number), clamping the value to a range of `0` to `1`, and finally
    subtracting the clamped value from `1` to get a percentage of the camera’s movement
    to move the image:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`difference`: How far the camera moved from its current position compared to
    its last position:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`transform.Translate()`: Move the image horizontally on the *X* axis (due to
    `Vector3.right`) by the distance the camera moved multiplied by the speed factor
    (effectively, speed values closer to `1` move relatively the same distance as
    the camera):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: foreach (C#)
  prefs: []
  type: TYPE_NORMAL
- en: The **foreach** statement iterates over a collection of items and executes its
    code block for each. Each list element is of the type specified when the list
    is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional reading on C# iteration statements: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements)'
  prefs: []
  type: TYPE_NORMAL
- en: Finish off by updating the variable that holds the camera’s last position after
    moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: int versus float divide by zero
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, *Hey, wait a second, Scott, with the* **Range** *attribute,
    you’re allowing a zero value for distance, and to calculate the parallax speed,
    we’re dividing by the distance. So, if the distance is zero, then won’t that throw
    a divide-by-zero exception error?* What an astute observation to make that point;
    thank you for asking! You would be correct if the camera’s **transform.position.z**
    value is an integer type. It would absolutely throw an exception, but it is a
    float value, so dividing by zero will never throw an exception because, in C#,
    floating-point types are based on the IEEE 754 standard, which allows for numbers
    representing infinity and **Not a** **Number** (**NaN)**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional** **reading**: [https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed our parallax effect script, let’s add the background
    layers to the scene and assign the field values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `ZDepth` value of 10,000 – meaning they’ll appear to be stationary
    – and images closer to the camera having values less than 1,000 – meaning they’ll
    move more closely to the camera movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Parallax background layers assigned to the Inspector](img/B18347_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Parallax background layers assigned to the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure also shows an object hierarchy we can use to organize the
    images for the background layers (and foreground images using the same technique).
    Drag the background images from `Assets/Sprites/Background` into the scene and
    parent the objects in **Hierarchy** to a **Background** empty GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: With the objects in the scene, you can position them and use the Sorting Layer
    and Order in Layer (Sprite Renderer) to set their display. Be sure to add a new
    **Background** Sorting Layer and position it at **Layer 0** so that our platforms’
    **Default** layer will draw in front of the background images.
  prefs: []
  type: TYPE_NORMAL
- en: This is more art than technical so play around with the position and scale,
    background image order, and so on, until things look good!
  prefs: []
  type: TYPE_NORMAL
- en: Now, add the `ZDepth` value for each image – assign higher values for the images
    further in the distance.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the parallax effect by entering `ZDepth` value so that it works
    within the bounds of your level design.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue adding polish to the environment with some clouds animated to
    move across the sky. This will be super easy by again leveraging the **Spline**
    **Animate** component.
  prefs: []
  type: TYPE_NORMAL
- en: Animated clouds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned how to easy it is to create a moving platform
    using a simple spline path and a component to animate its position. We’ll use
    the same approach to create two layers of different-style clouds moving across
    the sky at different speeds. The only difference here, compared to the platform,
    is that the clouds will start off-screen and loop continuously, instead of a ping-pong
    movement (clouds usually only move in one direction across the sky, after all).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to create two layers of clouds moving across the sky:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a Spline object to the scene using `90`, `0`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add cloud sprites to the scene and parent along with the Spline to a new empty
    GameObject named `Clouds 1` (you can add as many cloud layers as desired, just
    increment the count, as shown in *Figure 4**.18*). We have two cloud layers, and
    multiple cloud sprites added for the `Clouds` `2` object.*   Add a **Spline Animate**
    component to the cloud image GameObject and set the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the Spline object from **Hierarchy** to the **Spline** field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Align To** as **Spline Object**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Duration** field to a value that sets the clouds moving slowly across
    the sky – make sure to set this value to a different time, so multiple cloud layers
    are offset from one another!
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Loop Mode** as **Loop Continuous** because we want the clouds to restart
    the animation over again on the right side once they reach the end knot on the
    left side.![Figure 4.19 – Animated background clouds setup](img/B18347_04_19.jpg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.19 – Animated background clouds setup
  prefs: []
  type: TYPE_NORMAL
- en: This is a quick and easy way to bring more life to the environment. The same
    is true for the next 2D tooling feature we’ll introduce to add more polish.
  prefs: []
  type: TYPE_NORMAL
- en: Animated environment art with sprite skin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now set up some of the plant entity’s vines to sway and move in different
    ways in the background, giving the player a sense of presence by the unnatural
    forces at work here.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already imported and prepared artwork to use with `Assets/Sprites/Sprite
    Skins` folder and open **Sprite Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to create a mesh geometry that is deformable by a set
    of weighted bones:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Sprite Editor** dropdown menu, select **Skinning Editor** and enable
    the **Visibility** tool (top-right of the window next to **Revert** **and Apply**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Bones** section (left side of the window), select the **Create**
    **Bone** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is essential and not apparent in the **Skinning Editor** workflow
    – double-click on the sprite!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have a cursor with a red dot at the tip. Start creating bones
    by dragging the bones to the desired length, click to add a new bone, and hit
    the *Esc* key when finished. Refer to *Figure 4**.19* for an example of how to
    approach the bones layout (keep in mind that it is more performant to use fewer
    bones while still allowing for the desired deformation).
  prefs: []
  type: TYPE_NORMAL
- en: 'When satisfied with the bones, select **Auto Geometry** under the **Geometry**
    section and click the **Generate For** **Selected** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Animating a vine with Sprite Skinning](img/B18347_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Animating a vine with Sprite Skinning
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, select **Auto Weights** under the **Weights** section and click the
    **Generate** button (bottom-right corner of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, click the **Apply** button, and we have created our first Sprite
    Skin. Yay, ready for animation! You can test the deformation in **Skinning Editor**
    by clicking the **Preview Pose** button under the **Pose** section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our vine is *skinned*, it’s ready for animating!
  prefs: []
  type: TYPE_NORMAL
- en: Animating a Sprite Skin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s now add the vine sprite to the game environment as a background element
    and prepare it to be animated:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the vine sprite into the **Scene Hierarchy** as a child of one of your
    background images (so that it will move along with the background parallax), position,
    and set the Sorting Layer and Order in Layer accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the sprite selected, in the `skin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Sprite Skin** component, click the **Create** **Bones** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to add animation to the vine. While the vine is selected, open the
    `.anim`) that we’ll name `Vine 1 Idle` and save to the `Assets/Animation` folder.
    Put your animator hat on now… because it’s time to animate!
  prefs: []
  type: TYPE_NORMAL
- en: Using *Figure 4**.20* as a reference, by clicking the red record button (the
    **Animation** window), a keyframe will be recorded in the **Animation** timeline
    any time you rotate or position a bone (using the same transform tools we manipulate
    any object with). Scrub the timeline and repeat the process to get the desired
    movement for the vine.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is more art than technical and takes some trial and error. With
    practice, this becomes more intuitive and quicker to achieve good results. Use
    the playback controls and adjust accordingly – you’ve got this!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Animating the vine with keyframed bone rotation](img/B18347_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Animating the vine with keyframed bone rotation
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Animation*: [https://docs.unity3d.com/2022.3/Documentation/Manual/AnimationSection.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/AnimationSection.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: From the static pictures in this book, you can’t get a proper sense of how creepy
    these vines look when animated! Enter **Play Mode** to experience this yourself
    in your level design, or make sure to check out the completed project code or
    play the game online from the GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to keep the vine animations performant in our game now.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Skin performance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the last step for increasing animation performance with Sprite Skin, install
    the **Burst** and **Collections** packages to enable **deformation batching**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Installing Burst and Collections for optimization](img/B18347_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Installing Burst and Collections for optimization
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on the performance optimization topic, before we move on to importing
    and setting up the player character and enemies for the game, let’s look at optimizing
    the sprite draw calls to help keep our framerate from dropping to unacceptable
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing draw calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most impactful performance optimization we can make is addressing the draw
    calls. This was discussed briefly in a callout in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041)
    in the *Importing Sprites* section when we created a **Sprite Atlas**. Not surprising,
    we’re going to do the same thing here now.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Atlas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `Assets/Sprites` folder, then choose `Sprite Atlas`. Note that we won’t
    be adding any of the 2D sprite normal maps as those will be handled internally
    with the Sprite Atlas in the same way they are in **Sprite Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: Assign the individual sprite images from the `Assets/Sprites` folders to the
    `Assets/Sprites/Background` `Normal Maps`).
  prefs: []
  type: TYPE_NORMAL
- en: When there are too many images to fit into a single texture, Sprite Atlas will
    create additional textures and indicate that with a dropdown indicator labeled
    **#0** in the title bar of the **Preview** window. In some cases (for example,
    larger games), it may be desirable to use multiple Sprite Atlases where you will
    determine which one to bind at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note for compatibility reasons, while using **Sprite Shape,** we’ll have to
    make sure to disable both **Allow Rotation** and **Tight Packing**.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Sprite* *Atlas*: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-SpriteAtlas.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-SpriteAtlas.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at polishing the visuals of the *Outer World* 2D
    adventure game by adding a parallax background effect and animated elements. We
    then looked at keeping our game performant by reducing sprite draw calls.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the completed game code
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, the example code for this book can be downloaded from the GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter first covered the game, level, and environment design by introducing
    new elements for the GDD to cover the larger scope of the adventure game, importing
    and prepping artwork for use with Unity’s 2D features, and introducing a new level
    design principle to guide the player to a goal.
  prefs: []
  type: TYPE_NORMAL
- en: We continued with the imported artwork by creating static and moving platforms
    to challenge players on their journey. Then, we immersed the player in the game
    world by setting up a parallax background and animated environmental elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we optimized the draw calls for the sprites that define all the elements
    of the level and environment with a Sprite Atlas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll set up the player character with an imported rig
    using the PSD Importer, which will allow a quick setup of the character for animating.
    We’ll also learn how to add a player weapon that shoots projectiles in an optimized
    way by implementing another feature new for Unity 2022, and start introducing
    the enemy characters the player will be fending off on their journey to the habitat
    station.
  prefs: []
  type: TYPE_NORMAL
