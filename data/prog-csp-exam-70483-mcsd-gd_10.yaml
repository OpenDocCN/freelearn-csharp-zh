- en: Find, Execute, and Create Types at Runtime Using Reflection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反射在运行时查找、执行和创建类型
- en: The .NET Framework contains not just code but metadata as well. Metadata is
    data about assemblies, types, methods, properties, and so on used in a program.
    These assemblies, properties, types, and methods are classes defined within the
    C# programming language. These classes, types, and methods are retrieved at runtime
    to parse a developer's application logic for execution. Attributes allow us to
    add extra information to these programs as well as methods that can be used during
    runtime while executing application logic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架不仅包含代码，还包含元数据。元数据是关于程序中使用的程序集、类型、方法、属性等的描述性数据。这些程序集、属性、类型和方法是在 C# 编程语言内部定义的类。这些类、类型和方法在运行时被检索以解析开发者的应用程序逻辑以执行。属性允许我们在这些程序以及运行时可以使用的程序逻辑中添加额外的信息。
- en: The .NET Framework also allows developers to define this metadata information
    during development. It can be read during runtime using reflection. Reflection
    enables us to create an instance of the type retrieved and to invoke its methods
    and properties.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架还允许开发者在开发期间定义此元数据信息。它可以在运行时通过反射读取。反射使我们能够创建检索到的类型的实例，并调用其方法和属性。
- en: In this chapter, we will understand how the .NET Framework allows us to read
    and create metadata, and we will also learn how to use reflection to read metadata
    and process it during runtime. In the *Attributes* section, we will focus on using
    attributes, creating custom attributes, and learn how to retrieve attribute information
    at runtime. The *Reflection* section supplies an overview of how we can use reflection
    to create types, access properties, and invoke methods. Reflection also allows
    us to retrieve attribute information; for example, this could be extra information
    that we provided to .NET Runtime to be processed while executing the application
    logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 .NET 框架如何允许我们读取和创建元数据，我们还将学习如何使用反射在运行时读取元数据并处理它。在 *属性* 部分，我们将专注于使用属性、创建自定义属性以及学习如何在运行时检索属性信息。*反射*
    部分提供了如何使用反射创建类型、访问属性和调用方法的概述。反射还允许我们检索属性信息；例如，这可能是我们在执行应用程序逻辑时提供给 .NET 运行时的额外信息。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Reflection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The exercises in this chapter can be performed using Visual Studio 2012 and
    later with the .NET Framework 2.0 and later. However, any new C# features from
    C# 7.0 and later require you to have Visual Studio 2017.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习可以使用 Visual Studio 2012 及更高版本以及 .NET Framework 2.0 及更高版本执行。然而，任何从 C# 7.0
    及更高版本的新特性都需要您拥有 Visual Studio 2017。
- en: If you don't have a license for any of these products, then you can download
    the Community Version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这些产品的任何许可证，你可以从 [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
    下载 Visual Studio 2017 的社区版。
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10)。
- en: Attributes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Metadata or declarative information on types, methods, and properties can be
    associated using attributes. Metadata refers to what types are defined in a program.
    For instance, a class is a type: each class defines certain properties and methods,
    each property is of a type, and each method accepts certain data types and returns
    certain data types. All this information is referred to as metadata and can be
    accessed and retrieved during program execution.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用属性将类型、方法和属性上的元数据或描述性信息关联起来。元数据指的是程序中定义的类型。例如，一个类是一个类型：每个类定义了某些属性和方法，每个属性属于一个类型，每个方法接受某些数据类型并返回某些数据类型。所有这些信息统称为元数据，可以在程序执行期间访问和检索。
- en: Like any other method, while you define an attribute, you can define the parameters
    as well. You can define one or more attributes on an assembly, class, method,
    or property. Based on the program requirements, you can define what types of attribute
    your application needs and define them in your program. Once defined, you can
    read this information while executing your program and then process it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他方法一样，当你定义一个属性时，你也可以定义参数。你可以在汇编、类、方法或属性上定义一个或多个属性。根据程序要求，你可以定义应用程序需要的属性类型，并在程序中定义它们。一旦定义，你可以在程序执行时读取这些信息，然后进行处理。
- en: In the following section, we will demonstrate how to use attributes and create
    custom attributes as per our requirements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何使用属性并按照我们的要求创建自定义属性。
- en: Using attributes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性
- en: A declarative way of associating information to code can be done via attributes.
    However, only a few attributes can be used on every type. Instead, they are used
    for specific types. Attributes on any type can be specified by using square brackets,
    `[]`, on top of the type that we want to apply.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过属性将信息关联到代码的一种声明性方法是。然而，只有少数属性可以用于每个类型。相反，它们用于特定类型。可以通过在要应用的类型上方使用方括号`[]`来指定任何类型的属性。
- en: 'Let''s take a look at the following code. Generally, we see the `Serializable`
    attribute when we want to serialize an object to the binary or XML formats. In
    real-world applications, when we need to transfer a large object over the wire,
    we serialize an object into one of the aforementioned formats and then send it.
    The serialize attribute on a class enables runtime to allow converting the object
    to binary or XML or any format required by the program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码。通常，当我们想要将对象序列化为二进制或XML格式时，我们会看到`Serializable`属性。在实际应用中，当我们需要通过网络传输大型对象时，我们会将对象序列化为上述格式之一，然后发送。类上的序列化属性使运行时能够允许将对象转换为二进制或XML或程序所需的任何格式：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another common usage of attributes is in unit test projects. Observe the following
    code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的另一种常见用途是在单元测试项目中。观察以下代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code snippet, we create a new test project where two attributes
    are added to each class and method. By adding them in this way, we are letting
    the framework know that this class represents a test class and that the method
    is a test method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个新的测试项目，其中每个类和方法都添加了两个属性。通过这种方式添加它们，我们让框架知道这个类代表一个测试类，而这个方法是测试方法。
- en: As mentioned earlier, the use of attributes can be restricted to specific types.
    To achieve this, we will use attribute targets. By default, an attribute is applied
    to the preceding type. However, using a target, we can set whether the attribute
    applies to a class, method, or an assembly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，属性的使用可以限制为特定类型。为了实现这一点，我们将使用属性目标。默认情况下，属性应用于前面的类型。但是，使用目标，我们可以设置属性是否应用于类、方法或汇编。
- en: When the target is set to assembly, it means that the attribute is applied to
    the entire assembly. Similarly, a target can be set to a module, field, event,
    method, property, or type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标设置为汇编时，意味着该属性应用于整个汇编。同样，目标可以设置为模块、字段、事件、方法、属性或类型。
- en: For example, an attribute can be set on a field to let the runtime know what
    type of input is accepted. Additionally, it can be set on a method to specify
    whether it is a normal method or a web method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以在字段上设置属性，让运行时知道可以接受哪种类型的输入。此外，它还可以设置在方法上，以指定它是一个普通方法还是一个Web方法。
- en: 'Some common attributes defined by the framework include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 框架定义的一些常见属性包括以下内容：
- en: '**Global**: Attributes that are applied at the assembly or module level are
    generally global attributes, for example, `AssemblyVersionAttribute`. You might
    have seen this in every .NET project that is created using Visual Studio.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**：在汇编或模块级别应用的属性通常是全局属性，例如`AssemblyVersionAttribute`。你可能已经在使用Visual Studio创建的每个.NET项目中看到过它。'
- en: 'Let''s take a look at the following example. Here, you can see the `assembly.cs`
    file created when you create any .NET project using Visual Studio. Every assembly
    contains the following code, which tells the runtime about the current assembly
    that is being executed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例。在这里，你可以看到使用Visual Studio创建任何.NET项目时创建的`assembly.cs`文件。每个汇编都包含以下代码，它告诉运行时正在执行当前汇编：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Obsolete**: This attribute allows us to mark an entity or a class that should
    not be used. Therefore, when applied, it generates a warning message that is provided
    while applying the attribute. This class defines three constructors: the first
    without any parameters, the second with one parameter, and the third with two
    parameters. From a code-readability perspective, it is recommended that we use
    constructors with parameters as they generate warning or error messages based
    on usage. Additionally, setting the second parameter to `true` while applying
    an attribute will throw an error, whereas `false` will generate a warning. In
    the following code, we will see how we can use an obsolete attribute.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过时**: 此属性允许我们标记不应使用的实体或类。因此，当应用时，它会产生一个在应用属性时提供的警告消息。此类定义了三个构造函数：第一个没有任何参数，第二个有一个参数，第三个有两个参数。从代码可读性的角度来看，建议我们使用带参数的构造函数，因为它们根据使用情况生成警告或错误消息。此外，在应用属性时将第二个参数设置为`true`将引发错误，而`false`将生成警告。在下面的代码中，我们将看到如何使用过时属性。'
- en: 'In the following code snippet, we defined a class named `Firstclass`; later,
    a new class was created with the name `SecondClass`. When we want new users accessing
    our library to use the second class rather than the first class, then we can use
    an `Obsolete` attribute with a message so that new users will see it and act accordingly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们定义了一个名为`Firstclass`的类；后来，创建了一个名为`SecondClass`的新类。当我们希望新用户访问我们的库时使用第二个类而不是第一个类，那么我们可以使用带有消息的`Obsolete`属性，这样新用户就会看到并相应地采取行动：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Conditional**: When a conditional attribute is applied, the execution of
    the preceding code depends on the evaluation of the attribute. In a real-project
    scenario, while running a program in a live environment, you don''t want to log
    information and messages and fill up your storage. Instead, you can have a conditional
    attribute on your log methods, which will allow you to write when a flag in your
    configuration file is set to `true`. In this way, you can actually implement selecting
    logging.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件性**: 当应用条件属性时，前面代码的执行依赖于属性的评估。在实际项目场景中，当在一个实时环境中运行程序时，你不想记录信息和消息并填满你的存储空间。相反，你可以在你的日志方法上设置一个条件属性，这样你就可以在配置文件中的标志设置为`true`时进行写入。这样，你实际上可以实施选择日志。'
- en: 'In the following code, we have a `LogMessage` method; however, the attribute
    above the class will let the runtime application know that, when the `LogErrorOn`
    attribute is set to `yes` or `true`, it should execute this method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有一个`LogMessage`方法；然而，类上方的属性会让运行时应用程序知道，当`LogErrorOn`属性设置为`yes`或`true`时，它应该执行此方法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Caller information**: The caller information attribute allows you to retrieve
    who is calling the method. They are `CallerfilePathAttribute`, `CallerLineNumberAttribute`,
    `CallerMemberNameAttribute`. Each one has its own purpose, as their names suggest.
    They allow us to get the line number, the method name, and the path of the file.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用者信息**: 调用者信息属性允许你检索调用方法的人。它们是`CallerfilePathAttribute`、`CallerLineNumberAttribute`、`CallerMemberNameAttribute`。每个都有自己的用途，正如它们的名称所暗示的那样。它们允许我们获取行号、方法名和文件路径。'
- en: Creating custom attributes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义属性
- en: C# allows you to define your own attributes. This is similar to normal C# programming
    where you define classes and properties. To define an attribute, the first thing
    you need to do is to inherit it from the `System.Attribute` class. The class and
    properties you define are used to store and retrieve data at runtime.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许你定义自己的属性。这类似于正常的 C# 编程，其中你定义类和属性。要定义一个属性，你需要做的第一件事是从`System.Attribute`类继承它。你定义的类和属性用于在运行时存储和检索数据。
- en: 'There are four steps that you need to complete in order to complete defining
    custom attributes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成自定义属性的定义，你需要完成以下四个步骤：
- en: Attribute usage
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性使用
- en: Declaring attribute class
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明属性类
- en: Constructors
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Properties
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: 'Attribute usage can be defined by using `System.AttributeUsageAttribute`. We
    already mentioned that there are restrictions on certain attributes, which define
    where they can be used—for example, in classes, methods, or properties. `AttributeUsageAttribte`
    allows us to define such restrictions. `AllowMultiple` specifies whether this
    attribute can be used more than once on a specific type. Inherited controls defining
    child classes form the current attribute class. The following is the general syntax
    for using the `AttributeUsage` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`System.AttributeUsageAttribute`定义属性使用。我们已提到，某些属性的使用有约束，这定义了它们可以在哪里使用——例如，在类、方法或属性中。`AttributeUsageAttribte`允许我们定义这样的约束。`AllowMultiple`指定此属性是否可以在特定类型上使用多次。定义子类的继承控件形成当前属性类。以下是使用`AttributeUsage`类的通用语法：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you might have observed, you can declare the `AttributeUsage` attribute using
    its constructor on top of the custom attribute you want to define with the three
    parameters. With `AtributeTargetsAll`, you can use `CustomAttribute` on any type
    of element that is a class, property, method, and so on. A full list of allowed
    values is defined at [https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All](https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已观察到，您可以使用其构造函数在您想要定义的自定义属性上声明`AttributeUsage`属性，并使用三个参数。使用`AtributeTargetsAll`，您可以在任何类型为类、属性、方法等的元素上使用`CustomAttribute`。允许值的完整列表定义在[https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All](https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All)。
- en: '`Inherited` and `AllowMultiple` are both Boolean properties, which accept true
    or false.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inherited`和`AllowMultiple`都是布尔属性，它们接受true或false。'
- en: Once we define `AttributeUsage`, we can now move on to declare our custom class.
    This should be a public class and must inherit from the `System.Attribute` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`AttributeUsage`，我们现在可以继续声明我们的自定义类。这应该是一个公共类，并且必须继承自`System.Attribute`类。
- en: 'Now that we have our class declared, we can move on and define our constructors
    and properties. The framework allows us to define one or more constructors, covering
    all possible scenarios around a different combination of properties. Let''s define
    a custom attribute. A constructor of these attributes accepts three parameters—`AttributeTargets`,
    `AllowMultiple`, and `Inherited`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了我们的类，我们可以继续定义我们的构造函数和属性。框架允许我们定义一个或多个构造函数，覆盖所有可能的属性组合场景。让我们定义一个自定义属性。这些属性的构造函数接受三个参数——`AttributeTargets`、`AllowMultiple`和`Inherited`：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code defines a custom attribute named `CustomerAttribute`. We
    also defined a `CustomerType` enum that we want to use as an `Attribute` property.
    By not defining any parameters in the constructor and assigning the `Customer`
    type to a `Type` property, we are telling runtime, by default, when its value
    is a customer. Additionally, this attribute is set to be used on either a field
    or property so that it cannot be used at the class level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为`CustomerAttribute`的自定义属性。我们还定义了一个`CustomerType`枚举，我们希望将其用作`Attribute`属性。通过在构造函数中不定义任何参数并将`Customer`类型分配给`Type`属性，我们告诉运行时，默认情况下，当其值是客户时。此外，此属性被设置为可以在字段或属性上使用，因此不能在类级别上使用。
- en: 'Now, let''s examine how we can use this attribute in our class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在我们的类中使用这个属性：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we defined an `Account` class where we used our custom attribute. We applied
    an attribute without any parameters. This means that, by default, we create an
    account of the customer type. In the following section, we will demonstrate how
    we can retrieve these attributes and use them in our application logic.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`Account`类，在其中我们使用了我们的自定义属性。我们应用了一个不带任何参数的属性。这意味着，默认情况下，我们创建了一个客户类型的账户。在下一节中，我们将演示我们如何检索这些属性并在我们的应用程序逻辑中使用它们。
- en: Retrieving metadata
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取元数据
- en: As you are aware of OOP concepts, retrieving attribute information is as simple
    as creating an instance of the attribute that we want to retrieve, and then invoking
    the `GetCustomAttribute` method of the `System.Attribute` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，获取属性信息与创建我们想要检索的属性的实例并调用`System.Attribute`类的`GetCustomAttribute`方法一样简单。
- en: 'In the following example, we define a new attribute called `ChapterInfo` and
    define a constructor to mark two of its properties as required parameters:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个名为`ChapterInfo`的新属性，并定义了一个构造函数来标记其两个属性为必需参数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`ChapterName` and `ChapterAuthor` are the two required parameters that the
    developer has to define when using this attribute.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChapterName`和`ChapterAuthor`是开发者在使用此属性时必须定义的两个必需参数。'
- en: 'As you can see, in the following code the attribute is being defined over the
    `Program` class with two values: `Name` and `Author`. In the main method, `GetCustomAttribute`
    is invoked to read its properties, as you would do for any other class type variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在下面的代码中，属性是在`Program`类上定义的，有两个值：`Name`和`Author`。在主方法中，调用了`GetCustomAttribute`来读取其属性，就像您对任何其他类类型变量所做的那样：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Observe the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下输出：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the (`[ChapterInfo("SAMPLECHAPTER", "AUTHOR1")]`) values passed
    in the attribute definition over the program class were retrieved and displayed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在程序类属性定义中传递的（`[ChapterInfo("SAMPLECHAPTER", "AUTHOR1")]`）值被检索并显示出来。
- en: Reflection
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: Reflection is a way to query metadata at runtime from the application program.
    Reflection supplies type information from the assemblies loaded into memory that
    you can use to create an instance of the class and also access properties and
    methods of the class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是从应用程序程序在运行时查询元数据的一种方式。反射提供了从加载到内存的程序集中获取的类型信息，您可以使用这些信息创建类的实例，并访问类的属性和方法。
- en: For example, your application code executes a query and returns a dataset object,
    but your frontend accepts a custom class or model, and the model is defined during
    runtime. Based on the request received, reflection can be used to create the required
    model/class at runtime, access its properties or fields, and set their value by
    traversing through the resulting dataset.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的应用程序代码执行一个查询并返回一个数据集对象，但您的前端接受一个自定义类或模型，并且该模型在运行时定义。根据接收到的请求，可以使用反射在运行时创建所需的模型/类，通过遍历结果数据集来访问其属性或字段，并设置它们的值。
- en: Additionally, in previous sections, we learned how we can create custom attributes.
    So, in a scenario where you create an attribute to restrict numbers in a specific
    property, you can then use reflection to read the attribute, get the preceding
    property, implement application logic to restrict numbers, or display a message
    to users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在先前的章节中，我们学习了如何创建自定义属性。因此，在创建一个用于限制特定属性中数字的属性的属性的情况下，您可以使用反射来读取属性，获取前面的属性，实现应用逻辑以限制数字，或向用户显示消息。
- en: We can also use reflection to create a type at runtime and access its methods
    and properties. Reflection works with `System.Types` to query information about
    assemblies that are currently loaded into memory and are being executed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用反射在运行时创建一个类型，并访问其方法和属性。反射与`System.Types`一起工作，以查询当前加载到内存并正在执行的程序集的信息。
- en: The **Common Language Runtime** (**CLR**) manages application domains with boundaries
    around objects that are of the same scope. This process includes loading assemblies
    into these domains and controlling them as required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时**（**CLR**）管理具有相同作用域的对象的应用程序域。此过程包括将这些程序集加载到这些域中，并根据需要控制它们。'
- en: In the .NET world, assemblies contain modules, modules contain types, and types
    contain members. An assembly class is used to load assemblies. Modules are used
    to identify information about classes in the assembly as well as global and non-global
    methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET世界中，程序集包含模块，模块包含类型，类型包含成员。程序集类用于加载程序集。模块用于标识程序集中类的信息以及全局和非全局方法。
- en: There are many methods available in the `Reflection` class, such as `MethodInfo`,
    `PropertyInfo`, `Type`, `CustomAttribute`, and many more. These methods help developers
    to retrieve information at runtime. In the previous example, we used the `GetCustomAttribute`
    method to retrieve attribute information and displayed it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflection`类中提供了许多方法，例如`MethodInfo`、`PropertyInfo`、`Type`、`CustomAttribute`等。这些方法帮助开发者获取运行时信息。在先前的示例中，我们使用了`GetCustomAttribute`方法来检索属性信息并显示它。'
- en: Invoking methods and using properties
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用方法和使用属性
- en: In this section, we'll take a look at how we can access the properties and methods
    of a custom class at runtime using reflection.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用反射在运行时访问自定义类的属性和方法。
- en: This example serves to give you an idea of how we can access methods and properties
    using reflection at runtime. However, based on your requirements, you can dynamically
    access properties, their types and methods, and their parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例旨在向您展示我们如何在运行时使用反射访问方法和属性。然而，根据您的需求，您可以动态地访问属性、它们的类型和方法以及它们的参数。
- en: 'We created a new custom class where we defined two integer type properties:
    `Number1` and `Number2`. Then, we defined a public method that accepts a parameter
    and returns a number to be added or subtracted:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的自定义类，在其中我们定义了两个整数类型的属性：`Number1`和`Number2`。然后，我们定义了一个接受参数并返回要加或减的数字的公共方法：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, we created a simple method where we could access the properties and methods
    of the custom class that we created previously. In the first line, we retrieved
    the type information of the custom class. Using this type, we created an instance
    of the class using the `Activator.CreateInstance` method. Now, using the `Getproperties`
    method of the type we retrieved, we accessed all the properties and set a value
    to each of them based on the property name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个简单的方法，通过这个方法我们可以访问我们之前创建的自定义类的属性和方法。在第一行，我们检索了自定义类的类型信息。使用这个类型，我们通过`Activator.CreateInstance`方法创建了一个类的实例。现在，使用我们检索到的类型的`GetProperties`方法，我们访问了所有的属性，并根据属性名称为每个属性设置了一个值。
- en: 'In the next line, using the `Type` information of the object, we retrieve `MethodInfo`
    using the `GetMethod` method. Then, we invoked the `public` method of the custom
    class twice with two different actions called `Add` and `Subtract`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，使用对象的`Type`信息，我们通过`GetMethod`方法检索`MethodInfo`。然后，我们通过两个不同的操作`Add`和`Subtract`调用了自定义类的`public`方法两次：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run the program and debug every line, you will see that each property
    has been retrieved and values have been set. The following is the output of the
    program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序并逐行调试，你会看到每个属性都被检索了，并且已经设置了值。以下是程序的输出：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This sample is a simple one, as we created two properties, both of the integer
    type. However, in real time, such simple scenarios may not exist. Therefore, at
    runtime, you need to use the `GetType` method in order to understand the type
    of property retrieved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很简单，因为我们创建了两个整数类型的属性。然而，在实际应用中，这样的简单场景可能并不存在。因此，在运行时，你需要使用`GetType`方法来理解获取到的属性类型。
- en: Additionally, in the example we were able to get the type of the `Custom` class
    where we hardcoded it. Using generics, we can even pass the class at runtime and
    get the info type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在示例中，我们能够获取到我们硬编码的`Custom`类的类型。使用泛型，我们甚至可以在运行时传递类并获取类型信息。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how we can use system attributes, create custom
    attributes, retrieve attributes, and then use them in our application logic. Using
    reflection to retrieve attribute information, we also looked at how we can create
    types, access properties, and invoke a method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何使用系统属性，创建自定义属性，检索属性，然后在我们的应用程序逻辑中使用它们。通过反射检索属性信息，我们还探讨了如何创建类型，访问属性，以及调用方法。
- en: In the next chapter, we will gain an understanding of why is it important to
    validate application input, the type of information that flows into our application,
    and how can we handle it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解为什么验证应用程序输入很重要，流入我们应用程序的信息类型，以及我们如何处理它们。
- en: Questions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: While creating custom attributes, a target can be set to restrict the usage
    of an attribute?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建自定义属性时，是否可以设置一个目标来限制属性的用法？
- en: 'True'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: _______ is the method used to retrieve attribute information.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: _______ 是用于检索属性信息的方法。
- en: '`GetAttributeValue`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetAttributeValue`'
- en: '`GetCustomAttribute`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetCustomAttribute`'
- en: '`GetMetadata`'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetMetadata`'
- en: '`GetAttributeMetadata`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetAttributeMetadata`'
- en: The system allows you to retrieve property information from the object?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统允许你从对象中检索属性信息吗？
- en: 'True'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: Answers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**True**'
  id: totrans-100
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**True**'
- en: '**GetAttributeValue**'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GetAttributeValue**'
- en: '**True**'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**True**'
