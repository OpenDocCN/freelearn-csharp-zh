- en: '*Chapter 5*: Creating a Shop Scene for Our Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：为我们的游戏创建商店场景'
- en: In this chapter, we will incorporate and extend the scriptable objects that
    heavily helped make our player and the enemy ships in the previous chapter. We
    will customize a new shop scene, where we will add new upgrades for the player's
    ship with the use of scriptable objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将整合并扩展在上一章中大量帮助制作玩家和敌舰的可脚本化对象。我们将定制一个新的商店场景，其中我们将使用可脚本化对象为玩家的飞船添加新的升级。
- en: 'We will also look at the common uses of raycasts; if you aren''t familiar with
    them, they''re best described as an invisible laser that shoots from one point
    to another:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨射线投射的常见用途；如果你不熟悉它们，它们最好被描述为从一个点到另一个点的无形激光：
- en: '![Figure 5.1 – Identifying game objects with a raycast'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 使用射线投射识别游戏对象'
- en: '](img/Figure_5.01_B18381.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B18381.jpg)'
- en: Figure 5.1 – Identifying game objects with a raycast
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 使用射线投射识别游戏对象
- en: When the ray hits a game object with a collider, it can retrieve information
    about the object, and then we can go a little further and manipulate the object
    we've hit. For example, we can cast a ray to a game object cube, and the ray will
    confirm to us that it's a cube. Because we have the cube's reference, we can change
    its color or scale, or position or destroy it – we can pretty much do whatever
    we want with it. Here, we will use this raycast system to shoot a point from the
    camera's position to the button in three-dimensional space when we click or touch
    the screen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当射线击中具有碰撞器的游戏对象时，它可以检索有关该对象的信息，然后我们可以进一步操作我们击中的对象。例如，我们可以向一个立方体游戏对象投射射线，射线将确认它是一个立方体。因为我们有立方体的引用，我们可以改变它的颜色或缩放，或位置或销毁它
    – 我们几乎可以对其做任何我们想做的事情。在这里，我们将使用这个射线投射系统，在我们点击或触摸屏幕时，从摄像机的位置向三维空间中的按钮发射一个点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing our shop scripts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍我们的商店脚本
- en: Customizing our shop selection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制我们的商店选择
- en: Selecting game objects with raycasts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用射线投射选择游戏对象
- en: Adding information to our description panel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的描述面板添加信息
- en: By the end of this chapter, we will be comfortable with taking a piece of artwork
    and adding functionality to make it more useful. Scriptable objects are our friends,
    and we will make more use of them in this chapter – adding properties and values
    so that each option in our shop can hold sprites, prices, and a description. The
    shop buttons will be in 3D and selected with our invisible laser (the raycast
    system).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将能够轻松地将一件艺术品添加功能，使其更有用。脚本化对象是我们的朋友，在本章中我们将更多地使用它们 – 添加属性和值，以便我们的商店中的每个选项都可以持有精灵、价格和描述。商店按钮将是3D的，并通过我们的无形激光（射线投射系统）进行选择。
- en: The core exam skills covered in this chapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技能
- en: '*We will cover programming core interactions*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将涵盖编程核心交互*：'
- en: Implementing and configuring game object behavior and physics
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象的行为和物理
- en: Implementing and configuring input and controls
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置输入和控制
- en: '*We will also cover working in the art pipeline*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还将涵盖在艺术管道中工作*：'
- en: Understanding materials, textures, and shaders, and writing scripts that interact
    with Unity's rendering API
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材质、纹理和着色器，并编写与Unity渲染API交互的脚本
- en: '*This chapter also covers developing application systems*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章还涵盖开发应用程序系统*：'
- en: Interpreting scripts for application interface flow, such as menu systems, UI
    navigation, and application settings
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释用于应用程序界面流程的脚本，如菜单系统、UI导航和应用设置
- en: Interpreting scripts for user-controlled customization, such as character creators,
    inventories, storefronts, and in-app purchases
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释用户自定义脚本，如角色创建器、库存、店面和内购
- en: Analyzing scripts for user progression features, such as scoring, leveling,
    and in-game economies, utilizing technologies such as Unity Analytics and PlayerPrefs
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析用于用户进度功能的脚本，如得分、等级和游戏内经济，利用Unity Analytics和PlayerPrefs等技术
- en: Analyzing scripts for two-dimensional overlays, such as **Heads-Up Displays**
    (**HUDs**), minimaps, and advertisements
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析用于二维叠加的脚本，如**抬头显示**（**HUDs**）、小地图和广告
- en: '*We will also cover programming scene and environment design*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还将涵盖编程场景和环境设计*：'
- en: Identifying methods for implementing game object instantiation, destruction,
    and management
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍实现游戏对象实例化、销毁和管理的方法
- en: '*Finally, we will cover working in a professional software development team*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后，我们将涵盖在专业软件开发团队中工作*：'
- en: Recognizing techniques for structuring scripts for modularity, readability,
    and reusability
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于结构化脚本的模块化、可读性和可重用性技术
- en: Technical requirements
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_05](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_05).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可在 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_05](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_05)
    找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载每个章节的项目文件的全部内容，在 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All the content for this chapter is held in the chapter's `unitypackage` file,
    including a `Complete` folder, which holds all of the work we'll carry out in
    this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都存储在章节的 `unitypackage` 文件中，包括一个 `Complete` 文件夹，其中包含我们在本章中将要完成的所有工作。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3klZZ9q](https://bit.ly/3klZZ9q).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看 *代码的实际应用*：[https://bit.ly/3klZZ9q](https://bit.ly/3klZZ9q)。
- en: Introducing our shop scripts
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的商店脚本
- en: In this section, we will make some new scriptable objects, as we did when we
    created our player's ship settings (health, speed, firepower, and so on). You
    can refer to the *Introducing our scriptable object* (`SOActorModel`) section
    of [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*, Adding and Manipulating
    Objects*, for a reminder of how this is done. Instead of changing our enemy's
    or player's ships, we will be manipulating the shop's selection of powerups (with
    a selection grid) to add our own ship upgrades that the player will be able to
    choose from. These upgrades will then be transferred to the player's ship, which
    will be visually recognized, and two of the three upgrades will carry out alterations
    to the gameplay.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一些新的可脚本化对象，就像我们创建玩家的飞船设置（健康、速度、火力等）时做的那样。您可以参考 [*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048)
    的 *介绍我们的脚本化对象* (`SOActorModel`) 部分，以提醒如何完成此操作。我们不会改变敌人的或玩家的飞船，而是将操纵商店的选择（带有选择网格）以添加玩家可以选择的自己的飞船升级。这些升级然后将转移到玩家的飞船上，这将从视觉上得到识别，并且其中两个升级将对游戏玩法进行修改。
- en: Before we go into further detail, let's refresh our memory on where the shop
    scripts are within the game framework that we introduced in *Chapter 1, Setting
    Up and Structuring Our Project*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步详细介绍之前，让我们回顾一下商店脚本在我们介绍的 *第 1 章，设置和构建我们的项目* 中的游戏框架中的位置。
- en: 'The following diagram shows the location of the shop scripts:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了商店脚本的位置：
- en: '![Figure 5.2 – Killer Wave''s UML'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2 – Killer Wave''s UML'
- en: '](img/Figure_5.02_B18381.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.02_B18381.jpg]'
- en: Figure 5.2 – Killer Wave's UML
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 杀手波浪的 UML
- en: 'Our three shop scripts (`PlayerShipBuild`, `ShopPiece`, and `SOShopSelection`)
    connect to each other from where the `PlayerShipBuild` connects to the main, center
    `GameManager` script. In short, each script''s responsibility in the shop scene
    is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的三种商店脚本（`PlayerShipBuild`、`ShopPiece` 和 `SOShopSelection`）从 `PlayerShipBuild`
    连接到主中心 `GameManager` 脚本相互连接。简而言之，每个脚本在商店场景中的职责如下：
- en: '`PlayerShipBuild` is the overall function of the shop, including adverts and
    in-game credit control. This script can be broken down into more scripts, but
    for the sake of trying to keep our framework to a minimum, it is OK for a demo.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShipBuild` 是商店的整体功能，包括广告和在游戏中的信用控制。此脚本可以分解为更多脚本，但为了尽量保持我们的框架最小化，对于演示来说是可以的。'
- en: '`ShopPiece` handles the content of the player''s ship upgrade selections.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShopPiece` 处理玩家飞船升级选择的内 容。'
- en: '`SOShopSelection` is a scriptable object that holds the data types that will
    be used in each selection grid in our shop scene.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOShopSelection` 是一个可脚本化的对象，它包含将在我们的商店场景中的每个选择网格中使用的数据类型。'
- en: 'Let''s take a look at the scene that we will be creating and start applying
    shop scripts to it, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将要创建的场景，并开始将其应用于商店脚本，如下所示：
- en: From the `Scene` folder.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Scene` 文件夹。
- en: Double-click on the `shop` scene.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `shop` 场景。
- en: Drag and drop the `ShopManager` prefab from the `Assets/Prefab`).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/Prefab` 中拖放 `ShopManager` 预制体。
- en: Select `0`, `0`, and `0`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `0`、`0` 和 `0`。
- en: If you want a different-colored background, with **Camera** still selected in
    the **Hierarchy** window, change the **Clear Flags** property from **Skybox**
    to **Solid Color**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想有不同的背景颜色，在**层次结构**窗口中仍然选择**摄像机**，将**清除标志**属性从**天空盒**更改为**纯色**。
- en: Information
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: Make sure the camera remains in the same screen ratio we set in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048), *Adding
    and Manipulating Objects* (that is, 1920 x 1080). Use the following screenshot
    for reference.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保摄像机保持与我们之前在[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)中设置的相同屏幕比例（即1920
    x 1080）。以下截图供参考。
- en: 'The following scene is broken into four sections:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景分为四个部分：
- en: '![Figure 5.3 – Our shop layout'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 我们的商店布局'
- en: '](img/Figure_5.03_B18381.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B18381.jpg)'
- en: Figure 5.3 – Our shop layout
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 我们的商店布局
- en: 'Looking at the previous screenshot, let''s go through each of the numbered
    points:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下之前的截图，让我们逐一过一下编号的点：
- en: Starting with `testLevel` scene (the scene we have been working on in the previous
    four chapters).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`testLevel`场景开始（这是我们之前四章一直在工作的场景）。
- en: At the top left (**2**), we have a visual representation of the player's ship.
    We can see what it looks like on our player's ship if they buy an upgrade.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左上角（**2**），我们有玩家飞船的视觉表示。我们可以看到如果他们购买升级，它将看起来像我们的玩家飞船。
- en: Below the player's ship (**3**) is a small rectangle that will display the in-game
    credit balance.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在玩家飞船下方（**3**）有一个小矩形，将显示游戏中的信用余额。
- en: At the top right (**4**), a larger rectangle will hold information about our
    selected upgrade. It will also contain a button that, if the player has enough
    credits and/or hasn't purchased the item already, will give them the option to
    buy an upgrade.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右上角（**4**），一个更大的矩形将包含关于我们选定的升级的信息。它还将包含一个按钮，如果玩家有足够的信用分且/或尚未购买该物品，将给他们提供购买升级的选项。
- en: We can make a start with the selection grid (the shop's row of buttons). To
    save time, I have provided some template art for this scene because we will be
    replacing it in the next chapter when we create our own UI.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从选择网格（商店的按钮行）开始。为了节省时间，我已经为这个场景提供了一些模板艺术，因为我们将在下一章创建自己的UI时替换它。
- en: 'To make a start with the first button in our shop''s selection grid, we need
    to go to the **Hierarchy** window in the Unity Editor and do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的商店选择网格中的第一个按钮，我们需要进入Unity编辑器的**层次结构**窗口并执行以下操作：
- en: 'At the top-right corner of the `upgrade`, as shown in the following screenshot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下截图所示的`upgrade`的右上角：
- en: '![Figure 5.4 – Looking for game objects containing the word "upgrade" in the
    Hierarchy window'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 在层次结构窗口中寻找包含单词"upgrade"的游戏对象'
- en: '](img/Figure_5.04_B18381.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B18381.jpg)'
- en: Figure 5.4 – Looking for game objects containing the word "upgrade" in the Hierarchy
    window
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 在层次结构窗口中寻找包含单词"upgrade"的游戏对象
- en: Now, select the top game object titled `UPGRADE_00`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择标题为`UPGRADE_00`的顶级游戏对象。
- en: Information
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: Note that the content of the **Scene** window is grayed out, apart from the
    selected game object in the **Hierarchy** window in the Unity Editor. This is
    to help us locate the game object we are searching for.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，除了Unity编辑器中**层次结构**窗口中选定的游戏对象外，**场景**窗口的内容都是灰色的。这是为了帮助我们定位正在寻找的游戏对象。
- en: 'Click on the round **x** symbol to the right of the search bar. This will bring
    our **Hierarchy** content back and expand the parent game objects for us, as shown
    in the following screenshot:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击搜索栏右侧的圆形**x**符号。这将使我们的**层次结构**内容返回并展开父游戏对象，如下截图所示：
- en: '![Figure 5.5 – The children of UPGRADE_00'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – UPGRADE_00的子对象'
- en: '](img/Figure_5.05_B18381.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.05_B18381.jpg)'
- en: Figure 5.5 – The children of UPGRADE_00
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – UPGRADE_00的子对象
- en: 'Hold down *Ctrl* (or *command* on macOS) on your keyboard and select the three
    game objects:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住键盘上的*Ctrl*（或在macOS上按*command*）并选择三个游戏对象：
- en: '`sprite`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sprite`'
- en: '`itemText`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemText`'
- en: '`SelectionQuad`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionQuad`'
- en: With these three objects selected, select the top-left tick box in the **Inspector**
    window to make these objects active. The location of the box is shown in the following
    screenshot:![Figure 5.6 – Show and hide the game objects with the tick box
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择了这三个对象后，选择**检查器**窗口中的左上角的复选框以使这些对象激活。复选框的位置在以下截图中有显示：![图5.6 – 使用复选框显示和隐藏游戏对象
- en: '](img/Figure_5.06_B18381.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.06_B18381.jpg)'
- en: Figure 5.6 – Show and hide the game objects with the tick box
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 使用复选框显示和隐藏游戏对象
- en: 'Our grid should now show its first selection, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络应该现在显示其第一个选择，如下面的截图所示：
- en: '![Figure 5.7 – Our first shop button'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 我们的第一个商店按钮'
- en: '](img/Figure_5.07_B18381.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.07_B18381.jpg)'
- en: Figure 5.7 – Our first shop button
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 我们的第一个商店按钮
- en: Our shop has started to take form. With the first selection set up, we can now
    go further by customizing these selections with code in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的商店已经开始成形。在设置第一个选择后，我们可以在下一节通过代码自定义这些选择。
- en: Importing and calibrating our sprite game object
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入和校准我们的精灵游戏对象
- en: The game object that I have labeled `sprite` will receive and display a ship
    upgrade image that will be displayed in the selection grid. To understand how
    this sprite can be displayed correctly, we can view its properties when its game
    object is selected in the **Hierarchy** window.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我标记为`sprite`的游戏对象将接收并显示一个将在选择网格中显示的船升级图像。为了了解这个精灵如何正确显示，我们可以查看当其游戏对象在**层次结构**窗口中被选中时的属性。
- en: 'The `sprite` game object has a **Sprite Renderer** component attached to it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprite`游戏对象附有一个**精灵渲染器**组件：'
- en: '![Figure 5.8 – The Sprite Renderer component'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 精灵渲染器组件'
- en: '](img/Figure_5.08_B18381.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.08_B18381.jpg)'
- en: Figure 5.8 – The Sprite Renderer component
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 精灵渲染器组件
- en: I have grayed out the `sprite` game object property is what object type we are
    going to be supplying the `powerup` property, which gives us a fire-like icon
    in the **Scene** window.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`sprite`游戏对象属性灰显，这是我们为`powerup`属性提供哪种对象类型，这将在**场景**窗口中给我们一个类似火焰的图标。
- en: Let's check the `powerup` property so that we are certain of its data type and
    how it's recognized in the Unity Editor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`powerup`属性，以确保我们对其数据类型和它在Unity编辑器中的识别有把握。
- en: 'To view the sprite''s data type, follow these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看精灵的数据类型，请按照以下步骤操作：
- en: With the `sprite` game object still selected in our `powerup` property in the
    **Inspector** window of the **Sprite Renderer** section.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**精灵渲染器**部分的**检查器**窗口中，当`sprite`游戏对象仍然被选中时。
- en: 'The `powerup` sprite location will appear in the `powerup` sprite location
    pinging when selected from the **Sprite Renderer** component:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从**精灵渲染器**组件中选择时，`powerup`精灵的位置将在`powerup`精灵位置ping中出现：
- en: '![Figure 5.9 – The location of our ''powerup'' sprite in the Project window'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – 我们''powerup''精灵在项目窗口中的位置'
- en: '](img/Figure_5.09_B18381.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.09_B18381.jpg)'
- en: Figure 5.9 – The location of our 'powerup' sprite in the Project window
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 我们'powerup'精灵在项目窗口中的位置
- en: Next, click on the parent of the `powerup` property in the `powerup` sprite's
    import settings.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`powerup`精灵导入设置中`powerup`属性的父级。
- en: The majority of the information doesn't require altering, but the main point
    of focus is making sure that the **Texture Type** setting is recognized as **Sprite**
    to make the file compatible with the **Sprite Renderer** component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数信息不需要更改，但主要关注点是确保**纹理类型**设置为**精灵**，以便文件与**精灵渲染器**组件兼容。
- en: 'The following screenshot shows our `powerup` file recognized as a sprite, with
    an image preview at the bottom of the window:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的`powerup`文件被识别为精灵，窗口底部有图像预览：
- en: '![Figure 5.10 – Our ''powerup'' file will be set as a Sprite in the Texture
    Type field'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10 – 我们的''powerup''文件将在纹理类型字段中设置为精灵'
- en: '](img/Figure_5.10_B18381.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B18381.jpg)'
- en: Figure 5.10 – Our 'powerup' file will be set as a Sprite in the Texture Type
    field
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 我们的'powerup'文件将在纹理类型字段中设置为精灵
- en: It is possible that when a sprite, such as a `powerup` texture in the previous
    screenshot, is imported into Unity, it may not be recognized as a sprite and will
    be given the `Default` type. This is because `Default` is the most common selection
    for textures, especially with three-dimensional models. `Default` also offers
    more options with regard to texture properties.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能当精灵，如前一个截图中的`powerup`纹理，被导入Unity时，它可能不会被识别为精灵，并将被赋予`Default`类型。这是因为`Default`是纹理最常见的选项，尤其是在三维模型中。`Default`还提供了更多关于纹理属性的选项。
- en: Further Information
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: If you want to know more about texture types, check out [https://docs.unity3d.com/Manual/TextureTypes.html](https://docs.unity3d.com/Manual/TextureTypes.html).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于纹理类型的信息，请查看[https://docs.unity3d.com/Manual/TextureTypes.html](https://docs.unity3d.com/Manual/TextureTypes.html)。
- en: With regard to our `powerup` texture, we do not need to change it to `Default`.
    When we add another selection, the same principles of checking the image type
    should be carried out. Let's now move on to the second game object of the `UPGRADE_00`
    game object – `itemText`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的`powerup`纹理，我们不需要将其更改为`默认`。当我们添加另一个选择时，应该执行相同的检查图像类型的原理。现在让我们继续到`UPGRADE_00`游戏对象的第二个游戏对象`itemText`。
- en: Displaying credit on our itemText game object
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的`itemText`游戏对象上显示信用信息
- en: The second child game object from `UPGRADE_00` is `itemText`. This game object
    has a `SOLD` in the text.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPGRADE_00`的第二个子游戏对象是`itemText`。这个游戏对象中的文本包含一个`SOLD`。'
- en: 'The following screenshot shows the connection between the **Text Mesh** component
    and the text in the **Scene** window:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**Text Mesh**组件与**场景**窗口中文本之间的连接：
- en: '![Figure 5.11 – Text Mesh text set to ''0000'''
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.11 – Text Mesh text set to ''0000'']'
- en: '](img/Figure_5.11_B18381.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.11_B18381.jpg]'
- en: Figure 5.11 – Text Mesh text set to '0000'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 将Text Mesh文本设置为'0000'
- en: Let's now move on to the final child game object of the `UPGRADE_00` hierarchy,
    which is `SelectionQuad`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到最后一个`UPGRADE_00`层次结构的子游戏对象，即`SelectionQuad`。
- en: Project file diagnosis when making SelectionQuad
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在创建SelectionQuad时进行项目文件诊断
- en: In this section, I am going to briefly explain how the shop's selection grid
    is prepared.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将简要解释商店选择网格是如何准备的。
- en: '`SelectionQuad` is the third child game object of the `UPGRADE_00` game object,
    as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionQuad`是`UPGRADE_00`游戏对象的第三个子游戏对象，如下截图所示：'
- en: '![Figure 5.12 – The SelectionQuad game object in the Hierarchy window'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.12 – The SelectionQuad game object in the Hierarchy window]'
- en: '](img/Figure_5.12_B18381.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.12_B18381.jpg]'
- en: Figure 5.12 – The SelectionQuad game object in the Hierarchy window
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.12 – The SelectionQuad game object in the Hierarchy window]'
- en: 'This game object simply serves to show the player that they have made a selection.
    It consists of a quad mesh, which is a standard primitive that can be made in
    Unity (by right-clicking in the **Hierarchy** window and selecting **3D Object
    | Quad**). We are now going to change its appearance to make it look more interesting
    by manipulating its material values; follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏对象仅仅用来向玩家显示他们已经做出了选择。它由一个四边形网格组成，这是一个在Unity中可以创建的标准原语（通过在**层次结构**窗口中右键单击并选择**3D对象
    | 四边形**）。我们现在将改变其外观，通过操作其材质值使其看起来更有趣；请按照以下步骤操作：
- en: Once the `Quad` object is moved into position, change its **Material** properties
    from an **Opaque** rendering mode to **Transparent** (**1**).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将`Quad`对象移动到位置，将其**材质**属性从**不透明**渲染模式更改为**透明**（**1**）。
- en: 'Then, click on the `64`, `152`, `255`, and `140`. The following screenshot
    shows the color property changes made to the `SelectionQuad` material:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击`64`、`152`、`255`和`140`。以下截图显示了`SelectionQuad`材质所做的颜色属性更改：
- en: '![Figure 5.13 – Rendering Mode set to Transparent and the RGBA values modified
    to a light blue color'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.13 – Rendering Mode set to Transparent and the RGBA values modified
    to a light blue color]'
- en: '](img/Figure_5.13_B18381.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.13_B18381.jpg]'
- en: Figure 5.13 – Rendering Mode set to Transparent and the RGBA values modified
    to a light blue color
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 渲染模式设置为透明，并将RGBA值修改为浅蓝色
- en: That is the entirety of our `UPGRADE_00` selection. Then, copy and paste each
    game object onto two more black rectangles and rename them `UPGRADE_01` and `UPGRADE_02`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就是我们的`UPGRADE_00`选择的全貌。然后，将每个游戏对象复制并粘贴到两个更多的黑色矩形上，并将它们重命名为`UPGRADE_01`和`UPGRADE_02`。
- en: 'The following screenshot shows the three game objects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了三个游戏对象：
- en: '![Figure 5.14 – Duplicating the game objects'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.14 – Duplicating the game objects]'
- en: '](img/Figure_5.14_B18381.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.14_B18381.jpg]'
- en: Figure 5.14 – Duplicating the game objects
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 复制游戏对象
- en: 'For the purpose of this chapter, we are going to be using these three game
    objects to manipulate and carry information from one scene to another. Before
    we start making scripts for these selections, I want to show you some text that
    will be added to the two slightly larger buttons at the far right of the grid:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将使用这三个游戏对象来操作并将信息从一个场景传递到另一个场景。在我们开始为这些选择编写脚本之前，我想向您展示一些将被添加到网格最右侧两个略大的按钮上的文本：
- en: 'Scroll down in the `WATCH AD` and `START`. These two game objects will hold
    the following responsibilities:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WATCH AD`和`START`中向下滚动。这两个游戏对象将承担以下责任：
- en: '`WATCH AD` is used when the player selects this button; an advert will play.
    Once the advert is finished, the player is rewarded with credits. These credits
    can be used to buy more upgrades.'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家选择此按钮时使用`WATCH AD`；将播放广告。广告结束后，玩家将获得积分奖励。这些积分可以用来购买更多升级。
- en: '`START` is used when the player is finished with the shop. They can move on
    by pressing the **START** button.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家完成商店操作时使用`START`。他们可以通过按下**START**按钮继续前进。
- en: Expand `WATCH AD` and `START` by clicking on each arrow to the left of them.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击每个对象左侧的箭头来展开`WATCH AD`和`START`。
- en: Click on each game object and make them active in the **Inspector** window,
    as we did earlier in the *Introducing our shop scripts* section.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击每个游戏对象，并在**检查器**窗口中使它们处于活动状态，就像我们在*介绍我们的商店脚本*部分中做的那样。
- en: In each expanded game object, we have a label game object; this holds a **Text
    Mesh** component, which we have been introduced to already in this section, that
    displays our button text.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个展开的游戏对象中，我们都有一个标签游戏对象；这个对象包含一个**文本网格**组件，我们已经在本节中介绍过，用于显示按钮文本。
- en: 'The following screenshot shows the expanded `WATCH AD` and `START` objects
    in the **Hierarchy** window:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**层次结构**窗口中展开的`WATCH AD`和`START`对象：
- en: '![Figure 5.15 – The WATCH AD and START button locations'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15 – `WATCH AD`和`START`按钮的位置'
- en: '](img/Figure_5.15_B18381.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.15_B18381.jpg](img/Figure_5.15_B18381.jpg)'
- en: Figure 5.15 – The WATCH AD and START button locations
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 – `WATCH AD`和`START`按钮的位置
- en: So far, we understand that we have a shop scene that will contain scriptable
    objects for our ship's upgrades; we are also aware of how the option to watch
    adverts to gain credits is a popular mechanism with free-to-play games.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们了解到我们将有一个包含我们飞船升级的可脚本化对象的商店场景；我们也知道观看广告以获得积分是免费游戏中的一个流行机制。
- en: That is all that we need for the selection grid. We can now start considering
    how to turn the buttons on and off, change each upgrade art, and more in the next
    section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们选择网格所需的所有内容。现在我们可以开始考虑如何在下一节中开启和关闭按钮，更改每个升级的图标，以及更多操作。
- en: Customizing our shop selection
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义我们的商店选择
- en: In this section, we are going to use scriptable objects to customize each selection.
    We have already used scriptable objects in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*. This time, we will use a similar method but
    for our selection grid; hopefully, this will make you appreciate how scriptable
    objects can be expanded and used across the game.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用可脚本化对象来定制每个选择。我们已经在[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)，*添加和管理对象*中使用了可脚本化对象。这次，我们将使用类似的方法，但针对我们的选择网格；希望这能让你欣赏到可脚本化对象如何在游戏中扩展和使用。
- en: 'As mentioned in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048), *Adding
    and Manipulating Objects*, I make a habit of initialing scriptable objects with
    an `SO` prefix so that they''re easy to identify. Let''s create an `SOShopSelection`
    script:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)中所述，*添加和管理对象*，我习惯于使用`SO`前缀初始化可脚本化对象，以便于识别。让我们创建一个`SOShopSelection`脚本：
- en: In the Unity Editor, go to the `Assets/Script`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，转到`Assets/Script`。
- en: Create a script (using the same method from [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,*
    *Adding and Manipulating Objects*) and name it `SOShopSelection`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个脚本（使用与[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)*,* *添加和管理对象*)相同的方法）并命名为`SOShopSelection`。
- en: This `SOShopSelection` script will create a template of data types for our asset
    files (the same as with our player and enemy ships). These asset files will be
    attached to each of the player ship upgrades.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SOShopSelection`脚本将为我们的资产文件（与我们的玩家和敌舰相同）创建数据类型模板。这些资产文件将附加到每个玩家飞船的升级上。
- en: 'An individual selection from the grid will take four property types, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的单个选择将包含四种属性类型，如下所示：
- en: '`icon`: A picture of the selection.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon`：选择图片。'
- en: '`iconName`: Identifies what the selection is.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iconName`：标识选择的内容。'
- en: '`description`: Used to describe what the upgrade is in the large selection
    box at the top right of the scene.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：用于描述在场景右上角的大选择框中升级的内容。'
- en: '`cost`: Calculates how many credits it is worth so that it can be displayed
    in the credit values of the selection.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cost`：计算升级值，以便在选择的积分值中显示。'
- en: 'Let''s open the `SOShopSelection` script and begin to code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`SOShopSelection`脚本并开始编码：
- en: 'At the top of the script, make sure that we have imported the following library:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部，确保我们已导入以下库：
- en: '[PRE0]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with most scripts in Unity, we need the `UnityEngine` library so that we
    can use the `ScriptableObject` functionality.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Unity 中大多数脚本一样，我们需要 `UnityEngine` 库，以便我们可以使用 `ScriptableObject` 功能。
- en: 'To make it so that we can create assets from the scriptable object, we enter
    the following attribute above our class name:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够从可脚本对象中创建资产，我们在类名上方输入以下属性：
- en: '[PRE1]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the following code to inherit `ScriptableObject` to the `SOShopSelection`
    script. This will give us the functionality for creating template asset files:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以将 `ScriptableObject` 继承到 `SOShopSelection` 脚本中。这将为我们提供创建模板资产文件的功能：
- en: '[PRE2]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Enter the following code to hold the specific variables:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以保存特定的变量：
- en: '[PRE3]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the script.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: We have made the script to hold our data for each potential selection in the
    grid. As mentioned, we have already made these types of scripts before – we are
    just using them here to customize buttons, rather than spaceships.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了脚本以保存网格中每个潜在选择的资料。如前所述，我们之前已经创建了这些类型的脚本 – 我们只是在这里使用它们来定制按钮，而不是宇宙飞船。
- en: We can now customize our three `UPGRADE` game objects in the Unity Editor –
    let's do that next.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Unity 编辑器中自定义我们的三个 `UPGRADE` 游戏对象 – 让我们接下来这么做。
- en: Creating selection templates
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建选择模板
- en: In the last section, we made a scriptable object that allowed us to create an
    asset file that holds custom parameters and values. These assets and their properties
    can be created by users who don't hold programming knowledge, which is ideal for
    designers and programmers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们创建了一个可脚本对象，允许我们创建一个包含自定义参数和值的资产文件。这些资产及其属性可以由不具备编程知识的用户创建，这对于设计师和程序员来说是非常理想的。
- en: 'We have three selections to add to our selection grid:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个选择要添加到我们的选择网格中：
- en: '**Weapon upgrade**: Gives the player''s ship a stronger weapon'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**武器升级**：赋予玩家飞船更强的武器'
- en: '**Health upgrade**: Allows the player''s ship to get hit twice by an enemy
    object'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康升级**：允许玩家的飞船被敌人对象击中两次'
- en: '**Atom bomb**: Wipes all the visible enemies out'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子弹**：清除所有可见的敌人'
- en: 'So, let''s go back to the Unity Editor and make some asset templates for our
    selection grid:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到 Unity 编辑器，并为我们的选择网格创建一些资产模板：
- en: From the `Assets/ScriptableObject`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/ScriptableObject`。
- en: 'Right-click in an open space of the **Project** window, and from the dropdown
    that appears, select **Create** and then **Create Shop Piece**, as shown in the
    following screenshot:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 窗口的空白区域右键单击，然后从出现的下拉菜单中选择 **创建**，然后选择 **创建 Shop Piece**，如图下所示截图：
- en: '![Figure 5.16 – Creating a ''Shop Piece'''
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – 创建 ''Shop Piece'''
- en: '](img/Figure_5.16_B18381.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B18381.jpg)'
- en: Figure 5.16 – Creating a 'Shop Piece'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 创建 'Shop Piece'
- en: Rename the new `Create Shop Piece` file `Shot_PowerUp`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `Create Shop Piece` 文件重命名为 `Shot_PowerUp`。
- en: With `Shot_PowerUp` still selected, navigate to the **Inspector** window, where
    we have the data types that we can enter.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `Shot_PowerUp` 仍然被选中时，导航到 **检查器** 窗口，在那里我们有可以输入的数据类型。
- en: 'The following screenshot shows the `Shot_PowerUp` properties that we are going
    to change next:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将要更改的 `Shot_PowerUp` 属性：
- en: '![Figure 5.17 – The Shot_PowerUp properties'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – 射击_增强属性'
- en: '](img/Figure_5.17_B18381.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.17_B18381.jpg)'
- en: Figure 5.17 – The Shot_PowerUp properties
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 射击_增强属性
- en: We will apply our `powerup` sprite icon to the **Icon** data type by clicking
    on the small circle to the right of its field.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过点击其字段右侧的小圆圈，将我们的 `powerup` 精灵图标应用到 **图标** 数据类型。
- en: 'Scroll down in the `powerup` sprite, and then double-click it, as shown in
    the following screenshot:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `powerup` 精灵中向下滚动，然后双击，如图下所示截图：
- en: '![Figure 5.18 – Updating the shop buttons icon'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – 更新商店按钮图标'
- en: '](img/Figure_5.18_B18381.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.18_B18381.jpg)'
- en: Figure 5.18 – Updating the shop buttons icon
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 更新商店按钮图标
- en: 'Now, enter the following property names and the values we are going to give
    them:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下属性名称以及我们将赋予它们的值：
- en: '`b. Shot`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b. 射击`'
- en: '`Blast Shot`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blast Shot`'
- en: '`400`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`'
- en: Create another `ShopPiece` asset as we did before.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同之前所做的那样，创建另一个 `ShopPiece` 资产。
- en: 'This time, change the asset name from `Create Shop Piece` to `Health_Level1`
    and give it the details shown in the following screenshot:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，将资产名称从 `Create Shop Piece` 更改为 `Health_Level1`，并给出以下截图中的详细信息：
- en: '![Figure 5.19 – Health button properties'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 健康按钮属性'
- en: '](img/Figure_5.19_B18381.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.19_B18381.jpg)'
- en: Figure 5.19 – Health button properties
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 健康按钮属性
- en: 'Let''s now make the third asset file, using the exact same process as the last
    two assets, but this time name it `Bomb_Cluster` and give it the following details:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们制作第三个资产文件，使用与最后两个资产完全相同的流程，但这次将其命名为`Bomb_Cluster`并给出以下详细信息：
- en: '![Figure 5.20 – Bomb Cluster button properties'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20 – 炸弹集群按钮属性'
- en: '](img/Figure_5.20_B18381.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.20_B18381.jpg)'
- en: Figure 5.20 – Bomb Cluster button properties
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – 炸弹集群按钮属性
- en: We have made the scriptable objects and configured them for our ship's upgrades.
    Let's now make the second main script for the shop, `ShopPiece`. This script will
    hold each of the asset files we have just made and display their content around
    the shop's grid scene.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经制作了可脚本对象并为其飞船的升级进行了配置。现在让我们制作第二个主要脚本，即`ShopPiece`。此脚本将包含我们刚刚制作的每个资产文件，并在商店的网格场景周围显示其内容。
- en: Customizing our player ship's upgrade selection
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制我们的玩家飞船升级选择
- en: The purpose of this script is to send information to each of the selection buttons
    in our shop scene. For each of the three `UPGRADE` game objects, we will create
    and attach a script that takes reference from the `SOShopSelection` scriptable
    object (the three asset files we made in the previous section) and assign them
    to each player ship's upgrade button.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的目的是将信息发送到我们商店场景中的每个选择按钮。对于三个`UPGRADE`游戏对象中的每一个，我们将创建并附加一个脚本，该脚本引用`SOShopSelection`可脚本对象（我们在上一节中制作的三个资产文件）并将它们分配给每个玩家飞船的升级按钮。
- en: 'To create the `ShopPiece` script, do the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`ShopPiece`脚本，请执行以下操作：
- en: Let's start by navigating to `Assets/Script` from the **Project** window.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从**项目**窗口导航到`Assets/Script`开始。
- en: Create the script the same way as we did at the start of the *Customizing our
    shop selection* section and name the script `ShopPiece`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与在*定制我们的商店选择*部分开始时相同的方式创建脚本，并将脚本命名为`ShopPiece`。
- en: 'Open the script and begin to code, starting with the script that contains the
    `UnityEngine` library at the top of the script:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并开始编写代码，从脚本顶部的`UnityEngine`库开始：
- en: '[PRE4]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because we are using elements of Unity and attaching the `ShopPiece` script
    with the Unity Editor, this script will require the `UnityEngine` library.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用Unity的元素并将`ShopPiece`脚本附加到Unity编辑器中，因此此脚本将需要`UnityEngine`库。
- en: 'Check and enter the following code to declare the class name and inheritance:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查并输入以下代码以声明类名和继承：
- en: '[PRE5]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, our script should be automatically named, with `Monobehaviour` inherited.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的脚本应该自动命名，并继承`Monobehaviour`。
- en: 'Enter the following code to allow the `shopSelection` instance to be updated:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以允许更新`shopSelection`实例：
- en: '[PRE6]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We add a reference to the `SOShopSelection` script that we made in the last
    section. This reference is private (because it isn't labeled as `public`), but
    we expose it to the Unity Editor with a `[SerializeField]` function above it.
    This means that we can drag and drop each scriptable asset file to its field in
    the Unity Editor. If another script requires access to the private `shopSelection`
    variable, we can refer to the `ShopSelection` property that will receive and send
    its data (`get` and `set`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对上一节中制作的`SOShopSelection`脚本的引用。此引用是私有的（因为它没有标记为`public`），但我们通过其上方的`[SerializeField]`函数将其暴露给Unity编辑器。这意味着我们可以将每个可脚本资产文件拖放到Unity编辑器中的字段。如果另一个脚本需要访问私有的`shopSelection`变量，我们可以引用将接收和发送其数据的`ShopSelection`属性（`get`和`set`）。
- en: 'Enter the following code to update the `shopSelection` sprite:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以更新`shopSelection`精灵：
- en: '[PRE7]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When this script is active and runs for the first time, it runs its `Awake`
    function. Inside the function are two `if` statements; the first checks whether
    there is a `SpriteRenderer` component in any of its child game objects. If there
    is, then it grabs a reference from its `shopSelection` asset file and applies
    its icon sprite to display on the button.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当此脚本首次激活并运行时，它将运行其`Awake`函数。在函数内部有两个`if`语句；第一个检查其任何子游戏对象中是否有`SpriteRenderer`组件。如果有，则从其`shopSelection`资产文件中获取引用并将其图标精灵应用到按钮上显示。
- en: 'Enter the following code to update the cost value:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以更新成本值：
- en: '[PRE8]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The alternative `if` statement checks whether any of the child game objects
    of this class have a game object titled `itemText`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 替代`if`语句检查此类的任何子游戏对象是否有一个名为`itemText`的游戏对象。
- en: If there is a game object titled `itemText`, we update its `TextMesh` component's
    `text` value with the `shopSelection` cost value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个名为`itemText`的游戏对象，我们将其`TextMesh`组件的`text`值更新为`shopSelection`成本值。
- en: Save the script.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Back in the Unity Editor, we can attach the `ShopPiece` script, along with each
    asset script we made in the last section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Unity 编辑器，我们可以附加 `ShopPiece` 脚本，以及我们在上一节中制作的每个资产脚本。
- en: 'To attach each `ShopPiece` script to each `UPGRADE` game object file, follow
    these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要将每个 `ShopPiece` 脚本附加到每个 `UPGRADE` 游戏对象文件，请按照以下步骤操作：
- en: From the `UPGRADE_00` game object.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `UPGRADE_00` 游戏对象。
- en: Either drag and drop the `ShopPiece` script from the `Assets /Script`) or click
    on **Add Component** in the **Inspector** window and type the script's name in
    the drop-down search.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从 `Assets /Script` 中拖放 `ShopPiece` 脚本，或者在 **检查器** 窗口中点击 **添加组件** 并在下拉搜索中输入脚本的名称。
- en: '`UPGRADE_00` will be our weapon powerup button, so for the `Assets /ScriptableObject`)
    or click on the small circle to the right of the `Shot_PowerUp`. Use the following
    screenshot as a reference to see how your **Inspector** window should look:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPGRADE_00` 将是我们的武器升级按钮，因此对于 `Assets /ScriptableObject` 或点击 `Shot_PowerUp`
    右侧的小圆圈，使用以下截图作为参考，以查看您的 **检查器** 窗口应如何显示：'
- en: '![Figure 5.21 – Our ''Shop Piece'' script containing the ''Shop_PowerUp'' Scriptable
    Object'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21 – 包含 ''Shop_PowerUp'' 可脚本对象的 ''Shop Piece'' 脚本'
- en: '](img/Figure_5.21_B18381.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.21_B18381.jpg)'
- en: Figure 5.21 – Our 'Shop Piece' script containing the 'Shop_PowerUp' Scriptable
    Object
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 包含 'Shop_PowerUp' 可脚本对象的 'Shop Piece' 脚本
- en: 'Now, repeat this process for `UPGRADE_01` by giving the game object the `ShopPiece`
    script with the `Health_Level1` asset in its `ShopPiece` component for `UPGRADE_01`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重复此过程为 `UPGRADE_01`，给游戏对象添加 `ShopPiece` 脚本，并在其 `ShopPiece` 组件中使用 `Health_Level1`
    资产为 `UPGRADE_01`：
- en: '![Figure 5.22 – Our ''Shop Piece'' script containing the ''Health_Level1''
    Scriptable Object'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22 – 包含 ''Health_Level1'' 可脚本对象的 ''Shop Piece'' 脚本'
- en: '](img/Figure_5.22_B18381.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.22_B18381.jpg)'
- en: Figure 5.22 – Our 'Shop Piece' script containing the 'Health_Level1' Scriptable
    Object
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 包含 'Health_Level1' 可脚本对象的 'Shop Piece' 脚本
- en: 'Finally, complete the same procedure for `UPGRADE_02`, adding the `ShopPiece`
    script and applying `Bomb_Cluster` to the `ShopPiece` script with the `Bomb_Cluster`
    asset applied:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为 `UPGRADE_02` 完成相同的程序，添加 `ShopPiece` 脚本，并将 `Bomb_Cluster` 应用到 `ShopPiece`
    脚本中：
- en: '![Figure 5.23 – Our ''Shop Piece'' script containing the ''Bomb_Cluster'' Scriptable
    Object'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.23 – 包含 ''Bomb_Cluster'' 可脚本对象的 ''Shop Piece'' 脚本'
- en: '](img/Figure_5.23_B18381.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.23_B18381.jpg)'
- en: Figure 5.23 – Our 'Shop Piece' script containing the 'Bomb_Cluster' Scriptable
    Object
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 包含 'Bomb_Cluster' 可脚本对象的 'Shop Piece' 脚本
- en: To test whether the three selection pieces work in the selection grid, save
    the scene so far and click the **Play** button in the Unity Editor.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试三个选择组件是否在选择网格中正常工作，请保存当前场景，并在 Unity 编辑器中点击 **播放** 按钮。
- en: 'Our selection grid should go from the top three buttons with the same image
    and same value (not in play mode) to each image and value being different (in
    play mode):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的选择网格应从顶部三个具有相同图像和相同值（不在播放模式中）的按钮开始，到每个图像和值都不同（在播放模式中）：
- en: '![Figure 5.24 – Our shop buttons updating their prices in Play Mode'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.24 – 在播放模式中更新价格的商店按钮'
- en: '](img/Figure_5.24_B18381.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.24_B18381.jpg)'
- en: Figure 5.24 – Our shop buttons updating their prices in Play Mode
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 在播放模式中更新价格的商店按钮
- en: If you recall, our asset files have names and description data; we can use this
    for the large rectangle in the shop scene when it comes to supplying information
    about the item. Also, we need to update the player ship's visuals to show what
    a purchase looks like on the ship, as well as a few other things. In the next
    section, we are going to create a script that allows the player to press a button
    from the selection grid.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们的资产文件有名称和描述数据；当在商店场景中提供有关物品的信息时，我们可以使用这些数据。此外，我们还需要更新玩家的飞船视觉效果，以显示在飞船上购买的外观，以及一些其他事情。在下一节中，我们将创建一个脚本，允许玩家从选择网格中按按钮。
- en: Selecting game objects with raycasts
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用射线投射选择游戏对象
- en: In this section, we are going to create the final shop script, `PlayerShipBuild`.
    This script holds properties such as selecting any button from the selection grid,
    running adverts, communicating with our existing game framework scripts, launching
    our game to play, and a few other things that we will cover.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建最终的商店脚本 `PlayerShipBuild`。此脚本包含选择选择网格中的任何按钮、运行广告、与现有的游戏框架脚本通信、启动游戏进行播放以及其他我们将要介绍的一些功能。
- en: One of the subjects you will likely come across in your Unity programmer exam
    and when developing games/applications in Unity is shooting invisible lasers,
    which are used for things such as shooting a gun, making a selection in three-dimensional
    space, and more. In this section, we are going to make a button on the selection
    grid light up blue when the player presses on it to let them know that it has
    been selected. We already have each of our buttons set up with blue rectangles
    that are permanently on. So, all that we need to do now is turn them all off when
    the scene becomes active and make any of the buttons turn on when a ray (invisible
    laser) comes into contact with them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Unity程序员考试中可能会遇到的一个主题，以及在Unity中开发游戏/应用程序时，是发射不可见的激光，这些激光用于射击枪、在三维空间中进行选择等。在本节中，我们将创建一个按钮，当玩家按下它时，选择网格上的按钮会亮起蓝色，以便让他们知道它已被选中。我们已经在每个按钮上设置了永久开启的蓝色矩形。因此，我们现在需要做的只是当场景变得活跃时关闭它们，并在射线（不可见激光）与它们接触时打开任何按钮。
- en: 'The following screenshot shows an example of how the player sees the selection
    screen (**SELECTION 2D**) and the same scene at an angle so that we can see the
    main camera''s clipping planes (**SELECTION 3D**). When the player presses a button
    on the selection grid, an invisible line (ray) will travel across it. If the line
    comes into contact with a game object that has a collider attached to it, we can
    get information from that game object:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了玩家看到的2D选择屏幕（**选择2D**）以及从角度看到的相同场景，以便我们可以看到主摄像机的裁剪平面（**选择3D**）。当玩家按下选择网格上的按钮时，一条不可见的线（射线）将穿过它。如果这条线接触到附加了碰撞器的游戏对象，我们可以从该游戏对象获取信息：
- en: '![Figure 5.25 – Shooting a ray from our camera position to select a button
    in the shop'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25 – 从我们的摄像机位置发射射线以选择商店中的按钮'
- en: '](img/Figure_5.25_B18381.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.25_B18381.jpg](img/Figure_5.25_B18381.jpg)'
- en: Figure 5.25 – Shooting a ray from our camera position to select a button in
    the shop
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 – 从我们的摄像机位置发射射线以选择商店中的按钮
- en: So, what we are going to do for this selection is start creating a `PlayerShipBuild`
    script and give it the functionality to shoot rays, which will then change the
    color of the button.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个选择，我们将开始创建一个`PlayerShipBuild`脚本，并赋予它发射射线的能力，这将改变按钮的颜色。
- en: Let's start by creating a script in the usual `Assets/Script`) and naming it
    `PlayerShipBuild`. You should know how to make a script now, as we did so in the
    previous *Customizing our player ship's upgrade selection* section.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在常规`Assets/Script`目录中创建一个名为`PlayerShipBuild`的脚本开始。你现在应该知道如何创建脚本，因为我们已经在之前的*自定义我们的玩家飞船升级选择*部分中这样做过了。
- en: 'To create a raycast selection, open the `PlayerShipBuild` script and follow
    these steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建射线选择，打开`PlayerShipBuild`脚本并按照以下步骤操作：
- en: 'By default, we require the UnityEngine library, as previously mentioned:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，我们要求使用Unity引擎库，如前所述：
- en: '[PRE9]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Enter the following code to declare our class:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以声明我们的类：
- en: '[PRE10]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our script has a `public` access modifier and is named the same as the `PlayerShipBuild`
    file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本有一个`public`访问修饰符，并且与`PlayerShipBuild`文件同名。
- en: This script inherits `MonoBehaviour`, so it is recognized when attached to a
    game object in the Editor.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本继承自`MonoBehaviour`，因此在编辑器中附加到游戏对象时会被识别。
- en: 'Enter the following code to hold each of the `shopButtons`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以保持每个`shopButtons`：
- en: '[PRE11]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have a `private` variable that is exposed in the Editor with `[SerializeField]`
    (so we can see and edit it), which will hold an array of all 10 game object buttons
    on the selection grid.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`private`变量，在编辑器中通过`[SerializeField]`暴露（因此我们可以查看和编辑它），它将保存选择网格上所有10个游戏对象按钮的数组。
- en: 'Enter the following code to hold two game objects for raycasting:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以保持两个用于射线的游戏对象：
- en: '[PRE12]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `tmpSelection` variable is used to store the raycast selection so that we
    can check to see what we have made contact with. The target variable will be used
    later on in the script.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpSelection`变量用于存储射线选择，以便我们可以检查我们接触到了什么。目标变量将在脚本中稍后使用。'
- en: '`tmpSelection` will be used at the end of the selection process when it comes
    to turning the game object on.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpSelection`将在选择过程结束时使用，用于打开游戏对象。'
- en: 'Enter the following code within the `Start` function to run our method:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`函数中输入以下代码以运行我们的方法：
- en: '[PRE13]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unity's `Start` function will be the first thing called when this script becomes
    active.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当此脚本变得活跃时，Unity的`Start`函数将是首先被调用的。
- en: 'Next, we will enter the following code to create the `TurnOffSelectionHighlights`
    method:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将输入以下代码以创建 `TurnOffSelectionHighlights` 方法：
- en: '[PRE14]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Within the `TurnOffSelectionHighlights` method, we run a `for` loop that makes
    sure all of the buttons have their blue rectangles turned off.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TurnOffSelectionHighlights` 方法中，我们运行一个 `for` 循环以确保所有按钮的蓝色矩形都被关闭。
- en: 'Enter the following code into the `Update` function that is called at every
    frame:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到每帧调用的 `Update` 函数中：
- en: '[PRE15]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `AttemptSelection` method is responsible for receiving the player's input
    for a button selection. The content of this method will be covered in detail when
    we come to it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttemptSelection` 方法负责接收玩家对按钮选择的输入。当涉及到这一点时，我们将详细讨论这个方法的内容。'
- en: 'Enter the following code to create our `ReturnClickedObject` method:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入以创建我们的 `ReturnClickedObject` 方法：
- en: '[PRE16]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ReturnClickedObject` method also takes an argument of an `out` raycast
    hit, which will contain information of what collider the ray has made contact
    with.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReturnClickedObject` 方法也接受一个 `out` 射线投射命中的参数，该参数将包含射线接触到的碰撞器的信息。'
- en: Within this method, we reset the `target` game object to remove any previous
    data. We then take reference from the camera to find where the player tapped or
    clicked their mouse on the screen and store the result in the form of a ray.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们将 `target` 游戏对象重置以删除任何以前的数据。然后，我们从相机获取玩家在屏幕上触摸或点击鼠标的位置，并将结果以射线的形式存储。
- en: Further Information
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: More information about `ScreenPointToRay` can be found in Unity's scripting
    reference at [https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html](https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ScreenPointToRay` 的更多信息可以在 Unity 的脚本参考中找到，链接为 [https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html](https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html)。
- en: We then check whether the origin and the direction of the camera from where
    we have shot the ray have made contact with a collider (within 100 world space
    meters).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查从我们发射射线的地方，相机的原点和方向是否与碰撞器（在100个世界空间米内）接触。
- en: If we have made contact with a collider, the `if` statement is acknowledged
    as `true`; we then take the reference of the game object it has hit and store
    it in the `target` game object.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与碰撞器接触，`if` 语句被认可为 `true`；然后我们获取它所击中的游戏对象的引用并将其存储在 `target` 游戏对象中。
- en: Finally, we send out (`return`) the `target` game object that the ray has come
    into contact with.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发送出（`return`）射线接触到的 `target` 游戏对象。
- en: If you recall, we referred to an `AttemptSelection` method earlier in the `Update`
    function. The `AttemptSelection` method will check whether a condition is made
    when the player has made contact by tapping the screen or clicking a mouse button
    in our shop scene.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们在 `Update` 函数中之前提到了一个 `AttemptSelection` 方法。`AttemptSelection` 方法将检查当玩家通过触摸屏幕或点击鼠标按钮在我们的商店场景中接触时是否满足条件。
- en: 'Enter the following code to write out the `AttemptSelection` method:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入以编写 `AttemptSelection` 方法：
- en: '[PRE17]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the player has pressed the mouse button or tapped the touchscreen, we will
    fire the ray and send all `RaycastHit` objects into the `ReturnClickedObject`
    method that we mentioned in the previous section of code. The results from the
    `ReturnClickedObject` method are returned to the `target` game object that we
    made at the start of the script.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家按下了鼠标按钮或触摸了触摸屏，我们将发射射线并将所有 `RaycastHit` 对象发送到我们在上一节代码中提到的 `ReturnClickedObject`
    方法。`ReturnClickedObject` 方法的返回结果将返回到我们在脚本开头创建的 `target` 游戏对象。
- en: We then check whether this `target` game object exists. If it does exist, we
    then run another check to see whether this `target` game object is holding a game
    object named `itemText`. If it does have a game object with this name, we refresh
    the selection grid by turning all the blue quads off, followed by a method called
    `Select`, which is what we are going to talk about next.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查这个 `target` 游戏对象是否存在。如果它确实存在，我们接着检查这个 `target` 游戏对象是否持有名为 `itemText`
    的游戏对象。如果它确实有一个名为此的游戏对象，我们将通过关闭所有蓝色四边形并调用名为 `Select` 的方法来刷新选择网格，这是我们接下来要讨论的内容。
- en: We have finally dug down into the last bit of our script where we find the name
    of the `SelectionQuad` game object and turn it on to give the player visual feedback
    of what selection they have made.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终深入到脚本中的最后一段，在那里我们找到了 `SelectionQuad` 游戏对象的名称，并将其打开以给玩家提供他们所做选择的视觉反馈。
- en: 'Enter the following method into our code; this will make the player''s button
    selection active:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码中输入以下方法；这将使玩家的按钮选择变为活动状态：
- en: '[PRE18]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Select` method doesn't need to check any conditions with `if` statements,
    as this has mostly been done for us with the previous code. We will carry out
    a search for `SelectionQuad` and store its reference as `tmpSelection`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select` 方法不需要使用 `if` 语句检查任何条件，因为大部分工作已经由之前的代码为我们完成。我们将执行对 `SelectionQuad`
    的搜索，并将其引用存储为 `tmpSelection`。'
- en: Finally, we set the `tmpSelection` game object's activity to `true` so that
    it is seen in our `shop` **Scene** window.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `tmpSelection` 游戏对象的活动设置为 `true`，以便在 `shop` **场景**窗口中可见。
- en: Save the script and return to the Unity Editor.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 Unity 编辑器。
- en: 'We can now attach our `PlayerShipBuild` script to our shop game object (using
    the same attaching method we used earlier in this chapter for `ShopPiece`), which
    is the parent to all of the buttons in the selection grid, as shown in the following
    screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将 `PlayerShipBuild` 脚本附加到我们的商店游戏对象上（使用本章前面为 `ShopPiece` 使用的相同附加方法），这是选择网格中所有按钮的父对象，如下面的截图所示：
- en: '![Figure 5.26 – Our ''shop'' containing the ''Player Ship Build'' script and
    the amount of ''Shop Buttons'' highlighted (0)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.26 – 包含 ''Player Ship Build'' 脚本和突出显示的 ''Shop Buttons'' 数量的 ''shop''（0）'
- en: '](img/Figure_5.26_B18381.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.26_B18381.jpg]'
- en: Figure 5.26 – Our 'shop' containing the 'Player Ship Build' script and the amount
    of 'Shop Buttons' highlighted (0)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 包含 'Player Ship Build' 脚本和突出显示的 'Shop Buttons' 数量的 'shop'（0）
- en: Also, if you recall at the start of the `PlayerShipBuild` script, we added a
    game object variable that would take an array of `shopButtons`. We could have
    a `for` loop to add each `UPGRADE` game object automatically at the start of the
    script, but if, in the future, we wanted to consider using a joypad or keyboard
    to guide us through the selection grid, we would have more control over knowing
    which button is assigned to each array number. Also, this is just another way
    of programming without relying on code, as Unity is a component-based engine.
    Other controller inputs and interactions are something we are going to cover in
    [*Chapter 13*](B18381_13_Epub.xhtml#_idTextAnchor219), *Effects, Testing, Performance,
    and Alt Controls*, where we will start thinking about other platforms to port
    our game to.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您记得在 `PlayerShipBuild` 脚本的开始部分，我们添加了一个游戏对象变量，该变量将接受一个 `shopButtons` 数组。我们可以在脚本开始时使用
    `for` 循环自动添加每个 `UPGRADE` 游戏对象，但如果将来我们想要考虑使用游戏手柄或键盘来引导我们通过选择网格，我们将对知道哪个按钮分配给每个数组编号有更多的控制。这也是一种不依赖代码的编程方式，因为
    Unity 是一个基于组件的引擎。其他控制器输入和交互是我们将在 [*第 13 章*](B18381_13_Epub.xhtml#_idTextAnchor219)，*效果、测试、性能和替代控制*）中讨论的内容，我们将开始考虑将游戏移植到其他平台。
- en: 'With the potential of updating our controls in a later lesson, here is how
    you should attach the game objects to the `shopButtons` array in the Unity Editor:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续课程中更新我们的控制功能，以下是您应该在 Unity 编辑器中将游戏对象附加到 `shopButtons` 数组的方法：
- en: With the shop game object still selected in the **Hierarchy** window, it's probably
    best to lock the **Inspector** window at this point (as we did in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087),
    *Applying Art, Animation, and Particles*), as we are going to be selecting and
    dragging different game objects.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中仍然选择商店游戏对象时，此时锁定 **Inspector** 窗口可能是最好的选择（正如我们在 [*第 4 章*](B18381_04_Epub.xhtml#_idTextAnchor087)，*应用艺术、动画和粒子*）中做的），因为我们将要选择和拖动不同的游戏对象。
- en: Change the shop button's size from `0` to `10` in the **Inspector** window.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 窗口中将商店按钮的大小从 `0` 更改为 `10`。
- en: We will now get a burst of empty game object fields in the `SelectionQuad` game
    object to each field.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为每个 `SelectionQuad` 游戏对象获得一系列空的游戏对象字段。
- en: Next, to make things even easier, click on the arrow to the left of each game
    object under the shop game object to expand each of the child game objects. This
    will uncover the `SelectionQuad` game objects that we need to drag across.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了使事情更加简单，点击商店游戏对象下每个游戏对象左侧的箭头以展开每个子游戏对象。这将揭示我们需要拖动的 `SelectionQuad` 游戏对象。
- en: 'The following screenshot shows the **Inspector** window with a list of empty
    game objects and the **Hierarchy** window game objects expanded out:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了包含空游戏对象列表的 **Inspector** 窗口和展开的 **Hierarchy** 窗口游戏对象：
- en: '![Figure 5.27 – Drag and drop each SelectionQuad game object from the Hierarchy
    window into the correct fields in the Inspector window'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.27 – 将每个 SelectionQuad 游戏对象从 Hierarchy 窗口拖放到 Inspector 窗口中的正确字段]'
- en: '](img/Figure_5.27_B18381.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.27 – Figure_5.27_B18381.jpg]'
- en: Figure 5.27 – Drag and drop each SelectionQuad game object from the Hierarchy
    window into the correct fields in the Inspector window
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27 – 将Hierarchy窗口中的每个SelectionQuad游戏对象拖放到Inspector窗口的正确字段中
- en: We have also added arrow stripes to the previous screenshot to show which `SelectionQuad`
    objects need to go into which game object field in the **Inspector** window.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在之前的屏幕截图上添加了箭头条纹，以显示哪些`SelectionQuad`对象需要放入**Inspector**窗口的哪个游戏对象字段。
- en: Save the scene. If you locked your **Inspector** window, don't forget to unlock
    it.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。如果你锁定了**Inspector**窗口，别忘了解锁它。
- en: Press the **Play** button in the Editor.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中按下**播放**按钮。
- en: Now, when the scene starts, all the blue selection quads disappear, but if you
    click on any one, it will light up, depending on which button is pressed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当场景开始时，所有的蓝色选择四边形都会消失，但如果你点击任何一个，它将根据按下的哪个按钮而亮起。
- en: 'The following screenshot shows the atom bomb button selected when the mouse
    clicks on it in the game window. This will also work with touchscreen devices:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当鼠标在游戏窗口中点击它时选择的原子弹按钮。这也适用于触摸屏设备：
- en: '![Figure 5.28 – The Atom Bomb button selected'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28 – 选择的原子弹按钮'
- en: '](img/Figure_5.28_B18381.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28 – Figure_5.28_B18381.jpg]'
- en: Figure 5.28 – The Atom Bomb button selected
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 – 选择的原子弹按钮
- en: That covers using raycasts, which is a transferable skill and can be used for
    anything that involves shooting to grab information from another game object,
    providing it has a collider attached to it.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了使用射线投射，这是一种可转移的技能，可以用于任何涉及射击以从另一个游戏对象中获取信息的情况，前提是它附有碰撞器。
- en: Let's now move on to updating the description panel so that when a selection
    is made from the grid, we get the text on the large, dark rectangle with information
    we stored from the same scriptable objects that give information to each player
    upgrade button.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续更新描述面板，以便当从网格中选择一个选项时，我们能够从存储在相同可脚本对象中的信息获取大暗矩形上的文本，这些可脚本对象为每个玩家升级按钮提供信息。
- en: Adding information to our description panel
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的描述面板添加信息
- en: When a selection is made in the shop scene, we can take the information from
    the selection's scriptable object asset file and display its details within its
    `textBoxPanel` game object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当在商店场景中选择一个选项时，我们可以从选择的脚本对象资产文件中获取信息，并在其`textBoxPanel`游戏对象内显示其详细信息。
- en: 'Let''s take a look at the `textBoxPanel` object in the **Hierarchy** window:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看**Hierarchy**窗口中的`textBoxPanel`对象：
- en: '![Figure 5.29 – Our ''textBoxPanel'' content in the Hierarchy window'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.29 – Hierarchy窗口中的我们的''textBoxPanel''内容'
- en: '](img/Figure_5.29_B18381.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.29 – Figure_5.29_B18381.jpg]'
- en: Figure 5.29 – Our 'textBoxPanel' content in the Hierarchy window
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29 – Hierarchy窗口中的我们的'textBoxPanel'内容
- en: 'The `textBoxPanel` game object holds a black quad that is used for its background.
    It also holds four other game objects, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`textBoxPanel`游戏对象包含一个用于其背景的黑色四边形。它还包含其他四个游戏对象，如下所示：'
- en: '`name`: This game object contains a `iconName` scriptable object variable.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：此游戏对象包含一个`iconName`可脚本对象变量。'
- en: '`desc`: This game object also holds a `description` scriptable object variable.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`desc`：此游戏对象还包含一个`description`可脚本对象变量。'
- en: '`backPanel`: This game object serves as a background for the selection grid.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backPanel`：此游戏对象作为选择网格的背景。'
- en: '`BUY?`: This game object will be covered later on when we want to confirm that
    we want to purchase the item we have selected.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUY?`：当我们要确认购买所选项目时，将在稍后讨论此游戏对象。'
- en: 'The following screenshot identifies the two scriptable object data types from
    the `Health_Level1` asset file that we made earlier in this chapter. The information
    on this large rectangle will change, depending on which button is selected:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图标识了从我们本章早期制作的`Health_Level1`资产文件中获取的两个脚本对象数据类型。这个大矩形上的信息将根据所选按钮而改变：
- en: '![Figure 5.30 – A description of the button selected in the rectangle box'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.30 – 在矩形框中选择的按钮的描述'
- en: '](img/Figure_5.30_B18381.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.30 – Figure_5.30_B18381.jpg]'
- en: Figure 5.30 – A description of the button selected in the rectangle box
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30 – 在矩形框中选择的按钮的描述
- en: 'Let''s now go back to the `PlayerShipBuild` script and add some more code to
    update the description panel (the `textBoxPanel` game object):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在回到`PlayerShipBuild`脚本，并添加一些代码来更新描述面板（`textBoxPanel`游戏对象）：
- en: 'Reopen the `PlayerShipBuild` script and add the following variable to the top
    of the script with the other variables:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`PlayerShipBuild`脚本，并将以下变量添加到脚本顶部，与其他变量一起：
- en: '[PRE19]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This game object variable will hold a reference to the `textBoxPanel` game object
    in our scene. Next, we need to grab and refer to this game object from our **Hierarchy**
    window.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏对象变量将保存对场景中 `textBoxPanel` 游戏对象的引用。接下来，我们需要从 **层次结构** 窗口中获取并引用这个游戏对象。
- en: 'Scroll down to the `Start` function and enter the following line of code to
    store the `textBoxPanel` game object as a reference:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `Start` 函数，并输入以下代码行以将 `textBoxPanel` 游戏对象作为引用存储：
- en: '[PRE20]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, scroll down to the content of `AttemptSelection`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，滚动到 `AttemptSelection` 的内容。
- en: 'Scroll down until we get to the following `if` statement and add `UpdateDescriptionBox();`
    to the content of that statement:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到以下 `if` 语句，并将 `UpdateDescriptionBox();` 添加到该语句的内容中：
- en: '[PRE21]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `UpdateDescriptionBox` method will grab the selected button's two assets.
    These asserts (`iconName` and `description)` are then applied to each `TextMesh`
    `text` component of `textboxPanel`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateDescriptionBox` 方法将获取所选按钮的两个资产。这些资产（`iconName` 和 `description`）随后被应用到
    `textboxPanel` 的每个 `TextMesh` `text` 组件上。'
- en: 'Let''s now enter the content of this method with the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们用以下代码进入这个方法的正文：
- en: '[PRE22]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `UpdateDescriptionBox` method will get the reference name and description
    from the shop button that's selected and will apply the string values to the shop's
    black noticeboard ( `textBoxPanel`).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateDescriptionBox` 方法将获取所选商店按钮的引用名称和描述，并将字符串值应用到商店的黑色公告板上（`textBoxPanel`）。'
- en: Save the script.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Test the results by pressing **Play** in the Unity Editor.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Unity 编辑器中按 **播放** 测试结果。
- en: 'The following screenshot shows the first selection grid being selected with
    the description panel details displayed:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了第一个选择网格被选中，并显示了描述面板的详细信息：
- en: '![Figure 5.31 – The description displayed for selecting the ''Blast Shot''
    weapon'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.31 – 选择‘爆破射击’武器时显示的描述](img/Figure_5.31_B18381.jpg)'
- en: '](img/Figure_5.31_B18381.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.31 – 选择‘爆破射击’武器时显示的描述](img/Figure_5.31_B18381.jpg)'
- en: Figure 5.31 – The description displayed for selecting the 'Blast Shot' weapon
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 选择‘爆破射击’武器时显示的描述
- en: With a small amount of code, the description panel lights up and displays information
    from any of the items that are selected. This is useful, as if we ever wanted
    to extend the selection grid with more items, we wouldn't need to bloat our code
    to compensate for each selection.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 用少量的代码，描述面板就会亮起并显示所选任何物品的信息。这很有用，因为我们如果想要通过添加更多物品来扩展选择网格，我们就不需要膨胀我们的代码来补偿每个选择。
- en: We now have a shop scene that shows what is available to buy and descriptions
    of what each item is. Let's summarize what we have learned in this chapter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个显示可购买内容和每个物品描述的商店场景。让我们总结一下本章我们学到了什么。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started creating a shop scene that holds various buttons
    and panels created from three-dimensional polygons. We then created our own script
    to fill the scene with images, values, names, and descriptions of assets that
    can potentially be purchased with virtual credits.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始创建一个包含由三维多边形创建的各种按钮和面板的商店场景。然后我们创建了自己的脚本，用图像、值、名称和描述填充场景，这些资产可以用虚拟信用购买。
- en: We also made use of scriptable objects to create a template for our code so
    that it can be topped up with various in-game powerups without inflating our game's
    framework. We also made it interchangeable, so if a weapon needs changing, replacing,
    or removing, we can simply remove the template without affecting the rest of the
    code in our game framework.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用可脚本化的对象创建了一个代码模板，这样它就可以通过添加各种游戏内增强功能来补充，而不会膨胀我们的游戏框架。我们还使其可互换，如果需要更换、替换或删除武器，我们只需简单地删除模板，而不会影响游戏框架中的其他代码。
- en: The other lesson we learned in this chapter is being aware that we can create
    games that are free to download but also knowing how to create a form of income
    with a monetization game design to create revenue.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们学到的另一课是意识到我们可以创建免费下载的游戏，同时也要知道如何通过货币化游戏设计创建收入形式。
- en: In the next chapter, we will continue with our shop scene and focus more on
    the content of each button and the overall functionality of our shop by adding
    content to our player's ship. We will also look at game advertisements as a form
    of currency for the player to upgrade their spaceship.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的商店场景，通过向玩家的飞船添加内容，更多地关注每个按钮的内容和商店的整体功能。我们还将探讨游戏广告作为玩家升级飞船的一种货币形式。
