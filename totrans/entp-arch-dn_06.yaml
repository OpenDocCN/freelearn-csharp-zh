- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID Principles, from Code to Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from this chapter, we are going to step away from the theoretical part
    and, while we are not yet starting to code (this will start in [*Chapter 13*](B21293_13.xhtml#_idTextAnchor470)),
    we will start applying the theory to designing a small information system made
    of several applications. We will decompose the different functions, show how they
    help produce business process outcomes and create the software behind these functions.
    To do so, we will design the different components and the API contracts for the
    services involved, and think of how the data should be designed and governed.
    And in [*Chapter 13*](B21293_13.xhtml#_idTextAnchor470), we will use all of this
    design phase to actually implement the sample information system.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this information system will be reduced in perimeter and complexity,
    but the exercise has been designed to include most of the important decisions
    that should be made. You will find strict responsibility separation, nice separation
    between processes and functions, decoupling of the service through APIs, standardization
    of the contracts, best-of-breed approach, adapting the software stack to the functions
    desired, independence between the software and the hardware, and lots of other
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will start designing our demonstration system by thinking
    of the functions it should expose. To do so, we will use the **SOLID principles**,
    extending them to information systems. SOLID is the acronym composed of the first
    letters of the five essential principles of software development, which are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility** states that one module should only do one thing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/closed** differentiates between open to evolution and closed to modification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov’s** principle explains how substitution should work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation** follows with how contracts should be strongly aligned
    to business functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, **dependency inversion** deals with coupling and how it should be done,
    at the inverse of what seems natural in most cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It happens that these principles, often applied to software applications, actually
    apply to every software system and constitute a great way to design their different
    modules. We will thus use them to design our sample information system. But first,
    we need to describe the business requirements for this system.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the sample information system requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before any kind of analysis, we will imagine what the system owner would want
    from it. Of course, as we explained, time is a very important constraint in information
    systems design, which has a long life, and we will simulate the fact that we do
    not know everything about the requirements at first. In particular, the last chapters
    of the book will simulate the fact that new requirements arise for the imaginary
    company owning the information system, and explain how the system will adapt to
    it. This point is particularly important because the main goal of this book is
    to show how a system should be created or adapted so that its evolution is simpler
    in time.
  prefs: []
  type: TYPE_NORMAL
- en: To make the exercise as realistic as possible, while keeping it simple for it
    to be contained in a single book, we will imagine the company, the users of the
    information system, their business, the data they manipulate, and so on. This
    is what we are going to do in this first section.
  prefs: []
  type: TYPE_NORMAL
- en: The company and its business
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The company, which we will call **DemoEditor** for this purpose, would be an
    editing company that contracts with individual authors for the writing of books
    and then sells these books. We will imagine that this is quite a small company
    (less than 50 persons) and that its current information system is extremely reduced,
    mostly composed of a standard Office 365 organization providing them with email
    capability, basic SharePoint document management, an externalized website, and
    lots of internal functions being implemented through Excel workbooks.
  prefs: []
  type: TYPE_NORMAL
- en: While this remains a comfortable situation, because the information system has
    not turned into a spaghetti dish due to a long accumulation of point-to-point
    interoperations, degradation of legacy software applications, and so on, it still
    shows signs of inefficacy. The multiple copies of the Excel workbooks make it
    difficult for the employees to have a clear view of the pool of authors and the
    state of the writing of the books. Also, as the process of writing is not uniform,
    the director of the company complains about not being able to find clear statistics
    about global advances or delays in book delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The business is mostly about finding the right subjects for the market, choosing
    the right author, following up on the writing of the books, and organizing the
    right sales process.
  prefs: []
  type: TYPE_NORMAL
- en: The users and actors of the information system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 50 persons are, mostly, book editors. Then come the sales team, a bit of
    administration, and the director. For this simple example, we will consider that
    all the printing and distribution of the books is outsourced to another company
    and that DemoEditor concentrates only on the editing process.
  prefs: []
  type: TYPE_NORMAL
- en: The book editors’ job is to find authors, find book subjects, and match the
    right author to the right book. Then, they follow the writing process and make
    sure that the quality is there.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is up to the sales team and their job is to find indirect customers,
    which means libraries or book-selling organizations, as DemoEditor does not sell
    directly to readers. This means that commercial people actually sell the books
    by numbers, and not by units. Though we will not deal much with this part in our
    demo software system, it would be important in a real situation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the director needs to keep numbers in check through reporting and statistics
    coming from the sales team and the editors. The smooth running of the company
    heavily depends on the right deadlines for the book as much as the quality of
    the writing, the match between the subject and the author, and the expectations
    of readers and book-selling companies. This means that the director has to measure
    all of these indicators, and the information system is of course expected to provide
    them. Asking editors or salespersons to fill in Excel sheets every week does not
    make sense, as this is time lost for their real jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have imagined, DemoEditor’s information system will have to manipulate
    data about authors, books, and sales, plus some additional statistics drawn from
    these primary data. The author will be known by their identity, a little contact
    information, maybe their bank coordinates to pay them royalties, and certainly
    information on their skills. Books will be registered with business-wide reference
    numbers, their titles, their summaries, and other information about the content.
    Sales will basically be the number of books sold to booksellers, with the associated
    date and maybe sales conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reporting data will be everything that can be used to apply business intelligence
    by the director on sales, authors, and books: how many books are sold for each
    category, what the time trend of selling them is, how many editions authors can
    work on for a given book before sales slow down and the novelty effect does not
    work anymore, who is their best salesperson, which bookseller returns the least
    number of books or reorders some the quickest, and so on. The reporting data is
    definitely bound to time, and not only by the fact that reports evolve in time,
    but also by the fact that reports should show the movements of business in time
    as well as geographically.'
  prefs: []
  type: TYPE_NORMAL
- en: The stakes of the information system for the company
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DemoEditor is a small company, which means that employees can “fill the gaps”
    and do a little bit of everything. While this is an advantage in some cases, meaning
    that they are agile and adaptive, it also means that they do not tend to do things
    in an industrial, repeatable way. Excel spreadsheets may be copied over and spread
    out in different versions all over the company instead of a unique, reference
    version being kept on the network. Also, data sales are spread around the different
    salespersons because they tend to be competitive toward each other and it is thus
    difficult to homogenize quantity discounts (the price is fixed) as well as customer
    listings.
  prefs: []
  type: TYPE_NORMAL
- en: As the commercial pipe is not very formal, some leads become prospects and then
    customers without the salesperson being able to really give statistics on how
    long and how much effort this takes them. The director really has a hard time
    knowing whether the company would sell more if they hired more salespersons. The
    choice of authors for the right books is also an issue. Generally, the editors
    have a good grasp on the market and know quite well which subjects should be written
    about. But the pool of competent authors is quite restricted and the authors are
    mostly known for the books they have already written. Most of the time, the editors
    do not know which other technologies these experts know about and there have been
    times when a book has been contracted to a new author, after taking a lot of time
    to find them, only for the editor to realize a few weeks later that one of the
    good authors who’s already written several books for DemoEditor actually had the
    right skills for the new project. An updated, shared, and efficient knowledge
    of author competencies is important for DemoEditor.
  prefs: []
  type: TYPE_NORMAL
- en: The situation as seen by the person put in charge of improving the system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are asked by the director to come and help with the information system.
    Everyone in the company knows IT could be more efficient and help them better
    but, as they say, they are not specialists in it. Since there was no internal
    IT guy, they did as best as they could, but they realized the “do it yourself”
    spirit of a small company can only go so far, and they had to get someone to give
    some structure. The director is also anxious about increasing the size of the
    company before this effort is done; otherwise, it may add more problems than growth.
  prefs: []
  type: TYPE_NORMAL
- en: As the business processes go on and the budget is not extensible, you are tasked
    with “*changing the wheel while the car is running*.” There may be some small
    stops in the IT system, but not for long periods. The data has got to be cleaned
    but the databases of authors and books have got to remain available along the
    way since they are everyday tools for most of the company’s employees. The director
    does not care much about its reporting being unavailable, or even destroyed, since
    it is not very useful at the moment and most of the numbers were false anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will put ourselves in the skin of an engineer asked
    to carry out this foundational task and design the different components of the
    renewed IT system, and decide how its services should operate and what business
    domains should be designed. After that, we will implement all this and progressively
    transform the information system. But for now, we have to transform the theory
    learned in the previous chapters into principles that will guide us along the
    way. SOLID principles are a great set of principles that apply perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles and application to systems of whatever scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID principles are important principles that apply to software applications,
    but they happen to also apply very well to software systems in general, so we
    will be able to use them to structure our project. We are going to explain the
    five principles one by one, together with how they apply to the transformation
    requested by DemoEditor and the design of its new information system. As this
    is a book about information systems and not software development, even though
    we will eventually build some implementations, I will not describe the principles
    from the coding point of view, but only briefly their main idea and, with more
    details, their translation into systems design.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle states that a class, or in our case, a module of an information
    system, should do one and only one thing. This is quite wide as a definition but
    it can be narrowed down a bit by stating that an entity should have only one business
    reason to change. If the same class should be upgraded when there are changes
    in the author’s management and the book’s management, there is a problem regarding
    this single responsibility principle and the class should be decomposed into at
    least two smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: This principle is obviously easy to translate into an information system where
    it applies directly to modules, whether they are services, components, or other
    grains of entire systems (we will come back to the management of granularity in
    the next chapter). Each entity in the system should do one thing and only one.
    If this is observed from the point of view of the software applications composing
    the system, that means that each application should be in charge of only one business
    domain of the system. Since we manage authors, books, sales, and so on, we should
    indeed find one application for each of these. This notion of a business domain
    is not very precise for now but again, we will come to this in a future chapter,
    namely [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318), detailing the **domain-driven
    design** approach and the concepts of domain and bounded context.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s just agree that a business domain needs its own application.
    If you are thinking microservices, yes, this is the track we are going to follow
    but bear with me, as this “micro” qualification is not always necessary and we
    would rather talk about “services” (with a clearer definition in [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This first principle may sound very simple (and it is in its expression), but
    its implication can be very profound. To give just one example of the complexities
    we will have to deal with in our sample application, let’s unroll the case where
    a service depends on another, like in the case of the relationship of the “author
    of a book.” As said before, author and book management are two separate responsibilities.
    But how should we deal with the relationships between both? Is it another service?
    In any case, when someone reads a book entity from the service, how should the
    author of the book be retrieved and displayed? We can ask the same question the
    other way around: if someone calls the API on a given author, how should we display
    the list of books this author has participated in writing?'
  prefs: []
  type: TYPE_NORMAL
- en: Diving into this last scenario is useful to get a better grasp of the concept
    of responsibility. Imagine that there are two separate services, each with its
    own database since they are supposed to be independent. Now, a user calls the
    API with a `GET` word on a particular book, let’s say `https://demoeditor.org/api/books/123456`.
    The module is indeed responsible for sending the book title, ISBN/EAN number,
    and some other attributes of the book. How about the information about the author?
    This is where the principle of responsibility helps to draw the line. The editors
    would tell you that, most of the time, when they get the information about the
    book, they need to know the author, but only by their identifier and some main
    data, such as their first and last name. This is the responsibility of the book
    service. And if you ask your product owners again (the editors, as they are the
    ones who will be using the information system), and they need some more data,
    they will turn to the `/api/authors` service to get it, using, of course, the
    identifier provided by the initial answer from the `/api/books` service. Thus,
    that data is the only responsibility of the second service.
  prefs: []
  type: TYPE_NORMAL
- en: Each reader who knows about the principles of good database design is certainly
    suffocating already, considering that this approach necessitates data duplication.
    Indeed, since `/api/authors` is responsible for the whole data for the authors,
    including of course their first name and last name, that means that, if `/api/books`
    is responsible for providing, upon request, the identifier, first name, and last
    name of the author of the given book, the rule of non-duplication is broken! And
    this is where the concept of responsibility is interesting and should be dug into
    deeper. How about considering the following share of responsibilities?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/api/authors` service is responsible for providing always up-to-date data
    about an author, including their first name and last name. This means that it
    is the reference source of truth for the authors: anyone who needs the latest,
    best-so-far information about an author should turn to this service, which will
    be responsible for providing it on time. Since it is the reference for this data,
    the service would certainly provide it with a value date, as the data may change
    over time. For example, an author could change their last name after getting married;
    this should be tracked by the author service, as it is responsible for the data
    about authors and their integrity.'
  prefs: []
  type: TYPE_NORMAL
- en: The `/api/books` service is responsible for providing the same service for books,
    which means the same level of engagement on the book title, identifiers, and so
    on. But when talking about the author of a book, this is a relationship to another
    reference service, so the only data it is responsible for in terms of service
    is to point at the right entity in the other service. And this raises two interesting
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is functional: is the link supposed to simply point to a given
    author, or is it supposed to point to the value of an author *at a given point
    in time*? This necessitates answering some business rules: if an author gets married
    between the first and second editions of a book, should the author’s name as it
    appears on the book change? And if so, how should the registered copyright be
    adjusted? And is the same true for a simple reprint of the original edition of
    the book?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is more technical: if the book service stores the link to the
    author service and the latter is not available when needed, what happens? If a
    copy of the “usual” data (first name and last name) has been stored in the book
    service, no problem since it is now *independent* of the second one. But this
    comes back to the functional question again: if the name should not be changed
    on the book after an author gets married, no problem, and it is even better, as
    the local copy will prevent the difficulty of reaching the author’s service with
    the date of value to retrieve the “old” data. And if the name should evolve, it
    may be better to temporarily fall back on the old one rather than providing just
    the machine-readable identifier; only editors would know…'
  prefs: []
  type: TYPE_NORMAL
- en: I hope this example, though complex, has shown you what we mean by the word
    *responsibility*. It is admittedly complex but, remember, everything we talked
    about was linked to business complexity and is not accidental. Indeed, talking
    about value date and the importance of history in reference to data management
    may sound overly complex because it is not very often dealt with in current information
    systems. But this is a real problem and this lack of reflecting on the actual
    functional reality is a problem as it prevents reflecting all business rules!
    That does not mean that the software that will be constructed based on this reflection
    will take all this complexity into account. In a true Agile way, you will certainly
    start with something very simple. But this deep understanding of the functional
    complexity ensures that the software will be easy to evolve in the future and
    that you will not be stuck at some point of implementation because the software
    is not aligned with the business.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **open/closed principle** starts with a paradox in its very expression,
    which makes it strange at first sight: how can a module be open and closed at
    the same time? The comprehension of this principle is very important to create
    systems that will evolve because it states what should remain closed and what
    should be open to change for this evolution to work as smoothly as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: When applied to object-oriented programming, the open/closed principle states
    that a class should be open to extension, but closed to modification. Encapsulation
    and private members are used to prevent any instance in the program from modifying
    directly the state of another instance; otherwise, it would be very difficult
    to follow what happens when executing the program. Even debugging would be complicated
    if there is no way to track what class modifies the state of another one. This
    is why a class keeps its members private and only opens some public functions
    to allow only some changes in its state, in a way that is controlled by its own
    code, following its own rules. This is the closed part of the principle.
  prefs: []
  type: TYPE_NORMAL
- en: But a class, in general, is not marked as `final` to let another class inherit
    from it and specialize the functions that are marked as `virtual`. The inheriting
    class can also add some data members, in addition to accessing the one from the
    inherited class that is marked as `protected` (or, of course, `public`). Again,
    the class controls what can be overridden and what cannot, but at least it is
    open to an extension of its behavior by another class. This is the open part of
    the principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this principle to information systems does not imply a big change
    in reflection, as the services replace the classes, and the techniques to extend
    or protect only vary from the practical point of view. If we continue with examples
    where services are REST APIs, we can draw a parallel between the members of a
    class and the data that is persisted by the implementation of an API contract:
    nothing but the service can modify this data, as only the implementation has access
    to the persistence used (a database or anything else). Of course, some API methods
    may allow some specific modifications to be carried from the API clients, but
    the API implementation controls this and applies business rules to ensure the
    modification is carried as it wants (or maybe rejected, by the way). This is the
    closed part of the principle applied to a module of information systems, and it
    is quite obvious in its resemblance to the application in a class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the open part of the principle on an API is trickier,
    as the behavior of an API can be extended in many ways:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to do so is to create an API that will extend the initial API
    contract. Mechanisms exist in the OpenAPI grammar to implement polymorphism and
    it is also possible to aggregate types in such a way that the new one contains
    the initial type and all its content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way is to create an API that replaces the exposition of the old implementation,
    but still relies on it for all the standard data, and then provides its own data
    in addition. If done carefully, the extended API may even be fully compatible
    with the initial API contract, since it only adds new data (and if it just passes
    the initial data without changing any behavior, it even complies with the Liskov
    substitution principle, which we will see shortly).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third option is to use an API gateway to expose the updated contract and implement
    the mixing of data coming from the original API and the additional data coming
    from another service dedicated to its storing and manipulation. This approach
    is a bit closer to the principle of inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three approaches are schematized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.1 – Open/closed\uFEFF approaches to APIs](img/Figure_6.1_B21293.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Open/closed approaches to APIs
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Display`, that would implement a `print` function that sends black text
    on a white paper (through a printer, a screen, or anything else; no importance
    here). Let’s now suppose that a class called `ColorDisplay` specializes in the
    `Display` class and proposes a new function signature called `print` again, but
    accepts a parameter named `color` that allows the user to specify any color they
    want. How should the parameterless `print` function behave? The inheriting class
    will certainly point to its new and improved `print` function. And in this case,
    what should be the default color passed to this function? If you answer “black,
    of course,” you know what the Liskov substitution principle is about not surprising
    the user of a class, and ensuring them that the behavior is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for services inside a modular information system. Again, we will
    use APIs, as this is the standard way to decompose modules in such a system. When
    an API contract is provided to you, it states what method can be called, with
    which verbs, and through which URL; it also states the exact name of the attributes
    that you can send or that you will receive. But you may very well respect the
    letter of the contract API without respecting its spirit and this is what the
    Liskov substitution principle is about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s translate our previous example from object-oriented programming into
    API services, and imagine one can use version 1.0 of `/api/print` to process some
    text that will be sent to the device in black color. If using version 1.1 of an
    `/api/print` API, with the support of `/api/print?color=[HEX-VALUE]`, we will
    definitely expect that pointing our old client to the new API results in the production
    of black text. In terms of the stream between the API contract and its implementation,
    this can be pictured as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.2\uFEFF – Liskov substitution](img/Figure_6.2_B21293.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Liskov substitution
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Rectangle` class implements the `IShape` interface. This means that `Rectangle`
    would have to implement the `getSurface` and `getPerimeter` methods but also some
    methods such as `drawShape` and so on. If the only interesting thing in the program
    is to compute the mathematical characteristics of shapes, then the right approach
    would be to split `IShape` into `IGeometricalShape` and `IDrawableShape` (i.e.,
    segregate the interfaces) for the classes to implement only the interface they
    need.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for API contracts. To come back to our book service, it is better
    to separate two contracts, one for the book characteristics and one for the book
    sales characteristics, even if the same implementation will expose the two interfaces,
    one behind `/api/books` and the other behind `/api/books/sales`, rather than force
    the implementation of all functions by the use of only one contract.
  prefs: []
  type: TYPE_NORMAL
- en: Though it is always possible (and more acceptable in an API than in a class)
    to respond with a `NotImplemented` message, the separation into two interfaces
    also makes it easier to introduce versions. If the sales interface was not correctly
    defined in version 1.0 and a major, backward-compatible rewrite is necessary,
    it will be possible to continue exposing the book’s characteristics (potentially
    used by most of the clients) without any change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Backward compatibility** is the quality of a new version of an API where
    all calls used in the previous version work exactly with the same result on the
    new one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface segregation even makes it possible (and easy) to expose three
    API contracts, namely `/api/books`, `/api/books/sales`, and `/api/books/sales/v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Interface segregation](img/Figure_6.3_B21293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Interface segregation
  prefs: []
  type: TYPE_NORMAL
- en: Though quite obvious in the explanation, this principle is sadly often forgotten
    in existing APIs. This is particularly so because editors tend to provide functions
    in the frameworks that generate the OpenAPI contract from the implementation,
    instead of following the contract-first approach (which is admittedly more complicated,
    but the only one that leads to proper, business-aligned APIs). Since the contract
    is automatically generated from the whole source code, the generators do not make
    any difference between the different methods and resources and produce a single,
    monolithic contract that does not respect the interface segregation principle.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **dependency inversion approach** is named as such because it goes against
    the usual way of thinking about dependency. Imagine that we have a reporting module
    and another module that provides the data to be used for reporting purposes. Naturally,
    we tend to think that the reporting module should depend on the data module in
    technical terms because this is how it works from the functional point of view.
    This is a rare case where aligning the technical design directly with the functional
    concepts is not good enough. If we want to ensure low coupling, we have to make
    one more step and add some indirection to a common interface that both of the
    services will depend on:'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the `Data` class would implement `IData`, the `/api/data` service
    should implement the API contract defined in the data OpenAPI file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And like the `Reporting` class would use the `IData` source (and not directly
    the `Data` implementation) to prevent hard coupling, the `/api/reporting` service
    would not directly call the `/api/data` service but the URL provided to it by
    configuration, providing that it implements the data OpenAPI contract. In object-oriented
    programming, this will typically be done by injection. In a service, depending
    on the orchestration mechanism, this can be realized through an API gateway, the
    ingress exposition, or even a (more complicated) service mesh.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram has already been used in [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069),
    but it is particularly relevant here, as it shows visually the dependency inversion
    principle in information systems: instead of a dependency of one software module
    on another, each of the two modules working together points at the same business
    contract definition (which is purely functional), one to implement it, the other
    to consume it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Coupling on the four layers diagram](img/Figure_6.4_B21293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Coupling on the four layers diagram
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next section where we’ll analyze the SOLID principle.
  prefs: []
  type: TYPE_NORMAL
- en: Critical analysis of SOLID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though I have realized in time (certainly like many others) that the SOLID principles
    apply almost as well to information systems as to object-oriented classes and
    interfaces, some parts deserve discussion. Indeed, like for any other principle,
    a strict, not thoughtful, application may lead to problems. And even when the
    principles apply well to a given context, they may have strong side effects that
    make them ultimately more harmful than helpful. The necessary measured approach
    has led to lots of polemics and you must be careful in handling these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Limits of the separation of responsibilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first (and maybe most important) principle, namely the one about separation
    of responsibilities, is sometimes hard – perhaps impossible in some cases – to
    apply to services or high-level modules of an application. With classes, there
    is always the possibility to decompose a class without much impact on the whole
    application, once compiled. Services and modules do not present this ease of composition
    because they come with additional constraints such as exposition, endpoints, coding
    interfaces, documentation, integration subsystems, and so on. All this takes a
    toll on the decomposition, and this is the reason why people who are not careful
    with microservices and decompose them too much in their systems end up spending
    more time evolving them than if they had stayed on a monolith architecture. I
    am not going to talk again about granularity because the subject was already developed
    in the previous chapters, but this is clearly something that must be pondered
    and can limit the reach of the principle of separation of responsibilities, or
    at least its depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difficulty is not linked to how deeply you can separate the responsibilities,
    but how intricate some of them are sometimes, even at a relatively high level.
    This is, for example, a huge difficulty in “micro-frontend” architectures, and
    I am not talking about the problem associated with how “micro” the frontend component
    is. The simple fact that visual components present functions, but also have a
    visual impact, is a huge difficulty in making them independent. This is what is
    exposed, for example, in [https://jonhilton.net/good-blazor-components/](https://jonhilton.net/good-blazor-components/):
    by delegating the content of a Blazor component to another sub-component (in the
    example of the article, using the `ChildContext` property to include a `Card`
    instance), you indeed externalize the responsibility of displaying the inner part
    of a visual component. But that does not mean it will not have an impact, as the
    rendering of the subcomponent will necessarily have an impact on the one above
    it. Indeed, either the container fixes a size for the child and then takes responsibility
    for its display, or the container – in a purely responsive design manner – lets
    the child component adapt its display. In this case, its own size will be impacted
    by its child, which also ruins the independence that was supposed to be achieved
    by the principle of separation of responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: The intellectual solution for this is to consider that each component has the
    responsibility for its content, but not for its display and that this is the responsibility
    of the display engine in the browser. It may not be very satisfying because it
    comes back to a single point of execution for the whole frontend, which we were
    trying to make modular and easy to evolve, but at least the low coupling between
    the components has been achieved, though on a limited perimeter. This is one of
    the many compromises one will have to make when designing information systems
    and modular applications.
  prefs: []
  type: TYPE_NORMAL
- en: About the polemics on monoliths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter may be a good place to talk about the long-held discussion about
    “going back to monoliths,” a reaction to the drawbacks of microservices that have
    been very much observed in the discussions of the communities of software architects.
    In summary, the microservice approach is considered harmful and some people recommend
    going back to monolith applications. This is sadly another example of how polarized
    debates are nowadays, because both approaches (and the huge spectrum between them)
    have value, depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: No one serious has ever pretended microservices were the best solution for every
    architecture. In fact, right from the beginning, most articles explaining the
    approach insisted that they were only adapted to some specific circumstances (high
    volumes, frequent modification of the application, clear cut between teams in
    charge of different modules, and so on). However, some people did not take this
    into account and now complain that microservices were not the right fit for their
    case. Even worse, in a binary and not very thought-out reaction, they discard
    the whole principle of microservices and advertise a so-called “return to the
    monolith.” Any sensible engineer in this case would simply spot the well-known
    pendulum movement where one extreme chases another one. And the solution in this
    case is not in either of them or continuously balancing between one and the other,
    but simply reaching the nice equilibrium between them.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of software applications, what do we call a monolith? An application
    made of a single process? No, otherwise that would mean that even the smallest
    application such as `cd` or `exit` should be considered as such. The term has
    been coined precisely to describe single applications that were in charge of too
    many business features, which made them too heavy to have a nice evolution or
    fit the use they were designed for.
  prefs: []
  type: TYPE_NORMAL
- en: The situation talked about in the articles on the so-called death of microservice
    architecture and going back to monolith simply do not talk about the right subject,
    which is the granularity of services. Sure, the very small grain of microservices
    did not satisfy their information system needs. But that simply means the grain
    was too fine. Going back to the coarsest grain one can have (the monolith) simply
    displays a lack of depth in the comprehension of the problem. An engineer approach
    to this would be to search for the right granularity of the services. As said
    in [https://codeopinion.com/biggest-scam-in-software-dev-best-practices/](https://codeopinion.com/biggest-scam-in-software-dev-best-practices/),
    the choice is not only between “Amazon is doing it, so let’s do it” and “we are
    not Amazon so we should not do it” – knowledge of the business and analysis of
    the context only will tell you where you should place yourself between the two.
  prefs: []
  type: TYPE_NORMAL
- en: It just happens that there is an existing design method called domain-driven
    design that is the perfect method to find out the right granularity of services
    for an information system. It also relates strongly to the principles of business/IT
    alignment, as it states how business domains can be cut into internally cohesive,
    externally low-coupled modules. Everything we will be doing in the design of our
    demo application will be an illustration of this research of the right granularity,
    based on the business functional needs.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of unintended coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last piece of advice on the separation of responsibilities (this first
    principle is definitely causing lots of discussions!): once you have established
    a clear cut of responsibilities based on the **business capability map**, you
    are not done with the separation of responsibilities, as it is very easy to recreate
    coupling afterward in the technological transformation of the functions.'
  prefs: []
  type: TYPE_NORMAL
- en: I will give one simple example of such a problem because it is very representative
    of the trap I described. Imagine we create our demo application with an API for
    the books, an API for the book sales (possibly exposed under the same URL, but
    still independent in terms of contract), and an API for the authors. The director
    of the company may want, at some point, a report on how the geographical origin
    of the authors impacts the localization of their sales (maybe an author from Brittany
    will sell more in their region because their network of contacts is denser around
    them? Or perhaps it has no impact? Anyway, this might be interesting to analyze).
    This is a common issue with microservices, which are supposed to have their own
    persistence. In this case, how can we make links between data, just like we were
    creating `join` operations when we added a single database? One of the standard
    approaches is to add a collecting data structure that gathers, indexes, and aggregates
    data from all the microservices and proposes a dedicated `/api/reporting` service
    with its own API contract.
  prefs: []
  type: TYPE_NORMAL
- en: This service of course presents a level of coupling toward its source, but this
    can be made a lower level of coupling, for example, by keeping a local cache or
    mixing a subscribe approach to the data changes with a direct collection under
    a lower frequency to ensure that no signal has been lost and the data is reset
    at a controlled frequency. Also, it presents interesting functions that none of
    the atomic data services provide, such as indexing, the capacity of dynamic aggregation,
    and so on. **GraphQL** is a nice protocol to expose such services, and they integrate
    very well in a **Command Query Responsibility** **Segregation** architecture.
  prefs: []
  type: TYPE_NORMAL
- en: However, there might be an unintended coupling if the atomic service not only
    provides data for this reporting service but also starts consuming atomic data
    from it. And this can happen very quickly because the performance boost of an
    indexing engine is very appealing to developers. The problem is that this causes
    a circular functional dependency, which is already quite a problem, but also a
    higher level of coupling since, once this dependency is created, the atomic data
    service becomes suddenly coupled to each of the other ones. Of course, the coupling
    may remain low, but nonetheless, a link has been created and this is – in most
    cases I have seen – a real pain to come into the system.
  prefs: []
  type: TYPE_NORMAL
- en: If you really need fast aggregated reads in an atomic service, you have to deal
    with this internally, by adding indexes on the dedicated persistency, for example.
    This may sound complicated if you see this nice indexing engine right on the other
    side of the service wall, but this is the price to pay to keep your system free
    from coupling and easy to evolve in time. Again, this is a compromise and if the
    architect decides the functional coupling is not a problem, you may save time
    by doing so. But this has to be a conscious (and documented) compromise.
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 6.5 – Reducing coupling strength](img/Figure_6.5_B21293.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Reducing coupling strength
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up before going back to the demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the SOLID principles that can be applied
    to information systems (and not only object-oriented programming, as they were
    initially aimed at); the single responsibility principle and the interface segregation
    principle have been used to start a definition of the different API contracts
    we will need for our demo application. The open/closed principle will help to
    keep this API grammar free to evolve, and its evolution will have to follow the
    Liskov substitution principle for the system to evolve satisfyingly. Finally,
    dependency inversion has been demonstrated as the core principle behind contract-first
    API and the capacity to align the software implementations on the business-oriented
    functions, which is the main goal we seek in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go one step further in the design of our demo application
    by defining its different components. This will help us to draw a perimeter of
    the first version we want to create in this book, but also to define more clearly
    the different parts of the application using a method that adapts to the depth
    of decomposition.
  prefs: []
  type: TYPE_NORMAL
