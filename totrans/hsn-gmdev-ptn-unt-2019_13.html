<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Observer</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to learn about the Observer pattern, but we are going to take a different approach from our previous chapters, for the simple reason that the Observer pattern is already natively implemented in the Unity engine, in the form of the C# event system. But just to cover our bases, we will quickly review the classic form of the Observer pattern and then compare it to the C# event system.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basics of the the Observer pattern</li>
<li>Reviewing how it's implemented natively in the C# event system</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This is a hands-on chapter, so you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following <span>Unity-specific</span> engine and C# language concept(s):</p>
<ul>
<li>Events</li>
<li>Delegates</li>
<li>Coroutines</li>
</ul>
<p>You don't need to know about them before starting this chapter, but it would help to take the time to review some online documentation on the subject.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2Fy4HvP">http://bit.ly/2Fy4HvP</a></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A preview of the Observer pattern</h1>
                </header>
            
            <article>
                
<p>As its name implies, the purpose of the Observer pattern is to observe. To be more precise, the core purpose of the Observer is to observe other objects and specific changes in their internal states. Before the Observer pattern, the only way to watch an object from the <em>outside, looking in</em> was by calling constantly or <em>pinging</em> its public members in the hope that you would capture a change in its values.</p>
<p>The Observer pattern was designed to solve this limitation by defining a system in which objects (subjects) maintain a list of other objects (observers). Subjects call observers when they need to broadcast a change on their side.</p>
<p>We can visualize the principles of this system with this real-world example of a Wall Street broker managing a catalog of stocks (subjects) associated with a list of clients (observers). When particular market events occur, the broker calls all their clients to let them know that the value of their stocks has changed.</p>
<p class="CDPAlignLeft CDPAlign">Let's review a UML diagram of a typical implementation of the Observer pattern to see how this might work when implemented in code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e843293c-2b96-46ca-8fba-4c42b1f2ddc3.png" style="width:36.08em;height:28.33em;"/></p>
<p>As you can see, the subject and the observer both have their respective interfaces, but the most important one to analyze is <kbd>ISubject</kbd>, which includes the following public functions:</p>
<ul>
<li><kbd>Attach()</kbd>: This function allows the addition of an observer object to the list of observers to notify.</li>
<li><kbd>Detach()</kbd>: This one removes an observer from the list of observers.</li>
<li><kbd>Notify()</kbd>: This will notify all the observers that have been attached to the subject's observer list.</li>
</ul>
<p>Even though this is not a very complicated design to implement, it can become very tedious to write each time you need to observe other objects. Modern languages such as C# have natively implemented the Observer pattern in the form of an event system, so programmers don't have to write it out manually.</p>
<div class="packt_infobox">Unlike applications such as spreadsheets, which usually only change their current run-states depending on users' interactions, we must take note that games are not event-driven; instead, it's the main game loop that drives the game forward.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The C# event system</h1>
                </header>
            
            <article>
                
<p>As a Unity developer, you will probably never need to implement a complete Observer pattern by hand because C# has a native implementation of the Observer natively available in the form of the event system. But before we start writing code, let's review the core components of the C# event system:</p>
<ul>
<li><strong>Events:</strong> When an event is raised by an object (publisher), it sends out a signal that other objects (subscribers) can capture. This concept might sound very familiar to that of throwing and handling exceptions, in the sense that when an exception is thrown, it goes up the call stack until it's handled. But in the case of the event system, there's not really a call chain, because once an object broadcasts an event, only those objects that subscribe to it will be notified and can choose to get triggered by it or just ignore it. So, <span><span>we can basically imagine it has as a sudden burst of a radio signal that only those with antennas can listen to.</span></span></li>
</ul>
<ul>
<li><strong>Delegates:</strong> The concept behind delegates is simple when you understand their underlying low-level mechanism. A high-level definition of delegates is that they hold references to functions. They are very useful when you want to trigger multiple functions from one call—in other words, when you want to multicast. But this is a very abstract definition of what delegates actually do behind the scenes. They're basically function pointers, which means that they hold the memory address to other functions. So, we could visualize them as an address book that contains a list of locations of functions. And that's why a delegate can hold multiple functions and call them all at once.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Observer is one of those patterns that has become embedded in modern languages and code bases. It would be hard not to use this pattern, as its drawbacks are limited.</p>
<p>The following is a list of the benefits:</p>
<ul>
<li><strong>Loose coupling</strong>: The main advantage of the Observer is that it decouples observed objects from observers. They don't need to know one another; they just broadcast or listen.</li>
<li><strong>Send data to anyone</strong>: You can easily send data to and from one object to another.</li>
<li><strong>Stop listening at any time</strong>: There's no explicit contract between subjects and listeners, so they can stop broadcasting if needed.</li>
</ul>
<p>The following is a drawback:</p>
<ul>
<li><strong>Noisy code</strong>: The Observer pattern has brought about the event-driven paradigm, but it can can become noisy and difficult to manage, if overused</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Observer pattern in the form of an event system is often used to manage user input, but let's see whether we can use events for something else, such as an automated system that broadcasts its state changes to other systems.</p>
<p>Let's say we are building a classic puzzle game with a countdown timer. As in most games or sports that have timers, we will give our player a unique sign and feedback to remind them how much time there is left.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Our three main timer feedback events are going to be as follows:</p>
<ul>
<li>Clock started</li>
<li>Half time</li>
<li>Time's up</li>
</ul>
<p>For each event, let's trigger something unique, such as the following:</p>
<ul>
<li>Dim the lights</li>
<li>Trigger a buzzer</li>
<li>Display a message on the screen</li>
</ul>
<p>But the challenge here is this: how are we going to notify the individual systems or components that manage the lighting, sounds, and UI of the state of the timer? When we have this type of problem, the Observer pattern becomes very useful, in the form of the event system: we will be able to have all those individual systems listen to the timer while it broadcasts specific timed events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>We are going to start this code example by implementing the most important component of an Observer pattern: the subject. Without something to observe, the Observer pattern has no use. Refer to the following steps:</p>
<ol>
<li>In the case of our code example, the <kbd>Timer</kbd> class is going to be our subject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>public class Timer : MonoBehaviour<br/>{<br/>    private float m_Duration = 10.0f;<br/>    private float m_HalfTime;<br/><br/>    public delegate void TimerStarted();<br/>    public static event TimerStarted OnTimerStarted;<br/><br/>    public delegate void HalfTime();<br/>    public static event HalfTime OnHalfTime;<br/><br/>    public delegate void TimerEnded();<br/>    public static event TimerEnded OnTimerEnded;<br/><br/>    private IEnumerator m_Coroutine;<br/><br/>    IEnumerator Start()<br/>    {<br/>        m_HalfTime = m_Duration / 2;<br/><br/>        if (OnTimerStarted != null)<br/>        {<br/>            OnTimerStarted();<br/>        }<br/><br/>        yield return StartCoroutine(WaitAndPrint(1.0F));<br/><br/>        if (OnTimerEnded != null)<br/>        {<br/>            OnTimerEnded();<br/>        }<br/>    }<br/><br/>    private IEnumerator WaitAndPrint(float waitTime)<br/>    {<br/>        while (Time.time &lt; m_Duration)<br/>        {<br/>            yield return new WaitForSeconds(waitTime);<br/><br/>            Debug.Log("Seconds: " + Mathf.Round(Time.time));<br/><br/>            if (Mathf.Round(Time.time) == Mathf.Round(m_HalfTime))<br/>            {<br/>                if (OnHalfTime != null)<br/>                {<br/>                    OnHalfTime();<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see, there's not much code; it's quite simple to implement a subject with the C# event system. The most important thing is the relationship between the <kbd>delegate</kbd> and the <kbd>event</kbd> type. An <em>event</em> is a message sent by an object, but during the communication process, it doesn't know which objects will receive its message, so it needs a pointer-like mechanism that can act as an intermediate between the sender and the receivers, and that's when delegates are required. Just imagine the delegate as the one that points the event message to the right <em>observers</em>.</p>
<p style="padding-left: 60px">There's also another important detail to keep in mind. Notice that every time we call an event such as <kbd>OnTimerEnded()</kbd>, it checks for nulls on its associated event-type reference before raising the event:</p>
<pre style="padding-left: 60px">....        <br/>if (OnTimerEnded != null)<br/>{<br/>    OnTimerEnded();<br/>}</pre>
<p style="padding-left: 60px">We do this because we can't broadcast an event if no one is listening. We need at least one observer that will handle the reception of the event. This is the way the event system is implemented and manages its references.</p>
<ol start="2">
<li>Now that we have our subject ready, it's time to implement the systems that will register themselves to receive event messages from our <kbd>Timer</kbd>. In other words, we are going to implement our observers. The first one is <kbd>Buzzer</kbd>, which will notify our player that the timer has started or ended, by making a buzzing sound:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Buzzer : MonoBehaviour<br/>{<br/>    void OnEnable()<br/>    {<br/>        Timer.OnTimerStarted += PlayStartBuzzer;<br/>        Timer.OnTimerEnded += PlayEndBuzzer;<br/>    }<br/><br/>    void OnDisable()<br/>    {<br/>        Timer.OnTimerStarted -= PlayStartBuzzer;<br/>        Timer.OnTimerEnded -= PlayEndBuzzer;<br/>    }<br/><br/>    void PlayStartBuzzer()<br/>    {<br/>        Debug.Log("[BUZZER] : Play start buzzer!");<br/>    }<br/><br/>    void PlayEndBuzzer()<br/>    {<br/>        Debug.Log("[BUZZER] : Play end buzzer!");<br/>    }<br/>}</pre>
<p class="mce-root"/>
<ol start="3">
<li>The next one in our list is the <kbd>WarningLight</kbd>, which will blink when the timer reaches halftime:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class WarningLight : MonoBehaviour<br/>{<br/>    void OnEnable()<br/>    {<br/>        Timer.OnHalfTime += BlinkLight;<br/>    }<br/><br/>    void OnDisable()<br/>    {<br/>        Timer.OnHalfTime -= BlinkLight;<br/>    }<br/><br/>    void BlinkLight()<br/>    {<br/>        Debug.Log("[WARNING LIGHT] : It's half-time, blinking the warning light!");<br/>    }<br/>}</pre>
<ol start="4">
<li>As our final observer, we are going to implement <kbd>Notifier</kbd>, which has the responsibility of popping up a message when the time is up and the game is over:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Notifier : MonoBehaviour<br/>{<br/>    void OnEnable()<br/>    {<br/>        Timer.OnTimerEnded += ShowGameOverPopUp;<br/>    }<br/><br/>    void OnDisable()<br/>    {<br/>        Timer.OnTimerEnded -= ShowGameOverPopUp;<br/>    }<br/><br/>    void ShowGameOverPopUp()<br/>    {<br/>        Debug.Log("[NOTIFIER] : Show game over pop up!");<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We should notice something that all our observers have in common: they all register themselves to receive events from the <kbd>Timer</kbd> by pointing to a specific local function. This implementation means that when the <kbd>Timer</kbd> broadcasts an event, all those objects that are observing it will get one of their local methods called automatically. Therefore, a remote event can provoke a local function call of an object:</p>
<pre>// Adding the object as a observer of the OnTimerEnded event once it //get's enabled.<br/>void OnEnable() <br/>{<br/>    Timer.OnTimerEnded += ShowGameOverPopUp;<br/>}<br/><br/>// In case the object is disabled, removing it as an observer of //OnTimerEnded.<br/>void OnDisable()<br/>{<br/>    Timer.OnTimerEnded -= ShowGameOverPopUp;<br/>}</pre>
<p>Another point to keep in mind is that an event can't point to <kbd>null</kbd> references, so it's good practice to make sure an object will remove itself as an observer if it gets disabled.</p>
<p>The Observer pattern expressed through the C# event system offers a simple but powerful way of implementing an observer-and-subject relationship between objects, without explicit coupling and with a few lines of code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to implement the Observer pattern by building a timer that can trigger behaviors in our scene by having components listen to specific timed events. An important take away from this pattern is that the Observer pattern is natively implemented in Unity in the form of the C# event system.</p>
<p>In the next chapter, we will explore the State pattern. Another useful pattern for game programming, it is somewhat related to the Observer pattern.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercise</h1>
                </header>
            
            <article>
                
<p>As we have learned in this chapter, the Observer pattern was the inspiration for the C# event system. But, of course, it's not an exact implementation of this pattern. So, as an exercise, I would encourage you to re-write the timer system that we just implemented, but without using the C# event system; instead, follow the design of the Observer pattern.<br/>
<br/>
You can use the UML diagram shown at the beginning of the chapter as a starting point.</p>
<div class="packt_tip">It's common to see design patterns implemented in unorthodox ways. Often, design patterns inspire programmers to structure their code in a certain way, but rarely will you see an accurate and "by the book" implementation of a specific pattern in production code bases.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides<strong><br/></strong>(<a href="http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&amp;WT.oss_r=1&amp;item=171742">http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&amp;WT.oss_r=1&amp;item=171742</a>)<a href="http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20Elements%20of%20Reusable%20Object-Oriented%20Software"/></p>


            </article>

            
        </section>
    </body></html>