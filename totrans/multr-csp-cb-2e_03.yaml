- en: Chapter 3. Using a Thread Pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe the common techniques that are used for working
    with shared resources from multiple threads. You will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a delegate on a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting an asynchronous operation on a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A thread pool and the degree of parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a cancellation option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a wait handle and timeout with a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `BackgroundWorker` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed several ways to create threads and organize
    their cooperation. Now, let's consider another scenario where we will create many
    asynchronous operations that take very little time to complete. As we discussed
    in the *Introduction* section of [Chapter 1](ch01.html "Chapter 1. Threading Basics"),
    *Threading Basics*, creating a thread is an expensive operation, so doing this
    for each short-lived, asynchronous operation will include a significant overhead
    expense.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this problem, there is a common approach called **pooling** that
    can be successfully applied to any situation when we need many short-lived, expensive
    resources. We allocate a certain amount of these resources in advance and organize
    them into a resource pool. Each time we need a new resource, we just take it from
    the pool, instead of creating a new one, and return it to the pool after the resource
    is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: The **.NET thread pool** is an implementation of this concept. It is accessible
    via the `System.Threading.ThreadPool` type. A thread pool is managed by the .NET
    **Common** **Language Runtime** (**CLR**), which means that there is one instance
    of a thread pool per CLR. The `ThreadPool` type has a `QueueUserWorkItem` static
    method that accepts a **delegate**, representing a user-defined, asynchronous
    operation. After this method is called, this delegate goes to the internal queue.
    Then, if there are no threads inside the pool, it creates a new **worker thread**
    and puts the first delegate in the queue on it.
  prefs: []
  type: TYPE_NORMAL
- en: If we put new operations on a thread pool, after the previous operations are
    completed, it is possible to reuse this one thread to execute these operations.
    However, if we put new operations faster, the thread pool will create more threads
    to serve these operations. There is a limit to prevent creating too many threads,
    and in that case, new operations wait in the queue until the worker threads in
    the pool become free to serve them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to keep operations on a thread pool shortlived! Do not
    put long-running operations on a thread pool or block worker threads. This will
    lead to all worker threads becoming busy, and they will no longer be able to serve
    user operations. This, in turn, will lead to performance problems and errors that
    are very hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: When we stop putting new operations on a thread pool, it will eventually remove
    threads that are no longer needed after being idle for some time. This will free
    up any operating system resources that are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to emphasize once again that a thread pool is intended to execute
    short-running operations. Using a thread pool lets us save operating system resources
    at the cost of reducing the degree of parallelism. We use fewer threads, but execute
    asynchronous operations more slowly than usual, batching them by the number of
    worker threads available. This makes sense if operations complete rapidly, but
    this will degrade the performance if we execute many long-running, compute-bound
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to be very careful of is using a thread pool in ASP.NET
    applications. The ASP.NET infrastructure uses a thread pool itself, and if you
    waste all worker threads from a thread pool, a web server will no longer be able
    to serve incoming requests. It is recommended that you use only input/output-bound
    asynchronous operations in ASP.NET because they use different mechanics called
    **I/O threads**. We will discuss I/O threads in [Chapter 9](ch09.html "Chapter 9. Using
    Asynchronous I/O"), *Using Asynchronous I/O*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that worker threads in a thread pool are background threads. This means
    that when all of the threads in the foreground (including the main application
    thread) are complete, then all the background threads will be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn to use a thread pool to execute asynchronous
    operations. We will cover different ways to put an operation on a thread pool
    and how to cancel an operation and prevent it from running for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a delegate on a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to execute a delegate asynchronously on a thread
    pool. In addition, we will discuss an approach called the **Asynchronous Programming**
    **Model** (**APM**), which was historically the first asynchronous programming
    pattern in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to invoke a delegate on a thread pool, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates a thread in the old-fashioned way and then
    starts it and waits for its completion. Since a thread constructor accepts only
    a method that does not return any result, we use a **lambda expression** to wrap
    up a call to the `Test` method. We make sure that this thread is not from the
    thread pool by printing out the `Thread.CurrentThread.IsThreadPoolThread` property
    value. We also print out a managed thread ID to identify a thread on which this
    code was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a delegate and run it by calling the `BeginInvoke` method. This
    method accepts a callback that will be called after the asynchronous operation
    is complete and a user-defined state to pass into the callback. This state is
    usually used to distinguish one asynchronous call from another. As a result, we
    get a `result` object that implements the `IAsyncResult` interface. The `BeginInvoke`
    method returns the result immediately, allowing us to continue with any work while
    the asynchronous operation is being executed on a worker thread of the thread
    pool. When we need the result of an asynchronous operation, we use the `result`
    object returned from the `BeginInvoke` method call. We can poll on it using the
    `IsCompleted` result property, but in this case, we use the `AsyncWaitHandle`
    result property to wait on it until the operation is complete. After this is done,
    to get a result from it, we call the `EndInvoke` method on a delegate, passing
    the delegate arguments and our `IAsyncResult` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, using `AsyncWaitHandle` is not necessary. If we comment out `r.AsyncWaitHandle.WaitOne`,
    the code will still run successfully because the `EndInvoke` method actually waits
    for the asynchronous operation to complete. It is always important to call `EndInvoke`
    (or `EndOperationName` for other asynchronous APIs) because it throws any unhandled
    exceptions back to the calling thread. Always call both the `Begin` and `End`
    methods when using this kind of asynchronous API.
  prefs: []
  type: TYPE_NORMAL
- en: When the operation completes, a callback passed to the `BeginInvoke` method
    will be posted on a thread pool, more specifically, a worker thread. If we comment
    out the `Thread.Sleep` method call at the end of the `Main` method definition,
    the callback will not be executed. This is because when the main thread is completed,
    all the background threads will be stopped, including this callback. It is possible
    that both asynchronous calls to a delegate and a callback will be served by the
    same worker thread, which is easy to see by a worker thread ID.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of using the `BeginOperationName`/`EndOperationName` method and
    the `IAsyncResult` object in .NET is called the Asynchronous Programming Model
    or the APM pattern, and such method pairs are called asynchronous methods. This
    pattern is still used in various .NET class library APIs, but in modern programming,
    it is preferable to use the **Task** **Parallel Library** (**TPL**) to organize
    an asynchronous API. We will cover this topic in [Chapter 4](ch04.html "Chapter 4. Using
    the Task Parallel Library"), *Using the Task Parallel Library*.
  prefs: []
  type: TYPE_NORMAL
- en: Posting an asynchronous operation on a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to put an asynchronous operation on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to post an asynchronous operation on a thread pool, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we define the `AsyncOperation` method that accepts a single parameter
    of the `object` type. Then, we post this method on a thread pool using the `QueueUserWorkItem`
    method. Then, we post this method once again, but this time, we pass a `state`
    object to this method call. This object will be passed to the `AsynchronousOperation`
    method as the `state` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Making a thread sleep for 1 second after these operations allows the thread
    pool to reuse threads for new operations. If you comment on these `Thread.Sleep`
    calls, most certainly the thread IDs will be different in all cases. If not, probably
    the first two threads will be reused to run the following two operations.
  prefs: []
  type: TYPE_NORMAL
- en: First, we post a lambda expression to a thread pool. Nothing special here; instead
    of defining a separate method, we use the lambda expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, instead of passing the state of a lambda expression, we use **closure**
    mechanics. This gives us more flexibility and allows us to provide more than one
    object to the asynchronous operation and static typing for those objects. So,
    the previous mechanism of passing an object into a method callback is really redundant
    and obsolete. There is no need to use it now when we have closures in C#.
  prefs: []
  type: TYPE_NORMAL
- en: A thread pool and the degree of parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how a thread pool works with many asynchronous operations
    and how it is different from creating many separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found in `BookSamples\Chapter3\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how a thread pool works with many asynchronous operations and how
    it is different from creating many separate threads, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, we create many different threads and run an operation
    on each one of them. This operation prints out a thread ID and blocks a thread
    for 100 milliseconds. As a result, we create 500 threads running all these operations
    in parallel. The total time on my machine is about 300 milliseconds, but we consume
    many operating system resources for all these threads.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we follow the same workflow, but instead of creating a thread for each
    operation, we post them on a thread pool. After this, the thread pool starts to
    serve these operations; it begins to create more threads near the end; however,
    it still takes much more time, about 12 seconds on my machine. We save memory
    and threads for operating system use but pay for it with application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a cancellation option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows an example on how to cancel an asynchronous operation on a
    thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found in `BookSamples\Chapter3\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to implement a cancellation option on a thread, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we introduce the `CancellationTokenSource` and `CancellationToken` constructs.
    They appeared in .NET 4.0 and now are the de facto standard to implement asynchronous
    operation cancellation processes. Since the thread pool has existed for a long
    time, it has no special API for cancellation tokens; however, they can still be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we see three ways to organize a cancellation process. The first
    is just to poll and check the `CancellationToken.IsCancellationRequested` property.
    If it is set to `true`, this means that our operation is being cancelled and we
    must abandon the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The second way is to throw an `OperationCancelledException` exception. This
    allows us to control the cancellation process not from inside the operation, which
    is being canceled, but from the code on the outside.
  prefs: []
  type: TYPE_NORMAL
- en: The last option is to register a **callback** that will be called on a thread
    pool when an operation is canceled. This will allow us to chain cancellation logic
    into another asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a wait handle and timeout with a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to implement a timeout for thread pool operations
    and how to wait properly on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to implement a timeout and how to wait properly on a thread pool,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A thread pool has another useful method: `ThreadPool.RegisterWaitForSingleObject`.
    This method allows us to queue a callback on a thread pool, and this callback
    will be executed when the provided wait handle is signaled or a timeout has occurred.
    This allows us to implement a timeout for thread pool operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we register the timeout handling asynchronous operation. It will be
    called when one of the following events take place: on receiving a signal from
    the `ManualResetEvent` object, which is set by the worker operation when it is
    completed successfully, or when a timeout has occurred before the first operation
    is completed. If this happens, we use `CancellationToken` to cancel the first
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we queue a long-running worker operation on a thread pool. It runs for
    6 seconds and then sets a `ManualResetEvent` signaling construct, in case it completes
    successfully. In other case, if the cancellation is requested, the operation is
    just abandoned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we provide a 5-second timeout for the operation, that would not
    be enough. This is because the operation takes 6 seconds to complete, and we'd
    need to cancel this operation. So, if we provide a 7-second timeout, which is
    acceptable, the operation completes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is very useful when you have a large number of threads that must wait in
    the `blocked` state for some multithreaded event construct to signal. Instead
    of blocking all these threads, we are able to use the thread pool infrastructure.
    It will allow us to free up these threads until the event is set. This is a very
    important scenario for server applications, which require scalability and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to use a `System.Threading.Timer` object to create
    periodically-called asynchronous operations on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to create periodically-called asynchronous operations on a thread
    pool, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a new `Timer` instance. The first parameter is a lambda expression
    that will be executed on a thread pool. We call the `TimerOperation` method, providing
    it with a start date. We do not use the user `state` object, so the second parameter
    is null; then, we specify when are we going to run `TimerOperation` for the first
    time and what will be the period between calls. So, the first value actually means
    that we start the first operation in 1 second, and then, we run each of them in
    2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we wait for 6 seconds and change our timer. We start `TimerOperation`
    in a second after calling the `_timer.Change` method, and then run each of them
    for 4 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A timer could be more complex than this!**'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use a timer in more complicated ways. For instance, we can
    run the timer operation only once, by providing a timer period parameter with
    the `Timeout.Infinite` value. Then, inside the timer asynchronous operation, we
    are able to set the next time when the timer operation will be executed, depending
    on some custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we wait for the *Enter* key to be pressed and to finish the application.
    While it is running, we can see the time passed since the program started.
  prefs: []
  type: TYPE_NORMAL
- en: Using the BackgroundWorker component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes another approach to asynchronous programming via an example
    of a `BackgroundWorker` component. With the help of this object, we are able to
    organize our asynchronous code as a set of events and event handlers. You will
    learn how to use this component for asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2015\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter3\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to use the `BackgroundWorker` component, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program starts, we create an instance of a `BackgroundWorker` component.
    We explicitly state that we want our background worker to support cancellation
    and notifications on the operation's progress.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is where the most interesting part comes into play. Instead of manipulating
    with a thread pool and delegates, we use another C# idiom called **events**. An
    event represents a *source* of notifications and a number of *subscribers* ready
    to react when a notification arrives. In our case, we state that we will subscribe
    for three events, and when they occur, we call the corresponding **event handlers**.
    These are methods with a specially defined signature that will be called when
    an event notifies its subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, instead of organizing an asynchronous API in a pair of `Begin`/`End`
    methods, it is possible to just start an asynchronous operation and then subscribe
    to different events that could happen while this operation is executed. This approach
    is called an **Event-based** **Asynchronous Pattern** (**EAP**). It was historically
    the second attempt to structure asynchronous programs, and now, it is recommended
    to use TPL instead, which will be described in [Chapter 4](ch04.html "Chapter 4. Using
    the Task Parallel Library"), *Using the Task Parallel Library*.
  prefs: []
  type: TYPE_NORMAL
- en: So, we subscribed to three events. The first of them is the `DoWork` event.
    A handler of this event will be called when a background worker object starts
    an asynchronous operation with the `RunWorkerAsync` method. The event handler
    will be executed on a thread pool, and this is the main operating point where
    work is canceled if cancellation is requested and where we provide information
    on the progress of the operation. At last, when we get the result, we set it to
    event arguments, and then, the `RunWorkerCompleted` event handler is called. Inside
    this method, we find out whether our operation has succeeded, there were some
    errors, or it was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, a `BackgroundWorker` component is actually intended to be used
    in **Windows Forms** **Applications** (**WPF**). Its implementation makes working
    with UI controls possible from a background worker's event handler code directly,
    which is very comfortable as compared to the interaction of worker threads in
    a thread pool with UI controls.
  prefs: []
  type: TYPE_NORMAL
