<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-156"><a id="_idTextAnchor165"/>10</h1>
<h1 id="_idParaDest-157"><a id="_idTextAnchor166"/>Working with Remote Data</h1>
<p>So far, we’ve dug deep into MVVM and .NET MAUI, covering everything from the basics of the MVVM design, from data binding and Dependency Injection to navigation and handling user input. But there’s one big piece of the puzzle we haven’t tackled yet: getting data from the internet.</p>
<p>It’s hard to imagine an app these days that doesn’t talk to an online service to grab fresh data. Adding backend communications also means we need to tackle some architectural challenges such as maintaining separation of concerns, building your app with maintainability in mind, and so on.</p>
<p>Here’s what we’ll dive into in this chapter:</p>
<ul>
<li>Revisiting the model architecture</li>
<li>API communication with Refit</li>
<li>API communication from ViewModels</li>
</ul>
<p>By the end of this chapter, our <em class="italic">Recipes!</em> app will be more than just a standalone thing. It’ll communicate with a backend service to fetch fresh data and push updates. We’re going to equip it with the essential tools and skills needed for solid MVVM apps.</p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor167"/>Technical requirements</h1>
<p>In this chapter, we update the general architecture of the <em class="italic">Recipes!</em> app to better facilitate communication with remote APIs. To ensure you’re on the same page, all resources and code snippets are available on GitHub: <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10</a>. If you wish to code along, start with the code in the <code>Start</code> folder, which has been refactored to serve as the foundation for this chapter. Upon completion, you can compare your work with the <code>Finish</code> folder to see the finalized version.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor168"/>Revisiting the model architecture</h1>
<p>In our journey so far, our model has been straightforward. We simply used services that read local JSON <a id="_idIndexMarker667"/>files and fed <strong class="bold">Data Transfer Objects (DTOs)</strong> directly to our ViewModels. But as we introduce remote data, this simplistic model won’t suffice.</p>
<p>A straightforward approach would be to make an API call directly within our service and pass the resulting DTOs to our ViewModels. However, leaning on the principle of SoC, I believe services <a id="_idIndexMarker668"/>shouldn’t be making API calls. Moreover, using API-specific DTOs directly within our ViewModels is a slippery slope. It tightly couples our application with the external API, which can lead to maintenance nightmares, especially if the API changes often or isn’t under our control.</p>
<p>Instead, I advocate <a id="_idIndexMarker669"/>for mapping these DTOs to <strong class="bold">Plain Old CLR Objects (POCOs)</strong>, or entities or domain models – whatever you prefer to name them. The core idea? Work with types we own and control.</p>
<p class="callout-heading">Tip</p>
<p class="callout">By keeping the interaction points between our app and the API to a minimum, our code will be less impacted by potential API changes, enhancing maintainability.</p>
<p>To realize this, we’ll introduce <a id="_idIndexMarker670"/>the concept of <strong class="bold">repositories</strong> in our architecture. These repositories will interface with the API (or any data source), fetch the DTOs, map them to our domain models, and then supply them to our services and ViewModels. The following diagram captures this envisioned architecture:</p>
<div><div><img alt="Figure 10.1: Architectural overview" height="553" src="img/B20941_10_01.jpg" width="1317"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: Architectural overview</p>
<p>Now, one might ask: is this really needed? Can’t we just directly call an API from a service while using DTOs in our ViewModels? The answer is no, it is not needed; you can perfectly well <a id="_idIndexMarker671"/>call an API from a service if you want. This can definitely work for smaller “dumb” apps where all the business logic is done on the server. But as we scale or tackle more complex scenarios, thoughtful architecture becomes crucial for several reasons:</p>
<ul>
<li><strong class="bold">Separation of concerns</strong>: By introducing repositories, we distinctly segregate the roles within <a id="_idIndexMarker672"/>our system. Repositories are primarily concerned with fetching data from a data source – be it an API or another data store – and then translating it into a format our services can readily use. Positioning the repository layer outside of the core project not only emphasizes its distinct responsibility but also ensures that changes or expansions to data sources don’t interfere with the core business logic. This separation enhances the system’s adaptability and maintainability. It becomes clear that the repository’s sole purpose is data retrieval, acting as a thin layer that fetches data from various sources and feeds it to the core services. With repositories acting as intermediaries, changes to the data source or alterations to the data structure are centralized, streamlining modifications.</li>
<li><strong class="bold">Improved testability</strong>: By <a id="_idIndexMarker673"/>introducing a repository layer, we enhance our app’s testability. With repositories in place, we can effortlessly mock the data layer in our tests. This abstraction ensures our tests focus on the logic within our services, free from dependencies on external data sources. In <a href="B20941_13.xhtml#_idTextAnchor223"><em class="italic">Chapter 13</em></a>, <em class="italic">Unit Testing</em>, we will be looking at this in much more detail.</li>
<li><strong class="bold">Augmented services</strong>: The service layer remains free to introduce additional features <a id="_idIndexMarker674"/>such as caching, business logic, or data aggregation from multiple repositories. This decoupling means services aren’t tied directly to specific data sources and can evolve independently.</li>
</ul>
<p>Before we dive deep into the concepts of repositories and other details, let’s explore the solution found in the <code>Start</code> folder of this chapter’s accompanying code base to understand the changes that have been made.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor169"/>Updates to the codebase</h2>
<p>As we journey deeper into creating a robust MVVM architecture, it’s crucial to familiarize <a id="_idIndexMarker675"/>ourselves with changes and additions that <a id="_idIndexMarker676"/>have been made to the code base. If you take a look at the <code>Start</code> folder of the accompanying repository for this chapter, you’ll notice some changes. Here are notable updates:</p>
<ul>
<li>A <code>Recipes.Web.Api</code> API project has been added. At its core, it still reads from local JSON files, reminiscent of our earlier services. The implementation of the API is pretty bare-bones and only for demo purposes.</li>
<li>The new <code>Recipes.Shared</code> project holds the DTOs that the API returns and accepts.</li>
<li>In the <code>Features</code> folder of the <code>Recipes.Client.Core</code> project, we’ve added new POCO or domain entities. These are reflections of our DTOs but designed to be entirely under our control, ensuring a smoother integration with the rest of our app’s infrastructure.</li>
<li>A new <code>Recipes.Client.Repositories</code> project has been created. This project will hold the implementations of the repositories that we will be creating. The idea is to keep them separate from the <code>Recipes.Client.Core</code> project so that the core project is completely isolated from the API and its DTOs. This project also contains mappers that map the DTOs returned by the API to POCO entities that we will be using throughout the app.</li>
<li>The services <a id="_idIndexMarker677"/>and ViewModels no longer depend <a id="_idIndexMarker678"/>upon DTOs. Now, they interact solely with our own POCOs, ensuring a clean and maintainable architecture.</li>
<li>The <code>ratings.json</code> and <code>recipedetails.json</code> files have been removed from the <code>Recipes.Mobile</code> project as we are going to fetch our data from the API.</li>
<li>The registrations of <code>IRecipeService</code> and <code>IRatingsService</code> in the <code>MauiProgram</code> class have been updated to the following:<pre class="source-code">
builder.Services.AddTransient&lt;IRatingsService,
  RatingsService&gt;();
builder.Services.AddTransient&lt;IRecipeService,
  RecipeService&gt;();</pre></li> </ul>
<p>These changes set the stage for the introduction of repositories and interactions with the API.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor170"/>Always return a result</h2>
<p>In conventional coding, exceptions are commonly used to indicate failure. While they’re useful for <em class="italic">exceptional</em> cases, they might not be the best choice for regular, expected error scenarios. Using exceptions for expected errors can clutter the code and make it harder to follow.</p>
<p>That’s why I <a id="_idIndexMarker679"/>tend to use a <code>Result&lt;TSuccess&gt;</code> object to handle such cases. This object acts as a wrapper around the <a id="_idIndexMarker680"/>data we expect on success (<code>TSuccess</code>) and provides fields for an error code, error data, and an <code>Exception</code> error in the case of failure. It’s a very simple and convenient wrapper, as you can see here:</p>
<pre class="source-code">
public sealed class Result&lt;TSuccess&gt;
{
    ...
    public bool IsSuccess { get; }
    public TSuccess? Data { get; }
    public string? ErrorCode { get; }
    public string? ErrorData { get; }
    public Exception? Exception { get; }
    private Result(TSuccess? data,
        string? errorCode, string? errorData,
        Exception? exception, bool isSuccess)
    {
        Data = data;
        ErrorCode = errorCode;
        ErrorData = errorData;
        Exception = exception;
        IsSuccess = isSuccess;
    }
}</pre> <p>As the <a id="_idIndexMarker681"/>following code block shows, this class also <a id="_idIndexMarker682"/>contains some static methods that instantiate a <code>Success</code> or <code>Fail</code> <code>Result</code> object, facilitating the usage of this object:</p>
<pre class="source-code">
public static Result&lt;TSuccess&gt; Success(TSuccess data)
    =&gt; new Result&lt;TSuccess&gt;(data, null, null, null, true);
public static Result&lt;TSuccess&gt; Success()
    =&gt; new Result&lt;TSuccess&gt;(default, null, null,
        null, true);
public static Result&lt;TSuccess&gt; Fail(string errorCode,
  string? errorData = null, Exception? exception = null)
    =&gt; new Result&lt;TSuccess&gt;(default, errorCode,
        errorData, exception, false);
public static Result&lt;TSuccess&gt; Fail(Exception exception)
    =&gt; new Result&lt;TSuccess&gt;(default, nameof(exception),
        exception.Message, exception, false);</pre> <p>By using <a id="_idIndexMarker683"/>the <code>Result</code> object, we can easily distinguish between two types of errors:</p>
<ul>
<li><strong class="bold">Unexpected errors</strong>: These <a id="_idIndexMarker684"/>are real “exceptions” that we <a id="_idIndexMarker685"/>can’t predict and don’t know how to handle. They are still best managed by throwing exceptions.</li>
<li><code>Result</code> object.</li>
</ul>
<p>For example, a mobile <a id="_idIndexMarker688"/>app unable to retrieve data isn’t an exceptional case; it’s a scenario we should plan for. The <code>Result</code> object allows us to handle such situations gracefully without resorting to exceptions. It offers a richer context than simply returning <code>null</code> or <code>false</code>, letting us understand why an operation failed. This even works when we talk to an API that we don’t control: this is just a simple wrapper around an object.</p>
<p>The <code>Result</code> object brings clarity and consistency to our code. It removes uncertainties such as “<em class="italic">Can this method throw an exception? If so, what type? Is it the same exception type thrown in </em><em class="italic">similar scenarios?</em>”</p>
<p class="callout-heading">Errors versus exceptions</p>
<p class="callout">By segregating expected errors from true exceptions, we make the code more readable and maintainable. It lets exceptions be what they should be: indicators of critical, unexpected failures.</p>
<p>As we extend our <em class="italic">Recipes!</em> app to communicate with a backend API, the chances for various types of errors increase significantly. To prepare for this complexity, we’ll be wrapping the <a id="_idIndexMarker689"/>return values of our services and <a id="_idIndexMarker690"/>repositories in a <code>Result</code> object. This approach not only helps us deal effectively with expected errors but also brings a level of standardization and clarity to our error-handling strategy. Let’s see how this <code>Result</code> object brings elegance and robustness to the ViewModels.</p>
<h3>Putting the Result object to work</h3>
<p>The following <a id="_idIndexMarker691"/>code snippet shows how the <code>Result</code> object can gracefully handle both successful and unsuccessful outcomes in the <code>RecipeRatingsDetailViewModel</code>:</p>
<pre class="source-code">
private async Task LoadData(RecipeDetail recipe)
{
...
    var loadRatings = await
        ratingsService.LoadRatings(recipe.Id);
    if(loadRatings.IsSuccess)
    {
        GroupedReviews = loadRatings.Data
        ...
        .ToList();
    }
    else
    {
        var shouldRetry = await dialogService.AskYesNo(
            "Failed to load", "Retry?");
        if (shouldRetry)
            await LoadData(recipe);
        else
            await navigationService.GoBack();
    }
}</pre> <p>This example underscores the elegance and robustness the <code>Result</code> object brings to our ViewModels. By using the <code>IsSuccess</code> property, we can immediately determine the success <a id="_idIndexMarker692"/>of the operation. If it’s successful, we proceed to work with the data we’ve received. If not, we offer the user a chance to retry or go back. Additionally, the <code>Result</code> object also contains valuable error information in <code>ErrorMessage</code>, <code>ErrorCode</code>, and <code>Exception</code>, allowing us to tailor our error-handling strategy, such as displaying specific error messages to the user. This approach removes the necessity of adding exception-handling sections across our ViewModels, leading to a cleaner, easier-to-read, and more maintainable code structure.</p>
<p>If we would like <a id="_idIndexMarker693"/>to leverage C# <strong class="bold">pattern matching</strong> abilities, we could make the preceding code even more elegant, like so:</p>
<pre class="source-code">
if (loadRatings is { IsSuccess: true, Data: var ratings })
{
    GroupedReviews = ratings
    ...
    .ToList();
}
else
{
    ...
}</pre> <p>By using <a id="_idIndexMarker694"/>pattern matching, we could check for the <code>Result</code> object’s <code>IsSuccess</code> property to be <code>true</code>, and in the same statement, assign the <code>Result</code> object’s <code>Data</code> property to the <code>ratings</code> variable. This allows us to access the <code>Data</code> property more easily through the <code>ratings</code> variable inside that <code>if</code> block. Now that we have a good understanding of the <code>Result</code> object, we can start adding repositories to our architecture.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor171"/>Adding repository interfaces</h2>
<p>Let’s start <a id="_idIndexMarker695"/>adding repositories, the pieces of <a id="_idIndexMarker696"/>code that will directly interact with our API:</p>
<ol>
<li>In the <code>Recipes.Client.Core</code> project, add an interface called <code>IRecipeRepository</code> to the <code>Features/Recipes</code> folder. Here’s what this interface looks like:<pre class="source-code">
public interface IRecipeRepository
{
    Task&lt;Result&lt;LoadRecipesResponse&gt;&gt; LoadRecipes(
        int pageSize = 7, int page = 0);
    Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(string id);
}</pre><p class="list-inset">This interface defines the contract that any class needs to implement in order to be able to fetch recipes from a data source. There are two methods defined in this interface: <code>LoadRecipes</code> and <code>LoadRecipe</code>. The first method returns a <code>LoadRecipesResponse</code> object, which is a response containing a paged collection of recipes. The second method returns a <code>RecipeDetail</code> object for a recipe identified by its ID. The return value of both of these methods is wrapped in a <code>Result</code> object, allowing us to deal with the fact that the requested data (temporarily) couldn’t be retrieved, for example.</p></li> <li>Head over <a id="_idIndexMarker697"/>to the <code>RecipeService</code> class and add a parameter of type <code>IRecipeRepository</code> to its <a id="_idIndexMarker698"/>constructor. A field is also added to keep a reference to this instance, as shown in the following snippet:<pre class="source-code">
public class RecipeService : IRecipeService
{
    readonly IRecipeRepository _recipeRepository;
...
    public RecipeService(
        IRecipeRepository recipeRepository)
    {
        _recipeRepository = recipeRepository;
    }
}</pre></li> <li>As there isn’t much “business logic” going on in the <code>RecipeService</code> class, its methods should just call the injected repository’s methods and return their result. Have a look:<pre class="source-code">
public Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(
    string id) =&gt; <strong class="bold">_recipeRepository.LoadRecipe(id);</strong>
public Task&lt;Result&lt;LoadRecipesResponse&gt;&gt; LoadRecipes(
    int pageSize = 7, int page = 0)
    =&gt; <strong class="bold">_recipeRepository.LoadRecipes(pageSize, page);</strong></pre></li> </ol>
<p>We can add the same treatment to the <code>RatingsService</code> class: create a repository interface, add it as a dependency to the service, and call the interface’s methods from the <code>RatingsService</code> class’s methods. We’ll proceed as follows:</p>
<ol>
<li>Let’s create an <code>IRatingsRepository</code> interface for the <code>Features/Ratings</code> folder and add the following definitions to the newly created interface:<pre class="source-code">
Task&lt;Result&lt;IReadOnlyCollection&lt;Rating&gt;&gt;&gt;
    GetRatings(string recipeId);
Task&lt;Result&lt;RatingsSummary&gt;&gt; GetRatingsSummary(
    string recipeId);</pre><p class="list-inset">There are <a id="_idIndexMarker699"/>two methods defined in <a id="_idIndexMarker700"/>this interface: <code>GetRatings</code> and <code>GetRatingsSummary</code>. The first method returns a collection of <code>Rating</code> objects associated with the specified recipe ID. The second method returns a <code>RatingsSummary</code> for a recipe identified by its ID. As noted earlier, the return values are wrapped in a <code>Result</code> object.</p></li> <li>Next, we add <code>IRatingsRepository</code> as a dependency of the <code>RatingsService</code> class, by defining it as a constructor parameter:<pre class="source-code">
public class RatingsService : IRatingsService
{
    readonly IRatingsRepository _ratingsRepository;
...
    public RatingsService(
        IRatingsRepository ratingsRepository)
    {
        _ratingsRepository = ratingsRepository;
    }
}</pre></li> <li>Finally, as the <code>RatingsService</code> class doesn’t contain any additional logic, this class will just call the repository’s methods, as you can see here:<pre class="source-code">
public Task&lt;Result&lt;RatingsSummary&gt;&gt;
    LoadRatingsSummary(string recipeId)
    =&gt; <strong class="bold">_ratingsRepository.GetRatingsSummary(recipeId);</strong>
public Task&lt;&lt;Result&lt;IReadOnlyCollection&lt;Rating&gt;&gt;&gt;
    LoadRatings(string recipeId)
    =&gt; <strong class="bold">_ratingsRepository.GetRatings(recipeId);</strong></pre></li> </ol>
<p>That leaves <a id="_idIndexMarker701"/>us with one service left to <a id="_idIndexMarker702"/>update: <code>FavoritesService</code>. Unlike the previous services that we’ve been updating, <code>FavoritesService</code> does contain some additional logic. But let’s first take a look at what the <code>IFavoritesRepository</code> interface looks like:</p>
<pre class="source-code">
public interface IFavoritesRepository
{
    Task&lt;Result&lt;IReadonlyCollection&lt;string&gt;&gt;&gt;
        LoadFavorites(string userId);
    Task&lt;Result&lt;Nothing&gt;&gt; Add(string userId, string id);
    Task&lt;Result&lt;Nothing&gt;&gt; Remove(string userId, string id);
}</pre> <p>This interface defines three methods: <code>LoadFavorites</code>, <code>Add</code>, and <code>Remove</code>. Since our favorites are stored on a centralized server, it’s essential to pass the user’s identifier (or <code>userId</code>) to the API. This ensures that favorites fetched, added, or removed are specific to that user. Neither the <code>Add</code> method nor the <code>Remove</code> method has an intrinsic return value. To be consistent with the rest of our APIs, we want to return a value wrapped in a <code>Result</code> object. That’s why a custom <code>Nothing</code> type is returned. This is just an empty struct, as you can see here:</p>
<pre class="source-code">
public struct Nothing
{
}</pre> <p>Let’s update the <code>FavoritesService</code> so that it leverages the <code>IFavoritesRepository</code> interface:</p>
<ol>
<li>Go ahead <a id="_idIndexMarker703"/>and add the <code>IFavoritesRepository</code> interface to the <code>Features/Favorites</code> folder.</li>
<li>Update <code>FavoritesService</code> so that its constructor accepts a parameter of type <code>IFavoritesRepository</code>:<pre class="source-code">
public class FavoritesService : IFavoritesService
{
    readonly IFavoritesRepository
        _favoritesRepository;
...
    public FavoritesService(
        IFavoritesRepository favoritesRepository)
    {
        _favoritesRepository = favoritesRepository;
    }
}</pre></li> <li><code>FavoritesService</code> keeps a list of the user’s favorites in memory. This in-memory <a id="_idIndexMarker704"/>list can easily be used in the <code>IsFavorite</code> method to rapidly check whether the given <code>recipeId</code> exists in the list. Here’s how we can load this list in memory:<pre class="source-code">
List&lt;string&gt; favorites = null;
private async ValueTask LoadList()
{
    if (favorites is null)
    {
        var loadResult = await _favoritesRepository
            .LoadFavorites(GetCurrentUserId());
        if (loadResult.IsSuccess)
        {
            favorites = loadResult.Data.ToList();
        }
    }
}
//Dummy implementation,
//could be retrieved via injected service
private string GetCurrentUserId()
    =&gt; "3";</pre><p class="list-inset">The <code>LoadList</code> method calls the <code>LoadFavorites</code> method on the <code>IFavoritesRepository</code> when the favorites list is <code>null</code>. The “dummy” <code>GetCurrentUserId</code> method provides a fake identifier for the given user of the app. In a <a id="_idIndexMarker705"/>real-life scenario, this could be retrieved from an injected service.</p></li> <li>As said <a id="_idIndexMarker706"/>before, this in-memory list facilitates the implementation of the <code>IsFavorite</code> method, as shown in the next code block:<pre class="source-code">
public async Task&lt;bool&gt; IsFavorite(string id)
{
    await LoadList();
    return favorites is not null
        &amp;&amp; favorites.Contains(id);
}</pre><p class="list-inset">This method calls the <code>LoadList</code> method, which will retrieve the favorites from the API if the in-memory list is <code>null</code>. When favorites have been loaded, we can check whether the list contains the given ID.</p></li> </ol>
<p>In contrast <a id="_idIndexMarker707"/>to the earlier services we discussed, where each method simply invoked a corresponding method in the injected <a id="_idIndexMarker708"/>repository, things are slightly more complex here due to the presence of an in-memory list. Also, because both the <code>Add</code> and <code>Remove</code> methods send a <code>FavoriteUpdateMessage</code> instance, they require some extra logic for implementation. Here’s how it’s done:</p>
<ol>
<li>The first thing to do in <code>FavoritesService</code>’s <code>Add</code> method is to call the repository’s <code>Add</code> method, passing in the (fake) <code>userId</code> value, as shown here:<pre class="source-code">
public async Task&lt;Result&lt;Nothing&gt;&gt; Add(string id)
{
    var result = await _favoritesRepository
        .Add(GetCurrentUserId(), id);
}</pre></li> <li>The <code>Add</code> method of the <code>IFavoritesRepository</code> returns a <code>Nothing</code> object wrapped in a <code>Result</code> object. Thanks to the <code>Result</code> object, we can check if the API call was successful or not. If that’s the case, we add the ID of the favorited recipe to the in-memory list of favorites and send the <code>FavoriteUpdateMessage</code> as shown here:<pre class="source-code">
if (result.IsSuccess)
{
    if (favorites is not null
        &amp;&amp; !favorites.Contains(id))
        favorites.Add(id);
    WeakReferenceMessenger.Default
        .Send(new FavoriteUpdateMessage(id, true));
}
return result;</pre></li> <li>The <code>Remove</code> method <a id="_idIndexMarker709"/>is very <a id="_idIndexMarker710"/>similar:<pre class="source-code">
public async Task&lt;Result&lt;Nothing&gt;&gt; Remove(string id)
{
    var result = await _favoritesRepository
        .Remove(GetCurrentUserId(), id);
    if (result.IsSuccess)
    {
        if (favorites is not null
            &amp;&amp; favorites.Contains(id))
            favorites.Remove(id);
        WeakReferenceMessenger.Default
            .Send(
            new FavoriteUpdateMessage(id, false));
    }
    return result;
}</pre></li> </ol>
<p>With all of our code in place, it’s time to add implementations for these repositories and make sure they get registered in the DI container.</p>
<h3>Adding and registering repository implementations</h3>
<p>There’s a dedicated project in which we can place the implementations of the repository interfaces. As <a id="_idIndexMarker711"/>these repositories <a id="_idIndexMarker712"/>will communicate to our API, I tend to use <code>ApiGateway</code> as the naming. Personally, I think this name perfectly illustrates its functionality. In the <code>Recipes.Client.Repositories</code> project, we can add three classes: <code>FavoritesApiGateway</code>, <code>RatingsApiGateway</code>, and <code>RecipeApiGateway</code>. These classes should implement the <code>IFavoritesRepository</code>, <code>IRatingsRepository</code>, and <code>IRecipeRepository</code> interfaces respectively. In the next section, we will be discussing how to effectively activate API communication using Refit.</p>
<p>Now, let’s turn our attention to registering these repositories in the DI container. Instead of handling each registration in the <code>MauiProgram</code> class, we’ll delegate this task entirely to the code in the <code>Recipes.Client.Repositories</code> project:</p>
<ol>
<li>Add the <code>Microsoft.Extensions.DependencyInjection.Abstractions</code> NuGet package to the <code>Recipes.Client.Repositories</code> project.</li>
<li>In the <code>Recipes.Client.Repositories</code> project, add a <code>ServiceCollectionExtension</code> class. Here’s what this static class looks like:<pre class="source-code">
public static class ServiceCollectionExtension
{
    public static IServiceCollection
        RegisterRepositories(
        this IServiceCollection services)
    {
        services.AddTransient&lt;IRatingsRepository,
            RatingsApiGateway&gt;();
        services.AddTransient&lt;IRecipeRepository,
            RecipeApiGateway&gt;();
        services.AddTransient&lt;IFavoritesRepository,
            FavoritesApiGateway&gt;();
        return services;
    }
}</pre><p class="list-inset">This <a id="_idIndexMarker713"/>class contains <a id="_idIndexMarker714"/>one method: <code>RegisterRepositories</code>. This method is an extension method that extends the <code>IServiceCollection</code> interface. To use <code>IServiceCollection</code>, ensure you’ve included the <code>Microsoft.Extensions.DependencyInjection</code> namespace, which is part of the NuGet package we added in the first step. This method is all about registering the repositories. Ending the method by returning the <code>services</code> instance allows us to adopt a builder pattern, enabling the chaining of additional extension methods.</p></li> <li>Now, we can head over to the <code>MauiProgram.cs</code> file and add the following to the <code>CreateMauiApp</code> method:<pre class="source-code">
builder.Services.RegisterRepositories();</pre><p class="list-inset">The <code>RegisterRepositories</code> extension method can only be resolved when the <code>Recipes.Client.Repositories</code> namespace is added.</p></li> </ol>
<p>With all of this in place, the services of our app now depend on repositories that will eventually communicate to the app’s API. The implementation of those repository interfaces and their registration is done in the dedicated <code>Recipes.Client.Repositories</code> project. This keeps everything organized and modular and ensures a clear separation of concerns, making our codebase more maintainable.</p>
<p>Although <a id="_idIndexMarker715"/>we now have repositories <a id="_idIndexMarker716"/>that are being registered, they still lack communication with our API. Moreover, we registered the <code>RatingsApiGateway</code>, <code>RecipeApiGateway</code>, and <code>FavoritesApiGateway</code> classes, which don’t exist yet. Let’s see how we can add these and leverage Refit to make API requests and receive strongly typed responses, making it easier to handle errors and parse data.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor172"/>API communication with Refit</h1>
<p>Up to this point, we’ve set up a neat architecture for our repositories, but they’re still missing the <a id="_idIndexMarker717"/>ability to talk to our API. To add this functionality, we could use <code>HttpClient</code> manually to make API calls and deserialize the response. While that’s entirely possible, it’s also cumbersome and prone to errors, not to mention it takes a lot of boilerplate code to get it right.</p>
<p>This is where <a id="_idIndexMarker718"/>Refit comes into the picture. Refit is a powerful library that simplifies API calls by providing a more declarative and less error-prone approach. Instead of writing tedious HTTP requests and responses, you just define a C# interface that maps to the API’s endpoints. Refit takes care of the underlying <code>HttpClient</code> calls, serialization, and deserialization for you, letting you focus on what matters – the logic of your application.</p>
<p>In this section, we’ll see how Refit can make our life easier by reducing code complexity and increasing readability, while still offering customization options for more complex scenarios. So, let’s get our repositories talking to our API the smart way.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor173"/>Getting started with Refit</h2>
<p>Refit is a <a id="_idIndexMarker719"/>type-safe REST client for .NET that allows you to easily make API calls by defining an interface. You annotate the interface methods with HTTP attributes such as <code>[Get]</code>, <code>[Post]</code>, and so on, specifying the API endpoints. Refit is then able to generate the implementation for you, turning those interface methods into API calls. Let’s take a look at an example:</p>
<ol>
<li>First, we need to define the API endpoints we’ll be interacting with by declaring an interface:<pre class="source-code">
public interface IRecipeApi
{
    [Get("/recipe/{recipeId}")]
    Task&lt;ApiResponse&lt;RecipeDto&gt;&gt;
        GetRecipe(string recipeId);
}</pre><p class="list-inset">Here, the <code>IRecipeApi</code> interface defines an API call for fetching a single recipe by its ID. The <code>Refit.Get</code> attribute is used to define an <code>HTTP GET</code> method for a specific endpoint. The <code>{recipeId}</code> portion of the endpoint specifies a path parameter <a id="_idIndexMarker720"/>that is used to pass the <code>recipeId</code> parameter to the method. When the <code>GetRecipe</code> method is called with a recipe ID, we want the Refit library to send an <code>HTTP GET</code> request to the specified endpoint, replacing the <code>{recipeId}</code> portion of the endpoint with the specified ID.</p></li> <li>Secondly, we use <code>RestService.For</code> to generate an implementation of your interface, as shown here:<pre class="source-code">
var api = RestService.For&lt;IRecipeApi&gt;(
        "https://api.yourservice.com");</pre><p class="list-inset">This single line of code creates an object that knows how to make the API calls defined in <code>IRecipeApi</code>. This <code>RestService.For</code> method accepts a string parameter that defines the base URL of the API. Alternatively, an instance of <code>HttpClient</code> can be passed as a parameter, instead of the string value. Refit will use the given <code>HttpClient</code> to communicate with the API. Later on in the chapter, we’ll see why passing in an <code>HttpClient</code> can be useful.</p></li> <li>Finally, we can use the generated object to make API calls and handle the responses, as the following code snippet demonstrates:<pre class="source-code">
var recipeResponse = await api.GetRecipe("1");
if (recipeResponse.IsSuccessStatusCode)
{
    RecipeDto recipe = recipeResponse.Content;
}
Task&lt;RecipeDto&gt; GetRecipe(string recipeId);</pre><p class="list-inset">This would just return the deserialized object. I prefer the approach that returns <code>ApiResponse&lt;T&gt;</code> because it provides a fuller picture of what’s happening during the API interaction, which is crucial for robust error handling and insightful logging.</pre></li> </ol>
<p>And there you have it: three simple steps to replace what would have otherwise been much more boilerplate code. Now, let’s get back to our <em class="italic">Recipes!</em> app and put this into practice.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor174"/>Creating API interfaces</h2>
<p>Let’s add <a id="_idIndexMarker722"/>API interfaces to the <code>Recipes.Client.Repositories</code> project. Later on, we will be using them together with Refit to generate the required code to effectively communicate to the API:</p>
<ol>
<li>In the <code>Recipes.Client.Repositories</code> project and select <code>Api</code>.</li>
<li>Add an interface called <code>IFavoritesApi</code> to the newly created folder. The following code snippet shows what this interface looks like:<pre class="source-code">
public interface IFavoritesApi
{
    [Get("/users/{userId}/favorites")]
    Task&lt;string[]&gt; GetFavorites(string userId);
    [Post("/users/{userId}/favorites")]
    Task AddFavorite(string userId,
        FavoriteDto favorite);
    [Delete("/users/{userId}/favorites/{recipeId}")]
    Task DeleteFavorite(string userId,
        string recipeId);
}</pre><p class="list-inset">This interface <a id="_idIndexMarker723"/>maps directly to the API endpoints responsible for managing user favorites. The <code>Get</code>, <code>Post</code> and <code>Delete</code> attributes specify the HTTP methods that should be used for each API call. Parameters such as <code>userId</code> that appear in the URL are automatically populated from the method arguments. Notice the <code>favorite</code> parameter in the <code>AddFavorite</code> method. This parameter is not part of the defined endpoint URL; instead, it gets serialized and sent as the request body. Alternatively, it’s also possible to explicitly indicate that the favorite parameter needs to be sent in the message’s body by using the <code>Body</code> attribute. This is what that looks like:</p><pre class="source-code">[Post("/users/{userId}/favorites")]
    Task AddFavorite(string userId,
        <code>IRatingsApi</code> interface, which looks like this:<pre class="source-code">
public interface IRatingsApi
{
    [Get("/recipe/{recipeId}/ratings")]
    Task&lt;ApiResponse&lt;RatingDto[]&gt;&gt; GetRatings(
        string recipeId);
    [Get("/recipe/{recipeId}/ratingssummary")]
    Task&lt;ApiResponse&lt;RatingsSummaryDto&gt;&gt;
        GetRatingsSummary(string recipeId);
}</pre><p class="list-inset">Again, these methods and their attributes correspond with the endpoints that allow us <a id="_idIndexMarker724"/>to retrieve ratings and a ratings summary for a given recipe ID.</p></li> <li>Finally, let’s define the <code>IRecipeApi</code> interface:<pre class="source-code">
public interface IRecipeApi
{
    [Get("/recipe/{recipeId}")]
    Task&lt;ApiResponse&lt;RecipeDetailDto&gt;&gt;
      GetRecipe(string recipeId);
    [Get("/recipes")]
    Task&lt;ApiResponse&lt;RecipeOverviewItemsDto&gt;&gt;
      GetRecipes(int pageSize = 7, int pageIndex = 0);
}</pre><p class="list-inset">As you probably know by now, as with the previous ones, this interface also maps to certain API endpoints. The <code>pageSize</code> and <code>pageIndex</code> parameters of the <code>GetRecipes</code> method don’t appear in the endpoint of the <code>Get</code> attribute. As a result, they will be added as query string parameters when doing the request.</p></li> </ol>
<p>With our API <a id="_idIndexMarker725"/>interfaces defined, it’s finally time to bridge the gap between our repositories and the actual API calls.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor175"/>Integrating Refit</h2>
<p>Let’s integrate Refit into our repositories to make the API calls a breeze. It all starts with adding the <a id="_idIndexMarker726"/>Refit NuGet package to the <code>Recipes.Client.Repositories</code> project. To make integrating Refit even easier and avoid duplicate code later on, let’s first add a new <code>ApiGateway</code> abstract class to the <code>Recipes.Client.Repositories</code> project. The purpose of this class is to help us in executing a call and mapping the <code>ApiResponse</code> result to another type. This is what the <code>InvokeAndMap</code> method’s signature looks like:</p>
<pre class="source-code">
protected async Task&lt;Result&lt;TResult&gt;&gt;
    InvokeAndMap&lt;TResult, TDtoResult&gt;(
    Task&lt;ApiResponse&lt;TDtoResult&gt;&gt; call,
    Func&lt;TDtoResult, TResult&gt; mapper)
{
}</pre> <p>This method returns a <code>Task&lt;TResult&gt;</code> object and takes in two parameters:</p>
<ul>
<li>The <code>call</code> parameter is the API call to make, which returns an <code>ApiResponse&lt;TDtoResult&gt;</code> object</li>
<li>The <code>mapper</code> parameter is a method that takes in the <code>TDtoResult</code> object from the response and maps it to the <code>TResult</code> object that the <code>InvokeAndMap</code> method returns</li>
</ul>
<p>The implementation is fairly straightforward: the method must execute the provided <code>call</code> parameter. If the resulting <code>ApiResponse</code> instance indicates success, the passed-in <code>mapper</code> parameter will be used to map the result from <code>TDtoResult</code> to <code>TResult</code>, which is wrapped in a <code>Result</code> object that indicates success. If the response doesn’t indicate success, a failed result is returned, containing the response’s status code. The following <a id="_idIndexMarker727"/>code block shows how it’s done:</p>
<pre class="source-code">
try
{
    var response = await call;
    if (response.IsSuccessStatusCode)
    {
        return Result&lt;TResult&gt;
            .Success(mapper(response.Content));
    }
    else
    {
        return Result&lt;TResult&gt;.Fail("FAILED_REQUEST",
            response.Error.StatusCode.ToString());
    }
}
...</pre> <p>On top of that, we also need to be wary of potential exceptions being thrown, which we can handle as shown here:</p>
<pre class="source-code">
try
{
...
}
catch (ApiException aex)
{
    return Result&lt;TResult&gt;
        .Fail("ApiException",
            aex.StatusCode.ToString(), aex);
}
catch (Exception ex)
{
    return Result&lt;TResult&gt;.Fail(ex);
}</pre> <p>When an <a id="_idIndexMarker728"/>exception occurs, we should return a <code>Result</code> object that indicates failure, containing relevant data about the exception.</p>
<p class="callout-heading">A note on robustness</p>
<p class="callout">When developing mobile applications, it’s important to remember that network conditions can be unpredictable. Mobile devices might move between different network zones, causing unstable connections. As a best practice, always consider implementing resilience patterns such as <code>ApiGateway</code> class is the perfect spot to add this kind of retry logic instead of directly returning a <code>Fail</code> result. Find out more about Polly here: <a href="https://github.com/App-vNext/Polly">https://github.com/App-vNext/Polly</a>.</p>
<p>In situations where the data type returned by the API interface is identical to the type we wish to encapsulate in a <code>Result</code> object, we can provide an overloaded <code>InvokeAndMap</code> method that eliminates the need for a type mapper. This is particularly useful when dealing with primitive types. The following snippet shows this overload:</p>
<pre class="source-code">
protected Task&lt;Result&lt;T&gt;&gt;
    InvokeAndMap&lt;T&gt;(&lt;ApiResponse&lt;T&gt;&gt; call)
    =&gt; InvokeAndMap(call, e =&gt; e);</pre> <p>This base class will drastically simplify the mapping of a DTO returned by the API to a domain entity <a id="_idIndexMarker729"/>that gets encapsulated in a <code>Result</code> object. Now, let’s have a look at how we can utilize this <code>InvokeAndMap</code> method in our repositories:</p>
<ol>
<li>First, make sure that all of our repositories (<code>FavoritesApiGateway</code>, <code>RatingsApiGateway</code>, and <code>RecipeApiGateway</code>) inherit this abstract <code>ApiGateway</code> class by adding the following code:<pre class="source-code">
internal class FavoritesApiGateway : <strong class="bold">ApiGateway</strong>,
  IFavoritesRepository { ... }
internal class RatingsApiGateway : <strong class="bold">ApiGateway</strong>,
  IRatingsRepository { ... }
internal class RecipeApiGateway : <strong class="bold">ApiGateway</strong>,
  IRecipeRepository { ... }</pre></li> <li>Next, each of these repositories should get its corresponding API interface injected through its constructor. Let’s see what this looks like for <code>RatingsApiGateway</code>:<pre class="source-code">
internal class RatingsApiGateway : ApiGateway,
  IRatingsRepository
{
    <strong class="bold">readonly IRatingsApi _api;</strong>
...
    public RatingsApiGateway(<strong class="bold">IRatingsApi api</strong>)
    {
        <strong class="bold">_api = api;</strong>
    }
}</pre></li> <li>The injected <code>IRatingsApi</code> interface can now be used to do the network calls and retrieve <a id="_idIndexMarker730"/>the requested data from the API. The following code block shows the implemented <code>GetRatings</code> method:<pre class="source-code">
public Task&lt;Result&lt;IReadOnlyCollection&lt;Rating&gt;&gt;&gt;
    GetRatings(string recipeId)
    =&gt; InvokeAndMap(
        _api.GetRatings(recipeId), MapRatings);</pre><p class="list-inset">The <code>GetRatings</code> method calls the <code>InvokeAndMap</code> method of the base class. The <code>GetRatings</code> API call is passed in as a parameter, as well as the <code>MapRatings</code> method, which maps the <code>RatingDto</code> array returned by the API to an <code>IReadOnlyCollection</code> of <code>Rating</code> objects. The <code>MapRatings</code> method is a static method on the static <code>RatingsMapper</code> class. We can directly access <code>RatingsMapper</code>’s static mapping methods inside this class without explicitly needing to prepend its name because the following <code>using</code> statement is added to the class:</p><pre class="source-code">using static Recipes.Client.Repositories.Mappers
  .RatingsMapper;</pre></li> <li>We can now do the exact same thing for the <code>GetRatingsSummary</code> method on this class:<pre class="source-code">
public Task&lt;Result&lt;RatingsSummary&gt;&gt;
    GetRatingsSummary(string recipeId)
    =&gt; InvokeAndMap(_api.GetRatingsSummary(recipeId),
        MapRatingSummary);</pre></li> <li>Analogous to the previous examples, the implementation of the <code>FavoritesApiGateway</code> class can be done following the same pattern: inject the <code>IFavoritesApi</code> interface and use its methods to retrieve data from the API, leveraging <a id="_idIndexMarker731"/>the <code>InvokeAndMap</code> method of the <code>ApiGateway</code> base class:<pre class="source-code">
internal class FavoritesApiGateway : ApiGateway,
    IFavoritesRepository
{
    readonly IFavoritesApi _api;
    public Task&lt;Result&lt;Nothing&gt;&gt; Add(
        string userId, string id)
        =&gt; InvokeAndMap(_api.AddFavorite(userId,
            new FavoriteDto(id)));
    public Task&lt;Result&lt;string[]&gt;&gt; LoadFavorites(
        string userId)
        =&gt; InvokeAndMap(_api.GetFavorites(userId));
    public Task&lt;Result&lt;Nothing&gt;&gt; Remove(string userId,
    string recipeId)
        =&gt; InvokeAndMap(_api.DeleteFavorite(userId,
            recipeId));
    public FavoritesApiGateway(IFavoritesApi api)
    {
        _api = api;
    }
}</pre><p class="list-inset">All of these methods in the <code>FavoritesApiGateway</code> use the overloaded <code>InvokeAndMap</code> method, which doesn’t do additional mapping: the data type returned by the API interface is the same as the one the repository returns, but it’s encapsulated in a <code>Result</code> object.</p></li> <li>The implementation of the <code>RecipeApiGateway</code> class shouldn’t contain any surprises; it only contains more mapping. But at its core, it follows the exact same pattern <a id="_idIndexMarker732"/>as the previous two classes. First, a field of type <code>IRecipeApi</code> needs to be added as a member and constructor parameter, as the following snippet shows:<pre class="source-code">
internal class RecipeApiGateway : ApiGateway,
    IRecipeRepository
{
    readonly IRecipeApi _api;
...
    public RecipeApiGateway(IRecipeApi api)
    {
        _api = api;
    }
}</pre><p class="list-inset">The <code>LoadRecipes</code> method and the mappings it uses look like this:</p><pre class="source-code">public Task&lt;Result&lt;LoadRecipesResponse&gt;&gt;
    LoadRecipes(int pageSize, int page)
    =&gt; InvokeAndMap(_api.GetRecipes(pageSize, page),
        MapRecipesOverview);</pre><p class="list-inset"><code>LoadRecipes</code> calls the <code>InvokeAndMap</code> method, passing in the <code>GetRecipes</code> method of the API interface. The <code>MapRecipesOverview</code> method is used to map the resulting object of type <code>RecipesOverviewItemsDto</code> to a <code>LoadRecipesResponse</code> object.</p><p class="list-inset">And finally, we can implement the <code>LoadRecipe</code> method. It can use the <code>GetRecipe</code> method of the <code>IRecipeApi</code> to get the data. The result will be mapped using the static <code>MapRecipe</code> method of the static <code>RecipeMapper</code> class. Take a look:</p><pre class="source-code">public Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(
    string id)
    =&gt; InvokeAndMap(_api.GetRecipe(id), MapRecipe);</pre></li> </ol>
<p>We also need to update our <code>ServiceCollectionExtension</code> class. Because every repository now <a id="_idIndexMarker733"/>has a dependency on a particular API interface, we need to make sure these dependencies get registered as well. But first, we might want to add a new <code>RepositorySettings</code> class to the <code>Recipes.Client.Repositories</code> project. This class should be a way to pass settings from the app to the repositories, such as a specific <code>HttpClient</code> instance that needs to be used, for example. As the following code block shows, there’s not much to this class for this particular demo project. But in more complex applications, things such as particular serialization or authentication settings can be added here as well:</p>
<pre class="source-code">
public class RepositorySettings
{
    public HttpClient HttpClient { get; }
    public RepositorySettings(HttpClient httpClient)
    {
        HttpClient = httpClient;
    }
}</pre> <p>Let’s fit the <a id="_idIndexMarker734"/>final pieces of the puzzle together, update the <code>ServiceCollectionExtension</code>, and call it from our app. Here’s what we need to do:</p>
<ol>
<li>Add the <code>RepositorySettings</code> class, as shown earlier, to the <code>Recipes.Client.Repositories</code> project.</li>
<li>Add a parameter of type <code>RepositorySettings</code> to the <code>RegisterRepositories</code> extension method of the <code>ServiceCollectionExtension</code> class, as shown here:<pre class="source-code">
public static class ServiceCollectionExtension
{
    public static IServiceCollection
        RegisterRepositories (
        this IServiceCollection services,
        <strong class="bold">RepositorySettings settings</strong>)
    {
        ...
        return services;
    }
}</pre></li> <li>As we saw earlier, Refit’s <code>RestService.For</code> method can be used to generate implementations of the API interfaces. The following snippet shows how we can register the generated implementations in the DI container:<pre class="source-code">
services.AddSingleton((s) =&gt;
  RestService.For&lt;IRatingsApi&gt;(settings.HttpClient));
services.AddSingleton((s) =&gt;
  RestService.For&lt;IRecipeApi&gt;(settings.HttpClient));
services.AddSingleton((s) =&gt;
RestService.For&lt;IFavoritesApi&gt;(settings.HttpClient));</pre><p class="list-inset">The <code>RestService.For</code> method accepts an instance of <code>HttpClient</code> that will be used by Refit to do the API communication. An <code>HttpClient</code>, should be configured in the app and passed-in via the <code>RepositorySettings</code>.</p></li> <li>Finally, in the <code>MauiProgram</code> class, <a id="_idIndexMarker735"/>we can call the updated <code>RegisterRepositories</code> and pass-in a configured <code>HttpClient</code> as shown here:<pre class="source-code">
var baseAddress = DeviceInfo.Platform ==
    DevicePlatform.Android
    ? "https://10.0.2.2:7220"
    : "https://localhost:7220";
var httpClient = HttpClientHelper
    .GetPlatformHttpClient(baseAddress);
builder.Services.RegisterRepositories(
    new RepositorySettings(httpClient));</pre><p class="list-inset">As the Android emulator runs in an isolated network environment behind a virtual router, it cannot directly access the development machine using <code>localhost</code>. Instead, the emulator provides a special <code>10.0.2.2</code> alias that routes to the development machine’s loopback interface, enabling you to access local web services.</p><p class="list-inset">The <code>Recipes.Mobile</code> project contains an <code>HttpClientHelper</code> class that configures an <code>HttpClient</code> instance to be used for connecting to local web services. This is needed as some additional configuration specific to each platform needs to be done in order to effectively communicate to web services hosted locally.</p></li> </ol>
<p class="callout-heading">Connecting to local web services</p>
<p class="callout">While developing software, it’s typical to run a local web service and access it using an app in either <a id="_idIndexMarker736"/>an Android emulator or an iOS simulator. Some additional configuration is needed in order for the app to communicate with your local web service. More information about connecting to a local web service and how to configure each platform can be found here: <a href="https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services">https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services</a>.</p>
<p>If you want to debug the <em class="italic">Recipes!</em> app, we need to tell Visual Studio to run both the mobile app and the API. To do this, right-click <strong class="bold">Solution ‘Recipes App’</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Properties</strong>. In the pop-up, select <strong class="bold">Multiple startup projects</strong> and set the <strong class="bold">Action</strong> of both the <strong class="bold">Recipes.Mobile</strong> and <strong class="bold">Recipes.Web.Api</strong> projects to <strong class="bold">Start</strong>.</p>
<p>As we wrap <a id="_idIndexMarker737"/>up this chapter, let’s briefly turn our attention to how we can call APIs from ViewModels, deal with loading indicators, and handle potential errors, all while providing a seamless user experience.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor176"/>API communication from ViewModels</h1>
<p>When navigating to the <code>RecipeDetailPage</code>, you’ll see some data on the screen while the recipe <a id="_idIndexMarker738"/>is being loaded. The data being shown is <a id="_idIndexMarker739"/>the values defined as <code>FallbackValue</code> or <code>TargetNullValue</code> in the binding statements as a result of the data in <code>RecipeDetailViewModel</code> not being loaded yet. Although effective, I don’t think it looks pretty. Let’s see how we can improve this by showing a loading indicator while the data is being loaded.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor177"/>Showing a loading indicator</h2>
<p>One of the <a id="_idIndexMarker740"/>simplest yet effective ways to improve user experience is to provide visual feedback during API calls. Consider the following code snippet:</p>
<pre class="source-code">
private bool _isLoading = true;
public bool IsLoading
{
    get =&gt; _isLoading;
    set =&gt; SetProperty(ref _isLoading, value);
}
private async Task LoadRecipe(string recipeId)
{
    <strong class="bold">IsLoading = true;</strong>
...
    await Task.WhenAll(loadRecipeTask,
        loadIsFavoriteTask, loadRatingsTask);
...
    <strong class="bold">IsLoading = false;</strong>
}</pre> <p>Here, we set the <code>IsLoading</code> property of the <code>RecipeDetailViewModel</code> to <code>true</code> before we start <a id="_idIndexMarker741"/>loading the data and it is reverted back to <code>false</code> afterward. Thanks to the use of <code>async</code>/<code>await</code>, the UI thread is not blocked during this operation, allowing UI elements such as loading indicators to be updated and rendered.</p>
<p>You can bind this property to a loading spinner in your XAML like so:</p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;ScrollView&gt;
        ...
    &lt;/ScrollView&gt;
    &lt;Grid
        BackgroundColor="GhostWhite"
        <strong class="bold">IsVisible="{Binding IsLoading}"</strong>&gt;
        &lt;ActivityIndicator
            HorizontalOptions="Center"
            <strong class="bold">IsRunning="{Binding IsLoading}"</strong>
            VerticalOptions="Center" /&gt;
    &lt;/Grid&gt;
&lt;/Grid&gt;</pre> <p>As a result of this setup, whenever the API call – or any long-running process, for that matter – is in progress, the user receives a visual cue, indicating that the app is currently busy. In the <a id="_idIndexMarker742"/>preceding example, we’ve used a <code>Grid</code> property that overlays the entire page and contains an <code>ActivityIndicator</code>. However, you’re not limited to this approach; you could also use a message, an animation, or any other UI element that best suits your app’s design and user experience.</p>
<p>Using a property to indicate that a task is in progress, and binding this property to the UI, is a common MVVM pattern for managing longer-running operations. The responsiveness is made possible by the <code>async</code>/<code>await</code> construct, which keeps the UI thread unblocked, allowing for a smoother user experience.</p>
<p>Earlier in this chapter, we already saw how the <code>Result</code> object can help us elegantly handle successful and unsuccessful results. Now, let’s take it a step further by enhancing the user experience by handling a <code>Result</code> object that indicates failure.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor178"/>Handling failures</h2>
<p>Earlier in <a id="_idIndexMarker743"/>this chapter, we introduced the <code>Result</code> object as a way to elegantly handle failures. The object’s <code>IsSuccess</code> property indicates whether an operation is completed successfully or not. We’ve already seen that in successful cases, the <code>Data</code> property gives us access to the result. However, when <code>IsSuccess</code> is <code>false</code>, it’s crucial not to leave the user guessing. Instead, we should provide clear feedback and offer a way to resolve the issue. Let’s see how this is tackled in the <code>LoadRecipes</code> method <a id="_idIndexMarker744"/>of <code>RecipesOverviewViewModel</code>:</p>
<pre class="source-code">
private async Task LoadRecipes(int pageSize, int page)
{
    LoadFailed = false;
    var loadRecipesTask =
        recipeService.LoadRecipes(pageSize, page);
    ...
    if(recipesResult.IsSuccess)
    {
        //Set TotalNumberOfRecipes property
        //Fill Recipes collection
        ...
    }
    else
    {
        <strong class="bold">LoadFailed = true;</strong>
        <strong class="bold">ReloadCommand =</strong>
<strong class="bold">            new AsyncRelayCommand(</strong>
<strong class="bold">            () =&gt; LoadRecipes(pageSize, page));</strong>
    }
}</pre> <p>As you can see, when the task isn’t successful, the <code>LoadFailed</code> property is set to <code>true</code>. Also, the <code>ReloadCommand</code> property gets initialized. The following code block shows how both properties are data-bound to the UI and will provide the user with some information and the ability to retry loading the list of recipes:</p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;CollectionView&gt;
    ...
    &lt;/CollectionView&gt;
    &lt;Grid
        BackgroundColor="{StaticResource Primary}"
        HorizontalOptions="Fill"
        <strong class="bold">IsVisible="{Binding LoadFailed}"</strong>
        VerticalOptions="Fill"&gt;
        &lt;VerticalStackLayout
            HorizontalOptions="Center"
            VerticalOptions="Center"&gt;
            &lt;Label Text="Unable to load recipes" /&gt;
            &lt;Button <strong class="bold">Command="{Binding ReloadCommand}"</strong>
                Text="Retry" /&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/Grid&gt;
&lt;/Grid&gt;</pre> <p>Additionally, we could <a id="_idIndexMarker745"/>show a custom error message to the user when a specific failure occurs. The <code>ErrorMessage</code>, <code>ErrorCode</code>, and <code>Exception</code> properties of the <code>Result</code> object could be used for that. This approach eliminates the need for scattering various exception-handling blocks throughout our ViewModels, thereby creating a more streamlined, readable, and maintainable code base.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor179"/>Summary</h1>
<p>We kicked off this chapter by revisiting the architecture of our <em class="italic">Recipes!</em> app to include repositories. This addition was aimed at adhering to the principle of SoC and minimizing our app’s dependency on the API itself. We also introduced the <code>Result</code> object, a transformative component in our error-handling strategy. This single object encapsulates both success and failure states, making our ViewModels more robust and intelligible. By using the <code>Result</code> object, we’ve made it easier to handle anticipated errors in a graceful manner, while still keeping exceptions reserved for critical failures.</p>
<p>After setting this architectural foundation, we moved on to explore the power and simplicity of Refit, a type-safe REST client. Refit has substantially streamlined the way we interact with APIs, making the code more readable and maintainable.</p>
<p>We also looked at how the <code>Result</code> object elegantly fits into our ViewModels, making it far easier to handle expected errors and providing a uniform approach to error management. Alongside this, we discussed practical UI considerations, including loading indicators and error overlays, to offer the user an engaging and informative experience.</p>
<p>You should now have a solid understanding of how to make API calls, manage responses, and provide real-time user feedback, all in a resilient and easily maintainable way.</p>
<p>In the next chapter, we will be looking at how to create MVVM-friendly controls.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Refit documentation: <a href="https://reactiveui.github.io/refit/">https://reactiveui.github.io/refit/</a></li>
<li>Consuming a REST-based web service with <code>HttpClient</code>: <a href="https://learn.microsoft.com/dotnet/maui/data-cloud/rest">https://learn.microsoft.com/dotnet/maui/data-cloud/rest</a></li>
</ul>
</div>
</div>

<div><div><h1 id="_idParaDest-172" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor181"/>Part 3: Mastering MVVM Development</h1>
<p>This final part is all about refining and hardening your .NET MAUI app. We will delve deep into crafting controls that seamlessly integrate with MVVM. You will learn how to expand your app's reach with techniques for localization and fortify your code base with robust unit testing, ensuring stability and reliability. And when things don't go as planned, you will be able to rely on valuable troubleshooting and debugging tips to steer back on course.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B20941_11.xhtml#_idTextAnchor182"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating MVVM-Friendly Controls</em></li>
<li><a href="B20941_12.xhtml#_idTextAnchor196"><em class="italic">Chapter 12</em></a>, <em class="italic">Localization with MVVM</em></li>
<li><a href="B20941_13.xhtml#_idTextAnchor223"><em class="italic">Chapter 13</em></a>, <em class="italic">Unit Testing</em></li>
<li><a href="B20941_14.xhtml#_idTextAnchor238"><em class="italic">Chapter 14</em></a>, <em class="italic">Troubleshooting and Debugging Tips</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>