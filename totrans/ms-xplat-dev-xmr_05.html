<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Networking</h1></div></div></div><p>In this chapter, we will take a detailed look at the networking capabilities of Xamarin applications and various service integration scenarios. The chapter also includes real-world examples on how to use local storage for data caching on connected app scenarios. It is divided into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connected apps</li><li class="listitem" style="list-style-type: disc">Web services</li><li class="listitem" style="list-style-type: disc">Push notifications</li><li class="listitem" style="list-style-type: disc">SignalR</li><li class="listitem" style="list-style-type: disc">Patterns and best practices</li><li class="listitem" style="list-style-type: disc">Platform-specific concepts</li><li class="listitem" style="list-style-type: disc">Cloud integration</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Connected apps</h1></div></div></div><p>Mobile <a class="indexterm" id="id234"/>applications by definition should be as lightweight and resource-efficient as possible. You cannot expect to package media and other content into the application and then distribute the app or create an extravagant size of storage for user data, especially with applications whose main purpose is to provide user access to related content or store and manipulate the data.</p><p>For instance, while dealing with cross-platform projects, one of the easiest ways to create unified business logic and storage is to create a web service layer and delegate the responsibility and logic to this layer. In this scenario, the application(s) would be simply responsible for serving the content provided by the service layer or communicating the user input to the service layer.</p><p>This approach not only increases the efficiency of the application(s) but also creates an abstraction between the logic implementation and the presentation. This allows the developers to be free from the platform constraints on technology choices for storage and execution.</p><p>It is also important to mention that applications' dependency on external resources is not a matter of choice but has rather become a necessity, since applications are more and more dependent on <a class="indexterm" id="id235"/>third-party web service APIs and social media networks.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Web services</h1></div></div></div><p>A web <a class="indexterm" id="id236"/>service is generally defined as an interoperable machine-to-machine communication over the wire (network). In the context of cross-platform application, the most important term in this definition would be "interoperable". Web services written in different frameworks or languages and running on different type of runtimes and hardware conform to the same standards, most of which can be consumed by applications running on a variety of platforms, including Xamarin target platforms.</p><p>Xamarin target platforms, namely iOS and Android, and Windows Runtime, can access stateless web services using the TCP/IP (short for Transmission Control Protocol / Internet Protocol) stack over a secure or non-secure HTTP (short for Hypertext Transfer Protocol) transport layer. Even though various data representations can be consumed via web services, JSON and XML are the most common text-based notations used.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>While defining or accessing a web service, there are three basic elements that need to be taken into consideration. We can call these the A-B-C of a web service: Address, Binding, and Contract. The address is the remote access location to the service, binding defines the transport and security protocols, and contract defines the data types and the methods used by the service.</p></div></div><p>While the methods and data types defined in the web service contract are very case-specific, transport and serialization protocols that can be used by Xamarin applications can be generalized.</p><p>In web service scenarios, if the consumer is a Xamarin target platform, you should always be persistent about using asynchronous implementation for the client implementation. Asynchronous implementation for the web service clients decreases the chance of blocking the main thread, as discussed previously, and protects the application from network shortage related errors and crashes.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Transport</h2></div></div></div><p>For Xamarin applications <a class="indexterm" id="id237"/>on both iOS and Android platforms, the main communication protocol is HTTP. HTTP transport can be secured on the client and/or message level using a certificate or credentials.</p><p>The message-level security is optional in other versions of iOS and Xamarin.Android applications. In iOS 9, the <strong>App Transport Security</strong> (<strong>ATS</strong>) feature enforces secure connections to network resources. Even though it is possible to add certain domains to the exclusion list, <a class="indexterm" id="id238"/>or to turn off the ATS altogether for the target<a class="indexterm" id="id239"/> applications, it is strongly advised that you use secure transport over HTTP (or HTTPS) for Xamarin.iOS applications.</p><p>Even though communication protocols for TCP, UDP, or web sockets over HTTP are fully or partially supported on Xamarin platforms, with the current service infrastructure implementation, these communication channels cannot be used with web services.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Messaging</h2></div></div></div><p>Messaging <a class="indexterm" id="id240"/>specifications of a service define which format should be used while communicating data over the HTTP transport layer.</p><p>In Xamarin applications dealing with web services, messages should be constructed either according to the SOAP (Simple Object Access Protocol) or using POX (short for Plain Old XML) or JSON, depending on the service requirements.</p><div><img alt="Messaging" src="img/B04693_05_01.jpg"/><div><p>Simple SOAP Communication Example</p></div></div><p>The messaging structure is mainly important for the serialization and deserialization of request and response pairs between the client and server implementations. Hence, it is possible to employ other types of data communication models, which would require additional <a class="indexterm" id="id241"/>custom implementation for the client and the server.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>SOAP/XML services</h2></div></div></div><p>SOAP <a class="indexterm" id="id242"/>web services use XML data objects enveloped<a class="indexterm" id="id243"/> in SOAP-defined schemas. <strong>Windows Communication Foundation</strong> (<strong>WCF</strong>) services and ASP.Net Legacy Services (ASMX) are both SOAP services and conform to the SOAP protocol.</p><p>SOAP <a class="indexterm" id="id244"/>web service contracts are defined in <strong>Web Service Description Language</strong> (<strong>WSDL</strong>) and the WSDL document, together with other XML data schemas (for example, XSD files), are generally accessible through the web service URL. Using this document, web services can be defined in a consistent manner, irrespective of the underlying language, and can be interfaced with and consumed by various clients.</p><div><img alt="SOAP/XML services" src="img/B04693_05_02.jpg"/><div><p>Service WSDL for a SOAP 1.1 Service</p></div></div><p>In Xamarin applications, one of the possible ways to create a so-called proxy (service consumer) is to use the Silverlight SDK to generate the access code. The main reason for using the Silverlight SDK is the fact that the Windows Communication Foundation client infrastructure is<a class="indexterm" id="id245"/> not fully included in the Xamarin core and only a subset of client features, very similar to the Silverlight framework, can be used to access web services.</p><p>In order to generate the client, you can simply use the command-line tool to execute the following command:</p><div><pre class="programlisting">
<strong>slsvcutil http://localhost/ ReferenceService.svc /d:c:\bin\</strong>
</pre></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>SLSvcUtil can be found in various SDKs including Windows Phone 7, Windows Phone 8, Windows Phone 8.1 (Silverlight), as well as the actual Silverlight SDK directories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v7.0\Tools\SlSvcUtil.exe</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.0\Tools\SlSvcUtil.exe</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.1\Tools\SlSvcUtil.exe</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">C:\Program Files (x86)\Microsoft SDKs\Silverlight\v5.0\Tools\SlSvcUtil.exe</code></li></ul></div></div></div><p>The preceding command would generate a WCF client that can communicate with any web service that supports the SOAP 1.1 profile. If we were to consume a WCF service, the supported binding configurations would be <code class="literal">BasicHttpBinding</code> and <code class="literal">WebHttpBinding</code> (essentially a REST binding). <code class="literal">WSHttpBinding</code> and similar configurations use other SOAP profiles to envelope the data requests and responses.</p><div><img alt="SOAP/XML services" src="img/B04693_05_03.jpg"/><div><p>Generating Silverlight Proxy</p></div></div><p>The generated client would have both the Event-Based and Asynchronous Programming Model (APM) asynchronous <a class="indexterm" id="id246"/>methods for accessing the client.</p><div><pre class="programlisting">[OperationContract (AsyncPattern=true, Action="master.xamarin.com/ReferenceService/GetRegions", ReplyAction="master.xamarin.com/ReferenceService/GetRegionsResponse")]
IAsyncResult BeginGetRegions(Xamarin.Master.TravelTrace.Data.Region filter, AsyncCallback callback, object asyncState)
List&lt;Xamarin.Master.TravelTrace.Data.Region&gt; EndGetRegions(IAsyncResult result)

public void GetRegionsAsync(Xamarin.Master.TravelTrace.Data.Region filter)</pre></div><p>Another approach would be to create a web reference in Visual Studio or Xamarin Studio. A web reference can only be used to communicate with services that implement the WS-I Basic Profile 1.1 (in other words, SOAP 1.1). Web reference generated clients use the ASMX communication stack (.NET 2.0 Services Technology) as opposed to the WCF client infrastructure used by service references.</p><div><img alt="SOAP/XML services" src="img/B04693_05_04.jpg"/><div><p>Add Web Reference Dialog (Visual Studio)</p></div></div><p>If we <a class="indexterm" id="id247"/>were to compare the generated clients from the web reference and the Silverlight SDK, we could easily identify the underlying technologies.</p><div><pre class="programlisting">// Web Service Generated Client.
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BasicHttpBinding_ReferenceService", Namespace="master.xamarin.com")]
[GeneratedCodeAttribute("System.Web.Services", "4.6.79.0")]
public partial class AsmxReferenceServiceClient : System.Web.Services.Protocols.SoapHttpClientProtocol

// WCF Generated Client
[GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
public partial class ReferenceServiceClient : System.ServiceModel.ClientBase&lt;ReferenceService&gt;, ReferenceService</pre></div><p>Looking at the class diagram for both of the generated proxies, we can get some more insight into the method execution strategies:</p><div><img alt="SOAP/XML services" src="img/B04693_05_05.jpg"/><div><p>Generated Proxy Comparison</p></div></div><p>The ideal<a class="indexterm" id="id248"/> way to integrate the generated proxy in a cross-platform project would be to add the service reference in a portable class library to be used by platform-specific projects. In order to be able to add a service reference in a PCL project in Visual Studio, you must remove Windows Phone 8.1 as one of the targets and/or add a reference to the <code class="literal">System.ServiceModel</code> namespace (Visual Studio will automatically remove Windows Phone 8.1 from the targets list). The Windows Phone 8.1 platform does not include the Windows Communication Foundation client assemblies. After this step, the <strong>Add Service Reference</strong> option will appear under the project context menu.</p><p>For scenarios involving Windows Phone 8.1, the more appropriate solution would be to use a RESTful service and a client.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>RESTful services</h2></div></div></div><p>RESTful services <a class="indexterm" id="id249"/>are one of the most common distributed system implementations involving mobile applications. Compared to SOAP services, they don't have the overhead of SOAP protocols or the enveloping of the request/response pairs. In essence, network traffic caused by a SOAP method call is the <a class="indexterm" id="id250"/>same as the request/response pair of a REST call. The simplicity of the <strong>Representational State Transfer</strong> (<strong>REST</strong>) model increases the performance and maintainability. Stateless and cacheable approaches of RESTful services makes them an optimal solution for Xamarin target platforms.</p><p>REST services can essentially be described as static HTTP endpoints. The HTTP verbs (GET, PUT, POST, and DELETE) used to access these endpoints define the type of method to be invoked on the service layer (PUT for update, POST for create, and DELETE for delete actions). The messaging structure can vary from JSON to XML, even to ATOM.</p><p>On Xamarin target platforms, there are various out-of-the-box options and additional components available for REST-based web services. Any of these options can be used to execute web requests and request/response pairs can be serialized/deserialized according to the requirements and chosen messaging media-type.</p><p>Since we are making ordinary web requests to the REST endpoints, the simplest implementation would involve the <code class="literal">HttpClient</code>, which is included in the <code class="literal">System.Net.Http</code> namespace.</p><p>For instance, if we were to implement a base class that will handle the CRUD (create, read, update, and delete) methods on the RESTful version of the web service used in the previous section (<code class="literal">TravelTrace.ReferenceDataService</code>), we could implement a per-call wrapper around the inner HTTP client layer.</p><div><pre class="programlisting">public BaseClient(string baseAddress, string securityToken)
{
    if (string.IsNullOrEmpty(baseAddress)) throw new ArgumentNullException("baseAddress");

    BaseAddress = new Uri(baseAddress);

  // Storing the security token in a class property of type string
    SecurityToken = securityToken.StartsWith("Bearer") ? securityToken.Substring(7) : securityToken;

    m_HttpClient = CreateHttpClient();
}</pre></div><p>You will notice that we are using the base address as the server address and, if any, using the security token to initialize our client. In this implementation, the create method will simply create the HTTP client and use the authentication token as a default header. Another important requirement is to set the "Accept" header to announce which type of content the <a class="indexterm" id="id251"/>client is expecting from the server (JSON in this example).</p><div><pre class="programlisting">private HttpClient CreateHttpClient()
{
    var httpClient = new HttpClient();
    httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
            
    if (string.IsNullOrEmpty(SecurityToken))
    {
        httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", SecurityToken);
    }

    return httpClient;
}</pre></div><p>After the HTTP pipeline is ready to execute the requests, we can start implementing the base methods for the REST service.</p><div><pre class="programlisting">protected async Task&lt;string&gt; GetStringAsync(string path)
{
    // if we are using the BaseClient multiple times
    // we can create a new transport with each method
    //HttpClient httpClient = CreateHttpClient();

    try
    {
        // Get the response from the server url and REST path for the data
        var response = await m_HttpClient.GetAsync(new Uri(BaseAddress, path));

        if (response.StatusCode == HttpStatusCode.Unauthorized)
        {
            throw new UnauthorizedAccessException("Access Denied");
        }
        if (response.IsSuccessStatusCode)
        {
            return await response.Content.ReadAsStringAsync();
        }

        throw new WebException(response.ReasonPhrase);
    }
    catch (Exception ex)
    {
        // TODO:
        throw ex;
    }
}</pre></div><p>Now, the <code class="literal">GetRegions</code> method looks like this:</p><div><pre class="programlisting">var regions = await GetStringAsync("regions");</pre></div><p>The <a class="indexterm" id="id252"/>result of this request can be visualized in the debug screen:</p><div><img alt="RESTful services" src="img/B04693_05_06.jpg"/><div><p>JSON data returned from Web API</p></div></div><p>However, this is only the string representation of the service data, and we would need to extend our implementation to include a JSON serializer. There are multiple options available for serialization, including the standard libraries available through the <em>Microsoft BCL</em> package:<code class="literal"> System.Xml</code> and <code class="literal">System.Json</code> namespaces. <em>NewtonSoft Json.NET</em> is still one of the most popular JSON libraries and available through NuGet.</p><div><pre class="programlisting">public async Task&lt;List&lt;Region&gt;&gt; GetRegionsAsync(Region filter = null)
{
    var result = new List&lt;Region&gt;();

    var regions = await GetStringAsync("regions");
    var resultingList = JToken.Parse(regions);

    await Task.Run(() =&gt;
    {
        result.AddRange(resultingList["value"]
            .Select(item =&gt; item.ToObject&lt;Region&gt;()));
    });

    return result;
}</pre></div><p>Using this<a class="indexterm" id="id253"/> implementation, we can create generic methods in the base class implementation and push the serialization responsibility to this layer.</p><div><pre class="programlisting">protected async Task&lt;List&lt;T&gt;&gt; GetListAsync&lt;T&gt;(string path)
{
    List&lt;T&gt; result = new List&lt;T&gt;();

    try
    {
        var response = await GetStringAsync(path);
        var resultingList = JToken.Parse(response);

        await Task.Run(() =&gt;
        {
            result.AddRange(resultingList["value"]
                .Select(item =&gt; item.ToObject&lt;T&gt;()));
        });
    }
    catch (Exception ex)
    {
        // TODO:
        throw ex;
    }

    return result;
}</pre></div><p>We can extend this generic implementation for other web methods and create the basis for our RESTful client. The authentication scenario will be discussed further in the following section.</p><p>There are many more REST consumer implementations available for the Xamarin developer and these <a class="indexterm" id="id254"/>modules can be included in cross-platform projects via components and NuGet packages (RestSharp, Hammock, and so on).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>OData and OAuth</h2></div></div></div><p>OData<a class="indexterm" id="id255"/> and OAuth are two widely accepted standards/protocols for RESTful communication scenarios. Xamarin mobile applications that deal with external resources, and especially third-party web service APIs, are generally implementing these protocols.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec14"/>OData</h3></div></div></div><p>Unlike <a class="indexterm" id="id256"/>SOAP, which is a communication protocol, REST is simply an architectural approach to web service implementations. RESTful services do not need to conform to certain specifications and may vary greatly. In order to identify the requirements for RESTful services and create a uniform structure for data being exchanged between the client applications and the server, OData was initiated by Microsoft in 2007. OData is now an internationally accepted protocol that is maintained by OASIS and supported/used by various applications, platforms, and companies (for example, Microsoft Azure Mobile Services, Microsoft Office 365 Web Access, Salesforce, SAP Netweaver Gateway Solution, IBM WebSphere, and so on).</p><p>In OData protocol, each object set is defined by an endpoint in line with REST principles. For GET requests, these entity set endpoints can either accept object identifiers, which results in the details of that specific entity instance, or entities in the list can be queried with OData filter and other query options.</p><p>Similar to the WSDL in SOAP/XML services, accessible endpoints (entity sets and functions) and types used in the service contracts are generally served through the metadata endpoint with a CSDL (OData Common Schema Definition Language) file in OData.</p><p>To access<a class="indexterm" id="id257"/> the whole list of elements, visit <code class="literal">http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions</code>.</p><p>To access a single element in the entity set endpoint, visit <code class="literal">http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions(guid'90222c18-66fa-441a-b069-0115faa1e0f1')</code>.</p><p>To query the list of elements with a filter, visit <code class="literal">http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions?$filter=Continent eq 'Europe'</code>.</p><p>Advanced OData queries involving additional property expansions, lambda operators, and functions are also possible with the OData protocol; however, these topics are beyond the scope of this book.</p><p>There <a class="indexterm" id="id258"/>are <a class="indexterm" id="id259"/>multiple NuGet packages and components available both as open source and/or free to download that help with the client generation for OData services.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec15"/>OAuth</h3></div></div></div><p>OAuth is <a class="indexterm" id="id260"/>an open standard used generally by service providers<a class="indexterm" id="id261"/> for authorization. A general use case for OAuth would be to use third-party identity providers such as Live ID (Microsoft), Google, Facebook, or Twitter for authentication and authorization in a mobile or web application.</p><p>A classic OAuth 2.0 implementation scenario is generally a two-step process. The first step involves the user granting access to the client application through the provider web interface. The second step is using the authorization code received from the provider's web interface to get an access token to access the provider's resources.</p><div><img alt="OAuth" src="img/B04693_05_07.jpg"/><div><p>Facebook as Auth Provider</p></div></div><p>The first step of the authorization process on a web application is generally an <code class="literal">iframe</code> displaying the provider's authorization page. In a Xamarin application, this step is executed using a web view control or a more specialized implementation (<code class="literal">WebAuthenticationBroker</code> is an out-of-box control on Windows Phone 8.1). Implementing the two-step authentication process can become quite cumbersome considering the fact that the provider's page makes a callback request to the client application<a class="indexterm" id="id262"/> page with the authorization token and the client app is <a class="indexterm" id="id263"/>responsible for parsing and extracting this token either from the callback URL or the body of the content.</p><div><img alt="OAuth" src="img/B04693_05_08.jpg"/><div><p>Xamarin.Auth Components</p></div></div><p>To provide access to OAuth APIs and simplify the implementation, developers can make use of the available Xamarin OAuth component: Xamarin.Auth (available on Xamarin.iOS and Xamarin.Android platforms). There is also an accompanying component for social media provider APIs: Xamarin.Social.</p><p>Using the Xamarin.Auth implementation, authenticating with the Facebook API can become as simple as a few lines of code.</p><div><pre class="programlisting">var authenticationBroker = new OAuth2Authenticator(
    clientId: "&lt;App ID from https://developers.facebook.com/apps&gt;",
    scope: "",
    authorizeUrl: new Uri("https://m.facebook.com/dialog/oauth/"),
    redirectUrl: new Uri("http://www.facebook.com/connect/login_success.html"));

authenticationBroker.Completed += (sender, eventArgs) =&gt;
{
    DismissViewController(true, null);

    if (eventArgs.IsAuthenticated)
    {
        // TODO: eventArgs.Account contains the authenticated user info
    }
    else
    {
        // TODO: Possibly the user denied access to the account or
        // the user could not authenticate with the provider
    }
};

// The GetUI method returns UINavigationControllers on iOS, and Intents on Android
PresentViewController(authenticationBroker.GetUI(), true, null);</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>SignalR</h1></div></div></div><p>ASP.NET SignalR is a <a class="indexterm" id="id264"/>web server-side technology that allows developers to pass real-time updates to their applications. SignalR works in a similar way to WCF duplex channels where the server side is accessible through the main service contract and the server-to-client communication occurs through the callback contract. While WCF duplex channels provide support for the same scenarios as SignalR, duplex channel implementation is currently not supported in any of the Xamarin target platforms. On the other hand, there is a component available for use on all Xamarin target platforms for SignalR.</p><div><img alt="SignalR" src="img/B04693_05_09.jpg"/><div><p>SignalR Component</p></div></div><p>SignalR takes advantage of <code class="literal">WebSockets</code>, which enables bidirectional communication over the HTTP transport. In essence, <code class="literal">WebSockets</code> works almost in the same way as TCP Sockets; however, the connection is established over the HTTP transport layer.</p><p>Using SignalR, applications<a class="indexterm" id="id265"/> requiring real-time data can be implemented without resorting to polling or listener channel implementations, which is neither scalable nor efficient on mobile platforms.</p><p>SignalR is <a class="indexterm" id="id266"/>generally implemented with a Hub application on the server-side, which creates different event sinks to be subscribed by different applications. Each client that subscribes to a certain channel gets event notifications and data over these channels in a normal broadcast scenario in a string format or already deserialized as a complex type.</p><div><pre class="programlisting">// Connect to the server
var hubConnection = new HubConnection("http://xamarin.traveltrace.com/");

// Create a proxy to the 'MainHub' on the SignalR server
var myHubProxy = hubConnection.CreateHubProxy("MainHub");

// Subscribe to message from the server
myHubProxy.On&lt;string&gt;("ServerStringCall", message =&gt;
{
    // TODO: use the message update from the channel
});

// Subscribe to message with a complex type
myHubProxy.On&lt;Region&gt;("ServerComplexCall", message =&gt;
{
    // TODO: use the message update from the channel
});

// Start the connection
await hubConnection.Start();</pre></div><p>SignalR server <a class="indexterm" id="id267"/>implementations can, generally speaking, replace RESTful service actions. These duplex hubs can provide functions to be called by the consumers as well as update calls from the server to listening clients.</p><p>While different message formats can be used to exchange data, most implementations employ the JSON format to serialize and deserialize data, and Json.NET is the default serialization library used by the SignalR component.</p><div><pre class="programlisting">await myHubProxy.Invoke("MySimpleServerMethod", "myParameter");
await myHubProxy.Invoke&lt;Region&gt;("MyComplexServerMethod", new Region{Continent = Continent.Europe});</pre></div><p>On top of the <a class="indexterm" id="id268"/>server invoked events, SignalR channels also offer lifetime events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Received</strong>: Raised when any data is received on the connection. Provides the received data.</li><li class="listitem" style="list-style-type: disc"><strong>ConnectionSlow</strong>: Raised when the client detects a slow or frequently dropping connection.</li><li class="listitem" style="list-style-type: disc"><strong>Reconnecting</strong>: Raised when the underlying transport begins reconnecting.</li><li class="listitem" style="list-style-type: disc"><strong>Reconnected</strong>: Raised when the underlying transport has reconnected.</li><li class="listitem" style="list-style-type: disc"><strong>StateChanged</strong>: Raised when the connection state changes. Provides the old state and the new state.</li><li class="listitem" style="list-style-type: disc"><strong>Closed</strong>: Raised when the connection has disconnected.</li></ul></div><p>SignalR supports <a class="indexterm" id="id269"/>SSL transport security as well as having the ability to integrate with the existing authentication and authorization providers already being used by the web server and mobile applications.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Patterns and best practices</h1></div></div></div><p>In mobile <a class="indexterm" id="id270"/>applications, developers often use certain reusable<a class="indexterm" id="id271"/> design patterns while using web services and other communication channels in development projects. These patterns aim to increase the efficiency and increase the code sharing not only between platforms but also among various execution domains of cross-platform mobile applications.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Async conversions</h2></div></div></div><p>The generated <a class="indexterm" id="id272"/>proxies for WCF and/or SOAP/XML services generally include either an event-based async implementation or an asynchronous invoke pattern with begin and end methods. Both of these implementations can be converted to a task-based async pattern.</p><p>In order to convert the event-based async service method to a task-based one, we can use <code class="literal">TaskCompletionSource&lt;T&gt;</code> and return the task that is produced (refer to <a class="link" href="ch03.html" title="Chapter 3. Asynchronous Programming">Chapter 3</a>, <em>Asynchronous Programming</em>).</p><div><pre class="programlisting">public Task&lt;List&lt;Region&gt;&gt; GetRegionsAsync(Region filter = null)
{
    var taskAwaiter = new TaskCompletionSource&lt;List&lt;Region&gt;&gt;();

    var client = CreateServiceClient();

    EventHandler&lt;GetRegionsCompletedEventArgs&gt; completedDelegate = null;

    completedDelegate = (sender, args) =&gt;
        {
            if (args.Error != null)
            {
                taskAwaiter.SetException(args.Error);
            }

            taskAwaiter.SetResult(args.Result);

            client.GetRegionsCompleted -= completedDelegate;
        };

    client.GetRegionsCompleted += completedDelegate;

    client.GetRegionsAsync(new Region { Continent = Continent.Europe });

    return taskAwaiter.Task;
}</pre></div><p>For the async <a class="indexterm" id="id273"/>invoke pattern, we can use the designated methods from the <code class="literal">TaskFactory</code>. The <code class="literal">FromAsync</code> method of the <code class="literal">TaskFactory</code> uses the begin and end methods together with the async state object (which can, for example, be used for cancellation token or progress callback) and creates an awaitable task.</p><div><pre class="programlisting">public Task&lt;List&lt;Region&gt;&gt; GetRegionsAsync(Region filter = null)
{
    var client = (ReferenceService.ReferenceService)CreateServiceClient();

    var task = Task&lt;List&lt;Region&gt;&gt;.Factory
        .FromAsync(
        (callback, o) =&gt; client.BeginGetRegions(filter, callback, o),
        result =&gt; client.EndGetRegions(result),
        null);

    return task;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Data model abstraction</h2></div></div></div><p>Following<a class="indexterm" id="id274"/> the quality identifiers that were put forward previously, in service-related scenarios, it is important to create a data model abstraction layer which can be used by different branches of a cross-platform application.</p><p>Using the travelers' guide application example from previous sections, we can analyze the sharing strategy. In this example, as a development team or a single developer, we are responsible for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing the service layer responsible for accessing the database and connecting to external APIs, if necessary</li><li class="listitem" style="list-style-type: disc">Implementing the shared common logic which will be used by Xamarin applications</li><li class="listitem" style="list-style-type: disc">Implementing the Xamarin.iOS and Xamarin.Android applications</li><li class="listitem" style="list-style-type: disc">Implementing the Windows Phone 8.1 application</li><li class="listitem" style="list-style-type: disc">Implementing the web interface which will employ a Silverlight component (optional)</li></ul></div><p>For simplicity, we will be implementing only a single data type and a single GET method.</p><p>For the contracts and the data objects, we can create a portable library that will be targeting Xamarin platforms together with .NET 4.5. The reason we are including the .NET profile is because we will be using the data model in the service layer implementation as well.</p><p>The implementation starts by creating the Data Transfer Model objects. These objects are generally the reflection of the database tables used on the service layer. However, one-to-one mapping between DTOs and DBOs (Entity Framework items) is not absolutely necessary since the DTO abstraction layer's sole purpose is to create an abstraction layer over the actual data repository that we will be dealing with.</p><div><pre class="programlisting">public class Region
{
    [JsonProperty("id")]
    public Guid Id { get; set; }

    [JsonProperty("name")]
    public string Name { get; set; }

    [JsonProperty("continent")]
    public Continent Continent { get; set; }
}</pre></div><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Notice that we are including Json.NET attributes to define class properties. They are used to format the JSON object attributes during serialization/deserialization to camel-case (for example, camelCase), which is the JavaScript convention, rather than the .NET convention of pascal-case (for example, PascalCase) for property names. These property definitions can be used with RESTful clients and web service implementations. This will not interfere with other service or client layer use cases.</p></div></div><p>After we<a class="indexterm" id="id275"/> create the model, we can define the interface(s) that will be used by the web service and associated clients. We will define two interfaces for synchronous implementation on the service layer and asynchronous consumption on the client side.</p><div><pre class="programlisting">namespace Xamarin.Master.TravelTrace.Common.Infrastructure
{
    public interface IReferenceService
    {
        List&lt;Region&gt; GetRegions(Region filter = null);

        List&lt;Country&gt; GetCountries(Country filter = null);

        List&lt;City&gt; GetCities(City filter = null);
    }

    public interface IReferenceServiceAsync
    {
        Task&lt;List&lt;Region&gt;&gt; GetRegionsAsync(Region filter = null);

        Task&lt;List&lt;Country&gt;&gt; GetCountriesAsync(Country filter = null);

        Task&lt;List&lt;City&gt;&gt; GetCitiesAsync(City filter = null);
    }
} </pre></div><p>The service <a class="indexterm" id="id276"/>implementation strategy would normally be to use a RESTful layer. For demonstration purposes, let's implement the WCF service in a separate project, reusing the data model defined and the interface previously created.</p><div><img alt="Data model abstraction" src="img/B04693_05_10.jpg"/><div><p>Solution Structure</p></div></div><p>In this implementation, each service method will be calling a data repository (Entity Framework/MSSQL) and the repository will be returning the DTO objects by converting the database layer entities.</p><p>The next<a class="indexterm" id="id277"/> section of the project that we need to implement would be the service data consumer layer. We will create a new portable library for this layer and use a generated WCF client. After creating the project and adding the reference to the <code class="literal">System.ServiceModel</code> namespace and the common portable library that contains the DTO model, an important detail to remember is to make sure that the generated proxy reuses the referenced libraries.</p><div><img alt="Data model abstraction" src="img/B04693_05_11.jpg"/><div><p>Service Reference Properties</p></div></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>If you are using the Silverlight SDK to generate the client, it is a little more complicated to include the existing libraries so that the types are reused. In order to do this, you can use the "reference" switch (or simply, <code class="literal">/r</code>: ) and point the utility to the assemblies that contain the implemented types.</p><div><pre class="programlisting">
<strong>slsvcutil http://localhost/ReferenceService.svc </strong>
<strong>    /d:c:\bin\ /r:C:\Local\Xamarin.Master.TravelTrace.Common.dll</strong>
</pre></div></div></div><p>After creating the proxy, we have a structure in which the data model and the contracts are shared by different layers of the application including the service, data access layer, service <a class="indexterm" id="id278"/>proxy, and finally, the applications.</p><div><img alt="Data model abstraction" src="img/B04693_05_12.jpg"/><div><p>Shared service structure</p></div></div><p>The implementation, however, should be further extended with conversions to task-based async implementation on the service proxy. Another useful improvement would be to implement local DB caching and offline storage. For this caching layer, the same DTO implementation can be reused.</p><p>If we were to include a Windows Phone 8.1 client in this cross-platform project, the only solution to the lack of WCF infrastructure would be to exchange the WCF service with a RESTful implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Service cache</h2></div></div></div><p>When<a class="indexterm" id="id279"/> dealing with network scenarios, it is important to keep in mind that mobile devices do not always have a good network connectivity or network at all. In order to make the Xamarin connected app usable even in offline scenarios, a caching layer can be implemented to store and return data items that do not often change.</p><p>For instance, in travel guide applications, users will want to access guides, and possibly maps, even when they are with a roaming connection or, even worse, without any connection at all. To facilitate offline storage, we can implement a SQLite database that uses the existing data transfer objects as storage items and updates the data on certain intervals when there is Internet connectivity.</p><p>The first step of the implementation would be to revise our DTO layer classes and add SQLite attributes if needed. This will create a dependency on the service layer for SQLite assemblies; the other option is either to use linked code files between the service layer and the client<a class="indexterm" id="id280"/> libraries or to recreate the DTO objects specifically for the SQLite data store.</p><div><pre class="programlisting">public class Region
{
    public Region()
    {
        Countries = new List&lt;Country&gt;();
    }

    [PrimaryKey]
    [JsonProperty("id")]
    public Guid Id { get; set; }

    [JsonProperty("name")]
    public string Name { get; set; }

    [JsonProperty("continent")]
    public Continent Continent { get; set; }

    [OneToMany(CascadeOperations = CascadeOperation.CascadeInsert | CascadeOperation.CascadeRead)]
    [JsonProperty("countries")]
    public List&lt;Country&gt; Countries { get; set; } 
}</pre></div><p>In this scenario, in order to create a data context that will use the online storage if available and use the local data storage if Internet connectivity is limited, we can implement the same data interface that we created for the service proxy in the previous examples for the SQLite data source and create one parent handler for the data sync context.</p><div><img alt="Service cache" src="img/B04693_05_13.jpg"/><div><p>Data Abstraction on App Tiers</p></div></div><p>In the <a class="indexterm" id="id281"/>sync context, for GET methods, the service calls will be used only for updating the local storage and actual results will be returned from the local storage. For PATCH, POST, and PUT calls, depending on the online connectivity, we will be either saving the data locally or pushing the deltas and new object instances to the service and updating the local data with the updates.</p><div><pre class="programlisting">public class DataSyncContext : IReferenceServiceAsync
{
    public IReferenceServiceAsync LocalDataService { get; set; }

    public IReferenceServiceAsync RemoteDataService { get; set; }

...

    public async Task&lt;List&lt;Region&gt;&gt; GetRegionsAsync(Region filter = null)
    {
        try
        {
            // Getting the online results
            var results = await RemoteDataService.GetRegionsAsync(filter);

            // If there were any online changes.
            SyncToLocal(results);
        }
        catch (Exception ex)
        {
            // TODO:
        }

        // Returning the local storage results (with or without updates)
        return await LocalDataService.GetRegionsAsync(filter);
    }
...
}</pre></div><p>For <a class="indexterm" id="id282"/>performance improvement in this implementation, when we are loading data for certain visualizations, we can first call the local data provider and continue with UI updates and then call the web service method and the same continuation delegate.</p><div><pre class="programlisting">Action&lt;List&lt;Region&gt;&gt; onRegionsLoaded = regions =&gt;
{
    // Update the view-model data or the UI.
};

DataContext.LocalDataService.GetRegionsAsync()
    .ContinueWith((task) =&gt;
    {
        onRegionsLoaded(task.Result);
    });

DataContext.GetRegionsAsync()
    .ContinueWith((task) =&gt;
    {
        onRegionsLoaded(task.Result);
    });</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Platform-specific concepts</h1></div></div></div><p>There<a class="indexterm" id="id283"/> are other concepts and network communication methods on Xamarin platforms that are provided by the native runtime and supported by Xamarin.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Permissions</h2></div></div></div><p>In order <a class="indexterm" id="id284"/>for an Android or Windows Phone application to access Internet, the application manifest should declare that the application will need to use the network to access resources.</p><p>The permission on Android system is declared using the <code class="literal">uses-permission</code> tag in the manifest node of the XML file:</p><div><pre class="programlisting">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</pre></div><p>While this declaration will suffice in most use case scenarios, in order to access the current network status or the Wi-Fi status, you must also declare the network state permissions:</p><div><pre class="programlisting">&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;</pre></div><p>For a Windows phone, the app capability to declare would be <code class="literal">ID_CAP_NETWORKING</code>.</p><p>Application manifests for both platforms can be edited through the application project properties in the designated configuration section.</p><div><img alt="Permissions" src="img/B04693_05_14.jpg"/><div><p>Android Manifest</p></div></div><p>iOS, other than the App Transport Security (ATS) that was mentioned previously, does not enforce<a class="indexterm" id="id285"/> any manifest setup or permissions for applications to use network connection.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>NSUrlConnection/NSUrlSession (iOS Only)</h2></div></div></div><p>Apart from the different client libraries<a class="indexterm" id="id286"/> available for use with Xamarin target platforms, some native implementations can also be used to call and receive external web data. One of these available options for Xamarin.iOS platform is <code class="literal">NSUrlConnection</code>. With the help of <code class="literal">NSUrlConnection</code>, developers can make web requests and use the response.</p><p>A simple web request to retrieve the data from the previously demonstrated static data endpoint on iOS would look similar to this:</p><div><pre class="programlisting">public Task&lt;List&lt;Region&gt;&gt;  GetRegionsAsync(Region filter = null)
{
    var nsUrlRequest = new NSUrlRequest(new NSUrl(myServiceEndpoint));

    var taskSource = new TaskCompletionSource&lt;List&lt;Region&gt;&gt;();

    var nsUrlConnection = new NSUrlConnection(nsUrlRequest,
        new ConnectionSerializingHandler&lt;List&lt;Region&gt;&gt;(taskSource));
    nsUrlConnection.Start();

    return taskSource.Task;
}</pre></div><p>The implementation for the connection delegate would involve the deserialization of the data and assigning the result to the <code class="literal">TaskCompletionSource</code> so the method execution can be finalized.</p><div><pre class="programlisting">public class ConnectionSerializingHandler&lt;T&gt; : 
        NSUrlConnectionDataDelegate where T:class,new()
{
    private StringBuilder m_ResponseStore;

    private TaskCompletionSource&lt;T&gt; m_TaskCompletion; 
    public bool IsFinishedLoading { get; set; }
    public string ResponseContent { get; set; }

    public ConnectionSerializingHandler(TaskCompletionSource&lt;T&gt; taskCompletionSource)
        : base()
    {
        m_ResponseStore = new StringBuilder();
        m_TaskCompletion = taskCompletionSource;
    }
    public override void ReceivedData(NSUrlConnection connection, NSData data)
    {
        if (data != null)
        {
            m_ResponseStore.Append(data);
        }
    }

    public override void FinishedLoading(NSUrlConnection connection)
    {
        IsFinishedLoading = true;
        ResponseContent = m_ResponseStore.ToString();

        // TODO: implement deserialization and 
        m_TaskCompletion.SetResult(result);
    }
}</pre></div><p>Even though this implementation is <a class="indexterm" id="id287"/>possible on the iOS platform, considering the cost of passing the mono to iOS bridge (likewise on Android and JNC Bridge), this type of implementation should be avoided, and either only native or mono runtime code should be used to communicate over the network.</p><p>In a similar manner, we can implement the usage scenario for the new <code class="literal">NSUrlSession</code> class in iOS. However, <code class="literal">NSUrlSession</code> can also be used in background download scenarios. Therefore, we will discuss it in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Background downloads</h2></div></div></div><p>When<a class="indexterm" id="id288"/> the application requires larger network resources than the client UI can wait for, in Xamarin mobile applications we can resort to background downloads. Both iOS and Android platforms offer implementations for background downloads and these strategies can be executed on Xamarin runtime.</p><p>For Xamarin.Android application developers, the easiest way to execute a background download is to use the Download Manager API service/application provided since API level 9. The download manager can be initialized with a request and the application can subscribe to event notification(s) regarding the download status.</p><p>First, we<a class="indexterm" id="id289"/> need to create a request to pass onto the <code class="literal">DownloadManager</code>:</p><div><pre class="programlisting">global::Android.Net.Uri downloadUri = global::Android.Net.Uri.Parse("&lt;URL to Download&gt;");
DownloadManager.Request request = new DownloadManager.Request(downloadUri);

// Types of networks on which this download will be executed.
request.SetAllowedNetworkTypes(DownloadNetwork.Wifi);
            
// Allowed on Roaming connection?
request.SetAllowedOverRoaming(false);
            
// Allowed on Metered Connection?
request.SetAllowedOverMetered(false);
            
//Set the title of this downloaded
request.SetTitle("My Background Download");

//Set the description of this downloaded
request.SetDescription("Xamarin.Android download using DownloadManager");

//Set the local destination for the downloaded file
request.SetDestinationInExternalFilesDir(this, global::Android.OS.Environment.DirectoryDownloads, "MyDownloadedData.xml");
// or use the request.SetDestinationUri()</pre></div><p>Once the request is ready to be executed, we can get the <code class="literal">DownloadManager</code> instance and queue the download request:</p><div><pre class="programlisting">m_DownloadManager = (DownloadManager)GetSystemService(DownloadService);

// Enqueue the request
// The download reference will be used to retrieve the status
m_CurrentDownloadReference = m_DownloadManager.Enqueue(request);</pre></div><p>The download reference can be used to get the current status information about the queued download or cancel the ongoing background download.</p><p>To get the current status of the download or cancel it, we can use the respective methods on the <code class="literal">DownloadManager</code> instance.</p><div><pre class="programlisting">// Removing the queued request from the DownloadManager queue.
m_DownloadManager.Remove(m_CurrentDownloadReference);

//
// Retrieving the current status of the download queue
// Create a query to retrieve the download status(s)
DownloadManager.Query myDownloadQuery = new DownloadManager.Query();
myDownloadQuery.SetFilterById(m_CurrentDownloadReference);
// Request the queued download items as a data table.
var cursor = m_DownloadManager.InvokeQuery(myDownloadQuery);
var statusColumn = cursor.GetColumnIndex(DownloadManager.ColumnStatus);
var status = (DownloadStatus)cursor.GetInt(statusColumn);</pre></div><p>This<a class="indexterm" id="id290"/> implementation can be extended with the notification(s) that are received from the <code class="literal">DownloadManager</code> application using a <code class="literal">BroadcastReceiver</code> class.</p><div><pre class="programlisting">public class DownloadBroadcastReceiver : BroadcastReceiver
{
    public override void OnReceive(Context context, Intent intent)
    {
        // Get the download reference from the intent broadcast
        long referenceId = intent.GetLongExtra(DownloadManager.ExtraDownloadId, -1);

        // TODO: Implement the delegated execution
    }
}</pre></div><p>We can now register the broadcast receiver with the <code class="literal">DownloadManager</code> instance and update the UI with a possible delegated implementation for updating it.</p><div><pre class="programlisting">//set filter to only when download is complete and register broadcast receiver
IntentFilter filter = new IntentFilter(DownloadManager.ActionDownloadComplete);
// TODO: We can extend the DownloadBroadcastReceiver with delegates
RegisterReceiver(new DownloadBroadcastReceiver(), filter);</pre></div><p>On top of the broadcasts mechanism, the Download Manager App UI can also be invoked within the Xamarin applications to give a uniform UI about on-going or completed transfers.</p><p>On the iOS platform (at least post iOS 7), background transfers (both download and upload operations) are made possible with <code class="literal">NSUrlSession</code>. <code class="literal">NSUrlSession</code> provides an easy to implement interface that lets developers create an efficient and reliable transfer processes.</p><p>The implementation<a class="indexterm" id="id291"/> strategy for <code class="literal">NSUrlSession</code> initially involves the implementation of an <code class="literal">NSUrlSessionDelegate</code>, which will be the responsible "handler" for the transfer process. Basic methods related to the health and status of the transfer are exposed through this delegate and can be implemented to provide required information for the transfer or give real-time updates to the application user.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DidFinishEventsForBackgroundSession</code> is called when the background session is complete</li><li class="listitem" style="list-style-type: disc"><code class="literal">DidReceiveChallenge</code> is invoked when the server requests credentials</li><li class="listitem" style="list-style-type: disc"><code class="literal">DidBecomeInvalid</code> is invoked when there is a problem with the session</li></ul></div><p><code class="literal">NSUrlSessionDelegate</code> provides the base implementation for more specialized transfer delegates: <code class="literal">NSUrlSessionDownloadDelegate</code> for download operations and <code class="literal">NSUrlSessionTaskDelegate</code> for upload operations. These delegate classes expose additional status methods related to the transfer tasks (for example, download delegate provides methods to retrieve notifications about the download progress).</p><p>For instance, if we were to use the same example as on Xamarin.Android with the <code class="literal">BroadcastReceiver</code> implementation, the <code class="literal">NSUrlSessionDownloadDelegate</code> implementation would require three basic methods for completion, error, and progress.</p><div><pre class="programlisting">public class DownloadTaskDelegate : NSUrlSessionDownloadDelegate
{
    public override void DidFinishDownloading(NSUrlSession session, NSUrlSessionDownloadTask downloadTask, NSUrl location)
    {
        // TODO: Implement the delegate for download finished
    }
    public override void DidBecomeInvalid(NSUrlSession session, NSError error)
    {
        //base.DidBecomeInvalid(session, error);

        // TODO: Implement the delegate for error
    }
    public override void DidWriteData(NSUrlSession session, NSUrlSessionDownloadTask downloadTask, long bytesWritten, long totalBytesWritten,
        long totalBytesExpectedToWrite)
    {
        //base.DidWriteData(session, downloadTask, bytesWritten, 
        //  totalBytesWritten, totalBytesExpectedToWrite);

        // TODO: Implement the delegate for download progress
    }
} </pre></div><p>After<a class="indexterm" id="id292"/> the delegate implementation is complete, we can create the session and start the download operation using the <code class="literal">NSUrlSession</code>.</p><div><pre class="programlisting">NSUrlSessionConfiguration downloadSessionConfiguration = NSUrlSessionConfiguration.BackgroundSessionConfiguration ("com.TravelTravel.BackgroundTransfer");
m_DownloadSession = NSUrlSession
    .FromConfiguration(downloadSessionConfiguration, 
    new DownloadTaskDelegate(), 
    new NSOperationQueue());
NSUrl url = NSUrl.FromString("&lt;URL to Download&gt;");
NSUrlRequest request = NSUrlRequest.FromUrl(url);
m_DownloadTask = m_DownloadSession.CreateDownloadTask(request);</pre></div><p>On top of the handler implementation, the iOS app can be woken to execute certain code, such as a local mobile notification to inform the user about the completed sessions. For the task complete event, one needs to use the iOS application delegate (refer to <a class="link" href="ch02.html" title="Chapter 2. Memory Management">Chapter 2</a>, <em>Memory Management</em>) for <code class="literal">DidFinishEventsForBackgroundSession</code>.</p><p>Mobile notifications (also called pushed notifications for remote scenarios) are user notifications that are executed on the OS level to inform the user about application-related updates. They can be triggered both locally or by using a remote server.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Push notifications</h2></div></div></div><p>Push <a class="indexterm" id="id293"/>notifications are subtle UI messages that can help an application to provide the user information about an asynchronous task being executed by the service layer or about an external event that is related to the application instance itself (for example, messages from social networks, approval for a travel reservation, and so on).</p><p>It is possible to create and receive push notifications on both Xamarin platforms and Windows Phone. These notifications are triggered by a secondary server/application (for example, service layer), brokered by the corresponding messaging infrastructure provider for the platform and displayed by the application on the target client. For the Android platform, the<a class="indexterm" id="id294"/> messaging provider is <strong>Google Cloud Messaging</strong> (<strong>GCM</strong>) and it is the <strong>Apple Notification Push Service</strong> (<strong>APNS</strong>) for <a class="indexterm" id="id295"/>iOS. Both of these service providers require your application to be registered to receive push notifications and the server application to have the credentials to be able to authenticate with the notification services. Similarly, <strong>Windows Notification Services</strong> (<strong>WNS</strong>) adopts a federated<a class="indexterm" id="id296"/> authentication mechanism.</p><p>Both <a class="indexterm" id="id297"/>GCM and APNS use a subscription model in which the client app on a specific device subscribes/registers for the push notifications and an addressing token is created. The addressing token is used, later on, by the server to send push notifications to the message broker service (for example, GCM) and the queued messages are delivered to the specific client.</p><div><img alt="Push notifications" src="img/B04693_05_15.jpg"/><div><p>Push Notifications</p></div></div><p>On top of the classic messaging model, GCM also supports topic-based and group-based messages where the receivers are not limited to a single device/application pair. It is also possible with GCM to create a duplex channel where the client is able to send messages back to the server layer.</p><p>Push notifications on these platforms can be used to trigger various tasks, the most common of which is to navigate to a certain view and continue the business process flow initialized by the notification.</p><p>Although it is relatively elementary on the client side to subscribe to push notifications, cross-platform scenarios require complex implementation to introduce a single server environment to provide messages to both GCM and APNS. However, there are platform-agnostic implementations available for both of these platforms. The Microsoft Azure platform and the notification hub is one of these solutions, where communication with GCM <a class="indexterm" id="id298"/>and APNS are both supported through usage of the same business logic implementation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Cloud integration</h1></div></div></div><p>Even<a class="indexterm" id="id299"/> though there are multiple cloud service providers as development platforms for creating the backend for mobile applications, Microsoft Azure stands out among the competitors with its inherent natural bond to the .NET platform and subsequently Xamarin, considering its evolution. Most of the features supported by Azure have a specific implementation for Xamarin target platforms.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Azure Mobile Services</h2></div></div></div><p>Azure Mobile Services <a class="indexterm" id="id300"/>is a scalable cloud development platform that helps developers add functionality to their mobile applications with ease. The patterns and features described in this chapter related to network services such as OData services, offline data storage, push notifications, and OAuth authentication providers are already included in the mobile services SDK and can be configured through the Azure management console.</p><p>In order to demonstrate aforementioned features, we can incorporate them into our demo application.</p><p>The initial step would be to create a mobile service on the Azure management console. For this purpose, we will select a compute service and create the mobile service.</p><div><img alt="Azure Mobile Services" src="img/B04693_05_16.jpg"/><div><p>Create Compute Service</p></div></div><p>Then, we <a class="indexterm" id="id301"/>will set up the mobile service endpoint and create the SQL database to store the online data.</p><div><img alt="Azure Mobile Services" src="img/B04693_05_17.jpg"/><div><p>Mobile Service Setup</p></div></div><p>Once <a class="indexterm" id="id302"/>the setup is complete, the "personalized" service layer project can be downloaded in order to integrate the mobile services into the application project.</p><div><img alt="Azure Mobile Services" src="img/B04693_05_18.jpg"/><div><p>Connect Mobile Services to an existing Xamarin app</p></div></div><p>In the service layer project, you will notice that there is only a single controller created for your convenience. We will be extending the project with additional controllers and adding a reference to our own DTO data model. In order to reuse the types created in the previous sections, instead of referencing the common data model project directly, we add the data type files as a reference to the new service project that we downloaded from the Azure portal. The reason for the referenced files is that the data objects in the service project have to derive from <code class="literal">EntityData</code> class. Another change we need to make is to convert the class definitions to partial and remove the SQLite references, for example, you can comment out the SQLite property descriptors or use conditional compilation.</p><p>In this example, we are using <code class="literal">AZURE</code> as the build constant for the Azure web service.</p><div><pre class="programlisting">public partial class Region
{
    public Region()
    {
        Countries = new List&lt;Country&gt;();
    }

#if !AZURE
    [PrimaryKey]
    [JsonProperty("id")]
    public Guid Id { get; set; }
#endif

#if !AZURE
    [JsonProperty("name")]
#endif
    public string Name { get; set; }

#if !AZURE
    [JsonProperty("continent")]
#endif
    public Continent Continent { get; set; }

#if !AZURE
    [OneToMany(CascadeOperations = CascadeOperation.CascadeInsert | CascadeOperation.CascadeRead)]
    [JsonProperty("countries")]
#endif

    public List&lt;Country&gt; Countries { get; set; } 
}</pre></div><p>Finally, create <a class="indexterm" id="id303"/>a data object definition using a <code class="literal">partial</code> declaration for the <code class="literal">Region</code> class:</p><div><pre class="programlisting">public partial class Region : EntityData
{
}</pre></div><p>After this step, you can simply use the existing project item template for the controller to add the specialized data endpoint (Microsoft Azure Mobile Services Table Controller).</p><div><img alt="Azure Mobile Services" src="img/B04693_05_19.jpg"/><div><p>Microsoft Azure Mobile Services Table Controller</p></div></div><p>This <a class="indexterm" id="id304"/>will create a controller for the data object and insert the type into the data context.</p><p>Once the project is published and the mobile services are running, SQL database tables are going to be migrated automatically. This migration also applies to data table column changes or future additions to the DTO model.</p><p>Now we can add the NuGet package or the component to our client application and add the necessary initialization code, as described in the start page of mobile services section on the Azure management console.</p><p>In the main activity, we create the following mobile service instance:</p><div><pre class="programlisting">public static MobileServiceClient MobileService = new MobileServiceClient(
    "https://traveltrace.azure-mobile.net/",
    "&lt;Removed for security reasons&gt;"
    );</pre></div><p>Add the following to an event handler or the <code class="literal">OnCreate</code> function:</p><div><pre class="programlisting">// Intialization the mobile services on the mobile platform
CurrentPlatform.Init();

// Adding a region item to the database
var item = new Region {Continent = Continent.Europe, Name = "Balkan"};
MobileService.GetTable&lt;Region&gt;().InsertAsync(item).ContinueWith((result) =&gt;
{
    System.Diagnostics.Debug.Write(result.Status);
});</pre></div><p>After the<a class="indexterm" id="id305"/> code is successfully executed, the data on the Azure database can be observed using SQL Management Studio or the Visual Studio SQL Server tools.</p><div><img alt="Azure Mobile Services" src="img/B04693_05_20.jpg"/><div><p>Azure Data Sample</p></div></div><p>Now that we have a working service layer and a client that can communicate with it, we can have a look at the local synchronization.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Azure offline data</h2></div></div></div><p>For local <a class="indexterm" id="id306"/>data caching and offline scenarios, Azure Mobile Services SDK already implements a synchronization framework where the local data is stored in SQLite database and the synchronization is handled by pull and push commands (push requests upload local changes to the cloud store whereas pull requests download the latest changes from the server) using a default conflict handler. Each pull request automatically issues a push request where the local data is pushed to the cloud storage. Conflicts are resolved according to the created and updated fields, which are members of each object type defined using the <code class="literal">EntityData</code> base class.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Before starting the implementation, we need to download and install the Azure Mobile Services SQLiteStore NuGet package.</p></div></div><p>In order to initialize the default local data store, we will use the <code class="literal">MobileServicesSQLiteStore</code> implementation. Custom local store implementation can be incorporated using the <code class="literal">IMobileServiceLocalStore</code> interface.</p><div><pre class="programlisting">private async Task InitLocalStoreAsync()
{
    // new code to initialize the SQLite store
    string path = Path.Combine(
        Environment.GetFolderPath(
        Environment.SpecialFolder.Personal), "traveltrace.db");

    if (!File.Exists(path))
    {
        File.Create(path).Dispose();
    }

    var store = new MobileServiceSQLiteStore(path);
    store.DefineTable&lt;Region&gt;();

    // Uses the default conflict handler, which fails on conflict
    await MobileService.SyncContext.InitializeAsync(store);
}</pre></div><p>After<a class="indexterm" id="id307"/> the local store is initialized and the synchronization context is created, we can implement the synchronization method that can be called every time the application starts.</p><div><pre class="programlisting">private async Task SyncAsync()
{
    // IMobileServiceSyncTable&lt;Region&gt; RegionsTable = MobileService.GetSyncTable&lt;Region&gt;();
    await MobileService.SyncContext.PushAsync();
    await RegionsTable.PullAsync("AllRegions", RegionsTable.CreateQuery());
}</pre></div><p>Both the <code class="literal">PushAsync</code> and <code class="literal">PullAsync</code> methods additionally accept filter expressions so one can limit the synchronization to certain entities.</p><p>In this implementation, once the synchronization context is in place, if the service connection is not available, the <code class="literal">IMobileServiceSyncTable&lt;T&gt;</code> interface implementations handle the offline data and the data is kept in the local store until the next push operation.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Azure authentication</h2></div></div></div><p>The <a class="indexterm" id="id308"/>Azure platform provides various authentication mechanisms for Xamarin mobile applications. Each authentication mechanism can be integrated into existing mobile applications with a service backend through NuGet packages and/or components.</p><p>Being a multi-tenant, cloud-based directory and identity management service, Azure Active Directory (Azure AD) provides application developers an easy way to create single sign-on experience on a large number of cloud SaaS applications. It is also possible to incorporate an existing Windows Server Active Directory into applications and leverage the existing on-premise identity stores. These features make the Azure AD an ideal candidate for LOB applications.</p><p>Another<a class="indexterm" id="id309"/> authentication strategy for Azure Mobile Services is to configure an existing authentication provider such as Facebook, Google, Twitter, or Microsoft and secure the service requests using the Azure Mobile SDK. In order to register an authentication provider, the first step would be to create a consumer app on the target platform.</p><p>For instance, if <a class="indexterm" id="id310"/>we were to use Live ID for our authentication scenarios, we would need to use the Live Connect App management site (<a class="ulink" href="https://account.live.com/developers/applications/index">https://account.live.com/developers/applications/index</a>). Similarly, for Twitter, we <a class="indexterm" id="id311"/>would need to create a Twitter consumer application on the Twitter application management console (<a class="ulink" href="https://apps.twitter.com/">https://apps.twitter.com/</a>).</p><div><img alt="Azure authentication" src="img/B04693_05_21.jpg"/><div><p>Live Connect app management site</p></div></div><p>Once the application setup is in place, the Azure management console can be used to update the mobile services configuration.</p><div><img alt="Azure authentication" src="img/B04693_05_22.jpg"/><div><p>Mobile Services Identity Configuration</p></div></div><p>After the<a class="indexterm" id="id312"/> identity provider for the mobile services has been set up, the web service project can be easily protected simply by adding the Authorize attribute.</p><div><pre class="programlisting">[AuthorizeLevel(AuthorizationLevel.User)]
public class RegionController : TableController&lt;Region&gt;</pre></div><p>On the client apps, the authentication is handled by simply using the <code class="literal">LoginAsync</code> method on the Azure Mobile Services SDK client with the correct authentication provider.</p><div><pre class="programlisting">MobileService.LoginAsync(this, MobileServiceAuthenticationProvider.MicrosoftAccount).ContinueWith((task) =&gt;
{
    System.Diagnostics.Debug.WriteLine("Currently authenticated user's ID is {0}", task.Result.UserId);
});</pre></div><p>The result is the same authentication screen received using the Xamarin.Auth component.</p><div><img alt="Azure authentication" src="img/B04693_05_23-1.jpg"/><div><p>Brokered Authentication</p></div></div><p>Azure<a class="indexterm" id="id313"/> Cloud integration scenarios extend far beyond the ones described here. The features that are included in this cloud-based development platform can help developers enhance their Xamarin apps with ease and scalability.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Summary</h1></div></div></div><p>This chapter provided an overview of various network channels that can be used in Xamarin applications to create connected applications.</p><p>Web services are definitely on the essentials list for modern mobile applications because of the interoperability of the protocols in place for web services (both SOAP/XML and REST/JSON). Unfortunately, XML services are a little harder to integrate with Windows Phone 8.1 runtime (even though they are still supported by Windows Phone Silverlight runtime) because the Windows Communication Foundation client infrastructure is not included in Windows Phone runtime. However, the same RESTful service proxies can be used by applications on each Xamarin target platform and Windows Phone.</p><p>Cloud integration options such as mobile services and Azure Active Directory were discussed with demonstration samples. Each of these technologies provides additional connectivity and integration opportunities for Xamarin mobile apps. SignalR is another web technology that grants additional communication capabilities to mobile applications by means of bidirectional communication between the client apps and the server.</p><p>Several common service and web implementation patterns were demonstrated using the TravelTrace application scope that we will be using for various scenarios in the remainder of this book. Each pattern described targets different quality identifiers initially mentioned.</p><p>Finally, we discussed some of the platform-specific network options.</p></div></body></html>