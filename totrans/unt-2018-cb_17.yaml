- en: Working with Plain Text, XML, and JSON Text Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与纯文本、XML 和 JSON 文本文件一起工作
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Loading external text files using the TextAsset public variable
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TextAsset 公共变量加载外部文本文件
- en: Loading external text files using C# file streams
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 文件流加载外部文本文件
- en: Saving external text files with C# file streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 文件流保存外部文本文件
- en: Loading and parsing external XML files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和解析外部 XML 文件
- en: Creating XML text data manually using XMLWriter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XMLWriter 手动创建 XML 文本数据
- en: Saving and Loading XML text data automatically through serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过序列化自动保存和加载 XML 文本数据
- en: Creating XML text files, and saving XML directly to text files with XMLDocument.Save()
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XMLDocument.Save() 将 XML 直接保存到文本文件中创建 XML 文本文件
- en: Creating JSON strings from individual objects and lists of objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单个对象和对象列表创建 JSON 字符串
- en: Creating individual objects and lists of objects from JSON strings
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 JSON 字符串创建单个对象和对象列表
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Text-based external data is very common and very useful as it is both computer-
    and human- readable. Text files may be used to allow non-technical team members
    to edit written content or for recording game performance data during development
    and testing. Text-based formats also permit **serialization**—the encoding of
    live object data suitable for transmission, storing, and later retrieval.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文本的外部数据非常常见且非常有用，因为它既适合计算机阅读也适合人类阅读。文本文件可以用来允许非技术团队成员编辑书面内容，或者在开发和测试期间记录游戏性能数据。基于文本的格式还允许**序列化**——将实时对象数据编码成适合传输、存储和以后检索的格式。
- en: 'Unity treats all of the following (and also C# scripts) as **Text Assets**:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 将以下所有内容（以及 C# 脚本）视为**文本资产**：
- en: '`.txt`: Plain text file'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.txt`：纯文本文件'
- en: '`.html`, `.htm`: HTML page markup (HyperText Markup Language)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.html`、`.htm`：HTML 页面标记（超文本标记语言）'
- en: '`.xml`: XML data (eXtensible Markup Language)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xml`：XML 数据（可扩展标记语言）'
- en: '`.bytes`: Binary data (accessed through bytes property)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bytes`：二进制数据（通过 bytes 属性访问）'
- en: '`.json`: JSON (JavaScript Object Notation)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.json`：JSON（JavaScript 对象表示法）'
- en: '`.csv`: CSV (Comma Separate Variable)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.csv`：CSV（逗号分隔变量）'
- en: '`.yaml`: YAML Ain''t Markup Language'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.yaml`：YAML 不是标记语言'
- en: '`.fnt`: Bitmap font data (with associated image texture file)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fnt`：位图字体数据（与相关的图像纹理文件）'
- en: 'To learn more about Unity Text Assets in the manual pages, click on the following
    link: [https://docs.unity3d.com/Manual/class-TextAsset.html](https://docs.unity3d.com/Manual/class-TextAsset.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Unity 文本资产的手册页面，请点击以下链接：[https://docs.unity3d.com/Manual/class-TextAsset.html](https://docs.unity3d.com/Manual/class-TextAsset.html)。
- en: 'Many web-based systems use XML for asynchronous communications without requiring
    user interaction, leading to the term **AJAX**: **Asynchronous JavaScript XML**.
    Some modern web-based systems now use JSON for text-based communication. For this
    reason, this chapter puts special focus on these two text file formats.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于网络的系统使用 XML 进行异步通信，而不需要用户交互，因此产生了术语**AJAX**：**异步 JavaScript XML**。一些现代基于网络的系统现在使用
    JSON 进行基于文本的通信。因此，本章特别关注这两种文本文件格式。
- en: The Big picture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体图景
- en: 'Apart from plain text, there are two common text interchange file formats:
    XML and JSON. Each is discussed and illustrated through recipe examples in this
    chapter.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯文本之外，还有两种常见的文本交换文件格式：XML 和 JSON。本章将讨论并举例说明这两种格式。
- en: XML – the eXtensible markup language
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML – 可扩展标记语言
- en: 'XML is a meta-language, that is, a set of rules that allows markup languages
    to be created to encode specific kinds of data. Some examples of data-description
    language formats using the XML syntax include the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是一种元语言，即一组规则，允许创建标记语言来编码特定类型的数据。以下是一些使用 XML 语法的数据描述语言格式示例：
- en: '`.txt`: Plain text file'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.txt`：纯文本文件'
- en: '`.html`, `.htm`: HTML page markup (HyperText Markup Language)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.html`、`.htm`：HTML 页面标记（超文本标记语言）'
- en: '`.xml`: XML data (eXtensible Markup Language)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xml`：XML 数据（可扩展标记语言）'
- en: '`SVG`: Scalable Vector Graphics—an open standard method of describing graphics
    supported by the Worldwide Web consortium'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SVG`：可缩放矢量图形——一个由万维网联盟支持的开放标准图形描述方法'
- en: '`SOAP`: Simple Object Access Protocol for the exchange of messages between
    computer programs and web services'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOAP`：用于在计算机程序和 Web 服务之间交换消息的简单对象访问协议'
- en: '`X3D`: Xml 3D—an ISO standard for representing 3D objects—it is the successor
    to **VRML** (**Virtual Reality Modeling Language**)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X3D`：Xml 3D——一个用于表示 3D 对象的 ISO 标准——它是 **VRML**（**虚拟现实建模语言**）的继任者'
- en: JSON – the JavaScript object notation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON – JavaScript 对象表示法
- en: 'JSON is sometimes referred to as the *fat-free alternative to XML*—offering
    similar data interchange strengths, but being smaller, and simpler, both by not
    offering extensibility and using just three characters for formatting:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSON有时被称为XML的“无脂肪替代品”——提供类似的数据交换强度，但更小、更简单，因为它不提供可扩展性，并且仅使用三个字符进行格式化：
- en: '`property : value`: the colon character separates a property name form its
    value'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性 : 值`：冒号字符用于分隔属性名称和其值'
- en: '`{ }`: braces are for an object'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ }`：花括号用于表示对象'
- en: '`[ ]`: square brackets are for an array of values/objects'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]`：方括号用于表示值/对象的数组'
- en: You can read more about JSON versus XML at [https://www.json.org/xml.html](https://www.json.org/xml.html)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.json.org/xml.html](https://www.json.org/xml.html)了解更多关于JSON与XML的信息
- en: In Chapter 10, *Working with External Resource Files*, several methods for loading
    external resource files were demonstrated, which work for image, audio, and text
    resources. In this chapter, several additional methods for loading text files
    in particular are presented.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章“处理外部资源文件”中，演示了加载外部资源文件的方法，这些方法适用于图像、音频和文本资源。在本章中，还介绍了加载文本文件的一些额外方法。
- en: In [Chapter 13](80a35b7a-7c45-4b18-adcf-b9c99c2e486d.xhtml),  *Shader Graphs
    and Video Players*, some recipes illustrate the use of JSON for a database-driven
    web leaderboard, and Unity game communication with that leaderboard.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](80a35b7a-7c45-4b18-adcf-b9c99c2e486d.xhtml)，“着色器图和视频播放器”，一些示例说明了如何使用JSON为数据库驱动的网页排行榜，以及Unity游戏与该排行榜的通信。
- en: Loading external text files using the TextAsset public variable
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TextAsset公共变量加载外部文本文件
- en: A straightforward way to store data in text files and then choose between them
    before compiling is to use a public variable of the class `TextAsset`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是将数据存储在文本文件中，然后在编译前选择它们，可以使用类`TextAsset`的公共变量。
- en: This technique is only appropriate when there will be no change to the data
    file after game compilation, since the text file data is serialized (mixed into)
    the general build resources, and so cannot be changed after the build has been
    created.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术仅在游戏编译后数据文件不会发生变化时适用，因为文本文件数据是序列化的（混合到）通用构建资源中，因此构建创建后无法更改。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you''ll need a text `(.txt`) file. In the `11_01` folder,
    we have provided two such files:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要一个文本`(.txt)`文件。在`11_01`文件夹中，我们提供了两个这样的文件：
- en: '`cities.txt`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cities.txt`'
- en: '`countries.txt`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`countries.txt`'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To load external text files using `TextAsset`, perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`TextAsset`加载外部文本文件，请执行以下步骤：
- en: Create a new 2D project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的2D项目。
- en: Create a **UI TextGameObject**, center it on screen with the **Rect Transform**,
    and set its horizontal and vertical overflow to overflow.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**UI TextGameObject**，使用**Rect Transform**将其居中显示在屏幕上，并设置其水平和垂直溢出为溢出。
- en: Import the text file you wish to use into your project (for example, `cities.txt`)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你希望使用的文本文件导入到你的项目中（例如，`cities.txt`）
- en: 'Create a C# `ReadPublicTextAsset` script class and attach an instance as a
    component to your **UI Text GameObject**:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C# `ReadPublicTextAsset`脚本类，并将其作为组件附加到你的**UI Text GameObject**：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With **Ma****in Camera** selected in the **Hierarchy** view, drag the `cities.txt`
    file into the public string variable `dataTextFile` in the **Inspector**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**视图中选择**Main Camera**，将`cities.txt`文件拖放到**Inspector**中的公共字符串变量`dataTextFile`。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the scene starts, the text content of the text file is read into variable
    `textFromFile`. A reference is found to the **UI Text** component, and the text
    property of that UI component is set to be the content of `textFromFile`. The
    user can then see the content of the text file displayed in the middle of the
    screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景开始时，文本文件的内容被读取到变量`textFromFile`中。找到**UI Text**组件的引用，并将该UI组件的文本属性设置为`textFromFile`的内容。用户可以随后在屏幕中间看到文本文件的内容。
- en: Loading external text files using C# file streams
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#文件流加载外部文本文件
- en: For standalone executable games that both read from and write to (create or
    change) text files, **.NET** data streams are often used for both reading and
    writing. This recipe illustrates how to read a text file, while the next recipe
    illustrates how to write text data to files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于既从文本文件中读取又向文本文件中写入（创建或更改）的独立可执行游戏，通常使用**.NET**数据流进行读写。本示例说明了如何读取文本文件，而下一个示例将说明如何将文本数据写入文件。
- en: This technique only works when you compile to a Windows or Mac standalone executable;
    it will not work for **WebGL** builds, for example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术仅在将编译为Windows或Mac独立可执行文件时有效；例如，它不会为**WebGL**构建工作。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need a text file; two have been provided in the `11_01`
    folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此菜谱，您需要一个文本文件；在`11_01`文件夹中提供了两个文件。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To load external text files using C# file streams, perform the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用C#文件流加载外部文本文件，请执行以下步骤：
- en: 'Create a new C# script-class `FileReadWriteManager`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类`FileReadWriteManager`：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a C# `ReadWithStream` script class and attach an instance as a component
    to your **UI Text GameObject**:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C# `ReadWithStream`脚本类并将其实例作为组件附加到您的**UI Text GameObject**：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the current scene and then add this to the list of scenes in the build.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景并将其添加到构建的场景列表中。
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行您的（Windows、Mac或Linux）独立可执行文件。
- en: Copy the text file containing your data into your standalone's `Resources` folder
    (that is, the filename you set in the first statement in the `Start()` method—in
    our listing, this is the `cities.txt` file).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含您数据的文本文件复制到您的独立应用程序的`Resources`文件夹中（即`Start()`方法中设置的第一个语句中的文件名——在我们的示例中，这是`cities.txt`文件）。
- en: You will need to place the files in the `Resources` folder manually after every
    compilation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每次编译后，您都需要手动将文件放置在`Resources`文件夹中。
- en: 'For Windows and Linux users: When you create a Windows or Linux standalone
    executable, there is a `_Data` folder that is created with the executable application
    file. The `Resources` folder can be found inside this data folder.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows和Linux用户：当您创建Windows或Linux独立可执行文件时，会创建一个包含可执行应用程序文件的数据文件夹`_Data`。`Resources`文件夹位于此数据文件夹内部。
- en: 'For Mac users: A Mac standalone application executable looks like a single
    file, but it is actually a macOS "package" folder. Right-click on the executable
    file and select Show Package Contents. You will then find the standalone''s Resources
    folder inside the Contents folder.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac用户：Mac独立应用程序的可执行文件看起来像一个单独的文件，但实际上是一个macOS "包"文件夹。右键单击可执行文件并选择显示包内容。然后您将在Contents文件夹内找到独立应用程序的Resources文件夹。
- en: When you run your built executable, you should see the text file content loaded
    and displayed in the middle of the application window.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行构建的可执行文件时，您应该在应用程序窗口的中间看到加载并显示的文本文件内容。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the game runs, the `Start()` method creates the `filePath` string and then
    calls the `ReadTextFile()` method from the `fileReadWriteManager` object, to which
    it passes the filePath string. This method reads the content of the file and returns
    them as a string, which is stored in the `textFileContents` variable. Our `OnGUI()`
    method displays the values of these two variables (`filePath` and `textFileContents`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏运行时，`Start()`方法创建`filePath`字符串，然后从`fileReadWriteManager`对象调用`ReadTextFile()`方法，并将filePath字符串传递给它。此方法读取文件内容，并将其作为字符串返回，存储在`textFileContents`变量中。我们的`OnGUI()`方法显示这两个变量的值（`filePath`和`textFileContents`）。
- en: Note the need to use the `System.IO` package for this recipe. The C# script
    `FileReadWriteManager.cs` contains two general purpose file read and write methods
    that you may find useful in many different projects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此菜谱需要使用`System.IO`包。C#脚本`FileReadWriteManager.cs`包含两个通用的文件读写方法，您可能会在许多不同的项目中找到它们很有用。
- en: Saving external text files with C# file streams
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#文件流保存外部文本文件
- en: This recipe illustrates how to use C# streams to write text data to a text file,
    either into the standalone project's `Data` folder or to the `Resources` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱说明了如何使用C#流将文本数据写入文本文件，无论是写入独立项目的`Data`文件夹还是`Resources`文件夹。
- en: This technique only works when you compile to a Windows or Mac standalone executable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术仅在将编译为Windows或Mac独立可执行文件时有效。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the `11_02` folder, we have provided a text file containing the completed
    C# script class created in the previous recipe:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`11_02`文件夹中，我们提供了一个包含之前菜谱中创建的完成C#脚本类的文本文件：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To save external text files using C# file streams, follow these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用C#文件流保存外部文本文件，请按照以下步骤操作：
- en: Create a new 2D project.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的2D项目。
- en: Import the C# `FileReadWriteManager.cs` script class into your project.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C# `FileReadWriteManager.cs`脚本类导入到您的项目中。
- en: 'Add the following C# `SaveTextFile` script class to the **Main Camera**:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C# `SaveTextFile`脚本类添加到**主相机**：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the current scene and then add this to the list of scenes in the build.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景并将其添加到构建的场景列表中。
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行你的（Windows、Mac或Linux）独立可执行文件。
- en: After running the built executable, you should now find a new text file named
    `hello.txt` in the `Data` folder of your project's standalone files, containing
    the lines hello and and goodbye
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行构建好的可执行文件后，你现在应该能在你的项目独立文件中的`Data`文件夹里找到一个名为`hello.txt`的新文本文件，其中包含hello和goodbye两行。
- en: '![](img/67d41db9-a45d-42d8-ae2f-c5d5a3c59641.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67d41db9-a45d-42d8-ae2f-c5d5a3c59641.png)'
- en: It is possible to test this when running within the Unity editor (that is, before
    building a standalone application). To test this way, you'll need to create a
    `Data` folder in your project panel.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity编辑器内运行时可以测试这一点（即在构建独立应用程序之前）。要这种方式测试，你需要在项目面板中创建一个`Data`文件夹。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the game runs, the `Start()` method creates the `filePath` string from
    the public variables `fileName` and `folderName`, and then calls the `WriteTextFile()`
    method from the `fileReadWriteManager` object, to which it passes the `filePath`
    and `textData` strings. This method creates (or overwrites) a text file (for the
    given file path and filename) containing the string data received.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏运行时，`Start()`方法从公共变量`fileName`和`folderName`创建`filePath`字符串，然后从`fileReadWriteManager`对象调用`WriteTextFile()`方法，并将`filePath`和`textData`字符串传递给它。此方法创建（或覆盖）一个包含接收到的字符串数据的文本文件（对于给定的文件路径和文件名）。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following are some details you don't want to miss.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你不希望错过的细节。
- en: Choosing the Data or the Resources folder
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据或资源文件夹
- en: Standalone build applications contain both a `Data` folder and a `Resources`
    folder. Either of these can be used for writing (or some other folder, if desired).
    We generally put read-only files into the `Resources` folder and use the `Data`
    folder for files that are to be created from scratch or that have had their content
    changed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 独立构建的应用程序包含一个`Data`文件夹和一个`Resources`文件夹。这两个文件夹中的任何一个都可以用于写入（或如果需要，其他文件夹）。我们通常将只读文件放入`Resources`文件夹，并使用`Data`文件夹来创建从头开始创建或内容已更改的文件。
- en: Before you build your executable, you can specify a different file and folder
    name (for example, `Resources` instead of `Data`). Ensure the **Main Camera GameObject**
    is selected in the **Hierarchy**, and then change the values in those public variables
    in the **Inspector** component Save text File (Script).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的可执行文件之前，你可以指定不同的文件和文件夹名称（例如，`Resources`而不是`Data`）。确保在**层次结构**中选择了**主摄像机GameObject**，然后更改**检查器**组件中的那些公共变量在保存文本文件（脚本）中的值。
- en: Loading and parsing external XML
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和解析外部XML
- en: It is useful to be able to parse (process the content of) text files and strings
    containing data in the XML format. C# offers a range of classes and methods to
    make such processing straightforward, which we'll explore in this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 能够解析（处理包含XML格式数据的文本文件和字符串）非常有用。C#提供了一系列类和方法来简化此类处理，我们将在本食谱中探讨。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You''ll find player name and score data in XML format in the `playerScoreData.xml`
    file in the `11_04` folder. The content of this file is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`11_04`文件夹中的`playerScoreData.xml`文件中找到以XML格式存储的玩家姓名和分数数据。此文件的内容如下：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The data is structured by a root element named `scoreRecordList`, which contains
    a sequence of `scoreRecord` elements. Each `scoreRecord` element contains a player
    element (which contains a player's name), a score element (which has the integer
    content of the player's score), and a date element, which itself contains three
    child elements – day, month, and year.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过一个名为`scoreRecordList`的根元素进行结构化，该元素包含一系列`scoreRecord`元素。每个`scoreRecord`元素包含一个玩家元素（其中包含玩家的名字），一个分数元素（包含玩家的分数的整数值），以及一个日期元素，该日期元素本身包含三个子元素
    - 天、月和年。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To load and parse external XML files, follow these steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载和解析外部XML文件，请按照以下步骤操作：
- en: 'Create a C# `PlayerScoreDate` script class containing the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的C# `PlayerScoreDate`脚本类：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a C# `ParseXML` script class and attach an instance as a component to
    the **Main Camera**:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C# `ParseXML`脚本类并将其实例作为组件附加到**主摄像机**：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the scene, and the output of the `print()` statements should be visible
    in the Console window:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景，`print()`语句的输出应该在控制台窗口中可见：
- en: '![](img/7e7b5cdc-274f-4065-bbec-6eb17cad6056.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e7b5cdc-274f-4065-bbec-6eb17cad6056.png)'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `PlayerScoreDate` script class simply contains the three pieces of data
    for player-dated scores:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreDate`脚本类仅包含玩家按日期计分的三个数据项：'
- en: The player's name (string)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的名字（字符串）
- en: The player's score (integer)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的分数（整数）
- en: The date the score was recorded (string—to keep this recipe short...)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录分数的日期（字符串——为了使这个食谱简短...）
- en: Note the need to use the `System`, `System.Xml` and `System.IO` packages for
    the C# `ParseXML` script class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 C# `ParseXML` 脚本类，需要使用 `System`、`System.Xml` 和 `System.IO` 包。
- en: The `text` property of the `TextAsset` variable `scoreDataTextFile` provides
    the content of the XML file as a string, which is passed to the `ParseScoreXML(...)`
    method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextAsset` 变量 `scoreDataTextFile` 的 `text` 属性提供了 XML 文件的内容作为字符串，该字符串传递给 `ParseScoreXML(...)`
    方法。'
- en: This `ParseScoreXML(...)` method creates a new `XmlDocument` variable with the
    content of this string. The `XmlDocument` class provides the `SelectNodes()` method,
    which returns a list of node objects for a given element path. In this example,
    a list of `scoreRecord` nodes is requested. A for-each statement loops for each
    scoreRecord, passing the current node to method `NodeToPlayerScoreObject(...),`
    and storing the returned object into the next slot in the `playerScores `array.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `ParseScoreXML(...)` 方法使用此字符串的内容创建一个新的 `XmlDocument` 变量。`XmlDocument` 类提供了
    `SelectNodes()` 方法，该方法返回给定元素路径的节点对象列表。在此示例中，请求了一个 `scoreRecord` 节点列表。一个 for-each
    语句循环遍历每个 `scoreRecord`，将当前节点传递给 `NodeToPlayerScoreObject(...)` 方法，并将返回的对象存储在 `playerScores`
    数组的下一个槽位中。
- en: The `NodeToPlayerScoreObject(...)` method relies on the ordering of the XML
    elements to retrieve the player's name, score, and data strings. The score string
    is parsed into an integer, and the date node is converted to a date string using
    method `NodeToDateString(...)`. A new `PlayerScoreDate` object is created, and
    the name, score and date stored in it, and then that object is returned.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodeToPlayerScoreObject(...)` 方法依赖于 XML 元素的顺序来检索玩家的姓名、分数和数据字符串。分数字符串被解析为整数，日期节点使用方法
    `NodeToDateString(...)` 转换为日期字符串。创建一个新的 `PlayerScoreDate` 对象，并将名称、分数和日期存储在其中，然后返回该对象。'
- en: The `NodeToDateString(...)` method creates a date string as a slash-separated
    string by parsing the node containing the three date components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodeToDateString(...)` 方法通过解析包含三个日期组件的节点来创建一个日期字符串，以斜杠分隔。'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: The following are some details you don't want to miss.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你不希望错过的细节。
- en: Retrieving XML data files from the web
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络检索 XML 数据文件
- en: You can use the WWW Unity class if the XML file is located on the web rather
    than in your Unity project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 XML 文件位于网络上而不是你的 Unity 项目中，可以使用 WWW Unity 类。
- en: Creating XML text data manually using XMLWriter
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XMLWriter 手动创建 XML 文本数据
- en: One way to create XML data structures from game objects and properties is by
    hand-coding a method to create each element and its content, using the `XMLWriter`
    class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从游戏对象和属性创建 XML 数据结构的一种方法是通过手动编码一个方法来创建每个元素及其内容，使用 `XMLWriter` 类。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create XML text data using `XMLWriter`, follow these steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `XMLWriter` 创建 XML 文本数据，请按照以下步骤操作：
- en: 'Create a C# `CreateXMLString` script class to add an instance as a component
    to the **Main Camera**:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 C# `CreateXMLString` 脚本类，将其作为组件添加到 **主相机**：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The XML text data should be visible in the Console panel when the scene is
    run, and should look as follows (some newline characters have been added to make
    the output more human-readable...):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当场景运行时，XML 文本数据应在控制台面板中可见，并且应如下所示（添加了一些换行符以使输出更易于阅读...）：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Start()` method calls `BuildXMLString()` and stores the returned string
    in the output variable. This output text is then printed to the Console debug
    panel.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法调用 `BuildXMLString()` 并将返回的字符串存储在输出变量中。然后，将此输出文本打印到控制台调试面板。'
- en: The `BuildXMLString()` method creates a `StringWriter` object, into which `XMLWriter`
    builds the string of XML elements. The XML document starts and ends with the `WriteStartDocument()`
    and `WriteEndDocument()` methods. Elements start and end with `WriteStartElement()`
    and `WriteEndElement().` String content for an element is added using `WriteElementString().`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildXMLString()` 方法创建一个 `StringWriter` 对象，`XMLWriter` 将 XML 元素的字符串构建到该对象中。XML
    文档以 `WriteStartDocument()` 和 `WriteEndDocument()` 方法开始和结束。元素以 `WriteStartElement()`
    和 `WriteEndElement()` 方法开始和结束。使用 `WriteElementString()` 添加元素的内容。'
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Here are some details that you won't want to miss.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些细节，你不想错过。
- en: Adding new lines to make XML strings more human readable.
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新行以使 XML 字符串更易于阅读。
- en: 'After every instance of the `WriteStartElement()` and `WriteElementString()`
    methods, you can add a newline character using `WriteWhiteSpace().` These are
    ignored by XML parsing methods, but if you intend to display the XML string for
    a human to see, the presence of the new line''s characters makes it much more
    readable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用`WriteStartElement()`和`WriteElementString()`方法之后，你可以使用`WriteWhiteSpace()`添加一个换行符。这些在XML解析方法中被忽略，但如果你的意图是显示给人类看的XML字符串，新行字符的存在会使它更容易阅读：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Making data class responsible for creating XML from list
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使数据类负责从列表创建XML
- en: The XML to be generated is often from a list of objects, all of the same class.
    In this case, it makes sense to make the class of the objects responsible for
    generating the XML for a list of those objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成的XML通常来自对象列表，所有对象都是同一类。在这种情况下，让负责为这些对象的列表生成XML的对象类是有意义的。
- en: The `CreateXMLFromArray` class simply creates an instance of `List<T>` containing
    `PlayerScore` objects, and then calls the (static) method `ListToXML(),` passing
    in the list of objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateXMLFromArray`类简单地创建一个包含`PlayerScore`对象的`List<T>`实例，然后调用（静态）方法`ListToXML()`，传入对象列表。'
- en: 'The following should be a single block of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应该是一个单独的代码块：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All the hard work is now the responsibility of the `PlayerScore` class. This
    class has two private variables for the player''s name and score and a constructor
    that accepts values for these properties. The public static method `ListToXML()`
    takes a `List` object as an argument, and uses `XMLWriter` to build the XML string,
    looping through each object in the list and calling the object''s `ObjectToElement()`
    method. This method adds an XML element to the `XMLWriter` argument received for
    the data in that object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有艰苦的工作现在都由`PlayerScore`类负责。这个类有两个用于玩家姓名和得分的私有变量，以及一个接受这些属性值的构造函数。公共静态方法`ListToXML()`接受一个`List`对象作为参数，并使用`XMLWriter`构建XML字符串，遍历列表中的每个对象，并调用对象的`ObjectToElement()`方法。这个方法向接收该对象数据的`XMLWriter`参数添加一个XML元素：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Saving and loading XML text data automatically through serialization
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过序列化自动保存和加载XML文本数据
- en: Another way to work with XML data structures from game objects and properties
    is by serializing the content of an object automatically. This technique automatically
    generates XML for all the public properties of an object. This recipe uses the
    `XmlSerializer` class that can be found in the standard `System.Xml` C# package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种从游戏对象和属性中处理XML数据结构的方法是通过自动序列化对象的内容。这种技术会自动为对象的公共属性生成XML。这个配方使用了可以在标准`System.Xml`
    C#包中找到的`XmlSerializer`类。
- en: 'This recipe has been adapted from this 2013 (still works!) Unify Community
    Wiki article: [http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer](http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是从这篇2013年（仍然有效！）Unify社区维基文章改编的：[http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer](http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer)
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the `11_06` folder, you'll find two XML data files, allowing you to test
    the reader with different XML text file data files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`11_06`文件夹中，你会找到两个XML数据文件，允许你使用不同的XML文本文件数据文件测试读取器。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create XML text data through serialization, perform the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过序列化创建XML文本数据，请执行以下步骤：
- en: 'Create a C# `PlayerScore` script class:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C# `PlayerScore`脚本类：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a C# `PlayerScoreCollection` scrip class:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C# `PlayerScoreCollection`脚本类：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a C# `XmlWriter` script class and attach an instance as a component
    to the **Main Camera**:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C# `XmlWriter`脚本类，并将其实例作为组件附加到**主摄像机**：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can quickly test the scene in the Unity Editor if you create a `Data` folder
    in the Project panel and then run the scene. After 10-20 seconds, you should now
    find that text file `playerData.xml` has been created in the `Data` folder.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你能在项目面板中创建一个名为`Data`的文件夹，然后运行场景，你就可以快速在Unity编辑器中测试场景。大约10-20秒后，你应该会发现在`Data`文件夹中已经创建了一个名为`playerData.xml`的文本文件。
- en: Save the current scene and then add this to the list of scenes in the build.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景，然后将其添加到构建场景列表中。
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行你的（Windows、Mac或Linux）独立可执行文件。
- en: You should now find a new text file named `playerData.xml` in the `Data` folder
    of your project's standalone files, containing the XML data for the three players.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能在你的项目独立文件中的`Data`文件夹中找到一个名为`playerData.xml`的新文本文件，其中包含三个玩家的XML数据。
- en: 'The content of the `playerData.xml` file should be the XML player list data,
    that is:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`playerData.xml` 文件的内容应该是 XML 玩家列表数据，即：'
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Start()` method of class `XmlWriter` defines the file path (`Data/playerData.xml`)
    and creates a new `PlayerScoreCollection` object psc, by invoking the method `CreatePlayScoreCollection().`
    The Save(...) method of the `PlayerScoreCollection` object is then invoked, passing
    the file path.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `XmlWriter` 的 `Start()` 方法定义了文件路径（`Data/playerData.xml`），并通过调用 `CreatePlayScoreCollection()`
    方法创建一个新的 `PlayerScoreCollection` 对象 psc。然后调用 `PlayerScoreCollection` 对象的 `Save(...)`
    方法，传递文件路径。
- en: 'The `CreatePlayScoreCollection()` method of class `XmlWriter` creates a new
    `PlayerScoreCollection`, and inserts into this an array of two `PlayerScore` objects
    with name/score/version values as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `XmlWriter` 的 `CreatePlayScoreCollection()` 方法创建一个新的 `PlayerScoreCollection`，并向其中插入一个包含两个
    `PlayerScore` 对象的数组，这些对象具有以下名称/分数/版本值：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Save(...)` method of class `PlayerScoreCollection` creates a new `XmlSerializer`
    for the class type, and uses a `FileStream` to tell C# to serialize the content
    of the `PlayerScoreCollection` object (that is, its array of `PlayerScore` objects)
    as text to that file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreCollection` 类的 `Save(...)` 方法为类类型创建一个新的 `XmlSerializer`，并使用 `FileStream`
    告诉 C# 将 `PlayerScoreCollection` 对象（即其 `PlayerScore` 对象数组）的内容序列化为文本到该文件。'
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some details you don't want to miss.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的细节。
- en: Defining the XML node names
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 XML 节点名称
- en: 'We can use compiler statements to define the XML element name that will be
    used to encode each object property. For example, we have defined element Name
    (with a capital letter N) for the name property of each `PlayerScore`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用编译器语句来定义用于编码每个对象属性的 XML 元素名称。例如，我们为每个 `PlayerScore` 的名称属性定义了元素 Name（首字母大写
    N）：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If this hadn't been declared, then the XML Serializer would have defaulted to
    the lowercase property name `name` for these data elements.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有声明，那么 XML 序列化器将默认使用小写属性名 `name` 为这些数据元素。
- en: Loading data objects from XML text
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 XML 文本加载数据对象
- en: We can write static (class) methods for class `PlayerScoreCollection` that use
    the `XML``Serializer` to load XML data and create data objects from that loaded
    data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 `PlayerScoreCollection` 类编写静态（类）方法，这些方法使用 `XML` 序列化器来加载 XML 数据，并从加载的数据创建数据对象。
- en: 'Here is a method to load from a filepath:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个从文件路径加载的方法：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another method can be written to load from a text string:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写另一个方法从文本字符串加载：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For example, you could create a public `TextAsset` variable, and then create
    a `PlayerScoreCollection` object by invoking this static method, then loop through
    and print out the loaded objects with code such as the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个公共的 `TextAsset` 变量，然后通过调用此静态方法创建一个 `PlayerScoreCollection` 对象，然后通过以下代码循环遍历并打印出加载的对象：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating XML text files – saving XML directly to text files with XMLDocument.Save()
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 XML 文本文件 – 使用 XMLDocument.Save() 直接将 XML 保存到文本文件
- en: It is possible to create an XML data structure and then save that data directly
    to a text file using the `XMLDocument.Save()` method; this recipe illustrates
    how.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建一个 XML 数据结构，然后使用 `XMLDocument.Save()` 方法直接将该数据保存到文本文件；这个配方说明了如何做。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To save XML data to text files directly, perform the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接将 XML 数据保存到文本文件，请执行以下步骤：
- en: 'Create a new C# `PlayerXMLWriter` script class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# `PlayerXMLWriter` 脚本类：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a C# `CreateXMLTextFile` script class and attach an instance as a component
    to the **Main Camera**:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 C# `CreateXMLTextFile` 脚本类，并将其实例作为组件附加到 **主相机**：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can quickly test the scene in the Unity Editor if you create a `Data` folder
    in the Project panel and then run the scene. After 10-20 seconds, you should now
    find that text file `playerData.xml` has been created in the `Data` folder.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个名为 `Data` 的文件夹中创建一个 `Data` 文件夹并在 Unity 编辑器中运行场景，你可以快速测试场景。大约 10-20 秒后，你应该现在在
    `Data` 文件夹中找到一个名为 `playerData.xml` 的文本文件。
- en: Save the current scene and then add this to the list of scenes in the build.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景，然后将其添加到构建的场景列表中。
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行你的（Windows、Mac 或 Linux）独立可执行文件。
- en: 'You should now find a new text file named `playerData.xml` in the `Data` folder
    of your project''s standalone files, containing the XML data for the three players:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该在项目的独立文件 `Data` 文件夹中找到一个名为 `playerData.xml` 的新文本文件，其中包含三个玩家的 XML 数据：
- en: 'The content of the `playerData.xml` file should be the XML player list data:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`playerData.xml` 文件的内容应该是 XML 玩家列表数据：'
- en: '![](img/921244fb-5937-498c-944b-9212e785db90.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/921244fb-5937-498c-944b-9212e785db90.png)'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Start()` method creates `playerXMLWriter`, a new object of the `PlayerXMLWriter`
    class, to which it passes the new, required XML text file `filePath` as an argument.
    Three elements are added to the `PlayerXMLWriter` object, which store the names
    and scores of three players. The `SaveXMLFile()` method is called and a debug
    `print()` message is displayed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法创建 `playerXMLWriter`，这是 `PlayerXMLWriter` 类的新对象，它将新的、必需的 XML 文件路径
    `filePath` 作为参数传递。向 `PlayerXMLWriter` 对象添加了三个元素，用于存储三个玩家的姓名和分数。调用 `SaveXMLFile()`
    方法并显示一个调试 `print()` 消息。'
- en: 'The constructor method of the `PlayerXMLWriter` class works as follows: when
    a new object is created, the provided file path string is stored in a private
    variable; at the same time, a check is made to see whether any file already exists.
    If an existing file is found, the content elements are removed; if no existing
    file is found, then a new root element, `playerScoreList`, is created as the parent
    for child data nodes. The method `AddXMLElement()` appends a new data node for
    the provided player name and score. The method `SaveXMLFile()` saves the XML data
    structure as a text file for the stored file path string.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerXMLWriter` 类的构造函数方法如下：当创建一个新对象时，提供的文件路径字符串存储在一个私有变量中；同时，检查是否已存在任何文件。如果找到现有文件，则删除内容元素；如果没有找到现有文件，则创建一个新的根元素
    `playerScoreList` 作为子数据节点的父元素。`AddXMLElement()` 方法为提供的玩家姓名和分数追加一个新的数据节点。`SaveXMLFile()`
    方法将 XML 数据结构保存为文本文件，用于存储的文件路径字符串。'
- en: Creating JSON strings from individual objects and lists of objects
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单个对象和对象列表创建 JSON 字符串
- en: The `JsonUtility` class allows us to easily create JSON strings from individual
    objects, and also **Lists** of objects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonUtility` 类允许我们轻松地从单个对象和 **对象列表** 创建 JSON 字符串。'
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create JSON strings from individual and **Lists** of objects perform the
    following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要从单个对象和 **列表** 创建 JSON 字符串，请执行以下步骤：
- en: 'Create a new C# script class named `PlayerScore`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerScore` 的新 C# 脚本类：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new C# script class named `PlayerScoreList`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerScoreList` 的新 C# 脚本类：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a C# `ToJson` script class and attach an instance as a component to
    the **Main Camera**:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ToJson` 的 C# 脚本类，并将其实例作为组件附加到 **主摄像机**：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the scene. Two messages should be output to the Console panel:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。应该有两个消息输出到控制台面板：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These should be followed by this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 应遵循以下步骤：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `PlayerScore` scrip class declares two public properties: `name` and `score`.
    It also defines a public method `ToJson()` that returns a string containing the
    values of the properties encoded in JSON via the `JsonUtility.ToJson(...)` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScore` 脚本类声明了两个公共属性：`name` 和 `score`。它还定义了一个公共方法 `ToJson()`，该方法通过 `JsonUtility.ToJson(...)`
    方法返回包含属性值的字符串，这些属性值以 JSON 编码。'
- en: The `PlayerScoreList` script class declares a single public property `list`
    , which is a C# `List<>` of `PlayerScore` obejcts. So, we can store zero, one,
    or any number of `PlayerScore` objects in our list. Also declared is a single
    public method `ToJson()` that returns a string containing the values of the content
    of the `list` property encoded in JSON via the `JsonUtility.ToJson(...)` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreList` 脚本类声明了一个单个公共属性 `list`，它是一个 `PlayerScore` 对象的 C# `List<>`。因此，我们可以在我们的列表中存储零个、一个或任何数量的
    `PlayerScore` 对象。还声明了一个单个公共方法 `ToJson()`，该方法通过 `JsonUtility.ToJson(...)` 方法返回包含
    `list` 属性内容的字符串，这些内容以 JSON 编码。'
- en: It also defines a public `ToJson()` method that returns a string containing
    the values of the properties encoded in JSON via the `JsonUtility.ToJson(...)`
    method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它还定义了一个公共 `ToJson()` 方法，该方法通过 `JsonUtility.ToJson(...)` 方法返回包含属性值的字符串，这些属性值以
    JSON 编码。
- en: The `Awake()` method creates two `PlayerScore` objects, with some demo data
    in objects `playerScore1` and `playerScore2`. It also creates an instance-object
    of class `PlayerScoreList`, and adds references to the two objects to this list.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()` 方法创建两个 `PlayerScore` 对象，对象 `playerScore1` 和 `playerScore2` 中包含一些演示数据。它还创建了一个
    `PlayerScoreList` 类的实例对象，并将这两个对象的引用添加到该列表中。'
- en: The `Start()` method first invokes the `ObjectToJson()` method, then it invokes
    the `CollectionToJson()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法首先调用 `ObjectToJson()` 方法，然后调用 `CollectionToJson()`。'
- en: Method `ObjectToJson()` invokes the `ToJson()` method of object `playerScore1`,
    which returns a string, which is then printed to the Console panel.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `ObjectToJson()` 调用对象 `playerScore1` 的 `ToJson()` 方法，该方法返回一个字符串，然后将其打印到控制台面板。
- en: Method `CollectionToJson()` invokes the `ToJson()` method of object list `playerScoreList`
    which returns a string, which is then printed to the Console panel.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `CollectionToJson()` 调用了对象列表 `playerScoreList` 的 `ToJson()` 方法，该方法返回一个字符串，然后该字符串被打印到控制台面板。
- en: As we can see, both `PlayerScore` and `PlayerScoreList` classes define a `ToJson()`
    method, which makes use of the `JsonUtilty``ToJson()` method. In both cases, their
    `ToJson()` method returns a string that is the JSON representation of the object's
    data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`PlayerScore` 和 `PlayerScoreList` 类都定义了一个 `ToJson()` 方法，该方法使用了 `JsonUtilty`
    的 `ToJson()` 方法。在两种情况下，它们的 `ToJson()` 方法都返回一个字符串，该字符串是对象数据的 JSON 表示形式。
- en: 'The `PlayerScore` class''s `ToJson()` method outputs a JSON object string in
    this form:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScore` 类的 `ToJson()` 方法以以下形式输出 JSON 对象字符串：'
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `ToJson()` method of the  `PlayerScoreList` class outputs a JSON array
    string in this form:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreList` 类的 `ToJson()` 方法以以下形式输出 JSON 数组字符串：'
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, the `JsonUtility` class's `ToString()` method is capable of serializing
    individual objects, and C# Lists of objects into a storable string.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`JsonUtility` 类的 `ToString()` 方法能够将单个对象和 C# 对象列表序列化为可存储的字符串。
- en: Creating individual objects and Lists of objects from JSON strings
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 JSON 字符串创建单个对象和对象列表
- en: The `JsonUtility` class allows us to easily parse (process) JSON strings and
    extract individual objects, and also Lists of objects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonUtility` 类使我们能够轻松解析（处理）JSON 字符串并提取单个对象，以及对象列表。'
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create individual objects and Lists of objects from JSON strings, perform
    the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 JSON 字符串创建单个对象和对象列表，请执行以下步骤：
- en: 'Create a new C# script class named `PlayerScore`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerScore` 的新 C# 脚本类：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a new C# script class named `PlayerScoreList`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerScoreList` 的新 C# 脚本类：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a C# `ToJson` script class and attach an instance as a component to
    the **Main Camera**:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 C# `ToJson` 脚本类并将其作为组件附加到 **主相机**：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the scene. Three messages should be output to the Console panel:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。控制台面板应输出三条消息：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'They should be followed by this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 应该紧随其后的是：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Start()` method first invokes method `JsonToObject()`, and then it invokes
    method `JsonToList().`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法首先调用 `JsonToObject()` 方法，然后调用 `JsonToList()` 方法。'
- en: 'The method `JsonToObject()` declares a string that defines one `PlayerScore`
    object: `{name:matt, score:201}.` The string is created using escaped double-quote
    characters for property names and text data (quotes aren''t needed for the numeric
    data). The JSON string contains the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `JsonToObject()` 声明了一个字符串，该字符串定义了一个 `PlayerScore` 对象：`{name:matt, score:201}`。该字符串使用转义的双引号字符来创建属性名称和文本数据（对于数值数据不需要引号）。JSON
    字符串包含以下内容：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using escaped double-quote characters for property names and text data (quotes
    aren't needed for the numeric data). The **static** method `FromJSON(...)` of
    the class `PlayerScore` is then invoked with this JSON data string as its argument.
    The method returns a `PlayerScore` object, whose value is then printed to the
    Console panel.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转义的双引号字符来表示属性名称和文本数据（对于数值数据不需要引号）。然后，类 `PlayerScore` 的 **静态** 方法 `FromJSON(...)`
    使用这个 JSON 数据字符串作为其参数被调用。该方法返回一个 `PlayerScore` 对象，然后其值被打印到控制台面板。
- en: The **static** method `FromJSON(...)` of class `PlayerScore` invokes the `FromJson()`
    method of the `JsonUtility` class, and provides the class type `PlayerScore`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `PlayerScore` 的 **静态** 方法 `FromJSON(...)` 调用了 `JsonUtility` 类的 `FromJson()`
    方法，并提供了 `PlayerScore` 类类型。
- en: 'The method `JsonToList()` declares a string that defines a list of two `PlayerScore`
    objects: `{name:matt, score:800}` and `{name:joelle, score:901}`. The JSON string
    contains the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `JsonToList()` 声明了一个字符串，该字符串定义了两个 `PlayerScore` 对象的列表：`{name:matt, score:800}`
    和 `{name:joelle, score:901}`。JSON 字符串包含以下内容：
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The **static** method `FromJSON(...)` of the class `PlayerScoreList` is then
    invoked with this JSON data string as its argument. The method returns a `PlayerScoreList`
    object. A `foreach` loop extracts each `PlayerScore` object from the list property
    of the `PlayerScoreList` object. Each object's `name` and `score` values are printed
    out to the Console panel, prefixed with the text from the list.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用该 JSON 数据字符串作为参数调用类 `PlayerScoreList` 的 **静态** 方法 `FromJSON(...)`。该方法返回一个
    `PlayerScoreList` 对象。一个 `foreach` 循环从 `PlayerScoreList` 对象的列表属性中提取每个 `PlayerScore`
    对象。每个对象的 `name` 和 `score` 值被打印到控制台面板，前面带有列表中的文本。
- en: The **static** method `FromJSON(...)` of class `PlayerScoreList` invokes the
    `FromJson()` method of the `JsonUtility` class, and provides the class type `PlayerScoreList`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreList` 类的 **静态** 方法 `FromJSON(...)` 调用了 `JsonUtility` 类的 `FromJson()`
    方法，并提供了类类型 `PlayerScoreList`。'
- en: As we can see, the `JsonUtility` class's `FromJson()` method is capable of deserializing
    data into individual objects, and C# **Lists** of objects inside repository objects,
    such as `PlayerScoreList`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`JsonUtility` 类的 `FromJson()` 方法能够将数据反序列化为单个对象，以及存储在仓库对象内部的 C# **列表**
    对象，例如 `PlayerScoreList`。
