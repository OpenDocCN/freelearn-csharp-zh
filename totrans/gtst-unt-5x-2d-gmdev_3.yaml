- en: Chapter 3. Communicating with the Player – the User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User interfaces, often referred to as UIs for short, play a vital role in a
    game, since it's one of the main way to exchange information with the player.
    Usually, the game provides information, status, or stats of the game and the player
    interacts with the game with input through the UI.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain why UIs play such an important role in games and about
    the different things that we need to take into consideration when we design and/or
    implement UIs. Of course, this chapter will focus on the Unity framework to build
    UIs, and explains how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we will see how to start with UI programming
    from a practical point of view by implementing two important game play elements
    within the UI of our game. However, we will see more about UI programming in [Chapter
    5](part0062.xhtml#aid-1R42S1 "Chapter 5. The Secret Ingredient Is a Dash of Physics"),
    *The Secret Ingredient Is a Dash of Physics*, where we will polish the game and
    implement the whole gameplay based on the elements built in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you should definitely consider buying a book that is specifically about
    UI. Before writing this book, I wrote another book year: *Unity UI Cookbook*,
    *Packt publishing*. It has a perfect set of recipes ready to use. There you will
    find all the concepts mentioned here and much more, such as different tips and
    tricks. You can find it at [https://www.packtpub.com/game-development/unity-ui-cookbook](https://www.packtpub.com/game-development/unity-ui-cookbook).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, we will learn how the UIs are designed and how
    to implement them in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Unity framework to build UIs by looking in detail at each
    of its components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating and placing UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the UI for our tower defense game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a health bar within our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a sugar meter within our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all the other chapters of this book, you will find the *Homework* section
    at the end. It has a range of different exercises for you to do to improve your
    skills and implement a range of different functionalities into your game. So,
    let's get ready to learn a lot about UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the graphics from the same package of the previous chapter to build
    our UI as well. Therefore, be sure to have it imported and have the images imported
    as Sprites in order to use them in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think about when you are reading a book, the text or images are on the center
    of the page, the page number is located, usually, in a corner, and the pages are
    numbered consecutively. The whole process is pretty straightforward and hassle
    free. Players expect the same experience, not only with gameplay, but also with
    other on-screen elements such as the UI. The design of a UI requires considerations
    of a number of things. For example, the platform that you are designing for has
    limitations, such as screen size, and the types of interaction that it can afford
    (does it use touch or a mouse pointer?). But physiological reactions that the
    interface might give to the player need to be considered, since he or she will
    be the final consumer. In fact, another thing to keep in mind is that some people
    read from right to left in their native languages, and the UI should reflect this
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that if you are designing for multiple devices,
    try to keep the experience the same. With many applications being multi-platform,
    you don't want the user getting used to an experience on a mobile that is presented
    in one way, and then to log on to the computer version, and it's completely different.
    Therefore, while you are designing the UI, determine how it will look on each
    device. Is the home icon too small on a mobile to understand what it is? Is the
    navigation menu too large for a desktop version? Making sure that the UI is optimized
    will ensure that users who use your application across multiple devices will have
    a seamless transition and won't have to try to figure out how to access features
    all over again.
  prefs: []
  type: TYPE_NORMAL
- en: Just like our book example, players or users of applications are used to certain
    conventions and formats. For example, a house icon usually indicates home or the
    main screen, an e-mail icon usually indicates contact, and an arrow pointing right,
    usually indicates that it will continue to the next item in the list, or the next
    question, and so on. Therefore, to improve ease of use and navigation, it is ideal
    to stick to these or to at least keep these in mind during the design process.
    In addition to this, how the user navigates through the application is important.
    If there is only way to get from the home screen to an option, and it's via a
    whole bunch of screens, the whole experience is going to be tiresome. Therefore,
    be sure to create navigation maps early on to determine the route for each part
    of the experience. If a user has to navigate through six screens before they can
    reach a certain page, then they won't be doing it for very long.
  prefs: []
  type: TYPE_NORMAL
- en: Loud noises can immediately get people's attention. So can UI elements. Therefore,
    you want to make you more important elements the focal point. The key here is
    to have fewer elements, if not only a single element, the focal point to reduce
    the player from feeling overwhelmed. For example, in a game, you may want the
    health bar to be the main item of focus. Therefore, place it somewhere where it
    will be noticed and not in the corner in the player's peripheral view. One way
    to achieve this is to have the UI elements contrast the environment, ideally within
    the same color palette so that they stand out, but not draw so much attention
    that they are distracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great website to create great color schemes is Adobe Color ([https://color.adobe.com/](https://color.adobe.com/)).
    An example of it can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface](img/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In saying all of this, don't let the design over take the practicality of the
    user's experience. For example, you may have a beautiful UI but it makes it really
    hard to play the game or it causes too much confusion. Particularly during fast-paced
    gameplay, you don't want the player to have to sift through twenty different on-screen
    elements to find what they are looking for. You want the level mastery focused
    on the gameplay rather than understanding the UI. One way to also limit the amount
    of UI elements present at any one time is to have sliding windows or pop-up windows
    that have other UI elements present. For example, if your player has the option
    to unlock many different types of ability but they are only able to use one or
    two of them at any single moment during gameplay, there is no point in displaying
    them all. Therefore, having a UI element for them to click that then displays
    all of the other abilities, which they can swap for the existing ones, is one
    way to minimize the UI design. Of course, you don't want to have multiple pop-up
    windows, otherwise it becomes a quest in itself to change settings in-game.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that a UI can offer is feedback. Feedback is not necessarily a pop-up
    screen that is displayed in the center of the screen; it can be something as simple
    as a meter increasing/decreasing, such as a health bar, or a player's avatar changing
    over time; for example, they begin to age as the player progresses through the
    game. The next thing about adding feedback is how you are going to alert the player
    to changes in the UI. In some instances, it is not necessarily to alert the player,
    it's just a natural part of the process; in others, they need to know that changes
    have occurred or are occurring. One way to indicate changes to a player is to
    animate the UI element in question. This can be as simple as a glowing effect;
    for example, each time the player is attacked their health meter glows or pulsates
    as it decreases. Another option is to indicate that changes are occurring in the
    UI with sound; for example, each time the player's currency increases, a soft
    chime sound plays. Audio can be just as effective as an animation, but also keep
    in mind that feedback that is based on audio won't always be heard. For example,
    sometimes, players opt to disable the sound if they are in a public place and
    do not have headphones, so keep this in mind if you are using sound as the only
    way to indicate a change in the UI to the player. In addition to the types of
    feedback, each action needs a reaction, and if the player does something that
    they are not supposed to do, they need to be notified. So each time that a player
    provides input, clicks a button, or interacts with the UI, something should happen.
    How prominent it is is up to you; just make sure that it is clear and not over
    the top.
  prefs: []
  type: TYPE_NORMAL
- en: This section gave you an introduction into the issues behind designing a good
    UI. There are so many other factors to take into account that specific books just
    about UIs have been written. For instance, one of these is localization, which
    is so vast that a whole chapter is needed to describe it (you can find a brief
    introduction to Localization in [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What
    Is beyond the Cake?"), *What Is beyond the Cake?*).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before moving on, I just want to point out a technical term about
    UIs, since it also appears in the official documentation of Unity. Some UIs are
    not fixed on the screen, but actually have a physical space within the game environment.
    Some designers call these UIs *diegetic*, as opposed to classical interfaces that
    are *non-diegetic*. It is a term that has been borrowed from other disciplines,
    and therefore is not unanimously accepted for UIs. In fact, it might even cause
    a little confusion. Just to provide you with a bit more of a historical background,
    the term derives from the word *diegesis*. We can see its definition in the Merriam-Webster
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"the telling of a story by a narrator who summarizes events in the plot and
    comments on the conversations, thoughts, etc., of the characters."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An example of a diegetic interface, or just for simplicity an UI placed within
    the game word, is the minimap of the game *Dead Space* (Visceral Games, former
    EA Redwood Shores), which we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface](img/image00386.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Programming the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous section, designing UI can be tough, and requires
    experience to get into, especially if you take into consideration all the elements
    you should, such as the psychology of your audience. However, this is just half
    way through. In fact, designing is one thing, making it work is another. Usually,
    in large teams, there are artists who design the UI and programmers who implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Is UI programming that different? Well, the answer is no, programming is still
    programming; however, it's quite an interesting branch of the field of programming.
    If you are building your game engine from scratch, implementing an entire system
    that handles input is not something you can create just with a couple of hours
    of work. Catching all of the events that the player does in the game and in the
    UI is not easy to implement, and requires a lot of practice. Luckily, in the context
    of Unity, most of this backend for UIs is already done. Furthermore, as we will
    see in the next section, Unity provides a solid framework to work also on the
    frontend for UIs. This framework includes different components that can be easily
    used without knowing anything about programming. But if we are really interested
    in unlocking the potentiality of Unity framework for the UIs, we not only need
    to understand it, but also program within it.
  prefs: []
  type: TYPE_NORMAL
- en: Even with a solid framework, such as the one in Unity, UI programming still
    needs to take into consideration many factors, enough to have a specific role
    for this in large teams. Achieving exactly what designers have in mind, and possible
    without hitting the performances too much, is most of the job of an UI programmer
    (at least using Unity).
  prefs: []
  type: TYPE_NORMAL
- en: Mastering these skills requires time and patience, and this chapter is just
    an introduction to this world. I hope you will enjoy reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: User interface system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have acquired a basic knowledge about how to design UIs, it's time
    to learn how Unity handles all of this. From Unity 4.6, it is possible to use
    a dedicated UI system called UI. The goal of this section is understand how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is worth mentioning that, before version 4.6, Unity used an old system called
    GUI. Recently, Unity developer didn''t completely dismiss the system, but slightly
    changed it and renamed it **IMGUI**, which stands for **Immediate Mode GUI**.
    As we can see in the official documentation, it is not intended to be used in
    game, but rather for programmers to quickly debug. Moreover, it is also used to
    create windows or a custom Inspector when Unity is extended through scripts, a
    topic that is definitely out of the scope of this introductory book. However,
    if you are interested in learning more, I invite you to read the official documentation:
    [https://docs.unity3d.com/Manual/ExtendingTheEditor.html](https://docs.unity3d.com/Manual/ExtendingTheEditor.html)
    Also, follow this video tutorial: [https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090](https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090).'
  prefs: []
  type: TYPE_NORMAL
- en: However, you might find this section a little bit encyclopedic. In fact, you
    can use this section as a quick reference to the UI elements you need. Therefore,
    feel free to skip part of it, if you already have a certain knowledge about Unity
    UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this section is structured in such a way that the fundamental things
    are at the beginning, and progressively deals with more complicated topics, up
    to arrive out of the scope of this book. In fact, we you have reached this level,
    where it is really just matter of fine tuning, or achieving a really specific
    effect, this section will give you a general idea of how it works, so to have
    a ground from which to further extend your knowledge, especially with the official
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are wondering what a Canvas is, let''s begin with some background information.
    From the Merriam -Webster dictionary, a canvas is considered to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A firm closely woven cloth usually of linen, hemp, or cotton used for clothing
    and formerly much used for tents and sails."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But probably the definition that is closer to what Unity means is this, also
    from the Merriam-Webster dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A piece of cloth backed or framed as a surface for a painting; also: the
    painting on such a surface."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In computer graphics, a canvas is something slightly different, and we can
    see its definition on Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"In computer science and visualization, a canvas is a container that holds
    various drawing elements (lines, shapes, text, frames containing other elements,
    etc.). It takes its name from the canvas used in visual arts. It is sometimes
    called a scene graph because it arranges the logical representation of a user
    interface or graphical scene. Some implementations also define the spatial representation
    and allow the user to interact with the elements via a graphical user interface."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In Unity, a Canvas is an important component of the UI system. Since the UI
    is internally rendered by Unity in a different way than the rest of the scene,
    we need to specify which elements within our scene belong to the UI. In particular,
    all the UI elements should be children of a Canvas, which is a Game Object with
    a Canvas component attached on it. We can create a Canvas by right-clicking on
    the **Hierarchy** panel and then navigate to **UI | Canvas**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, two objects will be created in our scene, as we can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas](img/image00387.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, at the moment let's just focus on the Canvas, leaving the **EventSystem**
    for later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a new UI element, such as an image, for instance by right-clicking
    on the **Hierarchy** and then **UI** | **Image**, automatically creates a Canvas
    (and an EventSystem as well), if there isn't already a **Canvas** in the scene.
    The UI element is created as a child of this Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas is represented in the scene as a white rectangular. This helps us
    to edit the UI without switching back and forth from the Game View.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the **Scene** view is not set in 2D, for instance we are working in on a
    3D game, the Canvas appears distorted, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas](img/image00388.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since UI will be rendered orthographically, a rule of thumb of working with
    UIs is to switch the Scene View to 2D (as we learnt in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity*), to have something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas](img/image00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we select the Canvas, we should be able to see the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas](img/image00390.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The main setting is the **Render Mode**, which allows us to specify how we intend
    to use our UI. Let's take a closer look at these options.
  prefs: []
  type: TYPE_NORMAL
- en: Screen space – Overlay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This render mode is the most used. In fact, it places UI elements on the screen
    by rendering them on top of the scene, as in many games. This means that UI elements
    are rendered perfectly orthographically.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if the screen changes resolution or is resized, the Canvas will
    change size to automatically fit the new ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Screen space – Camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This render mode, instead, is linked to a specific Camera where the UI will
    be render on top of it. This means that the Canvas is placed at a given distance
    in front of the selected Camera. As a result, the UI elements will be affected
    by all the camera parameters and effects. This includes the perspective distortion,
    if the **Camera** is set to **Perspective**, which is regulated by the **Camera
    Field of View** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Like previously, the Canvas may change size based on the resolution of the screen
    as well as the camera frustum.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are wondering what the camera frustum is, keep reading this info box.
    When you select a camera, you will see a trunked pyramid (if the camera is in
    perspective mode, otherwise it has a Parallelepiped as shape), like the one in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen space – Camera](img/image00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the camera frustum, and everything that is inside it will be rendered
    by the camera. The plane that is closer to the camera is called **near clipping
    plane**, whereas the far one is called the **far clipping plane**. Understanding
    why a perspective camera has this shape is not hard, but it''s out of the scope
    of this book. However, in the documentation, you can find two interesting pages
    that talk about this. They are easy to understand, and as for your convenience,
    here are the links: [https://docs.unity3d.com/Manual/UnderstandingFrustum.html](https://docs.unity3d.com/Manual/UnderstandingFrustum.html)
    and [https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html](https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: World space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This render mode will make the Canvas behave like any other game object in the
    scene. This means that the Canvas has a precise position in the world (from here
    the name, since it is placed in the world space). As a result, the UI can be occluded
    by other objects in the scene. Its dimensions are set manually using the Rect
    Transform component (see some paragraphs ahead). This mode is useful for UIs that
    are meant to be a part of the world. As we have discussed previously, this is
    also known as a **diegetic interface**.
  prefs: []
  type: TYPE_NORMAL
- en: Draw order of UI elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we will see in the next paragraphs, UI elements will be images or text that
    is rendered on the screen. However, what happens when two of these components
    overlap? There is an order, so that the UI elements in the Canvas are drawn in
    the same order they appear in the hierarchy. This means that the first child is
    drawn first, the second child next, and so on. Therefore, when two UI elements
    overlap, the later one, in the Hierarchy, will appear on top of the earlier one.
  prefs: []
  type: TYPE_NORMAL
- en: To change which element appear on top of other elements, it's just matter of
    reordering the elements in the **Hierarchy** by dragging them.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this, look at the following screenshot, which represents
    two different situations with two images. For your convenience, the respective
    **Hierarchy** panel has been superimposed next to the images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Draw order of UI elements](img/image00392.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Lemon Cupcake is rendered on top of the chocolate one because the Lemon
    Cupcake is the last child of the Canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'The order can also be controlled from scripting by using these methods on the
    Transform component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SetAsFirstSibling()**: Place the game object as the first child of its parent.
    As a result, it will be rendered for first (with respect to its siblings), and
    therefore sent to the back (all other UI elements will be on top of it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetAsLastSibling()**: Place the game object as the last child of its parent.
    As a result, it will be rendered last (with respect to its siblings), and therefore
    brought to the front (all other UI elements will be behind it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetSiblingIndex()**: Place the game object to a specific index, allowing
    to decide at which point of the rendering hierarchy this game object will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unity UI comes with different premade components to build our UI. The most
    commonly used are the visual components, which allow rendering custom content
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The Image component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Image component, as the name suggests, allows us to render an image on
    the screen. In fact, we need to specify a **Source Image**, which is the image
    we want to render. An example of this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Image component](img/image00393.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for Sprites, the image assets we intend to use for the UI in our project
    must be set to Sprite (2D and UI), as [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A
    Flat World in Unity"), *A Flat World in Unity* explained.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can adjust the color, which is a multiplier of the Sprite, as well
    as assign a material, if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a **Source Image** has been set, we can define how the Sprite will appear
    by selecting the **Image Type**. The options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple**: just scales the image or Sprite equally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sliced**: if the Sprite has been 9-sliced (as [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity* explained), the nine
    different parts of the image will be scaled differently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiled**: this is similar to the previous one, but the central part of the
    9-slicing is tiled instead of stretched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filled**: this is similar to Simple, but allows us to show part of the image
    as it would be filled. This is controlled by parameters such as the Origin of
    the Filling, as well as the method and the amount. We will use this feature later
    in the chapter, and we will find out that is really useful for creating bars in
    video games:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The Image component](img/image00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some advanced bars, such as the health bar in Kingdom Hearts style, can be
    found in the book pointed out previously: *Unity UI Cookbook*, *Packt publishing*
    towards the end of *Chapter 2*, *Implementing Counters and Health Bars*.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when the image is **Simple** or **Filled**, the button **Set Native
    Size** is visible. It just restores the original size of the image. This is really
    useful when you assign a new **Source Image**, and you can restore the original
    ratio by using this button as well, before scaling to the right size for your
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: The Text component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Text component, as the name suggests, allows us to render any text on the
    screen. Sometimes, in some books, it is referred to as label, since usually it
    is used to give a label to other UI components. An example of this can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Text component](img/image00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It contains a text area, which can be extended using the Rect Tool (see the
    next paragraph). Within the component, you can find all the basic **Text** transformations,
    such as setting the font, the font style, and the font size. Furthermore, it is
    possible to enable or disable the rich text capability, which is enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you a wondering what rich text capability is, keep reading this info box.
  prefs: []
  type: TYPE_NORMAL
- en: Rich text capability allows us to place some HTML tags within the text to change
    only specific part of the text. In non-technical terms, you can change the color
    of a single word or change its font style to italic. For instance, you can have
    something like *This book is really amazing* in the **Text** area, but in the
    text component, it is written as `This book <b>is really</b> amazing`.
  prefs: []
  type: TYPE_NORMAL
- en: Since they are HTML tags, they must be placed at the beginning, specifying the
    settings, and at the end of the part of text where you want to apply the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main tags supported from unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<b>The text between these tags will be in bold</b>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<i>The text between these tags will be in italic</i>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<size=50>The text between these tags will have a size of 50, and you can change
    the number to any number</size>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<color= #rrggbbaa>This text between these tags will be colored with the hex
    color specified at the beginning</color>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t know what a hex color is, it is just a hex number (therefore,
    it contains also some letters) that represents a color; you can learn more about
    them on the Wikipedia page here: [https://en.wikipedia.org/wiki/Web_colors](https://en.wikipedia.org/wiki/Web_colors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, keep in mind that you don''t need to know all the detailed theory
    behind the Wikipedia page to use these colors. In fact, there are plenty of online
    color pickers that give you the hex number of a specific color. Then, you just
    need to copy and paste the code into your text in Unity. Furthermore, you don''t
    need necessarily to use the hex code for the color, but there are some presets
    in Unity. In fact, you can just use This `<color=red>word</color>` is red to make
    the word red, without specifying the whole hex code. The list of all these color
    shortcuts can be found by following the link at the end of this info box. Alternative,
    you could also select hex colors from online tools, such as: [http://www.w3schools.com/colors/colors_picker.asp](http://www.w3schools.com/colors/colors_picker.asp)
    or [http://htmlcolorcodes.com](http://htmlcolorcodes.com).'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of special tags, material and quad, which have a really specific
    use. If you want to learn more, follow the link at the end of this info box.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool feature of these tags is that you can nest them! This means you
    can use more than one at the same time. For instance, you can have part of the
    text that is blue, bold, and italic. However, they must be closed in reverse order,
    otherwise they won't work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more, follow this link: [https://docs.unity3d.com/Manual/StyledText.html](https://docs.unity3d.com/Manual/StyledText.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can find options to change the alignment of the text as well
    as for vertical and horizontal overflow, which means to control what happens when
    the text is larger than the text area. The **Best Fit** option rescales the text
    to fit the available space of the text area.
  prefs: []
  type: TYPE_NORMAL
- en: Basic transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen some basic UI elements, but how can we place and manipulate them? We
    will learn various different forms of implementing transformations in the next
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Rect Tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since UI elements are similar to Sprites (both are 2D), the best way to quickly
    manipulate them is by using the Rect Tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fast recap, you can find the Rect Tool in the top-left corner of the Unity
    Editor, and it is the last one on the right, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Rect Tool](img/image00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A border around our Sprite or UI elements should appear. As a result, we can
    transform it in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click and drag within the rectangle, we can move the object, as in the
    following picture (for learning purposes, a tasty cupcake has been used in an
    Image component):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The Rect Tool](img/image00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the blue dot in the middle, which is the pivot point, we can
    change its position (in this book we will not change any pivot points, since we
    won''t need this):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The Rect Tool](img/image00398.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click and drag an edge we can scale along that direction, as we can see
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The Rect Tool](img/image00399.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click and drag a corner, instead, we can scale freely along both directions.
    Furthermore, if you press **Shift** while dragging, the scale will be uniform,
    which means it will increase in size by the same quantity on both axes by keeping
    the ratio of the object constant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The Rect Tool](img/image00400.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, if we place the cursor next to a corner that is, outside of the rectangle,
    a little rotation icon appears. By clicking and dragging it is possible to rotate
    the object around its pivot point:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The Rect Tool](img/image00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And this is all for the Rect Tool.
  prefs: []
  type: TYPE_NORMAL
- en: The Rect Transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a major difference in how Unity handles Sprites and UI elements. In
    fact, Sprites have the usual Transform component, to indicate position, rotation,
    and Scale. UI elements, instead, have a Rect Transform (the 2D layout counterpart),
    which is much more complex and store more information. In fact, the Transform
    represents a single point in the space, whereas the Rect Transform represent a
    rectangle in which a UI element can be placed. An example of this can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Rect Transform](img/image00402.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity performs all the calculations of the positions of the different Rect Transform
    at the end of the frame to ensure having up-to-date values with respect to the
    rest of the frame. As a result, these values of the Rect Transform might not be
    correct when you use the `Start()` function. To overcome this problem, you can
    force the update of the canvas by calling the `Canvas.ForceUpdateCanvases()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if the parent of a Rect Transform is also a Rect Transform, the
    child Rect Transform can also specify how it should be positioned and sized relative
    to the parent rectangle. This hierarchical structure is what makes Rect Transform
    so powerful, especially when you need to design for multiple resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Other than scaling, a Rect Transform can be resized. They are similar operations,
    but the difference lies that resizing leaves invariant the local scale, and change
    the height and the width. As a result, font sizes, borders on sliced images, and
    so on, won't be affected from resizing, whereas they are in the case of scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to 2D Sprites, the Rect transform applies scaling, rotation, and resizing
    by the pivot point of the UI element. However, it is possible to change it directly
    inside the Scene View, by dragging it (the little blue circle) within the UI element.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most import concepts about this component is the Anchors, which allow
    us to specify the relation of the UI element with respect to the Canvas and its
    parent. They are displayed as four small triangular handles in the Scene View.
    The information related to these anchors is shown in the Rect Transform component
    in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there is no a simple way to explain Anchors without seeing the
    effects in motion, such as in a video or in an animated gif. Since this is a book,
    it cannot contain such animated media, which would clarify the concept immediately
    to you. Therefore, instead of losing time in a complicated explanation of anchors,
    which may not be fully understandable, I invite you to visit the official documentation
    here, in the anchors section: [https://docs.unity3d.com/Manual/UIBasicLayout.html](https://docs.unity3d.com/Manual/UIBasicLayout.html).
    Don''t worry, I''ll still be here when you come back from the webpage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have read the webpages, other than seeing the animated gif, you also
    have seen the Anchor presets, which are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Rect Transform](img/image00403.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These are useful shortcuts to quickly correctly anchor UI elements. Of course,
    I invite you to manually change this configuration in your game, when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Layout components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section we saw how it is possible to place UI elements in the
    screen. However, sometimes, it's really useful to automatically place them in
    the screen within a certain criteria, especially when the number of UI elements
    is not known a priori, and changes at runtime. This can be manually scripted,
    but Unity comes with a series of layout components that helps with basic layout
    placement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The auto-layout system is composed of two different kinds of elements: layout
    elements and layout controllers. To understand the former, note that every game
    object that has a Rect Transform, and eventually other components, is a layout
    element. These types have certain knowledge about what size they should be of,
    but they do not control it directly. Layout controllers, instead, are components
    that control sizes and also positions of one or more layout elements. They can
    control their own layout element or child Layout Elements of the game object to
    which they are attached.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Layout controllers change the Rect transforms in such a way that it's hard to
    restore the previous status. Therefore, before to even add a layout controllers
    and/or modify one, be sure to be in Play mode in order to make changes without
    causing any unwanted layout change to your UI. Once you are happy with the changes,
    stop Play mode, and insert the values that you have found that fit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The layout controllers are divided into Fitters and layout groups.
  prefs: []
  type: TYPE_NORMAL
- en: Fitters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Fitters only control the size of its own layout element. When resizing UI
    elements, keep in mind that it happens around the pivot point, as we discussed
    in the previous section. Therefore, you can use it also to align UI elements.
    For instance, if the pivot is in the center, the element will scale equally in
    all the directions, whereas if it is placed in a corner, such as the top-left,
    the element will scale down and to the right. All other positions will give different
    weighs along the four directions where the element will scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this said, let''s take a look at the Fitters controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content Size Fitter**: controls the size of its own layout element. The size
    is determined by the minimum or preferred sizes provided by layout element components
    on the Game Object. Such layout elements can be Image or Text components, layout
    groups, or a Layout Element component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Fitters](img/image00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Aspect Ratio Fitter**: can adjust the height to fit the width or vice versa,
    or it can make the element fit inside its parent or envelope its parent. The Aspect
    Ratio Fitter does not take layout information into account, such as minimum size
    and preferred size:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Fitters](img/image00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Layout groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The layout groups, instead, control the layout elements of their children,
    and not their own. They are used to orderly place the UI elements. They have different
    options to control the spacing between the children and define the preferred heights
    and/or widths. Other options include the possibility to force the expansion of
    the children so to fit the space available or to decide what happens when they
    are bigger than the space available. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical Layout Group**: allows us to stack the children along a vertical
    axis, and place them on top of each other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Layout groups](img/image00406.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Horizontal Layout Group**: allows us to stack the children along a horizontal
    axis, and place them next to each other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Layout groups](img/image00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Grid Layout Group**: this allows us to stack the children in a grid, both
    vertically and horizontally:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Layout groups](img/image00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The layout element component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more component, which is the **Layout Element** component. As the
    name suggests, it is not a controller, but rather allows us to change the layout
    element settings from the Rect Transform. In fact, when placed on a layout element,
    it allows us to override the settings, such as min, preferred, and flexible both
    for height and width. Furthermore, it has a flag to ignore the controllers. So,
    imagine having a label inside a grid layout component, you don't want the label
    to be stacked in the grid along all the other elements, but rather on the top,
    defining what the grid is about. In this case, ignoring the controller is useful
    to place the label outside the grid, and yet be a children of the grid, so to
    move it as a unique block, without replacing the label every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a picture of what this component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The layout element component](img/image00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Interaction components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity UI comes with more powerful premade components than the one seen in the
    visual components section. In fact, there are many components with which the user
    can interact. These interaction can be mouse or touch/tap events as well as keyboard
    or controller events.
  prefs: []
  type: TYPE_NORMAL
- en: However, this components are not visible on their own, and must be combined
    with one or more visual components in order to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The selectable base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before seeing how the single interaction components work, we need to understand
    some basic settings shared among all of them. In particular, these settings derive
    from the Selectable base class, which has transition and navigation options.
  prefs: []
  type: TYPE_NORMAL
- en: Interactable option
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is just a flag that determines if an interaction component is enable for
    interaction or not. When checked, the interaction component will be in the **Disable**
    state (see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Transition options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Usually, interaction components needs to send some feedback to the player, so
    he or she can understand if the action has been performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation of Unity, there are four states in which an interaction
    component could be. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal**: the interaction component is untouched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highlighted**: when the pointer is on the interaction component, but a click
    (or a touch/tap in the case of touch-screens) hasn''t been performed yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pressed**: when the click (or touch/tap) is happening on the interaction
    component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable**: when the interaction component is not interactable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They transitions and the specifications of these states can happen in four
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: The interaction component doesn''t change state. This is really useful
    when we want to implement the kind of interaction with the component in a custom
    way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Transition options](img/image00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Color Tint**: this option is selected by default and defines a color tint
    for each of the preceding states. Furthermore, it contains a **Fade Duration**
    to regulate how fast the component should change from one color to another, and
    a **Color Multiplier**. As a result, the interaction component will smoothly change
    color for each of the four states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Transition options](img/image00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Sprite Swap**: Usually, the interaction components have also an Image component
    attached to them, which defines the basic graphics. In this transition mode, instead
    of changing color, there is a different Sprite for each one of the four states.
    This is useful when you have custom graphics for each one of the states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Transition options](img/image00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Animation**: This is the most versatile transition mode, since it allows
    you to have a custom animation for each one of the states (we will talk more about
    animations in the upcoming chapters):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Transition options](img/image00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navigation options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The navigation options determine how the player can navigate through the UI
    elements during play mode. These are the different options available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: No keyboard navigation. This is useful when you want to implement
    your own navigation system within the game. Furthermore, the interaction component
    that is set in this mode will not receive focus from clicking (or tapping) on
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal**: navigates horizontally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertical**: navigates vertically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic**: Unity will try to guess which is the right navigation based
    on the positions of the UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit**: In this mode, you can specify the next UI element to select for
    each arrow key. This allows fine navigation control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Navigation options](img/image00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, the **Visualize** button allows to visualize the navigation scheme
    within the **Scene View**. An example of this visualization is presented in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation options](img/image00415.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the classical interaction component that can be found in any game.
    It contains only one event, `OnClick()`, which is triggered when the button is
    clicked/tapped. Of course, you can link any action to the event. An example of
    this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Button](img/image00416.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that if the pointer is moved away from the button before the click/tap
    is released, the action doesn't take place. You can find an exercise on this in
    the *Homework* section.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle and Toggle Group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Toggle component allows the player to turn off and on an option. An example
    of this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Toggle and Toggle Group](img/image00417.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the button, the toggle has a single event `OnValueChanged()`, which is called
    every time that the toggle changes its state; the value of the new state is passed
    as a Boolean parameter within the event data (see next paragraph). This component
    works well with another component, called Toggle Group, which controls whether
    there is only one option among a group of toggles to be turned on, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Toggle and Toggle Group](img/image00418.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can set up a toggle group by just add it to the **Group** property of all
    the toggles you wish in to be in the group. This is, for instance, really useful
    for mutually exclusive choices, such as character or class selection. Other common
    use is tuning the game settings, such as game speed, difficulty, or color scheme.
    Of course, you can use more than one toggle group per time within your scenes;
    however, a toggle can only belong to one group.
  prefs: []
  type: TYPE_NORMAL
- en: Slider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, a slider is a bar with a handle along it, which can slide
    from the beginning, which is considered the **Min Value**, to the end, which is
    considered the **Max Value**. All the values in between are in proportion to the
    position of the handle along the bar. By default, the handle increases its value
    from left to right, but by tweaking the **Direction** property, it''s possible
    to change in other directions, so not only from right to left but also along the
    vertical axis. An example of this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slider](img/image00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The slider has a single event, `OnValueChanged()`, which is triggered when the
    handle is dragged, and the new value of the slider is passed as a float to the
    triggered action.
  prefs: []
  type: TYPE_NORMAL
- en: Scrollbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This component is very similar to a slider, since it has a handle along a bar,
    and the minimum value is always 0.0 and the maximum is 1.0\. All the values in
    between represents the different percentage of where the handle will be. Again,
    the scrollbar can be orientated by tweaking the **Direction** property. An example
    of this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scrollbar](img/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The difference between this and the slider is the possibility to stretch the
    handle of the scrollbar depending on some content, such as text areas. When the
    text increases, the handle becomes smaller to slide among more content, which
    represents the amount of scrolling available. On the other hand, when the content
    is not large, the handle increases its dimensions to completely fill the bar and
    not allow scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: The scrollbar has a single event, called `OnValueChanged()`, and it works exactly
    the same way as the homonymous event on the slider.
  prefs: []
  type: TYPE_NORMAL
- en: Dropdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Dropdown** is a relatively new component in the Unity UI, since it has
    been released/implemented since Unity 5.2\. This component allows the player to
    select among a list of options. The component shows the current selected option
    only, and when the player clicks/taps on it, the full list appears. Once another
    item from the list is selected, the list closes and the new item is picked. Furthermore,
    the player can close the list without changing the item if he or she clicks somewhere
    else outside the component. An example of this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dropdown](img/image00421.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the dropdown in the inspector is quite intuitive, even if you need to
    get used to the template in the hierarchy if you want to change its appearance.
    Unfortunately, we don''t have time to go into detail about how this component
    works, but I''m sure you can easily understand it by visiting the official documentation
    here: [https://docs.unity3d.com/Manual/script-Dropdown.html](https://docs.unity3d.com/Manual/script-Dropdown.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, we won't use this component for our game, but in the *Homework*
    section you can challenge yourself to understand this component better.
  prefs: []
  type: TYPE_NORMAL
- en: Input Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Input Field** component allows the player to type text in the game, specifically
    within a text area. Of course, you need to use it in conjunction with a Text component,
    and/or other visual elements. An example of this can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Input Field](img/image00422.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Input Field** can be added also to an already existing **Text** component
    to make it editable. In order to do so, select the **Text** component in the **Hierarchy**
    panel and navigate to **Add Component** | **UI** | **Input Field** in the **Inspector**.
    Then, drag the **Text** component (also the game object itself will work) inside
    the **Text** component variable of the **Input Field**. Furthermore, you may want
    to add a placeholder as well. As such, I suggest that you create an **Input Field**
    and study how it works with its original structure, and then add existing text
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: When the player is typing, the **Text** property of the **Text** component will
    change, and it can be retrieved from the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the **Input Field** has different options to define the kind of characters
    that are allowed, whether they should be masked (for instance, if it is a password
    or a pin), whether there is a limit to the number, or whether multi-line editing
    is allowed. You can learn more about these additional features in the official
    documentation: [https://docs.unity3d.com/Manual/script-InputField.html](https://docs.unity3d.com/Manual/script-InputField.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Input Field** component has two events: `OnValueChanged()`, which is
    triggered every time the player types something, and `OnEndEdit()`, which is triggered
    only when the player has stopped typing. In both the cases, the whole text in
    the **Text** component is passed to the action function through a string parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that **Rich Text** is turned off by default. You can enable it,
    but it is not well supported for the **Input Field** because the navigation in
    the text includes markup, whereas the visual doesn't. As a result, it is really
    confusing for whoever is going to type there. Usually, you don't need **Rich Text**
    capability for editable texts; therefore, as a rule of thumb, just keep **Rich
    Text** turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll Rect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This component is used when your content is larger than the area it should
    occupy. Scroll Rect allows us to make a content scrollable inside a rectangle,
    and display all the content in a relatively small area. Usually, this component
    is used with the **Mask** component; in this way all the content outside the rectangle
    will not be visible, and you will have achieved a scroll view. An example of this
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scroll Rect](img/image00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, you can assign scrollbars (both on the horizontal and the vertical
    axes) to easily scroll through the content. You can find more options to tweak
    in the component, and if you really want to understand them, I invite you to consult
    the official documentation: [https://docs.unity3d.com/Manual/script-ScrollRect.html](https://docs.unity3d.com/Manual/script-ScrollRect.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Scroll Rect has only one event, `OnValueChanged()`, which is triggered
    when the position of the Scroll Rect is changed, signifying that the player scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: More about UI rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen a lot about UI, yet it's not everything. This section presents
    some relative advanced topics in the UI of Unity. Feel free to skip this section,
    or read without focus to completely understand what's written, You can always
    come back here later.
  prefs: []
  type: TYPE_NORMAL
- en: The canvas renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The careful reader has noticed that in all the UI elements there is always
    attached a Canvas Renderer, such as the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The canvas renderer](img/image00424.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What is this component that doesn't allow us to change any options? It allows
    Unity to know that that specific UI element should be rendered in a Canvas. In
    very particular cases, when an UI element is built from scratch, we need to manually
    add this component. However, if you are not planning to build custom UI elements
    from scratch, but just using the ones that Unity provides (which are more than
    enough to build really complex UIs), you can forget about this component. In fact,
    it is automatically created every time we create an UI element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the **Canvas Renderer** doesn''t have any options in the inspector,
    it has some properties that can be accessed through script. For such functions
    and variables, you can find details here: [https://docs.unity3d.com/ScriptReference/CanvasRenderer.html](https://docs.unity3d.com/ScriptReference/CanvasRenderer.html).'
  prefs: []
  type: TYPE_NORMAL
- en: More visual components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have analyzed the main visual components; however, there are more visual
    components, which are used rarely in special situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More visual components](img/image00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The most common is the **Mask** component. It is used to create a scroll view
    in conjunction with the **Scroll Rect**. It forces the children to have the shape
    of the parent. However, it doesn't support alpha channels. This means that part
    of the children will be either visible or not, without having any kind of opacity
    specified in the mask.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in knowing why the alpha channel is not supported, we
    need to mention implementation of Mask beneath Unity.
  prefs: []
  type: TYPE_NORMAL
- en: When you program with a GPU, you are constrained to use certain buffers to render
    things. Modern GPUs have a buffer called Stencil Buffer, used together with the
    **Color Buffer** and the **Depth Buffer**, which can only assume integer values
    and work on a pixel base. Usually, it is used to avoid rendering certain parts
    of the screen, and improve performance overall, and this is the case with Unity.
    Advanced uses of this may include changing it dynamically based on the Depth Buffer.
    However, Unity just uses this buffer to not render the part of the screen not
    covered by the mask, in particular, assigning the value of 1 to the pixel that
    should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Unity allows nested masks, in particular, using the AND (`&`) operation
    on them. As a result, a pixel will be rendered if and only if it is within all
    the nested masks. You can easily imagine this by overlapping different paper masks
    to a drawing, which is visible only in the parts that all the paper masks overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, Unity has introduced also another kind of Mask, **Rect Mask 2D**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More visual components](img/image00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It has some limitations with respect of the previous mask component, such as
    the fact that it only works in a 2D environment and with coplanar elements (non-coplanar
    is still possible, but the component might not work as it should). However, this
    approach brings some advantages, such as not needing to use the Stencil Buffer
    (see the preceding info box) with consequent performance improvements since there
    are no extra draw calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![More visual components](img/image00427.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another very special visual component is the **Raw Image**. It has some limitations
    with respect to the **Image** component, but has other features. In fact, the
    **Raw Image** doesn''t have the option to animate an image. However, it works
    directly with bytes, as the name suggests. As a result, it is able to display
    not only Sprites as the image, but also textures. To understand why this is useful,
    imagine that a texture is just an array of bytes, and as such, they can change
    at runtime. This means that you may download a texture from a URL during runtime,
    and show it on within a **Raw Image**. Other uses might be the use of **Render
    Textures** (from Unity 5.x, they are also available in the personal edition, and
    not only in the Pro version), and stream what another camera in the game world
    is seeing. This might be used, for instance, to quickly create a minimap in the
    game. You can find this process described in detail in the last chapter of the
    *Unity UI Cookbook* suggested at the beginning of this chapter. One more thing
    about raw images: they have a **UV Rect** option. This means you can scale and
    zoom the image/texture they have as you like, without changing the texture itself.'
  prefs: []
  type: TYPE_NORMAL
- en: UI effect components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the visual components and the interaction ones, Unity has special
    classes of components called effect components. In some books, and in the documentation
    itself, you might find them as a subclass of the visual components.
  prefs: []
  type: TYPE_NORMAL
- en: 'These components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shadow**: This allows us to add a shadow effect to an image or text component.
    It must be attached to the same game object of the text or image component. Its
    options change the distance of the shadow and the color. Furthermore, in the case
    of an image, a Boolean controls if the component in creating the shadow should
    use also the alpha channel of image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![UI effect components](img/image00428.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Outline**: This works similarly to the shadow component, but instead of a
    shadow, it adds an outline. The control options are the same as the shadow component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![UI effect components](img/image00429.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Position as UV1**: When this is on an Image component, Unity passes the canvas
    position through to the first UV channel. This means that if you have a custom
    shader, you can use this to create refraction or an UV offset sampling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI and lights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to all that we have discovered about UI, you can use lights on the
    UI. They are used to make them feel more realistic, especially when the UI is
    place within the 3D world, or when it has a kind of perspective. However, keep
    in mind that adding a light might decrease performance.
  prefs: []
  type: TYPE_NORMAL
- en: If the UI is in a 3D world, you may want it to be affected by the world lights,
    but if it has a perspective, such as in the case of the **Screen Space - Camera**
    of the Canvas, you may want it to just be affected by certain lights. As such,
    you need to create some layers to filter which lights will affect the UI.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not so simple as placing a light in the scene to make a UI component
    affected by light, since you need a material that responds to light. In this case,
    Unity provides specific shaders for UIs. In any case, this is out of the scope
    of the book, since it deals more with 3D game development, rather than 2D. But
    if you are interested in knowing more, in the *Unity UI cookbook*, in *Chapter
    2*, *Creating Panels for Menus*, you'll find a recipe that deals with lights in
    the UI. That is a good start to play with lights within the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The canvas components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the beginning of the chapter, we talked about the Canvas, and its main property
    about the **Render Mode**. However, if we look at the Canvas in the Inspector,
    we can see that it actually has three different components, which usually are
    used all together to make a Canvas. For your convenience, the following screenshot
    shows them in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The canvas components](img/image00430.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a general look at their functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canvas**: This is main component, which actually create the canvas, so Unity
    knows that everything inside it should be rendered as UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canvas Scaler**: This controls the overall scale and pixel density of UI
    elements within the Canvas. This scaling affects everything on the Canvas, including
    font sizes and image borders. There''s more information in the official documentation
    here: [https://docs.unity3d.com/Manual/script-CanvasScaler.html](https://docs.unity3d.com/Manual/script-CanvasScaler.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphic Raycaster**: This component belongs to the event system and allows
    us to detect mouse or touch events with respect to graphics. For more information
    about this component, you can look at the official documentation here: [https://docs.unity3d.com/Manual/script-GraphicRaycaster.html](https://docs.unity3d.com/Manual/script-GraphicRaycaster.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are going to face this topic, I suggest that you study the whole Event
    System framework that Unity provides (see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Canvas group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the UI components we already have seen, there is another one
    called **Canvas Group**. It allows us to define a group, or if you prefer, a subset
    of the UI elements within a Canvas. This is what it looks like in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas group](img/image00431.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, it provides some general functions to apply to all the elements
    belonging to the group. These may include alpha, if, for instance, you want to
    smoothly make part of the interface appear or disappear, or if it is interactable
    (or disabled).
  prefs: []
  type: TYPE_NORMAL
- en: Another common use for **Canvas Group** is to not block mouse events in certain
    areas of the UI, which means the player can click on a button that lies under
    an Image belonging to a **Canvas Group** with the **Blocks Raycast**s property
    set to false.
  prefs: []
  type: TYPE_NORMAL
- en: Event system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we pointed out in the *Canvas* section, every time we create a Canvas in
    new scene, an even system is also created. In fact, game objects contain a series
    of components that allow us to exchange messages between different parts of your
    game. In the case of the UI, the messages that are exchanged are the inputs from
    the user and the UI itself. Without this event system, the interaction components
    will not work. This is what the event system looks like in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event system](img/image00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it is divided into modules (this might change with respect to
    the platform your game is addressed; there's more about this in [Chapter 6](part0077.xhtml#aid-29DRA1
    "Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence"),
    *Through a Sea of Sprinkles – Navigation in Artificial Intelligence*). The basic
    functionalities exposed here allow you, for instance, to define which ones are
    the main interaction buttons/events (in the case of a standalone game).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for our purposes, we don''t need to extensively know how the Even
    System works, how to change its settings, or how to set up a custom message. For
    that, I suggest you read the official documentation here: [https://docs.unity3d.com/Manual/EventSystem.html](https://docs.unity3d.com/Manual/EventSystem.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As far as we're concerned, we just leave the default settings, and every time
    we use the event system in our scripts, we will just use its basic functionalities,
    and will be explained when we encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: With this said, we have covered a lot about UI, especially if you have been
    reading this whole section in one go. If so, I suggest you to take a little break
    before moving on to the next sections, which will guide us through practically
    using the UI interface in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving into our game, let''s mention general UI programming in Unity.
    Each of the elements we have met in the previous section has a class that exposes
    some variables and some functions that we can use within our scripts. However,
    all of these classes are in a different namespace. As such, every time we want
    to use these classes, we need to add the following line of code at the beginning
    of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, we can still use the classes without the `using` statement by explicitly
    call the namespace every time. However, this approach is fine only if we need
    to use the namespace few times. Since we are programming with UI, it is good practice
    to import the namespace by adding the line of code shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the interface for our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to begin designing the layout for our game. You can do this
    on paper or on the computer; it depends on how you feel most comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: In tower defense games, the UI often provides the way to interact with the game.
    Through the UI it is possible to build towers, sell them, or upgrade them. Furthermore,
    the UI is also used to visualize stats such as money and lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a preliminary sketch for designing the UI for our cupcakes tower defense
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the interface for our game](img/image00433.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a number of key components have been mapped out. These are primarily
    around the player's interaction, as well as the way that their opponents, the
    pandas, will move and be targeted on the map. For example, areas where players
    can place towers are roughly indicated, and the direction that the player can
    head in is also displayed. The UI elements, such as health, points, and tower
    upgrades, are also included.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, at this stage, it is all about experimenting with what feels better
    from an interactive point of view and what looks better. By *feels better*, it
    is not directly referring to the aesthetics but also the layout of the UI. Too
    many UI elements in one place can make the screen feel overwhelming, especially
    if they aren't explained properly. Now, this is not to say that you cannot have
    a lot of UI elements. In some instances, games (such as *MMORPG*s) can have a
    large amount of UI elements, but they need to be placed in a way that is meaningful
    and logical. There is no sense in having a purchase tower button on one side,
    then an upgrade button on the other side. The simplest way to consider UI is based
    on routine. If first you buy a tower and then upgrade it, then you need to follow
    that process in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have placed all of the key components at the top of the
    screen. That way, the focus is on the map. The health is indicated with large
    hearts, the score is indicated with large text, and the cupcake towers are in
    the center of the screen. However, what is missing is some labels about what is
    what, such as the score and buy options for the towers. In the following screenshot,
    you can see the final version, where these, as well as few UI adjustments, have
    been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the interface for our game](img/image00434.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the lives became a health bar, since it does make more sense
    for a strategy game (whereas for a platform, maybe lives could have suited better).
    Since we are targeting an occidental audience, we started to place the important
    elements on the left. (I apologize to readers who read from right to left, but
    for learning purposes I had to pick one choice. On the other hand, if you are
    reading this book, that means your understanding of English and languages that
    read from left to right is high enough to justify this interface we are developing).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the amount of sugar is the currency with which the player can upgrade
    and buy new towers. It is another important resource, and therefore has been placed
    below the health bar.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can find a section of the UI where the player is able to buy a tower
    from the three available. The following box, instead, is specific to a single
    tower, and it appears when the player selects a tower. It allows the player to
    sell and upgrade the cupcake tower.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on the right, there is the level name, which is information that the
    player will want to take into consideration, but not as often as health and sugar.
  prefs: []
  type: TYPE_NORMAL
- en: With this said, we have a UI design for our game, so let's start to implement
    it in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the scene for the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of the UI system, it's time to implement
    something within our game to practice a little bit. But the most important outcome
    from the rest of the chapter is to understand how to program UI within the framework
    of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to create a Canvas in our scene, and as a consequence,
    an event system will also be created. You can do it by right-clicking on the **Hierarchy**
    panel and then navigating to **UI** | **Canvas**. Select the **Canvas** object
    from the **Inspector** and tweak the options in the Inspector based on your needs.
    This really depends on your target platform (more on this in the last chapter
    of this book), and the best way to understand which of these options suit your
    needs is to test and test and test again.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to have a nice background for our interface. We got a really
    nice blue bar in our package that you can find in the `Graphics/UI` folder. In
    order to place it within our interface, let's create a new image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **Hierarchy** panel and navigate to **UI** | **Image**.
    We can rename the object `UI_Background`. Drag and drop `ui_blue_top_with_text`
    from the project panel into the Sprite variable of the Image component. Since
    our package is already in proportion with respect to the resolution we decided
    in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in Unity"), *A
    Flat World in Unity*, we can just press the **Set Native Size** button to restore
    the original ratio. Then, scale the bar and place it as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the scene for the UI](img/image00435.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the game view, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the scene for the UI](img/image00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for your convenience, the package contains an instance of the UI, which has
    already placed labels on it. This will allow us to save some time. However, if
    you want to create your UI, remember to place labels and format them with the
    right font.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we have got a place to start developing our UI as we designed it
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a health bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our game world, the terrible sweet-tooth pandas make a lot of trouble for
    our player, especially when they reach the longed-awaited cake. As such, with
    every bite they take, the player will lose some life. However, the player needs
    a way, and so does the game, to keep track of his or her life. In our design,
    we chose a health bar, which we are going to implement in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and placing the health bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within the `UI_Background` we created before, let's create another image by
    selecting **UI** | **Image** (you can right-click directly on `UI_Background`
    to parent already the new image to it). Then, rename it `Health_Bar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign `ui_health_bar_frame` as a Sprite in the `Graphics/UI` folder. Again,
    scale it properly (and if you wish use also the **Set Native Size** button, like
    we did for the bar) and place it as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and placing the health bar](img/image00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to create the health bar filling. Create a new image and name
    it `Health_Bar_Filling`. Assign `ui_health_bar_filling` to the image Sprite, and
    place in the scene as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and placing the health bar](img/image00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the end, you should have the following in the **Hierarchy** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and placing the health bar](img/image00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the **Inspector**, we need to set the **Image Type** of `Health_Bar_Filling`
    to **Filled**. Then, set **Fill** Method to **Horizontal** and **Fill Origin**
    to **Left**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and placing the health bar](img/image00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a result, if we change the amount variable (you can play with in in the Inspector
    with the slider), the bar will be more or less filled, as a health bar should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to actual make the health bar work by using a specific script.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the health bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, after many pages about UI, we start to see some code in this chapter.
    Again, as we said in the last chapter, don't be afraid of code, but try hard to
    understand why it works in that specific way, and you will be rewarded with the
    ability to program a game, which in my opinion is not bad.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's start to create a new Script within the Script folder. If you prefer,
    you can also create a sub-folder named `UI_Scripts`, but this is up to you. We
    can name the script `HealthbarScript`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the script by double-clicking on it. In order to use the UI classes,
    we need to import the namespace. This can be done by adding the following line
    at the beginning of our code, as we already pointed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can use also the UI classes, we need three variables. One is a
    public variable that allows us to decide the maximum amount of health that the
    player can have. The other two are private to keep track of the Image component
    attached to `Health_Bar_Filling`, in order to change the bar filling, and the
    current amount of health that the player possesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set a couple of variables in our `Start()` function, in particular,
    the reference to the UI Image of `Health_Bar_Filling` by using the `GetComponentInChildren()`
    function. We also need to set the current amount of health to the maximum. In
    this way, the player will start with the maximum amount of health, and this makes
    sense. Finally, we call a function to update the graphic of the health bar, which
    we will implement in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to expose a public method to reduce the amount of health the
    player possesses, based on an integer parameter we pass to it. This function will
    be called when one of the sweet-tooth pandas bites the cake, or in the worst-case
    scenario, it will dive into the cake. At the same time, the function should also
    check if the amount of health has reached zero. In this case, for the player,
    the game is over. As such, this function will return a Boolean value, which if
    true, means there is no more cake: the sweet-tooth pandas have eaten it all! Of
    course, we also need to update the graphic of the health bar when we change the
    health amount. Furthermore, to make the code slightly more robust. When the amount
    of health reaches zero or below, the current health is just set to zero and not
    to negative values. Therefore, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to write the function to update the Health Bar graphic, the
    one we have called in the previous functions. First, based on the current amount
    of health and the maximum available, the function computes the percentage (from
    0% to 100%) of the amount of health of the player as a float between `0.0` and
    `1.0`. Note that `*1f` is a fast way to convert the number into a float, and therefore
    make a division between floats, instead of integers. Then, the function assigns
    this percentage to the `fillingAmount` of the image component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have saved the script, it is ready to go. Also, remember to assign
    the maximum amount of health in the Inspector. For the purpose of our game, we
    set it to `100`. At the end, our script will be like the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting the health bar](img/image00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the player has a health, we need to focus on storing and displaying
    the amount of sugar that the player collects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the sugar meter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If in the previous section we have seen how the sweet-tooth pandas can defeat
    the player, now it's time to give the player a way to stop them. The first step
    is to have enough sugar to build cupcakes towers. As such, we need a sugar meter
    to keep track of the amount of sugar that the player possesses.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in our design, this will be a number, and not a bar like the
    health. Therefore, even if the concepts are similar, the implementation is slightly
    different.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and place
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process for creating the sugar meter is similar to the health bar, so let''s
    start to create a new Image, parented with the Canvas, named `Sugar_Meter`. As
    a Sprite, you can use the `ui_sugar_meter` file in the `Graphic/UI` folder. Place
    it, and scale it if necessary, in the scene to match the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and place](img/image00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create a Text component, parent it to `Sugar_Meter`, and name it `Sugar_Meter_Text`.
    You can set the font and the color that you prefer. At the end you should have
    something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and place](img/image00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the end, we should have the following in the **Hierarchy** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and place](img/image00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's make it work with a script.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the sugar meter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script for the sugar meter works similarly to the script for the health
    bar. Let''s import the namespace in order to use UI classes by adding the following
    line at the beginning of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We need two private variables to store the reference to `Sugar_Meter_Text`
    and the actual amount of sugar possessed by the player. As you can see, we don''t
    have a maximum, because in theory the player can accumulate an infinite amount
    of sugar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Start()` function, just get the reference to the UI text and update
    the graphic through a function, which we will implement in few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a generic function to increase or decrease player''s sugar by an
    arbitrary amount the. We also need to take into account that it is not possible
    to have a negative amount of sugar. This is more for code robustness rather than
    a real need for the game. In fact, the only way to decrease the sugar is if the
    player buys cupcake towers (or upgrades their towers), but he or she won''t if
    he or she doesn''t have enough sugar. One last thing to do is to update the graphic
    of the Sugar Meter as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we will need to retrieve the amount of the sugar that the player has
    in the upcoming chapters, mainly to check if he or she has enough to buy an upgrade
    or a tower, we need a function to retrieve this value. The reason to create this
    function is that the sugar amount is a private variable, and we don''t want to
    make it public, since for robustness we want it to change only with the `ChangeSugar()`
    function, which updates the graphic too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need the function to update the graphic. This function converts
    the amount of sugar possessed by the player into a string, and assigns the string
    to the **Text** component of `Sugar_Meter_Text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the script is saved, we don't have any parameters to set in the **Inspector**.
    Therefore, our sugar meter is ready to measure the amount of sugar.
  prefs: []
  type: TYPE_NORMAL
- en: More about UI scripting – handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last topic that we need to cover, since we will be using this technique
    later on in [Chapter 7](part0088.xhtml#aid-2JTHG1 "Chapter 7. Trading Cupcakes
    and the Ultimate Battle for the Cake – Gameplay Programming"), *Trading Cupcakes
    and the Ultimate Battle for the Cake – Gameplay Programming* .
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you want to create an UI component that does something when it
    is clicked. We could create a script with a public function, then attach a button
    component to the game object. Finally, we should create a new `OnClick()` event
    on the button component to trigger the function we have written before. It's fine,
    but isn't a bit laborious?
  prefs: []
  type: TYPE_NORMAL
- en: Another example is, suppose you need to drag a UI component around because it
    is a floating window. How are you going to do it? For what we have seen so far,
    this appears to be an hard task; but there is an easy solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, in our scripts, we can directly include directly the event systems,
    by using this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As a result, you will be able to extend your script with some (C#) interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case you don''t know what a C# interface is or don''t know how to use it,
    you can check any C# manual. However, I recommend this video from the official
    Documentation of Unity, since it applies interfaces directly to Unity: [https://unity3d.com/learn/tutorials/topics/scripting/interfaces](https://unity3d.com/learn/tutorials/topics/scripting/interfaces).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These interfaces allow you to create a function within your script that is
    triggered whenever the specific event you chose occurs. Moreover, this function
    provides some information about that specific event as a parameter within the
    `PointerEventData` class. For instance, to implement our dragging behavior from
    before, we need to add a handler/interface for the drag event next to the class
    declaration, like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to implement the interface with its specific function. In this
    case we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you are using Visual Studio as your code editor, you can right-click
    on the name of the interface and from the quick action menu select **Implement
    interface** to automatically create that the function we need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, implementing the drag behavior is simple, since within the `eventData`
    variable, we have all the data regarding the event, such as the mouse position.
    Therefore, we can write the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively, you can also use the `Input` class, as shown here: `transform.position
    = Input.mousePosition;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete list of events you can consult the official documentation here:
    [https://docs.unity3d.com/ScriptReference/EventSystems.EventTrigger.html](https://docs.unity3d.com/ScriptReference/EventSystems.EventTrigger.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For details about the `PointerEventData` class and which kind of information
    of an event it holds, here is the link to the official documentation: [https://docs.unity3d.com/ScriptReference/EventSystems.PointerEventData.html](https://docs.unity3d.com/ScriptReference/EventSystems.PointerEventData.html).'
  prefs: []
  type: TYPE_NORMAL
- en: What about all the rest?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What about all the cool menu interfaces, and all the gameplay interface to buy/sell
    towers that the book promised? Well, don't you think we have learned a lot in
    this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this chapter provided a lot of information about UIs, and I suggest
    you take your time to get familiar with all the concepts, as well as doing the
    exercises in the next section. Then, we will come back to implementing all of
    this when we will build the gameplay in [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at many aspects of UIs in the first part, whereas
    we got handy with it in the second part, by implementing a UI within our game.
    However, before going on to the next chapter, I invite you to take a look at these
    exercises to improve your UI designing/programming skills. They are divided, for
    your convenience, into two parts: the first to improve your designing skills,
    and the second to improve your programming skills.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Improving UI designing skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A great exercise**: A great exercise is to find around three examples of
    games that you like, which are all different. For example, choose a strategy,
    adventure, and puzzle game. Next, for each of them, write down, or draw and annotate,
    each of the UI elements, what their function is, and what happens when a user
    interacts with it. For example, if the user presses the next button, what happens?
    Do they go to a new screen, or does a pop-up appear? You don''t have to do this
    for the entire game, but enough to get a feel for how the UI works, and to understand
    how the placement of icons impact the user''s experience. Next, try to experiment
    with changing the way that the UI is positioned and even the types of UI element.
    For example, if there is a health bar on the left, move it to the right or substitute
    the bar with text and see how it changes the feel. The main purpose of this exercise
    is to keep experimenting with different approaches to the UI. This is especially
    useful when you may have too many elements on screen, and as a result you need
    to remove some. In this way, you will have begun to develop different ideas and
    approaches to modifying the UI to achieve different types of interaction. Finally,
    document what you have done, and feel gratified by what you have accomplished
    and learned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A frame interface (part I)**: Take the map provided in the package of this
    book (or the one you are currently using). Now imagine that, instead of having
    only a bar at the top for the UI, you have also a right lateral bar. Furthermore,
    imagine to have more than 20 kinds of cupcakes tower, two kinds of sugar that
    the player can collect, brown and white, and that for each tower the player can
    decide two different upgrades other than selling. In this scenario, design an
    interface that easily display to the player all what he or she needs. In particular,
    ensure that the interface is intuitive, and could be used even without an explanation.
    At the end, ask to your friends to take a look at the paper prototype of your
    interface and check if it really achieves what you had in mind. Little tip: it''s
    impossible to fit 20 kinds of tower all at once in the interface; therefore, you
    may want to divide them into categories, or have a scrollable area with all the
    towers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A frame interface (part II)**: Once you have designed the interface of the
    previous exercise, look carefully at the colors of the map provided into our package
    (or the one you are currently using). Now, choose the color palette carefully
    for your UI so that there is enough contrast to be able to read the interface
    without much effort, but at the same time it is pleasant to look at, since it
    is in harmony with the colors of the map.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A frame interface (part III)**: Now it''s time to create all the graphics
    necessary for the design you have created in the last two exercise. You can create
    the graphics from scratch, or take part of the graphics from the package of this
    book. Once created, import them into Unity, including slicing, dividing into Sprites,
    and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Improving your UI programming skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An evil button**: We have seen that the event on the button is triggered
    only when the pointer is released and still within the button. In fact, if the
    player moves the pointer out the component, the event won''t be triggered. In
    the case of an evil button, once the player has clicked it, it''s done, the action
    will be executed. However, in the case of the button, the action is not executed
    when the player clicks, but when released. Implement an evil button so that even
    if the player moves the pointer away from the button and release, the button will
    still trigger the action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The selected toggle**: Unfortunately, at the moment, Unity doesn''t have
    any functions to retrieve the toggle that is selected from a toggle group. If
    by the time you are reading this book, a new version of Unity releases this function,
    you can still improve your skills by doing this exercise and ignoring the new
    pre-made function of Unity. In fact, having the ability to retrieve the active
    toggle is really handy in many situations and in many of your games. As such,
    implement a script that given a toggle group with an arbitrary number of toggles
    is able to retrieve and return the selected one (if any; in fact, there might
    be none).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Runtime dropdown (part I)**: Read the official documentation of the drop-down
    component carefully, and implement one that can change the number of options at
    runtime. In particular, place a toggle group that allows the player to pick a
    set. Every set contains different options for the drop-down menu. Once the player
    choses a set, the options of the set are loaded into the drop-down menu (there
    should be only one drop-down menu in the scene, and you need to dynamically load
    the new options). Little tip: since the number of options in each set is variable,
    the easiest way to do this is to clear all the previous options of the drop-down
    menu and load the new ones.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Runtime dropdown (part II)**: If you want to go further, take the previous
    exercise and through a Input Field and a button allow the player to add an option
    to the current selected set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Runtime dropdown (part III)**: If you felt confident doing the previous exercise,
    keep going by implementing the possibility to remove an option from the set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The lighting pointer**: If you have read the UI effect component section,
    you will know about the existence of a special component that creates shadows.
    Place a text in the middle of your scene and apply the shadow component. Play
    a little bit with its values to understand how they work, and how to simulate
    the light coming from different directions. Now, implement a script that, based
    on the pointer positions, changes the shadow component so that it seems that the
    pointer has a kind of light on the text. Therefore, if the pointer is above the
    text, the shadow will be below, whereas if the pointer is on the left, the shadow
    will be on the right. By the way, I warn you that a possible consequence of doing
    this exercise is to create something that you will spend a fairly large amount
    of time to play with, because playing with it can become addictive!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Again Prefabs**: We faced prefabs in the previous section, in game development
    they are always really useful, particularly when you have multiple scenes and
    we don''t want to implement the whole UI again for each level. Since we are going
    to create different levels in the last chapter, it''s a good idea and good practice
    to create a prefab for each of the main UI functionalities. As such, create a
    prefab for the health bar, one for the sugar meter, one for the buy section of
    the UI and another one for the upgrade/selling section of the UI. Furthermore,
    create one last prefab containing all the UI (basically the canvas along with
    all its children). In this way, we can just place this last prefab in the scene
    in the next levels. However, remember to then add an Event System manually in
    the new scene.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A frame interface (part IV)**: If you have done at least the part 1 of this
    exercise, you have designed an interface. Scale the map so that you can create
    the frame described in part 1\. Then, implement the interface. Afterwards, test
    the interface again with your friends to check if it feels right now that it is
    digital. Eventually, modify it based on the suggestions of your friends, and don''t
    forget to share your work, also with me if you want. If you also quote the book,
    I''d be pleased.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A negative damage**: When we created our health bar script, we wrote a function
    to apply damage, and it checks if the health has reached zero. However, what about
    a negative damage? In that case, the health of the player increases, and it shouldn''t.
    Therefore, add a control to avoid a negative damage, such as setting the damage
    to zero if it''s below zero.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Healing the player**: If you have done the previous exercise, it''s not because
    we are sadistic against the player, but because that function should only apply
    damage. To heal the player instead, create another function that takes as a parameter
    an amount to cure the player, and checks if the health is no more than the maximum
    amount. If so, it just caps the health to the maximum.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Warning the player I**: When the health goes below 30% means that the sweet-tooth
    pandas are devouring the cake, and the player should be warned. Warn the player
    by showing a pop-up that appears on the screen only once, when the health is below
    30%.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Warning the Player II**: In the same vein as the previous exercise, a pop
    up menu could disturb the gameplay. Therefore, warn the player in this way: change
    the color of the health bar to yellow when the health is between 20% and 40%,
    and to red when it is below 20%. Of course, restore the green color once the health
    is above 40%.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter began with an introduction to UI designing and programming, in order
    to understand the main complications behind UIs and why they are so important.
    Then, in the first part of the chapter, we saw in detail how the Unity UI system
    works. In particular, we analyzed every component of the Unity framework and learned
    their use and functionality. In addition, a section explained some special components
    present in the framework, but that we won't need for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more about UI designing and programming (although with a major
    focus on gamification), including also how to use Illustrator to create your own
    graphic, in *Gamification with Unity 5.x* by *Lauren S. Ferro*, *Packt publishing*.
    You can find the book here: [https://www.packtpub.com/game-development/gamification-unity-5x](https://www.packtpub.com/game-development/gamification-unity-5x).'
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, we started to create the UI for the tower defense game.
    In particular, we implemented the logic for a health bar as well as for a sugar
    meter. However, we will implement more in [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are not going to be alone anymore. In fact, we will
    finally meet the terrible sweet-tooth pandas we have so anticipated.
  prefs: []
  type: TYPE_NORMAL
