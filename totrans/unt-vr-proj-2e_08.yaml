- en: Playing with Physics and Fire
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use physics and other Unity features to build variations
    of an interactive ball game. Along the way, we explore managing objects, Rigidbody
    physics, and adding more interactivity to the virtual experience. You will see
    how properties and materials based on physics can be added to objects, as well
    as more on C# scripting, particle effects, and music.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The Unity physics engine, the Unity Rigidbody component, and Physic Materials
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using velocity and gravity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing object lifetime and object pooling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with objects in VR using your head and hands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a fireball using particle effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing with music
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the projects in this chapter are separate and are not directly required
    by the other chapters in this book. If you decided to skip any of it or not save
    your work, that's OK.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Unity physics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Unity, the behavior of an object that is based on physics is defined separately
    from its mesh (shape), materials (UV texture), and the renderer properties. The
    items that play into physics include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Rigidbody**: Enables the object to act under the control of the physics engine,
    receive forces and torque to move in a realistic way'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collider**: Defines a simplified, approximated shape of the object used for
    calculating collisions with other objects'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physic Material**: Defines friction and bounce effects of colliding objects'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Manager**: Applies global settings for 3D physics for your project'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, physics (in this context) is defined by the positional and rotational
    forces that affect the transform of an object, such as gravity, friction, momentum,
    and collisions with other objects. It is not necessarily a perfect simulation
    of physics in the real world because it's optimized for performance and separation
    of concerns to facilitate animation. Besides, virtual worlds might just need their
    own laws of physics that aren't found in our God-given universe!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Unity integrates the **NVIDIA PhysX** engine, a real-time physics calculation
    middleware, which implements classical Newtonian mechanics for games and 3D applications.
    This multiplatform software is optimized to utilize fast hardware processors when
    present. It is accessible via the Unity scripting API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A key to physics is the Rigidbody component that you add to objects. Rigidbodies
    have parameters for gravity, mass, and drag, among others. Rigidbodies can automatically
    react to gravity and collisions with other objects. No extra scripting is needed
    for this. During gameplay, the engine calculates each rigid object's momentum
    and updates its transform position and rotation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Details on Rigidbodies can be found at [http://docs.unity3d.com/ScriptReference/Rigidbody.html](http://docs.unity3d.com/ScriptReference/Rigidbody.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Unity projects have a global gravity setting, found in the project's Physics
    Manager by navigating to Edit | Project Settings | Physics. As you might expect,
    the default gravity setting is a Vector3 with values (`0`, `-9.81`, `0`) that
    apply a downward force to all Rigidbodies. Gravity is in meters per second squared.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 项目有一个全局重力设置，可以在项目设置中的物理管理器中找到，方法是导航到 Edit | Project Settings | Physics。正如您所期望的，默认的重力设置是一个具有值的
    Vector3 (`0`, `-9.81`, `0`)，它对所有 Rigidbody 应用向下的力。重力以每秒平方米计算。
- en: Rigidbodies can automatically react to gravity and collisions with other objects.
    Extra scripting is not needed for this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体可以自动对重力和其他物体的碰撞做出反应。不需要额外的脚本编写。
- en: In order to detect a collision, both the colliding objects must have a `Collider`
    component. There are built-in colliders with basic geometric shapes such as a
    cube, sphere, cylinder, and a capsule. A mesh collider can assume an arbitrary
    shape. If you can, it's best to use one or more basic collider shapes that approximately
    fit the actual object, rather than a mesh collider to reduce the expense of calculating
    the actual collisions during gameplay. Unity requires that if your object will
    be used in physics and has a Rigidbody, then its mesh collider must be marked
    as convex and be limited to 255 triangles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测碰撞，碰撞的物体都必须具有 `Collider` 组件。有内置的具有基本几何形状的碰撞器，例如立方体、球体、圆柱体和胶囊。网格碰撞器可以假设任意形状。如果可能的话，最好使用一个或多个基本碰撞器形状，这些形状大致适合实际物体，而不是使用网格碰撞器，以减少游戏过程中实际碰撞计算的消耗。Unity
    要求，如果您的对象将用于物理并且具有 Rigidbody，则其网格碰撞器必须标记为凸形，并且限制为 255 个三角形。
- en: When rigid objects collide, the forces pertinent to each object in the collision
    are applied to the others. The values of the resulting forces are calculated based
    on the objects' current velocity and body mass. Other factors are also taken into
    consideration, such as gravity and drag (that is, resistance). Furthermore, you
    have options to add constraints to freeze the position or rotation of a given
    object in any of its *x*, *y*, and *z* axes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚性物体碰撞时，碰撞中每个物体的相关力会作用于其他物体。这些力的值是根据物体的当前速度和体重计算的。还会考虑其他因素，例如重力（即阻力）。此外，您可以选择添加约束来冻结给定物体在任何
    *x*、*y* 和 *z* 轴上的位置或旋转。
- en: The calculations can be further affected when a Physic Material is assigned
    to the object's collider, which adjusts the friction and the bounciness effects
    of the colliding objects. These properties will be applied only to the object
    that owns the Physic Material. (Note that it's really spelled *Physic Material*
    rather than *Physics Material* for historical reasons.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当将物理材料分配给对象的碰撞器时，计算可以进一步受到影响，这会调整碰撞物体的摩擦和弹性效果。这些属性仅适用于拥有物理材料的对象。（注意，由于历史原因，它实际上拼写为
    *Physic Material* 而不是 *Physics Material*。）
- en: So, let's say that Object A (Ball) hits Object B (Brick). If Object A has bounciness
    and Object B does not, Object A will have an impulse applied in the collision,
    but Object B will not. However, you have options to determine how their friction
    and bounciness combine, as we'll see next. It's not necessarily an accurate simulation
    of real-world physics. It's a game engine, not a computer-aided engineering modeler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设对象 A（球）击中对象 B（砖块）。如果对象 A 有弹性而对象 B 没有，则在碰撞中对象 A 将会有一个冲量，但对象 B 不会有。然而，您可以选择确定它们的摩擦和弹性的组合方式，正如我们接下来将要看到的。这并不一定是一个真实世界物理的准确模拟。这是一个游戏引擎，而不是计算机辅助工程模型器。
- en: From a scripting point of view, Unity will trigger events when objects collide
    (`OnTriggerEnter`), each frame while objects are colliding (`OnTriggerStay`),
    and when they've stopped colliding (`OnTriggerExit`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本的角度来看，Unity 会在物体碰撞时触发事件（`OnTriggerEnter`），在物体碰撞的每一帧触发（`OnTriggerStay`），以及当它们停止碰撞时（`OnTriggerExit`）。
- en: If this sounds daunting, read on. The rest of this chapter breaks it down into
    understandable bits and pieces.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来令人畏惧，请继续阅读。本章的其余部分将将其分解成可理解的部分。
- en: Bouncy balls
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性球
- en: The feature we'll implement here is, when a ball drops from mid-air and hits
    the ground, it bounces back up and down, and up again, diminished over time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要实现的功能是，当一个球从空中落下并击中地面时，它会弹起并上下跳动，然后再次弹起，随着时间的推移逐渐减弱。
- en: 'We are going to start simply with a new scene that consists of a ground plane
    and a sphere. Then, we''ll add physics to it, a bit at a time, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的场景开始，该场景由地面平面和球体组成。然后，我们将逐步添加物理效果，如下所示：
- en: Create a new scene by navigating to File | New Scene.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 File | New Scene 创建一个新的场景。
- en: Then, navigate to File | Save Scene As... and name it `BallsFromHeaven`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new plane by navigating to GameObject | 3D Object | Plane and reset
    its transform using the `Transform` component's *gear* icon | Reset.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new sphere by navigating to GameObject | 3D Object | Sphere and rename
    it `BouncyBall`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.5`, `0.5`, `0.5`) and Position to (`0`, `5`,`0`) so that
    it's above the center of the plane.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Red material from Project Assets (created in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects and Scale*) onto it so that it looks like a bouncy ball.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new Unity scene defaults come with Directional Light and Main Camera. It's
    OK to use this Main Camera for the time being.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Click on the *Play* button. Nothing happens. The ball just sits in mid-air and
    doesn't move.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give it a Rigidbody, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: With `BouncyBall` selected, in Inspector, navigate to Add Component | Physics
    | Rigidbody.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *Play* button. It drops like a lead balloon.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s make it bounce, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, select the top-level Assets folder, navigate to Create
    | Folder, and rename it to `Physics`
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Physics` folder selected, create a material by navigating to Assets
    | Create | Physic Material (or right-click within the folder)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Bouncy`
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Bounciness value to `1`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `BouncyBall` sphere selected in Hierarchy, drag the `Bouncy` asset
    from Project onto the sphere's Collider material field in Inspector
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the *Play* button. It bounces, but it does not go very high. We used
    the maximum value for Bounciness as `1.0`. What''s slowing it down? It''s not
    the Friction settings. Rather, the Bounce Combine is set to Average, which determines
    how much of the bounciness of the ball (1) is mixed with that of the plane (0).
    So, it diminishes rapidly over time. We want the ball to retain all its bounciness.
    We will accomplish this, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Change the `Bouncy` object's Bounce Combine to Maximum.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *Play* button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Much better. Actually, too much better. The ball keeps bouncing back up to its
    original height, ignoring gravity. Now, change the Bounciness to `0.8`. The bounces
    diminish, and the ball will eventually come to a stop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check it out in VR, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Delete the default Main Camera from the Hierarchy root.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `MeMyselfEye` prefab from Project Assets into the scene. Set its Position
    to (`0`, `0`, `-4`).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it in VR. Pretty neat! Even the simplest things look impressive in VR.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Standard Assets package includes a handful of example physic materials,
    including Bouncy, Ice, Meta, Rubber, and Wood.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s have some fun. Make it rain bouncy balls! To do this, we''ll make
    the ball a prefab and write a script that instantiates new balls, dropping them
    from random positions, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `BouncyBall` object from Hierarchy into the `Project Assets/Prefabs`
    folder, making it a prefab.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `BouncyBall` object from the Hierarchy, since we'll be instantiating
    it with a script.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty game controller object to attach the script to by navigating
    to GameObject | Create Empty. Rename it `GameController`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, navigate to Add Component | New Script, name it `BallsFromHeaven`,
    and open the script for editing.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script so that it looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script drops a new ball from `startHeight` at the rate of every `interval`
    seconds (an interval of 0.5 means that a new ball is dropped every half second).
    The new ball position is at a random X-Z coordinate between `-4` and `4`. The
    `Instantiate()` function adds a new ball into the scene Hierarchy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script. We now need to populate the Ball field with the `BouncyBall`
    prefab, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: With `GameController` selected in Hierarchy, drag the `BouncyBall` prefab from
    the `Project Assets/Prefabs` folder onto the Ball Prefab slot in the Balls From
    Heaven (Script) panel in Inspector.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to use the `BouncyBall` prefab from Project Assets so that can be instantiated.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene. Run it in VR. Fun!
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is what I get:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7f360b3-958d-4b64-9112-97115152fc74.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: In summary, we created a sphere with a Rigidbody and added a Physic Material
    with a Bounciness property of `0.8` and Bounce Combine to Maximum. Then, we saved
    the `BouncyBall` as a prefab and wrote a script to instantiate new balls that
    drop from above.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Managing game objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you have a script that instantiates objects, you must be aware of the
    life cycle of the object and possibly arrange to destroy it when it is no longer
    needed. You can destroy game objects, for example, after it is no longer visible
    in the scene, or after a specific life duration, or limit the scene to a maximum
    number of balls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Destroying fallen objects
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our scene, we have a limited size ground plane and as balls hit one another,
    some will fall off the plane into oblivion. At that point, we can remove the fallen
    ball from the scene. Watch the Hierarchy panel as new balls are instantiated.
    Note that some balls end up bouncing off the plane platform but remain in the
    Hierarchy panel. We need to clean this up by adding a script that destroys the
    balls that are out of play, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Select the `BouncyBall` prefab in `Project Assets/Prefabs`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add Component | New Script and name it `DestroyBall`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a `DestroyBall.cs` script, which will destroy the object if its Y position
    is well below the ground plane (Y = `0`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting a limited lifetime
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another strategy for managing object life cycle is to limit their duration.
    This is especially effective for things like projectiles (bullets, arrows, bouncyballs)
    or other objects that the player cares about most when its instantiated and then
    isn't paying attention to as gameplay moves on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: To implement, you could put a timer on the object prefab itself to destroy itself
    when time runs out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `DestroyBall.cs` script to destroy the object after `delay` seconds:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you play, notice that the ground plane remains substantially less crowded
    than before. Each BouncyBall will be destroyed after 15 seconds or when it has
    fallen off the plane, whichever comes first.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an object pool
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your `GameController` Interval is 0.5 seconds and the destroy timer is 15,
    then (do the math) there will be at most 30 balls in play at a time. Or less,
    if some have fallen over the edge. In that case, we do not need to make our app
    continuously allocate new memory for a new instance of BouncyBall, only to delete
    that object up to 15 seconds later. Too much instantiation and destroying of objects
    results in fragmented memory. Unity will periodically go through and clean this
    up, a computationally expensive process called **garbage collection** (**GC**)
    that is best to be avoided whenever possible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling is when you create a list of reusable objects to be used in your
    game, rather than continuously instantiating new ones. You will activate/deactivate
    the objects instead of instantiate/destroy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, we will write a generic object pooler and add it to the `GameController`
    in the scene.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we are also introducing you to the concept of lists in C#. As the
    name indicates, a list is an ordered collection of objects, like an array. Lists
    can be searched, sorted, and otherwise manipulated (see the documentation here: [https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx](https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx)).
    We will use them simply to hold our pre-instantiated objects. Let''s name the
    script `ObjectPooler`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Select the `GameController` in Hierarchy
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add Component | New Script and name it `ObjectPooler`
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open for editing. Let''s start by declaring several variables at the top:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The public `prefab` will get the prefab object we want to instantiate, namely `BouncyBall`.
    And `pooledAmount` says how many objects to initially instantiate. The actual
    list is held in `pooledObjects`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when the scene starts, we initialize the list as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We allocate a new list and populate it in the `for` loop, by instantiating our
    prefab, initially making it inactive, and adding it to the list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we want a new object, we''ll call `GetPooledObject`, which looks for
    one in the list that is presently not active. If all of them are active and none
    is available for reuse, we return `null`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also enhance the script to optionally grow the list so it never returns
    null. Add the option at the top:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add the following statements to `GetPooledObject` after the `for` loop:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save the script, attach it to `GameController`, and drag the `BouncyBall` prefab
    onto the Prefab slot for the component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to modify our `BallsFromHeaven` script to call `GetPooledObject`
    from `ObjectPooler` instead of `Instantiate`. The updated `BallsFromHeaven` script
    is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we added a directive, `[RequireComponent(typeof(ObjectPooler)]`, to
    ensure the object has an `ObjectPooler` component (and we also double-check in
    the `Start` function).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了一个指令`[RequireComponent(typeof(ObjectPooler))]`，以确保对象具有`ObjectPooler`组件（我们还在`Start`函数中进行了双重检查）。
- en: It's important to note that since we're not instantiating new objects but reusing
    them, you may need to reset any object properties to their starting values. In
    this case, we reset not just the transform but the RigidBody's velocity to zero.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，由于我们不是实例化新对象而是重用它们，你可能需要将任何对象属性重置为其起始值。在这种情况下，我们不仅重置了变换，还将RigidBody的速度重置为零。
- en: 'The last part is we modify `DestroyBall` to just disable (deactivate) the object
    rather than literally destroying it. Initially, handle the *fallen off the ground
    plane* case as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是我们修改`DestroyBall`，使其只是禁用（非激活）对象而不是真正销毁它。最初，处理*掉落在地面平面之外*的情况如下：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of calling `Destroy`, we changed `Update` to call a new function, `DisableMe`,
    which simply deactivates the object, returning it to the pool of available objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有调用`Destroy`，而是将`Update`改为调用一个新的函数`DisableMe`，该函数简单地禁用对象，将其返回到可用对象池中。
- en: 'For the timed destroy, there''s a number of different ways to implement this.
    Earlier, we called `Destroy(gameObject, timer)` from `Start()`. We can do something
    similar, using `OnEnable` instead of `Start`, since that''s when this instance
    starts. And it calls  `Invoke()`, instead of destroy directly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于定时销毁，有几种不同的实现方式。之前，我们从`Start()`中调用了`Destroy(gameObject, timer)`。我们可以做类似的事情，使用`OnEnable`而不是`Start`，因为这是这个实例开始的时候。它调用`Invoke()`而不是直接销毁：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We also provide an `OnDisable` to cancel the `Invoke`, since the object could
    be disabled should the ball fall over the edge before the timer is done and potentially
    re-enabled, we should make sure it's not being invoked twice at the same time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个`OnDisable`来取消`Invoke`，因为如果球在计时器完成之前掉落边缘，对象可能会被禁用并可能重新启用，我们应该确保它不会同时被调用两次。
- en: 'Now when you press Play, you can see in Inspector that new BouncyBalls are
    instantiated at the start to initialize the list, and then as it plays the objects
    are disabled and reactivated as they are returned to the pool and reused, as shown
    here (deactivated BouncyBall(Clone) objects are dimmer than the activated ones):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你按下播放时，你可以在检查器中看到，新的BouncyBalls在开始时被实例化以初始化列表，然后随着游戏的进行，对象被禁用并在返回池中重新激活，如图所示（禁用的BouncyBall(Clone)对象比激活的对象暗淡）：
- en: '![](img/5d35d2d7-88a8-45a7-baa1-6506d9bd3ac9.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d35d2d7-88a8-45a7-baa1-6506d9bd3ac9.png)'
- en: Headshot game
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部瞄准游戏
- en: Wouldn't it be fun to actually play with these bouncy balls? Let's make a game
    where you aim the ball at a target using headshots. For this game, balls drop
    one at a time from above and bounce off your forehead (face), aiming for a target.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上玩这些弹跳球会很有趣吗？让我们制作一个游戏，你可以用头部瞄准目标。在这个游戏中，球一个接一个地从上方落下，弹在你的额头（脸部）上，瞄准目标。
- en: The feature we'll implement here is, when a ball drops from above your head,
    you bounce it off your face and aim for a target.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要实现的功能是，当球从你头顶上方落下时，你将其弹回你的脸部，并瞄准目标。
- en: To implement this, create a cube as a child of the camera object (much like
    we did for the reticle cursor in [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml),
    *World Space UI*).  This provides a collider parented by the VR camera, so our
    head pose will move the face of the cube. I decided a cube-shaped collider will
    be better for this game than a sphere or capsule because it provides a flat face
    that will make the bounce direction more predictable. Balls will drop out of the
    sky. For a target, we'll use a flattened cylinder. We'll add audio cues to indicate
    when a new ball has been released and when a ball hits the target.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，创建一个作为相机对象子对象的立方体（就像我们在第6章中为瞄准十字准星所做的），*世界空间UI*。这提供了一个由VR相机父化的碰撞器，因此我们的头部姿态会移动立方体的面。我决定立方体形状的碰撞器比球体或胶囊体更适合这个游戏，因为它提供了一个平坦的面，这将使弹跳方向更加可预测。球将从天空中落下。我们将使用一个压扁的圆柱体作为目标。我们将添加音频提示，以指示何时释放新球以及何时球击中目标。
- en: 'Create a new scene or, more simple, start here by doing a Save As, and implement
    the head as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，或者更简单地说，通过执行“另存为”操作从这里开始，并按照以下方式实现头部动作：
- en: Navigate to File | Save Scene As and name it `BallGame`
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“文件”|“另存场景为”，并将其命名为`BallGame`
- en: Delete the `BallsFromHeaven` script component attached to `GameController` using
    the *gear* icon Remove Component. We won't need it
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Hierarchy, unfold `MeMyselfEye`, drilling down to the `Camera` object and
    selecting it (for OpenVR that might be  `[CameraRig]/Camera (head)`; for Daydream,
    it may be  `Player/Main Camera/`)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new 3D Object | Cube
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `GameController` selected, navigate to Add Component | Audio | Audio Source
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the small *circle-shaped* icon on the far right of the AudioClip field
    of Audio Source to open the Select AudioClip dialog box and choose the clip named
    `Jump`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `GameController` selected, navigate to Add Component | New Script, name
    it `BallGame`, and open it for editing
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can decide to disable the cube's Mesh Renderer, but I think it's cool to
    watch it in the Scene window as you play. Since the camera is inside the cube,
    the player will not see it (since only the outward facing surfaces are rendered
    in the game view).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We'll play the `Jump` sound clip (provided with the `Characters` package of
    Unity's Standard Assets) to indicate when a new ball is dropped. You might try
    another, perhaps more interesting, effect.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `BallGame.cs` script. It looks a lot like the `BallsFromHeaven`
    one with just a few differences:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We instantiate a new ball every 3 seconds ( `interval` ) from a `startHeight`
    position above the current head position.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The drop point defaults to directly above the player''s head position, as defined
    by the VR camera. That may feel uncomfortable on your neck, so let''s extent it
    in front a little, 0.2 units:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: As a child of `MeMyselfEye` (or as a child of your head or main camera object),
    create an empty game object and name it `Drop Point`
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to (`0`, `0`, `0.2`)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag this `Drop Point` onto the `GameController`'s Ball Game Drop Point slot
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On positionally tracked VR rigs, if your drop point is relative to the camera,
    it will follow the player around. If it's relative to `MeMyselfEye`, it will be
    relative to your play space while the player can move around.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Try it in VR.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: When you hear the ball, look up and aim the angle of your face to direct the
    bounce of the ball. *COOOL!*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need the target. Perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Create a flat cylinder for the target, navigate to Game Object | 3D Object |
    Cylinder, and name it `Target`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`3`, `0.1`, `3`) and Position to (`1`, `0.2`, `2.5`) so that
    it's out in front of you on the ground.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Blue` material from the `Project Assets/Materials` folder (created
    in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects
    and Scale*) onto it, or make a new one.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that its default Capsule Collider is domed, and it really won't do. On
    the Capsule Collider, select its *gear* icon | Remove Component.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to Add Component | Physics | Mesh Collider.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new Mesh Collider, enable the Convex checkbox and the Is Trigger checkbox
    too.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an audio source by navigating to Add Component | Audio | Audio Source.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Target` selected, click on the small *circle* icon on the far right
    of the AudioClip field to open the Select AudioClip dialog box, and choose the
    clip named `Land` (found in Standard Assets).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play On Awake checkbox.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And a new script, navigate to Add Component | New Script, name it `TriggerSound`,
    and open it in MonoDevelop.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we enabled Is Trigger, when something hits the collider, the `OnTriggerEnter`
    and other event handlers will get a call when present on the target object. The
    following `TriggerSound.cs` script will play a sound clip when you hit the target
    with a ball:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The ball enters the target's collider and the physics engine invokes a trigger
    enter event. The script uses the `OnTriggerEnter()` handler to play the audio
    clip.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of the collider properties and trigger events, including `OnTrggerEnter`
    and `OnTriggerExit`, see the documentation at [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it in VR. It''s a VR game! The following image shows the scene with the
    first person''s colliders and a ball bouncing off the cube collider towards the
    target:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/491546fa-fc3c-4d53-a7f8-179256fdd125.png)**Extra challenge**: Keep
    score. Provide an aiming reticle. Add a backboard. Add other features to make
    the game more challenging. For instance, you can vary the fire interval or increase
    the initial ball velocity.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we assigned Bounciness through a Physic Material attached
    to a sphere object. When the ball collides with another object, the Unity physics
    engine considers this bounciness to determine the ball's new velocity and direction.
    In the following section, we'll look at how one can transfer a bounce force from
    one object to another.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Paddle ball game
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll add hand controlled paddles to hit the ball. To keep things somewhat
    generic, our game paddles will be simple objects parented by the hand controllers
    in your camera rig. We'll move the target to be on a wall instead of the floor,
    and serve the balls a little further out in front of you so they're reachable
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: To set up the scene, you can Save As a new name and we'll work from here. I'll
    name my `PaddleBallGame`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Select File | Save Scene As and name it `PaddleBallGame`
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the head Cube we previously added as child of the camera, if present
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's create a paddle. We'll construct a very simple model using cylinders.
    You can find better ones, shaped and textured, online.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy root, Create | Create Empty, name it `Paddle`, and reset its
    Transform
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a child cylinder object (Create | 3D Object | Cylinder) and name it `Handle`
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Handle's Scale to (`0.02`, `0.1`, `0.02`)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another Cylinder as a sibling of Handle and name it `Pad`
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the pad's Scale to (`0.2`, `0.005`, `0.2`), Rotation (`90`, `0`, `0`), and
    Position (`0`, `0.2`, `0`)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your Project Materials folder, create a new material (Create | Material)
    and name it `Paddle` `Material`
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the material Albedo a wooden color, such as (`107`, `79`, `54`, `255`),
    then drag the material onto the Handle and Pad objects
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, modify the colliders:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Select the Handle, and delete its Capsule Collider
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Pad, and delete its Capsule Collider
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Pad selected, add a Mesh Collider (Add Component | Physics | Mesh Collider)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Convex checkbox
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the paddle as a prefab:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Paddle into your Project Prefabs folder
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Paddle from your Hierarchy
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to parent the Paddle to your hands. This is platform-specific. If you
    are using OpenVR, for example, that may be `MeMyselfEye / [CameraRig] / Controller`
    *(right)*. On Daydream, that might be `MeMyselfEye / Player / GvrControllerPointer.`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select the hand controller within `MeMyselfEye` (such as Controller
    (right). or `GvrControllerPointer`)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Empty child game object and name it `Hand` (reset its Transform if needed)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another Empty child beneath Hand and name it `Attach Point` (and reset
    its Transform if needed)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Paddle prefab from Project into Hierarchy as a child of Attach Point
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can adjust the paddle''s relative position and rotation so its grip
    feels natural within your hand. The follow values seem to work for me:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In OpenVR, use the attach point Rotation (`20`, `90`, `90`)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Daydream, use Position (`0`,  `0`,  `0`, `05)` and Rotation (`0`, `90`, `90`)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Daydream, the `GvrControllerPointer` includes a `GvrArmModel` component
    that can be configured for simulating arm, elbow, and wrist movement with the
    simple 3DOF controller. Setting this up yourself can be confusing. Fortunately,
    a bunch of examples are provided in the ArmModelDemo scene the Daydream Elements
    package (in the `DaydreamElements/Elements/ArmModels/D*emo/*` folder) including
    prefabs with some preconfigured arm models. Let''s add one. If you are on Daydream:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Find the `Elements/ArmModels/Prefabs` folder in Project Assets
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `SwingArm` prefab into `MeMyselfEye / Player` as a sibling of `GvrControllerPointer`
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move `GvrControllerPointer` as a child of SwingArm
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will give more arm extension for using the paddle. You can further adjust
    the settings as needed, including try moving the SwingArm transform Position further
    in front (`0`, `0`, `0.3`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you might want to extend the ball drop location a little further out
    in front of you so it's more readily within hand reach. In the earlier version
    of the project, we defined a Drop Point; modify its position as desired (for example,
    z = `0.6`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The paddle in play using HTC Vive is shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6906466-5459-4ca2-8771-c2f6d179bedf.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Deflector versus paddle
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As implemented, our paddle acts more like a deflector shield than a paddle.
    The ball will bounce off the paddle''s Pad in a direction based on the Pad''s
    surface normal orientation. But if you whack the ball, that doesn''t transfer
    any physics. We can change this by adding a RigidBody to the Pad, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Select the Pad of your Paddle
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | Physics | RigidBody
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck Use Gravity checkbox
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Is Kinematic checkbox
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Apply button at top of Inspector to save your changes in the prefab
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By making it kinematic, our Pad will apply physics to objects colliding with
    it, but will not react to collisions itself. This is good, otherwise, the paddle
    would shatter when hit by a ball.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: One important lesson in this project is the use of attach points for defining
    relative positions for specific behaviors. We used a Drop Point to mark the X,
    Z position where balls are dropped from. We used an Attach Point to mark the relative
    position and rotation of the paddle in your hand. We could have added a Grip Point
    to the paddle itself to specify its relative origin. And so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Shooter ball game
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next iteration of this project, we'll shoot balls at the player and
    you have to hit them at a target on a wall. There's not a lot of innovation in
    this version, but it shows how you can take an existing mechanic and turn it on
    its side (both literally and figuratively).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, lets make a wall and put the target on it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy root, create an Empty game object named `TargetWall` and
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it at (`0`, `0`, `5`)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a child Cube and name it `Wall`
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Wall Scale to (`10`, `5`, `0.1`) and Position (`0`, `2.5`, `0`)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material named `Wall Material`
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Rendering Mode to Transparent, and its Albedo color to (`85`, `60`,
    `20`, `75`) so it's a translucent glassy color
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the Target to a child of `TargetWall`
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the Target Transform Scale to (`1.5`, `0.1`, `1.5`), Rotation (`90`,
    `0`, `0`), and Position (`0`, `2.5`, `-0.25`) so it's smaller and just in front
    of the wall itself
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, instead of serving balls by dropping them out of the sky and relying
    on gravity, we''ll shoot balls at you from a source on the wall:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Create a Sphere game object as a child of `TargetWall`, named `Shooter`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.5`, `0.5`, `0.5`) and Position (`4`, `2.5`, `-0.25`)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable or remove its Sphere Collider component
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material named `Shooter Material`, with Albedo color (`45`, `22`,
    `12`, `255`)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll add a gun barrel to the shooter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Create another Sphere object as a child of Shooter, named `Barrel`
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale (`0.1`, `0.1`, `0.1`), Rotation (`90`, `0`, `0`), and Position
    (`0`, `0`, `-0.25`)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Duplicate the Shooter and set the second one''s Position to (`-4`, `2.5`, `-0.25`)
    so there''s one on either side of the Target. Here is a capture of the Scene view
    of the `TargetWall` with its sexy shooters:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e290e704-61dc-4e23-8b3d-5290aa045ee6.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'The game controller script is similar to the BallGame one we have, but sufficiently
    different we should create a new one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `GameController` and disable or remove the `BallGame` component
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C# script named `ShooterBallGame` and open it for editing
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the `ShooterBallGame` script as follows. We give it two shooters and
    the script alternates between them to shoot balls in the direction of a `shootAt`
    location. We play a sound effect each time a ball is shot. First, let''s define
    the public and private variable we will need:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Start` function initializes the variable we get at runtime:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the `Update` function shoots the balls at specified intervals, alternating
    between the two shooter locations:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, here''s the `ShootBall()` code we extracted into its own function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ShootBall` grabs a new ball from the object pool and initializes its position
    based on the shooter position. It then rotates the shooter to be pointing at the
    `shootAt` position (using `transform.LookAt`) and uses its forward vector to define
    the ball''s RigidBody velocity vector.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in Unity, we need to populate the public variable slots:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `Shooter` object (child of `TargetWall`) on to the Shooter 0 slot
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the other `Shooter` object on to the Shooter 1 slot
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the Shoot At slot empty for now, so it will default to the player's live
    head position.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Press Play. *Not bad*. The balls are too big and heavy. Let''s create new ball
    prefabs with different properties:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `BouncyBall` prefab from `Project` folder into the Hierarchy
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `ShooterBall`
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.25`, `0.25`, `0.25`)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Use Gravity checkbox (alternatively, you could play with its RigidBody
    Mass property)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the ShooterBall from Hierarchy into your `Prefabs` folder, creating a new
    prefab for it
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the ShooterBall from the Hierarchy
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `GameController` in Hierarchy, and drag the ShooterBall onto its Object
    Pooler Prefab slot
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the object pool will instantiate a collection of the new prefab objects.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Press Play. *Oh yeah!* The game is now much more challenging. Also, try modifying
    the Interval and Speed settings.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: It may be awkward that the ball is always shooting towards your head, especially
    on Daydream where you have limited hand control. You can adjust the scene, for
    example, positioning the ShootAt empty game object, as child of `MeMyselfEye`,
    at Position (`0`, `0.9`, `0.6`), and setting it into the `GameController`'s ShootAt
    slot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Some obvious gameplay improvement ideas should come to mind. You could make
    a moving target, perhaps in a predictable oscillating motion, or completely random.
    You could introduce some random variation in the ball velocity direction and speed
    or the intervals between shots. You could keep score, using `OnTriggerEnter` on
    the Target. You could disqualify bank shots that bounce first on the floor (using
    `OnTriggerEnter` on the ground plane).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Juicing the scene
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the basic mechanics implemented, we can now *juice it*! One of my favorite
    VR games is the popular Audio Shield ([http://audio-shield.com/](http://audio-shield.com/)).
    We're almost there building our own, we just need to add fireballs, a compelling
    environment scene, and synchronizing the fireball shots with music!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了基本机制后，我们现在可以给它添加活力！我最喜欢的VR游戏之一是流行的音频盾牌([http://audio-shield.com/](http://audio-shield.com/))。我们几乎完成了自己的构建，我们只需要添加火焰球、引人入胜的环境场景，以及将火焰球射击与音乐同步！
- en: The term *juice it* for game design was popularized by Jonasson and Purho in
    their presentation talk from 2012,  *Juice it or lose it - a talk by Martin Jonasson
    & Petri Purho* ([https://www.youtube.com/watch?v=Fy0aCDmgnxg](https://www.youtube.com/watch?v=Fy0aCDmgnxg)). <q
    class="calibre65">A juicy game feels alive and responds to everything you do,
    tons of cascading action and response for minimal user input.</q>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计中的术语*juice it*由Jonasson和Purho在2012年的演讲中普及，演讲主题为*Juice it or lose it - Martin
    Jonasson & Petri Purho的演讲*([https://www.youtube.com/watch?v=Fy0aCDmgnxg](https://www.youtube.com/watch?v=Fy0aCDmgnxg))。 <q
    class="calibre65">一个充满活力的游戏感觉充满生机，对你的每一个动作都做出反应，有大量的连锁动作和反应，而用户输入却很少。</q>
- en: Great balls of fire
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火球
- en: In the previous section, we disabled Use Gravity on the shooting balls. We did
    this in anticipation of changing the balls from being bouncy balls to balls of
    fire. Let's make that magic happen now. We will use the Particle System to render
    it instead of mesh geometry.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们禁用了射击球上的重力使用。我们这样做是为了预期将球从弹跳球变为火焰球。现在让我们实现这个魔法。我们将使用粒子系统来渲染它，而不是网格几何体。
- en: There are a lot of ways to get particle effects into your Unity project. If
    you recall, in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we added a water hose, spark emitter, and explosion effects from the
    `Unity Standard Assets` package. Here, we'll build our own, but use one of the
    materials, `ParticleFireCloud`, provided with the package. In the Unity Asset
    Store, you can find many offerings of particle effects and system enhancements
    too.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将粒子效果添加到Unity项目中有许多方法。如果你还记得，在[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)“基于注视的控制”中，我们从`Unity标准资产`包中添加了水龙带、火花发射器和爆炸效果。在这里，我们将构建自己的，但使用包中提供的材料之一，`ParticleFireCloud`。在Unity资产商店中，你还可以找到许多粒子效果和系统增强的提供。
- en: 'First, make a new prefab derived from ShooterBall, named `FireBall`, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的从ShooterBall派生的预制件，命名为`FireBall`，如下所示：
- en: Drag a copy of `ShooterBall` prefab from the `Project` folder into Hierarchy
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“项目”文件夹中将`ShooterBall`预制件的副本拖动到层次结构中
- en: Rename it FireBall
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为FireBall
- en: Drag FireBall into the `Project` *Prefabs* folder to create a new prefab
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将FireBall拖动到“项目”*预制件*文件夹中创建一个新的预制件
- en: Select the `GameController` from Hierarchy
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择`GameController`
- en: Drag the `FireBall` prefab from `Project` *Prefabs* folder onto the Object Pooler
    Prefab slot
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“项目”*预制件*文件夹中将`FireBall`预制件拖动到对象池器预制件槽中
- en: 'OK, now we can add the particle system:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以添加粒子系统：
- en: Select the FireBall from Hierarchy
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择FireBall
- en: Disable its Mesh Renderer, as we will render it with particles instead
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用其网格渲染器，因为我们将以粒子形式渲染它
- en: Right-click FireBall and select Create | Effects | Particle System
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击FireBall并选择创建 | 效果 | 粒子系统
- en: Rename it Fireball Particle System
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为Fireball Particle System
- en: There are a lot of details in working with particles, many options and configuration
    parameters. As we step through this quick implementation of fireballs, observe
    the effects of each change as we make them one at a time. Note that you can preview
    the particle effects in the Scene window. Feel free to experiment on your own.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理粒子时有很多细节，很多选项和配置参数。随着我们逐步实现火焰球的快速实现，注意我们逐个更改时每个更改的效果。请注意，你可以在场景窗口中预览粒子效果。请随意进行实验。
- en: First, at the bottom of the Particle System Inspector, find the Renderer panel.
    In its Material slot, click the doughnut icon and choose the ParticleFireCloud material
    (located in `Standard Assets/Particle Systems/Materials`. If not present, you
    may need to import it using Assets | Import Package | ParticleSystems).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在粒子系统检查器的底部，找到渲染器面板。在其材质槽中，点击甜甜圈图标并选择ParticleFireCloud材质（位于`Standard Assets/Particle
    Systems/Materials`。如果不存在，你可能需要使用“资产 | 导入包 | 粒子系统”导入它）。
- en: 'Near the top of the Particle System inspector, find the Shape panel. Select
    Shape: Sphere, and set its Radius to `0.1`.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粒子系统检查器的顶部附近，找到形状面板。选择形状：球体，并将其半径设置为`0.1`。
- en: Find the Emission panel, and set Rate of Time to `15`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发射面板中，将时间速率设置为`15`。
- en: 'At the top of the inspector, set Duration: `2.00`.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Lifetime: `1`.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Speed: `0`.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Size: `0.5`.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Start Rotation, click the selector icon on the right and choose Random
    Between Two Curves. Then click the slot and scroll to the Curve Editor at the
    bottom of the Inspector. If you''re not familiar, the editor can take some getting
    used to. Choose a full range of values from `180` (at top of graph) to `-180`
    (bottom of graph), as shown:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fe543e26-4c2e-4f6f-9d52-b08c61e2317c.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'Enable Color Over Lifetime and click the slot to open its Gradient Editor.
    We want to adjust the Alpha curve so it starts at Alpha `0` at Location `0%`,
    then becomes Alpha `255` at `10%`, then fades out over time back to Alpha `0`
    at `100%`. The editor is shown here:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c43d9d6a-184a-4caf-8fed-69ba777f9a68.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Set the Start Color, as Gradient (right-side selector) and then pick a range
    of colors such as yellow to red, as shown here:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c67f1214-4127-43fd-9b2f-6c17a6d9b4f4.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Next, set the Velocity Over Lifetime, using Random Between Two Curves. For each
    X, Y, Z, use the Curve Editor to set max and min values of `0.05` and `-0.05`
    respectively. (You can modify the vertical axis of the graph by clicking the axis
    label and typing a number; you can copy curves, for example, by right-clicking
    the Z slot, choosing Copy, then right-clicking the Y slot and choosing Paste.)
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we should adjust the fireball so it''s about the same size as
    our original BouncyBall. To check:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Re-enable the FireBall's Mesh Renderer. Adjust the particle system by changing
    the Renderer's Max Particle Size to `0.1`, or using the Transform Scale
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work by selecting Apply at the top of Inspector, to update your prefab
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you press Play, the Shooters will fire FireBalls. *Oh wow!*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to add some sparkle effect to the fireball, we can do that with
    the Trail panel:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Enable the Trail panel
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A warning may pop up tell you to add a trails material to the Renderer
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Renderer panel, select the doughnut icon on the Trail Material slot,
    and choose ParticleFireCloud as we use for the main fireball
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Speaking of trails, if you''d like to also implement trail effects on the fireball,
    there are several ways to do this too.  A quick solution is to duplicate our fireball
    particle system and modify it to use a Cone shape instead of Sphere, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Select the Fireball Particle System in Hierarchy.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click to Duplicate, move the duplicate as a child of Fireball Particle
    System and name it Trail Particle System.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its Shape to Cone.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its Velocity Over Lifetime. The Z curve needs a higher value range, such
    as `0.75` to `0.25`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The X and Y velocity curves should be smaller for some variation, such as `0.2`
    to `-0.2`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Size Over Lifetime range to `1.0` to `0.5`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Transform, set Position to (`0`, `0`, `0.5`) to give it an extra tail.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a screenshot of the gameplay window paddling an incoming fireball!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52a7b5d-8b8d-4cc0-88ca-fe7b40ea2df9.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: 'Special thanks to Tyler Wissler for his instructional video *How To: Basic
    Fireballs in Unity* (June 2014), which was very helpful is developing this topic
    ([https://www.youtube.com/watch?v=OWShSR6Tr50](https://www.youtube.com/watch?v=OWShSR6Tr50)).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Skull environment
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To spice up our game, even more, we should find an exciting environment and
    scene. Searching the Asset Store, I found the *Skull Platform* free asset ([https://assetstore.unity.com/packages/3d/props/skull-platform-105664](https://assetstore.unity.com/packages/3d/props/skull-platform-105664)).
    You can use it too, or find something different.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you''ve found and installed the Skull Platform asset, we''ll add it
    to our scene. First, let''s render our target as a skull:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Drag Platform_Skull_o1 as a child of Target (under `TargetWall`).
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Transform Rotation (`0`, `0`, `180`) and Scale (`0.3`, `0.3`, `0.3`).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Target and disable its Mesh Renderer.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, create a new Spotlight (Create | Light | Spotlight) to shine on the skull.
    As a child of Target, I used the following settings: Position (`-1`, `-30`, `-0.6`),
    Rotation (`-60`, `60`, `0`), Range: `10`, Spot Angle: `30`, Color: `#FFE5D4FF`,
    Intensity: `3`.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s add the big platform as a backdrop behind the wall. The quickest
    way is to merge in the Demoscene they provide:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object in the Hierarchy root, name it SkullPlatform, reset
    its transform.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of the Skull Platform's demo scene named Platform (`Assets/Skull
    Platform/Demo/` folder) into the Hierarchy.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Demo's Scene, Lighting, and Particles objects and drag them as children
    of SkullPlatform.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the assets we want, right-click the Platform scene in Hierarchy
    and choose Remove Scene. When prompted, choose Don't Save.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the SkullPlatform Position to (`0`, `-1.5`, `0`) so it's just below the
    ground plane.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the GroundPlane and disable its Mesh Renderer.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll set up the scene environment lighting:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Delete the Directional Light from the scene Hierarchy.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Lighting window. If its not already a tab in your editor, use Window
    | Lighting | Settings and dock it next to the Inspector.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Skybox Material to Sky (provided in the Skull Platform package).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Environmental Lighting section, set Source: Color to `#141415`.'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the Fog checkbox (in Other Settings), Color to `#8194A1FF`, Mode: Exponential,
    and Density to 0.`03`.'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a screen capture of the scene with the skull platform environment and
    lighting. *Sweet!*
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf4de82-7717-4dd4-995f-811d6347dab9.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Audio synchronization
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're almost there building our own version of Audio Shield, we just need to
    add synchronizing the fireball shots with music!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides an API for sampling audio source data, including `AudioSource.GetSpectrumData`
    and `GetOutputData`. Extracting actual beats in the music from this data is not
    trivial and requires a lot of math and some understanding of how music encoding
    works.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个API用于采样音频源数据，包括`AudioSource.GetSpectrumData`和`GetOutputData`。从这些数据中提取音乐的实际节拍并不简单，需要大量的数学知识和对音乐编码工作方式的一些理解。
- en: Fortunately, we found an open source script that does this for us, called Unity-Beat-Detection
    ([https://github.com/allanpichardo/Unity-Beat-Detection](https://github.com/allanpichardo/Unity-Beat-Detection)).
    It conveniently provides Unity Events for `onBeat`, which we'll use. (It also
    provides  `onSpectrum` events, with music frequency bands per frame, which you
    could use too, for example, to change the color of the fireball or other things
    based on frequency bands.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们找到了一个开源脚本，名为Unity-Beat-Detection ([https://github.com/allanpichardo/Unity-Beat-Detection](https://github.com/allanpichardo/Unity-Beat-Detection))，它可以为我们完成这项工作。它方便地提供了`onBeat`的Unity事件，我们将使用它。（它还提供了`onSpectrum`事件，每帧提供音乐频率带，你也可以使用它，例如，根据频率带改变火球或其他东西的颜色。）
- en: Download the `AudioProcessor.cs` script from GitHub (we've provided a copy with
    the files for this book for your convenience)
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载`AudioProcessor.cs`脚本（我们已提供与本书文件一起的副本，以方便您使用）
- en: Drag the file into your `Scripts` folder (or use Assets | Import New Asset)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件拖入你的`Scripts`文件夹（或使用Assets | Import New Asset）
- en: For your music, find any MP3 or WAV file that has a nice beat, and import it
    into your project. We looked on SoundCloud NoCopyrightSounds track ([https://soundcloud.com/nocopyrightsounds/tracks](https://soundcloud.com/nocopyrightsounds/tracks))
    to find one named *Third Prototype - Dancefloor* ([http://ncs.io/DancefloorNS](http://ncs.io/DancefloorNS)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的音乐，找到任何有良好节拍的MP3或WAV文件，并将其导入到你的项目中。我们在SoundCloud NoCopyrightSounds轨道 ([https://soundcloud.com/nocopyrightsounds/tracks](https://soundcloud.com/nocopyrightsounds/tracks))
    中找到了一个名为*Third Prototype - Dancefloor* ([http://ncs.io/DancefloorNS](http://ncs.io/DancefloorNS))。
- en: In Project window, create a folder named Audio
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，创建一个名为Audio的文件夹
- en: Drag your music file into the Audio folder (or use Assets | Import New Asset)
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的音乐文件拖到音频文件夹中（或使用Assets | Import New Asset）
- en: 'To implement this feature, we''ll make a MusicController and then modify the
    `ShooterBallGame` script to use its beats to fireballs. In Unity, do the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们将创建一个MusicController，然后修改`ShooterBallGame`脚本以使用其节拍发射火球。在Unity中，执行以下操作：
- en: In Hierarchy, create an Empty game object and name it MusicController
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，创建一个空的游戏对象并命名为MusicController
- en: Add the AudioProcessor script as a component
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将AudioProcessor脚本作为组件添加
- en: Note that it automatically adds an Audio Source component too
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意它还会自动添加一个Audio Source组件
- en: Drag your imported music file onto AudioClip slot
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你导入的音乐文件拖到AudioClip槽中
- en: Drag MusicController itself onto Audio Source slot
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MusicController本身拖到Audio Source槽中
- en: Note the G Threshold parameter on Audio Process. You can use this to adjust
    the sensitivity of the beat recognition algorithm.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意音频处理中的G Threshold参数。你可以使用它来调整节拍识别算法的灵敏度。
- en: 'Now, update the `ShooterBallGame` script on `GameController` as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式更新`GameController`上的`ShooterBallGame`脚本：
- en: '[PRE17]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's very similar to the previous version, but instead of calling `ShootBall`
    from `Update`, based on the time interval, we call it from `onBeatDetected`. In
    `Start`, we add `onBeatDetected` as an `onBeat` event listener.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 它与上一个版本非常相似，但不是从`Update`中调用`ShootBall`，而是根据时间间隔从`onBeatDetected`中调用它。在`Start`中，我们将`onBeatDetected`添加为`onBeat`事件监听器。
- en: Also, we've decided to randomly decide which shooter to use rather than just
    alternating back and forth.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们决定随机选择使用哪种射击方式，而不是简单地来回交替。
- en: 'Press Play and go at it! *Whoohoo,* we have our own version of Audio Shield!
    A screenshot of active gameplay is shown here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放并开始游戏！*哇哦，*我们有了自己的音频盾牌版本！以下是活跃游戏截图：
- en: '![](img/9c0c2270-17b5-46db-bebf-6ec52f55ca40.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c0c2270-17b5-46db-bebf-6ec52f55ca40.png)'
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a game that uses Unity's Physics Engine and a number
    of other features. First, we explained in layman's terms the relationship between
    Rigidbody, Colliders, and Physic Materials, and explored how the physics engine
    uses these to determine the velocity and collision of objects in the scene.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个使用Unity物理引擎和其他一些功能的游戏。首先，我们用通俗易懂的语言解释了Rigidbody、Collider和Physic
    Materials之间的关系，并探讨了物理引擎如何使用这些来决定场景中物体的速度和碰撞。
- en: Then, we considered the life cycle of game objects and implemented an object
    pooler that helps avoid memory fragmentation and garbage collection, which can
    lead to performance problems and VR discomfort.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考虑了游戏对象的整个生命周期，并实现了一个对象池器，它有助于避免内存碎片化和垃圾回收，这些问题可能导致性能问题和VR体验不适。
- en: Using what we learned, we implemented several variations of a ball game, first
    aiming for a target with your head, then using hand paddles. We modified the game
    so that, instead of serving balls from above-using gravity, we shoot them from
    in front and apply a velocity vector. Lastly, we juiced up our game, changing
    the bouncy balls into fireballs, adding a cool level environment, and synchronizing
    the fireballs to music beats. In the end, we have a good start to making our own
    version of the Audio Shield VR game.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们所学的知识，我们实现了几个球类游戏的变体，首先是用头部瞄准目标，然后使用手柄。我们修改了游戏，使其不是从上方使用重力来发球，而是从前面发射并应用一个速度向量。最后，我们增强了我们的游戏，将弹跳球变成了火球，添加了一个酷炫的关卡环境，并将火球与音乐节拍同步。最终，我们为制作我们自己的音频盾VR游戏版本迈出了良好的开端。
- en: In the next chapter, we will see another more practical example of a virtual
    interactive space. We are going to build an interactive art gallery space that
    you can move through and query the artwork for information and details.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到另一个更实用的虚拟交互空间示例。我们将构建一个互动艺术画廊空间，你可以在其中移动并查询艺术品的详细信息。
