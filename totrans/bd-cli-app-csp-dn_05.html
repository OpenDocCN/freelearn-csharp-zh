<html><head></head><body>
		<div><h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor068"/>5</h1>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Input/Output and File Handling</h1>
			<p>In the previous chapter, we laid out the<a id="_idIndexMarker123"/> foundations of <code>System.CommandLine</code> library to infuse CLI capabilities into the application.</p>
			<p>For now, our CLI application only contains one command (<code>link</code>), which allows for managing bookmarks by adding new ones or listing, updating, or removing existing ones.</p>
			<p>With this chapter, we are working toward two goals:</p>
			<ol>
				<li>To go a bit deeper with options to further control input values for our CLI applicationâ€™s command options.</li>
				<li>To see how to handle input and output files in a CLI application. This might be handy for import and export operations, making it easier to back up and restore our applicationâ€™s data and share it with other applications.</li>
			</ol>
			<p>Specifically, weâ€™ll cover the following main topics:</p>
			<ul>
				<li>Controlling input values for an option, determining when to use required versus non-required options, setting default values for options, controlling the set of allowed values for an option, and validating input values</li>
				<li>Working with files passed as parameters to the CLI application, both as input and output files, which will be useful for adding import and export capabilities to our CLI application</li>
			</ul>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Controlling input values for an option</h1>
			<p>Parameters are at the<a id="_idIndexMarker124"/> heart of any application. They allow users to indicate what command they want to execute and provide values to the input parameters. This is why, in this section and its subsections, we will cover the subtleties of dealing with these parameters.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>Required versus non-required options</h2>
			<p>In its current<a id="_idIndexMarker125"/> state, adding a new bookmark requires both the name and the URL to be provided, which is, obviously, what we want.</p>
			<p>This means that if we call the <code>link add</code> command without passing one of these options or their values, we should get an error such as the following:</p>
			<div><div><img src="img/B22400_05_01.jpg" alt="Figure 5.1 â€“ The name and URL for a bookmark should be required"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 â€“ The name and URL for a bookmark should be required</p>
			<p>However, if we run the<a id="_idIndexMarker126"/> program without passing these two options, we currently get the following result:</p>
			<p class="IMG---Figure"><a id="_idTextAnchor073"/></p>
			<div><div><img src="img/B22400_05_02.jpg" alt="Figure 5.2 â€“ The name and URL for the added bookmark are currently optional"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 â€“ The name and URL for the added bookmark are currently optional</p>
			<p>Notice how a new <a id="_idIndexMarker127"/>bookmark with no name and no URL is added to the collection of bookmarks. This is clearly not what we want!</p>
			<p>Fortunately, the <code>Option</code> class provides a Boolean value to specify whether it should be required or optional.</p>
			<p>To make the name and URL options required, letâ€™s set their respective <code>IsRequired</code> property to <code>true</code>:</p>
			<pre class="source-code">
nameOption.IsRequired = true;
urlOption.IsRequired = true;</pre>			<p>If we now run the<a id="_idIndexMarker128"/> program without passing in an option or its value, we get an error message:</p>
			<div><div><img src="img/B22400_05_03.jpg" alt="Figure 5.3 â€“ The name and URL for the added bookmark are now required"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 â€“ The name and URL for the added bookmark are now required</p>
			<p>Also note that the help menu clearly states that these two options are required.</p>
			<p>So far, we have two required options. Letâ€™s add an optional one.</p>
			<p>When an option is not required (i.e., optional), the application should not return an error if we donâ€™t pass that option or its value.</p>
			<p>Letâ€™s take an illustrative example.</p>
			<p>Letâ€™s say we want to classify our bookmarks by category. By doing so, we can imagine that we may want to list only the bookmarks that belong to a specific category.</p>
			<p>For that matter, we<a id="_idIndexMarker129"/> will first add a <code>Category</code> property to the <code>Bookmark</code> class, as follows:</p>
			<pre class="source-code">
public class Bookmark
{
Â Â Â Â public required string Name { get; set; }
Â Â Â Â public required string Url { get; set; }
Â Â Â Â public required string Category { get; set; }
}</pre>			<p>Then, we will add an option for the category and pass it to the <code>add</code> command:</p>
			<pre class="source-code">
var categoryOption = new Option&lt;string&gt;(
Â Â Â Â Â ["--category", "-c"],
Â Â Â Â Â "The category to which the bookmark is associated"
);
var addLinkCommand = new Command("add", "Add a new bookmark link")
{
Â Â Â Â Â nameOption,
Â Â Â Â Â urlOption,
Â Â Â Â Â categoryOption
};</pre>			<p>Next, we update the handler method and its association with the command:</p>
			<pre class="source-code">
addLinkCommand.SetHandler(OnHandleAddLinkCommand, nameOption, urlOption, categoryOption);
static void OnHandleAddLinkCommand(string name, string url, string category)
{
Â Â Â Â Â service.AddLink(name, url, category);
}</pre>			<p>Finally, do not forget to update <code>BookmarkService</code> so it handles the <code>Category</code> property accordingly.</p>
			<p>Now, if we execute <a id="_idIndexMarker130"/>the application without passing the category, no error is returned:</p>
			<div><div><img src="img/B22400_05_04.jpg" alt="Figure 5.4 â€“ The Category option is optional"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 â€“ The Category option is optional</p>
			<p>And, of course, if we pass a category, it works too. ðŸ˜Š</p>
			<div><div><img src="img/B22400_05_05.jpg" alt="Figure 5.5 â€“ Assigning a category to the newly added bookmark"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 â€“ Assigning a category to the newly added bookmark</p>
			<p>However, since<a id="_idIndexMarker131"/> the category is now optional, if we donâ€™t pass it, what would its value be?</p>
			<p class="callout-heading">Double or single dash?</p>
			<p class="callout">You might be wondering when we should use double versus single dashes. Do we even have to use both?</p>
			<p class="callout">The answer is no! You only use both if you want to provide both a long and a short form for passing in an option, but you can definitely opt for only one of these options.</p>
			<p class="callout">For example, while <code>--set-max-concurrent-requests</code> might be more self-explanatory to someone new to your CLI, if they often use your CLI application, having to type this long form again and again may become frustrating. Thatâ€™s why a short form, such as <code>-m</code>, will be more appropriate.</p>
			<p class="callout">In the real world, you will notice that users who are just starting to use your CLI application will rely on long-form options and gradually transition to short forms as they become more experienced with your CLI application.</p>
			<p class="callout">So, for example, a junior user of Bookmarkr will prefer this syntax:</p>
			<p class="callout"><code>bookmarkr link add --name "Packt Publishing" --</code><code>url "https://packtpub.com"</code></p>
			<p class="callout">An experienced<a id="_idIndexMarker132"/> user, on the other hand, is likely to prefer this syntax:</p>
			<p class="callout"><code>bookmarkr link add -n "Packt Publishing" -</code><code>u "https://packtpub.com"</code></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor074"/>What about arguments?</h2>
			<p>Ah! I can see that youâ€™ve learned<a id="_idIndexMarker133"/> about arguments. Arguments are instances of the <code>Argument</code> class, and they represent required parameters that are essential to the execution of a command.</p>
			<p>But waitâ€¦ why not use arguments instead of options for required parameters?</p>
			<p>You could, of course! But I donâ€™t like these because they are <em class="italic">positional</em> parameters and not <em class="italic">named</em> parameters. This means that only their position instructs the user about their purpose, which, to me, sacrifices the readability of the CLI request.</p>
			<p>To illustrate my point, here is what the call to the <code>link add</code> command would look like if it relied on arguments rather than parameters:</p>
			<pre class="console">
$ bookmarkr link add 'Packt Publishing' 'https://packtpub.com' 'Great tech books'</pre>			<p>See how this is way less readable than our previous request (which relies on options)?</p>
			<p>Thatâ€™s why I donâ€™t like arguments and prefer to use options, specifying which ones are required and <a id="_idIndexMarker134"/>which ones are optional.</p>
			<p>So, letâ€™s get back to exploring options.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor075"/>Setting a default value for an option</h2>
			<p>Well, as you <a id="_idIndexMarker135"/>may have guessed, the default value for an option will be (by default) the default value for its data type (are you still with me?).</p>
			<p>Since the <code>Category</code> option is of type <code>string</code>, its default value is <code>null</code>. However, the <code>Option</code> class allows us to define a default value.</p>
			<p>Letâ€™s set the default value for the <code>Category</code> option to <code>"Read later"</code>. This can be done by calling the <code>SetDefaultValue</code> method and passing in the default value:</p>
			<pre class="source-code">
categoryOption.SetDefaultValue("Read later");</pre>			<p>If we run the program without providing a value for the <code>Category</code> option, we can see that its default value is used:</p>
			<div><div><img src="img/B22400_05_06.jpg" alt="Figure 5.6 â€“ Using the default value for the category option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 â€“ Using the default value for the category option</p>
			<p>However, if we do<a id="_idIndexMarker136"/> provide a value for the category, we can see that this value is actually used:</p>
			<div><div><img src="img/B22400_05_07.jpg" alt="Figure 5.7 â€“ Using the provided value for the category option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 â€“ Using the provided value for the category option</p>
			<h3>Should we provide default values for required options?</h3>
			<p>No, we should not! This <a id="_idIndexMarker137"/>is because if we do that, a required option will no longer behave as a required one but rather as an optional one.</p>
			<p>Why? Because if we do not provide a value for it, the default value will be used.</p>
			<p>This is why default values should only be used with optional options.</p>
			<p>Note that in the previous example, the user can specify any string value for the <code>Category</code> option. But what if we wanted to control the set of allowed values? This is where the <code>FromAmong</code> method comes in.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor076"/>Controlling the allowed values for an option</h2>
			<p>Letâ€™s pretend for a<a id="_idIndexMarker138"/> moment that we only allow a set of categories in our application. Yes, in real life, we would allow users to create as many categories as they want, but this will serve our purpose of explaining how to only allow a specific set of values for an option.</p>
			<p>Letâ€™s say we allow the following categories:</p>
			<ul>
				<li>Read later (which serves as the default one)</li>
				<li>Tech books</li>
				<li>Cooking</li>
				<li>Social media</li>
			</ul>
			<p>We will do this by passing these values to the <code>FromAmong</code> method as follows:</p>
			<pre class="source-code">
categoryOption.FromAmong("Read later", "Tech books", "Cooking", "Social media");</pre>			<p>If we run the application by passing in an allowed category, everything works fine:</p>
			<div><div><img src="img/B22400_05_08.jpg" alt="Figure 5.8 â€“ Passing in an allowed value for the category"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 â€“ Passing in an allowed value for the category</p>
			<p>However, if we do <a id="_idIndexMarker139"/>pass an unallocated category value, we will get an error message:</p>
			<div><div><img src="img/B22400_05_09.jpg" alt="Figure 5.9 â€“ Passing in an unallowed value for the category"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 â€“ Passing in an unallowed value for the category</p>
			<p>Notice that the <a id="_idIndexMarker140"/>error message indicates the allowed values. We can also see the allowed values from the help menu:</p>
			<div><div><img src="img/B22400_05_10.jpg" alt="Figure 5.10 â€“ Seeing the allowed values in the help menu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 â€“ Seeing the allowed values in the help menu</p>
			<p>Using <code>FromAmong</code> can be particularly useful for ensuring data integrity and guiding user input, especially in scenarios where options need to conform to a predefined set of valid values.</p>
			<p>Okay, so letâ€™s recap. Our CLI application has required and optional parameters. It specifies a default value for its optional parameter, along with allowed values. However, we are missing something, something important. Can you guess what it is?</p>
			<p>Yes, exactly, the ability <a id="_idIndexMarker141"/>to ensure that the provided value for a specific parameter is valid.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor077"/>Validating input values</h2>
			<p>When adding a <a id="_idIndexMarker142"/>new bookmark, we need to pass a URL for it. But, until now, we havenâ€™t checked whether the provided value is indeed a valid URL. Letâ€™s fix this.</p>
			<p>The <code>Option</code> class allows us to configure a validator function. We will then add a validator method for <code>urlOption</code> to ensure it only gets valid URLs.</p>
			<p>This can be achieved by calling the <code>AddValidator</code> method, as follows:</p>
			<pre class="source-code">
urlOption.AddValidator(result =&gt;
{
Â Â Â Â if (result.Tokens.Count == 0)
Â Â Â Â {
Â Â Â Â Â Â Â Â result.ErrorMessage = "The URL is required";
Â Â Â Â }
Â Â Â Â else if (!Uri.TryCreate(result.Tokens[0].Value, UriKind.Absolute, 
Â Â Â Â out _))
Â Â Â Â {
Â Â Â Â Â Â Â Â result.ErrorMessage = "The URL is invalid";
Â Â Â Â }
});</pre>			<p>In the preceding code snippet, the <code>AddValidator</code> method uses an inline delegate to ensure that the value provided to <code>urlOption</code> is valid. In this case, it ensures that it is actually present (thatâ€™s what the <code>if</code> section is checking) and that it is a valid URL (thatâ€™s what the <code>else if</code> section is checking).</p>
			<p>So now, if we execute the <a id="_idIndexMarker143"/>program with both an invalid and a valid URL, we can see that it behaves as expected:</p>
			<div><div><img src="img/B22400_05_11.jpg" alt="Figure 5.11 â€“ Validating the input value for the URL option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 â€“ Validating the input value for the URL option</p>
			<p class="callout-heading">More advanced validation</p>
			<p class="callout">Validation could be more advanced than that. Our application is intended to collect bookmarks from everywhere on the web. However, if you would like to restrict its usage to, letâ€™s say, your organization only, you may want to check (in your validation process) that the bookmarked URLs are only referring to your corporate domain and dismiss everything else.</p>
			<p>Perfect! So now, Bookmarkr allows us to manage bookmarks, ensuring that only valid information can be passed to (and stored in) the CLI application.</p>
			<p>However, up to this point, we can still only add one bookmark at a time. Wouldnâ€™t it be nice if we could provide a set of names and URLs as part of the same request and have Bookmarkr add them in one go?</p>
			<p><code>System.CommandLine</code> has <a id="_idIndexMarker144"/>a feature that allows us to do just that ðŸ˜‰.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor078"/>Adding multiple elements in one go</h2>
			<p>Letâ€™s try passing in<a id="_idIndexMarker145"/> multiple names and URLs to the same request, such as this:</p>
			<pre class="source-code">
dotnet run link add --name 'Packt Publishing' --url 'https://packtpub.com/' --name 'Audi cars' --url 'https://audi.ca'</pre>			<p>But if we do this, we will get the following error:</p>
			<div><div><img src="img/B22400_05_12.jpg" alt="Figure 5.12 â€“ Name and URL options expect only one value by default"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 â€“ Name and URL options expect only one value by default</p>
			<p>This is due to the arity of these options.</p>
			<p><strong class="bold">What is an </strong><strong class="bold">arity, anyway?</strong></p>
			<p>The arity<a id="_idIndexMarker146"/> of an option represents the number of values that can be passed if that option is specified. It is expressed with a minimum value and a maximum value.</p>
			<p>This is of great importance if your CLI application supports bulk operations through one or many of its commands. In our example, we want to perform a bulk operation for adding multiple bookmarks at the same time.</p>
			<p>In the case of an option of type <code>string</code>, the minimum and maximum values are both set to <code>1</code>, which means that if we specify the option, we must provide a value.</p>
			<p>A Boolean option will have a minimum value of <code>0</code> and a maximum value of <code>1</code> since we donâ€™t need to pass in a value as both these syntaxes are valid:</p>
			<pre class="source-code">
--force
-- force true</pre>			<p>In the same way, a list <a id="_idIndexMarker147"/>of elements has a minimum arity of 1 and a maximum of (by default) 100,000.</p>
			<p>In order to specify the arity of an option, <code>System.CommandLine</code> provides an enumeration named <code>ArgumentArity</code>, which has these values:</p>
			<ul>
				<li><code>Zero</code>, meaning no values are allowed. So, <code>--force</code> would be valid but not <code>--</code><code>force true</code>.</li>
				<li><code>ZeroOrOne</code>, meaning a minimum of zero and a maximum of one value is allowed.</li>
				<li><code>ZeroOrMore</code>, meaning either zero, one, or many values are allowed.</li>
				<li><code>ExactlyOne</code>, meaning a minimum of one and a maximum of one value is allowed. This is the case for our string options, name, and URL.</li>
				<li><code>OneOrMore</code>, meaning either one or multiple values are allowed.</li>
			</ul>
			<p>To set the arity of an option, we can then use one of the values provided by the <code>ArgumentArity</code> enumeration, like this:</p>
			<pre class="source-code">
nameOption.Arity = ArgumentArity.OneOrMore;</pre>			<p>So now, we should be able to provide multiple values for a given option. Letâ€™s try this:</p>
			<div><div><img src="img/B22400_05_13.jpg" alt="Figure 5.13 â€“ Failing to provide multiple values for a given option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 â€“ Failing to provide multiple values for a given option</p>
			<p>Oops, this is not what we expected, right?</p>
			<p>The problem <a id="_idIndexMarker148"/>here is that even though <code>nameOption</code> can accept more than one value, it is not clear to the program how to convert those values into a single string. This is why the error message is referring to a custom binder (so it is told how to perform such a conversion).</p>
			<p>In order to fix this problem, we need to tell the program to treat each of these inputs as a separate argument. This is done by setting the <code>AllowMultipleArgumentsPerToken</code> property to <code>true</code>, as follows:</p>
			<pre class="source-code">
nameOption.AllowMultipleArgumentsPerToken = true;</pre>			<p>Also, letâ€™s get rid of the arity for a moment by commenting out the corresponding line of code.</p>
			<p>Now, if we run the program, we can see that the error is gone but we are still not getting the expected resultâ€¦</p>
			<div><div><img src="img/B22400_05_14.jpg" alt="Figure 5.14 â€“ nameOption is now accepting multiple values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 â€“ nameOption is now accepting multiple values</p>
			<p>Notice how only the last pair of names and URLs were considered and added to the list of bookmarks.</p>
			<p>What happened, in fact, is that <code>System.CommandLine</code> noticed that we have two occurrences of the name and URL, so the last ones have overridden the first ones and only those last ones were actually passed to the <code>Handler</code> method. This is why we only get one bookmark added with the information of the last pair of names and URL values.</p>
			<p>But what if we <a id="_idIndexMarker149"/>want to be able to pass a list of names and URLs and have the <code>Handler</code> method add as many bookmarks as the number of name and URL pairs?</p>
			<p>To do this, we need two things. First, letâ€™s uncomment the lines of code that set the arities for <code>nameOption</code>, <code>urlOption</code>, and <code>categoryOption</code>.</p>
			<p>Next, letâ€™s change the declaration of the name, URL, and category options along with the validator and the signature of the <code>Handler</code> method so that they accept a list of strings rather than a single string:</p>
			<pre class="source-code">
var nameOption = new Option&lt;string[]&gt;(
Â Â Â Â ["--name", "-n"], // equivalent to new string[] { "--name", "-n" }
Â Â Â Â Â "The name of the bookmark"
);
nameOption.IsRequired = true;
nameOption.Arity = ArgumentArity.OneOrMore;
nameOption.AllowMultipleArgumentsPerToken = true;
var urlOption = new Option&lt;string[]&gt;(
Â Â Â Â ["--url", "-u"],
Â Â Â Â "The URL of the bookmark"
);
urlOption.IsRequired = true;
urlOption.Arity = ArgumentArity.OneOrMore;
urlOption.AllowMultipleArgumentsPerToken = true;
urlOption.AddValidator(result =&gt;
{
Â Â Â Â foreach (var token in result.Tokens)
Â Â Â Â {
Â Â Â Â Â Â Â Â if (string.IsNullOrWhiteSpace(token.Value))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â result.ErrorMessage = "URL cannot be empty";
Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â else if (!Uri.TryCreate(token.Value, UriKind.Absolute, out _))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â result.ErrorMessage = $"Invalid URL: {token.Value}";
Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
});
var categoryOption = new Option&lt;string[]&gt;(
Â Â Â Â ["--category", "-c"],
Â Â Â Â "The category to which the bookmark is associated"
);
categoryOption.Arity = ArgumentArity.OneOrMore;
categoryOption.AllowMultipleArgumentsPerToken = true;
categoryOption.SetDefaultValue("Read later");
categoryOption.FromAmong("Read later", "Tech books", "Cooking", "Social media");
categoryOption.AddCompletions("Read later", "Tech books", "Cooking", "Social media");
static void OnHandleAddLinkCommand(string[] names, string[] urls, string[] categories)
{
Â Â Â Â service.AddLinks(names, urls, categories);
Â Â Â Â service.ListAll();
}</pre>			<p>Now, if we run <a id="_idIndexMarker150"/>the program, things work (finally) as expected! ðŸ˜Š</p>
			<div><div><img src="img/B22400_05_15.jpg" alt="Figure 5.15 â€“ Bookmarkr accepts a list of bookmarks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 â€“ Bookmarkr accepts a list of bookmarks</p>
			<p>Since each option accepts multiple values, letâ€™s take a look at whether we can simplify the following CLI request:</p>
			<pre class="console">
$ dotnet run link add --name 'Packt Publishing' --url 'https://packtpub.com/' --category 'Tech books' --name 'Audi cars' --url 'https://audi.ca' --category 'Read later'</pre>			<p>Weâ€™ll simplify it as follows:</p>
			<pre class="console">
$ dotnet run link add --name 'Packt Publishing' 'Audi cars' --url 'https://packtpub.com/' 'https://audi.ca' --category 'Tech books' 'Read later'</pre>			<p>Notice that we <a id="_idIndexMarker151"/>only need to specify <code>--name</code>, <code>--url</code>, and <code>--</code><code>category</code> once.</p>
			<p>Since both CLI requests are equivalent, they lead to the same result:</p>
			<div><div><img src="img/B22400_05_16.jpg" alt="Figure 5.16 â€“ Simplified CLI request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 â€“ Simplified CLI request</p>
			<p>Excellent! This works just great!</p>
			<p>Butâ€¦ typing a list of names, URLs, and categories might quickly become tedious as the list grows.</p>
			<p>Wouldnâ€™t it be nice if we could simply provide the path to a file as a parameter that contains all the names, URLs, and categories and let the application read that file and create the bookmarks accordingly?</p>
			<p>In the same<a id="_idIndexMarker152"/> way, wouldnâ€™t it be nice if we could specify the path to an output file to store all the bookmarks our CLI application is holding?</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor079"/>Working with files passed in as options values</h1>
			<p>Files <a id="_idIndexMarker153"/>can be provided as options values to serve as input or output parameters.</p>
			<p>As an input parameter, a fileâ€™s content can be read to import data into the CLI application. In our case, we could import bookmarks from other browsers, such as Chrome or Firefox, into Bookmarkr.</p>
			<p>As an output parameter, a file can be created to export the data that is held by Bookmarkr, which in turn can be imported into other browsers, such as Chrome or Firefox.</p>
			<p>Together, these two capabilities can enable backup and restore but also data sharing and exchange scenarios.</p>
			<p>Letâ€™s build these features<a id="_idIndexMarker154"/> into Bookmarkr!</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Browsers, such as Chrome or Firefox, have their own proprietary structure to import and export bookmarks.</p>
			<p class="callout">We wonâ€™t be performing parsing or conversion to these formats for the sake of simplicity. Our goal is to focus on working with input and output files as part of a CLI application. We will, however, import and export bookmarks in JSON format.</p>
			<p>Letâ€™s begin with the <code>export</code> command.</p>
			<p>This command is meant to take all bookmarks managed by Bookmarkr and save them in a JSON file whose path is specified as a value to the <code>--file</code> option. This option is, of course, required.</p>
			<p>First, we will need to create an option of type <code>FileInfo</code>, and it will be required:</p>
			<pre class="source-code">
var outputfileOption = new Option&lt;FileInfo&gt;(
Â Â Â Â ["--file", "-f"],
Â Â Â Â "The output file that will store the bookmarks"
)
{
Â Â Â Â IsRequired = true
};</pre>			<p>Next, we will need to create a new command and add it to the <code>root</code> command:</p>
			<pre class="source-code">
var exportCommand = new Command("export", "Exports all bookmarks to a file")
{
Â Â Â Â outputfileOption
};
rootCommand.AddCommand(exportCommand);</pre>			<p>Then, we need to set a <code>Handler</code> method for the <code>export</code> command:</p>
			<pre class="source-code">
exportCommand.SetHandler(OnExportCommand, outputfileOption);
static void OnExportCommand(FileInfo outputfile)
{
Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â File.WriteAllText(outputfile.FullName, json);
}</pre>			<p>The <code>Handler</code> method calls <code>BookmarkService</code> to get the list of all bookmarks, then converts them to JSON and saves that JSON content into the provided<a id="_idIndexMarker155"/> file. If the file already exists, it is overwritten.</p>
			<p>Note that youâ€™ll need to import this namespace for the code to compile:</p>
			<pre class="source-code">
using System.Text.Json;</pre>			<p>Now, letâ€™s try it and see whether it works as expected!</p>
			<div><div><img src="img/B22400_05_17.jpg" alt="Figure 5.17 â€“ Exporting all bookmarks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17 â€“ Exporting all bookmarks</p>
			<p>Perfect! This is exactly what we expected!</p>
			<p>But how can we ensure that the provided file has a valid name?</p>
			<p>We could certainly create a validator<a id="_idIndexMarker156"/> method to check this, but <code>System.CommandLine</code> already provides an extension method for that matter (and I wanted to let you know ðŸ˜‰):</p>
			<pre class="source-code">
outputfileOption.LegalFileNamesOnly();</pre>			<p>Letâ€™s try calling the <code>export</code> command with an invalid file:</p>
			<div><div><img src="img/B22400_05_18.jpg" alt="Figure 5.18 â€“ Handling invalid files"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18 â€“ Handling invalid files</p>
			<p>See? That error has been raised<a id="_idIndexMarker157"/> because of the call to the <code>LegalFileNamesOnly</code> method.</p>
			<p>Okay! Now letâ€™s move on to adding the <code>import</code> command!</p>
			<p>As a reminder, the syntax to import bookmark data from an existing file is as follows:</p>
			<pre class="console">
$ bookmarkr import --file &lt;path to the input file&gt;</pre>			<p>Since many of the steps involved are very similar to the ones we followed to create the <code>export</code> command, letâ€™s just share the code here and discuss the differences:</p>
			<pre class="source-code">
var inputfileOption = new Option&lt;FileInfo&gt;(
Â Â Â Â ["--file", "-f"],
Â Â Â Â "The input file that contains the bookmarks to be imported"
)
{
Â Â Â Â IsRequired = true
};
inputfileOption.LegalFileNamesOnly();
inputfileOption.ExistingOnly();
var importCommand = new Command("import", "Imports all bookmarks from a file")
{
Â Â Â Â inputfileOption
};
rootCommand.AddCommand(importCommand);
importCommand.SetHandler(OnImportCommand, inputfileOption);
static void OnImportCommand(FileInfo inputfile)
{
Â Â Â Â string json = File.ReadAllText(inputfile.FullName);
Â Â Â Â List&lt;Bookmark&gt; bookmarks = JsonSerializer.
Â Â Â Â Deserialize&lt;List&lt;Bookmark&gt;&gt;(json) ?? new List&lt;Bookmark&gt;();
Â Â Â Â service.Import(bookmarks);
}</pre>			<p>The main difference is the call to the <code>ExistingOnly</code> method. This method ensures that <code>inputfileOption</code> will only accept values corresponding to existing files, otherwise an error is raised.</p>
			<p>The other difference is how the <code>OnImportCommand</code> handler method operates: it reads the content of the file, converts it from JSON to a list of items of type <code>Bookmark</code>, and then<a id="_idIndexMarker158"/> passes it to <code>BookmarkService</code> to add these items to the list of bookmarks it manages (by calling its <code>Import</code> method).</p>
			<p>Now, letâ€™s try this code!</p>
			<div><div><img src="img/B22400_05_19.jpg" alt="Figure 5.19 â€“ Importing bookmarks from a file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19 â€“ Importing bookmarks from a file</p>
			<p>What happens if the file doesnâ€™t exist?</p>
			<div><div><img src="img/B22400_05_20.jpg" alt="Figure 5.20 â€“ Handling a non-existent file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20 â€“ Handling a non-existent file</p>
			<p>Once <a id="_idIndexMarker159"/>again, we can see that we are getting the expected result! ðŸ˜Š</p>
			<p>And thatâ€™s a wrap! You now know how to work with input and output files in your CLI applications. Congratulations! Letâ€™s now conclude this chapter.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor080"/>Summary</h1>
			<p>In this chapter, we improved our CLI application, Bookmarkr, by adding better control for the input values for its commandâ€™s options (by explicitly indicating what options are required, setting default values where appropriate, designing validators to ensure the input values comply with the expected type, format, or range of values, and enabling auto-completion to make things simpler for the user).</p>
			<p>We also added the ability to import and export application data from and to a file. This makes it easier to back up and restore data and even share it offline.</p>
			<p>In the upcoming chapter, we will see how to implement a very important feature in every application: logging and error handling.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor081"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the following features.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor082"/>Task #1 â€“ validating the format and the ability to access the input file</h2>
			<p> As a reminder, the syntax to import bookmark data from an existing file is as follows:</p>
			<pre class="console">
$ bookmarkr import --file &lt;path to the input file&gt;</pre>			<p>If the input file cannot be accessed, or if its data is not in the expected format, then the application should display a corresponding error message to the user. Otherwise, the application should import all the bookmarks from the input file and display a success message to the user indicating how many bookmarks have been imported.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor083"/>Task #2 â€“ merging existing links from the input file</h2>
			<p>When importing bookmarks from an existing file, it is possible that some of them already exist in the bookmarks held by the application.</p>
			<p>In such a situation, it is a best practice for a CLI application to provide the user with an option to control whether they want to merge those existing links or simply discard them and not import them.</p>
			<p>In this task, I challenge you to implement this best practice by adding an optional <code>--merge</code> option to the <code>import</code> command.</p>
			<p>Hence, the syntax for the <code>import</code> command with the <code>--merge</code> option will be as follows:</p>
			<pre class="console">
$ bookmarkr import --file &lt;path to the input file&gt; --merge</pre>			<p>When the <code>--merge</code> option is specified, the expected behavior of the <code>import</code> command is that for each bookmark in the provided input file, the following apply:</p>
			<ul>
				<li>If its URL already exists in the list of bookmarks held by the application, the name of the existing bookmark should be updated with the name corresponding to this URL in the input file</li>
				<li>Otherwise, the bookmark should simply be added to the list of bookmarks held by the application</li>
			</ul>
		</div>
	</body></html>