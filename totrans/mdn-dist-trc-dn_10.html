<html><head></head><body>
<div id="_idContainer114">
<h1 class="chapter-number" id="_idParaDest-162"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.2.1">Tracing Network Calls</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we’ll apply what we learned about tracing in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Tracing Your Code</span></em><span class="koboSpan" id="kobo.7.1">, to instrument client and server communication </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">via gRPC.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We’ll start by instrumenting unary gRPC calls on the client and server according to OpenTelemetry semantic conventions. </span><span class="koboSpan" id="kobo.9.2">Then, we’ll switch to streaming and explore different ways to get observability for individual messages. </span><span class="koboSpan" id="kobo.9.3">We’ll see how to describe them with events or individual spans and learn how to propagate context within individual messages. </span><span class="koboSpan" id="kobo.9.4">Finally, we’ll see how to use our instrumentation to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">investigate issues.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, you’ll learn how to do </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Instrument network calls on the client and server following OpenTelemetry semantic conventions and propagate context over </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the wire</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Instrument gRPC streaming calls according to your </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">application needs</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Apply telemetry to get insights into network call latency and failure rates and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">investigate issues</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">Using gRPC as an example, this chapter will show you how to trace network calls and propagate context through them. </span><span class="koboSpan" id="kobo.19.2">With this chapter, you should also be able to instrument advanced streaming scenarios and pick the appropriate observability signals and granularity for </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">your traces.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The code for this chapter is available in the book’s repository on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">To run the samples and perform analysis, we’ll need the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.28.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">docker-compose</span></strong></span></li>
</ul>
<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.33.1">Instrumenting client calls</span></h1>
<p><span class="koboSpan" id="kobo.34.1">Network calls are </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.35.1">probably the most important thing to instrument in any distributed application since network and downstream services are unreliable and complex resources. </span><span class="koboSpan" id="kobo.35.2">In order to understand how our application works and breaks, we need to know how the services we depend </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">on perform.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Network-level metrics can help us measure essential things such as latency, error rate, throughput, and the number of active requests and connections. </span><span class="koboSpan" id="kobo.37.2">Tracing enables context propagation and helps us see how requests flow through the system. </span><span class="koboSpan" id="kobo.37.3">So, if you instrument your application at all, you should start with incoming and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">outgoing requests.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">When instrumenting the client side of calls, we need to pick the right level of the network stack. </span><span class="koboSpan" id="kobo.39.2">Do we want to trace TCP packets? </span><span class="koboSpan" id="kobo.39.3">Can we? </span><span class="koboSpan" id="kobo.39.4">The answer depends, but distributed tracing is usually applied on the application layer of the network stack where protocols such as HTTP or </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">AMQP live.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">In the case of HTTP on .NET, we apply instrumentation on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">HttpClient</span></strong><span class="koboSpan" id="kobo.43.1"> level – to be more precise, on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">HttpMessageHandler</span></strong><span class="koboSpan" id="kobo.45.1"> level, which performs individual HTTP requests, so we trace individual retries </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and redirects.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">If we instrument </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">HttpClient</span></strong><span class="koboSpan" id="kobo.49.1"> methods, in many cases, we collect the duration of the request, which includes all attempts to get a response with back-off intervals between them. </span><span class="koboSpan" id="kobo.49.2">The error rate would show the rate without transient failures. </span><span class="koboSpan" id="kobo.49.3">This information is very useful, but it describes network-level calls very indirectly and heavily depends on the upstream service configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">and performance.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Usually, gRPC runs on top of HTTP/2 and to some extent can be covered by HTTP instrumentation. </span><span class="koboSpan" id="kobo.51.2">This is the case for unary calls, when a client sends a request and awaits a response. </span><span class="koboSpan" id="kobo.51.3">The key difference with HTTP instrumentation is that we’d want to collect a gRPC-specific set of attributes, which includes the service and method names as well as the gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">status code.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">However, gRPC also supports streaming when the client establishes a connection with the server, and then they can send each other multiple asynchronous messages within the scope of one HTTP/2 call. </span><span class="koboSpan" id="kobo.53.2">We’ll talk about streaming calls later in the </span><em class="italic"><span class="koboSpan" id="kobo.54.1">Instrumenting streaming calls</span></em><span class="koboSpan" id="kobo.55.1"> section</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.56.1"> of this chapter. </span><span class="koboSpan" id="kobo.56.2">For now, let’s focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">unary calls.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.58.1">Instrumenting unary calls</span></h2>
<p><span class="koboSpan" id="kobo.59.1">We’re going </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.60.1">to use gRPC implementation in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">Grpc.Net.Client</span></strong><span class="koboSpan" id="kobo.62.1"> NuGet</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.63.1"> package, which has an OpenTelemetry instrumentation </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">library available.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.65.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.66.1">OpenTelemetry provides two flavors of gRPC instrumentation: one for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Grpc.Net.Client</span></strong><span class="koboSpan" id="kobo.68.1"> package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">OpenTelemetry.Instrumentation.GrpcNetClient</span></strong><span class="koboSpan" id="kobo.70.1"> and another one for the lower-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Grpc.Core.Api</span></strong><span class="koboSpan" id="kobo.72.1"> package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">OpenTelemetry.Instrumentation.GrpcCore</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">Depending on how you use gRPC, make sure to use one </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">or another.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">These instrumentations should cover most gRPC tracing needs and you can customize them further using the techniques described in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.77.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.78.1">, </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">OpenTelemetry.Instrumentation.GrpcNetClient</span></strong><span class="koboSpan" id="kobo.82.1"> instrumentation allows the suppression of the underlying HTTP instrumentation or the enrichment of </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">corresponding activities.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Here, we’re going to write our own instrumentation as a learning exercise, which you can apply to other protocols or use to satisfy additional requirements that you </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">might have.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">We can wrap every gRPC call with instrumentation code, but this would be hard to maintain and would pollute the application code. </span><span class="koboSpan" id="kobo.86.2">A better approach would be to implement instrumentation in a </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">gRPC </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Interceptor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">So, we know where instrumentation should be done, but what should we instrument? </span><span class="koboSpan" id="kobo.90.2">Let’s start with gRPC OpenTelemetry semantic conventions – the tracing conventions are available </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">at </span></span><a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/rpc.md"><span class="No-Break"><span class="koboSpan" id="kobo.92.1">https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/rpc.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.93.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">The conventions are currently experimental and some changes (such as attribute renames) should </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">be expected.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">For unary client calls, the tracing specification recommends using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">{package.service}/{method}</span></strong><span class="koboSpan" id="kobo.98.1"> pattern for span names and the following set of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">essential attributes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.100.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">rpc.system</span></strong><span class="koboSpan" id="kobo.102.1"> attribute has to match </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">grpc</span></strong><span class="koboSpan" id="kobo.104.1"> – it helps backends understand that it’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">gRPC call.</span></span></li>
<li><span class="koboSpan" id="kobo.106.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">rpc.service</span></strong><span class="koboSpan" id="kobo.108.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">rpc.method</span></strong><span class="koboSpan" id="kobo.110.1"> attributes should describe the gRPC service and method. </span><span class="koboSpan" id="kobo.110.2">Even though this information is available in the span name, individual service and method attributes help query and filter spans in a more reliable and </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">efficient way.</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">net.peer.name</span></strong><span class="koboSpan" id="kobo.114.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">net.peer.port</span></strong><span class="koboSpan" id="kobo.116.1"> attributes describe </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">remote endpoints.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">rpc.grpc.status_code</span></strong><span class="koboSpan" id="kobo.119.1"> describes the numeric representation of the gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">status code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.121.1">So, in the interceptor, we need to do a few things: start a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Activity</span></strong><span class="koboSpan" id="kobo.123.1"> with the recommended</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.124.1"> name and a set of attributes, inject the</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.125.1"> context into the outgoing request, await the response, set the status, and end the activity. </span><span class="koboSpan" id="kobo.125.2">This is demonstrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">code snippet:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.127.1">client/GrpcTracingInterceptor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
public override AsyncUnaryCall&lt;Res&gt;
  AsyncUnaryCall&lt;Req, Res&gt;(Req request,
    ClientInterceptorContext&lt;Req, Res&gt; ctx,
    AsyncUnaryCallContinuation&lt;Req, Res&gt; continuation)
{
</span><strong class="bold"><span class="koboSpan" id="kobo.129.1">  var activity = Source.StartActivity(ctx.Method.FullName,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.130.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.131.1">ActivityKind.Client);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.132.1">  ctx = InjectTraceContext(activity, ctx);</span></strong><span class="koboSpan" id="kobo.133.1">
  if (activity?.IsAllDataRequested != true)
    return continuation(request, ctx);
</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">  SetRpcAttributes(activity, ctx.Method);</span></strong><span class="koboSpan" id="kobo.135.1">
  var call = continuation(request, context);
  return new AsyncUnaryCall&lt;Res&gt;(
</span><strong class="bold"><span class="koboSpan" id="kobo.136.1">    HandleResponse(call.ResponseAsync, activity, call),</span></strong><span class="koboSpan" id="kobo.137.1">
    call.ResponseHeadersAsync,
    call.GetStatus,
    call.GetTrailers,
    call.Dispose);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs"><span class="koboSpan" id="kobo.138.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.139.1">Here, we override the interceptor’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">AsyncUnaryCall</span></strong><span class="koboSpan" id="kobo.141.1"> method: we start a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Activity</span></strong><span class="koboSpan" id="kobo.143.1"> with the</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.144.1"> client kind and inject a trace context</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.145.1"> regardless of the sampling decision. </span><span class="koboSpan" id="kobo.145.2">If the activity is sampled out, we just return a continuation call and avoid any additional </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">performance overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">If the activity is sampled in, we set the gRPC attributes and return the continuation call with the modified </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">response task:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">client/GrpcTracingInterceptor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
private async Task&lt;Res&gt; HandleResponse&lt;Req, Res&gt;(Task&lt;Res&gt;
  original, Activity act, AsyncUnaryCall&lt;Req&gt; call)
{
  try
  {
    var response = await original;
    SetStatus(act, call.GetStatus());
    return response;
  }
  ...
</span><span class="koboSpan" id="kobo.150.2">  finally
  {
    act.Dispose();
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs"><span class="koboSpan" id="kobo.151.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.152.1">We dispose of </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Activity</span></strong><span class="koboSpan" id="kobo.154.1"> explicitly here since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">AsyncUnaryCall</span></strong><span class="koboSpan" id="kobo.156.1"> method is synchronous and will end before the request is complete, but we need the activity to last until </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.157.1">we</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.158.1"> get the response from </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Let’s take a closer look at each of the operations, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">context injection:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">client/GrpcTracingInterceptor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
private ClientInterceptorContext&lt;Req, Res&gt;
  InjectTraceContext&lt;Req, Res&gt;(Activity? </span><span class="koboSpan" id="kobo.163.2">act,
    ClientInterceptorContext&lt;Req, Res&gt; ctx)
  where Req: class where Res: class
{
  ...
</span><strong class="bold"><span class="koboSpan" id="kobo.164.1">  _propagator.Inject(new PropagationContext(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.165.1">      act.Context, Baggage.Current),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.166.1">    ctx.Options.Headers,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.167.1">    static (headers, k, v) =&gt; headers.Add(k, v));</span></strong><span class="koboSpan" id="kobo.168.1">
  return ctx;
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs"><span class="koboSpan" id="kobo.169.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.170.1">Here, we inject the context using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">OpenTelemetry.Context.Propagation.TextMapPropagator</span></strong><span class="koboSpan" id="kobo.172.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Inject</span></strong><span class="koboSpan" id="kobo.174.1"> method. </span><span class="koboSpan" id="kobo.174.2">We’ll see how the propagator is configured a </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">bit later.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">We created an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">PropagationContext</span></strong><span class="koboSpan" id="kobo.178.1"> structure – it contains everything that needs to be propagated, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.180.1"> and the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">current </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Baggage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The context is injected into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">ctx.Options.Headers</span></strong><span class="koboSpan" id="kobo.186.1"> property, which represents gRPC metadata. </span><span class="koboSpan" id="kobo.186.2">The metadata is later on transformed into HTTP request headers </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">GrpcNetClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">The last parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">Inject</span></strong><span class="koboSpan" id="kobo.192.1"> method is a function that tells the propagator how to inject key-value pairs with trace context into the provided metadata. </span><span class="koboSpan" id="kobo.192.2">The propagator, depending on its implementation, may follow different formats and inject different headers. </span><span class="koboSpan" id="kobo.192.3">Here, we don’t need to worry </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">about it.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Okay, we </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.195.1">injected</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.196.1"> the context to enable correlation with the backend, and now it’s time to populate </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">the attributes:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">client/GrpcTracingInterceptor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
private void SetRpcAttributes&lt;Req, Res&gt;(Activity act,
  Method&lt;Req, Res&gt; method)
{
  act.SetTag("rpc.system", "grpc");
  act.SetTag("rpc.service", method.ServiceName);
  act.SetTag("rpc.method", method.Name);
  act.SetTag("net.peer.name", _host);
  if (_port != 80 &amp;&amp; _port != 443)
    act.SetTag("net.peer.port", _port);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs"><span class="koboSpan" id="kobo.200.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.201.1">Here, we populate the service and method names from the information provided in the call context. </span><span class="koboSpan" id="kobo.201.2">But the host and port come from instance variables we passed to the interceptor constructor – this information is not available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">client interceptor.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Finally, we should populate the gRPC status code and </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Activity</span></strong><span class="koboSpan" id="kobo.205.1"> status once the response</span><a id="_idIndexMarker559"/> <span class="No-Break"><span class="koboSpan" id="kobo.206.1">is </span></span><span class="No-Break"><a id="_idIndexMarker560"/></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">received:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">client/GrpcTracingInterceptor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
private static void SetStatus(Activity act, Status status)
{
  act.SetTag("rpc.grpc.status_code",
    (int)status.StatusCode);
  var activityStatus = status.StatusCode != StatusCode.OK ?
</span><span class="koboSpan" id="kobo.209.2">    ActivityStatusCode.Error : ActivityStatusCode.Unset;
  act.SetStatus(activityStatus, status.Detail);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs"><span class="koboSpan" id="kobo.210.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/GrpcTracingInterceptor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.211.1">We left </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Activity.Status</span></strong><span class="koboSpan" id="kobo.213.1"> unset if the request was successful following the gRPC semantic conventions. </span><span class="koboSpan" id="kobo.213.2">It makes sense for generic instrumentation libraries since they don’t know what represents a success. </span><span class="koboSpan" id="kobo.213.3">In a custom instrumentation, we may know better and can be </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">more specific.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">This is it; we just</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.216.1"> finished</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.217.1"> unary call instrumentation on the client. </span><span class="koboSpan" id="kobo.217.2">Let’s now configure a gRPC client </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">to use.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.219.1">Configuring instrumentation</span></h2>
<p><span class="koboSpan" id="kobo.220.1">Let’s set </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.221.1">up a</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.222.1"> tracing interceptor on </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">GrpcClient</span></strong><span class="koboSpan" id="kobo.224.1"> instances. </span><span class="koboSpan" id="kobo.224.2">In the demo application, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">GrpcClient</span></strong><span class="koboSpan" id="kobo.226.1"> integration with ASP.NET Core and set it up in the </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">following way:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.228.1">client/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
builder.Services
  .AddGrpcClient&lt;Nofitier.NofitierClient&gt;(o =&gt; {
    o =&gt; o.Address = serverEndpoint; ... </span><span class="koboSpan" id="kobo.229.2">})
</span><strong class="bold"><span class="koboSpan" id="kobo.230.1">  .AddInterceptor(() =&gt; new GrpcTracingInterceptor(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.231.1">    serverEndpoint, contextPropagator))</span></strong><span class="koboSpan" id="kobo.232.1">
  ...</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Program.cs"><span class="koboSpan" id="kobo.233.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.234.1">Here, we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">GrpcClient</span></strong><span class="koboSpan" id="kobo.236.1">, configured the endpoint, and added a tracing interceptor. </span><span class="koboSpan" id="kobo.236.2">We passed the options – the service endpoint and context propagator – </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">The propagator is the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">TextMapPropagator</span></strong><span class="koboSpan" id="kobo.240.1"> class – we use a composite one that supports W3C Trace Context and </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">Baggage formats:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.242.1">client/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
CompositeTextMapPropagator contextPropagator = new (
  new TextMapPropagator[] {
    new TraceContextPropagator(),
    new BaggagePropagator() });
Sdk.SetDefaultTextMapPropagator(contextPropagator);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Program.cs"><span class="koboSpan" id="kobo.244.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.245.1">The last step is to configure OpenTelemetry and enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.247.1"> we use in </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">the interceptor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">client/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
builder.Services.AddOpenTelemetry()
  .WithTracing(b =&gt; b.AddSource("Client.Grpc")...);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Program.cs"><span class="koboSpan" id="kobo.251.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.252.1">That’s it for</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.253.1"> the unary client calls. </span><span class="koboSpan" id="kobo.253.2">Let’s now </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.254.1">instrument </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">the server.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.256.1">Instrumenting server calls</span></h1>
<p><span class="koboSpan" id="kobo.257.1">Service-side </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.258.1">instrumentation is similar. </span><span class="koboSpan" id="kobo.258.2">We can use the gRPC interceptor again and this time override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">UnaryServerHandler</span></strong><span class="koboSpan" id="kobo.260.1"> method. </span><span class="koboSpan" id="kobo.260.2">Once the request is received, we should extract the context and start a new activity. </span><span class="koboSpan" id="kobo.260.3">It should have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">server</span></strong><span class="koboSpan" id="kobo.262.1"> kind, a name that follows the same pattern as for the client span – </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">{package.service}/{method}</span></strong><span class="koboSpan" id="kobo.264.1"> – and attributes very similar to those we saw on the client. </span><span class="koboSpan" id="kobo.264.2">Here’s the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">interceptor code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">server/GrpcTracingInterceptor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
var traceContext = _propagator.Extract(default,
  ctx.RequestHeaders,
  static (headers, k) =&gt; new[] { headers.GetValue(k) });
Baggage.Current = traceContext.Baggage;
using var activity = Source.StartActivity(ctx.Method,
  ActivityKind.Server, traceContext.ActivityContext);
if (activity?.IsAllDataRequested != true)
  return await continuation(request, ctx);
SetRpcAttributes(activity, ctx.Host, ctx.Method);
try
{
  var response = await continuation(request, ctx);
  SetStatus(activity, ctx.Status);
  return response;
}
catch (Exception ex) {...}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/server/GrpcTracingInterceptor.cs"><span class="koboSpan" id="kobo.268.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/server/GrpcTracingInterceptor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.269.1">We extract the</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.270.1"> trace context and baggage using the propagator and then pass the extracted parent trace context to the new activity and add the attributes. </span><span class="koboSpan" id="kobo.270.2">The server interceptor callback is asynchronous, so we can await a response from the server and populate </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the status.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">That’s it; now we just need to configure interceptors and </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">enable </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">ActivitySource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">server/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
builder.Services
  .AddSingleton&lt;TextMapPropagator&gt;(contextPropagator)
  .AddGrpc(o =&gt; {
    </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">o.Interceptors.Add&lt;GrpcTracingInterceptor&gt;();</span></strong><span class="koboSpan" id="kobo.279.1"> ...});
builder.Services.AddOpenTelemetry()
    .WithTracing(b =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">b.AddSource("Server.Grpc")</span></strong><span class="koboSpan" id="kobo.281.1">...);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/server/Program.cs"><span class="koboSpan" id="kobo.282.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/server/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.283.1">We added gRPC services, configured the tracing interceptor, and enabled the new activity source. </span><span class="koboSpan" id="kobo.283.2">It’s time to check out </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">generated traces.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Run the application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">$docker-compose up --build</span></strong><span class="koboSpan" id="kobo.287.1"> and then hit the frontend at </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">http://localhost:5051/single/hello</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">It will send a message to the server </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.290.1">and return a response or show a transient error. </span><span class="koboSpan" id="kobo.290.2">An example of a trace with an error is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.291.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.292.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.294.1"><img alt="Figure 10.1 – gRPC trace showing error on server" src="image/B19423_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.295.1">Figure 10.1 – gRPC trace showing error on server</span></p>
<p><span class="koboSpan" id="kobo.296.1">Here, we see two spans from the client application and one from the server. </span><span class="koboSpan" id="kobo.296.2">They describe an incoming request collected by the ASP.NET Core instrumentation and client and server sides of the gRPC call. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.297.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.298.1">.2</span></em><span class="koboSpan" id="kobo.299.1"> shows client span attributes where we can see the destination </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">and status:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.301.1"><img alt="Figure 10.2 – gRPC client attributes" src="image/B19423_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.302.1">Figure 10.2 – gRPC client attributes</span></p>
<p><span class="koboSpan" id="kobo.303.1">This instrumentation allows us to trace unary calls for any gRPC service, which is similar to the HTTP instrumentation we saw in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.304.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.305.1">, </span><em class="italic"><span class="koboSpan" id="kobo.306.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">Let’s now explore</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.308.1"> instrumentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">streaming calls.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.310.1">Instrumenting streaming calls</span></h1>
<p><span class="koboSpan" id="kobo.311.1">So far in the </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.312.1">book, we have covered the instrumentation of synchronous calls where the application makes a request and awaits its completion. </span><span class="koboSpan" id="kobo.312.2">However, it’s common to use gRPC or other protocols, such as SignalR or WebSocket, to communicate in an asynchronous way when the client and server establish a connection and then send each </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">other messages.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Common use cases for this kind of communication include chat applications, collaboration tools,  and other cases when data should flow in real time and frequently in </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">both directions.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The call starts when the client initiates a connection and may last until the client decides to disconnect, the connection becomes idle, or some network issue happens. </span><span class="koboSpan" id="kobo.316.2">In practice, it means that such calls may last </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">for days.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">While a connection is alive, the client and server can write each other messages to corresponding network streams. </span><span class="koboSpan" id="kobo.318.2">It’s much faster and more efficient when the client and server communicate frequently within a relatively short period of time. </span><span class="koboSpan" id="kobo.318.3">This approach minimizes the overhead created by DNS lookup, protocol negotiation, load balancing, authorization, and routing compared to request-response communication when at least some of these operations would happen for </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">each request.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">On the downside, the application could become more complex as in many cases, we’d still need to correlate client messages with service replies to them and come up with our own semantics for metadata and </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">status codes.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">For </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.323.1">observability, it means that out-of-the-box instrumentation is rarely enough and at least some custom instrumentation is necessary. </span><span class="koboSpan" id="kobo.323.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">see why.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.325.1">Basic instrumentation</span></h2>
<p><span class="koboSpan" id="kobo.326.1">Some applications</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.327.1"> pass completely independent messages within one streaming call and would want different traces to describe individual messages. </span><span class="koboSpan" id="kobo.327.2">Others use streaming to send scoped batches of messages and would rather expect one trace to describe everything that happens within one streaming call. </span><span class="koboSpan" id="kobo.327.3">When it comes to streaming, there is no </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">single solution.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">gRPC auto-instrumentations follow OpenTelemetry semantic conventions and provide a default experience where a streaming call is represented with client and server spans, even if the call lifetime is unbound. </span><span class="koboSpan" id="kobo.329.2">Individual messages are described with span events with attributes covering the direction, message identifier, </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">and size.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">You can find a full instrumentation implementation that follows these conventions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">client/GrpcTracingInterceptor.cs</span></strong><span class="koboSpan" id="kobo.333.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">server/GrpcTracingInterceptor.cs</span></strong><span class="koboSpan" id="kobo.335.1"> files in the book’s repository. </span><span class="koboSpan" id="kobo.335.2">Let’s look at the traces </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">it produces.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">Go ahead and start the application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.339.1"> and then hit the client application at </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">http://localhost:5051/streaming/hello?count=2</span></strong><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">It will send two messages to the server and read all </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the responses.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">Check out Jaeger at </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">http://localhost:16686/</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">You should see a trace similar to the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.346.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.347.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.349.1"><img alt="Figure 10.3 – Streaming call with events" src="image/B19423_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.350.1">Figure 10.3 – Streaming call with events</span></p>
<p><span class="koboSpan" id="kobo.351.1">Similarly to a unary call, the trace consists of three spans. </span><span class="koboSpan" id="kobo.351.2">The only difference is that client and server gRPC spans have events – two events per message, indicating when the message was sent and received. </span><span class="koboSpan" id="kobo.351.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">message.id</span></strong><span class="koboSpan" id="kobo.353.1"> attribute here represents the sequence number of a message in a request or response stream and might be used to correlate request and </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">response messages.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">The trace</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.356.1"> shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.357.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.358.1">.3</span></em><span class="koboSpan" id="kobo.359.1"> represents the best we can achieve with auto-instrumentation that is not aware of our specific streaming usage. </span><span class="koboSpan" id="kobo.359.2">Let’s see how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">improve it.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.361.1">Tracing individual messages</span></h2>
<p><span class="koboSpan" id="kobo.362.1">Let’s pretend</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.363.1"> that the client initiates a very long stream – in this case, the previous trace would not be very helpful. </span><span class="koboSpan" id="kobo.363.2">Assuming messages are not too frequent and verbose, we might want to instrument each specific message and see how server response messages correlate with </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">client messages.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">To instrument individual messages, we’d have to propagate context inside the message, which is not possible in an interceptor where we operate with generic </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">message types.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">Our message protobuf definition contains text and an attribute map that we can use to pass </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">trace context:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.369.1">client\Protos\notifier.proto</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
message Message {
  string text = 1;
</span><strong class="bold"><span class="koboSpan" id="kobo.371.1">  map&lt;string, string&gt; attributes = 2;</span></strong><span class="koboSpan" id="kobo.372.1">
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/notifier.proto"><span class="koboSpan" id="kobo.373.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/notifier.proto</span></a></p>
<p><span class="koboSpan" id="kobo.374.1">We’re going to create one client span per message to describe and identify it, and a server span that will represent processing </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">the message.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">If we have hundreds of messages during one streaming call, having all of them in one trace will be hard to read. </span><span class="koboSpan" id="kobo.376.2">Also, typical sampling techniques would not apply – depending on the sampling decision made for the whole streaming call, we’ll sample in or drop all </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">per-message spans.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Ideally, we want to have a trace per message flow and have a link to the long-running HTTP requests that carried the message over. </span><span class="koboSpan" id="kobo.378.2">This way, we still know what happened with the transport and what else was sent over the same HTTP request, but we’ll make independent sampling decisions and will have smaller and more </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">readable traces.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.380.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.381.1">Tracing individual messages is reasonable when messages are relatively big and processing them takes a reasonable amount of time. </span><span class="koboSpan" id="kobo.381.2">Alternative approaches may include custom correlation or context propagation for sampled-in </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">messages only.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Let’s go ahead</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.384.1"> and instrument individual messages: we’ll need to start a new activity per message with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">producer</span></strong><span class="koboSpan" id="kobo.386.1"> kind indicating an async call. </span><span class="koboSpan" id="kobo.386.2">We need to start a new trace and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.388.1"> as a link rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">a parent:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">client/controllers/StreamingController.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
IEnumerable&lt;ActivityLink&gt;? </span><span class="koboSpan" id="kobo.391.2">links = null;
if (Activity.Current != null)
{
  links = new[] {
    new ActivityLink(Activity.Current.Context) };
</span><strong class="bold"><span class="koboSpan" id="kobo.392.1">  Activity.Current = null;</span></strong><span class="koboSpan" id="kobo.393.1">
}
</span><strong class="bold"><span class="koboSpan" id="kobo.394.1">using var act = Source.StartActivity("SendMessage",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.395.1">  ActivityKind.Producer,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.396.1">  default(ActivityContext),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.397.1">  links: links)</span></strong><span class="koboSpan" id="kobo.398.1">;</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Controllers/StreamingController.cs"><span class="koboSpan" id="kobo.399.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Controllers/StreamingController.cs</span></a></p>
<p><span class="koboSpan" id="kobo.400.1">We created a link from the current activity and then set </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.402.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">null</span></strong><span class="koboSpan" id="kobo.404.1">, which</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.405.1"> forces the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">StartActivity</span></strong><span class="koboSpan" id="kobo.407.1"> method to create an </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">orphaned activity.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.409.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.410.1">Setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.412.1"> should be done with caution. </span><span class="koboSpan" id="kobo.412.2">In this example, we’re starting a new task specifically to ensure that it won’t change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.414.1"> value beyond the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">this task.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">We have an activity; now it’s time to inject the context and send a message to </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">the server:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.418.1">client/controllers/StreamingController.cs</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.419.1">_propagator.Inject(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.420.1">  new PropagationContext(act.Context, Baggage.Current),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.421.1">  message,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.422.1">  static (m, k, v) =&gt; m.Attributes.Add(k, v));</span></strong><span class="koboSpan" id="kobo.423.1">
try
{
  await requestStream.WriteAsync(message);
}
catch (Exception ex)
{
  act?.SetStatus(ActivityStatusCode.Error, ex.Message);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Controllers/StreamingController.cs"><span class="koboSpan" id="kobo.424.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/client/Controllers/StreamingController.cs</span></a></p>
<p><span class="koboSpan" id="kobo.425.1">Context injection looks similar to what we did in the client interceptor earlier in this chapter, except here we inject it into message attributes rather than gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">call metadata.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">On the server side, we need to extract the context from the message, then use it as a parent. </span><span class="koboSpan" id="kobo.427.2">We should also set </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.429.1"> as a link so we don’t lose correlation between the message processing and streaming calls. </span><span class="koboSpan" id="kobo.429.2">The new activity has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">consumer</span></strong><span class="koboSpan" id="kobo.431.1"> kind, which indicates </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.432.1">the processing side of the async call, as shown in this </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">code snippet:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.434.1">server/NotifierService.cs</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.435.1">var context = _propagator.Extract(default,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.436.1">  message,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.437.1">  static (m, k) =&gt; m.Attributes.TryGetValue(k, out var v)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.438.1">      ? </span><span class="koboSpan" id="kobo.438.2">new [] { v } : Enumerable.Empty&lt;string&gt;());</span></strong><span class="koboSpan" id="kobo.439.1">
var link = Activity.Current == null ?
</span><span class="koboSpan" id="kobo.439.2">   default : new ActivityLink(Activity.Current.Context);
using var act = Source.StartActivity(
  "ProcessMessage",
  ActivityKind.Consumer,
</span><strong class="bold"><span class="koboSpan" id="kobo.440.1">  context.ActivityContext,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.441.1">  links: new[] { link });</span></strong><span class="koboSpan" id="kobo.442.1">
...</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/server/NotifierService.cs"><span class="koboSpan" id="kobo.443.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter10/server/NotifierService.cs</span></a></p>
<p><span class="koboSpan" id="kobo.444.1">We can now enable corresponding client and server activity sources – we used different names for per-message tracing and interceptors, so we can now control instrumentations individually. </span><span class="koboSpan" id="kobo.444.2">Go ahead and enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Client.Grpc.Message</span></strong><span class="koboSpan" id="kobo.446.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Server.Grpc.Message</span></strong><span class="koboSpan" id="kobo.448.1"> sources on the client and server correspondingly and then start </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">an application.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">If we hit the streaming endpoint at </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">http://localhost:5051/streaming/hello?count=5</span></strong><span class="koboSpan" id="kobo.452.1"> and then went to Jaeger, we’d see six traces – one for each message sent and one for the </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">gRPC call.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Per-message </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.455.1">traces consist of two spans, like the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.456.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.457.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.459.1"><img alt="Figure 10.4 – Tracing messages in individual traces" src="image/B19423_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.460.1">Figure 10.4 – Tracing messages in individual traces</span></p>
<p><span class="koboSpan" id="kobo.461.1">Here, we see that sending this message took about 1 ms and processing it took about 100 ms. </span><span class="koboSpan" id="kobo.461.2">Both spans have links (references in Jaeger terminology) to spans describing the client and server sides of the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">gRPC call.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">If we didn’t force new trace creation for individual messages, we’d see only one trace containing all the spans, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.464.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.467.1"><img alt="Figure 10.5 – Tracing ﻿a streaming call with all messages in one trace" src="image/B19423_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.468.1">Figure 10.5 – Tracing a streaming call with all messages in one trace</span></p>
<p><span class="koboSpan" id="kobo.469.1">Depending on your scenario, you might prefer to separate traces, have one big trace, or come up with </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">something else.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">Note that we can now remove our custom tracing interceptor and enable shared gRPC and HTTP client instrumentation libraries. </span><span class="koboSpan" id="kobo.471.2">If you do this, the per-message instrumentation will remain exactly the same and will keep working along </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">with auto-instrumentation.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">With this, you</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.474.1"> should be able to instrument unary or streaming gRPC calls and have an idea of how to extend it to other cases, including SignalR or </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">socket communication.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Let’s now see how to use gRPC instrumentation to </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">investigate issues.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.478.1">Observability in action</span></h1>
<p><span class="koboSpan" id="kobo.479.1">There are several</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.480.1"> issues in our server application. </span><span class="koboSpan" id="kobo.480.2">First issue reproduces sporadically when you hit the frontend at </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">http://localhost:5051/single/hello</span></strong><span class="koboSpan" id="kobo.482.1"> several times. </span><span class="koboSpan" id="kobo.482.2">You might notice that some requests take longer than others. </span><span class="koboSpan" id="kobo.482.3">If we look at the duration metrics or Jaeger’s duration view, we’ll see something similar to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.483.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.484.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.486.1"><img alt="Figure 10.6 – Duration view in Jaeger" src="image/B19423_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.487.1">Figure 10.6 – Duration view in Jaeger</span></p>
<p><span class="koboSpan" id="kobo.488.1">We see that most of the calls are fast (around 100 ms), but there is one that takes longer than a </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.489.1">second. </span><span class="koboSpan" id="kobo.489.2">If we click on it, Jaeger will open the corresponding trace, like the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.490.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.491.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.493.1"><img alt="Figure 10.7 – Long trace with errors" src="image/B19423_10_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.494.1">Figure 10.7 – Long trace with errors</span></p>
<p><span class="koboSpan" id="kobo.495.1">Apparently, there were three attempts to send the message – the first two were not successful, but the third one succeeded. </span><span class="koboSpan" id="kobo.495.2">So retries are the source of long latency. </span><span class="koboSpan" id="kobo.495.3">We can investigate the error by expanding the exception event – we’ll see a full stack </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">trace there.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">Notably, we see retries only on the service side here. </span><span class="koboSpan" id="kobo.497.2">There is just one gRPC span on the client side. </span><span class="koboSpan" id="kobo.497.3">What happens here is that we enable a retry policy on the gRPC client channel, which internally adds a retry handler to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">HttpClient</span></strong><span class="koboSpan" id="kobo.499.1"> level. </span><span class="koboSpan" id="kobo.499.2">So, our tracing interceptor is not called on tries and traces the logical part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">gRPC call.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">The official </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">OpenTelemetry.Instrumentation.GrpcNetClient</span></strong><span class="koboSpan" id="kobo.503.1"> instrumentation works properly and traces individual tries on the client </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Let’s look at another problem. </span><span class="koboSpan" id="kobo.505.2">Send the following request: </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">http://localhost:5051/streaming/hello?count=10</span></strong><span class="koboSpan" id="kobo.507.1">. </span><span class="koboSpan" id="kobo.507.2">It will return a few messages and then stop. </span><span class="koboSpan" id="kobo.507.3">If we look into Jaeger traces, we’ll see a lot of errors for individual messages. </span><span class="koboSpan" id="kobo.507.4">Some</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.508.1"> of them will have just a client span, like the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.509.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.510.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.512.1"><img alt="Figure 10.8 – Client error without server span" src="image/B19423_10_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1">Figure 10.8 – Client error without server span</span></p>
<p><span class="koboSpan" id="kobo.514.1">There is not much information in the span, but luckily, we have a link to the gRPC call. </span><span class="koboSpan" id="kobo.514.2">Let’s follow it to see whether it explains something. </span><span class="koboSpan" id="kobo.514.3">The corresponding trace is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.515.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.516.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.518.1"><img alt="Figure 10.9 – Error in the middle of the gRPC stream" src="image/B19423_10_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.519.1">Figure 10.9 – Error in the middle of the gRPC stream</span></p>
<p><span class="koboSpan" id="kobo.520.1">Here, we see a familiar trace, but the processing has failed while parsing the message text. </span><span class="koboSpan" id="kobo.520.2">The server span has six events, indicating that two messages were received and the response was successfully sent to the server. </span><span class="koboSpan" id="kobo.520.3">The third one was received but then instead of the response, we see an exception with a stack trace to help us </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">investigate further.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">If we expand the </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.523.1">client gRPC span, we’ll see more exceptions for each message that was attempted to be sent after the server error </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">has happened.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">But there were no retries – why? </span><span class="koboSpan" id="kobo.525.2">In our case, gRPC retries, as we’ve seen in the previous example, are applied on the HTTP level. </span><span class="koboSpan" id="kobo.525.3">In the case of streaming, it means that after the first response is received from the server, the HTTP response, including status codes and headers, is received and the rest of the communication happens within the request and response streams. </span><span class="koboSpan" id="kobo.525.4">You can read more about this in the Microsoft gRPC documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">at </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/retries"><span class="No-Break"><span class="koboSpan" id="kobo.527.1">https://learn.microsoft.com/en-us/aspnet/core/grpc/retries</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.528.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">So, once an unhandled exception is thrown on the server for a particular message, it ends the gRPC call and corresponding request and response streams on the client and server. </span><span class="koboSpan" id="kobo.529.2">It affects all remaining messages on the client and explains the partial response </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">we noticed.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Distributed tracing helps us see what happens and learn more about the technologies we use. </span><span class="koboSpan" id="kobo.531.2">In addition to tracing, OpenTelemetry defines a set of metrics to monitor on the client and server sides, which includes the duration, the failure rate that can be derived from it, the </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.532.1">number of requests and responses, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">payload sizes.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.534.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.535.1">In this chapter, we got hands-on experience in instrumenting network calls using gRPC as an example. </span><span class="koboSpan" id="kobo.535.2">Before starting instrumentation, we learned about the available instrumentation libraries and what OpenTelemetry semantic conventions recommend recording </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">for gRPC.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">First, we instrumented unary calls with client and server spans and propagated context through gRPC metadata. </span><span class="koboSpan" id="kobo.537.2">Then, we experimented with gRPC streaming, which needs a different approach to tracing. </span><span class="koboSpan" id="kobo.537.3">The generic instrumentation of streaming calls suggests creating an event per individual request and response message in the stream and provides a basic level of observability. </span><span class="koboSpan" id="kobo.537.4">Depending on our scenarios and observability needs, we can add another layer of instrumentation to trace individual messages. </span><span class="koboSpan" id="kobo.537.5">These custom spans work on top of the generic </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">gRPC instrumentation.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">Finally, we used tracing to get insights into high latency and transient error scenarios, which also helped us understand </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">gRPC internals.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">You’re now ready to instrument your network stack with tracing or enrich existing instrumentation libraries by adding custom layers of instrumentation specific to your application. </span><span class="koboSpan" id="kobo.541.2">In the next chapter, we’ll look into messaging scenarios and dive even deeper into observability for </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">asynchronous processing.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.543.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.544.1">When using gRPC, would you write your own instrumentation or reuse an </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">existing one?</span></span></li>
<li><span class="koboSpan" id="kobo.546.1">Let’s imagine we want to instrument gRPC communication between the client and server when the client initiates a connection at startup time and keeps it open forever (until the server or client stops) and then reuses this connection for all the communication. </span><span class="koboSpan" id="kobo.546.2">Which tracing approach would you </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">choose? </span><span class="koboSpan" id="kobo.547.2">Why?</span></span></li>
</ol>
</div>
</body></html>