- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In video games, objects continually transition from one state to another depending
    on events that might be triggered by the player or the game's mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: So, one of the primary responsibilities of a game programmer is to implement
    a list of finite states and behaviors for entities, ranging from **non-player
    characters** (**NPCs**) to weapons. These tasks must be accomplished in a way
    that's maintainable and configurable so that a team of designers can tweak each
    stateful behavior individually until the game feels balanced.
  prefs: []
  type: TYPE_NORMAL
- en: The State pattern was designed precisely to accomplish this by offering a simple
    way to encapsulate behaviors into individual classes that represent the specific
    states of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the State pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a collection of finite states for a game involving a spaceship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity-specific engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with this concept, please review it before moving forward
    with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2UfzpTD](http://bit.ly/2UfzpTD)'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The State pattern is very similar to the Strategy pattern in the sense that
    it permits us to apply behaviors at runtime to a specific object. The core difference
    is that the State pattern is used when we need to manage an object's internal
    states, while the Strategy pattern focuses on choosing the right algorithm to
    execute, depending on the runtime context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of a class structure for a spaceship project, the following
    diagram shows how state classes (`NormalShipState`, `AlertShipState`, and `DisabledShipState`)
    have a standard interface that permits the `Ship` class to invoke the behavior
    of a specific state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23d448b1-a72a-4f10-8443-02abb2a98e78.png)'
  prefs: []
  type: TYPE_IMG
- en: As we will see in the code example, the concept behind the State pattern is
    as simple as its actual implementation, because it offers us a way to encapsulate
    behaviors and apply them, without resorting to long conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be challenging to pinpoint the common drawbacks of the State pattern,
    because managing states are fundamental to game development, so we could say that
    this pattern is essential and cannot be disregarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of using the State pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulated behaviors**: The State pattern allows us to implement an entity''s
    behaviors as a collection of self-contained components that can be attached dynamically
    to an object when it changes states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduction of condition blocks**: Using the State pattern reduces the need
    for huge chunks of `if-else` conditions or switching cases, because behaviors
    can be dynamically assigned depending on an object''s internal or global state
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is only one drawback:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code complexity**: Implementing patterns sometimes results in verbose code
    bases with a higher number of classes because of encapsulation and highly defined
    structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine we are working on a game in which the player controls a spaceship.
    Our lead designer is still brainstorming ideas on what exactly the spaceship will
    be able to do in our game. But they ask us to implement at least three core states
    that our spaceship could be in depending on the result of a space battle against
    an enemy ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal**: The player''s spaceship is running as normal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alert**: An enemy spaceship is approaching and is ready to attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: The player''s spaceship has been defeated in battle and currently
    cannot move or fight back'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In each state, there''s a specific set of behaviors and actions for the crew
    members to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal**: The crew members go into their default positions and perform their
    assigned duties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alert**: The crew members run to their assigned combat positions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: The crew members run to the escape pods and abandon the ship'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important thing about this list is that it's very generic, which means
    that we could write those states and behaviors so, we can attach them to any type
    of ship in our game, including enemy ships. As we will see in the following code
    example, the State pattern permits us to decouple behaviors from entities, and
    this is why we can easily have an entity switch between states.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described in the use case example, we are going to implement a finite series
    of states for our spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the interface that will be used to define our
    states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Execute` function receives an entity of the `Ship` type. This
    declaration means that we will able to attach and execute our state on any ship,
    making our code very modular and extendable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to define each state and add some contextual code to the `Execute()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Normal` state is our default one, which executes the behaviors of a normally
    operating ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the `Alert` state. In this context, the crew of the ship and its system
    are alerted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is the `Disabled` state. This means that the ship is unable
    to move and the crew is fleeing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For our code example, we are making things straightforward by merely implementing
    some console outputs to indicate the current state, but in a real project, we
    could easily trigger sound cues, particles, and animations for every state change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a collection of states that we can attach to a ship. For the
    next step, let''s write a concrete implementation of the `Ship` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review a short list of what we have accomplished with this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: We have eliminated the need for switch cases or `if-elses` to manage the transition
    between the ship's stateful behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have decoupled the ship's behaviors into self-contained components that we
    can attach dynamically to any type of ship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These small benefits have given us a considerable amount of flexibility, and
    we can now write behaviors as individual components. This means we could have
    one colleague working on the `Alert` state while another refactors the `Disabled`
    state, without interfering with each other's work.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the final part of our code example is our `Client`, a class that we will
    use to test each state by triggering them with the user''s input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are manually triggering the ship's finite states, but we
    could have easily used events or a health system to trigger them. In other words,
    by using the State pattern, we have been given the flexibility to attach multiple
    stateful behaviors to any entity and trigger them dynamically through any type
    of mechanism, without having to write long and complex conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed a pattern that's the cornerstone of game development.
    We now have the ability to encapsulate stateful behaviors into individual components
    that can be assigned dynamically to an object depending on its state. We have
    reduced our dependency on long conditional statements and have a consistent approach
    to structuring our code that's related to behaviors and state management.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to review the Visitor pattern, a unique pattern
    that gives us the ability to decouple algorithms from an object's structure.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A conventional technique in video games to make entities feel less mechanical
    in the way they behave is to ease out the transition between states. For example:
    instead of having a patrolling enemy character transitioning immediately from
    a passive to an aggressive state when they detect the player''s character, there
    could be a short animation sequence in between states, showing the enemy going
    into an alert stance before attacking.'
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, I would recommend experimenting with the concept of integrating
    transitional states between each finite state of the spaceship and find a solution
    to make the transition between them blend seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, by Erich
    Gamma, John Vlissides, Ralph Johnson, and Richard Helm'
  prefs: []
  type: TYPE_NORMAL
- en: ([http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610))
  prefs: []
  type: TYPE_NORMAL
