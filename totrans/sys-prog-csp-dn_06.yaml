- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One Where Processes Whisper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Interprocess* *Communication (IPC)*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about input/output. Most of our attention
    was on files. Files are one of the first things that spring to mind when people
    think about sharing data with other systems. Another often-used method is networking.
    However, there are other ways systems can communicate with one another. Files
    are great if you want to keep data around for a more extended time. Network connections
    are an excellent way to connect more directly between systems on different machines.
    But files and networking are more about the underlying technology to transmit
    data. We also must decide how to connect to systems using those methods. That
    is what **interprocess communication** (**IPC**) in short, is all about. How can
    we have two systems talk to each other?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is IPC?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What considerations do we have to worry about when designing IPC?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Messages – a Windows-native way of messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes – both named and anonymous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets – a network-based messaging system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared memory – a quick and simple local messaging system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote procedure call** (**RPC**) – controlling other machines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google remote procedure call** (**gRPC**) – the newest kid on the block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome to the beautiful world of whispering systems!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will find all the code in this chapter in the following link: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter06](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of IPC and its importance in modern computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most software has a user interface. After all, that is how the user should interact
    with the application. The user clicks buttons, enters text, and reads the response
    on the screen. The screen is how data, the user, and the application exchange
    data and instructions.
  prefs: []
  type: TYPE_NORMAL
- en: People do not use systems software. Other software does. So, it needs a different
    way to interact. I suppose it would technically be possible to write a regular
    user interface and use tricks to read or enter data, but that is not really efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Applications communicate differently when they are talking amongst themselves.
    They have their own language and their own protocols. This is what IPC is all
    about – the communication between processes.
  prefs: []
  type: TYPE_NORMAL
- en: Given the nature of systems, we must consider several key points when designing
    the interface between systems. We make different choices when designing this interface
    than if we were designing a user interface meant for people. There are many factors
    to consider here. Let’s go through them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Choose your language wisely:** Systems can use many different ways to talk
    to one another, and, just like human conversations, it helps tremendously if all
    parties involved speak the same language. This chapter describes how we can make
    the systems talk to each other, but there are many more. Some ways are better
    suited for a particular environment or use case than others, so you must think
    it through. Do not pick the one you feel most comfortable with because you know
    that solution. Think of all the use case scenarios and then pick the proper protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Security is a huge topic, especially in systems programming.
    We are dealing with data, and the systems are hidden deep in our computers. Most
    people do not know that multiple processes are running on their machines, so they
    are not very likely to inspect them and assess their level of security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data format and serialization**: You must consider the best way to transform
    your data as it moves from one system to another. The data must be part of a package,
    envelope, or other transmitting method. There are many different formats and ways
    to serialize, but which one you choose depends on many factors. For instance,
    if you use a direct memory connection between two 64-bit processes on the same
    Windows machine, you can use a very efficient, lightweight binary representation.
    However, suppose you have to talk to a machine running a different operating system
    on the other side of the globe. In that case, you must devise a serialization
    mechanism both systems understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling and robustness**: Software can go wrong. We all know that.
    The problems with bugs and availability scale up exponentially if you are talking
    about multiple independent systems. So, you must be mindful of that. You also
    have to consider what your requirements are. Do you need guaranteed delivery?
    Do you need error recovery? Those two things might be handy, but they come with
    a price. Nothing comes for free, after all. You need to think about those scenarios.
    Usually, you must devise a solution you can get away with and not go overboard
    on error correction schemes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and scalability**: Transferring blocks of memory inside a process
    is pretty quick. Moving data between processes can be really slow or even unimaginably
    slow. Moving a block of bits to another machine over a **Transmission Control
    Protocol** (**TCP**) connection is thousands of times slower than doing that in
    memory. Writing data to a disk, even a speedy SSD, is even slower than that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That means you must ensure optimal IO strategy for those use cases. Setting
    up a connection or creating a file is slow, but you have to do that only once
    for each transfer. Once you have that, you can write the data. If you have lots
    of tiny packets, you might want to bundle them so you only have to initiate it
    once. As we have stated before, it might be a good idea to compress data before
    transmitting. Yes, compression takes CPU cycles, but it might be worth it since
    transferring that data to another system is orders of magnitude slower.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization and deadlocks**: Once your data leaves your system, you no
    longer know what is happening to it. Other processes might also be asking for
    the recipient’s attention, or the recipient might be out of data. You have to
    be very careful to ensure the data is synchronized. Or not. It depends on your
    use case, of course. Also, deadlocks can occur. You might wait for an operation
    to finish on the recipient’s side, but if that one waits for your system, you
    have a problem. Be mindful of those problem areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation and maintainability**: Sharing data with other systems means
    sharing your data structures with other developers. Do not forget that “other
    developers” could be yourself in six months when you look at what you did and
    wonder what you were thinking. Documenting your work, your thoughts, and the structures
    of your data saves you and your peers a lot of headaches further down the road.
    Do yourself a favor and document your data and its structure, what you did to
    satisfy all the constraints, and your assumptions. That makes your code much more
    maintainable. Of course, this applies to data-sharing scenarios and all software
    development, but it is so much more important when you need to share data with
    other systems. Do not skip on this!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform and environment constraints**: You might not always be aware of
    the kind of hardware your data will be shared with. If you do not know this, you
    must consider all available options. Assume the worst and plan for that. For instance,
    if you transmit data packets of a couple of gigabytes, encrypted and wrapped in
    a compression algorithm, you might get complaints that the recipient is a very
    low-end IOT device with limited memory and CPU power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all platforms support all of the strategies I outline in this chapter. For
    instance, Windows Messages, which we discuss next, is only available on Windows.
    The name sort of gives it away, doesn’t it? Be aware of the platform and environment
    constraints and design your data sharing around those.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that you know the considerations to take when choosing a communication
    method, let’s look at what methods we have available. We start with a classic:
    Windows Messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Windows Messages** are the oldest type of IPC in Windows. They may not be
    the best choice when writing systems software, but they can be helpful. More importantly,
    they are extremely fast and lightweight. However, as the name suggests, they are
    a Windows-only feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Messages work with windows. I do not mean the operating system; I am talking
    about the screens on your monitor. Almost everything on the GUI in Windows is
    a window. The windows obviously are, but so are buttons, edit boxes, text boxes,
    sliders, and so on. The operating system communicates with your application by
    sending messages to a window. Your application has at least one main window, which
    then distributes the message to the *subwindows* or handles the messages for those
    subwindows. However, each window can have its own message-handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: Since messages work with graphical screen elements, such as buttons, labels,
    and list boxes, you might think they cannot be used on console applications or
    Windows services. That is technically correct, but we can get around that. We
    can create a hidden window that can receive the messages.
  prefs: []
  type: TYPE_NORMAL
- en: A message is straightforward. It is nothing but a structure containing four
    numeric parameters. This is what the parameters are and what they are used for.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type /** **C# Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `hWnd` | HWND / IntPtr | The unique handle of the window that is to receive
    the message |'
  prefs: []
  type: TYPE_TB
- en: '| `Msg` | UINT / uint | The ID of the message |'
  prefs: []
  type: TYPE_TB
- en: '| `wParam` | WPARAM / IntPtr | An additional parameter, or pointer to a data
    structure |'
  prefs: []
  type: TYPE_TB
- en: '| `lParam` | LPARAM / IntPtr | An additional parameter, or pointer to a data
    structure |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Parameters in a Windows Message'
  prefs: []
  type: TYPE_NORMAL
- en: That is all that a message has. The `wParam` and `lParam` pointers point to
    some memory containing the payload. They can also be just a number if that is
    all you want to send. In 16-bit Windows, `wParam` was 16 bits, and `lParam` was
    32\. In 32-bit versions of Windows, they are both 32-bit long, and in 64-bit versions,
    they are both 64-bit long. So, there is no real difference between `wParam` and
    `lParam` anymore regarding length.
  prefs: []
  type: TYPE_NORMAL
- en: These messages are all communications from the operating system to your application.
    If the user moves the mouse over your window, you get notified. Well, in the case
    of the mouse movement, you get hundreds of notifications. If the user presses
    a key, you get a message. If the user resizes the window, you get another message.
    Anything that happens on the operating system that might be interesting for your
    application is sent to you as a message. There are hundreds, if not thousands,
    of messages sent to your application all the time. Your application is required
    to listen to those messages. We shall see how that works shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The message identifier can be predefined; it can be a number you choose, or
    the operating system can generate it.
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain what I mean by that.
  prefs: []
  type: TYPE_NORMAL
- en: If Windows sends a message, it is one of the predefined ones. For instance,
    if the mouse has moved, you get the `WM_MOUSEMOVE` message. `WM_MOUSEMOVE` is
    a constant with the `0x0200` value. `wParam` contains information about the state
    of the mouse buttons and keys, such as the *Ctrl* key on your keyboard. You can
    decode these flags to see whether a button is pressed while the mouse moves. `lParam`
    contains both the *X* and the *Y* position of the mouse relative to the upper-left
    corner of the window that receives the message (the first half of `lParam` contains
    the *Y* coordinate, and the second half contains the *X* coordinate).
  prefs: []
  type: TYPE_NORMAL
- en: An interesting message is `WM_CLOSE`. This has the `0x0010` value. If a window
    receives that message, the user wants to close it. If that happens on your main
    window, the application ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define your own message. There is a constant called `WM_USER`
    (with a value of `0x0400`). You can freely use any of the values between `WM_USER`
    and `0x7FFF` in your application to define your message. One caveat: you can only
    use them if you send those messages to your application’s other windows. You cannot
    use them to communicate with other applications. The reason is simple: you have
    no idea who uses those values outside your system.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to send messages to other applications, you need to register that
    with Windows. You can call an API to reserve a unique and reserved number as long
    as the computer stays on. If two applications reserve the same message name, they
    get the same ID. This is something you can use to communicate between processes,
    and that is precisely what we will be doing now.
  prefs: []
  type: TYPE_NORMAL
- en: A sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work with messages, we need to use a lot of Win32 APIs. The logic is not
    complex, but this sample requires a lot of setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can break it down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Window` class. It’s just like object-oriented programming: you define a class
    first and then create instances. Windows are just like that.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define the message loop method**: This method gets called as soon as a message
    is available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create the window**: As soon as that happens, the messages start flowing
    in.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WM_CLOSE`, close the application. If you want to handle the message, do so.
    If not, pass it on to the default handler that all apps get.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: The source code on the GitHub repository for this book contains a sample. I
    have not included it here since the sample requires a lot of boilerplate code
    that takes up several pages. I decided to leave it out of this chapter since Windows
    Messages are not used except for certain specialized cases. However, if you are
    interested, just look at the sample code. With the preceding explanation, you
    can follow along just nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how Windows Messages work, we can take the next step and look
    into other means. We begin simple enough: pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with pipes for local IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pipes** originally came from Unix but have also found their way to other
    platforms. A pipe is like a direct connection between two systems. It is very
    lightweight and easy to set up. You can use them to communicate between processes
    on the same machine and between machines across a network. Theoretically, you
    can communicate between Linux and Windows using pipes. I said theoretically because
    since the implementation of the pipes on both platforms is so different, you have
    to jump through many loops to get that working. In fact, the work you must do
    to get it working is so intensive that you might as well use other ways, such
    as sockets, to achieve that same result. That will be much easier to pull off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of pipes: **named pipe** and **anonymous pipe**. The named
    pipe is the simplest of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Named pipes** are a great solution if you want to communicate from one process
    to another on the same machine. Communicating over a network is not complex but
    requires more thought concerning security and access rights.'
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, you can use the `NamedPipeServerStream` and `NamedPipeClientStream`
    classes to get this working.
  prefs: []
  type: TYPE_NORMAL
- en: The code is straightforward. For example, let us look at a server waiting for
    a connection. We also added a client that connects to that server. As soon as
    the connection is established, the server sends a message to the client, which
    will be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Again, I am using my `Dump()` extension method here to colorize the messages
    on the screen quickly.
  prefs: []
  type: TYPE_NORMAL
- en: First, I create an instance of `NamedPipeServerStream`. As a parameter, I give
    it a unique name. If I use a name that is already registered, I get access to
    that other named pipe. The names are unique on your machine but are gone once
    `NamedPipeServerStream` is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we wait for a connection. When a client connects, we create `StreamWriter`,
    give it the named pipe server stream, and write the data to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `AutoFlush` on the writer: we don’t want data hanging around.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar. We create an instance of `NamedPipeClientStream`
    (instead of a server) and give it two parameters. The first is the name of the
    computer on the network (in our case, our own computer as specified by the dot).
    The second parameter is the name of the pipe. Obviously, this should be the same
    as we used for the server stream.
  prefs: []
  type: TYPE_NORMAL
- en: We connect the client to the pipe, create an instance of `StreamReader` with
    that client, and read the data. Lastly, we display the data coming from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Anonymous pipes** work more or less the same way as named pipes do. They
    provide a lightweight way of connecting processes to each other. However, there
    are differences between the named pipes and the anonymous pipes. The following
    table highlights the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Named pipes** | **Anonymous pipes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Identification** | Named. You can find them using the name. | Unnamed.
    You have to know the runtime handle to connect. |'
  prefs: []
  type: TYPE_TB
- en: '| **Communication** | Both local and networked. | Only local. |'
  prefs: []
  type: TYPE_TB
- en: '| **Peers** | Multiple clients per server. Can be set up to handle bidirectional
    conversations. | One-on-one only. Also, one way only |'
  prefs: []
  type: TYPE_TB
- en: '| **Complexity** | More complex. Allows for asynchronous communications, also
    able to do fire-and-forget scenarios. | More simple. Straightforward one-way parent-child
    communication. |'
  prefs: []
  type: TYPE_TB
- en: '| **Security** | Supports ACL to enable secure communications. | No security
    features are available. |'
  prefs: []
  type: TYPE_TB
- en: '| **Speed** | Slower due to more control. | Fast. Almost no overhead. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Comparison of features between named pipes and anonymous pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to set up an anonymous pipe is actually quite simple. Let’s start
    with the server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let me walk you through this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I create an instance of `AnonymousPipeServerStream`. This class handles
    all the setting up of the communication. We can tell that it can either send or
    receive code. We cannot use the supplied `PipeDirection.InOut` enum: that will
    throw an exception. Remember: anonymous pipes are one-way.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to make sure the handle can be inherited as well. This is because the
    client needs to “inherit” this handle. After all, this is the only way we can
    identify the pipe. There is no name; it is anonymous!
  prefs: []
  type: TYPE_NORMAL
- en: We call `GetClientHandleAsString` so we know what to use on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: When you create `AnonymousPipeServerStream`, it automatically creates a client
    as well. This can be handy if you want to communicate inside your process. However,
    if another process needs to talk to this server, you have a problem. Anonymous
    pipes are single-connection only. The call to `DisposeLocalCopyOfClientHandle`
    removes the local client, so we have room for another client.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a stream, give it the pipe, and write to it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `WaitForPipeDrain`, a blocking call that only continues if
    the client has read all the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client is even more simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We read the handle from the console first. This is the output from our server,
    so we have that available. Then, we create the client by creating an instance
    of `AnonymousPipeClientStream`, telling it to be ready for incoming data, and
    giving it the handle.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create `stream` and read from it. That’s it!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one big caveat. Suppose you write these two console applications and
    you run them. In that case, you see that as soon as you try to create an instance
    of that `AnonymousPipeClientStream`, you get an `InvalidHandle` exception. The
    reason is that Windows separates the processes, ensuring security is as high as
    possible. If you run two processes, they cannot reach each other’s handles. So,
    it cannot access the pipe, which means you cannot communicate. I am afraid there
    is nothing we can do about that. If you think about it, it does make sense, though.
    You can only have one-on-one communications. So, if multiple console apps connect
    to the server, how do you ensure this one-on-one behavior? The answer is: you
    cannot.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want separate console apps, you should use named pipes instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you want to use the example I supplied, you can ensure the client
    and the server run in the same address space. You do this by launching the client
    from the server. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to change the client to get the handle from the `args` parameter
    given to the `Main` method instead of getting it from the user through the console.
  prefs: []
  type: TYPE_NORMAL
- en: The secret here is the line where we set `UseShellExecute` to `False`. If it
    is `True`, the client starts in another shell, thus isolating it from the server.
    By setting this to `False`, we prevent that and can access the handle and, consequently,
    the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: If they fit your scenario, anonymous pipes are a great addition to your communications
    toolbelt. They are fast and lightweight, just the sort of thing we love as systems
    programmers. However, there are other ways to communicate that might even be better,
    although they are not as simple. Let’s talk about sockets…
  prefs: []
  type: TYPE_NORMAL
- en: Using sockets to establish network-based IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets are awesome. They are a bit like the Swiss Army knife for communications.
    The downsides of pipes and Windows messages are gone when you move to sockets.
    Of course, nothing comes for free, so be prepared to spend a lot of time thinking
    about error handling and memory management. Still, once you get the idea, sockets
    are not hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sockets** are endpoints of a connection over a network between two systems.
    Of course, the systems can live on the same machine, but they can also be at different
    ends of the world. Thanks to all the hard work people have done building networks
    since the 1960s, we can now reach all sorts of machines worldwide.'
  prefs: []
  type: TYPE_NORMAL
- en: Networking 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer networks have been around for a long time. However, each supplier had
    its own way of making machines talk to one another. Over time, standards emerged.
    As it goes with standards, there were many to choose from. These days, we have
    more or less standardized on setting up a network, so you no longer have to worry
    about that.
  prefs: []
  type: TYPE_NORMAL
- en: But before we dive into the specifics, we need to talk about **Open Systems
    Interconnection** (**OSI**) first.
  prefs: []
  type: TYPE_NORMAL
- en: OSI is a layered architecture where you can describe how a network works. Each
    layer builds on top of the previous one (with the apparent exception of the first
    layer).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are seven layers, and this is what they describe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level 1 – Physical**: This is what describes the hardware. For example, what
    a cable looks like, how the switches are working, the electrical voltages that
    are applied, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 2 – Data Link**: This describes how systems connect over the physical
    layers. Here, we describe how ethernet or Wi-Fi works. The MAC addresses (unique
    number per network device) are defined here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 3 – Network**: This one is all about routing and addressing. There
    are several protocols defined on level 3, such as **Internet Control Message Protocol**
    (**ICMP**), which is used for network diagnostics and error reporting, **Address
    Resolution Protocol** (**ARP**), used for address resolution, Bluetooth, and,
    of course, **Internet Protocol** (**IP**), both v4 and v6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 4 – Transport**: This layer is responsible for end-to-end communication
    and reliability. TCP and **User Datagram Protocol** (**UDP**), the topics of this
    chapter, live in this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 5 – Session**: this manages the sessions between applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 6 – Presentation**: This layer ensures the data is presented in a format
    other systems can understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 7 – Application**: here are the applications that use the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hardware and the operating system handle levels 1 through 4\. Levels 5 through
    7 are ours to take care of.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all systems use TCP as a transport layer, but sometimes people choose
    UDP. I start by explaining TCP and how to use it, and I move to UDP at the end
    of this part. IP is more or less a given. We could choose other network-level
    protocols, but that would make life unnecessarily complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the session (level 5) is where we write the code to set up the connection
    on the client or server. The presentation, level 6, is about how we package the
    data: how we serialize, what encoding to use, and so on. We have covered that
    already extensively. Level 7 is just our app; I leave that one to you.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s write some level 5 code!
  prefs: []
  type: TYPE_NORMAL
- en: A TCP-based chat app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The “hello-world” application for networking is a chat app. That sort of app
    allows us to investigate how systems can connect and exchange data without dealing
    with technicalities about what kind of data is passed between them. The type of
    data is part of the application, which we learned is level 7 in the OSI model.
    We do not care about that here. Level 6 is presentation, but for a simple chat
    application, we can get away with something straightforward: we take a string
    and encode that in UTF8 bytes (and back again, of course). Since the OS takes
    care of levels 1 up to 3, we only have to deal with 4 and 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: I want to use TCP here, which is an excellent protocol that gives us reliability
    and guarantees the order in which the data arrives. It is also effortless to set
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since so much is happening, I decided to use line numbers here. That makes it
    a bit easier to refer to what I am explaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line 7, we create a new instance of the `TcpListener` class. This class
    handles all the details about communications, but it needs some information from
    us about that. We give the constructor two parameters that tell it all it needs
    to know. The first is the address we use. The address is the unique identifier
    for a network adapter, such as your ethernet or Wi-Fi adapter. This IP address
    is part of level 3, the network level of the OSI model. It is part of the IP specifications.
    However, multiple applications can simultaneously use a network adapter in a computer.
    We can specify a port number to ensure all the applications get the data they
    need and send it to the correct application on the other end of the line. This
    more or less arbitrary number decides what application connected to that IP address
    gets the data. This port number is part of level 4 of the OSI model. I said the
    number is more or less arbitrary. Technically, you can choose whatever number
    you desire, but there are conventions about these numbers. Since the port decides
    what application gets or sends the data, standards help ensure we all use the
    same ports for the same applications. Web servers, for instance, listen to port
    `80` unless they use the secure HTTPS protocol. That one uses port `443`. There
    are a lot of “reserved” numbers, but technically, nothing stops you from using
    port `80` for your chat application. I would not recommend doing so, though: it
    confuses other people.'
  prefs: []
  type: TYPE_NORMAL
- en: I want to ensure our chat server listens on port `8080`, a “free to use” number.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have used the word “listening” a few times here. Listening means that the
    application waits for another process, either on our machine or on an external
    one, to connect. Compare it to waiting for the phone to ring: you are listening
    for your ringtone and ready to pick it up if it goes.'
  prefs: []
  type: TYPE_NORMAL
- en: Since your machine can have multiple network adapters, you must specify which
    one you want to listen to. In this case, I chose a fixed IP address, `IPAddress.Loopback`,
    which translates to the `127.0.0.1` IPv4 address. This address is the local machine,
    not attached to any actual adapter. In other words, we only listen to connections
    from the same physical machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 8 is straightforward: we start the server. With the call to `AcceptTcpClienAsync`
    in line 14, we tell the server to accept any incoming connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple clients can connect to the same server at the same time. The client
    here is what represents the connected client. We only expect one client, so we
    do not have to deal with sessions. Remember: session management is level 5 of
    the OSI model. We assume one and only one client, and we store that in the variable
    client. The type of client is `TcpClient`, in case you were wondering.'
  prefs: []
  type: TYPE_NORMAL
- en: This call is blocking, and only continues when a client is connected, something
    we tell the user with the message on line 15.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we have established a connection, we open a stream to access the
    client’s data or to enable us to send data to that client. This stream, of the
    `NetworkStream` type, is bidirectional. We store that stream in the variable stream
    in line 17.
  prefs: []
  type: TYPE_NORMAL
- en: Data comes in binary. Therefore, we use `ReadAsync` to read a buffer of data.
    I assume that no incoming data exceeds 1,024 bytes. You probably cannot make that
    assumption in a real-world application, so you must keep reading until you have
    all the data. Here, we store that data in a byte array of 1,024 bytes long (lines
    20 and 21) and convert that to a UTF8 string (lines 22). This is how our data
    is presented, which is level 6 of the OSI model. As soon as we have that string,
    we display it. If the string is “bye” we take it that the client wants to disconnect.
    Otherwise, we allow the user on the server end to enter a response and send that
    string to the client after converting it to another byte array. We use the same
    stream here.
  prefs: []
  type: TYPE_NORMAL
- en: If the stream contains no more data or someone uses the word “bye” in the conversation,
    we close the connection (line 37) and stop listening (line 38).
  prefs: []
  type: TYPE_NORMAL
- en: 'The client is very similar in code. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In line 6, we create a new instance of the `TcpClient` class. Again, we have
    to give it an IP address and a port. This time, we have to use an actual number.
    We use `127.0.0.1`, so we are looking for a server on the same machine. The port
    is again `8080`; otherwise, our server never sees any connection coming in.
  prefs: []
  type: TYPE_NORMAL
- en: This call is again blocking, so it will not continue until a connection has
    been made. We can access the stream once we have a connection, as in line 8\.
    This stream is, once again, of the `NetworkStream` type, so we have a bidirectional
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: We do the same thing as we did for the server. We assume a message size of 1,024
    bytes or less. We convert strings to and from byte arrays using UTF8 as encoding.
    We use the word “bye” to signal a desire to stop talking, and we use `client.Close()`
    to finalize the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the code is very similar to the server’s. We simplified many
    things here: we do not consider having multiple clients connecting to one server.
    We make many assumptions about the message size and have to fall back or retry
    mechanisms in case things go wrong. When working with connections across machines,
    things go wrong often, so you must be aware of that and code accordingly. However,
    since that has nothing to do with the actual networking code, as I have shown
    you here, I can safely leave that to you to figure out.'
  prefs: []
  type: TYPE_NORMAL
- en: UDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP is a great protocol, but it is not the only one. **UDP** is more straightforward
    and lighter. Of course, that comes with disadvantages as well. I outline the differences
    between the two protocols in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Consideration** | **TCP** | **UDP** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Main objective | Reliability | Speed |'
  prefs: []
  type: TYPE_TB
- en: '| Ordering | Order guaranteed | No guarantee about the order of messages |'
  prefs: []
  type: TYPE_TB
- en: '| Handshaking | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Error Checking | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Congestion control | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Use case | Web browsing, chatting, file transfer, email | Video streaming,
    online gaming, VOIP |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: TCP and UDP compared'
  prefs: []
  type: TYPE_NORMAL
- en: TCP is reliable. Message almost always arrives. When things go wrong, TCP tries
    to resend the data until it has been delivered. UDP doesn’t care about that. It
    just tries to get the data out there as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP ensures that messages arrive in the same order as they have been sent.
    UDP, however, does not: messages could arrive at the destination in a different
    order than how they left the origin.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP makes sure the other end is ready to communicate. UDP just starts sending
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP checks the data to see whether errors have occurred during transmission
    and can even fix some. UDP does not care: as long as the data is sent, it is happy
    with it.'
  prefs: []
  type: TYPE_NORMAL
- en: If the network gets congested, TCP can slow down transmission to help alleviate
    that. UDP dumps data as fast as possible, regardless of network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP is best used when you must have a reliable, error-free way of transmitting
    data. For instance, with chat, the message must come across as intended, in the
    correct order. UDP, however, is all about speed. Video streaming comes to mind:
    if part of the data stream is lost sometimes, it is not a big deal. Slow streams,
    however, are killing the experience.'
  prefs: []
  type: TYPE_NORMAL
- en: UDP is not often used, but it can be a valuable tool in your belt.
  prefs: []
  type: TYPE_NORMAL
- en: Using shared memory to exchange data between processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been sending messages to other processes on the same computer.
    With named pipes and sockets, we could have used other machines as well. That’s
    the beauty of those protocols: they are network agnostic. However, if you are
    sure you want to stay on the same machine, using pipes or sockets can be a burden.
    These methods are not the fastest way to communicate. In those cases, you might
    be better off using **shared memory**.'
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory is effortless to set up. And yes, of course, that comes with downsides.
    There is almost no way to secure the data or to prevent collisions. However, it
    is fast; really, really fast. So, let’s look at a sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we look at how to write data to shared memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Shared memory is like having a file that only exists in memory. It’s a block
    reserved in memory. It has a name you can use to identify it. Again, it is just
    like a file. Here, we create a new instance of the `MemoryMappedFile` class, giving
    it a name and a size. (in our case, 1,024 bytes). If you want to use that file,
    you must get `MemoryMappedViewAccessor`. You can get that by calling `CreateViewAccessor`
    on the `MemoryMappedFile` instance.
  prefs: []
  type: TYPE_NORMAL
- en: You can then read and write data to and from that accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading from that shared file is just as easy. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use almost the same code as the writer. However, instead of creating a new
    file in memory, we open an existing one. We do not have to specify the size but
    must know the name.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have that file, we can use the same code to get an accessor. With that,
    we can read the data and display it. Simple, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is a speedy way to share data between processes on the same machine.
    However, the downsides are something to be aware of. For instance, any process
    that knows the name of the shared memory block can access it. There is no security
    whatsoever. Of course, you can circumvent that by using encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Another downside is that there is no built-in mechanism to notify processes
    of new or changed data. You have to use things such as semaphores and mutexes
    to do that. You can set up `FileSystemWatcher` with actual files to get notified,
    but that is not available for these shared files in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential downside is that it is Windows only. That might limit your
    options for deployment later on.
  prefs: []
  type: TYPE_NORMAL
- en: But all in all, shared memory is a great way to quickly share large amounts
    of data across processes on the same Windows machine. Use it to your advantage!
  prefs: []
  type: TYPE_NORMAL
- en: Overview of RPCs and how to use them for IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at ways we can share data. In most cases, developers
    use this to do just data: send a payload from one system to another. However,
    the payload can also be something else. They can be commands to instruct a piece
    of software to do something. Instead of storing, transforming, and using data
    in systems, we can tell other systems to perform actions. In that case, we talk
    about RPC.'
  prefs: []
  type: TYPE_NORMAL
- en: To control a system from the outside, establish a communication line, ensure
    your security is in order, and define a protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to do this. In the old days, we used to have SOAP, DCOM,
    WCF, and other techniques to do so.
  prefs: []
  type: TYPE_NORMAL
- en: RESTFul services versus RPC
  prefs: []
  type: TYPE_NORMAL
- en: You could consider RESTFul services to be some kind of RPC. However, they are
    not the same, and I do not want to go into RESTful services here. There are many
    similarities, but the basic idea behind RESTful services is that they are all
    about resources. Calls to web services are usually used to retrieve data from
    a server. Technically, you could set up RESTful services to accept commands only,
    in which way they are RPC. It’s like calling a calzone a pizza. Technically, that
    is correct, but there are enough differences in practice to warrant a different
    approach. Therefore, I have decided not to include RESTful services in this book.
    If you choose to use RESTful services to communicate with your system, by all
    means, be my guest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, it’s all very simple. You think of a way to structure and send commands
    over the line. This works fine as long as both parties understand what is going
    on. Of course, you don’t have to reinvent the wheel: several well-established
    standards exist to do this. Later in this chapter, I show you how to do this with
    gRPC. However, as with all standards, they come with a cost. Sometimes, you do
    not need the additional complexity an established framework gives you. Sometimes,
    you just want to send a simple command to a system. Suppose your scenario allows
    for a less secure and unknown protocol. In that case, you can improve your speed
    and memory by having your own protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON RPC is one of the most used ways to do this yourself. Let’s have a look.
  prefs: []
  type: TYPE_NORMAL
- en: JSON RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON RPC is just encapsulating your commands in a JSON structure, sending them
    off over the wire, intercepting them at the other end, and doing whatever the
    command tells the system to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with defining a command we want to send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I want the client to inform the server that it needs to print the current date.
    I might want to include the current time as well. So, this is the command we created:
    `ShowDateCommand` with the `IncludeTime` field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my sample, I have put the client and the server in the same application,
    each running on a different task. I did that for the sake of simplicity. Of course,
    if you want to send commands to a different part of the same application, RPC
    is overkill. It’s not even correct: it’s not remote at all. However, for this
    demo, it works just fine.'
  prefs: []
  type: TYPE_NORMAL
- en: For communications, I have chosen a named pipe. It’s easy to set up and could
    be used to send messages across the network. Besides those considerations, I had
    no real reason to choose this option, so you can do whatever you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server part looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The class, called `Server`, has one method named `StartServer`. It creates
    an instance of `NamePipeServerStream` with the `CommandsPipe` name. Then, it waits
    for a client to connect. As soon as that happens, we read the data coming in.
    As soon as we get a string, we deserialize it to the correct format and perform
    the task it is told to perform: it prints out the current date and optionally
    includes the time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The client creates an instance of `ShowDateCommand` and sets `IncludeTime` to
    `true`. Then, it creates `NamedPipeClientStream` with the correct name and connects
    to the server. Finally, it sends the JSON over the wire. That’s all there is to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, I give you the code that initializes both the server and
    the client in the `Main` method of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I create instances of `Server` and `Client`, starting them in `Task.Run()` and
    wait for the user to press a key. In the background, `Server` and `Client` do
    their thing, telling you all about it with the calls to `Dump()`. Please pay attention
    to the thread IDs in `Dump` – they can be pretty informative for learning about
    threading (or refreshing your memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is simple and very fast. However, it only works if you know
    both ends of the equation: the server and the client must follow your proprietary
    protocol. If that is not the case, you are better off using a standard. One of
    those standards is gRPC. Let’s look at that next.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of gRPC and how to use it for IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the leading ways to establish a straightforward way of communication
    between processes these days is gRPC. The acronym **gRPC** stands for either **Google
    remote procedure call** or the recursive name gRPC remote procedure call. You
    can pick whichever you like. Google developed it as a public version and improvement
    of their internal framework, Stubby.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC uses **Protocol Buffers** (**Protobufs**). This is a format that describes
    the available commands, the messages, and the parameters you can pass. Protobufs
    are compiled into a binary form, resulting in faster data transfers. The system
    is built on HTTP/2, so we can use multiplexing (multiple requests over the same
    TCP connection). HTTP/2 has many more advantages over the older HTTP/1.x, most
    of which involve efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-language and platform support was also one of the leading drivers. So,
    you can be sure gRPC can be used on many devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to rebuild our example of a system that can be remotely instructed
    to display the current date (with or without time). In that case, we first have
    to define the message structure. However, before we do that, we need to add a
    couple of NuGet packages to our server application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Google.Protobuf` | Handles the proto files |'
  prefs: []
  type: TYPE_TB
- en: '| `Grpc.Core` | The core implementation of gRPC |'
  prefs: []
  type: TYPE_TB
- en: '| `Grpc.Tools` | Contains, amongst others, the compiler for proto files |'
  prefs: []
  type: TYPE_TB
- en: '| `Grpc.AspNetCore` | Needed to host the server in our application |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: NuGet packages for our gRPC server'
  prefs: []
  type: TYPE_NORMAL
- en: In a C# console application, add a new file called `displayer.proto`. This is
    just a text file. I like to put them in a separate folder, which I call `Protos`.
    The compiler takes this file and creates a lot of C# for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s dissect this.
  prefs: []
  type: TYPE_NORMAL
- en: First, we tell the system what format this is. We use `proto3`, which is the
    latest and recommended version.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we tell the system what namespace to put them in when it generates the
    C# files. As you can imagine, this option is C# only. It is a helper option that
    helps us keep our code organized.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the service. We have one service called `TimeDisplayer`. It
    has one RPC method called `DisplayTime`. It takes `DisplayTimeRequest` as a parameter
    and returns something of the `DisplayTimeReply` type.
  prefs: []
  type: TYPE_NORMAL
- en: '`DisplayTimeRequest` and `DisplayTimeReply` types are defined below that. They
    are messages, and they can contain parameters. I added a name to show you how
    to add a string. For the request, I also added a bool, indicating whether we want
    to show the time.'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters need to be ordered and numbered. This way, if somehow the message
    gets scrambled, both systems still know what the data looked like initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio usually knows how to handle this if you add a `.proto` file to
    your application. However, if this doesn’t happen (and I have seen it go wrong
    occasionally), you must instruct the compiler on how to handle this file. In your
    `csproj` file, just add the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That should be enough to get the compiler on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build the server!
  prefs: []
  type: TYPE_NORMAL
- en: 'I have added the code for the server in my console application. Since the compiler
    takes our `.proto` file and compiles all the necessary code for us, we can use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our `TimeDisplayerService` class is derived from the `TimeDisplayer.TimeDisplayerBase`
    base class. This base class is generated out of our `.proto` file. As you can
    see, the `TimeDisplayer` name matches what we have in that `.``proto` file.
  prefs: []
  type: TYPE_NORMAL
- en: We have one method here, called `DisplayTime`. Again, this matches what we have
    in our `.proto` file. The code is pretty simple; it just takes an instance of
    `DisplayTimeRequest`, looks at the `WantsTime` parameter, and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, gRPC servers run on some sort of webserver, and adding this code to
    an ASP.NET application is straightforward. But, of course, you can run it anywhere
    you want, which is something we, as systems programmers, really can use. So, if
    you’re going to run this code in a console application, you can set that up as
    follows. In the primary method of your program, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We create a new instance of the `Server` class. This comes from the `gRPC.Core`
    NuGet package we installed. We give it the services we want to use (in our case,
    `TimeDisplayerService`) and define the network address and port we decide to use.
    I do not care about credentials here, but you can use SSL, TLS, and other ways
    of security.
  prefs: []
  type: TYPE_NORMAL
- en: We start the server and wait for the user to press any key. Then, we stop the
    server again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up next: the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we need to add some NuGet packages to our console application. These
    are the ones you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Google.Protobuf` | Handles the proto files |'
  prefs: []
  type: TYPE_TB
- en: '| `Grpc.Net.Client` | The client implementation for gRPC |'
  prefs: []
  type: TYPE_TB
- en: '| `Grpc.Tools` | Contains, amongst others, the compiler for proto files |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.5: NuGet packages for our gRPC client'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a `.prot`o file. To be more precise, we need the same `.proto`
    file we used on the server. So, it is best to link to that file instead of recreating
    it. However, if you like typing, be my guest and create a new one. Just make sure
    these files remain in sync when you make changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not need a specific client class; we only have to add the following code
    to our `Main` method in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We start with a wait for the user to press a key. Since I start the server and
    the client simultaneously in my solution, I might get timing issues if the client
    is slightly faster than the server in setting up the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `GrpcChannel.ForAddress()` with the correct parameters to set
    up the connection. With that connection, we call the `DisplayTimeAsync` method
    with a correct `DisplayTimeRequest` setup. The result should come back and show
    you what the server did.
  prefs: []
  type: TYPE_NORMAL
- en: That is all there is to it! We now have a fully functional server and client
    application, talking to one another over gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between JSON RPC and gRPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw, setting up a gRPC server and client is not too complicated. But
    still, it adds a bit of complexity to your code. If you do not need the advantages
    of gRPC, you can use JSON RPC instead. But when do you pick which one?
  prefs: []
  type: TYPE_NORMAL
- en: If your messages get big, gRPC is the far better choice. Remember when I said
    IO takes a long time? Well, JSON files are usually much bigger than their binary
    equivalent. gRPC uses that smaller binary format, so data transmission is much
    faster when using that.
  prefs: []
  type: TYPE_NORMAL
- en: However, JSON is more readable, more debuggable, and easier to interpret for
    humans. The code is also easier to set up. The `.proto` files are something you
    have to get used to. Next to that, the compiler needs to transform the `.proto`
    files into C# classes, and they make your system more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, it depends on your scenario. However, for easy reference, I have
    outlined the differences between JSON RPC and gRPC in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **gRPC** | **RPC** **with JSON** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Serialization format** | Protobufs (binary format) | JSON (text format)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Performance** | Generally higher due to binary serialization, initial setup
    and connection might be slower | Lower than binary formats but quicker to set
    up (depending on the communication setup) |'
  prefs: []
  type: TYPE_TB
- en: '| **Protocol** | HTTP/2 | Typically HTTP/1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Streaming** | Supports bidirectional streaming | Limited support, usually
    request-response only |'
  prefs: []
  type: TYPE_TB
- en: '| **Type safety** | Strongly-typed contracts (Protobuf) | Loosely typed, prone
    to runtime errors |'
  prefs: []
  type: TYPE_TB
- en: '| **Language** **interoperability** | High (supports many languages natively)
    | High (JSON is universally supported) |'
  prefs: []
  type: TYPE_TB
- en: '| **Network efficiency** | More efficient (smaller payload, HTTP/2 features)
    | Less efficient (larger payload, HTTP/1.1) |'
  prefs: []
  type: TYPE_TB
- en: '| **Error handling** | Rich error handling with explicit error codes | Typically
    relies on HTTP status codes |'
  prefs: []
  type: TYPE_TB
- en: '| **Deadline/timeouts** | Native support for specifying call deadlines | Usually
    managed at the application level |'
  prefs: []
  type: TYPE_TB
- en: '| **Security** | Supports various authentication mechanisms | Varies, usually
    added at the application layer |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.6: Differences between gRPC and JSON RPC'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, although gRPC and RPC with JSON share many features, each has
    their own use case. Pick whichever works best for your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Everybody needs somebody*. That truth has even been the title of a song. The
    same goes for systems, especially those not meant to be used by humans. They need
    something to tell them what to do and what data to do it with. They need to communicate
    with each other. You have now seen the many ways you can use to set up communications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have looked at Windows Messages, the old-school communication style (although
    Windows still uses it for internal communications). We have looked at both named
    and anonymous pipes. Then, we looked at the most used way for computers to talk
    to one another: sockets. While at it, we investigated the OSI model a bit to understand
    where we need to write code and where we can leave that to others.'
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at a speedy way to share data on the same machine using shared
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we investigated how we can issue commands by using JSON RPC and gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should be ready to take the next step. After all, besides talking to
    our code, we can use the operating system to help us. Windows offers many services
    we might need or can use to our advantage, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
