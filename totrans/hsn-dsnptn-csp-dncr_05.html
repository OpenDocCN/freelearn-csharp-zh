<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Design Patterns - Basics Part 1</h1>
                
            
            
                
<p>In the previous two chapters, we introduced and defined a wide range of modern patterns and practices pertaining to the <strong>software development life cycle</strong> (<strong>SDLC</strong>), from lower-level development patterns to high-level solution architectural patterns. This chapter applies some of those patterns in a sample scenario in order to provide context and further understanding of the definitions. The scenario is the creation of a solution to manage the inventory of an e-commerce bookseller.</p>
<p>The scenario was chosen as it provides enough complexity to illustrate the patterns while the concept is relatively simple. The company needs a way of managing their inventory, including allowing users to order their products. The organization needs to get an application in place, as soon as possible, to allow them to track their inventory, but there are many additional features, including allowing customers to order products and provide reviews. As the scenario plays out, the number of features requested grows to the point where the development team does not know where to start. Fortunately, by applying some good practices to help manage the expectations and requirements, the development team is able to simplify their initial delivery and get back on track. Also, by using patterns, they are able to build a solid foundation in order to help the expansion of the solution as new features are added. </p>
<p>This chapter will cover the kickoff of a new project and the creation of the first release of the application. The following patterns are illustrated in this chapter:</p>
<ul>
<li><strong>Minimal Viable Product</strong> (<strong>MVP</strong>) </li>
<li><strong>Test-driven development</strong> (<strong>TDD</strong>)</li>
<li>Abstract Factory pattern (Gang of Four)</li>
<li>SOLID principles</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter contains various code examples to explain the concepts. The code is kept simple and is just for demonstration purposes. Most of the examples involve a .NET Core console application written in C#.</p>
<p>To run and execute the code, you need the following:</p>
<ul>
<li>Visual Studio 2019 (you can also run the application using Visual Studio 2017 version 3 or later)</li>
<li>.NET Core</li>
<li>SQL Server (Express Edition is used in this chapter)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Visual Studio</h1>
                
            
            
                
<p>To run these code examples, you need to install Visual Studio or you can use your preferred IDE. To do this, follow these instructions:</p>
<ol>
<li>Download Visual Studio from the following link: <a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.</li>
<li>Follow the installation instructions included. Multiple versions are available for Visual Studio installation. In this chapter, we are using Visual Studio for Windows.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up .NET Core</h1>
                
            
            
                
<p class="mce-root">If you do not have .NET Core installed, you need to follow these instructions:</p>
<ol>
<li class="mce-root">Download .NET Core from the following link: <a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.</li>
<li>Follow the installation instructions and related library: <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.</li>
</ol>
<p>The complete source code is available in GitHub. The source code shown in the chapter might not be complete, so it is advisable to retrieve the source in order to run the examples: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3</a>.<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Minimum Viable Product</h1>
                
            
            
                
<p>This section covers the initial phase of starting a new project to build a software application. This is sometimes referred to as a project kickoff or project launch, where the initial features and capabilities of the application are collected (in other words, requirement gathering).</p>
<p>Many approaches, which can be viewed as patterns, exist for the determining the features of a software application. Best practices around how to effectively model, conduct interviews and workshops, brainstorm and other techniques are outside the scope of this book. Instead, one approach, Minimum Viable Product, is described to provide an example of what these patterns might contain.</p>
<p>The project is for a hypothetical situation where a company, FlixOne, wants to use an inventory management application to manage its growing collection of books. This new application will be used both by the staff to manage the inventory, and by customers to browse and create new orders. The application will need to be scalable, and, as an essential system to the business, it is planned to be used for a foreseeable future.</p>
<p>The company is broadly broken down into <em>business users</em> and the <em>development team,</em> where business users are primarily concerned with the functionality of the system and the development team is concerned about satisfying the requirements, as well as keeping a tab on the maintainability of the system. This is a simplification; however, organizations are not necessarily so tidily organized, and individuals might not fit correctly into one classification or another. For example, a <strong>Business Analyst</strong> (<strong>BA</strong>) or <strong>Subject Matter Expert</strong> (<strong>SME</strong>) often represent both a business user and a member of the development team.</p>
<p>As this is a technical book, we will mostly view the scenario from the development team's perspective and discuss the patterns and practices used to implement the inventory management application. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Requirements</h1>
                
            
            
                
<p>Over the course of several meetings, the business and the development teams discussed the requirements of the new inventory management system. Progress toward defining a clear set of requirements was slow and the vision of the final product was not clear. The development team decided to pare down the enormous list of requirements to enough functionality that a key individual could start to record some inventory information. This would allow for simple inventory management and provide a basis that the business could extend upon. Each new set of requirements could then be added to the initial release.</p>
<p class="mce-root"/>
<p>Minimum Viable Product (MVP)<br/>A Minimum Viable Product is the smallest set of features of an application that can still be released and have enough value for a user base.</p>
<p>An advantage of the MVP approach is it gives the business and development teams a simplified vision of what needs to be delivered by narrowing the scope of an application. By reducing the features that will be delivered, the effort in determining what needs to be done becomes more focused. In the FlixOne scenario, a meeting's value would often degrade into discussing the particulars of a feature that, although important for the final version of the product, would require several features to be released before it. For example, the design around a customer-facing website was distracting the team from focusing on the data to be stored in the inventory management system.</p>
<p>MVP is very useful in situations where the complexity of requirements is not fully understood and/or the final vision is not well defined. It is important though to still maintain a product vision to avoid the risk of developing functionality that may not be required in the final version of the application.</p>
<p>The business and development teams were able to define the following functional requirements for the initial inventory management application:</p>
<ul>
<li>The application should be a console application:
<ul>
<li>It should print a welcome message that includes the version of the assembly.</li>
<li>It should loop until a quit command is given.</li>
<li>If a given command is not successful or not understood, then it should print a helpful message.</li>
</ul>
</li>
<li>The application should respond to simple case-insensitive text commands.</li>
<li>Each command should have a short form, of a single character, and a long form.</li>
<li>If a command has additional parameters:
<ul>
<li>Each one should be entered in sequence and submitted with the return key.</li>
<li>Each one should have a prompt <kbd>Enter {parameter}:</kbd> where <kbd>{parameter}</kbd> is the name of the parameter.</li>
</ul>
</li>
<li>A help command (<kbd>?</kbd>) should be available:
<ul>
<li>Prints a summary of the commands available.</li>
<li>Prints example usage of each command.</li>
</ul>
</li>
<li>A quit command (<kbd>q</kbd>, <kbd>quit</kbd>) should be available:
<ul>
<li>Prints a farewell message</li>
<li>Ends the application</li>
</ul>
</li>
<li>An add inventory command (<kbd>"a"</kbd>, <kbd>"addinventory"</kbd>) should be available:
<ul>
<li>The <kbd>name</kbd> parameter of type string.</li>
<li>It should add an entry into the database with the given name and a 0 quantity.</li>
</ul>
</li>
<li>An update quantity command (<kbd>"u"</kbd>, <kbd>"updatequantity"</kbd>) should be available :
<ul>
<li>The <kbd>name</kbd> parameter of type string.</li>
<li>The <kbd>quantity</kbd> parameter of a positive or negative integer.</li>
<li>It should update the quantity value of the book with the given name by adding the given quantity.</li>
</ul>
</li>
<li>A get inventory command (<kbd>"g"</kbd>, <kbd>"getinventory"</kbd>) should be available:
<ul>
<li>Returns all the books and their quantities in the database.</li>
</ul>
</li>
</ul>
<p>And the following non-functional requirements were defined:</p>
<ul>
<li>No security is required other than what was supplied by the operating system.</li>
<li>The short form of a command is for usability while the long form of a command is for readability.</li>
</ul>
<p class="mce-root">The FlixOne example is an illustration of how MVP could be used to help focus and streamline the SDLC. It is worth emphasizing that the difference between a <strong>Proof of Concept</strong> (<strong>PoC</strong>) and an MVP will differ with each organization. In this book, a PoC is different from MVP in that the resulting application is not viewed as disposable or incomplete. For a commercial product, this would mean the end product could be sold, and for an internal enterprise solution, the application could add value to the organization. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How does MVP fit with future development?</h1>
                
            
            
                
<p>Another benefit to using MVP to focus and contain requirements is its synergy with Agile software development. Breaking development cycles into smaller cycles of development is a software development technique that has gained popularity over traditional Waterfall development. The driving concept is that requirements and solutions evolve during the life cycle of an application and involve a collaboration between the development team and the end users. Typically, the agile software development framework has a short release cycle where new functionality is designed, developed, tested, and released. Release cycles are then repeated as the application includes additional functionality. MVP fits well within agile development when the scope of work fits within a release cycle.</p>
<p class="mce-root"/>
<p>Scrum and Kanban are popular software development frameworks based on agile software development.</p>
<p>The scope of the initial MVP requirements was kept to a size that could be designed, developed, tested, and released with an agile cycle. In the next cycle, additional requirements will be added to the application. The challenge is to limit the scope of new functionality to what can be accomplished within a cycle. Each new release of functionality is limited to essential requirements or to its MVP. The principle here is that, by using an iterative approach to software development, the final version of the application will have a greater benefit to the end user than by using a single release that requires all requirements to be defined up front.</p>
<p>The following diagram sums up the difference between Agile and Waterfall software development methods: </p>
<div><img class="alignnone size-full wp-image-155 image-border" src="img/e56ad7fa-bc0c-4584-83f4-976b9a32daf3.png" style=""/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Test-driven development</h1>
                
            
            
                
<p>Different approaches to <strong>test-driven development</strong> (<strong>TDD</strong>) exist, and a <em>test</em> can vary from a unit test that is run on demand during development, to a unit test that is run during the build of a project, to a test script that will be run as a part of <strong>user acceptance testing</strong> (<strong>UAT</strong>). Similarly, a <em>test</em> can be code or a document describing the steps to be performed by a user in order to verify a requirement. A reason for this is that there are different views as to what TDD is trying to achieve. TDD for some teams is a technique to refine requirements before writing code, while others view TDD as a way of measuring or validating the code that is delivered. </p>
<p>UAT<br/>
UAT is a term used for the activity during the SDLC where the product or project is verified to fulfill specified requirements. This is typically performed by members of the business or a selection of customers. Depending on the circumstances, this phase can be broken further into alpha and beta stages where alpha testing is performed by the development team and beta by the end users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why did the team choose TDD?</h1>
                
            
            
                
<p>The development team decided to use TDD for several reasons. First, the team wanted a way to clearly measure progress during the development process. Second, they wanted to be able to reuse the tests in subsequent development cycles in order to continue to validate existing functionality while new functionality is added. For these reasons, the team will use unit tests to verify that the functionality written satisfies the given requirements of the team.</p>
<p>The following diagram illustrates the basics of TDD:</p>
<div><img class="alignnone size-full wp-image-156 image-border" src="img/4bfd18c6-4755-4bbf-8cf1-e0caff120847.png" style=""/></div>
<p>Tests are added and the code base is updated until all the defined tests pass. It is important to note that this is repeated. In each iteration, new tests are added and the tests are not considered passed until all tests, new and existing, pass.</p>
<p>The FlixOne development team decided to incorporate both unit tests and UAT into a single agile cycle. At the beginning of each cycle, new acceptance criteria would be determined. This would include the functionality to be delivered, as well as how it would be verified or accepted at the end of the development cycle. These acceptance criteria would then be used to add tests to the project. The development team would then build the solution until the new and existing tests passed, and then prepare a build for acceptance testing. Then, the acceptance testing would be run, and if any issues were detected, the development team would define new tests or amend existing tests based on the failures. The application would be developed again until all tests passed and a new build would be prepared. This would be repeated until acceptance testing passed. Then, the application would be deployed and a new development cycle would begin.</p>
<p>The following diagram illustrates this approach:</p>
<div><img class="alignnone size-full wp-image-157 image-border" src="img/9798b545-4ea5-418d-91d5-5963745c9089.png" style=""/></div>
<p>The team now has a plan, so let's start coding!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the projects</h1>
                
            
            
                
<p>In this scenario, we will use the <strong>Microsoft Unit Test</strong> (<strong>MSTest</strong>) framework. This section provides some instructions to create the initial project using the .NET Core <strong>command-line interface</strong> (<strong>CLI</strong>) tools. These steps could have been completed using an <strong>integrated development environment</strong> (<strong>IDE</strong>) such as Visual Studio or Visual Studio Code. The instructions are supplied here to illustrate how the CLI can be used to complement the IDE.</p>
<p class="mce-root"/>
<p>CLI<br/>
.NET Core CLI tools are cross-platform utilities for developing .NET applications and are the basis for more sophisticated tooling, such as IDEs. Please see the documentation for more information: <a href="https://docs.microsoft.com/en-us/dotnet/core/tools">https://docs.microsoft.com/en-us/dotnet/core/tools</a>.</p>
<p>The solution for this chapter will consist of three projects: a console application, a class library, and a test project. Let's create the solution directory, FlixOne, to contain the solution and sub-directories for the three projects. Within the created directory, the following command will create a new solution file:</p>
<pre><strong>dotnet new sln</strong></pre>
<p>The following screenshot illustrates creating the directory and solution (note: only an empty solution file has been created so far):</p>
<div><img class="alignnone size-full wp-image-158 image-border" src="img/c5472945-a2fe-4251-8d8a-7a9c1dd8b2c9.png" style=""/></div>
<p>The class library, <kbd>FlixOne.InventoryManagement</kbd>, will contain our business entities and logic. In later chapters, we will split these into separate libraries but, as our application is still small, they are contained in a single assembly. The <kbd>dotnet</kbd> core CLI command to create the project is shown here:</p>
<pre><strong>dotnet new classlib --name FlixOne.InventoryManagement</strong></pre>
<p>Note, in the following screenshot, that a new directory is created containing the new class library project file:</p>
<div><img class="alignnone size-full wp-image-159 image-border" src="img/7206ccd0-c6be-432b-bd5c-799896c79687.png" style=""/></div>
<p>References should be made from the solution to the new class library with the following command:</p>
<pre><strong>dotnet sln add .\FlixOne.InventoryManagement\FlixOne.InventoryManagement.csproj</strong></pre>
<p>To create a new console application project, the following command should be used:</p>
<pre><strong>dotnet new console --name FlixOne.InventoryManagementClient</strong></pre>
<p>The following screenshot shows the <kbd>console</kbd> template being restored:</p>
<div><img class="alignnone size-full wp-image-160 image-border" src="img/d4670643-d4de-4934-b042-0772541e3e0d.png" style=""/></div>
<p>The console application requires a reference to the class library (note: the command needs to be run in the directory with the project file that will have the reference added to it):</p>
<pre><strong>dotnet add reference ..\FlixOne.InventoryManagement\FlixOne.InventoryManagement.csproj</strong></pre>
<p>A new <kbd>MSTest</kbd> project will be created using the following command:</p>
<pre><strong>dotnet new mstest --name FlixOne.InventoryManagementTests</strong></pre>
<p>The following screenshot shows the creation of the MSTest project and should be run in the same folder as the solution, FlixOne (note the packages restored as part of the command containing the required MSTest NuGet packages):</p>
<div><img class="alignnone size-full wp-image-161 image-border" src="img/f0e033e2-5bda-4b22-9b5e-5fa2600001ff.png" style=""/></div>
<p>The test project also requires a reference to the class library (note: this command needs to be run in the same folder as the MSTest project file):</p>
<pre><strong>dotnet add reference ..\FlixOne.InventoryManagement\FlixOne.InventoryManagement.csproj</strong></pre>
<p>Finally, both the console application and the MSTest project should be added to the solution by running the following commands in the same directory as the solution file:</p>
<pre><strong>dotnet sln add .\FlixOne.InventoryManagementClient\FlixOne.InventoryManagementClient.csproj</strong><br/><strong>dotnet sln add .\FlixOne.InventoryManagementTests\FlixOne.InventoryManagementTests.csproj</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Visually, the solution is shown as follows:</p>
<div><img class="alignnone size-full wp-image-162 image-border" src="img/7e47db76-ac52-4e8b-8866-1db9a03d4ebf.png" style=""/></div>
<p>Now that the initial structure of our solution is ready, let's first start by adding to our unit test definitions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Initial unit test definitions</h1>
                
            
            
                
<p>The development team first transcribed the requirements into some basic unit tests. As nothing had been designed or written yet, these mostly take the form of noting what functionality should be validated. As the design and development progress, these tests will also evolve toward completion; for example, there is a requirement for adding inventory:</p>
<p>An add inventory command ("a", "addinventory") is available:
<ul>
<li>The <kbd>name</kbd> parameter of type string.</li>
<li>Add an entry into the database with the given name and a <kbd>0</kbd> quantity.</li>
</ul>
</p>
<p>To capture this requirement, the development team created the following unit test to serve as a placeholder:</p>
<pre>[TestMethod]<br/>private void AddInventoryCommand_Successful()<br/>{<br/>  // create an instance of the command<br/>  // add a new book with parameter "name"<br/>  // verify the book was added with the given name with 0 quantity<br/><br/>  Assert.Inconclusive("AddInventoryCommand_Successful has not been implemented.");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As the application design becomes known and development starts, the existing tests will expand and new tests will be created, as follows: </p>
<div><img class="alignnone size-full wp-image-163 image-border" src="img/b2f6bef0-f8e8-481c-bc9c-83761e6bb255.png" style=""/></div>
<p>The importance of the inconclusive tests is that they communicate what needs to be accomplished to the team and provide a measure as the development proceeds. As the development progresses, inconclusive and failing tests will indicate work to be undertaken and successful tests will indicate progress toward completing the current set of tasks.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Abstract Factory design pattern</h1>
                
            
            
                
<p>To illustrate our first pattern, let's walk through the development of the help command and the initial console application. The initial version of the console application is shown as follows:</p>
<pre>private static void Main(string[] args)<br/>{<br/>    Greeting();<br/>    <br/>    // note: inline out variable introduced as part of C# 7.0<br/>    GetCommand("?").RunCommand(out bool shouldQuit); <br/><br/>    while (!shouldQuit)<br/>    { <br/>        // handle the commands<br/>        ...<br/>    }<br/><br/>    Console.WriteLine("CatalogService has completed."); <br/>}</pre>
<p>When the application starts, both a greeting and the result of a help command are shown. The application will then process entered commands until the quit command is entered.</p>
<p>The following shows the detail of handling commands:</p>
<pre>    while (!shouldQuit)<br/>    { <br/>        Console.WriteLine(" &gt; ");<br/>        var input = Console.ReadLine();<br/>        var command = GetCommand(input);<br/><br/>        var wasSuccessful = command.RunCommand(out shouldQuit);<br/><br/>        if (!wasSuccessful)<br/>        {<br/>            Console.WriteLine("Enter ? to view options.");<br/>        }<br/>    }</pre>
<p>Until the application solution quits, the application will continue to prompt the user for command and, if a command was not successfully handled, then help text is shown.</p>
<p>RunCommand(out bool shouldQuit)<br/>
C# 7.0 introduces a more fluid syntax for creating <kbd>out</kbd> parameters. This will declare the variables in the scope of the command block. This is illustrated with the following, where the <kbd>shouldQuit</kbd> Boolean is not declared ahead of time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">InventoryCommand abstract class</h1>
                
            
            
                
<p>The first thing to point out about the initial console application is that the team is using <strong>object-oriented programming</strong> (<strong>OOP</strong>) to create a standard way of handling commands. What the team learned from this initial design is that all commands will contain a <kbd>RunCommand()</kbd> method that will return two Booleans indicating whether the command was successful and whether the program should terminate. For example, the <kbd>HelpCommand()</kbd> will simply display a help message to the console and should not cause the program to end. The two return Booleans would then be <em>true</em>, to indicate that the command ran successfully and <em>false, </em>to indicate that the application should not terminate. The following shows the initial version:</p>
<p>The ... indicates additional statements and, in this particular example, additional <kbd>Console.WriteLine()</kbd> statements.</p>
<pre>public class HelpCommand<br/>{<br/>    public bool RunCommand(out bool shouldQuit)<br/>    {<br/>        Console.WriteLine("USAGE:");<br/>        Console.WriteLine("\taddinventory (a)");<br/>        ...<br/>        Console.WriteLine("Examples:");<br/>        ...<br/><br/>        shouldQuit = false;<br/>        return true;<br/>    }<br/>}</pre>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The <kbd>QuitCommand</kbd> will display a message and then cause the program to end. The initial <kbd>QuitCommand</kbd> was as follows:</p>
<pre>public class QuitCommand<br/>{<br/>    public bool RunCommand(out bool shouldQuit)<br/>    {<br/>        Console.WriteLine("Thank you for using FlixOne Inventory Management System");<br/>            <br/>        shouldQuit = true;<br/>        return true;<br/>    }<br/>}</pre>
<p>The team decided to either create an interface that both classes implement, or an abstract class that both classes inherit from. Both could have achieved the desired dynamic polymorphism but the team chose to use an abstract class as all commands will have shared functionality.</p>
<p>In OOP and in particular C#, polymorphism is supported in three main ways: function overloading, generics, and subtyping or dynamic polymorphism. </p>
<p>Using the Abstract Factory Design pattern, the team created an abstract class that commands would inherit from, <kbd>InventoryCommand</kbd>. The <kbd>InventoryCommand</kbd> class has a single method, <kbd>RunCommand</kbd>, that will perform the command and return whether the command was successfully executed and whether the application should quit. The class is abstract, meaning the class contains one or more abstract methods. In this case, the <kbd>InternalCommand()</kbd> method is abstract and the intent is that classes deriving from the <kbd>InventoryCommand</kbd> class will implement the <kbd>InternalCommand</kbd> method with the specific command functionality. For example, <kbd>QuitCommand</kbd> will extend <kbd>InventoryCommand</kbd> and provide a concrete implementation for the <kbd>InternalCommand()</kbd> method. The following snippet shows the <kbd>InventoryCommand</kbd> abstract class with the abstract <kbd>InternalCommand()</kbd> method:</p>
<pre>public abstract class InventoryCommand<br/>{<br/>    private readonly bool _isTerminatingCommand;<br/>    internal InventoryCommand(bool commandIsTerminating)<br/>    {<br/>        _isTerminatingCommand = commandIsTerminating; <br/>    }<br/>    public bool RunCommand(out bool shouldQuit)<br/>    {<br/>        shouldQuit = _isTerminatingCommand;<br/>        return InternalCommand();<br/>    }<br/><br/>    internal abstract bool InternalCommand();<br/>}</pre>
<p>The abstract method would then be implemented in each derived class, as illustrated with the <kbd>HelpCommand</kbd>. The <kbd>HelpCommand</kbd> simply prints some information to the console and then returns <kbd>true</kbd>, indicating that the command was executed successfully:</p>
<pre>public class HelpCommand : InventoryCommand<br/>{<br/>    public HelpCommand() : base(false) { }<br/><br/>    internal override bool InternalCommand()<br/>    { <br/>        Console.WriteLine("USAGE:");<br/>        Console.WriteLine("\taddinventory (a)");<br/>        ...<br/>        Console.WriteLine("Examples:");<br/>        ... <br/>        return true;<br/>    }<br/>}</pre>
<p>The development team then decided on making two additional changes to the <kbd>InventoryCommand</kbd>. The first thing they did not like was how the <kbd>shouldQuit</kbd> Boolean was being returned as an <em>out</em> variable. Thus, they decided to use the new tuples feature of C# 7 to instead return a single <kbd>Tuple&lt;bool,bool&gt;</kbd> object as follows:</p>
<pre>public (bool wasSuccessful, bool shouldQuit) RunCommand()<br/>{<br/>    /* additional code hidden */<br/><br/>    return (InternalCommand(), _isTerminatingCommand);<br/>}</pre>
<p>Tuple<br/>
The tuple is a C# type that provides a lightweight syntax for packaging multiple values into a single object easily. The disadvantage over defining a class is you lose inheritance and other object-oriented functionality. For more information, please see <a href="https://docs.microsoft.com/en-us/dotnet/csharp/tuples">https://docs.microsoft.com/en-us/dotnet/csharp/tuples</a>.</p>
<p>The other change was to introduce another abstract class to indicate whether the command was a non-terminating command; in other words, a command that does not cause the solution to quit or end.</p>
<p>As shown in the following code, this command is still abstract as it does not implement the <kbd>InternalCommand</kbd> method of <kbd>InventoryCommand</kbd>, but it passes a false value to the base class:</p>
<pre>internal abstract class NonTerminatingCommand : InventoryCommand<br/>{<br/>    protected NonTerminatingCommand() : base(commandIsTerminating: false)<br/>    {<br/>    }<br/>}</pre>
<p>The advantage here is now commands that do not cause the application to end – in other words, are non-terminating – now have a simpler definition:</p>
<pre>internal class HelpCommand : NonTerminatingCommand<br/>{<br/>    internal override bool InternalCommand()<br/>    {<br/>        Interface.WriteMessage("USAGE:");<br/>        /* additional code hidden */<br/><br/>        return true;<br/>    }<br/>}</pre>
<p>The following class diagram shows the inheritance of the <kbd>InventoryCommand</kbd> abstract class:</p>
<div><img class="alignnone size-full wp-image-164 image-border" src="img/bc1bd371-98d9-4fec-8acc-1f26d74eb3ac.png" style=""/></div>
<p>There is only one terminating command, <kbd>QuitCommand</kbd>, while the other commands extend the <kbd>NonTerminatingCommand</kbd> abstract class. It is also worth noting that only the <kbd>AddInventoryCommand</kbd> and <kbd>UpdateQuantityCommand</kbd> require parameters and the use of the <kbd>IParameterisedCommand</kbd> is explained later in the <em>Liskov Substitution Principle</em> section. Another subtle point in the diagram is that all the types, other than the base <kbd>InventoryCommand</kbd>, are not public (visible to external assemblies). This will become relevant in the <em>Access modifiers</em> section later in the chapter. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">SOLID principles</h1>
                
            
            
                
<p>As the team simplifies the code by using patterns, they also use SOLID principles to help identify problems. By simplifying the code, the team aims to make the code more maintainable and easier for new team members to understand. This approach of reviewing the code with a set of principles is very useful in writing concise classes that only do what they need to achieve, and putting in a layer of abstraction that helps to write code that is easier to modify and understand.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Single responsibility principle (SRP)</h1>
                
            
            
                
<p>The first principle that the team applies is the <strong>single responsibility principle</strong> (<strong>SRP</strong>). The team identified that the actual mechanism of writing to the console is not the responsibility of the <kbd>InventoryCommand</kbd> classes. Because of this, a <kbd>ConsoleUserInterface</kbd> class is introduced that is responsible for the interaction with the user. SRP will help keep the <kbd>InventoryCommand</kbd> classes smaller and avoid situations where the same code is duplicated. For example, the application should have a uniform way of prompting the user for information and displaying messages and warnings. Instead of repeating this in the <kbd>InventoryCommand</kbd> classes, this logic is encapsulated in the <kbd>ConsoleUserInterface</kbd> class. </p>
<p>The <kbd>ConsoleUserInteraface</kbd> will consist of three methods, as indicated in the following:</p>
<pre>public class ConsoleUserInterface<br/>{<br/>    // read value from console<br/><br/>    // message to the console<br/><br/>    // writer warning message to the console<br/>}</pre>
<p class="mceNonEditable"/>
<p>The first method will be used to read input from the console:</p>
<pre>public string ReadValue(string message)<br/>{<br/>    Console.ForegroundColor = ConsoleColor.Green;<br/>    Console.Write(message);<br/>    return Console.ReadLine();<br/>}</pre>
<p>The second method will print a message to the console using the color green:</p>
<pre>public void WriteMessage(string message)<br/>{<br/>    Console.ForegroundColor = ConsoleColor.Green;<br/>    Console.WriteLine(message);<br/>}</pre>
<p>The final method will print a message to the console using a dark yellow color indicating a warning message:</p>
<pre>public void WriteWarning(string message)<br/>{<br/>    Console.ForegroundColor = ConsoleColor.DarkYellow;<br/>    Console.WriteLine(message);<br/>}</pre>
<p>With the <kbd>ConsoleUserInterface</kbd> class, we can reduce the impact of changes to how we interact with the user. As our solution develops, we might find that the interface changes from a console to a web application. In theory, we would replace the <kbd>ConsoleUserInterface</kbd> with a <kbd>WebUserInterface</kbd>. If we had not reduced the user interface to a single class, the impact of such a change would most likely be more disruptive.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Open/closed principle (OCP)</h1>
                
            
            
                
<p>The <strong>open/closed principle</strong>, the O in SOLID, is represented by the different <kbd>InventoryCommand</kbd> classes. Instead of having an implementation of the <kbd>InventoryCommand</kbd> class per command, the team could have defined a single class containing multiple <kbd>if</kbd> statements. Each <kbd>if</kbd> statement would determine what functionality to execute. For example, the following illustrates how the team could have broken this principle:</p>
<pre>internal bool InternalCommand(string command)<br/>{<br/>    switch (command)<br/>    {<br/>        case "?":<br/>        case "help":<br/>            return RunHelpCommand(); <br/>        case "a":<br/>        case "addinventory":<br/>            return RunAddInventoryCommand(); <br/>        case "q":<br/>        case "quit":<br/>            return RunQuitCommand();<br/>        case "u":<br/>        case "updatequantity":<br/>            return RunUpdateInventoryCommand();<br/>        case "g":<br/>        case "getinventory":<br/>            return RunGetInventoryCommand();<br/>    }<br/>    return false;<br/>}</pre>
<p>The above method breaks this principle because adding a new command would alter the behavior of the code. The idea of the principle is that it is <strong>closed</strong> to modification that would <em>alter</em> its behavior and instead is <strong>open</strong> to extend the class to support additional behavior. This is what is accomplished by having the abstract <kbd>InventoryCommand</kbd> and derived classes (for example, <kbd>QuitCommand</kbd>, <kbd>HelpCommand</kbd>, and <kbd>AddInventoryCommand</kbd>). A compelling reason for this, especially when combined with the other principles, is that it leads to succinct code that is easier to maintain and understand. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Liskov substitution principle (LSP)</h1>
                
            
            
                
<p>The commands for quit, help, and get inventory do not require parameters, while the <kbd>AddInventory</kbd> and <kbd>UpdateQuantityCommand</kbd> do. There are several ways to handle this and the team decided to introduce an interface to identify those commands as follows:</p>
<pre>public interface IParameterisedCommand<br/>{<br/>    bool GetParameters();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>By applying the <strong>Liskov substitution principle</strong> (<strong>LSP</strong>), only those commands that require parameters should implement the <kbd>GetParameters()</kbd> method. For example, on the <kbd>AddInventory</kbd> command, the <kbd>IParameterisedCommand</kbd> is implemented using a method defined on the base <kbd>InventoryCommand</kbd>:</p>
<pre>public class AddInventoryCommand : InventoryCommand, IParameterisedCommand<br/>{<br/>    public string InventoryName { get; private set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// AddInventoryCommand requires name<br/>    /// &lt;/summary&gt;<br/>    /// &lt;returns&gt;&lt;/returns&gt;<br/>    public bool GetParameters()<br/>    {<br/>        if (string.IsNullOrWhiteSpace(InventoryName))<br/>            InventoryName = GetParameter("name");<br/><br/>        return !string.IsNullOrWhiteSpace(InventoryName);<br/>    }    <br/>}</pre>
<p>The <kbd>GetParameter</kbd> method on the <kbd>InventoryCommand</kbd> class simply uses the <kbd>ConsoleUserInterface</kbd> to read a value from the console. The method will be shown later in this chapter. In C#, there is handy syntax that shows well how LSP can be used to apply functionality to only objects of a specific interface. On the first line of the <kbd>RunCommand</kbd> method, the <kbd>is</kbd> keyword is used to both test whether the current object implements the <kbd>IParameterisedCommand</kbd> interface as well as cast the object as a new object: <kbd>parameterisedCommand</kbd>. This is shown in bold in the following code snippet:</p>
<pre>public (bool wasSuccessful, bool shouldQuit) RunCommand()<br/>{<br/>    if (<strong>this is IParameterisedCommand parameterisedCommand</strong>)<br/>    {<br/>        var allParametersCompleted = false;<br/><br/>        while (allParametersCompleted == false)<br/>        {<br/>            allParametersCompleted = parameterisedCommand.GetParameters();<br/>        }<br/>    }<br/><br/>    return (InternalCommand(), _isTerminatingCommand);<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Interface segregation principle (ISP)</h1>
                
            
            
                
<p>One approach to handling commands with and without parameters would have been to define another method, <kbd>GetParameters</kbd>, on the <kbd>InventoryCommand</kbd> abstract class, and for those that do not require parameters to just return true to indicate that all, in this case no, parameters have been received. For example, the <kbd>QuitCommand</kbd>, <kbd><strong>HelpCommand</strong></kbd>, and <kbd>GetInventoryCommand</kbd> would all have an implementation similar to the following:</p>
<pre>internal override bool GetParameters()<br/>{<br/>    return true;<br/>}</pre>
<p>This would work but it does break the <strong>interface segregation principle</strong> (<strong>ISP</strong>), which states that an interface should only contain methods and properties that are required. Similar to SRP, which applies to classes, ISP applies to interfaces and is effective in keeping interfaces small and focused. In our example, only the <kbd>AddInventoryCommand</kbd> and <kbd>UpdateQuantityCommand</kbd> classes will implement the <kbd>InventoryCommand</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency inversion principle</h1>
                
            
            
                
<p>The <strong>dependency inversion principle</strong> (<strong>DIP</strong>), also referred to as the <strong>dependency injection</strong> <strong>principle</strong> (<strong>DIP</strong>), modules should not depend on details but, instead, on abstractions. This principle encourages writing loosely coupled code to enhance both readability as well as maintenance, especially in a large complex code base.</p>
<p>If we revisit the <kbd>ConsoleUserInterface</kbd> class that was introduced earlier (in the <em>Single responsibility principle</em> section), we could use the class without the <kbd>QuitCommand</kbd> as follows:</p>
<pre>internal class QuitCommand : InventoryCommand<br/>{<br/>    internal override bool InternalCommand()<br/>    {<br/>        var console = new ConsoleUserInterface();<br/>        console.WriteMessage("Thank you for using FlixOne Inventory Management System");<br/>            <br/>        return true;<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This breaks several SOLID principles, but in regards to DIP, it makes a tight coupling between the <kbd>QuitCommand</kbd> and the <kbd>ConsoleUserInterface</kbd>. Imagine the scenario where the console is no longer the means to display information to the user, or what if the constructor of the <kbd>ConsoleUserInterface</kbd> requires additional parameters?</p>
<p>By applying the DIP principle, the following refactor was performed. First a new interface, <kbd>IUserInterface</kbd>, was introduced that contained the definitions of the methods implemented in the <kbd>ConsoleUserInterface</kbd>. Next, the interface, and not the concrete class, is used in the <kbd>InventoryCommand</kbd> classes. Finally, a reference to an object implementing the <kbd>IUserInterface</kbd> is passed into the constructor of the <kbd>InventoryCommand</kbd> classes. This approach protects the <kbd>InventoryCommand</kbd> classes from changes to the implementation details of <kbd>IUserInterface</kbd> classes, as well as providing a mechanism for more easily replacing different implementations of <kbd>IUserInterface</kbd> as the code base evolves. </p>
<p>The DIP is illustrated as follows with the <kbd>QuitCommand</kbd> and is our final version of the class for this chapter:</p>
<pre>internal class QuitCommand : InventoryCommand<br/>{<br/>    public QuitCommand(IUserInterface userInterface) : <br/>           base(commandIsTerminating: true, userInteface: userInterface)<br/>    {<br/>    }<br/><br/>    internal override bool InternalCommand()<br/>    {<br/>        Interface.WriteMessage("Thank you for using FlixOne Inventory Management System");<br/>            <br/>        return true;<br/>    }<br/>}</pre>
<p>Note that the class extends the <kbd>InventoryCommand</kbd> abstract class, providing both a common way of handling commands, as well as providing shared functionality. The constructor requires the <kbd>IUserInterface</kbd> dependency to be injected when the object is instantiated. Also note the <kbd>QuitCommand</kbd> implements a single method, <kbd>InternalCommand()</kbd>, keeping the <kbd>QuitCommand</kbd> lean and easy to read and understand.</p>
<p class="mce-root"/>
<p>To complete the picture, let's view the final <kbd>InventoryCommand</kbd> base class. The following shows the constructor and properties:</p>
<pre>public abstract class InventoryCommand<br/>{<br/>    private readonly bool _isTerminatingCommand;<br/>    protected IUserInterface Interface { get; }<br/><br/>    internal InventoryCommand(bool commandIsTerminating, IUserInterface userInteface)<br/>    {<br/>        _isTerminatingCommand = commandIsTerminating;<br/>        Interface = userInteface;<br/>    }<br/>    ...<br/>}</pre>
<p>Note the <kbd>IUserInterface</kbd> is passed into the constructor as well as a Boolean indicating whether the command is terminating or not. The <kbd>IUserInterface</kbd> is then made available to all implementation of <kbd>InventoryCommand</kbd> as the <kbd>Interface</kbd> property. </p>
<p>The <kbd>RunCommand</kbd> is the only public method on the class:</p>
<pre>public (bool wasSuccessful, bool shouldQuit) RunCommand()<br/>{<br/>    if (this is IParameterisedCommand parameterisedCommand)<br/>    {<br/>        var allParametersCompleted = false;<br/><br/>        while (allParametersCompleted == false)<br/>        {<br/>            allParametersCompleted = parameterisedCommand.GetParameters();<br/>        }<br/>    }<br/><br/>    return (InternalCommand(), _isTerminatingCommand);<br/>}<br/><br/>internal abstract bool InternalCommand();</pre>
<p>Furthermore, the <kbd>GetParameter</kbd> method is a method common to all implementations of <kbd>InventoryCommand</kbd>, so it is made internal:</p>
<pre>internal string GetParameter(string parameterName)<br/>{<br/>    return Interface.ReadValue($"Enter {parameterName}:"); <br/>}</pre>
<p>DIP and IoC<br/>
The DIP and <strong>Inversion of Control</strong> (<strong>IoC</strong>) are closely related and all address the same issues but in slightly different ways. IoC and its specialized form, the <strong>Service Locator Pattern</strong> (<strong>SLP</strong>), use a mechanism to supply an implementation of an abstraction on demand. So, instead of injecting the implementation, IoC acts as a proxy to supply the details that are required. In the next chapter, .NET Core support for these patterns will be explored.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">InventoryCommand unit tests</h1>
                
            
            
                
<p>With the <kbd>InventoryCommand</kbd> classes taking shape, let's revisit the unit tests so we can start to validate what has been written so far and identify any missing requirements. The SOLID principles will show their value here. Because we kept our classes (SRP) and interfaces (ISP) small, and focused on just the minimum amount of functionality required (LSP), our tests should also be simpler to write and validate. For example, a test regarding one of the commands will not need to validate the display of the messages on the console (for example, color or text size) as that is not the responsibility of the <kbd>InventoryCommand</kbd> classes but of the implementation of the <kbd>IUserInterface</kbd>. Also, with dependency injection, we will be able to isolate the test to just the inventory command. The following diagram illustrates this, as the unit test will only validate what is contained in the green box:</p>
<div><img class="alignnone size-full wp-image-165 image-border" src="img/4cfda6fb-5968-451a-af94-5bee807667a1.png" style=""/></div>
<p>By keeping the unit test's scope limited, it will be easier to handle change as the application changes. In some situations where it is more difficult to separate the functionality due to interdependencies within classes (in other words, when SOLID is not followed), a test can span a larger section of the application including repositories. These tests are usually referred to as integration tests instead of unit tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Access modifiers</h1>
                
            
            
                
<p>Access modifiers are an important way of handling the visibility of types and type members by encapsulating code. By using a clear access strategy, the intent of how an assembly and its types should be used can be communicated and enforced. For example, in the FlixOne application, only types that should be accessed directly by the console are marked as public. This means that the console application should have visibility of a limited number of types and methods. These types and methods have been marked as public while types and methods that the console should not have access to, have been marked as internal, private, or protected.</p>
<p>Please see the Microsoft docs programming guide for more information on access modifiers: <br/>
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers</a></p>
<p>The <kbd>InventoryCommand</kbd> abstract class is made public as the console application will use the <kbd>RunCommand</kbd> method to handle the command.</p>
<p>In the following snippet, note how the constructor and interface are made protected to give access to the sub-classes:</p>
<pre>public abstract class InventoryCommand<br/>{<br/>    private readonly bool _isTerminatingCommand;<br/>    protected IUserInterface Interface { get; }<br/><br/>    protected InventoryCommand(bool commandIsTerminating, IUserInterface userInteface)<br/>    {<br/>        _isTerminatingCommand = commandIsTerminating;<br/>        Interface = userInteface;<br/>    }<br/>    ...<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>In the following snippet, note that the <kbd>RunCommand</kbd> method is made public while the <kbd>InternalCommand</kbd> is made internal:</p>
<pre>public (bool wasSuccessful, bool shouldQuit) RunCommand()<br/>{<br/>    if (this is IParameterisedCommand parameterisedCommand)<br/>    {<br/>        var allParametersCompleted = false;<br/><br/>        while (allParametersCompleted == false)<br/>        {<br/>            allParametersCompleted = parameterisedCommand.GetParameters();<br/>        }<br/>    }<br/><br/>    return (InternalCommand(), _isTerminatingCommand);<br/>}<br/><br/>internal abstract bool InternalCommand();</pre>
<p>Similarly, the implementations of <kbd>InventoryCommand</kbd> are marked as internal to prevent them from being directly referenced outside of the assembly. This is illustrated as follows with the <kbd>QuitCommand</kbd>:</p>
<pre>internal class QuitCommand : InventoryCommand<br/>{<br/>    internal QuitCommand(IUserInterface userInterface) : base(true, userInterface) { }<br/><br/>    protected override bool InternalCommand()<br/>    {<br/>        Interface.WriteMessage("Thank you for using FlixOne Inventory Management System");<br/>            <br/>        return true;<br/>    }<br/>}</pre>
<p>Because the access of the different implementations will not be visible directly to the unit test project, an additional step is required to make the internal types visible. The <kbd>assembly</kbd> directive could be placed in any compiled file and, for the FlixOne application, an <kbd>assembly.cs</kbd> was added containing the assembly attribute:</p>
<pre>using System.Runtime.CompilerServices;<br/>[assembly: InternalsVisibleTo("FlixOne.InventoryManagementTests")]</pre>
<p>In situations where the assembly is signed, the <kbd>InternalsVisibleTo()</kbd> requires a public key. Please see the Microsoft Docs C# Guide for more information: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Helper TestUserInterface</h1>
                
            
            
                
<p>As part of a unit test of one of the <kbd>InventoryCommand</kbd> implementations, we do not want to test the referenced dependencies. Fortunately, because the commands adhere to the DIP, we can create a <kbd>helper</kbd><em> </em>class to validate the implementation interactions with the dependencies. One of the dependencies is the <kbd>IUserInterface</kbd>, which is passed into the implementation in the constructor. The following is a reminder of the methods of the interface:</p>
<pre>public interface IUserInterface : IReadUserInterface, IWriteUserInterface { }<br/><br/>public interface IReadUserInterface<br/>{<br/>    string ReadValue(string message);<br/>}<br/><br/>public interface IWriteUserInterface<br/>{<br/>    void WriteMessage(string message);<br/>    void WriteWarning(string message);<br/>}</pre>
<p>By implementing a <kbd>helper</kbd> class, we can supply the information required by the <kbd>ReadValue</kbd> method as well as verify that the appropriate messages are received in the <kbd>WriteMessage</kbd> and <kbd>WriteWarning</kbd> methods. In the test project, a new class called <kbd>TestUserInterface</kbd> was created that implements the <kbd>IUserInterface</kbd> interface. The class contains three lists containing the expected <kbd>WriteMessage</kbd>, <kbd>WriteWarning</kbd>, and <kbd>ReadValue</kbd> calls, and keeps track of the number of times it has been called.</p>
<p>For example, the <kbd>WriteWarning</kbd> method is shown as follows:</p>
<pre>public void WriteWarning(string message)<br/>{<br/>    Assert.IsTrue(_expectedWriteWarningRequestsIndex &lt; _expectedWriteWarningRequests.Count,<br/>                  "Received too many command write warning requests.");<br/><br/>    Assert.AreEqual(_expectedWriteWarningRequests[_expectedWriteWarningRequestsIndex++], message,                             "Received unexpected command write warning message");<br/>}</pre>
<p>The <kbd>WriteWarning</kbd> method performs two asserts. The first verifies that the method is not called more times than expected and the second verifies that the message received matches the expected message.</p>
<p>The <kbd>ReadValue</kbd> method is similar but it additionally returns a value back to the calling <kbd>InventoryCommand</kbd> implementation. This will simulate the user entering information into the console:</p>
<pre>public string ReadValue(string message)<br/>{<br/>    Assert.IsTrue(_expectedReadRequestsIndex &lt; _expectedReadRequests.Count,<br/>                  "Received too many command read requests.");<br/>            <br/>    Assert.AreEqual(_expectedReadRequests[_expectedReadRequestsIndex].Item1, message, <br/>                    "Received unexpected command read message");<br/><br/>    return _expectedReadRequests[_expectedReadRequestsIndex++].Item2;<br/>}</pre>
<p> As an extra validation step, at the end of a test method, the <kbd>TestUserInterface</kbd> is called to verify that the expected number of <kbd>ReadValue</kbd>, <kbd>WriteMessage</kbd>, and <kbd>WriteWarning</kbd> requests were received:</p>
<pre>public void Validate()<br/>{<br/>    Assert.IsTrue(_expectedReadRequestsIndex == _expectedReadRequests.Count, <br/>                  "Not all read requests were performed.");<br/>    Assert.IsTrue(_expectedWriteMessageRequestsIndex == _expectedWriteMessageRequests.Count, <br/>                  "Not all write requests were performed.");<br/>    Assert.IsTrue(_expectedWriteWarningRequestsIndex == _expectedWriteWarningRequests.Count, <br/>                  "Not all warning requests were performed.");<br/>}</pre>
<p>The <kbd>TestUserInterface</kbd> class illustrates how a dependency can be mocked to provide stubbed functionality as well as provide assertions to help verify the expected behavior. In later chapters, we will use a third-party package to provide a more sophisticated framework for mocking the dependencies.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Example unit test – QuitCommand</h1>
                
            
            
                
<p>Starting with the <kbd>QuitCommand</kbd>, the requirements are pretty straightforward: the command should print a farewell message and then cause the application to end. We have designed the <kbd>InventoryCommand</kbd> to return two Booleans to indicate whether the application should quit and whether the command ended successfully: </p>
<pre>[TestMethod]<br/>public void QuitCommand_Successful()<br/>{<br/>    var expectedInterface = new Helpers.TestUserInterface(<br/>        new List&lt;Tuple&lt;string, string&gt;&gt;(), // ReadValue()<br/>        new List&lt;string&gt; // WriteMessage()<br/>        {<br/>            "Thank you for using FlixOne Inventory Management System"<br/>        },<br/>        new List&lt;string&gt;() // WriteWarning()<br/>    );<br/><br/>    // create an instance of the command<br/>    var command = new QuitCommand(expectedInterface);<br/><br/>    var result = command.RunCommand();<br/><br/>    expectedInterface.Validate();<br/><br/>    Assert.IsTrue(result.shouldQuit, "Quit is a terminating command.");<br/>    Assert.IsTrue(result.wasSuccessful, "Quit did not complete Successfully.");<br/>}</pre>
<p>The test uses the <kbd>TestUserInterface</kbd> to verify that the text <kbd>"Thank you for using FlixOne Inventory Management System"</kbd><em> </em>is sent to the <kbd>WriteMessage</kbd> method and no <kbd>ReadValue</kbd> or <kbd>WriteWarning</kbd> requests are received. These last two criteria are verified by the <kbd>expectedInterface.Validate()</kbd> call. The result of the <kbd>QuitCommand</kbd> is verified by checking that the <kbd>shouldQuit</kbd> and <kbd>wasSuccessful</kbd> Booleans are true.</p>
<p>In the FlixOne scenario, the text to be shown is <em>hardcoded</em> in the solution for simplicity. A better approach would be to use resource files. Resource files provide a way of maintaining the text separate from the functionality as well as supporting localizing the data for different cultures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter introduced the scenario of an online bookseller, FlixOne, wanting to build an application for managing their inventory. The chapter covered a range of patterns and practices that the development team can use while developing the application. The team used MVP to help keep the scope of the initial delivery to a manageable level and to help focus the business onto determining the requirements that had the maximum benefit to the organization. The team decided to use TDD to validate that the delivery matches the requirements and to help the team measure progress. The basic project, as well as the unit testing framework, MSTest, was created. The team also used SOLID principles to help structure the code in a way that will both help readability as well as the maintenance of the code base, as new enhancements to the application are added. The first Gang of Four pattern, the Abstract Factory design pattern, was used to provide a base for all inventory commands.</p>
<p>In the next chapter, the team will continue to build the initial inventory management project to fit the requirements defined in the MVP. The Gang of Four's Singleton pattern and the Factory Method pattern will be used by the team. These will be shown both with and without the mechanisms supported in .NET Core for these features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<p class="mce-root">The following questions will allow you to consolidate the information contained in this chapter:</p>
<ol>
<li>In developing software for an organization, why is it sometimes difficult to determine requirements?</li>
<li>What are two advantages and disadvantages of Waterfall software development versus Agile software development?</li>
<li>How does dependency injection help when writing unit tests?</li>
<li>Why is the following statement false? With TDD, you no longer need people to test a new software deployment.</li>
</ol>


            

            
        
    </body></html>