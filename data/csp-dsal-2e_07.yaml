- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Variants of Trees
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的变体
- en: In the previous chapters, you learned about many data structures, starting with
    simple ones such as arrays. Now, it is time for you to get to know a significantly
    more complex group of data structures, namely **trees**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了关于许多数据结构的知识，从简单的数组开始。现在，是时候了解一个显著更复杂的数据结构组了，即**树**。
- en: At the beginning of this chapter, a **basic tree** will be presented, together
    with its implementation in the C# language, and with some examples showing it
    in action. Then, a **binary tree** will be introduced, with a detailed description
    of its implementation and an example of its application. A **binary search tree**
    (**BST**) is another tree variant and is one of the most popular types of trees,
    used in many algorithms. You will also cover **self-balancing trees**, namely
    **AVL** and **red-black trees** (**RBTs**). Then, you will see a **trie** as a
    specialized data structure for performing operations on strings. The remaining
    part of the chapter is dedicated to a short introduction to the topic of **heaps**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开头将介绍一个**基本树**，以及其在C#语言中的实现，并有一些示例展示其作用。然后，将介绍**二叉树**，包括其实现的详细描述和应用的示例。**二叉搜索树**（BST）是另一种树变体，是最流行的树类型之一，在许多算法中使用。你还将了解**自平衡树**，即**AVL树**和**红黑树**（RBTs）。然后，你将看到**字典树**作为一个专门的数据结构，用于执行字符串操作。本章的其余部分将简要介绍**堆**的主题。
- en: Arrays, lists, stacks, queues, dictionaries, sets, and now trees. Are you ready
    to increase the level of difficulty and learn the next data structures? If so,
    let’s start reading!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、列表、栈、队列、字典、集合，现在还有树。你准备好提高难度并学习下一个数据结构了吗？如果是这样，让我们开始阅读吧！
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basic trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本树
- en: Binary trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树
- en: Binary search trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: Self-balancing trees
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自平衡树
- en: Tries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典树
- en: Heaps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Basic trees
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本树
- en: 'Let’s start with introducing trees. What are they? Do you have any ideas about
    how such a data structure should look? If not, let’s take a look at the following
    diagram, which depicts a tree with captions regarding its particular elements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍树开始。它们是什么？你对这样一个数据结构的外观有什么想法吗？如果没有，让我们看看以下图表，它描绘了一个带有关于其特定元素的标题的树：
- en: "![Figure 7.1 – \uFEFFIllustration of a tree](img/B18069_07_01.jpg)"
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 树的示意图](img/B18069_07_01.jpg)'
- en: Figure 7.1 – Illustration of a tree
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 树的示意图
- en: A tree consists of multiple **nodes**, including one **root** (**100** in the
    diagram). The root does not contain a **parent** node, while all other nodes do.
    For example, the parent element of node **1** is **100**, while node **96** has
    node **30** as the parent.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 树由多个**节点**组成，包括一个**根节点**（图中为**100**）。根节点不包含**父节点**，而所有其他节点都包含。例如，节点**1**的父元素是**100**，而节点**96**的父节点是**30**。
- en: Moreover, each node can have any number of **child** nodes, such as three **children**
    (that is, **50**, **1**, and **150**) in the case of the **root**. The child nodes
    of the same node can be named **siblings**, as in the case of nodes **70** and
    **61**. A node without children is named a **leaf**, such as **45** and **6**
    in the diagram.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个节点可以有任意数量的**子节点**，例如在**根节点**的情况下有三个**子节点**（即**50**、**1**和**150**）。同一节点的子节点可以被称为**兄弟节点**，例如节点**70**和**61**的情况。没有子节点的节点被称为**叶节点**，例如图中的**45**和**6**。
- en: Let’s take a look at the rectangle with three nodes (that is, **30**, **96**,
    and **9**). Such a part of the tree can be called a **subtree**. Of course, you
    can find many subtrees in the tree.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看包含三个节点（即**30**、**96**和**9**）的矩形。这样的树的一部分可以称为**子树**。当然，你可以在树中找到许多子树。
- en: Imagine a tree
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一棵树
- en: If you want to better imagine a tree, look at the structure of a slightly larger
    company, where at the very top of the hierarchy there is the **chief executive
    officer** (**CEO**), to whom the **chief operating officer** (**COO**), **chief
    marketing officer** (**CMO**), **chief financial officer** (**CFO**), and **chief
    technology officer** (**CTO**) are assigned. As sales is one of the key topics
    in the company’s operations, regional directors report to the COO, and for each
    of them, between three and five sales specialists are assigned. Look for yourself
    – you have a tree in your mind right now! Its root is the CEO, which has four
    children (COO, CMO, CFO, and CTO), which can have further child nodes to create
    subsequent levels of the hierarchy. Sales specialists who no longer have any subordinates
    are named leaves.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更好地想象一棵树，看看一个稍微大一点的公司结构，在层级结构的顶端是**首席执行官**（**CEO**），向他分配**首席运营官**（**COO**）、**首席营销官**（**CMO**）、**首席财务官**（**CFO**）和**首席技术官**（**CTO**）。由于销售是公司运营中的关键主题之一，区域总监向COO汇报，并为他们中的每一个分配三到五个销售专家。你自己找找看——你现在脑中就有了一棵树！它的根是CEO，它有四个子节点（COO、CMO、CFO和CTO），这些子节点可以进一步创建后续层级的子节点。不再有任何下属的销售专家被称为叶子节点。
- en: Let’s briefly talk about the minimum and maximum numbers of children of a node.
    In general, such numbers are not limited, and each node can contain zero, one,
    two, three, or even more children. However, in practical applications, the number
    of children is often limited to two, as you will see soon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地讨论一下节点子节点的最小和最大数量。一般来说，这些数字没有限制，每个节点可以包含零个、一个、两个、三个甚至更多的子节点。然而，在实际应用中，子节点的数量通常限制为两个，正如你很快就会看到的。
- en: Implementation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: The C#-based implementation of a basic tree seems to be quite obvious and not
    complicated. To do so, you declare two classes, representing a single node and
    a whole tree, as described in this section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于C#的基本树实现似乎非常明显且不复杂。要做到这一点，你需要声明两个类，代表单个节点和整个树，如本节所述。
- en: Node
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点
- en: 'The first class is named `TreeNode` and is declared as a generic class to provide
    a developer with the ability to specify a type of data stored in each node. Thus,
    you can create a strongly typed solution, which eliminates the necessity of casting
    objects to target types. The code is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类被命名为`TreeNode`，它被声明为一个泛型类，以便为开发者提供指定每个节点存储的数据类型的可能性。因此，你可以创建一个强类型解决方案，这消除了将对象强制转换为目标类型的必要性。代码如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The class contains three properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个属性：
- en: The data stored in the node (`Data`)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点中存储的数据（`Data`）
- en: A reference to the parent node (`Parent`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对父节点的引用（`Parent`）
- en: A collection of references to child nodes (`Children`)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对子节点引用的集合（`Children`）
- en: Apart from the properties, the `TreeNode` class contains the `GetHeight` method,
    which returns the height of the node – that is, the distance from this node to
    the root node. The implementation of this method is very simple because it just
    uses a `while` loop to go up from the node until there is no parent element, which
    means that the root is reached.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性之外，`TreeNode`类还包含`GetHeight`方法，它返回节点的高度——即从该节点到根节点的距离。这个方法的实现非常简单，因为它仅仅使用一个`while`循环从节点向上移动，直到没有父元素，这意味着到达了根节点。
- en: Tree
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树
- en: 'The next necessary class is named `Tree`. It represents the whole tree, as
    follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必要的类被命名为`Tree`。它代表整个树，如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class contains only one property, `Root`. You can use this property to get
    access to the root node, and then you can use its `Children` property to obtain
    data of its child nodes. Then, you can take a look at each of them and get data
    of their child nodes, as well. By repeating such operations, you can get data
    from all nodes located in the tree.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该类只有一个属性，`Root`。你可以使用这个属性来访问根节点，然后你可以使用它的`Children`属性来获取其子节点的数据。然后，你可以查看每一个，并获取它们的子节点数据。通过重复这样的操作，你可以从树中所有节点获取数据。
- en: It is worth noting that both `TreeNode` and `Tree` classes are generic, and
    the same type is used in the case of these classes. For instance, if tree nodes
    should store `string` values, the `string` type should be used for instances of
    `Tree` and `TreeNode` classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`TreeNode`和`Tree`类都是泛型的，并且在这些类的情况下使用的是相同的类型。例如，如果树节点应该存储`string`类型的值，那么`string`类型应该用于`Tree`和`TreeNode`类的实例。
- en: Example – hierarchy of identifiers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 标识符层次结构
- en: 'Do you want to see how to use a tree in a C#-based application? Let’s take
    a look at our first example. The aim is to construct a tree with a few nodes,
    as shown in the following diagram. Only the group of nodes with a bolder border
    will be presented in the code. However, it is a good idea to adjust the code to
    construct the whole tree by yourself:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你想看看如何在基于C#的应用程序中使用树吗？让我们看看我们的第一个例子。目标是构建一个包含几个节点的树，如图所示。代码中只展示带有更粗边框的节点组。然而，自己调整代码来构建整个树是个好主意：
- en: "![Figure 7.2 – \uFEFFIllustration of the hierarchy of identifiers example](img/B18069_07_02.jpg)"
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 标识符层次结构示例的说明](img/B18069_07_02.jpg)'
- en: Figure 7.2 – Illustration of the hierarchy of identifiers example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 标识符层次结构示例的说明
- en: 'Here, each node stores an integer value, so `int` is the type used for both
    the `Tree` and `TreeNode` classes. The following code should be placed in the
    `Program.cs` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个节点存储一个整数值，因此`int`类型被用于`Tree`和`TreeNode`类。以下代码应放置在`Program.cs`文件中：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code looks quite simple, doesn’t it? At the beginning, a new instance of
    the `Tree` class is created and the root node is configured by creating a new
    instance of the `TreeNode` class and setting a value of the `Data` property to
    `100`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来相当简单，不是吗？一开始，创建了一个`Tree`类的新实例，并通过创建`TreeNode`类的新实例并设置`Data`属性的值为`100`来配置根节点。
- en: In the following lines, the child nodes of the root node are specified, namely
    the nodes with values equal to `50`, `1`, and `150`. For each of them, a value
    of the `Parent` property is set to a reference to the previously added root node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下行中，指定了根节点的子节点，即值为`50`、`1`和`150`的节点。对于每个节点，将`Parent`属性的值设置为先前添加的根节点的引用。
- en: 'The remaining part of the code shows how to add a child node for a given node,
    namely for the third child of the root node – that is, the node with a value equal
    to `150`. Here, only one node is added: the one with the value set to `30`. Of
    course, you need to specify a reference to the parent node, as well.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分展示了如何为给定节点添加子节点，即根节点的第三个子节点——即值为`150`的节点。这里只添加了一个节点：值为`30`的节点。当然，你还需要指定父节点的引用。
- en: That’s all! You created the first program that uses trees. Now, you can run
    it, but you will not see any output in the console. If you want to see how the
    data of nodes is organized, you can debug the program and see the values of variables
    while debugging.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！你已经创建了第一个使用树的程序。现在，你可以运行它，但在控制台你将看不到任何输出。如果你想查看节点数据的组织方式，你可以调试程序并查看调试时的变量值。
- en: Example – company structure
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 公司结构
- en: 'In the previous example, you saw how to use integer values as data stored in
    each node in a tree. However, it is also possible to store instances of user-defined
    classes in nodes. In this example, you will see how to create a tree presenting
    the structure of a company, divided into three main departments: development,
    research, and sales.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到了如何在树中的每个节点存储整数值作为数据。然而，也可以在节点中存储用户定义类的实例。在这个例子中，你将看到如何创建一个表示公司结构的树，该树分为三个主要部门：开发、研究和销售。
- en: Within each department, there can be another structure, such as in the case
    of the development team. Here, **John Smith** is head of development. He is a
    boss for **Chris Morris**, who is a manager for two junior developers, **Eric
    Green** and **Ashley Lopez**. The latter is also a supervisor of **Emily Young**,
    who is a developer intern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个部门内，可能存在另一种结构，例如在开发团队的情况下。在这里，**约翰·史密斯**是开发团队的负责人。他是**克里斯·莫里斯**的老板，**克里斯·莫里斯**是两位初级开发人员**埃里克·格林**和**阿什莉·洛佩兹**的经理。后者也是**艾米丽·杨**的导师，**艾米丽·杨**是开发实习生。
- en: 'An example tree is shown in the following diagram:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图中展示了示例树：
- en: "![Figure 7.3 – \uFEFFIllustration of the company structure example](img/B18069_07_03.jpg)"
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 公司结构示例的说明](img/B18069_07_03.jpg)'
- en: Figure 7.3 – Illustration of the company structure example
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 公司结构示例的说明
- en: 'As you can see, each node should store more information than just an integer
    value. There should be a name and a role. Such data is stored as values of properties
    in an instance of the `Person` record, which is shown next:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个节点应该存储比仅仅整数值更多的信息。应该有一个姓名和角色。此类数据作为`Person`记录实例的属性值存储，如下所示：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Apart from creating a new record, it is also necessary to add some code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建新的记录外，还需要添加一些代码：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first line, a new instance of the `Tree` class is created. It is worth
    mentioning that the `Person` record is used as a type specified while creating
    new instances of the `Tree` and `TreeNode` classes. Thus, you can easily store
    more than one simple data type for each node. The remaining lines of code look
    similar to the first example for basic trees. Here, you also specify the root
    node (for the `Chief Executive Officer` role), then configure its child elements
    (`John Smith`, `Alice Batman`, and `Lily Smith`), and set a child node for one
    of the existing nodes, namely the node for the `Head of` `Sales` role.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，创建了一个新的`Tree`类实例。值得注意的是，在创建`Tree`和`TreeNode`类的新实例时使用了`Person`记录作为指定的类型。因此，您可以轻松地为每个节点存储多个简单数据类型。代码的其余部分与第一个基本树的示例类似。在这里，您也指定了根节点（对于`Chief
    Executive Officer`角色），然后配置其子元素（`John Smith`、`Alice Batman`和`Lily Smith`），并为现有节点之一设置子节点，即`Head
    of Sales`角色的节点。
- en: 'Does it look simple and straightforward? In the next section, you will see
    a more restricted, but very important and well-known variant of trees: a binary
    tree.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来简单直接吗？在下一节中，您将看到一种更受限制，但非常重要且广为人知的树变体：二叉树。
- en: Binary trees
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: 'Generally speaking, each node in a basic tree can contain any number of children.
    However, in the case of **binary trees**, **a node cannot contain more than two
    children**. It means that **it can contain zero,****one, or two child nodes**.
    Such a requirement has an important impact on the shape of a binary tree, as shown
    in the following two diagrams presenting binary trees:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，基本树中的每个节点可以包含任意数量的子节点。然而，在**二叉树**的情况下，**一个节点不能包含超过两个子节点**。这意味着**它可以包含零个、一个或两个子节点**。这样的要求对二叉树的形状有重要影响，如下两个图所示，它们展示了二叉树：
- en: "![Figure 7.4 – \uFEFFIllustration of binary trees](img/B18069_07_04.jpg)"
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 二叉树的示意图](img/B18069_07_04.jpg)'
- en: Figure 7.4 – Illustration of binary trees
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 二叉树的示意图
- en: As already mentioned, a node in a binary tree can contain at most two children.
    For this reason, they are referred to as the **left child** and the **right child**.
    In the case of the binary tree shown on the left-hand side of the preceding diagram,
    node **21** has two children, namely **68** as the left child and **12** as the
    right child, while node **100** has only a left child.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，二叉树中的一个节点最多可以包含两个子节点。因此，它们被称为**左子节点**和**右子节点**。在前一个图中左侧显示的二叉树中，节点**21**有两个子节点，即作为左子节点的**68**和作为右子节点的**12**，而节点**100**只有一个左子节点。
- en: Traversal
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历
- en: 'Have you thought about how you can iterate through all the nodes in a tree?
    How can you specify an order of nodes during **traversal** of a tree? There are
    three common approaches, namely **pre-order**, **in-order**, and **post-order**,
    as shown next:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否想过如何遍历树中的所有节点？您如何在树的遍历过程中指定节点的顺序？有三种常见的方法，即**先序**、**中序**和**后序**，如下所示：
- en: '![Figure 7.5 – Pre-order, in-order, and post-order traversal](img/B18069_07_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 先序、中序和后序遍历](img/B18069_07_05.jpg)'
- en: Figure 7.5 – Pre-order, in-order, and post-order traversal
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 先序、中序和后序遍历
- en: As you can see in the diagram, there are visible differences between the approaches.
    However, do you have any idea how you can apply pre-order, in-order, or post-order
    traversals for binary trees? Let’s explain all of these approaches in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图中所见，这些方法之间存在明显的差异。然而，您是否有任何想法如何应用二叉树的先序、中序或后序遍历？让我们详细解释所有这些方法。
- en: Pre-order
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先序
- en: If you want to traverse a binary tree with the **pre-order** approach, you first
    visit the root node. Then, you visit the left child. Finally, the right child
    is visited. Of course, such a rule does not apply only to the root node, but to
    any node in a tree. For this reason, you can understand the order of pre-order
    traversal as **first visiting the current node, then its left child (the whole
    left subtree using the pre-order approach recursively), and finally its right
    child (the right subtree in a** **similar way)**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用**先序**方法遍历二叉树，您首先访问根节点。然后，您访问左子节点。最后，访问右子节点。当然，这样的规则不仅适用于根节点，也适用于树中的任何节点。因此，您可以理解先序遍历的顺序为**首先访问当前节点，然后是其左子节点（使用先序方法递归地遍历整个左子树），最后是其右子节点（以类似的方式遍历右子树）**。
- en: The explanation can sound a bit complicated, so let’s take a look at a simple
    example regarding the tree shown on the left of the preceding diagram. First,
    the root node (that is, **1**) is visited. Then, you analyze its left child node.
    For this reason, the next visited node is the current node, **9**. The next step
    is the pre-order traversal of its left child. Thus, **5** is visited. As this
    node does not contain any children, you can return to the stage of traversing
    when **9** is the current node. It has already been visited, as has its left child
    node, so it is time to proceed to its right child. Here, you first visit the current
    node, **6**, and follow to its left child, **3**. You can apply the same rules
    to continue traversing the tree. The final order is **1**, **9**, **5**, **6**,
    **3**, **4**, **2**, **7**, **8**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解释可能听起来有点复杂，所以让我们看看前一个图中左侧所示树的简单示例。首先，访问根节点（即 **1**）。然后，分析它的左子节点。因此，下一个访问的节点是当前节点，**9**。下一步是它的左子节点的中序遍历。因此，访问
    **5**。由于这个节点没有子节点，你可以回到当前节点是 **9** 的遍历阶段。它已经被访问，以及它的左子节点，所以现在是时候继续到它的右子节点。在这里，你首先访问当前节点，**6**，然后跟随到它的左子节点，**3**。你可以应用相同的规则继续遍历树。最终的顺序是
    **1**，**9**，**5**，**6**，**3**，**4**，**2**，**7**，**8**。
- en: 'If it still sounds a bit confusing, the following diagram should remove any
    doubts:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然有点令人困惑，以下图应该可以消除任何疑问：
- en: '![Figure 7.6 – Detailed diagram of pre-order traversal](img/B18069_07_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 前序遍历的详细图](img/B18069_07_06.jpg)'
- en: Figure 7.6 – Detailed diagram of pre-order traversal
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 前序遍历的详细图
- en: 'The diagram presents the following steps of the pre-order traversal with additional
    indicators: **C** for the **current node**, **L** for the **left child**, and
    **R** for the **right child**.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了前序遍历的以下步骤，并增加了额外的指示：**C** 代表 **当前节点**，**L** 代表 **左子节点**，**R** 代表 **右子节点**。
- en: In-order
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中序
- en: 'The second traversal mode is called **in-order**. It differs from the pre-order
    approach in the order that nodes are visited: **the left child, the current node,
    and then the** **right child**.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种遍历模式称为 **中序**。它与前序方法的不同之处在于访问节点的顺序：**先访问左子节点，然后是** **当前节点**，最后是 **右子节点**。
- en: If you take a look at the example shown in the diagram with all three traversal
    modes, you can see that the first visited node is **5**. Why? At the beginning,
    the root node is analyzed, but it is not visited because the in-order traversal
    starts with the left child node. Thus, it analyzes node **9**, but it also has
    a left child, **5**, so you proceed to this node. As this node does not have any
    children, the current node (**5**) is visited. Then, you return to the step when
    the current node is **9**, and, as its left child was already visited, you also
    visit the current node. Next, you follow to the right child, but it has a left
    child, **3**, which should be visited first. According to the same rules, you
    visit the remaining nodes in the binary tree. The final order is **5**, **9**,
    **3**, **6**, **1**, **4**, **7**, **8**, **2**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看图中展示的包含所有三种遍历模式的示例，你可以看到第一个访问的节点是 **5**。为什么？一开始，根节点被分析，但并未访问，因为中序遍历从左子节点开始。因此，它分析了节点
    **9**，但该节点也有一个左子节点，**5**，所以你继续到这个节点。由于这个节点没有子节点，当前节点（**5**）被访问。然后，你回到当前节点是 **9**
    的步骤，由于它的左子节点已经被访问，你也访问了当前节点。接下来，你跟随到右子节点，但该节点有一个左子节点，**3**，它应该首先被访问。根据相同的规则，你按照相同的规则访问二叉树中的剩余节点。最终的顺序是
    **5**，**9**，**3**，**6**，**1**，**4**，**7**，**8**，**2**。
- en: Post-order
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后序
- en: 'The last traversal mode is named **post-order** and supports the following
    order of node traversal: **the left child, the right child, and then the** **current
    node**.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种遍历模式称为 **后序**，支持以下节点遍历顺序：**先遍历左子节点，然后是右子节点，最后是** **当前节点**。
- en: Let’s analyze the post-order example shown on the right-hand side of the diagram.
    At the beginning, the root node is analyzed but it is not visited because the
    post-order traversal starts with the left child node. Thus, you proceed to node
    **9**, then **5**, which you visit first. Next, you need to analyze the right
    child of node **9**. However, node **6** has the left child (**3**), which should
    be visited earlier. For this reason, after **5**, you visit **3**, and then **6**,
    followed by **9**. What is interesting is that the root node of the binary tree
    is visited at the end. The final order is **5**, **3**, **6**, **9**, **8**, **7**,
    **2**, **4**, **1**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析图右侧显示的后序遍历示例。一开始，分析根节点，但由于后序遍历从左子节点开始，所以它没有被访问。因此，你继续到节点 **9**，然后是 **5**，你首先访问它。接下来，你需要分析节点
    **9** 的右子节点。然而，节点 **6** 有一个左子节点（**3**），它应该先被访问。因此，在 **5** 之后，你访问 **3**，然后是 **6**，接着是
    **9**。有趣的是，二叉树的根节点是在最后被访问的。最终的顺序是 **5**，**3**，**6**，**9**，**8**，**7**，**2**，**4**，**1**。
- en: What about the performance?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: 'If you want to check whether a binary tree contains a given value, you need
    to check each node, traversing the tree using one of three available modes: pre-order,
    in-order, or post-order. This means that the lookup time is linear, namely *O(n)*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查二叉树是否包含某个给定的值，你需要检查每个节点，通过三种可用的模式之一遍历树：前序、中序或后序。这意味着查找时间是线性的，即 *O(n)*。
- en: After this short introduction, let’s proceed to the C#-based implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们继续进行基于 C# 的实现。
- en: Implementation
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation of a binary tree is simple, especially if you use the already
    described code for the basic tree. Let’s start with a class representing a node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树的实施很简单，特别是如果你使用已经描述的基本树代码。让我们从一个表示节点的类开始。
- en: Node
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点
- en: 'A node in a binary tree is represented by an instance of `BinaryTreeNode`,
    which inherits from the `TreeNode` generic class. In the `BinaryTreeNode` class,
    it is necessary to hide the `Children` definition from the base class, as well
    as declare two properties, `Left` and `Right`, which represent both possible children
    of a node. The relevant part of the code is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树中的节点由 `BinaryTreeNode` 类的实例表示，该类继承自 `TreeNode` 泛型类。在 `BinaryTreeNode` 类中，有必要隐藏从基类继承的
    `Children` 定义，并声明两个属性，`Left` 和 `Right`，它们代表节点的两个可能的子节点。相关代码如下：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Moreover, you need to ensure that the array with child nodes contains exactly
    two items, initially set to `null`. Thus, if you want to add a child node, a reference
    to it should be placed as the first or the second element of the array from the
    `Children` property. Therefore, such an array always has exactly two elements,
    and you can access the first or the second one without any exception. If such
    an element is set to any node, a reference to it is returned. Otherwise, `null`
    is returned.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要确保包含子节点的数组恰好包含两个项目，最初设置为 `null`。因此，如果你想添加一个子节点，应该将其引用放置在 `Children` 属性数组的第一个或第二个元素中。因此，这样的数组始终恰好有两个元素，你可以无异常地访问第一个或第二个元素。如果设置了这样的元素，则返回其引用。否则，返回
    `null`。
- en: Tree
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树
- en: 'The next necessary class is named `BinaryTree`. It represents the whole binary
    tree. By using the generic class, you can easily specify the type of data stored
    in each node. The first part of the implementation of the `BinaryTree` class is
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必要的类被命名为 `BinaryTree`。它代表整个二叉树。通过使用泛型类，你可以轻松指定每个节点存储的数据类型。`BinaryTree` 类的实现的第一部分如下：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `BinaryTree` class contains two properties:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryTree` 类包含两个属性：'
- en: '`Root` indicates the root node (instance of the `BinaryTreeNode` class)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Root` 表示根节点（`BinaryTreeNode` 类的实例）'
- en: '`Count` stores the total number of nodes placed in the tree'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count` 存储放置在树中的节点总数'
- en: 'Of course, these are not the only members of the class because it is also equipped
    with a set of methods regarding traversing the tree. The first traversal method
    is `TraversePreOrder` method is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些并不是类的唯一成员，因为它还配备了一套关于遍历树的方法。第一个遍历方法是 `TraversePreOrder` 方法，如下所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The method takes two parameters: the current node (`node`) and the list of
    already visited nodes (`result`). The recursive implementation is very simple.
    First, you check whether the node exists by ensuring that the parameter is not
    equal to `null`. Then, you add the current node to the collection of visited nodes,
    start the same traversal method for the left child, and then start it for the
    right child.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：当前节点（`node`）和已访问节点的列表（`result`）。递归实现非常简单。首先，你检查节点是否存在，通过确保参数不等于`null`来确保。然后，你将当前节点添加到已访问节点的集合中，对左子节点启动相同的遍历方法，然后对右子节点启动。
- en: 'Similar implementation is possible for the `TraverseInOrder` method, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的实现也适用于`TraverseInOrder`方法，如下所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you call the `TraverseInOrder` method for the left child, add the current
    node to the list of visited nodes, and start the in-order traversal for the right
    child.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你为左子节点调用`TraverseInOrder`方法，将当前节点添加到已访问节点的列表中，然后对右子节点启动中序遍历。
- en: 'The next method is related to the **post-order** traversal mode, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法与**后序**遍历模式相关，如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code is similar to the already described methods, but, of course, another
    order of visiting nodes is applied. Here, you start with the left child, then
    you visit the right child, followed by adding the current node to the list of
    visited nodes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与已描述的方法类似，但当然，应用了另一种访问节点的顺序。这里，你从左子节点开始，然后访问右子节点，接着将当前节点添加到已访问节点的列表中。
- en: 'Finally, let’s add a public method for traversing the tree in various modes,
    which calls the private methods presented earlier. The relevant code is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个公共方法来以各种模式遍历树，该方法调用前面提到的私有方法。相关代码如下：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The method takes only one parameter, namely a value of the `TraversalEnum`
    enumeration, which chooses the proper mode from pre-order, in-order, and post-order.
    The `Traverse` method uses a `switch` statement to call a suitable private method,
    depending on the value of the parameter. The mentioned enumeration is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法仅接受一个参数，即`TraversalEnum`枚举的值，它从先序、中序和后序中选择适当的模式。`Traverse`方法使用`switch`语句根据参数的值调用一个合适的私有方法。所提到的枚举如下：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: public int GetHeight() => Root != null
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: public int GetHeight() => Root != null
- en: '? Traverse(TraversalEnum.PreOrder)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '? Traverse(TraversalEnum.PreOrder)'
- en: .Max(n => n.GetHeight())
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: .Max(n => n.GetHeight())
- en: ': 0;'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ': 0;'
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: BinaryTree<string> tree = GetTree();
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTree<string> tree = GetTree();
- en: BinaryTreeNode<string>? node = tree.Root;
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTreeNode<string>? node = tree.Root;
- en: while (node != null)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: while (node != null)
- en: '{'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (node.Left != null && node.Right != null)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点左侧和右侧都不为空
- en: '{'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine(node.Data);
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(node.Data);
- en: node = Console.ReadKey(true).Key switch
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: node = Console.ReadKey(true).Key switch
- en: '{'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ConsoleKey.Y => node.Left,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleKey.Y => node.Left,
- en: ConsoleKey.N => node.Right,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleKey.N => node.Right,
- en: _ => node
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: _ => node
- en: '};'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine(node.Data);
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(node.Data);
- en: node = null;
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: node = null;
- en: '}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: BinaryTree<string> GetTree()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTree<string> GetTree()
- en: '{'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: BinaryTree<string> tree = new();
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTree<string> tree = new();
- en: tree.Root = new BinaryTreeNode<string>()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: tree.Root = new BinaryTreeNode<string>()
- en: '{'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Data = "Do you have an experience
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Data = "Do you have an experience
- en: in app development?",
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: in app development?",
- en: Children =
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Children =
- en: '['
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: new BinaryTreeNode<string>()
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: new BinaryTreeNode<string>()
- en: '{'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Data = "Have you worked as a developer
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Data = "Have you worked as a developer
- en: for 5+ years?",
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: for 5+ years?",
- en: Children =
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Children =
- en: '['
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: new() { Data = "Apply as
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: new() { Data = "Apply as
- en: a senior developer" },
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一名高级开发者" },
- en: new() { Data = "Apply as
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: new() { Data = "Apply as
- en: a middle developer" }
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一名中级开发者" }
- en: ']'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new BinaryTreeNode<string>()
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: new BinaryTreeNode<string>()
- en: '{'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Data = "Have you completed a university?",
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Data = "Have you completed a university?",
- en: Children =
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Children =
- en: '['
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: new() { Data = "Apply as
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: new() { Data = "Apply as
- en: a junior developer" },
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一名初级开发者" },
- en: new BinaryTreeNode<string>()
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: new BinaryTreeNode<string>()
- en: '{'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Data = "Will you find some time
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Data = "Will you find some time
- en: during the semester?",
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: during the semester?",
- en: Children =
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Children =
- en: '['
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: new() { Data = "Apply for
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: new() { Data = "Apply for
- en: long-time internship" },
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 长期实习" },
- en: new() { Data = "Apply for
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: new() { Data = "Apply for
- en: summer internship" }
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: summer internship" }
- en: ']'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '};'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: tree.Count = 9;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: tree.Count = 9;
- en: return tree;
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: return tree;
- en: '}'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: public class BinarySearchTree<T>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: public class BinarySearchTree<T>
- en: ': BinaryTree<T>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ': BinaryTree<T>'
- en: 'where T : IComparable'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'where T : IComparable'
- en: '{'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: public bool Contains(T data)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: public bool Contains(T data)
- en: '{'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: BinaryTreeNode<T>? node = Root;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTreeNode<T>? node = Root;
- en: while (node != null)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: while (node != null)
- en: '{'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int result = data.CompareTo(node.Data);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: int result = data.CompareTo(node.Data);
- en: if (result == 0) { return true; }
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果为0，则返回true；
- en: else if (result < 0) { node = node.Left; }
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: else if (result < 0) { node = node.Left; }
- en: else { node = node.Right; }
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: else { node = node.Right; }
- en: '}'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: public void Add(T data)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: public void Add(T data)
- en: '{'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: BinaryTreeNode<T>? parent = GetParentForNewNode(data);
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTreeNode<T>? parent = GetParentForNewNode(data);
- en: BinaryTreeNode<T> node = new()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTreeNode<T> node = new()
- en: '{'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Data = data,
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Data = data,
- en: Parent = parent
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Parent = parent
- en: '};'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: if (parent == null)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: if (parent == null)
- en: '{'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Root = node;
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Root = node;
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (data.CompareTo(parent.Data) < 0)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: else if (data.CompareTo(parent.Data) < 0)
- en: '{'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: parent.Left = node;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: parent.Left = node;
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: parent.Right = node;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: parent.Right = node;
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Count++;
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Count++;
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: private BinaryTreeNode<T>? GetParentForNewNode(T data)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: private BinaryTreeNode<T>? GetParentForNewNode(T data)
- en: '{'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: BinaryTreeNode<T>? current = Root;
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTreeNode<T>? current = Root;
- en: BinaryTreeNode<T>? parent = null;
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryTreeNode<T>? parent = null;
- en: while (current != null)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: while (current != null)
- en: '{'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: parent = current;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: parent = current;
- en: int result = data.CompareTo(current.Data);
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: int result = data.CompareTo(current.Data);
- en: if (result == 0) { throw new ArgumentException(
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: if (result == 0) { throw new ArgumentException(
- en: $"The node {data} already exists."); }
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: $"节点 {data} 已存在。"); }
- en: else if (result < 0) { current = current.Left; }
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: else if (result < 0) { current = current.Left; }
- en: else { current = current.Right; }
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: else { current = current.Right; }
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return parent;
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: return parent;
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'public void Remove. The implementation of this private method is more complicated
    and is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: public void Remove. 这个私有方法的实现更为复杂，具体如下：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At the beginning, the method checks whether the current node (the `node` parameter)
    exists. If not, you exit from the method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，方法检查当前节点（`node`参数）是否存在。如果不存在，则退出方法。
- en: Then, the `Remove` method tries to find the node to remove. That is achieved
    by comparing the value of the current node with the value for removal and calling
    the `Remove` method recursively for either the left or right subtree of the current
    node.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Remove`方法尝试找到要删除的节点。这是通过比较当前节点的值与要删除的值，并对当前节点的左子树或右子树递归调用`Remove`方法来实现的。
- en: 'The most interesting operations are performed in the following part of the
    method. Here, you need to handle four scenarios of node removal, namely the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中最有趣的操作在以下部分进行。在这里，你需要处理四种节点删除场景，如下所示：
- en: Removing a leaf node
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除叶子节点
- en: Removing a node with only a left child
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除只有一个左子节点的节点
- en: Removing a node with only a right child
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除只有一个右子节点的节点
- en: Removing a node with both left and right children
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除既有左子节点又有右子节点的节点
- en: In the case of **removing a leaf node**, you just update a reference to the
    deleted node in the parent element. Therefore, there will be no reference from
    the parent node to the deleted node, and it cannot be reached while traversing
    the tree.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除叶子节点**的情况，你只需更新父元素中删除节点的引用。因此，将不会有从父节点到删除节点的引用，在遍历树时无法访问到它。'
- en: '**Removing a node with only a left child** is also simple because you only
    need to replace a reference to the deleted node (in the parent element) with the
    node that is a left child of the deleted node. This scenario is shown in the following
    diagram, which presents how to remove node **80** with only the left child:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除只有一个左子节点的节点**也很简单，因为你只需要将删除节点的引用（在父元素中）替换为删除节点的左子节点。以下图示展示了如何删除只有一个左子节点的节点**80**：'
- en: '![Figure 7.10 – Removing a node with only a left child from a BST](img/B18069_07_10.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 从二叉搜索树中删除只有一个左子节点的节点](img/B18069_07_10.jpg)'
- en: Figure 7.10 – Removing a node with only a left child from a BST
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 从二叉搜索树中删除只有一个左子节点的节点
- en: The case of **removing a node with only a right child** is very similar to the
    second case. Thus, you just replace a reference to the deleted node (in the parent
    element) with the node that is a right child of the deleted node.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除只有一个右子节点的节点**的情况与第二种情况非常相似。因此，你只需将删除节点的引用（在父元素中）替换为删除节点的右子节点。'
- en: 'All those three cases are handled in the code in a similar way, by calling
    the `ReplaceInParent` auxiliary method, the code of which is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这三种情况都在代码中以类似的方式处理，通过调用`ReplaceInParent`辅助方法，其代码如下：
- en: '[PRE20]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The method takes two parameters: the node for removal (`node`) and the node
    that should replace it in the parent node (`newNode`). For this reason, if you
    want to remove a leaf node, you just pass `null` as the second parameter because
    you do not want to replace the removed node with anything else. In the case of
    removing a node with only one child, you pass a reference to the left or right
    child.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：要删除的节点（`node`）和应在父节点中替换它的节点（`newNode`）。因此，如果你想删除一个叶子节点，只需将第二个参数传递为`null`，因为你不想用任何其他东西替换被删除的节点。在删除只有一个子节点的情况下，你传递左子节点或右子节点的引用。
- en: If the node for removal is not the root, you check whether it is the left child
    of the parent. If so, a proper reference is updated. It means that the new node
    is set as the left child of the parent node of the node for removal. In a similar
    way, the method handles the scenario when the node for removal is the right child
    of the parent. If the node for removal is the root, the node for replacing is
    set as the root. At the end, you check whether the new node is not equal to `null`.
    It means that you are not removing a leaf node. In such a case, you set a value
    of the `Parent` property to indicate that the new node should have the same parent
    as the node for removal.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被删除的节点不是根节点，你需要检查它是否是父节点的左子节点。如果是，则更新适当的引用。这意味着新节点被设置为被删除节点的父节点的左子节点。以类似的方式，该方法处理被删除节点是父节点的右子节点的情况。如果被删除的节点是根节点，则替换节点被设置为根节点。最后，你检查新节点是否不等于`null`。这意味着你并没有删除一个叶子节点。在这种情况下，你设置`Parent`属性的值以指示新节点应该具有与被删除节点相同的父节点。
- en: 'A bit more complicated scenario is `Remove` method recursively for the found
    node. The relevant part of the code is shown in the following code snippet, copied
    here from the `Remove` private method for your convenience:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的情况是`Remove`方法递归地应用于找到的节点。相关代码片段如下所示，此代码片段是从`Remove`私有方法中复制出来的，以方便你阅读：
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last auxiliary method is named `FindMinimumInSubtree` and is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的辅助方法命名为`FindMinimumInSubtree`，如下所示：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method takes the root of the subtree, where the minimum value should be
    found, as the parameter. Within the method, a `while` loop is used to get the
    leftmost element. When there is no left child, the current value of the `node`
    variable is returned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受子树的根节点作为参数，其中应找到最小值。在方法内部，使用`while`循环来获取最左边的元素。当没有左子节点时，返回`node`变量的当前值。
- en: Where you can find more information?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在哪里找到更多信息？
- en: There is a lot of information about BSTs in books, research papers, as well
    as over the internet. Howe[ver, the presented implementation of a BST is ba](https://en.wikipedia.org/wiki/Binary_search_tree)sed
    on the code shown at https://en.wikipedia.org/wiki/Binary_search_tree, where you
    can also find more information about this data structure. I strongly encourage
    you to be curious about various data structures and algorithms and to broaden
    your knowledge.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍、研究论文以及互联网上关于BST的信息有很多。然而，所提供的BST实现是基于在https://en.wikipedia.org/wiki/Binary_search_tree中显示的代码，在那里你还可以找到有关此数据结构的更多信息。我强烈建议你对各种数据结构和算法保持好奇心，并拓宽你的知识面。
- en: 'The preceding code does not look very difficult, does it? However, how does
    it work in practice? Let’s take a look at a diagram depicting the removal of a
    node with two children:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来并不复杂，对吧？然而，它在实际中是如何工作的呢？让我们看看一个表示删除具有两个子节点的节点的图表：
- en: '![Figure 7.11 – Removing a node with two children in a BST](img/B18069_07_11.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 在BST中删除具有两个子节点的节点](img/B18069_07_11.jpg)'
- en: Figure 7.11 – Removing a node with two children in a BST
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 在BST中删除具有两个子节点的节点
- en: The diagram shows how to remove the node with **40** as the value. To do so,
    you need to find the successor. It is the node with the minimum value in the right
    subtree of the node for removal. The successor is node **42**, which replaces
    node **40**.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了如何删除值为**40**的节点。为此，你需要找到后继节点。它是被删除节点的右子树中具有最小值的节点。后继节点是**42**，它替换了**40**。
- en: Example – BST visualization
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – BST可视化
- en: While reading the section regarding BSTs, you learned a lot about this data
    structure. So, it is high time to create an example program to see this variant
    of trees in action. The application will show you how to create a BST, add some
    nodes (both manually and using the previously presented method for insertion),
    remove nodes, traverse the tree, as well as visualize the tree in the console.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读有关二叉搜索树（BSTs）的部分时，你学到了很多关于这种数据结构的知识。因此，现在是时候创建一个示例程序来查看这种树的变体在实际中的表现了。该应用程序将向你展示如何创建一个BST，添加一些节点（手动添加和使用之前介绍的插入方法），删除节点，遍历树，以及在控制台中可视化树。
- en: 'At the beginning, a new tree (with nodes storing integer values) is prepared
    by creating a new instance of the `BinarySearchTree` class. It is configured manually
    by adding three nodes, together with indicating proper references for children
    and parent elements. The relevant part of the code is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，通过创建 `BinarySearchTree` 类的新实例来准备一个新的树（存储整数值的节点）。通过手动添加三个节点，并指示适当的子元素和父元素引用来配置。相关代码如下：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you use the `Add` method to add some nodes to the tree and visualize
    the current state of the tree using the `Visualize` method, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用 `Add` 方法向树中添加一些节点，并使用 `Visualize` 方法可视化当前树的状态，如下所示：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s add five more nodes with the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加五个节点，以下代码如下：
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next set of operations is related to the removal of various nodes from
    the tree, together with visualization of particular changes. The part of the code
    is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的操作集与从树中删除各种节点以及可视化特定更改有关。相关代码如下：
- en: '[PRE26]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At the end, all three traversal modes are presented. The suitable code is as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，展示了三种遍历模式。相应的代码如下：
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Another interesting task is the development of a tree visualization in the console.
    Such a feature is really useful because it allows a comfortable and fast way of
    observing the tree without the necessity of debugging the application in the IDE
    and expanding the following elements in the tooltip with the current values of
    variables. However, presenting a tree in the console is not a trivial task. Fortunately,
    you do not need to worry about it because you will learn how to implement such
    a feature in this section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的任务是在控制台中开发树的可视化。这样的功能非常有用，因为它允许舒适且快速地观察树，无需在IDE中调试应用程序并展开工具提示中的以下元素以显示变量的当前值。然而，在控制台中展示树不是一个简单任务。幸运的是，你无需担心这一点，因为在本节中你将学习如何实现此功能。
- en: 'First, let’s take a look at the `Visualize` method:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `Visualize` 方法：
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The method takes two parameters, namely an instance of the `BinarySearchTree`
    class representing the whole tree, and a caption that should be shown above the
    visualization. Within the method, an array with characters that should be presented
    in the console is initialized using the `Initialize` auxiliary method, shown a
    bit later. Then, you call the `VisualizeNode` recursive method to fill various
    parts of the array with data regarding particular nodes existing in the tree.
    At the end, the caption and the board (represented by the array) are written in
    the console.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数，即代表整个树的 `BinarySearchTree` 类的实例，以及应在可视化上方显示的标题。在方法内部，使用 `Initialize`
    辅助方法初始化一个字符数组，该数组应在控制台中显示，稍后展示。然后，调用 `VisualizeNode` 递归方法将特定节点在树中的数据填充到数组的各个部分。最后，将标题和板（由数组表示）写入控制台。
- en: 'The `Initialize` method creates the aforementioned array, as presented in the
    following code snippet:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize` 方法创建了上述数组，如下代码片段所示：'
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The two-dimensional array contains the number of rows equal to the height of
    the tree multiplied by `2` to have space also for lines connecting nodes with
    parents. The number of columns is calculated according to the formula *columnwidth*
    * 2height - 1, where *columnwidth* is the `ColumnWidth` constant value and *height*
    is the height of the tree.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组包含的行数等于树的高度乘以 `2`，以便也有空间用于连接节点与父节点的线条。列数根据公式 *columnwidth* * 2^height -
    1 计算，其中 *columnwidth* 是 `ColumnWidth` 常量值，*height* 是树的高度。
- en: 'These values can be simpler to understand if you take a look at the result:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下结果，这些值可能更容易理解：
- en: "![Figure 7.12 – \uFEFFScreenshot of the BST visualization example](img/B18069_07_12.jpg)"
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – BST可视化示例的截图](img/B18069_07_12.jpg)'
- en: Figure 7.12 – Screenshot of the BST visualization example
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – BST可视化示例的截图
- en: 'In the `Visualize` method, `VisualizeNode` is called. Are you interested to
    learn about how it works and how you can present not only the values of nodes
    but also lines? If so, let’s take a look at its code, which is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Visualize` 方法中，调用了 `VisualizeNode`。你对了解它是如何工作的以及如何不仅展示节点值还展示线条感兴趣吗？如果是这样，让我们看看它的代码，如下所示：
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `VisualizeNode` method takes five parameters, including the current node
    for visualization (`node`), the index of a row (`row`), and the index of a column
    (`column`). Within the method, there is a check for whether the current node exists.
    If it does, the value of the node is obtained as a `char` array, the margin is
    calculated, and the `char` array (with a character-based representation of the
    value) is written in the buffer (the `console` variable) within a `for` loop.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualizeNode`方法接受五个参数，包括用于可视化的当前节点(`node`)，行的索引(`row`)和列的索引(`column`)。在方法内部，有一个检查以确定当前节点是否存在。如果存在，则获取节点的值作为一个`char`数组，计算边距，并在`for`循环中将带有值字符表示的`char`数组写入缓冲区（`console`变量）。'
- en: In the following lines of code, the `VisualizeNode` method is called for the
    left and right child nodes of the current node. Of course, you need to adjust
    the index of the row (by adding `2`) and the index of the column (by adding or
    subtracting the calculated value).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码行中，对当前节点的左右子节点调用了`VisualizeNode`方法。当然，你需要调整行索引（通过添加`2`）和列索引（通过添加或减去计算出的值）。
- en: 'At the end, lines are drawn by calling the `DrawLineLeft` and `DrawLineRight`
    methods. The first is presented in the following code snippet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用`DrawLineLeft`和`DrawLineRight`方法来绘制线条。第一个在以下代码片段中展示：
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The method also takes five parameters:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法也接受五个参数：
- en: The current node for which the line should be drawn (`node`)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该绘制线的当前节点(`node`)
- en: The index of a row (`row`)
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行的索引(`row`)
- en: The index of a column (`column`)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列的索引(`column`)
- en: An array as a screen buffer (`console`)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为屏幕缓冲区的数组(`console`)
- en: A delta value calculated in the `VisualizeNode` method
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`VisualizeNode`方法中计算出的增量值
- en: At the beginning, you check whether the current node contains a left child because
    only then is it necessary to draw the left part of the line. If so, you calculate
    the start (`sci`, which stands for *start column index*) and end (`eci` as *end
    column index*) indices of columns and fill the proper elements of the array with
    dashes. At the end, a plus sign is added to the array in the place where the drawn
    line will be connected with the right line of another element and on the other
    side of the line.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，你检查当前节点是否包含左子节点，因为只有在这种情况下才需要绘制线的左侧部分。如果是这样，你计算列的起始(`sci`，代表*起始列索引*)和结束(`eci`作为*结束列索引*)索引，并用破折号填充数组的适当元素。最后，在绘制线条将与另一个元素的右侧线连接的地方以及线的另一侧添加一个加号。
- en: 'In almost the same way, you draw the right line for the current node. Of course,
    you need to adjust the code regarding calculating column start and end indices.
    The final version of the code of the `DrawLineRight` method is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎以相同的方式，你为当前节点绘制右侧线。当然，你需要调整有关计算列起始和结束索引的代码。`DrawLineRight`方法的最终代码如下：
- en: '[PRE32]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At the end, let’s see the `Draw` method that shows the board in the console.
    It just iterates through all elements of the array and writes them in the console,
    as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看在控制台中显示棋盘的`Draw`方法。它只是遍历数组的所有元素并将它们写入控制台，如下所示：
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That’s all! You wrote the whole code necessary to build the project, launch
    the program, and see it in action. Just after launching, you will see the first
    BST, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！你已经写下了构建项目、启动程序并看到其运行的整个代码。启动后，你会看到第一个BST，如下所示：
- en: "![Figure 7.13 – \uFEFFScreenshot of the \uFEFFBST visualization example, step\
    \ 1](img/B18069_07_13.jpg)"
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – BST可视化示例截图，步骤1](img/B18069_07_13.jpg)'
- en: Figure 7.13 – Screenshot of the BST visualization example, step 1
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – BST可视化示例截图，步骤1
- en: 'After adding the next two nodes, `75` and `125`, the BST looks a bit different:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下一个两个节点`75`和`125`后，BST看起来略有不同：
- en: "![Figure 7.14 – \uFEFFScreenshot of the BST visualization example, step 2](img/B18069_07_14.jpg)"
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – BST可视化示例截图，步骤2](img/B18069_07_14.jpg)'
- en: Figure 7.14 – Screenshot of the BST visualization example, step 2
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – BST可视化示例截图，步骤2
- en: 'Then, you perform an insertion operation for the next five elements. These
    operations have a very visible impact on the tree shape, as presented in the console:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你为接下来的五个元素执行插入操作。这些操作对树形结构有非常明显的影响，如控制台所示：
- en: "![Figure 7.15 – \uFEFFScreenshot of the BST visualization example, step 3](img/B18069_07_15.jpg)"
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – BST可视化示例截图，步骤3](img/B18069_07_15.jpg)'
- en: Figure 7.15 – Screenshot of the BST visualization example, step 3
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – BST可视化示例截图，步骤3
- en: 'After adding 10 elements, the program shows the impact of removing a particular
    node on the shape of the tree. To start, let’s remove the leaf node with `25`
    as the value:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了10个元素之后，程序显示了移除特定节点对树形状的影响。首先，让我们移除值为`25`的叶节点：
- en: "![Figure 7.16 – \uFEFFScreenshot of the BST visualization example, step 4](img/B18069_07_16.jpg)"
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – BST可视化示例的截图，步骤4](img/B18069_07_16.jpg)'
- en: Figure 7.16 – Screenshot of the BST visualization example, step 4
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – BST可视化示例的截图，步骤4
- en: 'Then, the program removes a node with only one child node, namely the right
    one. What is interesting is that the right child also has a right child. However,
    the presented algorithm works properly in such conditions, and you receive the
    following result:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序移除只有一个子节点的节点，即右子节点。有趣的是，右子节点也有一个右子节点。然而，所提出的算法在这种情况下也能正常工作，您得到了以下结果：
- en: "![Figure 7.17 – \uFEFFScreenshot of the BST visualization example, step 5](img/B18069_07_17.jpg)"
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图7.17 – BST可视化示例的截图，步骤5](img/B18069_07_17.jpg)'
- en: Figure 7.17 – Screenshot of the BST visualization example, step 5
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 – BST可视化示例的截图，步骤5
- en: 'The last removal operation is the most complicated one because it requires
    you to remove the node with both children, and it also performs the role of the
    root. In such a case, the leftmost element from the right subtree of the root
    is found and replaces the node for removal, as shown in the final view of the
    tree:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个移除操作是最复杂的，因为它需要您移除具有两个子节点的节点，并且它还扮演着根的角色。在这种情况下，从根的右子树的最左端找到元素，并将其替换为要移除的节点，如图树最终视图所示：
- en: "![Figure 7.18 – \uFEFFScreenshot of the BST visualization example, step 6](img/B18069_07_18.jpg)"
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18 – BST可视化示例的截图，步骤6](img/B18069_07_18.jpg)'
- en: Figure 7.18 – Screenshot of the BST visualization example, step 6
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – BST可视化示例的截图，步骤6
- en: 'One more set of operations is left, namely traversal of the tree in pre-order,
    in-order, and post-order. The application presents the following results:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的一组操作是树的遍历，即先序、中序和后序遍历。应用程序呈现了以下结果：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The created application looks quite impressive, doesn’t it? You created not
    only the implementation of a BST from scratch but also prepared the platform for
    its visualization in the console. Great job!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的应用程序看起来相当令人印象深刻，不是吗？您不仅从头开始实现了BST的实现，还为在控制台中可视化它准备了平台。干得好！
- en: Is it already sorted?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经排序了吗？
- en: Let’s take one more look at the results of the in-order approach. As you can
    see, it gives you the nodes sorted in ascending order in the case of a BST.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看中序遍历的结果。如您所见，在BST的情况下，它以升序排序节点。
- en: However, can you see a potential problem with the created solution? What about
    a scenario where you remove nodes only from the given area of a tree or when you
    insert already sorted values? It could mean that a fat tree, with a proper **breadth-depth
    ratio**, could become a skinny one. In the worst case, it could even be depicted
    as a list, where all nodes have only one child. Do you have any idea how to solve
    the problem of unbalanced trees and keep them balanced all the time? If not, next,
    you will find some information on how to achieve this goal.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您能看出创建的解决方案中存在潜在问题吗？考虑一下只从树的给定区域移除节点或插入已排序值的情况。这可能意味着一个具有适当**宽度-深度比**的胖树可能会变成瘦树。在最坏的情况下，它甚至可能被描绘成一个列表，其中所有节点只有一个子节点。您有什么想法来解决不平衡树的问题并始终保持其平衡吗？如果没有，接下来您将找到一些关于如何实现这一目标的信息。
- en: Self-balancing trees
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 自平衡树
- en: In this section, you will get to know two variants of a **self-balancing tree**,
    which **keeps the tree balanced all the time while adding and removing nodes.**
    However, why is it so important? As already mentioned, the lookup performance
    depends on the shape of the tree. In the case of improper organization of nodes,
    forming a list, the process of searching for a given value can be an *O(n)* operation.
    With a correctly arranged tree, the performance can be significantly improved
    with *O(log n)*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解**自平衡树**的两种变体，这些变体**在添加和移除节点时始终保持树平衡**。然而，为什么这如此重要呢？如前所述，查找性能取决于树的形状。在不适当的节点组织情况下，形成列表，搜索给定值的操作可能是一个*O(n)*操作。而一个正确排列的树，其性能可以通过*O(log
    n)*显著提高。
- en: 'Do you know that a BST can very easily become an **unbalanced tree**? Let’s
    make a simple test of adding the following nine numbers to the tree, from **1**
    to **9**. Then, you will receive a tree with the shape shown in the following
    diagram on the left. However, the same values can be arranged in another way,
    as a **balanced tree**, with a significantly better breadth-depth ratio, which
    is shown on the right:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道BST可以非常容易地变成一个**不平衡树**吗？让我们做一个简单的测试，向树中添加以下九个数字，从**1**到**9**。然后，你将收到一个如左图所示的树形。然而，相同的值可以以另一种方式排列，形成一个**平衡树**，具有显著更好的宽度-深度比，如右图所示：
- en: '![Figure 7.19 – Difference between an unbalanced and a balanced tree](img/B18069_07_19.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19 – 不平衡树与平衡树的差异](img/B18069_07_19.jpg)'
- en: Figure 7.19 – Difference between an unbalanced and a balanced tree
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – 不平衡树与平衡树的差异
- en: You now know what unbalanced and balanced trees are, as well as what is the
    aim of self-balancing trees. However, what is an AVL tree or a red-black tree?
    How do they work? What rules should be taken into account while using these data
    structures? You will find answers to these questions next.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了不平衡树和平衡树是什么，以及自平衡树的目标是什么。然而，AVL树或红黑树是什么？它们是如何工作的？在使用这些数据结构时应该考虑哪些规则？你将在下一部分找到这些问题的答案。
- en: AVL trees
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树
- en: An **AVL tree** is named after its inventors, namely Adelson-Velsky and Landis.
    It is **a binary search tree with the additional requirement that, for each node,
    the height of its left and right subtrees cannot differ by more than one**. Of
    course, that rule must be maintained after adding and removing nodes from a tree.
    The important role is performed by **rotations**, used to fix incorrect arrangements
    of nodes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**AVL树**是以其发明者Adelson-Velsky和Landis的名字命名的。它**是一种二叉搜索树，它还要求每个节点的左右子树的高度之差不能超过一**。当然，在向树中添加和删除节点后，必须保持这条规则。旋转在这个过程中扮演着重要的角色，用于纠正节点的错误排列。'
- en: What about the performance?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: While talking about AVL trees, it is crucial to indicate the performance of
    this data structure. In this case, both average and worst-case scenarios of insertion,
    removal, and lookup are *O(log n)*, so there is significant improvement in the
    worst-case scenarios in comparison with a BST.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论AVL树时，指出这种数据结构的性能至关重要。在这种情况下，插入、删除和查找的平均和最坏情况的时间复杂度都是*O(log n)*，因此与BST相比，最坏情况下的性能有显著提升。
- en: The implementation of AVL trees, including various rotations necessary to keep
    the balanced state of a tree, is not trivial and will require quite a long explanation.
    Due to the limited number of pages in the book, its implementation is not presented
    here. Fortunately, you can use one of the available NuGet packages that support
    such tree-based data structures to benefit from AVL trees in your applications.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树的实现，包括保持树平衡状态所需的必要旋转，并不简单，需要相当长的解释。由于本书的页数有限，其实现在此未展示。幸运的是，你可以使用一个支持此类基于树的NuGet包，在你的应用程序中利用AVL树。
- en: Red-black trees
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'A **red-black tree** (**RBT**) is the next variant of self-balancing binary
    search trees. As a variant of BSTs, this data structure requires that standard
    BST rules are maintained. Moreover, the following rules must be taken into account:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**红黑树**（**RBT**）是自平衡二叉搜索树的下一个变体。作为BST的变体，这种数据结构要求维护标准的BST规则。此外，还必须考虑以下规则：'
- en: '**Each node must be colored either red or black**. Thus, you need to add additional
    data for a node that stores a color.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个节点必须着色为红色或黑色**。因此，你需要为存储颜色的节点添加额外的数据。'
- en: '`NIL` pseudo-nodes should be used as leaves in the tree, while all other nodes
    are internal ones. Moreover, all `NIL` pseudo-nodes must be black.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NIL`伪节点应作为树的叶子使用，而所有其他节点都是内部节点。此外，所有`NIL`伪节点都必须是黑色的。'
- en: '**If a node is red, both its children must** **be black**.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果一个节点是红色，那么它的两个子节点必须是黑色**。'
- en: For any node, `NIL` pseudo-node) **must be** **the same**.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何节点，`NIL`伪节点**必须相同**。
- en: 'A proper RBT is presented in the following diagram:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的红黑树在以下图中展示：
- en: "![Figure 7.20 – \uFEFFIllustration of a red-black tree](img/B18069_07_20.jpg)"
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20 – 红黑树的示意图](img/B18069_07_20.jpg)'
- en: Figure 7.20 – Illustration of a red-black tree
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 – 红黑树的示意图
- en: The tree consists of nine nodes, each colored red or black. It is worth mentioning
    the `NIL` pseudo-nodes, which are added as leaf nodes. If you again take a look
    at the set of rules listed previously, you can confirm that all such rules are
    maintained in this case.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 该树由九个节点组成，每个节点着色为红色或黑色。值得一提的是 `NIL` 伪节点，它们被添加为叶子节点。如果你再次查看之前列出的规则集，你可以确认在这种情况下所有这些规则都得到了维护。
- en: Similarly to AVL trees, RBTs also must maintain rules after adding or removing
    a node. In this case, the process of restoring the RBT properties is even more
    complicated because it involves both **recoloring** and **rotations**.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AVL 树类似，RBTs 在添加或删除节点后也必须维护规则。在这种情况下，恢复 RBT 属性的过程甚至更加复杂，因为它涉及到 **重新着色** 和
    **旋转**。
- en: What about the performance?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: While talking about this variant of self-balancing BSTs, it is also worth noting
    the performance. In both average and worst-case scenarios, insertion, removal,
    and lookup are *O(log n)* operations, so they are the same as in the case of AVL
    trees and much better in worst-case scenarios in comparison with BSTs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这种自平衡二叉搜索树变体时，也值得注意其性能。在平均情况和最坏情况下，插入、删除和查找操作都是 *O(log n)* 操作，因此它们与 AVL 树的情况相同，并且在最坏情况下比
    BSTs 更好。
- en: Fortunately, you do not need to know and understand the internal details, which
    are quite complex, to benefit from this data structure and apply it to your projects.
    As already mentioned in the case of AVL trees, you can also use one of the available
    NuGet packages for RBTs.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要了解和理解内部细节，这些细节相当复杂，才能从这种数据结构中受益并将其应用于你的项目。正如在 AVL 树的情况下已经提到的，你也可以使用可用的
    NuGet 包之一来处理 RBTs。
- en: Where can you find more information?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: The topic of trees is much broader than shown in this chapter. For this reason,
    if you are interested in such a subject, I strongly encourage you to search for
    more information on your own. You can also find some content on *Wikipedia*, such
    as at [https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree)
    and [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
    Self-balancing trees are covered at [https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree)
    and [https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree).
    The topic of tries and binary heaps (mentioned later in this chapter) is presented
    as well at [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
    and [https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 树的主题比本章所展示的要广泛得多。因此，如果你对这样的主题感兴趣，我强烈建议你自己去寻找更多信息。你还可以在 *Wikipedia* 上找到一些内容，例如在
    [https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree)
    和 [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree)。自平衡树的内容在
    [https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree)
    和 [https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree)
    中介绍。本章后面提到的 tries 和二叉堆（binary heaps）的主题也在 [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
    和 [https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap)
    中介绍。
- en: You already learned some basic information about self-balancing trees, namely
    AVL trees and RBTs. So, let’s take a look at another tree-based structure, namely
    a trie, which is a great solution for string-related operations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了一些关于自平衡树的基本信息，即 AVL 树和 RBTs。那么，让我们看看另一种基于树的结构，即 trie，它是字符串相关操作的绝佳解决方案。
- en: Tries
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Tries
- en: A tree is a powerful data structure that is used in various scenarios. One of
    them is related to processing strings, such as for **autocomplete** and **spellchecker**
    features that you certainly know from many systems. If you want to implement it
    in your application, you can benefit from another tree-based data structure, namely
    a **trie**. It is used to store strings and to perform prefix-based searching.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种强大的数据结构，在各种场景中使用。其中之一与处理字符串相关，例如用于 **自动完成** 和 **拼写检查** 功能，这些功能你肯定从许多系统中都了解过。如果你想在你的应用程序中实现它，你可以从另一种基于树的数据库结构中受益，即
    **Trie**。它用于存储字符串并执行基于前缀的搜索。
- en: '**A trie is a tree with one root node, where each node represents a string
    and each edge indicates a character. A trie node contains references to the next
    nodes as an array with 26 elements, representing 26 chars from the alphabet (from**
    **a** **to** **z****). When you go from the root to each node, you receive a string,
    which is either a saved word or** **its substring**.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**Trie** 是一种树，只有一个根节点，其中每个节点代表一个字符串，每条边表示一个字符。Trie 节点包含对下一个节点的引用，作为一个包含 26
    个元素的数组，代表字母表中的 26 个字符（从**a**到**z**）。当您从根节点到每个节点移动时，您会收到一个字符串，它要么是一个已保存的单词，要么是**它的子串**。'
- en: Why exactly 26 elements?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么正好是 26 个元素？
- en: Here, we use 26 elements representing 26 chars because it is the exact number
    of basic characters between `a` and `z` in the alphabet, without any special characters
    existing in various languages. Of course, in your implementation, you can expand
    this set with other characters, such as `ą`, `ę`, or `ś` from Polish, as well
    as with even digits or some special characters, such as a dash. Choosing a proper
    set of characters depends on the scenario in which this data structure will be
    used.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用代表 26 个字符的 26 个元素，因为这是字母表中 `a` 和 `z` 之间基本字符的确切数量，没有任何特殊字符存在于各种语言中。当然，在您的实现中，您可以扩展这个集合，包括其他字符，例如来自波兰语的
    `ą`、`ę` 或 `ś`，以及甚至数字或一些特殊字符，例如破折号。选择合适的字符集取决于此数据结构将用于的场景。
- en: 'Does it sound complicated? It could, so let’s take a look at the following
    diagram, which should remove any doubts:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来复杂吗？可能是的，所以让我们看看下面的图，它应该能消除任何疑虑：
- en: "![Figure 7.21 – \uFEFFIllustration of a trie](img/B18069_07_21.jpg)"
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – trie 的示意图](img/B18069_07_21.jpg)'
- en: Figure 7.21 – Illustration of a trie
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – trie 的示意图
- en: 'The diagram depicts a trie that stores the following words: **ai**, **aid**,
    **aim**, **air**, **airplane**, **airport**, **algorithm**, **all**, **allergy**,
    **allow**, **allowance**. As you can see, there is a root node (marked with **-**)
    that contains only one child, namely for the **a** substring. This node contains
    two child nodes, regarding the **ai** word and the **al** substring. The **ai**
    node has three children, namely representing **aid**, **aim**, and **air** words.
    In a similar way, you can analyze the whole trie. Please keep in mind that words
    are marked with bolder lines while substrings are shown with lighter ones.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了存储以下单词的 trie：**ai**、**aid**、**aim**、**air**、**airplane**、**airport**、**algorithm**、**all**、**allergy**、**allow**、**allowance**。正如您所看到的，有一个根节点（用**-**标记），它只包含一个子节点，即代表
    **a** 子串。此节点包含两个子节点，分别对应 **ai** 单词和 **al** 子串。**ai** 节点有三个子节点，分别代表 **aid**、**aim**
    和 **air** 单词。以类似的方式，您可以分析整个 trie。请记住，单词用粗线标记，而子串用较细的线表示。
- en: What about the performance?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？
- en: The searching and insertion in the case of a trie are *O(n)* operations, where
    *n* indicates a word length. So, a trie is an efficient data structure for string-based
    operations.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在 trie 的情况下，搜索和插入是 *O(n)* 操作，其中 *n* 表示单词长度。因此，trie 是一种高效的字符串操作数据结构。
- en: Implementation
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 实现
- en: After this short introduction, let’s move to something more exciting – coding!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们转向一些更令人兴奋的事情——编码！
- en: Node
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 节点
- en: 'Please take a look at the following implementation of a class representing
    a node:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下表示节点的类的实现：
- en: '[PRE35]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `TrieNode` class contains two properties. The first is named `Children`
    and is an array with `26` elements. Each of them represents a particular letter
    from an alphabet, starting from `a` (index equal to `0`) and ending with `z` (index
    equal to `25`). If there is another word with the same prefix, a reference to
    the next node is located in a suitable element of the `Children` array. The second
    property is named `IsWord` and indicates whether the current node is the last
    char from a word. It means that you can get this word by moving from the root
    element to this node.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrieNode` 类包含两个属性。第一个属性名为 `Children`，是一个包含 `26` 个元素的数组。每个元素代表字母表中的一个特定字母，从
    `a`（索引等于 `0`）到 `z`（索引等于 `25`）。如果有另一个具有相同前缀的单词，则下一个节点的引用位于 `Children` 数组的一个合适元素中。第二个属性名为
    `IsWord`，表示当前节点是否是单词的最后一个字符。这意味着您可以通过从根元素移动到该节点来获取此单词。'
- en: Trie
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Trie
- en: 'The next part of the code shows the implementation of a class representing
    a trie:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分展示了表示 trie 的类的实现：
- en: '[PRE36]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, there is a private field representing the root element. Of course, you
    need to add some methods to make it operational. First, let’s implement a method
    that checks whether a given word exists in the trie. Its code is as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有一个表示根元素的私有字段。当然，你需要添加一些方法来使其可用。首先，让我们实现一个检查给定单词是否存在于字典树中的方法。其代码如下：
- en: '[PRE37]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At the beginning, you save a reference to the root element as the current node.
    Then, you iterate through the following characters that form the word. For each
    character (represented by the `c` variable), you get a proper node (`child`).
    If it is `null`, it means that the word does not exist in the trie. Otherwise,
    you save the child element as the current one. When the `foreach` loop ends, the
    current node represents a node of the last character, so you just need to return
    the value of the `IsWord` property.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你保存根元素的引用作为当前节点。然后，你遍历构成单词的以下字符。对于每个字符（由`c`变量表示），你获取一个适当的节点（`child`）。如果它是`null`，则意味着该单词不在字典树中。否则，你保存子元素作为当前节点。当`foreach`循环结束时，当前节点代表最后一个字符的节点，因此你只需返回`IsWord`属性的值。
- en: 'The next method allows you to insert a word into a trie, as shown here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法允许你将单词插入到字典树中，如下所示：
- en: '[PRE38]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is a bit similar to that already described. However, there
    is one important difference in the `foreach` loop. Here, you create a new child
    node if it does not exist for any of the chars forming the word. At the end, you
    indicate that the node represents the word by setting the value of the `IsWord`
    property to `true`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与已描述的代码有些相似。然而，在`foreach`循环中有一个重要的区别。在这里，如果你为构成单词的任何字符都没有找到子节点，则创建一个新的子节点。最后，通过将`IsWord`属性的值设置为`true`，你表明该节点代表一个单词。
- en: 'As already mentioned, a trie is a data structure that allows you to perform
    **prefix-based searching** in an efficient way. So, let’s implement it:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，字典树是一种数据结构，它允许你以高效的方式执行**基于前缀的搜索**。因此，让我们来实现它：
- en: '[PRE39]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The method takes one parameter, namely the prefix of the searched words. At
    the beginning, you iterate through all characters of the prefix to get a reference
    to the last character forming the prefix. If a child node is not found at any
    phase, you return an empty list, which means that there are no results.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个参数，即搜索单词的前缀。一开始，你遍历前缀的所有字符以获取形成前缀的最后一个字符的引用。如果在任何阶段找不到子节点，则返回一个空列表，这意味着没有结果。
- en: 'Otherwise, you create a `List<string>` instance to store the result, and then
    you call the `GetAllWithPrefix` method, the code of which is shown next:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你创建一个`List<string>`实例来存储结果，然后调用`GetAllWithPrefix`方法，其代码如下：
- en: '[PRE40]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You check whether the current node is `null`. If so, you return from the method.
    Otherwise, you verify whether the current node forms a word. If so, you add it
    to `results`. Next, you iterate through all alphabet characters, namely from `a`
    to `z`, and call the same method recursively to find the next words and add them
    to the list with `results`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要检查当前节点是否为`null`。如果是，则从方法中返回。否则，你将验证当前节点是否构成一个单词。如果是，则将其添加到`results`中。接下来，你遍历所有字母字符，即从`a`到`z`，并递归调用相同的方法以找到下一个单词并将它们添加到`results`列表中。
- en: 'As you can see, the basic implementation of a trie is not a complicated task
    and can be done with clear and short code. However, how can you test a trie in
    action? Let’s see:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，字典树的基本实现并不复杂，可以用清晰简洁的代码完成。然而，你如何测试字典树的实际效果呢？让我们看看：
- en: '[PRE41]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code forms a trie, as shown in *Figure 7**.21*, with 11 words
    starting with `a`, such as `algorithm` and `allow`. You add such words with the
    `Insert` method. Then, you check whether the `air` word exists with the `DoesExist`
    method. Next, you get all words that start with the `ai` prefix and write them
    in the console:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码形成一个字典树，如图7**.21**所示，有以`a`开头的11个单词，例如`algorithm`和`allow`。你使用`Insert`方法添加这样的单词。然后，使用`DoesExist`方法检查`air`单词是否存在。接下来，你获取所有以`ai`前缀开头的单词并将它们写入控制台：
- en: '[PRE42]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the end of the section regarding tries, let’s talk about the space complexity
    of this data structure. As you can see, you need to store 26 references to child
    nodes for each trie node, and there can be a lot of situations where only one
    or two references are set. For instance, you can take a look at the `algorithm`
    word, where a lot of space is wasted. It would be much better to optimize it in
    some way to make the whole tree smaller.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于 trie 的部分结束时，让我们谈谈这种数据结构的空间复杂度。如您所见，您需要为每个 trie 节点存储 26 个子节点引用，并且可能有很多只有一两个引用被设置的情况。例如，您可以看看
    `algorithm` 这个词，其中浪费了很多空间。通过某种方式优化它，使整个树更小会更好。
- en: 'Fortunately, it is possible to use another data structure that is named a **radix
    tree** or a **compressed trie**, which is **a space-optimized version of a trie**.
    The difference is quite simple: namely, **you merge with the parent each node
    that is the only child of this parent**. Of course, **edges can represent a substring**
    in such a case.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以使用另一种名为 **radix tree** 或 **压缩 trie** 的数据结构，它是 **trie 的空间优化版本**。区别相当简单：即
    **您将此父节点的唯一子节点与父节点合并**。当然，在这种情况下，**边可以表示子串**。
- en: 'If you want to see what a radix tree looks like for the same input data as
    in the diagram of a trie, take a look at the following diagram:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到与 trie 图表相同的输入数据的 radix tree 的样子，请看以下图表：
- en: "![Figure 7.22 – \uFEFFIllustration of a radix tree](img/B18069_07_22.jpg)"
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.22 – 根树示意图](img/B18069_07_22.jpg)'
- en: Figure 7.22 – Illustration of a radix tree
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 根树示意图
- en: Looks much simpler, doesn’t it? For example, let’s analyze the path from the
    root node to **algorithm**. Here, you use only three edges, namely **a**, **l**,
    and **gorithm**.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来简单多了，不是吗？例如，让我们分析从根节点到 **算法** 的路径。在这里，您只需使用三个边，即 **a**、**l** 和 **gorithm**。
- en: Try to implement it on your own
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己实现它
- en: Based on the preceding diagram and the implementation of a trie, I encourage
    you to try to implement a radix tree on your own. You should also prepare a method
    for searching a word in such a data structure. Good luck!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的图表和 trie 的实现，我鼓励您尝试自己实现 radix tree。您还应该准备一个在这样数据结构中搜索单词的方法。祝你好运！
- en: Example – autocomplete
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 – 自动完成
- en: As an example of a trie application, you will create an `Countries.txt` file
    with names of countries, as well as add it to the project as content that will
    be automatically copied to the output directory.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 trie 应用程序的示例，您将创建一个包含国家名称的 `Countries.txt` 文件，并将其作为内容添加到项目中，该内容将被自动复制到输出目录。
- en: How to add a file to the project?
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将文件添加到项目中？
- en: You should right-click on the project node in the `.txt` extension. After confirmation,
    the file is created. If you want to mark this file as a content file and automatically
    copy it to the output directory, you should click on the file and change two properties
    in the **Properties** window. First, change **Build Action** to **Content**. Then,
    set **Copy to Output Directory** to **Copy always**.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在 `.txt` 扩展名的项目节点上右键单击。确认后，文件将被创建。如果您想将此文件标记为内容文件并自动将其复制到输出目录，您应该单击文件并在 **属性**
    窗口中更改两个属性。首先，将 **生成操作** 更改为 **内容**。然后，将 **复制到输出目录** 设置为 **始终复制**。
- en: 'A part of the file with country names is as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 国家名称的部分文件内容如下：
- en: '[PRE43]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Of course, a lot of country names are omitted in the preceding code snippet.
    However, when the file with country names is ready, you need to read its content
    and form a trie, as presented in the following code block:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的代码片段中省略了很多国家名称。然而，当国家名称文件准备好后，您需要读取其内容并形成一个 trie，如下面的代码块所示：
- en: '[PRE44]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: At the beginning, you create a new instance of the `Trie` class. Then, you read
    all lines from the `Countries.txt` file and store them in the `countries` array.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，您创建 `Trie` 类的新实例。然后，您从 `Countries.txt` 文件中读取所有行并将它们存储在 `countries` 数组中。
- en: The remaining part of the code consists of a `foreach` loop that iterates through
    all country names. For each of them, you make it lowercase and remove all chars
    other than `a`-`z`. Such a task is performed with a regular expression and the
    `Regex` class from the `System.Text.RegularExpressions` namespace.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分由一个 `foreach` 循环组成，该循环遍历所有国家名称。对于每一个，您将其转换为小写并删除所有除了 `a`-`z` 的字符。这个任务通过正则表达式和
    `System.Text.RegularExpressions` 命名空间中的 `Regex` 类来完成。
- en: 'When the trie is ready, you use a `while` loop, as shown next:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当 trie 准备就绪后，您使用一个 `while` 循环，如下所示：
- en: '[PRE45]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Inside the `while` loop, you wait until the user presses any key. If this key
    is other than `a`-`z`, the program ends its operation. Otherwise, you append the
    entered char to the prefix that is used for searching all country names that start
    with this prefix. If the number of results is equal to zero, the application ends
    its operation. Otherwise, you use the `ForEach` extension method to write each
    suggestion on a separate line.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，你等待用户按下任何键。如果这个键不是 `a` 到 `z` 之间的字母，程序将结束其操作。否则，你将输入的字符追加到用于搜索以该前缀开头的所有国家名称的前缀中。如果结果数量为零，应用程序将结束其操作。否则，你使用
    `ForEach` 扩展方法将每个建议写入单独的一行。
- en: 'As you can see, a trie provides you with a powerful and efficient mechanism
    for implementing an autocomplete feature. But what does it look like in practice?
    Let’s take a look at the following output regarding searching for `POLAND`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前缀树为你提供了一个强大而高效的机制来实现自动完成功能。但在实践中它看起来是什么样子呢？让我们看看以下关于搜索 `POLAND` 的输出：
- en: '[PRE46]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At the beginning, you can see names of countries that start with `P`. After
    typing `O`, you limit the results to countries whose names start with `PO`. In
    the same way, you further increase the prefix and get fewer and fewer results.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，你可以看到以 `P` 开头的国家名称。在输入 `O` 之后，你将结果限制为以 `PO` 开头的国家名称。以同样的方式，你可以进一步增加前缀，并得到越来越少的结果。
- en: Let’s proceed to the last part of this chapter, which is related to heaps. What
    are they, and why are they featured in a chapter about trees?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续本章的最后部分，这部分与堆有关。堆是什么，为什么它们会在关于树的章节中出现？
- en: Heaps
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 堆
- en: A **heap** is another variant of a tree, which you already got to know in [*Chapter
    3*](B18069_03.xhtml#_idTextAnchor088), *Arrays and Sorting*. There, you used a
    heap in the heap sort algorithm for sorting an array. For this reason, in the
    current chapter, you will see only a brief summary of this data structure. However,
    I strongly encourage you not to leave this topic and learn much more about heaps
    on your own, as they are powerful and popular data structures.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是树的另一种变体，你已经在 [*第 3 章*](B18069_03.xhtml#_idTextAnchor088) *数组和排序* 中了解到了。在那里，你使用堆在堆排序算法中对数组进行排序。因此，在本章中，你将只看到这个数据结构的一个简要总结。然而，我强烈建议你不要离开这个主题，并且自己学习更多关于堆的知识，因为它们是强大且流行的数据结构。'
- en: 'As you already know, a binary heap exists in two versions: **min-heap** and
    **max-heap**. For each of them, an additional property must be satisfied:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，二叉堆存在两种版本：**最小堆**和**最大堆**。对于每一种，都必须满足一个额外的属性：
- en: '**For min-heap**: The value of each node must be greater than or equal to the
    value of its parent node'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于最小堆**：每个节点的值必须大于或等于其父节点的值'
- en: '**For max-heap**: The value of each node must be less than or equal to the
    value of its parent node'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于最大堆**：每个节点的值必须小于或等于其父节点的值'
- en: These rules perform a very important role because they dictate that **the root
    node always contains the smallest value (in the min-heap) or the largest value
    (in the max-heap)**. You benefited from this assumption while sorting. Do you
    remember?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则起着非常重要的作用，因为它们规定**根节点始终包含最小值（在最小堆中）或最大值（在最大堆中）**。你在排序时受益于这个假设。你还记得吗？
- en: A binary heap must also adhere to the **complete binary tree** rule, which requires
    that **each node cannot contain more than two children and all levels of a tree
    must be fully filled, except the last one, which must be filled from left to right**
    and can have some space on the right.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆还必须遵循**完全二叉树**规则，该规则要求**每个节点不能包含超过两个子节点，并且树的所有层级必须完全填充，除了最后一层，最后一层必须从左到右填充**，并且可以在右侧留出一些空间。
- en: 'Let’s take a look at the following two binary heaps:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个二叉堆：
- en: "![Figure 7.23 – \uFEFFIllustration of a min-heap and a max-heap](img/B18069_07_23.jpg)"
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – 最小堆和最大堆的示意图](img/B18069_07_23.jpg)'
- en: Figure 7.23 – Illustration of a min-heap and a max-heap
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 最小堆和最大堆的示意图
- en: You can easily check whether both heaps adhere to all the rules. As an example,
    let’s verify the heap property for the node with a value equal to **20** from
    the min-heap variant (shown on the left). The node has two children with values
    of **35** and **50**, which are both greater than **20**. In the same way, you
    can check the remaining nodes in the heap.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地检查这两个堆是否都遵循所有规则。作为一个例子，让我们验证最小堆变体中值等于 **20** 的节点（如图中左侧所示）的堆属性。该节点有两个子节点，其值分别为
    **35** 和 **50**，这两个值都大于 **20**。以同样的方式，你可以检查堆中的其他节点。
- en: The binary tree rule is also maintained, as each node contains at most two children.
    The last requirement is that each level of the tree is fully filled except the
    last one, which does not need to be fully filled, but must contain nodes from
    left to right. In the min-heap example, three levels are fully filled (with one,
    two, and four nodes), while the last level contains two nodes (**25** and **70**),
    placed on the two leftmost positions. In the same way, you can confirm that the
    max-heap (shown on the right) is configured properly.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树规则也被保持，因为每个节点最多包含两个子节点。最后一个要求是树的每一层除了最后一层都要完全填满，最后一层不需要完全填满，但必须从左到右包含节点。在最小堆的例子中，有三层被完全填满（分别包含一个、两个和四个节点），而最后一层包含两个节点（**25**和**70**），放置在两个最左边的位置。同样，你可以确认最大堆（如右图所示）配置正确。
- en: At the end of this short introduction to the topic of heaps, and especially
    to binary heaps, it is worth mentioning the broad range of applications. First
    of all, this data structure is a convenient way of implementing a **priority queue**
    with the operation of inserting a new value and removing the smallest value (in
    the min-heap) or the largest value (in the max-heap). Moreover, a heap is used
    in the **heap sort algorithm**, as well as in **graph algorithms**.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在对堆的主题，尤其是二叉堆的简短介绍结束时，值得提到的是其广泛的应用范围。首先，这种数据结构是实现**优先队列**的便捷方式，具有插入新值和移除最小值（在最小堆中）或最大值（在最大堆中）的操作。此外，堆在**堆排序算法**以及**图算法**中也被使用。
- en: A binary heap can either be implemented from scratch or you can use some of
    the already available implementations as NuGet packages. One of the solutions
    is named `PommaLabs.Hippie` and can be easily installed on the project using the
    **NuGet Package Manager**. The mentioned library contains an implementation of
    a few variants of heaps, including binary heaps, **binomial heaps**, and **Fibonacci
    heaps**.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆可以从头开始实现，或者你可以使用一些已经可用的实现作为NuGet包。其中一个解决方案名为`PommaLabs.Hippie`，可以使用**NuGet包管理器**轻松地在项目中安装。提到的库包含了一些堆变体的实现，包括二叉堆、**二项堆**和**斐波那契堆**。
- en: Trees were everywhere in this chapter, and heaps are also representatives of
    this data structure! As you already learned a lot about trees, let’s proceed to
    the *Summary* section.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，树无处不在，堆也是这种数据结构的代表！既然你已经对树有了很多了解，让我们继续到**总结**部分。
- en: Summary
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: The current chapter was the longest so far in the book. However, it contained
    a lot of information about variants of trees. Such data structures perform a very
    important role in many algorithms, and it is good to learn more about them, as
    well as to know how to use them in your applications. For this reason, this chapter
    contained not only short theoretical introductions but also diagrams, explanations,
    and code samples.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当前章节是书中迄今为止最长的章节。然而，它包含了大量关于树变体的信息。这些数据结构在许多算法中扮演着非常重要的角色，因此了解它们以及如何在应用程序中使用它们是很好的。因此，本章不仅包含了简短的理论介绍，还包含了图表、解释和代码示例。
- en: At the beginning, **the concept of a tree** was described. As a reminder, a
    tree consists of **nodes**, including one **root**. The root does not contain
    a parent node, while all other nodes do. Each node can have any number of **child
    nodes**. The child nodes of the same node can be named **siblings**, while a node
    without children is named a **leaf**.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，**树的概念**被描述了。作为提醒，树由**节点**组成，包括一个**根节点**。根节点没有父节点，而所有其他节点都有。每个节点可以有任意数量的**子节点**。同一节点的子节点可以被称为**兄弟节点**，而没有子节点的节点被称为**叶节点**。
- en: Various variants of trees follow this structure. The first one described in
    the chapter is a **binary tree**. In this case, a node can contain at most two
    children. However, the rules for **binary search trees** are even more strict.
    For any node in such trees, the values of all nodes in its left subtree must be
    smaller than the value of the node, while the values of all nodes in its right
    subtree must be greater than the value of the node. BSTs have a broad range of
    applications and provide developers with significant improvements in the lookup
    performance. However, it is possible to easily make a tree unbalanced while adding
    sorted values to the tree. Thus, the positive impact on the performance can be
    limited.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 树的多种变体遵循这种结构。本章首先描述的是**二叉树**。在这种情况下，一个节点最多可以包含两个子节点。然而，**二叉搜索树**的规则更为严格。对于这类树中的任何节点，其左子树中所有节点的值必须小于该节点的值，而其右子树中所有节点的值必须大于该节点的值。BSTs在许多应用中都有广泛的应用，并为开发者提供了显著的查找性能提升。然而，在向树中添加排序值时，很容易使树变得不平衡。因此，对性能的积极影响可能有限。
- en: Fortunately, `NIL` pseudo-nodes. Moreover, it is required that if a node is
    red, both its children must be black, and for any node, the number of black nodes
    on the route to a descendant leaf must be the same.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在`NIL`伪节点。此外，如果节点是红色的，那么它的两个子节点必须是黑色的，并且对于任何节点，到达其子叶的路径上黑色节点的数量必须相同。
- en: Then, you learned a lot about **tries** and saw their great performance regarding
    processing strings, such as for autocomplete or spellchecker features. Each trie
    is a tree with one root node, where each node represents a string and each edge
    indicates a character. A trie node contains references to the next nodes as an
    array with elements representing possible characters. When you go from the root
    to each node, you receive a string, which is either a saved word or its substring.
    Within this part, a **radix tree** was mentioned as well, which is a space-optimized
    version of a trie.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了关于**字典树**的很多知识，并看到了它们在处理字符串方面的出色性能，例如用于自动完成或拼写检查功能。每个字典树是一个只有一个根节点的树，其中每个节点代表一个字符串，每条边表示一个字符。字典树节点包含指向下一个节点的引用，这些引用作为一个包含可能字符的数组的元素。当你从根节点到每个节点移动时，你会得到一个字符串，它要么是一个已保存的单词，要么是其子串。在这一部分，还提到了**基数树**，它是字典树的空间优化版本。
- en: The remaining part of the chapter was related to **binary heaps**. As a reminder,
    a heap is another variant of a tree, which exists in two versions, **min-heap**
    and **max-heap**. It is worth noting that the value of each node must be greater
    than or equal to (for min-heaps) or less than or equal to (for max-heaps) the
    value of its parent node.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分与**二叉堆**相关。作为提醒，堆是树的一种变体，存在两种版本，**最小堆**和**最大堆**。值得注意的是，每个节点的值必须大于或等于（对于最小堆）或小于或等于（对于最大堆）其父节点的值。
- en: Let’s proceed to **graphs**, which are the subject of the next chapter!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论**图**，这是下一章的主题！
- en: '[PRE47]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
