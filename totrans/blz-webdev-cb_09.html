<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-308">
    <a id="_idTextAnchor308">
    </a>
    
     9
    
   </h1>
   <h1 id="_idParaDest-309">
    <a id="_idTextAnchor309">
    </a>
    
     Exploring Navigation and Routing
    
   </h1>
   <p>
    
     Routing and navigation are essential features in any modern web application.
    
    
     In a Blazor Web App, routing is the process that maps URLs to Razor components, allowing users to navigate between different views.
    
    
     Navigation refers to the actions and processes involved in moving from one route to another, whether through user interactions, programmatic commands, or other means.
    
    
     Blazor provides a flexible routing system that supports both static and interactive routing, depending on how you configure
    
    
     
      the application.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Static routing
     
    </strong>
    
     occurs
    
    <a id="_idIndexMarker440">
    </a>
    
     during static server-side rendering when prerendering is enabled.
    
    
     In this mode, the Blazor router, defined by the
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     component in
    
    <strong class="source-inline">
     
      Routes.razor
     
    </strong>
    
     , performs routing based on the HTTP request path, mapping URLs directly to components.
    
    
     Conversely, when the Blazor router is set to an interactive render mode, it automatically
    
    <a id="_idIndexMarker441">
    </a>
    
     transitions from static to
    
    <strong class="bold">
     
      interactive routing
     
    </strong>
    
     after the initial rendering on the server is completed.
    
    
     Interactive routing uses the document’s URL (the URL in the browser’s address bar) to determine which component to render dynamically, allowing an application to respond to user interactions and navigate without performing full HTTP requests.
    
    
     This approach enables dynamic content updates and seamless navigation within
    
    
     
      the application.
     
    
   </p>
   <p>
    
     When comparing routing in Blazor to routing in ASP.NET Core, there are both similarities and key differences to consider.
    
    
     ASP.NET Core primarily uses controllers and actions for routing, where routes are typically defined in a centralized manner, often using attribute-based or conventional routing.
    
    
     In contrast, Blazor’s routing is component-based, directly mapping URLs to Razor components instead of controller actions.
    
    
     This component-based approach in Blazor allows a more modular and encapsulated routing experience, where each component can manage its own navigation logic.
    
    
     Additionally, Blazor supports navigation within a client-side browser, without requiring full-page reloads, which is a significant difference from traditional server-side routing in
    
    
     
      ASP.NET Core.
     
    
   </p>
   <p>
    
     In this chapter, we will cover aspects of routing and navigation in Blazor web apps using .NET 9.
    
    
     We will begin with enabling routes from multiple assemblies, essential for building modular applications and scenarios where you’ll leverage external NuGet packages.
    
    
     Then, we will explore parameterized routes, where you will learn to create dynamic and flexible URLs with route parameters.
    
    
     Then, we will discuss implementing unified
    
    <strong class="bold">
     
      deep linking
     
    </strong>
    
     for centralizing route definitions for easier management.
    
    
     We will also cover handling incorrect
    
    <a id="_idIndexMarker442">
    </a>
    
     navigation requests and controlling navigation history to enhance the user experience.
    
    
     Near the end, we will explain how to execute asynchronous operations during navigation and cancel long-running tasks when users navigate away.
    
    
     Lastly, we will explore how to prevent unintentional data loss by prompting users about unsaved changes before navigating away
    
    
     
      from forms.
     
    
   </p>
   <p>
    
     By the end of this chapter, you will understand how routing works in Blazor and how to implement various routing and
    
    
     
      navigation scenarios.
     
    
   </p>
   <p>
    
     Routing and navigation are critical components that often impact entire application behavior.
    
    
     However, the recipes in this chapter are fully independent and don’t build on one another.
    
    
     This approach also means you can review and implement each recipe in isolation.
    
    
     Recipes begin with instructions on what working directory you should create and which sample files you need to execute the
    
    
     
      following task.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Enabling routes from
     
     
      
       multiple assemblies
      
     
    </li>
    <li>
     
      Working with
     
     
      
       parameterized routes
      
     
    </li>
    <li>
     
      Working with
     
     
      
       query parameters
      
     
    </li>
    <li>
     
      Implementing unified
     
     
      
       deep linking
      
     
    </li>
    <li>
     
      Handling incorrect
     
     
      
       navigation requests
      
     
    </li>
    <li>
     
      Executing an asynchronous operation
     
     
      
       with navigation
      
     
    </li>
    <li>
     
      Canceling a long-running task when users
     
     
      
       navigate away
      
     
    </li>
    <li>
     
      Controlling
     
     
      
       navigation history
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-310">
    <a id="_idTextAnchor310">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     Before diving in, make sure that you have
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      .NET 9
     
     
      
       SDK installed
      
     
    </li>
    <li>
     
      A modern IDE (that supports
     
     
      
       Blazor development)
      
     
    </li>
    <li>
     
      A modern web browser (that
     
     
      
       supports WebAssembly)
      
     
    </li>
    <li>
     
      A
     
     
      
       Blazor project
      
     
    </li>
   </ul>
   <p>
    
     We will build all recipes in a
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     project, so all references will reflect that assembly.
    
    
     Make sure you adjust assembly references to match
    
    
     
      your project.
     
    
   </p>
   <p>
    
     You can find all the code written in this chapter and code samples on GitHub
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09">
     
      
       https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-311">
    <a id="_idTextAnchor311">
    </a>
    
     Enabling routes from multiple assemblies
    
   </h1>
   <p>
    
     You might want to modularize your Blazor application by spreading routes across multiple assemblies.
    
    <strong class="bold">
     
      Modularization
     
    </strong>
    
     is the practice of breaking down an application into smaller, manageable, and independent
    
    <a id="_idIndexMarker443">
    </a>
    
     modules, each responsible for a specific functionality.
    
    
     It’s an ideal development approach when working in big or distributed teams, as each team can deliver features independently.
    
    
     Modularization is also
    
    <a id="_idIndexMarker444">
    </a>
    
     beneficial in larger applications, as you can encapsulate different features in separate assemblies.
    
    
     Blazor allows you to discover routable components from additional assemblies through the
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     component’s API, for interactive routing, and the endpoint convention builder, for static
    
    
     
      route setups.
     
    
   </p>
   <p>
    
     Let’s learn how to allow users to navigate to a component from an assembly different than our
    
    
     
      base project.
     
    
   </p>
   <h2 id="_idParaDest-312">
    <a id="_idTextAnchor312">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we extend assemblies, where Blazor scans for routable components, copy the
    
    <strong class="source-inline">
     
      BlazorCookbook.Library
     
    </strong>
    
     project from the GitHub repository to
    
    
     
      your solution.
     
    
   </p>
   <h2 id="_idParaDest-313">
    <a id="_idTextAnchor313">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to allow Blazor to discover routes from
    
    
     
      different assemblies:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       BlazorCookbook.App
      
     </strong>
     
      server-side project of
     
     
      
       your solution.
      
     
    </li>
    <li>
     
      Open
     
     <strong class="source-inline">
      
       BlazorCookbook.App.csproj
      
     </strong>
     
      and add a reference to the
     
     
      <strong class="source-inline">
       
        BlazorCookbook.Library
       
      </strong>
     
     
      
       project:
      
     
     <pre class="source-code">
&lt;ItemGroup&gt;
  &lt;ProjectReference
    Include="..\BlazorCookbook.App.Client\
    BlazorCookbook.App.Client.csproj" /&gt;
  &lt;ProjectReference
    Include="..\BlazorCookbook.Library\
    BlazorCookbook.Library.csproj" /&gt;
&lt;/ItemGroup&gt;</pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      and locate a
     
     <a id="_idIndexMarker445">
     </a>
     
      component mapping section.
     
     
      Use the
     
     <strong class="source-inline">
      
       AddAdditionalAssemblies()
      
     </strong>
     
      method to map routes from the
     
     
      <strong class="source-inline">
       
        ExternalEventManager
       
      </strong>
     
     
      
       assembly:
      
     
     <pre class="source-code">
using BlazorCookbook.Library.Chapter09.Recipe01;
//other registrations and pipelines
app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(
        typeof(_Imports).Assembly,
        typeof(ExternalEventManager).Assembly
    );</pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Routes
      
     </strong>
     
      component and extend the array attached to the
     
     <strong class="source-inline">
      
       AdditionalAssemblies
      
     </strong>
     
      parameter with the
     
     
      <strong class="source-inline">
       
        ExternalEventManager
       
      </strong>
     
     
      
       assembly:
      
     
     <pre class="source-code">
@using BlazorCookbook.Library.Chapter09.Recipe01
&lt;Router AppAssembly="@typeof(Program).Assembly"
        AdditionalAssemblies="new[]
        {
            typeof(Client._Imports).Assembly,
            typeof(ExternalEventManager).Assembly
        }"&gt;
    @* router configuration *@
&lt;/Router&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-314">
    <a id="_idTextAnchor314">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we add all the configurations for routable component discoverability in the server-side project
    
    <a id="_idIndexMarker446">
    </a>
    
     of the solution.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we find the
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     project configuration file and reference the
    
    <strong class="source-inline">
     
      BlazorCookbook.Library
     
    </strong>
    
     project that you’ve copied from the GitHub repository.
    
    <strong class="source-inline">
     
      BlazorCookbook.Library
     
    </strong>
    
     contains an
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     component, and we want our users to be able to navigate
    
    
     
      to it.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we set up the discoverability of the static routing that might come from the
    
    <strong class="source-inline">
     
      BlazorCookbook.Library
     
    </strong>
    
     .
    
    
     We navigate to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file of the
    
    <strong class="source-inline">
     
      BlazorCookbook.App
     
    </strong>
    
     project and locate where we build the endpoint convention of the application.
    
    
     The endpoint route builder starts from the
    
    <strong class="source-inline">
     
      MapRazorComponents()
     
    </strong>
    
     method call.
    
    
     At the end of the builder, we call the
    
    <strong class="source-inline">
     
      AddAdditionalAssemblies()
     
    </strong>
    
     method to map all the static routes from the
    
    <strong class="source-inline">
     
      BlazorCookbook.App.Client
     
    </strong>
    
     project.
    
    
     Now, we extend the additional assemblies’ array with the
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     assembly.
    
    
     To make the registration type-safe, rather than a simple string, we use the
    
    <strong class="source-inline">
     
      typeof()
     
    </strong>
    
     method.
    
    
     The
    
    <strong class="source-inline">
     
      typeof()
     
    </strong>
    
     method in .NET allows us to obtain the
    
    <strong class="source-inline">
     
      Type
     
    </strong>
    
     object for a given type name, enabling reflection and metadata access at runtime.
    
    
     Additionally, it allows retrieval of the assembly containing the type, which solves our
    
    
     
      requirement perfectly.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Routes
     
    </strong>
    
     component, still in the server-side project, to extend the discoverability of interactive routes.
    
    
     Here, we find our application
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     configuration.
    
    
     By specifying assemblies with the
    
    <strong class="source-inline">
     
      AppAssembly
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      AdditionalAssemblies
     
    </strong>
    
     parameters,
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     dynamically discovers and maps routes to components defined in those assemblies.
    
    
     In our case, again, we find that the client-side project assembly is
    
    <a id="_idIndexMarker447">
    </a>
    
     already attached to the
    
    <strong class="source-inline">
     
      AdditionalAssemblies
     
    </strong>
    
     parameter of the
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     .
    
    
     We extend the
    
    <strong class="source-inline">
     
      AdditionalAssemblies
     
    </strong>
    
     with reference to the
    
    
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
    
    
     
      assembly.
     
    
   </p>
   <h1 id="_idParaDest-315">
    <a id="_idTextAnchor315">
    </a>
    
     Working with parameterized routes
    
   </h1>
   <p>
    
     In Blazor, parameterized routes allow you to pass parameters through the URL, making your application more dynamic and flexible.
    
    
     By leveraging route parameters, you can create components that
    
    <a id="_idIndexMarker448">
    </a>
    
     respond to specific URL segments and render content based on those parameters.
    
    
     You can also use route parameters to persist the component state and allow users to bookmark it (which we explored at the beginning of
    
    <a href="B22020_05.xhtml#_idTextAnchor165">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Let’s extend component routing with parametrized routes, enforcing
    
    
     
      parameter constraints.
     
    
   </p>
   <h2 id="_idParaDest-316">
    <a id="_idTextAnchor316">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before exploring parametrized routing, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory in the
     
     <strong class="source-inline">
      
       BlazorCookbook.Library
      
     </strong>
     
      project or the matching directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-317">
    <a id="_idTextAnchor317">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement routes with parameters and intercept
    
    
     
      their values:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      component and extend its routes with
     
     
      
       parametrized options:
      
     
     <pre class="source-code">
@page "/ch09r02"
@page "/ch09r02/{eventId:guid}"
@page "/ch09r02/{eventId:guid}/venues/{venue?}"</pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      , initialize the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block with two parameters –
     
     <strong class="source-inline">
      
       EventId
      
     </strong>
     
      
       and
      
     
     
      <strong class="source-inline">
       
        Venue
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
@code {
    [Parameter] public Guid EventId { get; set; }
    [Parameter] public string Venue { get; set; }
}</pre>
    </li>
    <li>
     
      Extend the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      markup by constructing a conditional display
     
     <a id="_idIndexMarker449">
     </a>
     
      of the
     
     <strong class="source-inline">
      
       Venue
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        EventId
       
      </strong>
     
     
      
       values:
      
     
     <pre class="source-code">
@if (EventId == default) return;
&lt;p&gt;Event ID: @EventId&lt;/p&gt;
&lt;p&gt;In @(Venue ?? "all venues")&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-318">
    <a id="_idTextAnchor318">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     and extend the routing there.
    
    
     We add a new route that expects an
    
    <strong class="source-inline">
     
      eventId
     
    </strong>
    
     parameter by placing the parameter name in curly braces.
    
    
     We also declare that it must be of type
    
    <strong class="source-inline">
     
      guid
     
    </strong>
    
     .
    
    
     Blazor also supports route parameter constraints, which enhance your application’s security by automatically rejecting parameter values that don’t meet the specified constraints.
    
    
     Users providing incompatible values will receive a
    
    <strong class="source-inline">
     
      404
     
    </strong>
    
     error status code.
    
    
     While the route parameter name is case-insensitive, the constraint must follow the configured casing.
    
    
     As constraint support is limited, in the
    
    <em class="italic">
     
      See also
     
    </em>
    
     section for this recipe, there’s a link to all currently supported data types.
    
    
     In the last route we add, we declare the
    
    <strong class="source-inline">
     
      venue?
     
    </strong>
    
     optional route parameter by adding a
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     symbol at the end.
    
    
     Having an optional parameter means users can navigate to the page whether they provide the value of the
    
    <strong class="source-inline">
     
      venue
     
    </strong>
    
     or not, and we can adjust the display
    
    
     
      logic accordingly.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we initialize a
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block in
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     and declare two parameters,
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Venue
     
    </strong>
    
     , matching the names of the parameters added in the routes but following the Pascal case convention.
    
    
     That’s all it takes to enable Blazor to bind route parameters to the
    
    
     
      component’s properties.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we construct a
    
    <a id="_idIndexMarker450">
    </a>
    
     simple markup in
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     .
    
    
     Below the existing
    
    <strong class="source-inline">
     
      h1
     
    </strong>
    
     element, we check whether
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     was set in the route and render its value in a paragraph.
    
    
     Lastly, we add another paragraph, below
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     , to display the current value of
    
    <strong class="source-inline">
     
      Venue
     
    </strong>
    
     or a message indicating that the user is viewing all venues (if
    
    <strong class="source-inline">
     
      Venue
     
    </strong>
    
     was not provided in the route).
    
    
     With this setup, you can test how different routes impact the
    
    
     
      component’s behavior.
     
    
   </p>
   <h2 id="_idParaDest-319">
    <a id="_idTextAnchor319">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Alternatively, you can implement a
    
    <em class="italic">
     
      catch’em all
     
    </em>
    
     pattern to intercept route parameters.
    
    
     You can intercept an
    
    <a id="_idIndexMarker451">
    </a>
    
     entire route segment into a
    
    
     
      string parameter:
     
    
   </p>
   <pre class="source-code">
@page "/ch09r02/{*path}"
@code {
    [Parameter] public string Path {get; set; }
}</pre>
   <p>
    
     We still declare the route parameter in curly braces and a matching
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     parameter in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, similar to other routing cases.
    
    
     However, to indicate that we want to intercept an entire route segment, we prefix the parameter name with a
    
    <strong class="source-inline">
     
      *
     
    </strong>
    
     symbol.
    
    
     For example, when a user navigates to
    
    <strong class="source-inline">
     
      /ch09r02/im/definitely/lost
     
    </strong>
    
     , Blazor assigns
    
    <strong class="source-inline">
     
      im/definitely/lost
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      Path
     
    </strong>
    
     value.
    
    
     You can still mix standard route parameters and constraints as long as the catch-all route segment parameter is the last in the
    
    
     
      route path.
     
    
   </p>
   <h2 id="_idParaDest-320">
    <a id="_idTextAnchor320">
    </a>
    
     See also
    
   </h2>
   <p>
    
     For the full list of data types that Blazor supports as route parameter constraints, check out the following Microsoft
    
    <a id="_idIndexMarker452">
    </a>
    
     documentation
    
    
     
      link:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-321">
    <a id="_idTextAnchor321">
    </a>
    
     Working with query parameters
    
   </h1>
   <p>
    <strong class="bold">
     
      Query strings
     
    </strong>
    
     and parameters are
    
    <a id="_idIndexMarker453">
    </a>
    
     parts of a URL that allow you to pass optional data to a web application.
    
    
     They appear
    
    <a id="_idIndexMarker454">
    </a>
    
     after the
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     symbol in a URL and consist of key-value pairs, separated by
    
    <strong class="source-inline">
     
      =
     
    </strong>
    
     and joined by
    
    <strong class="source-inline">
     
      &amp;
     
    </strong>
    
     .
    
    
     The use of query parameters is useful for filtering data, pagination, and passing user-specific information without altering the URL
    
    
     
      structure significantly.
     
    
   </p>
   <p>
    
     Let’s enhance the routing by allowing the conditional passing of an event date that will be
    
    
     
      loaded dynamically.
     
    
   </p>
   <h2 id="_idParaDest-322">
    <a id="_idTextAnchor322">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before exploring query parameters, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Working with parameterized routes
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-323">
    <a id="_idTextAnchor323">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to intercept values from
    
    
     
      query parameters:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      and introduce a
     
     <strong class="source-inline">
      
       Date
      
     </strong>
     
      parameter, but use a
     
     <strong class="source-inline">
      
       SupplyParameterFromQuery
      
     </strong>
     
      attribute to indicate that Blazor should intercept it from the
     
     
      
       query string:
      
     
     <pre class="source-code">
[SupplyParameterFromQuery]
public DateTime Date { get; set; }</pre>
    </li>
    <li>
     
      At the end of the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      markup, check whether
     
     <strong class="source-inline">
      
       Date
      
     </strong>
     
      is available and render another paragraph with the
     
     
      <strong class="source-inline">
       
        Date
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
@if (Date == DateTime.MinValue) return;
&lt;p&gt;On @Date&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-324">
    <a id="_idTextAnchor324">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     and declare a
    
    <strong class="source-inline">
     
      Date
     
    </strong>
    
     parameter.
    
    
     Instead of using the standard
    
    <strong class="source-inline">
     
      Parameter
     
    </strong>
    
     attribute, we leverage the
    
    <strong class="source-inline">
     
      SupplyParameterFromQuery
     
    </strong>
    
     variant, instructing Blazor to intercept parameters from the query string.
    
    
     There’s no need to manipulate routes; simply annotating the parameter with
    
    <strong class="source-inline">
     
      SupplyParameterFromQuery
     
    </strong>
    
     enables
    
    
     
      this functionality.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we extend the
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     markup.
    
    
     We check whether the
    
    <strong class="source-inline">
     
      Date
     
    </strong>
    
     value matches
    
    <a id="_idIndexMarker455">
    </a>
    
     the default value of
    
    <strong class="source-inline">
     
      DateTime
     
    </strong>
    
     , which indicates that the parameter was not in the query string.
    
    
     If Blazor intercepts the
    
    <strong class="source-inline">
     
      Date
     
    </strong>
    
     parameter, we render a paragraph displaying its value.
    
    
     However, it’s important to note that the format of the date provided in the query string needs to match the culture settings of the application.
    
    
     By default, Blazor and .NET expect dates in the
    
    <strong class="source-inline">
     
      MM-DD-YYYY
     
    </strong>
    
     format, which is a default format in the
    
    <strong class="source-inline">
     
      en-US
     
    </strong>
    
     culture, reflecting the United States standard.
    
    
     If the date is provided in a different format, such as
    
    <strong class="source-inline">
     
      DD-MM-YYYY
     
    </strong>
    
     , it may not be parsed correctly unless the application’s culture is set appropriately.
    
    
     This can be adjusted either globally or within specific components by configuring the appropriate culture settings, ensuring that Blazor interprets the date in the
    
    
     
      desired format.
     
    
   </p>
   <h2 id="_idParaDest-325">
    <a id="_idTextAnchor325">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     When your C# parameter name differs from the one provided in a query string, or when a parameter key is present multiple times in a query string and you need to intercept all values into an array, you must explicitly declare the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property of the
    
    
     <strong class="source-inline">
      
       SupplyParameterFromQuery
      
     </strong>
    
    
     
      attribute:
     
    
   </p>
   <pre class="source-code">
[SupplyParameterFromQuery(Name = "seat")]
public string[] Seats { get; set; }</pre>
   <p>
    
     With this code, Blazor will intercept all the query parameters attached to the
    
    <strong class="source-inline">
     
      seat
     
    </strong>
    
     key and store them in the
    
    <strong class="source-inline">
     
      Seats
     
    </strong>
    
     array.
    
    
     You can then use that array to highlight or reserve seats with
    
    
     
      specific numbers.
     
    
   </p>
   <h2 id="_idParaDest-326">
    <a id="_idTextAnchor326">
    </a>
    
     See also
    
   </h2>
   <p>
    
     If you’d like to learn
    
    <a id="_idIndexMarker456">
    </a>
    
     more about globalization and culture settings in Blazor, check out the Microsoft Learn resource
    
    
     
      here:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-327">
    <a id="_idTextAnchor327">
    </a>
    
     Implementing unified deep linking
    
   </h1>
   <p>
    <strong class="bold">
     
      Deep linking
     
    </strong>
    
     in a web application is the ability to link directly to specific content or functionality.
    
    
     Implementing a
    
    <a id="_idIndexMarker457">
    </a>
    
     unified deep linking service in your application centralizes route management, making the application more maintainable and scalable.
    
    
     It’s much easier to manage routing changes and avoid inconsistencies with all routes in
    
    
     
      one place.
     
    
   </p>
   <p>
    
     Let’s move some routes to a static deep links container and update component routing to leverage these unified
    
    
     
      deep links.
     
    
   </p>
   <h2 id="_idParaDest-328">
    <a id="_idTextAnchor328">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we encapsulate routes into a dedicated container, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Working with query parameters
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-329">
    <a id="_idTextAnchor329">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to introduce a container for routes in
    
    
     
      your application:
     
    
   </p>
   <ol>
    <li>
     
      This time, create a
     
     <strong class="source-inline">
      
       DeepLinks
      
     </strong>
     
      static class, not
     
     
      
       a component:
      
     
     <pre class="source-code">
public static class DeepLinks
{
    // you will define routes here
}</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       DeepLinks
      
     </strong>
     
      class, define three
     
     <strong class="source-inline">
      
       const
      
     </strong>
     
      routes that match the ones you have
     
     <a id="_idIndexMarker458">
     </a>
     
      
       in
      
     
     
      <strong class="source-inline">
       
        ExternalEventManager
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
public const string
    LandingPage = "/ch09r04",
    EventPage = "/ch09r04/{eventId:guid}",
    EventAtVenuePage =
        "/ch09r04/{eventId:guid}/venues/{venue?}";</pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      , and replace the
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directives with the
     
     <strong class="source-inline">
      
       @attribute
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       [Route]
      
     </strong>
     
      attributes.
     
     
      Instead of providing the routes explicitly, leverage the
     
     
      <strong class="source-inline">
       
        DeepLinks
       
      </strong>
     
     
      
       constants:
      
     
     <pre class="source-code">
@attribute [Route(DeepLinks.LandingPage)]
@attribute [Route(DeepLinks.EventPage)]
@attribute [Route(DeepLinks.EventAtVenuePage)]</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-330">
    <a id="_idTextAnchor330">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a new
    
    <strong class="source-inline">
     
      DeepLinks
     
    </strong>
    
     class.
    
    <strong class="source-inline">
     
      DeepLinks
     
    </strong>
    
     is not a component but, rather, a
    
    <strong class="source-inline">
     
      static
     
    </strong>
    
     class, as it represents a fixed library that should be easily accessible in the entire application and won’t change through the application’s lifetime.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we declare three
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     routes for the
    
    <strong class="source-inline">
     
      LandingPage
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      EventPage
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      EventAtVenuePage
     
    </strong>
    
     pages inside
    
    <strong class="source-inline">
     
      DeepLinks
     
    </strong>
    
     .
    
    
     These routes match the ones we already have explicitly declared in
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     , so we copy those
    
    
     
      values here.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we navigate to
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     and replace all
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directives with
    
    <strong class="source-inline">
     
      @attribute
     
    </strong>
    
     .
    
    
     With
    
    <strong class="source-inline">
     
      @attribute
     
    </strong>
    
     , we can leverage the
    
    <strong class="source-inline">
     
      [Route]
     
    </strong>
    
     attribute, which accepts a route as a parameter.
    
    
     We use the
    
    <strong class="source-inline">
     
      DeepLinks
     
    </strong>
    
     route repository to explicitly construct the same routing we had with
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directives.
    
    
     Even though we’ve encapsulated routes in
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     variables, Blazor still respects the constraints and optionality of the
    
    
     
      route parameters.
     
    
   </p>
   <p>
    
     You can leverage the
    
    <strong class="source-inline">
     
      DeepLinks
     
    </strong>
    
     class to safely set up navigation links in the application menu or
    
    <a id="_idIndexMarker459">
    </a>
    
     anywhere else.
    
    
     By having routes as named objects, you avoid mistyping and reduce the risk of errors in your
    
    
     
      routing configuration.
     
    
   </p>
   <h2 id="_idParaDest-331">
    <a id="_idTextAnchor331">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     You can extend the
    
    <strong class="source-inline">
     
      DeepLinks
     
    </strong>
    
     class with methods that allow you to generate stateful links and enable a more flexible and dynamic way to create URLs with route parameters.
    
    
     For instance, you can implement a method that accepts
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     and places it correctly in the
    
    <strong class="source-inline">
     
      EventPage
     
    </strong>
    
     
      route template:
     
    
   </p>
   <pre class="source-code">
public const string
    EventPage = "/ch09r04/{eventId:guid}";
public static string GetPage(Guid eventId)
    =&gt; EventPage.Replace("{eventId:guid}", $"{eventId}");</pre>
   <p>
    
     When rendering a grid with events, you can leverage the
    
    <strong class="source-inline">
     
      GetPage()
     
    </strong>
    
     method and safely generate links to the event page with details.
    
    <strong class="source-inline">
     
      GetPage()
     
    </strong>
    
     accepts the
    
    <strong class="source-inline">
     
      eventId
     
    </strong>
    
     parameter and uses the
    
    <strong class="source-inline">
     
      Replace()
     
    </strong>
    
     extension method to insert parameters into the
    
    <strong class="source-inline">
     
      EventPage
     
    </strong>
    
     
      route template.
     
    
   </p>
   <h1 id="_idParaDest-332">
    <a id="_idTextAnchor332">
    </a>
    
     Handling incorrect navigation requests
    
   </h1>
   <p>
    
     Graceful handling of incorrect navigation requests is mandatory in modern web development to ensure a smooth and user-friendly experience.
    
    
     By preventing users from encountering confusing error
    
    <a id="_idIndexMarker460">
    </a>
    
     messages or broken links, you make your application feel professional and reliable.
    
    
     While we have already covered unauthorized navigation in
    
    <a href="B22020_08.xhtml#_idTextAnchor273">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     , other error states might unexpectedly occur.
    
    
     How you handle broken links or mistyped URLs defines the quality of the
    
    
     
      user experience.
     
    
   </p>
   <p>
    
     Let’s implement a global, safe redirection to a friendly error page when users face unexpected
    
    
     
      navigation exceptions.
     
    
   </p>
   <h2 id="_idParaDest-333">
    <a id="_idTextAnchor333">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before implementing the safe redirection, you must have something to redirect to.
    
    
     If you have been following along
    
    <a id="_idIndexMarker461">
    </a>
    
     with the entire book or just scaffolded your project, you already have a routable
    
    <strong class="source-inline">
     
      Error
     
    </strong>
    
     component.
    
    
     Otherwise, you can get it from the
    
    <strong class="source-inline">
     
      Modules
     
    </strong>
    
     directory in the
    
    
     
      GitHub repository.
     
    
   </p>
   <h2 id="_idParaDest-334">
    <a id="_idTextAnchor334">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to add a global safe redirection when user
    
    
     
      navigation fails:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file of the
     
     
      
       server-side project.
      
     
    </li>
    <li>
     
      After all the existing middleware registrations, use the
     
     <strong class="source-inline">
      
       UseStatusCodePagesWithRedirects()
      
     </strong>
     
      extension method of
     
     <strong class="source-inline">
      
       WebApplication
      
     </strong>
     
      to register an error redirection middleware and redirect users to the
     
     <strong class="source-inline">
      
       /
      
     </strong>
     
      <strong class="source-inline">
       
        error
       
      </strong>
     
     
      
       route:
      
     
     <pre class="source-code">
//...
//other middleware registrations
app.UseAntiforgery();
app.UseStatusCodePagesWithRedirects("/error");
//...</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-335">
    <a id="_idTextAnchor335">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In Blazor apps, before the introduction of Blazor web apps, you would use the
    
    <strong class="source-inline">
     
      NotFound
     
    </strong>
    
     parameter of
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     to handle users navigating to an unavailable route.
    
    
     Blazor web apps still support the
    
    <strong class="source-inline">
     
      NotFound
     
    </strong>
    
     parameter for backward compatibility, but leveraging the server-side middleware pipeline to resolve status codes provides much
    
    
     
      more flexibility.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     file of the server-side project, where we configure the server-side middleware pipeline.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we locate where the existing middleware registrations end and use the
    
    <strong class="source-inline">
     
      UseStatusCodePagesWithRedirects()
     
    </strong>
    
     method to extend the middleware pipeline.
    
    
     With
    
    <strong class="source-inline">
     
      UseStatusCodePagesWithRedirects()
     
    </strong>
    
     , we define that whenever a server request results in an unhandled error status code, users get redirected to an
    
    <strong class="source-inline">
     
      /error
     
    </strong>
    
     page.
    
    
     With the
    
    <strong class="source-inline">
     
      Error
     
    </strong>
    
     component, we can customize the message, details, and next steps that our
    
    
     
      users see.
     
    
   </p>
   <p>
    
     The added benefit of
    
    <strong class="source-inline">
     
      UseStatusCodePagesWithRedirects()
     
    </strong>
    
     is that it covers all unsuccessful
    
    <a id="_idIndexMarker462">
    </a>
    
     status codes, not just the
    
    <em class="italic">
     
      route not
     
    </em>
    
     <em class="italic">
      
       found
      
     </em>
    
    
     
      case.
     
    
   </p>
   <h2 id="_idParaDest-336">
    <a id="_idTextAnchor336">
    </a>
    
     See also
    
   </h2>
   <p>
    
     We’ve covered
    
    <strong class="source-inline">
     
      UseStatusCodePagesWithRedirects()
     
    </strong>
    
     , as it’s the method most commonly used in UI-based applications.
    
    
     However, it’s just one of the options from the
    
    <strong class="source-inline">
     
      UseStatusCodePages()
     
    </strong>
    
     family of methods.
    
    
     Handling ranges from simple text status representation to fully customized exception-handling logic
    
    
     
      and retries.
     
    
   </p>
   <p>
    
     You can find all available options, with examples of when and how to use each, in the Microsoft
    
    
     
      docs:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-337">
    <a id="_idTextAnchor337">
    </a>
    
     Executing an asynchronous operation with navigation
    
   </h1>
   <p>
    
     In modern web applications, executing common logic during navigation can be crucial for maintaining a seamless user
    
    <a id="_idIndexMarker463">
    </a>
    
     experience and gathering valuable insights.
    
    
     You can implement navigation event logging and achieve a better understanding of user behavior, identify the most
    
    <a id="_idIndexMarker464">
    </a>
    
     frequently used features, and improve them accordingly.
    
    
     You can also implement periodic security checks and refresh a user’s access
    
    
     
      token seamlessly.
     
    
   </p>
   <p>
    
     Let’s log all navigation requests inside the application to understand better which features users use the most so that you can
    
    
     
      prioritize them.
     
    
   </p>
   <h2 id="_idParaDest-338">
    <a id="_idTextAnchor338">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We will work inside the
    
    <strong class="source-inline">
     
      Routes
     
    </strong>
    
     component, which you must already have, as it’s an integral part of the Blazor application.
    
    
     No preparation is required in
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-339">
    <a id="_idTextAnchor339">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to trigger an operation on all navigation inside
    
    
     
      the app:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Routes
      
     </strong>
     
      component
     
     <a id="_idIndexMarker465">
     </a>
     
      and inject a
     
     
      <strong class="source-inline">
       
        Logger
       
      </strong>
     
     
      
       instance:
      
     
     <pre class="source-code">
@inject ILogger&lt;Routes&gt; Logger</pre>
    </li>
    <li>
     
      Initialize an
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block in the
     
     <strong class="source-inline">
      
       Routes
      
     </strong>
     
      component, and implement a
     
     <strong class="source-inline">
      
       LogNavigation()
      
     </strong>
     
      method
     
     <a id="_idIndexMarker466">
     </a>
     
      that accepts
     
     <strong class="source-inline">
      
       NavigationContext
      
     </strong>
     
      and logs the path that the
     
     
      
       user entered:
      
     
     <pre class="source-code">
@code {
    private void LogNavigation(
        NavigationContext context)
        =&gt; Logger.LogInformation(
            "User entered: {Path}",
            context.Path);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Routes
      
     </strong>
     
      markup, locate
     
     <strong class="source-inline">
      
       Router
      
     </strong>
     
      and attach the
     
     <strong class="source-inline">
      
       LogNavigation()
      
     </strong>
     
      method to its
     
     
      <strong class="source-inline">
       
        OnNavigateAsync
       
      </strong>
     
     
      
       callback:
      
     
     <pre class="source-code">
&lt;Router AppAssembly="@typeof(Program).Assembly"
        AdditionalAssemblies="new[]
        {
            typeof(Client._Imports).Assembly,
            typeof(ExternalEventManager).Assembly
        }"
        OnNavigateAsync="@LogNavigation"&gt;
    @* here's further router configuration *@
&lt;/Router&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-340">
    <a id="_idTextAnchor340">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Routes
     
    </strong>
    
     component.
    
    
     You learned about
    
    <strong class="source-inline">
     
      Routes
     
    </strong>
    
     in the
    
    <em class="italic">
     
      Enabling routes from multiple assemblies
     
    </em>
    
     recipe.
    
    
     First, we inject an instance of
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     interface simplifies logging information in applications and allows you to log messages with
    
    <a id="_idIndexMarker467">
    </a>
    
     different severity levels (such as information, warning, or error) without depending on a
    
    <a id="_idIndexMarker468">
    </a>
    
     specific logging implementation.
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     allows you to provide a logger category, which is then reflected in logs, implying the log source.
    
    
     In our case, we declare the
    
    <strong class="source-inline">
     
      Routes
     
    </strong>
    
     as the logger category.
    
    
     You can find more logging resources in the
    
    <em class="italic">
     
      See also
     
    </em>
    
     section at the end of
    
    
     
      the recipe.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we initialize an
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block and implement a
    
    <strong class="source-inline">
     
      LogNavigation()
     
    </strong>
    
     method.
    
    <strong class="source-inline">
     
      LogNavigation()
     
    </strong>
    
     accepts
    
    <strong class="source-inline">
     
      NavigationContext
     
    </strong>
    
     , which provides information about the navigation event.
    
    
     By accessing the
    
    <strong class="source-inline">
     
      Path
     
    </strong>
    
     property of the
    
    <strong class="source-inline">
     
      NavigationContext
     
    </strong>
    
     , we can pass the navigation destination path to
    
    <strong class="source-inline">
     
      Logger
     
    </strong>
    
     and log the path the user
    
    
     
      navigated to.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      Routes
     
    </strong>
    
     markup.
    
    
     Here, we find the
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     construction.
    
    
     The
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     component exposes an
    
    <strong class="source-inline">
     
      OnNavigateAsync
     
    </strong>
    
     callback, so we attach the
    
    <strong class="source-inline">
     
      LogNavigation()
     
    </strong>
    
     method there.
    
    
     Now, with each navigation request,
    
    <strong class="source-inline">
     
      Router
     
    </strong>
    
     will invoke the
    
    <strong class="source-inline">
     
      OnNavigateAsync
     
    </strong>
    
     callback and trigger the
    
    <strong class="source-inline">
     
      LogNavigation()
     
    </strong>
    
     method, effectively logging every path our users enter inside
    
    
     
      the application.
     
    
   </p>
   <p>
    
     By default, you will have a
    
    <strong class="source-inline">
     
      Console
     
    </strong>
    
     logger registered, but you can freely extend the logging behavior to cover your business use case.
    
    
     You can either implement your own logger or find multiple NuGet packages that support logging from different
    
    
     
      hosting models.
     
    
   </p>
   <h2 id="_idParaDest-341">
    <a id="_idTextAnchor341">
    </a>
    
     See also
    
   </h2>
   <p>
    
     You can learn more about logging by checking out the Microsoft learning
    
    
     
      resources:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/logging">
     
      
       https://learn.microsoft.com/en-us/dotnet/core/extensions/logging
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-342">
    <a id="_idTextAnchor342">
    </a>
    
     Canceling a long-running task when users navigate away
    
   </h1>
   <p>
    
     Depending on the traffic in your
    
    <a id="_idIndexMarker469">
    </a>
    
     application, long-running tasks can negatively impact performance and user experience if you don’t properly manage them.
    
    
     With components rendered in SSR mode, the server handles cancellations for you, similar to what happens in web API projects.
    
    
     But in interactive modes, when state is persisted either on the server or the client side when users navigate away from a page where a long-running task is in progress, it’s essential that you gracefully cancel the task to free up resources and prevent
    
    
     
      unnecessary processing.
     
    
   </p>
   <p>
    
     Let’s implement a graceful cancellation of long-running tasks with the help of Blazor’s
    
    <strong class="source-inline">
     
      NavigationManager
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       CancellationToken
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-343">
    <a id="_idTextAnchor343">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore graceful cancellation of a long-running task when a user navigates away, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       DeepLinks
      
     </strong>
     
      files from the
     
     <em class="italic">
      
       Implementing unified deep linking
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      As
     
     <strong class="source-inline">
      
       DeepLinks
      
     </strong>
     
      contains recipe-specific routes and routes in the application must be unique, update the paths with
     
     <strong class="source-inline">
      
       ch09r07
      
     </strong>
     
      to reflect the
     
     
      
       current recipe
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Source
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-344">
    <a id="_idTextAnchor344">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to trigger graceful cancellation when a user
    
    
     
      navigates away:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      component, and then enhance it to render it in
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode and implement
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      .
     
     
      We will
     
     <a id="_idIndexMarker470">
     </a>
     
      address the resulting compilation
     
     
      
       error shortly:
      
     
     <pre class="source-code">
@rendermode InteractiveWebAssembly
@implements IDisposable</pre>
    </li>
    <li>
     
      At the top of the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      ,
     
     
      
       inject
      
     
     
      <strong class="source-inline">
       
        NavigationManager
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
[Inject] private NavigationManager Nav { get; init; }</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       Nav
      
     </strong>
     
      injection, declare a
     
     <strong class="source-inline">
      
       _cts
      
     </strong>
     
      variable of
     
     
      
       type
      
     
     
      <strong class="source-inline">
       
        CancellationTokenSource
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
private CancellationTokenSource _cts;</pre>
    </li>
    <li>
     
      At the end of the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      , implement a
     
     <strong class="source-inline">
      
       CancelTask()
      
     </strong>
     
      method, matching the signature for an
     
     <strong class="source-inline">
      
       EventHandler
      
     </strong>
     
      object returning
     
     <strong class="source-inline">
      
       LocationChangedEventArgs
      
     </strong>
     
      , which acts as a proxy to call the
     
     <strong class="source-inline">
      
       Cancel()
      
     </strong>
     
      method of the
     
     
      <strong class="source-inline">
       
        _cts
       
      </strong>
     
     
      
       object:
      
     
     <pre class="source-code">
private void CancelTask(object sender,
    LocationChangedEventArgs args) =&gt; _cts?.Cancel();</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       CancelTask()
      
     </strong>
     
      method, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      life cycle method and subscribe the
     
     <strong class="source-inline">
      
       CancelTask()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       LocationChanged
      
     </strong>
     
      event exposed by the
     
     
      
       injected
      
     
     
      <strong class="source-inline">
       
        Nav
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; Nav.LocationChanged += CancelTask;</pre>
    </li>
    <li>
     
      Next to
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      , implement a
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     
      method required by the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      interface, where
     
     <a id="_idIndexMarker471">
     </a>
     
      you safely unsubscribe from the
     
     <strong class="source-inline">
      
       LocationChanged
      
     </strong>
     
      event and gracefully dispose of the
     
     
      <strong class="source-inline">
       
        _cts
       
      </strong>
     
     
      
       instance:
      
     
     <pre class="source-code">
public void Dispose()
{
    Nav.LocationChanged -= CancelTask;
    _cts?.Dispose();
}</pre>
    </li>
    <li>
     
      To complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       GetAsync()
      
     </strong>
     
      method, where you get
     
     <strong class="source-inline">
      
       eventId
      
     </strong>
     
      from
     
     <strong class="source-inline">
      
       Source
      
     </strong>
     
      , and redirect the user to the event
     
     
      
       details page:
      
     
     <pre class="source-code">
private async Task GetAsync()
{
    _cts = new();
    var eventId = await Source.LoadAsync(_cts.Token);
    if (_cts.IsCancellationRequested) return;
    Nav.NavigateTo($"/ch09r07/{eventId}");
}</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      markup area, and below the header, replace the fast-return clause when
     
     <strong class="source-inline">
      
       EventId
      
     </strong>
     
      is not set with a rendering of a button, allowing users to load an event if it has not
     
     
      
       yet loaded:
      
     
     <pre class="source-code">
@if (EventId == default)
{
    &lt;button class="btn btn-primary"
            @onclick="@GetAsync"&gt;
        Get event
    &lt;/button&gt;
    return;
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-345">
    <a id="_idTextAnchor345">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     component and declare it to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode, as we want to monitor the execution of a long-running task to cancel it if needed.
    
    
     We also need
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     to implement
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     .
    
    
     Declaring the component as
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     results in a compilation error, but we will resolve it
    
    <a id="_idIndexMarker472">
    </a>
    
     before the end of
    
    
     
      the recipe.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we inject a
    
    <strong class="source-inline">
     
      NavigationManager
     
    </strong>
    
     instance at the top of the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      NavigationManager
     
    </strong>
    
     instance allows us to react to navigation and location changes.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we set up the backbone of graceful task cancellation by declaring a
    
    <strong class="source-inline">
     
      CancellationTokenSource
     
    </strong>
    
     variable.
    
    
     With
    
    <strong class="source-inline">
     
      CancellationTokenSource
     
    </strong>
    
     , we can signal and manage cancellation requests for
    
    
     
      asynchronous operations.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      CancelTask()
     
    </strong>
    
     method with a signature matching an
    
    <strong class="source-inline">
     
      EventHandler
     
    </strong>
    
     object returning
    
    <strong class="source-inline">
     
      LocationChangedEventArgs
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      CancelTask()
     
    </strong>
    
     method’s responsibility is to invoke
    
    <strong class="source-inline">
     
      Cancel()
     
    </strong>
    
     of the
    
    <strong class="source-inline">
     
      _cts
     
    </strong>
    
     instance and cancel all running operations, depending on that instance.
    
    
     We leverage the
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     operator, called a
    
    <strong class="bold">
     
      null-conditional operator
     
    </strong>
    
     , as it
    
    <a id="_idIndexMarker473">
    </a>
    
     allows us to invoke a method or access to a member only if the preceding object (
    
    <strong class="source-inline">
     
      _cts
     
    </strong>
    
     in this case) is not
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     life cycle method of
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     and subscribe
    
    <strong class="source-inline">
     
      CancelTask()
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      LocationChanged
     
    </strong>
    
     event exposed by
    
    <strong class="source-inline">
     
      Nav
     
    </strong>
    
     .
    
    
     Blazor triggers the
    
    <strong class="source-inline">
     
      LocationChanged
     
    </strong>
    
     event whenever a user navigates to a new location within the application.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we complete the implementation of
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     by constructing a
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method.
    
    
     In the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method, we safely unsubscribe from the
    
    <strong class="source-inline">
     
      LocationChanged
     
    </strong>
    
     event to prevent memory leaks.
    
    
     We also dispose of the
    
    <strong class="source-inline">
     
      _cts
     
    </strong>
    
     instance using the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method it exposes.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block by implementing a
    
    <strong class="source-inline">
     
      GetAsync()
     
    </strong>
    
     method to test the graceful cancellation of a long-running task.
    
    
     As part of
    
    <strong class="source-inline">
     
      GetAsync()
     
    </strong>
    
     , we initialize a new
    
    <strong class="source-inline">
     
      _cts
     
    </strong>
    
     instance and call the
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method of the
    
    <strong class="source-inline">
     
      Source
     
    </strong>
    
     class, passing in a
    
    <strong class="source-inline">
     
      CancellationToken
     
    </strong>
    
     sourced from the
    
    <strong class="source-inline">
     
      _cts
     
    </strong>
    
     instance.
    
    <strong class="source-inline">
     
      CancellationToken
     
    </strong>
    
     allows
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     to be aware of any cancellation requests as it executes.
    
    
     As we expect loading cancellations, we add a
    
    <strong class="source-inline">
     
      _cts
     
    </strong>
    
     state-check.
    
    
     With the
    
    <strong class="source-inline">
     
      IsCancellationRequested
     
    </strong>
    
     property, we can verify whether cancellation was requested and short-circuit the code execution.
    
    
     Lastly, if
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     completes, we redirect the user to the appropriate event
    
    
     
      details page.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     markup and add a simple button, allowing users to trigger
    
    <strong class="source-inline">
     
      GetAsync()
     
    </strong>
    
     and put the implementation to the test.
    
    
     You can run the application and click the
    
    <strong class="bold">
     
      Get event
     
    </strong>
    
     button.
    
    
     The
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method from the
    
    <strong class="source-inline">
     
      Source
     
    </strong>
    
     has a hardcoded delay of five seconds and logs status messages to your browser console.
    
    
     If you
    
    <a id="_idIndexMarker474">
    </a>
    
     navigate away from the
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     page before the timer elapses, you will see that the saving request you’ve queued was
    
    
     
      gracefully canceled.
     
    
   </p>
   <div><div><img alt="Figure 9.1: Messages in the browser console, indicating graceful task cancellation" src="img/Figure_9.1_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.1: Messages in the browser console, indicating graceful task cancellation
    
   </p>
   <h1 id="_idParaDest-346">
    <a id="_idTextAnchor346">
    </a>
    
     Controlling navigation history
    
   </h1>
   <p>
    
     The
    
    <strong class="source-inline">
     
      NavigationManager
     
    </strong>
    
     in Blazor uses
    
    <a id="_idIndexMarker475">
    </a>
    
     the browser’s
    
    <strong class="bold">
     
      History API
     
    </strong>
    
     to maintain navigation history.
    
    
     Manipulating navigation history is particularly useful when authenticating users with
    
    <a id="_idIndexMarker476">
    </a>
    
     external identity providers, where users are redirected back to an application after authentication.
    
    
     It’s also beneficial when displaying intermediate pages that allow users to configure their application, but you want to restrict them from going backward in
    
    
     
      that process.
     
    
   </p>
   <p>
    
     Let’s simulate intermediate page removal from the browser history and force users to navigate to the last stable page when they try to return to the
    
    
     
      intermediate stage.
     
    
   </p>
   <h2 id="_idParaDest-347">
    <a id="_idTextAnchor347">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore browser navigation history manipulations, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe08
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       DeepLinks
      
     </strong>
     
      files from the
     
     <em class="italic">
      
       Canceling a long running task when users navigate away
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      As
     
     <strong class="source-inline">
      
       DeepLinks
      
     </strong>
     
      contains recipe-specific routes and routes in the application must be unique, update the paths with
     
     <strong class="source-inline">
      
       ch09r08
      
     </strong>
     
      to reflect the
     
     
      
       current recipe
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Source
      
     </strong>
     
      file
     
     <a id="_idIndexMarker477">
     </a>
     
      from the
     
     <strong class="source-inline">
      
       Chapter09
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-348">
    <a id="_idTextAnchor348">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to replace an entry in the browser’s
    
    
     
      navigation history:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       ExternalEventManager
      
     </strong>
     
      and find the
     
     
      <strong class="source-inline">
       
        GetAsync()
       
      </strong>
     
     
      
       method.
      
     
    </li>
    <li>
     
      Inside
     
     <strong class="source-inline">
      
       GetAsync()
      
     </strong>
     
      , when invoking the
     
     <strong class="source-inline">
      
       NavigateTo()
      
     </strong>
     
      method of the injected
     
     <strong class="source-inline">
      
       NavigationManager
      
     </strong>
     
      , explicitly set the additional
     
     <strong class="source-inline">
      
       replace
      
     </strong>
     
      parameter
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        true
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
private async Task GetAsync()
{
    //... event getting logic
    Nav.NavigateTo($"/ch09r08/{eventId}",
        replace: true);
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-349">
    <a id="_idTextAnchor349">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      ExternalEventManager
     
    </strong>
    
     .
    
    
     Here, in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we have a
    
    <strong class="source-inline">
     
      GetAsync()
     
    </strong>
    
     method that users trigger when retrieving event details from an external source.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we extend the
    
    <strong class="source-inline">
     
      GetAsync()
     
    </strong>
    
     navigation logic by passing
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     as the
    
    <strong class="source-inline">
     
      replace
     
    </strong>
    
     argument.
    
    
     With the
    
    <strong class="source-inline">
     
      replace
     
    </strong>
    
     argument in
    
    <strong class="source-inline">
     
      NavigationManager.NavigateTo()
     
    </strong>
    
     , we ensure that the current entry in the browser’s history is replaced with the new URL rather than adding a
    
    
     
      new entry.
     
    
   </p>
   <p>
    
     If a user hasn’t loaded any event yet, we will display a page with a button allowing them to load an event.
    
    
     After
    
    <a id="_idIndexMarker478">
    </a>
    
     clicking the button, they get redirected to the event details page automatically.
    
    
     From there, when users try to navigate back, they will land on whatever page they were on before getting the event.
    
    
     The browser will not be aware of the intermediate step of loading the event in the
    
    
     
      first place.
     
    
   </p>
  </div>
 </body></html>