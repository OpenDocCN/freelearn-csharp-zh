<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-124">
    <a id="_idTextAnchor154">
    </a>
    
     10
    
   </h1>
   <h1 id="_idParaDest-125">
    <a id="_idTextAnchor155">
    </a>
    
     Profiling and Identifying Bottlenecks
    
   </h1>
   <p>
    
     As your minimal API project evolves, the potential for performance bottlenecks increases.
    
    
     Working with data, making connections over networks, and running business logic and calculations – all these activities have a performance cost.
    
    
     If configured the wrong way, these activities could incur a higher than
    
    
     
      necessary cost.
     
    
   </p>
   <p>
    
     In this chapter, we are going to explore strategies for analyzing resource utilization, identifying common bottlenecks, and implementing them.
    
    
     We will cover
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      An introduction to profiling and
     
     
      
       performance monitoring
      
     
    </li>
    <li>
     
      Profiling tools
     
     
      
       and techniques
      
     
    </li>
    <li>
     
      Common
     
     
      
       performance bottlenecks
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-126">
    <a id="_idTextAnchor156">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You will need Visual Studio 2022 or Visual Studio code running, at minimum, a new ASP.NET core minimal API project.
    
    
     It is recommended to use the code from the previous chapter, as we will be working with performance examples within the context of the
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     API project.
    
    
     Because the examples in this chapter are run against the code examples in
    
    <a href="B20968_10.xhtml#_idTextAnchor154">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     , you will need to have Entity Framework installed as per the instructions in the previous chapter.
    
    
     (See the
    
    <em class="italic">
     
      Configuring Entity Framework in minimal API projects
     
    </em>
    
     section in
    
    <a href="B20968_09.xhtml#_idTextAnchor143">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     
      .)
     
    
   </p>
   <h1 id="_idParaDest-127">
    <a id="_idTextAnchor157">
    </a>
    
     An introduction to profiling and performance monitoring
    
   </h1>
   <p>
    
     At the beginning of
    
    <a id="_idIndexMarker398">
    </a>
    
     this chapter, we established that the code we run in a minimal API
    
    <a id="_idIndexMarker399">
    </a>
    
     application will incur performance costs, some of which could be presented as bottlenecks, hampering the efficiency of the overall system.
    
    
     To remedy this, we can leverage a profiling tool, also known as
    
    
     
      a profiler.
     
    
   </p>
   <h2 id="_idParaDest-128">
    <a id="_idTextAnchor158">
    </a>
    
     Introducing the profiler
    
   </h2>
   <p>
    
     A
    
    <strong class="bold">
     
      profiler
     
    </strong>
    
     is
    
    <a id="_idIndexMarker400">
    </a>
    
     a piece of software that measures the cost of running code.
    
    
     While your API application runs, the profiler will provide telemetry that outlines how expensive certain areas of the code base are in terms of resource usage.
    
    
     This allows us to identify areas of inefficiency, which is critical to optimizing the performance of your minimal API applications.
    
    
     This is an important practice for many reasons, not limited to
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Scalability
      
     </strong>
     
      : The ability to ensure that your code will be able to perform at an increasing rate
     
     
      
       of demand.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Availability
      
     </strong>
     
      : Access to the API to outside clients is paramount.
     
     
      If clients cannot access the API because of a lack of available hardware resources, the application has
     
     
      
       lost availability.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Security
      
     </strong>
     
      : The connection between the client and API should not be open for any longer than necessary.
     
     
      If your API takes a long time to complete a request, the connection is open for longer, leaving more opportunities for malicious activity
     
     
      
       to occur.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Cost
      
     </strong>
     
      : The financial cost of not optimizing a system can be severe.
     
     
      If production servers frequently require upgrades because of software bottlenecks, each scale-up of the hardware incurs
     
     
      
       financial costs.
      
     
    </li>
    <li>
     <strong class="bold">
      
       User experience
      
     </strong>
     
      : Ensuring that your API runs as quickly as possible ensures that people will have a positive experience, securing repeat usage of
     
     
      
       the application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Error detection
      
     </strong>
     
      : While profiling allows for the detection of bottlenecks, it can also indirectly reveal other bugs in the code base that may not have been detected by unit or
     
     
      
       integration testing.
      
     
    </li>
   </ul>
   <p>
    
     Along the same vein, the
    
    <a id="_idIndexMarker401">
    </a>
    
     advantages of profiling minimal APIs
    
    
     
      are considerable:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Latency reduction
      
     </strong>
     
      : With profiling, response times can be increased, resulting in a much more
     
     
      
       responsive API.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Optimal hardware usage
      
     </strong>
     
      : Profiling can help you see where you are overconsuming resources such as CPU, memory,
     
     
      
       and I/O.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Preventative measures
      
     </strong>
     
      : Running a profiler to identify potential optimizations allows developers to get ahead of potential future issues, letting them make planned changes rather than
     
     
      
       reactionary ones.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Maintenance
      
     </strong>
     
      : Overall, a
     
     <a id="_idIndexMarker402">
     </a>
     
      more performant code base is usually easier to maintain.
     
     
      If the minimal API application is easy to maintain, it will likely see a more frequent
     
     
      
       release cadence.
      
     
    </li>
   </ul>
   <p>
    
     Next, let’s look at some
    
    
     
      performance metrics.
     
    
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor159">
    </a>
    
     Performance metrics
    
   </h2>
   <p>
    
     Before
    
    <a id="_idIndexMarker403">
    </a>
    
     releasing
    
    <a id="_idIndexMarker404">
    </a>
    
     an application for general use, it is difficult to predict how an API will cope under heavy load in an accurate way without performing stress testing and gathering the resulting data.
    
    <strong class="bold">
     
      Performance monitoring
     
    </strong>
    
     can help by providing insights into how your code is performing in specific scenarios.
    
    
     This data in the form of metrics can inform how you optimize your code as you approach release.
    
    
     One of the key things you need to understand from performance metrics is how the resources on the machine hosting the API handle a high volume
    
    
     
      of requests.
     
    
   </p>
   <p>
    
     Profiling can monitor various resources within a minimal API and its dependencies, including
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Response times
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker405">
     </a>
     
      amount of time it takes for a request to be handled by the API, with a response being returning
     
     
      
       the client.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Throughput
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker406">
     </a>
     
      volume of data flowing through a connection at any
     
     
      
       given time.
      
     
    </li>
    <li>
     <strong class="bold">
      
       CPU processing
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker407">
     </a>
     
      amount of processing being completed by the API host’s CPU during requests, or even on other background tasks not related to a
     
     
      
       client request.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Memory
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker408">
     </a>
     
      amount of RAM being consumed by the application at any
     
     
      
       given time.
      
     
    </li>
   </ul>
   <p>
    
     Having access to metrics allows us to start identifying potential bottlenecks so that we can then take steps to address them in the minimal
    
    
     
      API code.
     
    
   </p>
   <p>
    
     For example, the profiler might show a sudden increase in CPU usage during a particular operation.
    
    
     This may indicate that the operation is written in a sub-optimal way (e.g., an unnecessary loop or iteration over
    
    
     
      a collection).
     
    
   </p>
   <p>
    
     With some understanding of profiling and performance monitoring, let’s take a look at some tools and techniques for
    
    
     
      the former.
     
    
   </p>
   <h1 id="_idParaDest-130">
    <a id="_idTextAnchor160">
    </a>
    
     Profiling tools and techniques
    
   </h1>
   <p>
    
     There are many different profiling tools available, but for the purposes of developing minimal APIs in ASP.NET, we will be looking at two examples: the Visual Studio profiler and BenchmarkDotNet.
    
    
     The former is a GUI-based tool, whereas the latter is a library that we can add as a dependency to
    
    
     
      our project.
     
    
   </p>
   <p>
    
     Each of these tools has its strengths in particular use cases, as
    
    
     
      shown here:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       The Visual Studio profiler
      
     </strong>
     
      : It is
     
     <a id="_idIndexMarker409">
     </a>
     
      integrated into the IDE and provides live performance
     
     <a id="_idIndexMarker410">
     </a>
     
      data and CPU and memory metrics.
     
     
      It is ideal for capturing a quick profile, performing basic performance analysis, and identifying areas of high CPU and
     
     
      
       memory usage.
      
     
    </li>
    <li>
     <strong class="bold">
      
       BenchmarkDotNet
      
     </strong>
     
      : It can
     
     <a id="_idIndexMarker411">
     </a>
     
      be installed as
     
     <a id="_idIndexMarker412">
     </a>
     
      a package within a .NET project and is adept at micro-benchmarking.
     
     
      It is used for establishing baseline performance and the fine-tuning
     
     
      
       of code.
      
     
    </li>
   </ul>
   <p>
    
     There are several other potential choices that are not free, such as dotTrace by JetBrains, which is a very competent profiler that can provide the usual resource consumption metrics along with some very in-depth views of the call tree and events over a timeline.
    
    
     I can certainly recommend dotTrace, but as it is not free, we will keep things simple by exploring profiling examples in the Visual Studio profiler
    
    
     
      and BenchmarkDotNet.
     
    
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor161">
    </a>
    
     Profiling in Visual Studio
    
   </h2>
   <p>
    
     Let
    
    <a id="_idIndexMarker413">
    </a>
    
     us start
    
    <a id="_idIndexMarker414">
    </a>
    
     by setting up profiling in
    
    
     
      Visual Studio:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       MyCompany
      
     </strong>
     
      API example in Visual Studio.
     
     
      Then, click
     
     <strong class="bold">
      
       Debug
      
     </strong>
     
      , and select
     
     <strong class="bold">
      
       Performance Profiler
      
     </strong>
     
      .
     
     
      You will see several different options on the screen for various kinds of profiling.
     
     
      For this example, we are going to profile CPU usage to
     
     
      
       demonstrate profiling.
      
     
    </li>
    <li>
     
      Tick
     
     <strong class="bold">
      
       CPU Usage
      
     </strong>
     
      and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Start
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.1: The profiling configuration screen" src="img/B20968_10_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.1: The profiling configuration screen
    
   </p>
   <p class="list-inset">
    
     The aim will be to start profiling so that it is capturing CPU usage data in the background while we are interacting with the API.
    
    
     Once the application stops, a report will be generated that will give us a breakdown of CPU usage over time, which we can then track back to specific lines
    
    
     
      of code.
     
    
   </p>
   <ol>
    <li value="3">
     
      After starting the profiler (ensure that it is recording) your API project will also start running.
     
     
      Interact with the API by calling the
     
     <strong class="source-inline">
      
       GetEmployeeById
      
     </strong>
     
      endpoint, passing an ID value for an existing employee record.
     
     
      You will notice when you make the request that the profiler updates in real time.
     
     
      You should see an increase in CPU usage as soon as the request starts, which settles down again once the request
     
     
      
       has completed.
      
     
    </li>
    <li>
     
      Once
     
     <a id="_idIndexMarker415">
     </a>
     
      you have made some requests to the API, click the
     
     <strong class="bold">
      
       Stop Collection
      
     </strong>
     
      button in the top-left corner of the screen, and then click
     
     <a id="_idIndexMarker416">
     </a>
     
      the
     
     <strong class="bold">
      
       CPU Usage
      
     </strong>
     
      tab (around a quarter of the way down the screen toward the left).
     
     
      The result should be a diagnostic report showing the peaks and dips in CPU usage across the time
     
     
      
       being profiled.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.2: The profiler report for CPU usage" src="img/B20968_10_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.2: The profiler report for CPU usage
    
   </p>
   <p>
    
     As you can see in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     , there was a spike in CPU usage at the beginning of the profiling session.
    
    
     This was at the point that a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request was made to the
    
    <strong class="source-inline">
     
      employees
     
    </strong>
    
     endpoint, with the API handling the request by returning an
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object with the
    
    
     
      given ID.
     
    
   </p>
   <p>
    
     There is a wealth of information that can be filtered in this view.
    
    
     Suffice it to say, a whole book could be written on profiling in .NET alone.
    
    
     However, by way of example, click the
    
    <strong class="bold">
     
      Open Details
     
    </strong>
    
     button toward the top-right corner of the
    
    <strong class="bold">
     
      CPU
     
    </strong>
    
     <strong class="bold">
      
       Usage
      
     </strong>
    
    
     
      pane.
     
    
   </p>
   <p>
    
     The details shown on the screen following this will provide more detailed information about the code that consumes various percentage levels of CPU for the given time.
    
    
     There are several key views, such as the
    
    <strong class="bold">
     
      Call Tree
     
    </strong>
    
     view, which shows the nested relationships
    
    <a id="_idIndexMarker417">
    </a>
    
     between function and method calls (i.e.,
    
    <em class="italic">
     
      what
     
    </em>
    
     <em class="italic">
      
       called what
      
     </em>
    
    
     
      ).
     
    
   </p>
   <div><div><img alt="Figure 10.3: The Call Tree view, showing the CPU consumed by functions at each level of the tree" src="img/B20968_10_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.3: The Call Tree view, showing the CPU consumed by functions at each level of the tree
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Functions
     
    </strong>
    
     view
    
    <a id="_idIndexMarker418">
    </a>
    
     is quite useful in the sense that it can be used to identify which specific lines of code are consuming higher amounts of CPU.
    
    
     By sorting this view by
    
    <strong class="bold">
     
      Total CPU% descending
     
    </strong>
    
     , you can quickly identify the top consumer of CPU.
    
    
     This can be beneficial when performing optimization on a minimal API, as you can gain insights into the underlying functions’ impact on an endpoint’s response time
    
    
     
      for example.
     
    
   </p>
   <p>
    
     What is more, any of the entries in this view can be double-clicked to reveal the original source code, with the CPU usage annotated next to the
    
    
     
      function signature.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Caller/Callee
     
    </strong>
    
     view, which demonstrated what functions are called by and what they themselves call, is particularly insightful in
    
    
     
      this request.
     
    
   </p>
   <p>
    
     Take the example in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     .
    
    
     We can see that for the current function in
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      GetEmployeeById()
     
    </strong>
    
     , the CPU resource was consumed at
    
    <strong class="source-inline">
     
      51.42%
     
    </strong>
    
     .
    
    
     Going deeper, we can see that the function is called into a method within Entity Framework Core.
    
    
     In this case, the function
    
    
     
      was
     
    
    
     <strong class="source-inline">
      
       FirstOrDefault()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      FirstOrDefault()
     
    </strong>
    
     is a
    
    <strong class="bold">
     
      Language Integrated Query
     
    </strong>
    
     (
    
    <strong class="bold">
     
      LINQ
     
    </strong>
    
     ) feature that will get the first item in a
    
    <a id="_idIndexMarker419">
    </a>
    
     collection that meets the given condition, or it will return a default value, in this
    
    
     
      case,
     
    
    
     <strong class="source-inline">
      
       null
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     What we can see in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     is that of the
    
    <strong class="source-inline">
     
      51.42%
     
    </strong>
    
     of CPU usage consumed by
    
    <strong class="source-inline">
     
      GetEmployeeById()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      50.34%
     
    </strong>
    
     of that usage was taken up by
    
    <strong class="source-inline">
     
      FirstOrDefault()
     
    </strong>
    
     ; don’t be surprised
    
    <a id="_idIndexMarker420">
    </a>
    
     if the value you get for the same profiling differs.
    
    
     This
    
    <a id="_idIndexMarker421">
    </a>
    
     value should and would vary between machines.
    
    
     The important thing is that you are able to see a spike
    
    
     
      in usage.
     
    
   </p>
   <div><div><img alt="Figure 10.4: The Caller/Callee view, demonstrating the breakdown of CPU usage for the GetEmployeeById() function" src="img/B20968_10_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.4: The Caller/Callee view, demonstrating the breakdown of CPU usage for the GetEmployeeById() function
    
   </p>
   <p>
    
     This result demonstrates the percentage of CPU usage spread across each function.
    
    
     On its own, this does not necessarily indicate a bottleneck, but it is useful information when troubleshooting performance or for
    
    
     
      general optimization.
     
    
   </p>
   <p>
    
     We could dig into this further by replacing
    
    <strong class="source-inline">
     
      FirstOrDefault()
     
    </strong>
    
     with our own custom implementation of a loop for finding the first employee with the
    
    
     
      matching ID.
     
    
   </p>
   <p>
    
     The loop would look like the
    
    
     
      example here:
     
    
   </p>
   <pre class="source-code">
foreach(var employee in _companyContext.Employees)
{
    if (employee.Id == id)
    {
        return employee;
    }
}
throw new EmployeeNotFoundException(id);</pre>
   <p>
    
     If we run this loop in place of
    
    <strong class="source-inline">
     
      FirstOrDefault()
     
    </strong>
    
     , we can check the same profiling capture and compare the
    
    
     
      CPU usage.
     
    
   </p>
   <p>
    
     In this case, when running the updated code using a loop, we saw a minor increase in CPU usage compared to
    
    <strong class="source-inline">
     
      FirstOrDefault()
     
    </strong>
    
     .
    
    
     So, while
    
    <strong class="source-inline">
     
      FirstOrDefault()
     
    </strong>
    
     is not confirmed to be the most performant method of retrieving
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     for the calling API endpoint, it is
    
    <a id="_idIndexMarker422">
    </a>
    
     confirmed that our alternative is not
    
    <a id="_idIndexMarker423">
    </a>
    
     as performant.
    
    
     This is a process of elimination technique, which is an exercise worth practicing across your whole
    
    
     
      code base.
     
    
   </p>
   <div><div><img alt="Figure 10.5: CPU usage for GetEmployeeById() using a foreach loop instead of FirstOrDefault()" src="img/B20968_10_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.5: CPU usage for GetEmployeeById() using a foreach loop instead of FirstOrDefault()
    
   </p>
   <p>
    
     As mentioned previously, we could go much further into the Visual Studio profiler, but that is beyond the scope of this book.
    
    
     With this foundation, you should now have at least one item in your toolset for optimizing minimal APIs.
    
    
     Let us look at another useful tool for analyzing API performance –
    
    
     
      BenchmarkDotNet.
     
    
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor162">
    </a>
    
     Benchmarking with BenchmarkDotNet
    
   </h2>
   <p>
    <strong class="bold">
     
      BenchmarkDotNet
     
    </strong>
    
     is an
    
    <a id="_idIndexMarker424">
    </a>
    
     open source .NET library designed to facilitate micro-benchmarking in .NET applications.
    
    
     It was created by software engineer, Andrey Akinshin, a prominent member of the .NET community specializing in
    
    
     
      software performance.
     
    
   </p>
   <p>
    
     The project
    
    <a id="_idIndexMarker425">
    </a>
    
     started around 2014 to provide developers with an easy-to-use tool for measuring and comparing the performance of different pieces
    
    
     
      of code.
     
    
   </p>
   <p>
    
     The library is available as a NuGet package and will need to be installed in order for us to run performance benchmarking against the
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     
      API project.
     
    
   </p>
   <p>
    
     To keep things clean, we will perform the benchmarking in another project.
    
    
     However, we can stay within the current Visual Studio setup by adding the new benchmarking project to the
    
    
     
      current solution.
     
    
   </p>
   <p>
    
     In Visual Studio’s Solution Explorer, right-click the current solution and select
    
    <strong class="bold">
     
      Add
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       New Project
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In the
    
    <strong class="bold">
     
      New Project
     
    </strong>
    
     screen
    
    <a id="_idIndexMarker426">
    </a>
    
     there is a search box at the top of the window that allows you to search for a project template.
    
    
     Use this to search for
    
    <strong class="bold">
     
      "C# Console App"
     
    </strong>
    
     .
    
    
     Once you see it, select it and click
    
    <strong class="bold">
     
      "Next"
     
    </strong>
    
     .
    
    
     You will be asked to choose a .NET version.
    
    
     We are using version 9, so leave this selected and
    
    
     
      click
     
    
    
     <strong class="bold">
      
       "Create"
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Next, we will need to add the
    
    <strong class="source-inline">
     
      BenchmarkDotNet
     
    </strong>
    
     library package to the new project via the Package
    
    
     
      Manager Console:
     
    
   </p>
   <pre class="console">
dotnet add package BenchmarkDotNet</pre>
   <p>
    
     The new project is in our solution and has the required libraries installed, but how is it supposed to be able to reference the dependencies from the minimal
    
    
     
      API project?
     
    
   </p>
   <p>
    
     The way to address this is to create a project reference.
    
    
     This allows us to reference object types across multiple .NET projects.
    
    
     This is especially easy when the projects are in the same solution as they are in
    
    
     
      this example.
     
    
   </p>
   <p>
    
     To add the project reference, right-click your new benchmarking project and click
    
    <strong class="bold">
     
      Add
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       Project Reference
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     You will be presented with a dialog box in which you can browse to the project location.
    
    
     Your ASP.NET project should have been compiled
    
    <a id="_idIndexMarker427">
    </a>
    
     as a
    
    <strong class="bold">
     
      Dynamic Link Library
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DLL
     
    </strong>
    
     ) so you should be able to select that from the bin folder within your ASP.NET
    
    
     
      project directory.
     
    
   </p>
   <p>
    
     Now that you have a project reference, you can add using statements to reference types in that project as if they had been created within the
    
    
     
      benchmarking project.
     
    
   </p>
   <p>
    
     We can now move on to setting up our benchmarks and utilizing the dependencies that we would have normally injected, but first, the benchmarks need their own class; so, create one
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       EmployeeBenchmarks
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In this new class, create a private field to
    
    
     
      hold
     
    
    
     <strong class="source-inline">
      
       EmployeeService
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public class EmployeeBenchmarks
{
    private EmployeeService _employeeService;
}</pre>
   <p>
    
     Next, we
    
    <a id="_idIndexMarker428">
    </a>
    
     can create a method that accesses the required dependencies.
    
    
     We will call this method
    
    <strong class="source-inline">
     
      Setup()
     
    </strong>
    
     .
    
    
     We need to annotate this method with an attribute –
    
    <strong class="source-inline">
     
      [
     
    </strong>
    
     <strong class="source-inline">
      
       GlobalSetup]
      
     </strong>
    
   </p>
   <p>
    
     Having this attribute means that BenchmarkDotNet will run the logic inside
    
    <strong class="source-inline">
     
      Setup()
     
    </strong>
    
     before
    
    
     
      benchmarks run:
     
    
   </p>
   <pre class="source-code">
[GlobalSetup]
    public void Setup()
    {
        var services = new ServiceCollection();
        services.AddScoped&lt;MyCompanyContext&gt;();
        services.AddScoped&lt;EmployeeService&gt;();
        var serviceProvider =
            services.BuildServiceProvider();
        _employeeService =
            serviceProvider
                .GetRequiredService&lt;EmployeeService&gt;();
    }</pre>
   <p>
    
     This code uses
    
    <strong class="source-inline">
     
      ServiceCollection
     
    </strong>
    
     , which will require the
    
    <strong class="source-inline">
     
      Microsoft.Extensions.DependencyInjection
     
    </strong>
    
     package to
    
    
     
      be installed.
     
    
   </p>
   <p>
    
     Inside
    
    <strong class="source-inline">
     
      Setup()
     
    </strong>
    
     , we have created the required dependencies and added them to
    
    <strong class="source-inline">
     
      ServiceContainer
     
    </strong>
    
     so that they are ready to be used
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     We have also retrieved
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     and stored it in the private field so that our benchmark can call the
    
    <strong class="source-inline">
     
      GetEmployeeId()
     
    </strong>
    
     function
    
    
     
      within it.
     
    
   </p>
   <p>
    
     Finally, for
    
    <a id="_idIndexMarker429">
    </a>
    
     this class, we add the benchmark itself, which is the important part.
    
    
     We want to create a benchmark for the activity running in Entity Framework so we will call the
    
    <strong class="source-inline">
     
      GetEmployeeId()
     
    </strong>
    
     function so that it interacts with the database via
    
    <strong class="source-inline">
     
      MyCompanyContext
     
    </strong>
    
     , and this activity will be recorded by BenchmarkDotNet.
    
    
     We are passing a hardcoded ID to
    
    <strong class="source-inline">
     
      GetEmployeeById()
     
    </strong>
    
     , because we know that the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     record with ID
    
    <strong class="source-inline">
     
      6
     
    </strong>
    
     exists and that this is not going to change (obviously, you must ensure a record with this ID exists, or change the value from
    
    <strong class="source-inline">
     
      6
     
    </strong>
    
     to one you know to exist in
    
    
     
      the database):
     
    
   </p>
   <pre class="source-code">
  [Benchmark]
  public void GetEmployeeByIdBenchmark()
  {
      var result = _employeeService
          .GetEmployeeById(6)
          .GetAwaiter()
          .GetResult();
  }</pre>
   <p>
    
     Notice the presence of the
    
    <strong class="source-inline">
     
      [Benchmark]
     
    </strong>
    
     attribute decorating the
    
    <strong class="source-inline">
     
      GetEmployeeByIdBenchmark()
     
    </strong>
    
     method.
    
    
     This labels the method as being a relevant benchmark that should
    
    
     
      be run.
     
    
   </p>
   <p>
    
     Now, this is where having a separate console application really helps.
    
    
     In the
    
    <strong class="source-inline">
     
      Main()
     
    </strong>
    
     method of the benchmark console application’s
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     class, we can simply call the static
    
    <strong class="source-inline">
     
      BenchmarkRunner
     
    </strong>
    
     and tell it to run any of the benchmarks in the benchmark class, which it will detect based on the presence of the
    
    <strong class="source-inline">
     
      [
     
    </strong>
    
     <strong class="source-inline">
      
       Benchmark]
      
     </strong>
    
    
     
      attribute:
     
    
   </p>
   <pre class="source-code">
static void Main(string[] args)
{
    var result = BenchmarkRunner.Run&lt;EmployeeBenchmarks&gt;();
}</pre>
   <p>
    
     The benchmarking console application can now be run to provide results for any methods or functions in
    
    <strong class="source-inline">
     
      EmployeeBenchmarks
     
    </strong>
    
     that are annotated with the
    
    <strong class="source-inline">
     
      [
     
    </strong>
    
     <strong class="source-inline">
      
       Benchmark]
      
     </strong>
    
    
     
      attribute.
     
    
   </p>
   <p>
    
     Before running
    
    <a id="_idIndexMarker430">
    </a>
    
     the console application, right-click the console application project in Solution Explorer and select
    
    <strong class="bold">
     
      Set as
     
    </strong>
    
     <strong class="bold">
      
       Startup Project
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Once the console app has finished running, you will see the benchmark output in the console window, as well as a series of files published to the
    
    <strong class="source-inline">
     
      bin
     
    </strong>
    
     directory of the application in a folder called
    
    <strong class="source-inline">
     
      BenchmarkDotNet.Artifacts
     
    </strong>
    
     .
    
    
     Here, you will find the output to the console, as well as the results organized in HTML, Markdown, and
    
    
     
      Excel formats.
     
    
   </p>
   <p>
    
     Let’s look at the most important section of the output.
    
    
     In the result shown in the console, you’ll notice a table.
    
    
     This table contains the benchmarking information
    
    
     
      for
     
    
    
     <strong class="source-inline">
      
       GetEmployeeById()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
| Method                   | Mean     | Error   | StdDev  |
|------------------------- |---------:|--------:|--------:|
| GetEmployeeByIdBenchmark | 171.1 μs | 3.37 μs | 5.63 μs |</pre>
   <p>
    
     This table shows the average time in microseconds that it took to run
    
    <strong class="source-inline">
     
      GetEmployeeById()
     
    </strong>
    
     out of
    
    
     
      several iterations.
     
    
   </p>
   <p>
    
     The average time taken is displayed as a mean value, giving us a measurement we can use as a basis for performance analysis.
    
    
     It would be advisable to note this mean average, and then run benchmarking several more times with different inputs, to provide further re-enforcement of this
    
    
     
      average value.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Error
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      StdDev
     
    </strong>
    
     columns provide some further supporting information.
    
    <strong class="source-inline">
     
      StdDev
     
    </strong>
    
     represents the
    
    <strong class="bold">
     
      standard deviation
     
    </strong>
    
     , which
    
    <a id="_idIndexMarker431">
    </a>
    
     is the amount of variation from the average.
    
    
     A smaller standard deviation means that benchmark times were consistent.
    
    
     If you see a higher standard deviation, it implies more variability in
    
    
     
      average results.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Error
     
    </strong>
    
     column represents the estimated standard deviation of the mean average result, which is an indication of how reliable the result is.
    
    
     The smaller the number, the more reliable
    
    
     
      the result.
     
    
   </p>
   <p>
    
     Again, it makes sense to run several benchmarks with varying inputs.
    
    
     If you are seeing similar standard deviations and errors, you can be confident in the accuracy of
    
    
     
      the results.
     
    
   </p>
   <p class="callout-heading">
    
     Release mode
    
   </p>
   <p class="callout">
    
     Your project will need to be built in Release mode for the preceding profiling to work.
    
    
     If you see the word
    
    <strong class="bold">
     
      Debug
     
    </strong>
    
     in a dropdown in the top ribbon of Visual Studio, change it to
    
    <strong class="bold">
     
      Release
     
    </strong>
    
     and then rebuild
    
    
     
      your project.
     
    
   </p>
   <h1 id="_idParaDest-133">
    <a id="_idTextAnchor163">
    </a>
    
     Common performance bottlenecks
    
   </h1>
   <p>
    
     Let’s look at some common
    
    <a id="_idIndexMarker432">
    </a>
    
     reasons that performance could be degraded and how you might address them.
    
    
     These are by no means applicable to every situation, but they are
    
    
     
      well-known bottlenecks:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Database access
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker433">
     </a>
     
      bottleneck is caused by slow database queries or inefficient use of database connections.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Use asynchronous database
       
       
        
         operations (
        
       
       
        <strong class="source-inline">
         
          async/await
         
        </strong>
       
       
        
         ).
        
       
      </li>
      <li>
       
        Optimize SQL queries and use proper indexing.
       
       
        Look at any
       
       <strong class="source-inline">
        
         WHERE
        
       </strong>
       
        clauses or
       
       <strong class="source-inline">
        
         JOIN
        
       </strong>
       
        operations that might be taxing
       
       
        
         the system.
        
       
      </li>
      <li>
       
        Implement connection pooling to reduce the number of times new connections need to
       
       
        
         be opened.
        
       
      </li>
      <li>
       
        Use a caching system such as ASP.NET’s
       
       <strong class="source-inline">
        
         IMemoryCache
        
       </strong>
       
        for frequently
       
       
        
         accessed data.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       I/O operations
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker434">
     </a>
     
      bottleneck is due to blocking I/O operations, such as file or network access.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Use asynchronous
       
       
        
         I/O operations.
        
       
      </li>
      <li>
       
        Minimize disk and network I/O.
       
       
        Where possible, retrieve commonly required data from memory rather than from persistent storage or over
       
       
        
         a network.
        
       
      </li>
      <li>
       
        Use efficient data formats (e.g., JSON instead
       
       
        
         of XML).
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Serialization/deserialization
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker435">
     </a>
     
      bottleneck arises from slow or inefficient serialization and deserialization of data.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Use optimized serializers such as
       
       <strong class="source-inline">
        
         System.Text.Json
        
       </strong>
       
        instead
       
       
        
         of
        
       
       
        <strong class="source-inline">
         
          Newtonsoft.Json.
         
        </strong>
       
      </li>
      <li>
       
        Minimize the size of the data
       
       
        
         being serialized.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Middleware pipeline
      
     </strong>
     
      :The bottleneck is caused by excessive or inefficient middleware in
     
     <a id="_idIndexMarker436">
     </a>
     
      the request pipeline.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Review and optimize
       
       
        
         middleware components.
        
       
      </li>
      <li>
       
        Remove
       
       
        
         unnecessary middleware.
        
       
      </li>
      <li>
       
        Use
       
       
        
         lightweight middleware.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Logging
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker437">
     </a>
     
      bottleneck results from extensive or synchronous logging.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Use
       
       
        
         asynchronous logging.
        
       
      </li>
      <li>
       
        Reduce the log verbosity level
       
       
        
         in production.
        
       
      </li>
      <li>
       
        Use efficient logging frameworks such
       
       
        
         as Serilog.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Dependency injection (DI)
      
     </strong>
     
      :The bottleneck is due to the inefficient use of dependency
     
     <a id="_idIndexMarker438">
     </a>
     
      injection.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Use scoped or singleton lifetimes
       
       
        
         where appropriate.
        
       
      </li>
      <li>
       
        Avoid unnecessary injections of services.
       
       
        If there is a simpler alternative that avoids dependency injection,
       
       
        
         use it.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Garbage collection (GC) pressure
      
     </strong>
     
      : The bottleneck results from excessive memory
     
     <a id="_idIndexMarker439">
     </a>
     
      allocation, leading to frequent garbage collection.
     
     
      To mitigate this, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Reduce allocations by
       
       
        
         reusing objects.
        
       
      </li>
      <li>
       
        Use value types instead of reference types
       
       
        
         where possible.
        
       
      </li>
      <li>
       
        Optimize data structures and avoid large allocations of objects onto the heap (relates back to using value types over reference types
       
       
        
         where possible).
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Network latency
      
     </strong>
     
      : The bottleneck is caused by high latency in network calls.
     
     
      To mitigate this, do
     
     <a id="_idIndexMarker440">
     </a>
     
      
       the following:
      
     
     <ul>
      <li>
       
        Minimize the number of
       
       
        
         network calls.
        
       
      </li>
      <li>
       
        Implement retry policies with
       
       
        
         exponential backoff.
        
       
      </li>
      <li>
       
        Investigate alternative network protocols, using benchmarking to see whether they are
       
       
        
         less resource-intensive.
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     By having a general understanding of the most common bottlenecks and how they can be mitigated, you will become more vigilant when debugging and reviewing code in
    
    
     
      minimal APIs.
     
    
   </p>
   <p>
    
     We will now recap the various topics we have covered in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor164">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we explored at a high level the various pitfalls and mitigation options for performance issues in
    
    
     
      minimal APIs.
     
    
   </p>
   <p>
    
     We started by outlining the basics of performance analysis and why it is important within not just minimal APIs, but in general
    
    
     
      software engineering.
     
    
   </p>
   <p>
    
     We then reviewed some of the different tools on offer, before narrowing the scope of the tools we would use to the Visual Studio profiler
    
    
     
      and BenchmarkDotNet.
     
    
   </p>
   <p>
    
     Then, we started profiling the
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     API using the Visual Studio profiler, with a breakdown of the various metrics that are outputted into the diagnostic report produced by the profiler.
    
    
     This allowed us to find the overall CPU usage of a section of a code, but then also to break that down further by its called functions lower down in the
    
    
     
      call tree.
     
    
   </p>
   <p>
    
     Moving on to BenchMarkDotNet, we implemented the same analysis example undertaken by the Visual Studio profiler, this time running a performance benchmark against the target method.
    
    
     We then reviewed the output to understand how best to secure an accurate benchmark based on the consistency of the error rate and the
    
    
     
      standard deviation.
     
    
   </p>
   <p>
    
     Like many topics in this book, this is just a scratch of the surface, but it will provide a solid foundation for further optimization of minimal APIs and give you a good grounding in analyzing
    
    
     
      their efficiency.
     
    
   </p>
   <p>
    
     Let’s move on to the next chapter, in which we will be exploring ways to use asynchronous programming to scale
    
    
     
      minimal APIs.
     
    
   </p>
  </div>
 </body></html>