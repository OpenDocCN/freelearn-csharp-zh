- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Characters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: In *Chapter 2*, *Design and Prototype*, we discussed that this book will be
    utilizing a vertical slice method for our model. Being a vertical slice, the project
    is a simplification of the game. It is similar to a demo, but it has all of the
    main mechanics the game would contain, just in a simpler form. It is meant to
    give investors a strong example of what could be an entire game experience. We
    will be showing the character’s behavior to draw the player in and then lead into
    a small portion of the story with mechanics driven by environment puzzles while
    learning about the main character’s past.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第二章**，**设计和原型**中，我们讨论了这本书将采用垂直切片方法来构建我们的模型。作为一个垂直切片，这个项目是对游戏的简化。它类似于一个演示，但包含了游戏将包含的所有主要机制，只是形式更为简单。它的目的是向投资者展示一个可能成为完整游戏体验的强大例子。我们将展示角色的行为来吸引玩家，然后通过环境谜题驱动的机制引入故事的小部分，同时了解主要角色的过去。
- en: 'We will start with the concepts related to the main character; we will then
    model the character out and make changes as we see fit by working through their
    mechanics and movement. We will make a rig for them so they can be animated. After
    this, we will put them in Unity and test out how it feels moving them around in
    the engine. This chapter will be packed with a lot of information, and we will
    be going over many different production concepts to create our character and get
    them properly moving:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从与主要角色相关的概念开始；然后我们将建模角色，并在通过他们的机制和动作进行工作时，根据我们的喜好进行修改。我们将为他们制作一个布线，以便他们可以被动画化。之后，我们将它们放入Unity中，测试在引擎中移动它们的感觉。这一章将包含大量信息，我们将讨论许多不同的制作概念来创建我们的角色，并确保它们能够正确移动：
- en: Design and concept
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和概念
- en: Rigging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布线
- en: Character controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色控制器
- en: Scripting your character’s movement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写角色的动作脚本
- en: Let’s start with the conception phase for Myvari, the main character of our
    small story.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Myvari，我们小故事的主角的概念阶段开始。
- en: Design and concept
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和概念
- en: To make a character, there can be many dimensions. We want to make sure that
    the hero character of this vertical slice, Myvari, is as fleshed out as possible.
    One of the best tools for this is asking “why” for aspects of the character.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要创造一个角色，可以有多个维度。我们想确保这个垂直切片中的英雄角色Myvari尽可能丰满。为此，最好的工具之一是询问“为什么”关于角色的各个方面。
- en: Asking why
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 询问为什么
- en: 'We are building an adventure-based puzzle game. The first question that comes
    to mind is: why is the character on this adventure? In this case, we answered
    that question with: “She is seeking to find answers about her race’s past that
    aren’t in the stories being told or the books she’s read.” Now we’ve defined a
    few things, but there are still more questions.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个基于冒险的解谜游戏。首先想到的问题是：为什么这个角色在这个冒险中？在这种情况下，我们用“她正在寻求找到关于她种族过去的答案，这些答案不在被讲述的故事或她读过的书中。”来回答这个问题。现在我们已经定义了一些事情，但还有更多问题。
- en: 'To give an idea of the questions that came up from this initial answer, look
    at this list:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出从这个初步答案中产生的想法，看看这个列表：
- en: What race is she and why does this matter to the story?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她是什么种族的，这为什么对故事很重要？
- en: Why female?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么是女性？
- en: Why is her history hidden?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么她的历史被隐藏了？
- en: What is her clothing like?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她的服装是什么样的？
- en: What does the race look like?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个种族看起来是什么样子？
- en: Is she humanoid?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她是类人形吗？
- en: As you can see, this can go on for a while, and it should. All of these answers
    should bring more questions. Take them down to their lowest possible components.
    This may seem tedious, but when you are done, you will know how this character
    acts when they are confronted, their facial expressions, behaviors, inside jokes,
    family backstory, and everything in between.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这可以持续一段时间，而且应该如此。所有这些答案都应该带来更多问题。将它们简化到最低可能的组成部分。这可能看起来很繁琐，但当你完成时，你就会知道这个角色在面对挑战时的行为、面部表情、行为、内部笑话、家庭背景，以及所有介于其中的事情。
- en: Concept time!
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念时间！
- en: Now that we have a strong idea of Myvari and who she is, we can draw up concept
    art. We first start out with some proportion work and sketch work to find her
    basic appearance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Myvari和她是谁有了强烈的认识，我们可以绘制概念艺术。我们首先从一些比例工作和草图工作开始，以找到她基本的外观。
- en: On the left in *Figure 4.1*, we also drew up a behavioral take. This gives us
    a visual idea of how she may act in an **idle break** animation. An idle break
    is an animation that occurs when your character remains still for some time. We
    felt that her character would be studious and inquisitive, so she would pull out
    a book and just start studying on the spot.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的 *图 4.1* 中，我们还绘制了一个行为草图。这让我们对她在 **空闲休息** 动画中的可能行为有一个视觉概念。空闲休息是一种当你的角色静止一段时间时发生的动画。我们觉得她的角色会勤奋好学，所以她会拿出书并立即开始学习。
- en: '![](img/B17304_04_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_04_01.png)'
- en: 'Figure 4.1: Initial Myvari sketches'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：初始 Myvari 草图
- en: After we have drawn up the sketches of what she may look like, including giving
    a sense of her personality, we need to get a feel for the colors to finalize the
    design. The color scheme shown in *Figure 4.2* was chosen after answering all
    the previous questions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制出她可能看起来像的草图，包括给她一个性格感之后，我们需要对颜色有一个感觉，以最终确定设计。*图 4.2* 中显示的配色方案是在回答了所有之前的问题后选择的。
- en: Myvari’s overall color themes give the sense of royalty, curiosity, and safety.
    These are depicted through regal clothing with gold lines denoting royalty. Blue
    evokes a sense of safety—a psychological and physical effect, as seeing this color
    lowers our blood pressure. Using blue draws the player slightly more into her
    character, curious about this bright blue amongst the rest of her neutrally colored
    outfit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Myvari 的整体色彩主题给人一种皇室、好奇和安全感。这些感觉通过华丽的服装和金色线条来体现皇室地位。蓝色唤起一种安全感——一种心理和生理效应，因为看到这种颜色会降低我们的血压。使用蓝色会让玩家稍微更多地进入她的角色，对她中性色调服装中的这种明亮的蓝色感到好奇。
- en: Her most unique accessory is her necklace, which has a mechanical purpose. It
    will be the key for the puzzles that she will have to interact with. For this
    reason, the necklace has a color that stands out from the rest of Myvari. This
    color will also be unique in the environment utilizing a concept known as **user
    guidance**, which we will talk about in *Chapter 5*, *Environment*, *Chapter 6*,
    *Interactions and Mechanics*, *Chapter 7*, *Rigid Bodies and Physics Interaction*,
    and *Chapter 12*, *Final Touches*. We will need to use this color continuously
    in the environment, the mechanics, as well as the polishing of the entire vertical
    slice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 她最独特的配饰是她的项链，它具有机械功能。它将是她必须与之互动的谜题的关键。因此，项链的颜色与 Myvari 的其他颜色形成鲜明对比。这种颜色在环境中也将是独特的，它利用了一个称为
    **用户引导** 的概念，我们将在 *第五章*，*环境*，*第六章*，*交互和机制*，*第七章*，*刚体和物理交互* 和 *第十二章*，*最终润色* 中讨论。我们需要在环境、机制以及整个垂直切片的打磨中持续使用这种颜色。
- en: '![](img/B17304_04_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_04_02.png)'
- en: 'Figure 4.2: Myvari’s color scheme'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：Myvari 的配色方案
- en: Once we have a strong idea about the character’s personality and colors, we
    need to move into the 3D versions of concepting. This is less creating and more
    defining a character. The following image depicts the character’s facial features
    using a **sculpting** tool. Our team has a strong background in the use of Pixologic’s
    ZBrush, which allowed us to create the sculpt you see in *Figure 4.3*. 3DCoat
    and Blender also offer sculpting tools.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对角色的性格和颜色有了强烈的想法，我们就需要进入概念设计的 3D 版本。这更多的是定义一个角色，而不是创造。以下图像使用 **雕塑** 工具描绘了角色的面部特征。我们的团队在
    Pixologic 的 ZBrush 的使用方面有很强的背景，这使我们能够创建 *图 4.3* 中看到的雕塑。3DCoat 和 Blender 也提供了雕塑工具。
- en: After we’ve worked through enough iterations with the sculpts, we will use this
    as a beginning high-resolution model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对雕塑进行了足够的迭代工作后，我们将使用这个作为起始的高分辨率模型。
- en: Now that we’ve defined our primary high-res sculpt, we can move on to getting
    a low-res model out of ZBrush.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的主要高分辨率雕塑，我们可以继续进行从 ZBrush 中获取低分辨率模型的工作。
- en: '![](img/B17304_04_03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_04_03.png)'
- en: 'Figure 4.3: Myvari’s high-resolution head sculpt'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：Myvari 的高分辨率头部雕塑
- en: The low-res model will be our scale bias for everything in the game, as seen
    below in *Figure 4.4*. When you are creating buildings, flora, fauna, or characters,
    this model will act as the universal **scale** for them. There are multiple ways
    to work through scale, however, I know that this character is the main creature
    in this game; all of the items will be environmental or props, which will all
    be scaled off her size as the base scale.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 低分辨率模型将成为游戏中所有事物的比例偏差，如图 4.4 中所示。当你创建建筑、植物、动物或角色时，这个模型将作为它们的通用 **比例**。然而，有多种处理比例的方法，但我知道这个角色是游戏中的主要生物；所有物品都将作为环境或道具，它们都将基于她的尺寸作为基础比例。
- en: '![](img/B17304_04_04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_04_04.png)'
- en: 'Figure 4.4: Myvari’s low-resolution head sculpt'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：Myvari的低分辨率头部雕刻
- en: Some other ways scaling can be done is by building to scale. Unity’s units are
    centimeters. If you build to a meter and then export from your Digital Content
    Creation (**DCC**) as a centimeter, everything will follow a single unit scale.
    This is a great way to build if you are building a large game with many teams
    working around the world. You could also build the game around the environment
    itself. An example of this could be a top-down game using squares for environment
    creation, so it all clicks together. The squares may be a 10^(th) of the screen.
    From this information, you would take a screenshot at the resolution expected,
    then draw the character concepts on that picture to fit the scale. Look at your
    project and look through what the single point of scale that you can build off
    is. This will ultimately save you time down the road.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些进行缩放的方法是通过按比例构建。Unity的单位是厘米。如果你按米来构建，然后从你的数字内容创作（**DCC**）以厘米为单位导出，所有内容都将遵循单一的单位比例。如果你正在构建一个由世界各地的许多团队协作的大型游戏，这是一个很好的构建方式。你也可以围绕环境本身来构建游戏。一个例子可能是使用方块来创建环境的俯视游戏，这样所有东西都能完美拼接。方块可能是屏幕的1/10。从这个信息中，你会在预期的分辨率下拍摄一张截图，然后在图片上绘制角色概念以适应比例。看看你的项目，看看你可以构建的单一比例点。这最终会节省你未来的时间。
- en: You could potentially just build whatever you can and scale the item in-game
    after it’s imported. However, what will happen with that is the mechanics may
    not work properly. Think about games like Tomb Raider or Assassin’s Creed, where
    the main character must climb onto walls. This requires the character to have
    a very specific height and a large amount of conditioning to ensure they are in
    the right spot at the right time for the animation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能只是构建你能构建的任何东西，然后在导入到游戏中后对其进行缩放。然而，这样做的结果是，机制可能不会正常工作。想想像《古墓丽影》或《刺客信条》这样的游戏，其中主要角色必须爬上墙壁。这要求角色具有非常特定的身高和大量的训练，以确保他们在动画的正确时间和地点。
- en: Rigging
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布线
- en: After working through this whole concepting phase, we need to work on getting
    some bones into the character so we can animate her. We will be using Autodesk’s
    Maya 2022 to rig our character. The points we will go over will be principles,
    not technical details. Depending on your DCC tool, you may encounter slightly
    different terminology, however, the following terms will generally apply to any
    of the major DCCs in use for game development.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成整个概念阶段的工作后，我们需要在角色中添加一些骨骼，以便我们可以对她进行动画处理。我们将使用Autodesk的Maya 2022来为我们的角色布线。我们将讨论的原则不是技术细节。根据你的DCC工具，你可能会遇到略微不同的术语，但是以下术语通常适用于任何用于游戏开发的DCC的主要工具。
- en: Animation-first thinking
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以动画为先的思考
- en: When beginning the rigging task, the most efficient way to work is by having
    a detailed conversation about the animations themselves with the artists who will
    be responsible for them. Even if you’re doing the animations yourself, successful
    rigs are ones that ensure the animator doesn’t need an explanation of what each
    control does. There may be some technical attributes, but overall if a control
    doesn’t need something, it should be locked and hidden.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始布线任务时，最有效的工作方式是与将负责这些动画的艺术家进行详细的对话。即使你自己做动画，成功的布线应该是确保动画师不需要解释每个控制的作用。可能会有一些技术属性，但总体来说，如果一个控制不需要某些东西，它应该被锁定并隐藏。
- en: When the animator moves a control that oversees the hand, they may expect all
    the finger controls to be on that control. This is intuitive but it shouldn’t
    be assumed that the animator needs this. They may want all individual controls
    to be placed on their own control.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画师移动控制手部的控制时，他们可能期望所有手指控制都在那个控制上。这是直观的，但不应该假设动画师需要这个。他们可能希望所有单独的控制都放在他们自己的控制上。
- en: Deformation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变形
- en: This is the ability for a mesh to be able to bend in a predetermined way, such
    as the elbows or knees. Since you know how they will be bending, you can plan
    your mesh for that deformation to be possible with a proper **edge flow** in your
    model. Edge flow is an art form all on its own, ensuring that there is enough
    geometry to keep the shape when deforming. An example edge flow can be seen in
    *Figure 4.5*. Take your time working through other AAA model examples and learn
    how each body structure may bend.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网格能够以预定方式弯曲的能力，例如肘部或膝盖。由于你知道它们会如何弯曲，你可以规划你的网格，使其在模型中通过适当的**边流**实现这种变形。边流是一种艺术形式，它确保在变形时有足够的几何形状来保持形状。一个边流的例子可以在*图4.5*中看到。花时间研究其他AAA模型示例，了解每个身体结构可能如何弯曲。
- en: '![](img/B17304_04_05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_04_05.png)'
- en: 'Figure 4.5: Example of edge flow on a humanoid'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：人类边流示例
- en: Facial deformation is by far the most specific deformation. If you are planning
    on having any facial deformation when you start rigging, look for some videos
    explaining how to set up the character for this. Facial expressions are intricate
    and hard to do correctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 面部变形是最具体的变形。如果你在开始绑定时计划进行任何面部变形，寻找一些解释如何为这种变形设置角色的视频。面部表情复杂且难以正确完成。
- en: A small example of edge flow and separation can be seen in *Figure 4.6*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.6*中可以看到边流和分离的小示例。
- en: '![](img/B17304_04_06.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_04_06.png)'
- en: 'Figure 4.6: Example of facial edge flow'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：面部边流示例
- en: Facial deformation done correctly will result in your character producing relatable
    expressions. This can accentuate the experience by bolstering the immersion through
    emotion. If you plan on having close-ups of your character, it’s a good idea to
    take the time to work through facial deformation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正确完成面部变形将使你的角色产生令人信服的表情。这可以通过增强情感沉浸感来增强体验。如果你计划在角色有特写镜头时，花时间研究面部变形是个好主意。
- en: Hierarchy
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次结构
- en: 'Hierarchy and parenting are an integral part of rigging knowledge. When Unity
    imports a skeletal mesh, there may be transforms that your DCC had in place. This
    can sometimes be a grouping or hierarchical change that has its own transform.
    Unity would see these items as GameObjects and place them in the same spot in
    the Hierarchy of the skeleton. Every application may be slightly different. An
    example of this is with Maya: if your hierarchy has a group node as a parent of
    your rig, Unity will think this is a transform of its own and import it as such.
    This may not cause an issue in the beginning with no logic on the GameObject,
    but it’s always best to be as clean as possible. If you are using Maya, we recommend
    that you don’t have any parent nodes on the skeleton you will be binding.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构和父子关系是绑定知识的组成部分。当Unity导入骨骼网格时，你的DCC可能已经设置了变换。这有时可能是一个分组或层次结构变化，它有自己的变换。Unity将这些项目视为GameObject，并将它们放置在骨骼层次结构中的相同位置。每个应用程序可能略有不同。例如，在Maya中：如果你的层次结构有一个组节点作为你的绑定的父节点，Unity会认为这是一个它自己的变换并将其导入。这可能不会在开始时引起问题，因为GameObject上没有逻辑，但始终最好尽可能干净。如果你使用Maya，我们建议你不在你将要绑定的骨骼上使用任何父节点。
- en: 'This brings up a topic that is interesting to work with: the **control rig**.
    The most customizable rig that we’ve worked with was a binding rig, which was
    bound to all the vertices on the character. This was then driven directly by a
    duplicate rig, which we called a control rig. This allowed for the bind rig to
    only worry about the inputs of a single entity. This is important as sometimes
    you may want to have multiple deforming tools moving around the rig. You might
    want a separate squash control and twist control. All this logic on the control
    rig will drive the bind rig without worrying about breaking the binding on the
    character.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个有趣的工作主题：**控制绑定**。我们使用过的最可定制的绑定是绑定绑定，它绑定到角色的所有顶点上。然后，它直接由一个副本绑定驱动，我们称之为控制绑定。这允许绑定绑定只关注单个实体的输入。这很重要，因为有时你可能希望有多个变形工具在绑定周围移动。你可能需要一个单独的挤压控制和扭曲控制。所有这些逻辑都在控制绑定上，而不必担心破坏角色的绑定。
- en: Bones or joints
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 骨骼或关节
- en: Bones and joints are terms used interchangeably in rigging. The bind skeleton
    consists only of bones or joints in its own Hierarchy from the root, through the
    spine, arms, legs, neck, and head. These bones can be seen in *Figure 4.7* below.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定中，骨骼和关节是可互换使用的术语。绑定骨骼在其自己的层次结构中仅由骨骼或关节组成，从根节点开始，经过脊柱、手臂、腿部、颈部和头部。这些骨骼可以在下面的*图4.7*中看到。
- en: '![](img/B17304_04_07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_04_07.png)'
- en: 'Figure 4.7: Examples of joints of character inside DCC'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：DCC内部角色关节的示例
- en: After you’ve laid out your bones, you then need to plan out the next level by
    constraining systems that will drive the bones’ structure. If you are using a
    control rig on top, these constraints would instead drive the control rig bones.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你布置好骨骼之后，你需要通过规划驱动骨骼结构的约束系统来规划下一级。如果你在顶部使用控制骨架，这些约束将驱动控制骨架的骨骼。
- en: Forward Kinematics/Inverse Kinematics
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向运动学/反向运动学
- en: '**Forward Kinematics** (**FK**) and **Inverse Kinematics** (**IK**) are two
    major forms of animation for arms and legs. FK is a technique where the animator
    will manually rotate every joint individually. If you are animating an arm, you
    would start from the shoulder, then the elbow, then the wrist, etc. It’s called
    “forward” as you are going forward down the Hierarchy for animation. On the contrary,
    IK is where you would animate the hand, and the shoulder and elbow would follow
    from the guidance of a rotate plane. There is a debate on whether to use one or
    the other, however, they are tools. If you work with one and it makes your job
    easier, then use that style. It is very common to see FK/IK switches on character
    rigs as both have their places in certain animation workflows.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向运动学**（**FK**）和**反向运动学**（**IK**）是手臂和腿部动画的两种主要形式。FK是一种技术，其中动画师将手动单独旋转每个关节。如果你在动画化一个手臂，你会从肩膀开始，然后是肘部，然后是手腕，等等。它被称为“前向”，因为你是在沿着动画层次结构向下前进。相反，IK是你将动画化手部，肩膀和肘部会根据旋转平面的引导而跟随。关于使用哪一个存在争议，然而，它们都是工具。如果你使用其中一个并且它使你的工作变得更简单，那么就使用那种风格。在角色骨架上看到FK/IK切换是非常常见的，因为它们在特定的动画工作流程中都有其位置。'
- en: Further, the primary concern about IK is that you can keep the hand in the same
    position or to the space where it was last placed. Imagine standing up and putting
    a hand in the air, then moving your hips up and down while keeping your hand in
    the air in the same place. This would be extremely tedious to animate with an
    FK-only setup as you would have to key the shoulder, elbow, and wrist separately
    to all the hip motions. With IK, you would be able to key the wrist in the spot
    where it would be and then just animate the hips. IK would handle the shoulder
    and elbow for you. However, a walk cycle where gravity is working on the hand
    and it’s mostly just making an arc with the momentum of the movement is better
    suited for FK.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于IK的主要担忧是你可以保持手部在相同的位置或者到它最后放置的空间。想象一下站起来，将一只手举到空中，然后上下移动臀部，同时保持手部在空中相同的位置。如果只使用FK设置，这将是一个非常繁琐的动画过程，因为你必须分别对所有臀部的动作进行关键帧设置。使用IK，你将能够将手腕设置在它应该在的位置，然后只需动画化臀部。IK会为你处理肩膀和肘部。然而，对于重力作用于手部并且主要只是随着运动动量画出一个弧线的情况，FK更适合。
- en: As previously mentioned, these are tools that can potentially produce the same
    result. As you build experience with your tools, it will provide you with insight
    into your animation style.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些是可能产生相同结果的工具。随着你使用工具的经验积累，它将为你提供关于你的动画风格的洞察。
- en: Constraints
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束
- en: Constraining is a simple action. Using visual objects, we want the animators
    to understand the control’s purpose straight away. A concise example would be
    a **NURBS** (**non-uniform rational basis spline**—a point in space that creates
    something visual) curve that will point to each finger in a rigged hand to help
    with making a fist. *Figure 4.8* below shows how we did this with Myvari’s rig.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 限制是一个简单的动作。使用视觉对象，我们希望动画师能够立即理解控制的目的。一个简洁的例子就是一个**NURBS**（**非均匀有理B样条**——空间中的一个点，可以创建视觉元素）曲线，它会指向一个装上骨架的手的每一个手指，以帮助制作拳头。下方的*图4.8*展示了我们如何使用Myvari的骨架来完成这个动作。
- en: '![A picture containing text, indoor  Description automatically generated](img/B17304_04_08.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，室内  自动生成的描述](img/B17304_04_08.png)'
- en: 'Figure 4.8: Myvari’s hand controls'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：Myvari的手部控制
- en: 'These are called controls simply because they allow the animators to control
    certain aspects of the character. Reading this may sound similar to another term
    we introduced in *Chapter 1*, *A Primer to the Third Dimension*: **parenting**.
    It is true that there is a similarity between constraining and parenting, however,
    we are allowed to be specific in what we want to constrain with constraints. In
    Maya, this is separated into translation, rotation, and scale constraining. You
    can also constrain individual components of each of these, such as “rotate *x*”
    only. This allows the rigger to be able to restrict the animator a bit. The above
    example with the head control may only need a rotational constraint. This makes
    it so the translation of the box would not affect the bones. With parenting, you
    wouldn’t be able to separate these. Parents affect all transforms of the child
    object.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为控制，仅仅是因为它们允许动画师控制角色的某些方面。阅读这篇文章可能会让人联想到我们在第一章中介绍过的另一个术语：**父子关系**。确实，约束和父子关系之间存在相似性，然而，我们可以具体指定我们想要用约束来约束的内容。在Maya中，这被分为平移、旋转和缩放约束。你还可以约束每个这些组件的单独部分，例如“仅旋转*x*”。这允许绑定师稍微限制动画师。上面的头部控制示例可能只需要旋转约束。这使得盒子的平移不会影响骨骼。使用父子关系，你无法将这些分开。父对象会影响子对象的全部变换。
- en: Deformers
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变形器
- en: The deforming tools will be unique to each DCC. The primary function of a deformer
    is to control the top-level hierarchy in certain ways. An example of this may
    be a twist deformer, which could allow a nice twist of the controls to make it
    easier for the animator to build a twist animation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 变形工具将因每个DCC而异。变形器的主要功能是以某种方式控制顶级层次结构。一个例子可能是一个扭曲变形器，它可以允许控制有一个很好的扭曲，使动画师更容易构建扭曲动画。
- en: Some advanced animations use the deformers on another mesh that is controlling
    the bones, which is sometimes called a ribbon rig, which is seen below in *Figure
    4.9*. This image shows the ribbon on the left and the deformers that control the
    underlying joints of the necklace. The right side shows what the animator sees
    by hiding the underlying ribbon control.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级动画使用控制骨骼的另一个网格上的变形器，这有时被称为带子绑定，如图4.9所示。这张图片显示了左侧的带子和控制项链下关节的变形器。右侧显示了动画师通过隐藏下方的带子控制所看到的内容。
- en: '![](img/B17304_04_09.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_04_09.png)'
- en: 'Figure 4.9: Examples of a ribbon rig for Myvari’s necklace'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：Myvari项链的带子绑定的示例
- en: Controls
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制
- en: Animators have the unique job in the 3D world of working with representations
    of the items they need to move in real time. Whether this is a box surrounding
    the hand or head, each shape gives the animator control. Each character will have
    controls unique to their needs. Myvari will have standard controls for a biped
    and extra controls for her clothing and trinkets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 动画师在3D世界中有一个独特的工作，那就是实时处理他们需要移动的物品的表示。无论是围绕手或头的盒子，还是每个形状都给动画师提供了控制。每个角色都会有满足其需求的独特控制。Myvari将会有双足的标准控制和额外的控制，用于她的服装和饰品。
- en: Below in *Figure 4.10* is our character’s controls for her whole body.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下图4.10显示了角色的全身控制。
- en: '![](img/B17304_04_10.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_04_10.png)'
- en: 'Figure 4.10: Myvari’s whole-body controls'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：Myvari的全身控制
- en: Physics-based animation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于物理的动画
- en: Some animation can be done through a simulation. There should be a bone attached
    to the mesh, but the DCC will perform physics movements that would be slightly
    constrained. These are very good to work with for chains, necklaces, and basically
    anything springy or dangly. These things are notoriously difficult to animate
    by hand, so it’s best to let the application handle it for you. In some cases,
    the game engine can handle all the physics-based animation and doesn’t need to
    be keyed by the animators. This means that the physics animation would be independent
    of the animation file itself, which would allow for a much smoother blending of
    animations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动画可以通过模拟来完成。应该有一个骨头连接到网格上，但DCC将执行稍微受限的物理运动。这些对于链条、项链以及基本上任何有弹性的或悬垂的东西都非常适合工作。这些事情用手动画是非常困难的，所以最好让应用程序来处理。在某些情况下，游戏引擎可以处理所有的基于物理的动画，不需要动画师进行关键帧设置。这意味着物理动画将独立于动画文件本身，这将允许动画的平滑混合。
- en: Human Inverse Kinematics (HIK) system
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人类逆向运动学（HIK）系统
- en: Autodesk has created a biped rigging system to integrate multiple software easily.
    This is needed primarily for motion capture work where the animations are created
    through separate technologies. Motion capture is done through suits, facial capture
    devices, as well as specialized gloves.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Autodesk创建了一个双足装置系统，以便轻松集成多个软件。这主要用于动作捕捉工作，其中动画是通过不同的技术创建的。动作捕捉是通过服装、面部捕捉设备以及专业手套完成的。
- en: The primary purpose of a **Human Inverse Kinematics** (**HIK**) rig is to gather
    animation data for the biped’s head, spine, arms, and legs. There is an advanced
    version that allows for fingers as well as more features on the arms and legs,
    such as twists. To gather more information about HIK skeletons, Autodesk has published
    documentation about how best to use it. For our demonstrations, we will not be
    using the HIK system. With Myvari, we will be doing all hand-keyed animations
    and no mocap work. In knowing this, we decided to stick to just keeping a custom
    rig and control system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**人逆运动学**（**HIK**）装置的主要目的是收集双足角色的头部、脊柱、手臂和腿部的动画数据。有一个高级版本允许手指以及手臂和腿部的更多功能，例如扭曲。为了收集更多关于HIK骨骼的信息，Autodesk已经发布了关于如何最佳使用它的文档。在我们的演示中，我们不会使用HIK系统。使用Myvari，我们将进行所有手动画制作，而不进行动作捕捉工作。了解这一点后，我们决定只保留自定义装置和控制系统。'
- en: Animation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: We have now designed, modeled, and rigged a character with controls. Now we
    can use our animation skills in our DCC to give some life to the character. When
    you are deciding what animations to make, be sure to give good thought to what
    personality the character has. Since we spent a good amount of time asking all
    the hard questions about our character’s motivations and desires, we should honor
    that with the correct movements expected of someone with that personality.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设计、建模并装备了一个带有控制器的角色。现在我们可以使用我们的动画技能在我们的DCC中给角色赋予生命。当你决定制作哪些动画时，一定要仔细考虑角色的性格。由于我们花了很多时间询问关于角色动机和欲望的难题，我们应该用符合这种性格的正确动作来尊重这一点。
- en: A strong way to work through animations is the same way that you would work
    through any art form. First, we will work with a blocking phase to get the timing
    right by working with just key poses. While you are doing this, get the key posing
    as strong as possible. Every keyframe should have a personality in it. If you
    look at the keyframe and cannot get a sense of the character, then it would not
    be considered “key” to the character. After you have blocked in some keyframes
    and moved them to get a sense of timing, this is when you would then add in-betweens.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 处理动画的一种强有力的方式与处理任何艺术形式的方式相同。首先，我们将通过仅使用关键姿势来获得正确的时机，进入一个阻塞性阶段。当你这样做的时候，尽量使关键姿势尽可能强。每个关键帧都应该有个性。如果你看关键帧，无法感受到角色的感觉，那么它就不会被认为是角色的“关键”。在你放置了一些关键帧并将它们移动以获得时机感之后，这就是你添加中间帧的时候了。
- en: These are keyframes in between the key poses in timing. These keys will help
    sell the movement within each key pose.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在关键姿势之间的关键帧，这些关键帧将有助于展现每个关键姿势内的动作。
- en: Once you get to this point, it can be a good idea to add it into the game engine
    to get a sense of actual movement with the character controller to see if what
    you see in the DCC translates into the game’s movement. Doing this at this stage
    is smart as you will have a good amount of time near the end of the project to
    polish all your animations after you learn how to move your character.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到这个阶段，将动画添加到游戏引擎中可能是个好主意，以获得与角色控制器实际动作的感觉，看看你在DCC中看到的是否能转化为游戏中的动作。在这个阶段做这个是明智的，因为你在项目接近尾声时将有大量时间学习如何移动角色后，对所有的动画进行润色。
- en: Character controllers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色控制器
- en: 'Now that we have put together a character design, model, and rig, we need to
    set up a **controller** to have them react to inputs. There are two general methods
    for character controllers. The built-in character controller that Unity provides
    will allow you to have a character walk around, up stairs, and easily build in
    further functions of interaction, but it has its limits. The largest limitation
    is that it is not used as a physics object. If you need your character to get
    pushed around by physics, there is a second option available. The second option
    is using a Rigidbody and collision capsule with a character script using these
    as restrictions to the physics engine. Just as you may have come to expect by
    now, to choose the correct option here we need to ask questions! The following
    are some examples:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了角色设计、模型和绑定设置，我们需要设置一个**控制器**来使它们对输入做出反应。角色控制器有两种一般方法。Unity提供的内置角色控制器将允许您让角色四处走动、上楼梯，并轻松地构建进一步的交互功能，但它有其局限性。最大的局限性是它不作为物理对象使用。如果你需要你的角色被物理力推动，还有一个第二个选项可用。第二个选项是使用刚体和碰撞胶囊，以及使用这些作为对物理引擎限制的角色脚本。正如你现在可能已经预料到的，为了选择正确的选项，我们需要提出问题！以下是一些例子：
- en: What are the primary mechanics?
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要机制是什么？
- en: Do I need physics for movements?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要物理运算来移动吗？
- en: How many other limitations will there be for my character?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的角色将有多少其他限制？
- en: 'After some time, you may learn to ask these questions very early when you start
    seeing what architecture may be needed to pull off the gameplay you want within
    Unity. This will only happen after leaving these questions unanswered and missing
    the mark slightly. Do not get discouraged by this. This is the best way of learning:
    failing fast and failing often. The options available to you are not always obvious.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，当你开始看到在Unity中实现你想要的玩法可能需要什么架构时，你可能学会在早期就提出这些问题。这只有在这些问题没有得到回答，并且稍微偏离目标之后才会发生。不要因此气馁。这是最好的学习方法：快速失败和经常失败。可用的选项并不总是显而易见的。
- en: An example of this is asking yourself what the primary mechanics are. Looking
    at your game, you may try to push crafting weapons in the game, but the combat
    mechanics are more fun during production. After finding this out, you may cut
    most of the crafting and put more effort into polishing the combat mechanics.
    What this does is place more emphasis on the character controller over UI or interactive
    crafting work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是问自己主要机制是什么。看看你的游戏，你可能试图推动游戏中的武器制作，但在制作过程中战斗机制更有趣。在弄清楚这一点后，你可能削减大部分制作工作，并更多地投入到打磨战斗机制中。这样做实际上是在角色控制器上比UI或交互式制作工作更强调。
- en: In our game, we decided to take a simple approach to the character movement.
    We only need movement, and all other interactions will mostly be through mouse
    position and camera work. With that in mind, we will investigate the character
    controller foundation to build upon.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们决定对角色移动采取简单的方法。我们只需要移动，所有其他交互将通过鼠标位置和相机操作来完成。考虑到这一点，我们将研究角色控制器的基础，以便在此基础上构建。
- en: Built-in character controller
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置角色控制器
- en: 'Unity has a built-in character controller component that can be added to your
    character. This will give you solid foundations to work with. It is simply a capsule
    collider that allows simple movement for a first-person or third-person game.
    The interesting portion of this is that it does not use physics or Rigidbodies
    for physics. Unity documentation explains this the best as a “Doom-style” controller:
    moving very fast and when you let go of the thumbstick, it stops immediately.
    This is sometimes desirable, but not often. An example of when this could be desirable
    is when you’re making a game where extremely tight controls are needed. Metroid
    uses this to flip the character left and right immediately. If you had to slow
    to a stop before turning, the game wouldn’t feel as good as it does.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unity内置了一个可以添加到您角色上的角色控制器组件。这将为您的工作提供坚实的基础。它只是一个胶囊碰撞体，允许第一人称或第三人称游戏进行简单的移动。有趣的是，它不使用物理或刚体进行物理运算。Unity文档将其最佳解释为“Doom风格”控制器：移动非常快，当你松开摇杆时，它立即停止。这有时是可取的，但并不常见。一个可能需要这种功能的例子是当你制作一个需要极其精确控制的游戏时。Metroid使用这个功能立即左右翻转角色。如果你在转向前必须减速到停止，游戏的感觉就不会像现在这样好。
- en: The best part of this is that it is fast and easy to throw it on your character
    to get moving if you want to just test something simple. If you want to add jumping,
    floating, swimming, flying, or anything dealing with physics, this application
    will not work without a good amount of work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，如果你只是想测试一些简单的东西，将它应用到角色上以使其移动既快又简单。如果你想添加跳跃、漂浮、游泳、飞行或任何与物理相关的动作，没有大量的工作，这个应用程序将无法工作。
- en: We will be using the built-in character controller for this tutorial, as Myvari
    only needs to explore on the ground without jumping or sliding and none of her
    interactions use any focused physics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个教程中使用内置的角色控制器，因为 Myvari 只需要在地面上探索，不需要跳跃或滑动，而且她所有的交互都不需要任何特定的物理效果。
- en: Rigidbody character controller
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rigidbody 角色控制器
- en: This option for a component starts with coding in mind but offers a large amount
    of flexibility that the built-in character controller can’t provide for many purposes.
    The initial reasoning for using a Rigidbody is if you are looking to have different
    physics materials in your game. If your game is planning on utilizing physics
    in multiple ways, then it would be better to plan on working with the Rigidbody
    and collision components as your choice for physics on your character controller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的选项从编码的角度出发，但提供了内置角色控制器在很多情况下无法提供的灵活性。使用 Rigidbody 的初始理由是如果你想在游戏中使用不同的物理材料。如果你的游戏计划以多种方式利用物理，那么计划与
    Rigidbody 和碰撞组件一起工作作为你在角色控制器上的物理选择会更好。
- en: Scripting your character’s movement
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写角色的动作脚本
- en: 'When you’re scripting your character, it’s a good idea to have as many movement-related
    design conversations as you can to know what to architect out. For Myvari, we
    wanted to have a few movement-related specifics in the environment because this
    game is an environmental puzzle game. We should have the environment interact
    with her as she traverses it. Here is a list of what we went over:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写角色脚本时，进行尽可能多的与动作相关的设计讨论是个好主意，以便知道要构建什么。对于 Myvari，我们希望在环境中有一些与动作相关的具体设置，因为这款游戏是一个环境解谜游戏。我们应该让环境在她穿越时与她互动。以下是我们讨论过的列表：
- en: Idling
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲
- en: 'Walking:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走路：
- en: On the ground
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地面上
- en: In water
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在水中
- en: On ledges
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在边缘上
- en: Rotation
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转
- en: There are two movement-related scripts that we, at this time, haven’t fully
    decided on implementing. These are running and jumping. The reason we aren’t going
    to implement these currently is that we do not know for certain that we need them.
    As we move through the level currently, it feels good walking through it, and
    we want the player to pay attention to the environment as well. We will set up
    the character controller to accept a running movement if we think it’s needed
    later. Jumping is similar, but we have no mechanics that require jumping up or
    over. You would only implement this to satisfy the need for jumping around in
    an environment. We may find that this is needed after some QA passes are done
    and player feedback states that they need to jump around. If this is a strong
    enough case, we can add it in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有完全决定实施两个与动作相关的脚本。这些是跑步和跳跃。我们目前不打算实施这些动作的原因是我们不能确定我们是否真的需要它们。在我们目前通过关卡的过程中，走路的感觉很好，我们希望玩家也能关注环境。如果我们认为以后需要的话，我们会设置角色控制器以接受跑步动作。跳跃类似，但我们没有需要跳跃上升或跨越的机制。你只会实施这个来满足在环境中跳跃的需求。我们可能会在经过一些质量保证测试和玩家反馈后，发现这确实是必要的。如果这是一个强有力的案例，我们可以添加它。
- en: Initial setup in Unity
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 中的初始设置
- en: To begin with, to get Myvari set up to even accept scripts for movement, we
    should set it up in Unity. We should already have Myvari imported into the Unity
    project. Just so you are aware, the way to go about this is just a simple drag
    and drop onto the project’s folder you want her to be in. If you select `SM_Myvari`
    in the `Character` folder, the Inspector will show the imported settings on the
    model, as shown in *Figure 4.11*. The default settings that are in use here are
    good for our needs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使 Myvari 能够接受动作脚本，我们应该在 Unity 中设置它。我们应已将 Myvari 导入到 Unity 项目中。只是让你知道，进行操作的方式只是简单地将它拖放到你希望她所在的项目的文件夹中。如果你在“角色”文件夹中选择
    `SM_Myvari`，检查器将显示模型上的导入设置，如图 *图 4.11* 所示。这里使用的默认设置对我们来说已经足够好了。
- en: '![](img/B17304_04_11.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_04_11.png)'
- en: 'Figure 4.11: Import settings Model tab'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：导入设置 模型选项卡
- en: We need to move over to the **Rig** tab and set up our rig. In *Figure 4.12*,
    we have a couple of options to go over. We want to make sure that **Animation
    Type** is set to **Humanoid**. We also want to create an avatar from this model
    and then configure it. This will open another window to set up the bones in the
    humanoid structure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要切换到 **Rig** 选项卡并设置我们的装置。如图 *图 4.12* 所示，我们有几个选项要讨论。我们想确保 **动画类型** 设置为 **人类**。我们还想从这个模型创建一个头像并对其进行配置。这将打开另一个窗口来设置人类结构中的骨骼。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_04_12.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图描述自动生成，中等置信度](img/B17304_04_12.png)'
- en: 'Figure 4.12: Import settings Rig tab'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：导入设置 Rig 选项卡
- en: This window will default to the body portion, though we’re showing the head
    section in *Figure 4.13*. It’s best to go through every portion of the body as
    the avatar system will do its best to align the joints to the right location,
    but sometimes it doesn’t work out. If it isn’t set up properly, just select the
    correct joint to fill the slot properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口将默认显示身体部分，尽管我们在 *图 4.13* 中展示了头部部分。最好检查身体的每一部分，因为头像系统会尽力将关节对齐到正确的位置，但有时可能不起作用。如果没有正确设置，只需选择正确的关节以正确填充插槽即可。
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B17304_04_13.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成，中等置信度](img/B17304_04_13.png)'
- en: 'Figure 4.13: Import settings Rig, configure head portion'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：导入设置 Rig，配置头部部分
- en: Before we set up the controller, we should have a chat about our decisions on
    how the game will be played. We have a third-person, over-the-shoulder play style.
    This means we must add a camera to the character. As such, we should make a **Prefab**
    with our character and our camera. To set this up, we make a Hierarchy that will
    allow for independent camera movement but keep the camera and character together.
    In *Figure 4.14* you can see the way we set up the Prefab.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置控制器之前，我们应该讨论一下关于游戏如何玩的决定。我们有一个第三人称、肩上视角的玩法。这意味着我们必须给角色添加一个摄像头。因此，我们应该制作一个包含我们的角色和摄像头的
    **Prefab**。为了设置这个，我们创建一个层次结构，它允许独立地移动摄像头，但保持摄像头和角色在一起。如图 *图 4.14* 所示，你可以看到我们如何设置
    Prefab。
- en: '![Text  Description automatically generated](img/B17304_04_14.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B17304_04_14.png)'
- en: 'Figure 4.14: Character prefab hierarchy'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：角色 prefab 层次结构
- en: The reason we set it up this way was that we wanted a container to hold both
    the camera and the character. The character GameObject holds all the scripts needed
    for the character. The mesh will hold the animator and avatar. The camera rig
    will house the camera as well as the scripts needed to maintain the camera in
    the position we want. Later in the book, when we get into the mechanics in *Chapter
    6*, *Interactions and Mechanics*, we will be going over **Cinemachine** quite
    heavily as there are parts of the game where we will need to put the camera in
    a location for a cinematic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样设置的原因是我们想要一个容器来同时容纳摄像头和角色。角色 GameObject 包含所有用于角色的脚本。网格将包含动画器和头像。摄像头装置将容纳摄像头以及保持摄像头在我们想要的位置所需的脚本。在本书后面的
    *第 6 章* 中，当我们进入机制时，*交互和机制*，我们将详细讨论 **Cinemachine**，因为在游戏中的一些部分我们需要将摄像头放置在电影拍摄的位置。
- en: For the rest of this chapter, we will go over just the basics of setting the
    character up for movement. On the character GameObject, let’s set up the components
    to get her moving around. As shown in *Figure 4.15*, we will add four more components.
    These are the character controller, our movement script, a Rigidbody component,
    and a player input system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将简要介绍如何设置角色移动的基本设置。在角色 GameObject 上，让我们设置组件以使她能够移动。如图 *图 4.15* 所示，我们将添加四个更多组件。这些是角色控制器、我们的移动脚本、一个
    Rigidbody 组件和一个玩家输入系统。
- en: '![](img/B17304_04_15.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_04_15.png)'
- en: 'Figure 4.15: Character GameObject components'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：角色 GameObject 组件
- en: As stated previously, we will be using the base character controller. These
    settings are subjective, and we haven’t finalized them, but this is what we have
    so far. One note we should add here regards the **center attribute**. This is
    where the character controller thinks the center of the character is. It defaults
    to being on the ground, but you need to move it up so the capsule is closer to
    the center and slightly off the ground. We try to put it near the pelvis and then
    use the radius and height to encompass the general body of the character. We do
    this because the pelvis controls the overall height as the human structure has
    its center of mass in the belly button.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用基础角色控制器。这些设置是主观的，我们还没有最终确定，但这是我们目前所拥有的。在此我们应该添加的一个注意事项是关于 **中心属性**。这是角色控制器认为角色中心的位置。它默认在地面，但您需要将其向上移动，使胶囊体更靠近中心并稍微离开地面。我们尝试将其放在骨盆附近，然后使用半径和高度来包围角色的整体身体。我们这样做是因为骨盆控制整体高度，因为人体结构的质量中心在肚脐处。
- en: We’re going to skip over the movement script for now. The Rigidbody here is
    to help with future mechanics needs and physics-based work. We will cover this
    in *Chapter 5*, *Environment*, and *Chapter 6*, *Interactions and Mechanics*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将跳过移动脚本。这里的 Rigidbody 是为了帮助未来的机械需求以及基于物理的工作。我们将在 *第五章*，*环境* 和 *第六章*，*交互和机械*
    中介绍这一点。
- en: '**PlayerInput** is a Unity system that sets up modular inputs to easily add
    different input systems without needing to change the code. Firstly, open your
    **Package Manager** and see if the **Input System** is installed. It would be
    part of the **Unity Registry**. If it’s not installed, install it! If it is, then
    we need to make an input system for us to work with.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**PlayerInput** 是一个 Unity 系统，它设置模块化输入，以便轻松添加不同的输入系统，而无需更改代码。首先，打开您的 **包管理器**，查看是否已安装
    **输入系统**。它将是 **Unity 注册表** 的一部分。如果没有安装，请安装它！如果已安装，那么我们需要为我们自己创建一个输入系统。'
- en: This can be done by adding a new asset called **Input Actions**, as shown in
    *Figure 4.16*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过添加一个名为 **输入动作** 的新资产来实现，如 *图 4.16* 所示。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_04_16.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_04_16.png)'
- en: 'Figure 4.16: Adding an Input Actions asset'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：添加输入动作资产
- en: After you create the input action, name it according to your needs. We are naming
    ours `Player Actions`. We are going to use this grouping of input actions specifically
    for any player actions needed. You may need other actions besides characters in
    your future projects. At this point, you will need to double-click the asset to
    open the **Input Actions** window. Here, we will design the input options for
    use as currently needed for Myvari.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建输入动作后，根据您的需求为其命名。我们将其命名为 `Player Actions`。我们将专门使用这个输入动作分组来处理任何所需的玩家动作。在未来的项目中，您可能需要除了角色之外的其他动作。在此阶段，您需要双击资产以打开
    **输入动作** 窗口。在这里，我们将设计用于当前所需的 Myvari 的输入选项。
- en: '*Figure 4.17* shows a completed input system as we need it currently. We may
    add more inputs as the vertical slice continues to develop.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.17* 展示了我们目前所需的完整输入系统。随着垂直切片的持续开发，我们可能会添加更多输入。'
- en: '![Graphical user interface  Description automatically generated](img/B17304_04_17.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_04_17.png)'
- en: 'Figure 4.17: Input Actions'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：输入动作
- en: '**Action Maps** are groupings that have their own set of actions that can be
    called upon. Properties are details and options for the selected action. For this
    case, we only need inputs for Myvari, so we created a Myvari Action Mapping. Notice
    the capitalization of the **Action Mapping** name, as it will be used in scripting
    once we get into the movement script.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作映射** 是一组具有自己可以调用的动作的分组。属性是所选动作的细节和选项。对于这个案例，我们只需要 Myvari 的输入，因此我们创建了一个
    Myvari 动作映射。请注意 **动作映射** 名称的大写，因为它一旦进入移动脚本编写阶段将被使用。'
- en: In **Actions**, the green sections are the actions themselves, the blue are
    the bindings, and the light red are the binding parts. For **Locomotion** we only
    need to worry about a composite of vectors. When adding a new binding, if you
    press the plus (**+**) symbol on the right of the action, you have two options.
    These are **Binding** or **2D Vector Composite**. When you click **2D Vector Composite**,
    it automatically adds the **Up**, **Down**, **Left**, and **Right** composite
    parts. We are defining them as keyboard inputs currently to stick with a certain
    input system. There is a very interesting and useful tool when setting an action,
    called the **Listen** button. Looking at *Figure 4.18*, you can see that it’s
    pressed and is listening for input. For us, being able to press the assumed button
    that may be pressed gives us a sense of immediate player feedback. If it feels
    odd at this point to assign a keystroke to an action, then it won’t feel much
    better during gameplay.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在**动作**中，绿色部分是动作本身，蓝色是绑定，浅红色是绑定部分。对于**移动**，我们只需要关注向量的组合。当你添加一个新的绑定时，如果你在动作的右侧按下加号（**+**）符号，你有两个选项。这些是**绑定**或**2D
    向量组合**。当你点击**2D 向量组合**时，它会自动添加**上**、**下**、**左**和**右**的组合部分。我们目前将它们定义为键盘输入，以保持一定的输入系统。在设置动作时，有一个非常有趣且有用的工具，称为**监听**按钮。查看*图4.18*，你可以看到它被按下并且正在监听输入。对我们来说，能够按下可能被按下的假设按钮，给我们一种即时的玩家反馈感。如果在这个时候将按键分配给动作感觉奇怪，那么在游戏过程中也不会感觉好多少。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_04_18.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，描述由中等置信度自动生成](img/B17304_04_18.png)'
- en: 'Figure 4.18: Listening for input'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：监听输入
- en: The **Look** input is for camera movement, and we are using **Delta** for mouse
    movement. Our **Aim** action is meant for when you’re holding down the right mouse
    button for precision. This is choosing the **Action Type** as a **button** and
    expecting a right mouse button input. Finally, we have an **Interact** button.
    This is the same as **Aim** but designed for the *E* key to be hit at certain
    times. Those times will be defined in*, Environment,* and *, Interactions and
    Mechanics*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**查看**输入用于相机移动，我们使用**Delta**进行鼠标移动。我们的**瞄准**动作是为了当你按下右鼠标按钮进行精确操作时。这是选择**动作类型**为**按钮**并期望右鼠标按钮输入。最后，我们有一个**交互**按钮。这与**瞄准**相同，但设计为在特定时间按下*E*键。这些时间将在*环境*和*交互和机制*中定义。'
- en: We now have a setup for the inputs we as players put into the game. Even if
    we wrote scripts to work with this input system, it wouldn’t affect anything.
    So, before we start scripting, we need to put together the basics of the animation
    setup for Myvari. Let’s look at the animations we will need. For now, we only
    need **Idle** and **Walk** for animation transitioning. We do not need to set
    up **Interact** just yet here as we do not currently have a use for it. In *Chapter
    5*, *Environment*, we will be looking at the use of **Interact**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为玩家输入的游戏设置了基础框架。即使我们编写了与这个输入系统协同工作的脚本，它也不会影响任何事情。因此，在我们开始编写脚本之前，我们需要为 Myvari
    准备动画设置的基础。让我们看看我们需要哪些动画。目前，我们只需要**空闲**和**行走**动画进行过渡。在这里我们暂时不需要设置**交互**，因为我们目前还没有用到它。在**第5章**，**环境**中，我们将探讨**交互**的使用。
- en: Idling
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲
- en: Myvari may have to stand still for a time as the player looks around. Most of
    the time, there is no scripting involved when idling as this should be the standard
    state in your animation controller. When you bring the character into your Scene,
    you will need to add an **Animator** component. See *Figure 4.19* for a correct
    configuration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家四处张望时，Myvari 可能需要暂时保持静止。大多数时候，空闲时不需要编写脚本，因为这应该是你的动画控制器中的标准状态。当你将角色添加到场景中时，你需要添加一个**动画控制器**组件。参见*图4.19*以获取正确的配置。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_04_19.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述由中等置信度自动生成](img/B17304_04_19.png)'
- en: 'Figure 4.19: Animator component'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：动画控制器组件
- en: '**Controller** and **Avatar** will be empty. We need to create the controller
    by creating a new asset and going to **Create** > **Animator Controller**. The
    controller is an interface between the code and visuals to move the skeletal mesh
    we want to animate.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**和**角色**将是空的。我们需要通过创建一个新的资产并转到**创建**>**动画控制器**来创建控制器。控制器是代码和视觉效果之间的接口，用于移动我们想要动画化的骨骼网格。'
- en: With **Idle**, we will make a default state and name it `Idle`. You can see
    this in *Figure 4.20*. In the **Characters** > **Animations** folder within the
    project, there are animations we’ve set up with Myvari. Select the **Idle** state
    and drag the idle animation from that folder onto the **Motion** parameter in
    the inspector, as shown in *Figure 4.21* below.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**Idle**，我们将创建一个默认状态并命名为`Idle`。您可以在*图4.20*中看到这一点。在项目中的**Characters** > **Animations**文件夹内，有我们使用Myvari设置的动画。选择**Idle**状态，将此文件夹中的空闲动画拖放到检查器中的**Motion**参数上，如图*图4.21*所示。
- en: '![Diagram  Description automatically generated](img/B17304_04_20.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17304_04_20.png)'
- en: 'Figure 4.20: Controller state machine'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：控制器状态机
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_04_21.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，中等置信度自动生成](img/B17304_04_21.png)'
- en: 'Figure 4.21: Idle animation state inspector'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：空闲动画状态检查器
- en: When you have the idle animation in place, when you press **Play**, the character
    will enter idle mode and loop that animation forever!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当您放置好空闲动画时，当您按下**播放**，角色将进入空闲模式并无限循环该动画！
- en: We also want to have a walk animation though. To add this, in an empty space,
    right-click and choose **Create State** and then choose **Empty**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望有一个行走动画。为此，在空白区域右键单击，选择**创建状态**，然后选择**空状态**。
- en: Name it `Walk`. Select it and add the walking animation. After that, right-click
    on **Idle** and choose **Make Transition**, then left-click on the **Walk** state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将其命名为`Walk`。选择它并添加行走动画。之后，在**Idle**上右键单击并选择**创建转换**，然后左键单击**Walk**状态。
- en: This will make a transition from **Idle** to **Walk**. Do the same thing from
    the **Walk** state back to **Idle**. This allows us to set up parameters to transition
    to and from **Idle** and **Walk**. We will now add a parameter of `isWalking`
    to the controller, as seen in *Figure 4.22*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使状态从**空闲**转换为**行走**。从**行走**状态返回**空闲**状态时，请执行相同操作。这允许我们设置从**空闲**和**行走**状态转换的参数。现在，我们将在控制器中添加一个名为`isWalking`的参数，如图*图4.22*所示。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_04_22.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_04_22.png)'
- en: Figure 4.22 Controller parameters
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 控制器参数
- en: The **Parameters** section is found on the upper left of the controller. We
    want to make a bool and name it `isWalking`. We will be using this parameter in
    the transition points. If you select the transition from the **Idle** to **Walk**
    states, you will see the transition from one animation to the other in the inspector.
    At the bottom of the inspector are conditions. Let’s add a condition and set it
    to **isWalking is True**. The animation state of **Idle** will change to **Walk**
    when `isWalking` is `true`. You can then do the opposite to revert to **Idle**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**部分位于控制器的右上角。我们想要创建一个布尔值并命名为`isWalking`。我们将在转换点使用此参数。如果您选择从**Idle**到**Walk**状态的转换，您将在检查器中看到从一种动画到另一种动画的转换。检查器的底部是条件。让我们添加一个条件并将其设置为**isWalking
    is True**。当`isWalking`为`true`时，**Idle**的动画状态将转换为**Walk**。然后您可以执行相反操作以返回**Idle**。'
- en: We now have inputs and animations in place with a transition ready to listen
    to the character logic. We now need to get in there and get the movement script
    working. Let’s dive into the code!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已设置好输入和动画，并准备好转换以监听角色逻辑。现在我们需要进入那里并使移动脚本生效。让我们深入代码！
- en: Code entry point
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码入口点
- en: We wanted to add a small section here explaining how we will go over the code.
    In *Chapter 3*, *Programming*, we went step by step through every line to go over
    the basics of code. What we plan on doing here is having the script in its entirety
    available to you, with full comments so you can read it if you’re more comfortable
    with code. In the rest of this chapter, we will be going over small parts we haven’t
    been over previously and explaining them as tools. We encourage you to build your
    own scripts and work with the tools we go over to build your own character movement
    scripts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加一小节，解释我们将如何介绍代码。在*第3章，编程*中，我们逐行介绍了代码的基础知识。我们计划在这里提供完整的脚本，并附上完整的注释，以便您在更熟悉代码的情况下阅读。在本章的其余部分，我们将介绍之前未介绍的部分，并作为工具进行解释。我们鼓励您构建自己的脚本，并使用我们介绍的工具构建自己的角色移动脚本。
- en: We are going to be working through the `MyvariThirdPersonMovement.cs` file.
    We have some simple work here as well as a complicated function. While we are
    going through this, know that it is OK not to fully grasp everything that is discussed.
    By noticing the hard parts and working through them, you are solidifying that
    knowledge and understanding how to work as a developer in Unity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理`MyvariThirdPersonMovement.cs`文件。这里有一些简单的工作，以及一个复杂的功能。当我们处理这些时，要知道不完全理解所讨论的内容是正常的。通过注意到难点并解决它们，你正在巩固这些知识，并了解如何在Unity中作为开发者工作。
- en: RequireComponent
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RequireComponent
- en: When you see a `RequireComponent` above the class definition, this is saying
    that the GameObject that this script is attached to is required to have something.
    In our case, we want `MyvariThirdPersonMovement.cs` on the character, and we need
    to ensure it has a character controller. Something that is very helpful is that
    if Unity sees that the GameObject you attach this to doesn’t have the required
    component, it will just attach it to the GameObject for you! Isn’t that nice?
    We think so.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类定义上方看到`RequireComponent`时，这意味着这个脚本附加到的GameObject需要有一些东西。在我们的情况下，我们希望在角色上`MyvariThirdPersonMovement.cs`，并需要确保它有一个角色控制器。非常有帮助的是，如果Unity看到你附加的GameObject没有所需的组件，它将直接为你将其附加到GameObject上！这不是很好吗？我们认为是的。
- en: '[PRE0]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Update code
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新代码
- en: We’re going to go through this part in a bit of detail as each line goes in-depth
    about the previous information and it’s difficult to explain a single line at
    the end without showing the context. For the first part, we want to ensure that
    if the character is grounded and their velocity isn’t above *0*, it is set to
    *0*. Sometimes GameObjects will move in small increments in the *y* direction.
    This isn’t a common occurrence, however sometimes in 3D applications, rotations
    and movement causing rounding to happen for values and velocity can increment
    when it shouldn’t. This can be prevented by using these few lines of code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细地处理这一部分，因为每一行都深入探讨了之前的信息，而且如果不展示上下文，很难解释单行。对于第一部分，我们想要确保如果角色是地面上的，并且他们的速度不是高于*0*，则将其设置为*0*。有时GameObject会在*y*方向上以小的增量移动。这并不常见，然而有时在3D应用程序中，旋转和移动会导致值和速度的舍入，这可能导致不应该增加的增量。可以通过使用这些几行代码来防止这种情况。
- en: '[PRE1]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the next section we are breaking down the code we’ve written to ensure a
    thorough explanation leading up to the character movement script assignment in
    the Editor.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分解我们编写的代码，以确保在编辑器中角色移动脚本分配之前的彻底解释。
- en: If you recall at the start of the *Scripting your character movement* section
    of this chapter, walking through water was one of the movements we wanted to have
    set up. We need to check if the character is in water to know how to set up that
    logic. We will be using a method from the **Physics** library called **Raycast**,
    which takes arguments, as seen in the helper tooltip in *Figure 4.23* below.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回想起本章“脚本化角色移动”部分的开始，穿过水面是我们想要设置的一种移动方式之一。我们需要检查角色是否在水中，以便知道如何设置该逻辑。我们将使用来自**物理**库的**Raycast**方法，该方法需要参数，如以下*图4.23*中的辅助提示所示。
- en: '![Graphical user interface, text  Description automatically generated](img/B17304_04_23.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B17304_04_23.png)'
- en: 'Figure 4.23: Physics.Raycast arguments'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：Physics.Raycast参数
- en: 'When a Raycast is used, its arguments are as follows: **origin**, **direction**,
    **hitInfo**, **maxDistance**, and **layerMask**:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Raycast时，其参数如下：**origin**、**direction**、**hitInfo**、**maxDistance**和**layerMask**：
- en: We define **origin** as this GameObject’s position plus one unit in the up direction
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将**原点**定义为这个GameObject的位置加上向上方向的一个单位
- en: '**direction** is the down direction'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**是向下方向'
- en: '**hitInfo** is being saved as a `RayCastHit` named `hit`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hitInfo**被保存为名为`hit`的`RayCastHit`'
- en: '**maxDistance** is set to 2 units'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxDistance**设置为2个单位'
- en: '**layerMask** is set to `waterLayer`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**layerMask**设置为`waterLayer`'
- en: To test this, make a cube and select **Water** for its layer value in the inspector.
    We will call for this `waterLayer` check during the `controller.Move` portion
    at the bottom.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，创建一个立方体，并在检查器中选择**Water**作为其层值。我们将在底部的`controller.Move`部分调用这个`waterLayer`检查。
- en: '[PRE2]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This next part is where the **Input System** is reading the value of the locomotion
    we put together. The **movement** variable is a `Vector2,` or *x* and *y* only.
    So, we will need to manipulate this to make sure it makes sense for a 3D movement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分是**输入系统**正在读取我们组合的移动值。**movement**变量是一个`Vector2`，只有`x`和`y`。所以，我们需要操纵这个变量，以确保它对3D移动有意义。
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We make a `Vector3` and place the *x* and *y* from the read value while keeping
    the *y* of the `Vector3` as *0*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Vector3`，并将读取值中的`x`和`y`放置进去，同时保持`Vector3`的`y`值为`0`。
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now need to think about the character and camera coordination. We have a
    `move` variable that has the `movement` we need to move toward, but the camera
    may be looking in another direction other than straight forward relative to your
    character. So, let’s take that into account before moving.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要考虑角色和摄像机的协调。我们有一个`move`变量，它包含我们需要移动到的`movement`，但摄像机可能相对于你的角色朝向另一个方向，而不是直向前方。所以，在移动之前，让我们考虑这一点。
- en: '[PRE5]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then we again just zero out that *y* value. If we were to implement jumping
    sometime later, we would need to change this from *0* to different values depending
    on the jump.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次将那个`y`值置零。如果我们稍后要实现跳跃，我们需要将这个值从`0`改为不同的值，这取决于跳跃的高度。
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we go. Now it’s time to move the character. We’ve thought about all the
    possible problems we could have with the camera, character, and type of terrain.
    The standard Unity character controller has a method named **Move**. This method
    takes a single argument, a `Vector3`. This tells the character which way to go.
    We need to take advantage of a few things. How fast are they moving? Are they
    in water? Something new we are using here is something called a **ternary**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是我们移动角色的时候了。我们已经考虑了与摄像机、角色和地形类型可能出现的所有可能问题。标准的Unity角色控制器有一个名为**Move**的方法。这个方法接受一个单一参数，一个`Vector3`。这告诉角色朝哪个方向移动。我们需要利用一些东西。他们移动得多快？他们在水中吗？我们在这里使用的新东西叫做**三元运算符**。
- en: 'Let’s give a slight explanation before we get into the next line of code. This
    is the ternary function. What is being said here is this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一行代码之前，让我们先稍微解释一下。这是一个三元函数。这里所说的内容是：
- en: '[PRE7]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is handy! We can slow the character down by a tunable value easily and
    if we aren’t in water, she moves at the regular rate we have already designed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这很方便！我们可以通过可调值轻松地减慢角色的速度，如果我们不在水中，她将以我们已设计的常规速度移动。
- en: '[PRE8]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have gravity defined at the top of this class, and we set the velocity to
    that gravity value multiplied by the change in time to account for framerate.
    This will not be accounted for unless Myvari is not grounded due to the `if` statement
    on top of the update function, which sets the `velocity.y` to *0* if it’s less
    than *0* and `isGrounded`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类的顶部定义了重力，并将速度设置为重力值乘以时间变化，以考虑帧率。除非Myvari由于更新函数顶部的`if`语句而没有接地，否则这不会计算。该语句将`velocity.y`设置为`0`，如果它小于`0`并且`isGrounded`。
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we are calling two methods to handle rotation and animation states.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用两个方法来处理旋转和动画状态。
- en: '[PRE10]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Methods
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: In an effort to keep the update loop as clean as possible, we refactored out
    handling the rotation and animation from the `Update` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能保持更新循环的简洁性，我们将处理旋转和动画从`Update`函数中重构出来。
- en: Refactoring is the process of restructuring existing code to make it more readable.
    It’s running in the update, but it’s only called one line per method. The initial
    method we’d like to go over is the `HandleAnimation` method. This takes a `Vector2`
    as an input, which is the direct input to the `Vector2` reading from the input
    system. We are only worried about the single animation parameter `isWalking`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是重新组织现有代码以使其更易于阅读的过程。它在更新时运行，但每个方法只调用一行。我们最初想讨论的方法是`HandleAnimation`方法。这个方法接受一个`Vector2`作为输入，这是从输入系统读取的`Vector2`的直接输入。我们只关心单个动画参数`isWalking`。
- en: We first get the value of the bool at its current state and store it in a local
    variable. Then we check if either of the vectors in the input movement is nonzero
    as well as if `isWalking` is currently `false`. If so, we set the animator bool
    to `true`. Otherwise, we set it to `false`. When this bool changes, it will update
    in the controller and set the animations to the appropriate state.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取布尔值在其当前状态下的值，并将其存储在局部变量中。然后我们检查输入移动中的任意一个向量是否非零，以及`isWalking`当前是否为`false`。如果是这样，我们将动画器布尔值设置为`true`。否则，我们将其设置为`false`。当这个布尔值改变时，它将在控制器中更新并设置适当的动画状态。
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the most advanced method we have going on here. We think it’s a smart
    idea to get out of our comfort zones as often as possible to continue growth.
    We will walk through this and if it’s not making sense right now, let it sink
    in and your brain will work through it. There are three actions taking place here.
    We need to find the angle we want to rotate to, get a rotation value, and then
    rotate!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在这里使用的最先进的方法。我们认为，尽可能经常地走出我们的舒适区是一个明智的想法，以继续成长。我们将逐步讲解这个过程，如果现在它还不清楚，让它慢慢消化，你的大脑会处理它。这里有三个动作在进行。我们需要找到我们想要旋转到的角度，获取一个旋转值，然后旋转！
- en: Firstly, `targetAngle` is doing a `Mathf` method called `Atan2`. `Atan2` is
    an arctangent method that allows you to find the angle given the target position
    of where you want to rotate to. It’s an interesting method that is very useful
    in games for character rotations in 3D applications. The problem is that we need
    to also account for the camera again. `Atan2` returns radians, so we need to multiply
    it by the radians-to-degrees constant and then add the camera’s *y* angle. This
    is the offset from the character’s angle.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`targetAngle` 正在执行一个名为 `Mathf.Atan2` 的 `Mathf` 方法。`Mathf.Atan2` 是一个反正切方法，它允许你根据你想要旋转到的目标位置找到角度。这是一个有趣的方法，在游戏中对于3D应用程序中角色的旋转非常有用。问题是，我们还需要再次考虑相机。`Mathf.Atan2`
    返回弧度，因此我们需要将其乘以弧度到度的常数，然后加上相机的 *y* 角度。这是从角色角度的偏移量。
- en: Next, we then take that target angle and create a quaternion from it in the
    current camera angle on the *y* axis. This will allow us to get an angle we will
    need to go to without worrying about **gimbal locking** occurring. Gimbal locking
    is when two axes get stuck in rotation due to one axis being 90 degrees off center.
    Quaternions are not susceptible to gimbal locking, which is why we transfer to
    quaternions in the end from the Euler angles.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们然后从目标角度创建一个四元数，在当前相机的 *y* 轴上。这将允许我们得到一个我们将需要到达的角度，而不用担心会发生 **万向节锁**。万向节锁是指由于一个轴偏离中心90度，两个轴在旋转中卡住。四元数不会受到万向节锁的影响，这就是为什么我们最终从欧拉角转换到四元数。
- en: By definition, Euler angles are oriented with respect to a fixed coordinate
    system. This is how we represent the angle we are at in the game where the reference
    is from *0*, *0*, *0* in rotation on import. If you rotate the character 90 degrees
    on the *y* axis, it is represented as *0*, *90*, *0* in the rotational fields
    of the transform of that GameObject. These values are Euler angles.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，欧拉角是相对于一个固定坐标系定向的。这是我们表示游戏中我们所在的角度的方式，其中参考是从 *0*、*0*、*0* 的旋转导入。如果你在 *y*
    轴上旋转角色90度，它表示为 *0*、*90*、*0* 在那个 GameObject 的变换的旋转字段中。这些值是欧拉角。
- en: Finally, we need to transition to that rotation value. We do this through a
    **Slerp**. This stands for a **spherical lerp**. When working with rotations,
    it’s best to use the Slerp method. The arguments are our current rotation, the
    new rotation we just made, and then how long it should take to rotate to that
    new position. We made this rotation speed publicly available so we could change
    it on the fly to get the variable that feels best.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要过渡到那个旋转值。我们通过一个 **Slerp** 来做这件事。这代表一个 **球面插值**。当处理旋转时，最好使用 Slerp 方法。参数是我们的当前旋转、我们刚刚创建的新旋转，以及旋转到那个新位置所需的时间。我们使这个旋转速度公开可用，这样我们就可以在飞行中更改它以获得感觉最好的变量。
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After this is done, your character now has movement and rotation. This is a
    great first step to building out an environmental, narrative-driven exploration
    game. Let’s finish up with a summary of what the whole chapter covered.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，你的角色现在有了移动和旋转的能力。这是构建一个环境驱动、叙事驱动的探索游戏的一个很好的第一步。让我们总结一下本章涵盖了哪些内容。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a large amount of character information. We went
    through design, modeling and rigging, character controllers, rigid bodies, working
    in Unity, and scripting a movement controller.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的角色信息。我们讨论了设计、建模和绑定、角色控制器、刚体、在 Unity 中工作以及编写移动控制器脚本。
- en: Design will always be boiled down to the question of “why?” You should’ve taken
    away from this chapter that the why of your character and their motivations will
    help secure a unique character that can be relatable. Modeling and rigging are
    heavily dependent on the type of modeling you will need to do. We went over some
    key methods to help guide your modeling to think of animation first. This also
    applies to rigging. Animation will be the final stage, and the easier it is to
    properly animate, the easier you and your players will find a better overall experience.
    Animations tend to be continually worked on until very close to release. Take
    the design of the rig seriously, as making changes after animations start could
    end up requiring a remake of animations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 设计始终归结为“为什么？”你应该从本章中了解到，你角色的“为什么”以及他们的动机将有助于确保一个独特且易于引起共鸣的角色。建模和绑定很大程度上取决于你需要进行的建模类型。我们介绍了一些关键方法来帮助你将动画首先考虑在建模中。这也适用于绑定。动画将是最终阶段，动画越容易正确执行，你和你玩家将发现更好的整体体验。动画往往会在发布前一直进行修改。认真对待绑定设计，因为一旦动画开始制作，做出更改可能会导致需要重新制作动画。
- en: We realized that Unity built-in character controller makes the most sense to
    us as we don’t need Myvari to be tossed around by physics, such as ragdolling.
    We then went into Unity and imported Myvari and went over the components needed
    to get input as well as animations for her. Finally, we finished going over a
    character script for movement and rotations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，Unity 内置的角色控制器对我们来说最有意义，因为我们不需要 Myvari 被物理效果抛来抛去，比如拉杆效果。然后我们进入 Unity，导入
    Myvari，并检查了获取输入以及她的动画所需的组件。最后，我们完成了关于移动和旋转的角色脚本的检查。
- en: In the next chapter, we will look at the environment, the terrain, and a tool
    called ProBuilder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨环境、地形以及一个名为 ProBuilder 的工具。
- en: Join us on Discord!
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社群！
- en: At the time of writing this book, we had over 200 Unity professionals on the
    Unity server and we are constantly adapting to add new channels to facilitate
    conversations on key topics such as C# programming, game mechanics, game UI, animations,
    3D games, sound and effects, and a dedicated channel for Packt authors to connect
    with the book’s readers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，我们在 Unity 服务器上有超过 200 名 Unity 专业人士，我们正在不断适应，添加新的频道以促进关于关键主题的讨论，例如
    C# 编程、游戏机制、游戏 UI、动画、3D 游戏、音效和效果，以及一个专门用于 Packt 作者与本书读者建立联系的频道。
- en: Tell us about your progress made so far and the game idea you have in mind to
    build alongside this book. You never know—you might end up collaborating with
    someone on the server to build your mini-team today.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们到目前为止你所取得的进展以及你构思的与这本书一起构建的游戏想法。你永远不知道——你可能会在今天与服务器上的某人合作，组建你的迷你团队。
- en: '[https://packt.link/unity3dgamedev](https://packt.link/unity3dgamedev)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unity3dgamedev](https://packt.link/unity3dgamedev)'
- en: '![](img/QR_Code89002272-1876859406.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code89002272-1876859406.png)'
