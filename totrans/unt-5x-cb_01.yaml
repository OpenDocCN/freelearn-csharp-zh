- en: Chapter 1. Core UI – Messages, Menus, Scores, and Timers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 核心UI – 消息、菜单、得分和计时器
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Displaying a "Hello World" UI text message
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示 "Hello World" UI 文本消息
- en: Displaying a digital clock
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数字时钟
- en: Displaying a digital countdown timer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数字倒计时计时器
- en: Creating a message that fades away
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建渐隐的消息
- en: Displaying a perspective 3D text message
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示透视 3D 文本消息
- en: Displaying an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示图像
- en: Creating UI Buttons to move between scenes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI 按钮，在场景间切换
- en: Organizing images inside panels and changing panel depths via buttons
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面板内组织图像并通过按钮更改面板深度
- en: Displaying the value of an interactive UI Slider
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示交互式 UI 滑块的值
- en: Displaying a countdown timer graphically with a UI Slider
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI 滑块图形化显示倒计时计时器
- en: Displaying a radar to indicate the relative locations of objects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示雷达以指示对象的相对位置
- en: Creating UIs with the Fungus open-source dialog system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Fungus 开源对话框系统创建 UI
- en: Setting custom mouse cursor images
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置自定义鼠标光标图像
- en: Input Fields component for text entry
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本输入字段组件
- en: Toggles and radio buttons via Toggle Groups
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过切换组使用切换和单选按钮
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A key element contributing to the entertainment and enjoyment of most games
    is the quality of the visual experience, and an important part of this is the
    **User Interface** (**UI**). UI elements involve ways for the user to interact
    with the game (such as buttons, cursors, text boxes, and so on), as well as ways
    for the game to present up-to-date information to the user (such as the time remaining,
    current health, score, lives left, or location of enemies). This chapter is filled
    with UI recipes to give you a range of examples and ideas for creating game UIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数游戏娱乐和享受贡献关键要素的是视觉体验的质量，而这其中重要的部分是**用户界面**（**UI**）。UI 元素包括用户与游戏交互的方式（例如按钮、光标、文本框等），以及游戏向用户展示最新信息的方式（例如剩余时间、当前生命值、得分、剩余生命或敌人位置）。本章充满了
    UI 烹饪配方，为你提供一系列创建游戏 UI 的示例和想法。
- en: The big picture
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体概念
- en: Every game is different, and so this chapter attempts to fulfill two key roles.
    The first aim is to provide step-by-step instructions on how to create a wide
    range of the **Unity 5** UI elements and, where appropriate, associate them with
    game variables in code. The second aim is to provide a rich illustration of how
    UI elements can be used for a variety of purposes, so that you can get good ideas
    about how to make the Unity 5 UI set of controls deliver the particular visual
    experience and interactions for the games that you are developing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都不同，因此本章试图完成两个关键角色。第一个目标是提供创建各种 **Unity 5** UI 元素的逐步说明，并在适当的地方将它们与代码中的游戏变量关联。第二个目标是提供丰富的说明，说明
    UI 元素可以用于各种目的，以便你可以获得关于如何使 Unity 5 UI 控件集为正在开发的游戏提供特定视觉体验和交互的灵感。
- en: The basic UI elements can provide static images and text to just make the screen
    look more interesting. By using scripts, we can change the content of these images
    and text objects, so that the players' numeric scores can be updated, or we can
    show stickmen images to indicate how many lives the player has left, and so on.
    Other UI elements are interactive, allowing users to click on buttons, choose
    options, enter text, and so on. More sophisticated kinds of UI can involve collecting
    and calculating data about the game (such as percentage time remaining or enemy
    hit damage; or the positions and types of key GameObjects in the scene, and their
    relationship to the location and orientation of the player), and then displaying
    these values in a natural, graphical way (such as progress bars or radar screens).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基本UI元素可以提供静态图像和文本，仅使屏幕看起来更有趣。通过使用脚本，我们可以更改这些图像和文本对象的内容，以便更新玩家的分数，或者我们可以显示棍人图像来指示玩家剩余的生命，等等。其他
    UI 元素是交互式的，允许用户点击按钮、选择选项、输入文本等。更复杂的 UI 类型可能涉及收集和计算有关游戏的数据（例如剩余时间的百分比或敌人击中伤害；或场景中关键
    GameObjects 的位置和类型，以及它们与玩家位置和朝向的关系），然后以自然、图形化的方式显示这些值（例如进度条或雷达屏幕）。
- en: 'Core GameObjects, components, and concepts relating to Unity UI development
    include:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Unity UI 开发相关的核心 GameObjects、组件和概念包括：
- en: '**Canvas**: Every UI element is a child to a **Canvas**. There can be multiple
    **Canvas** GameObjects in a single scene. If a **Canvas** is not already present,
    then one will automatically be created when a new UI GameObject is created, with
    that UI object childed to the new **Canvas** GameObject.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Canvas**：每个UI元素都是**Canvas**的子对象。一个场景中可以有多个**Canvas** GameObjects。如果还没有**Canvas**，则在创建新的UI
    GameObject时，会自动创建一个，并且该UI对象将成为新**Canvas** GameObject的子对象。'
- en: '**EventSystem**: An **EventSystem** GameObject is required to manage the interaction
    events for UI controls. One will automatically be created with the first UI element.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventSystem**：需要一个**EventSystem** GameObject来管理UI控件的交互事件。第一个UI元素创建时，会自动创建一个。'
- en: '**Panel**: UI objects can be grouped together (logically and physically) with
    UI **Panels**. **Panels** can play several roles, including providing a GameObject
    parent in the **Hierarchy** for a related group of controls. They can provide
    a visual background image to graphically relate controls on the screen, and they
    can also have scripted resize and drag interactions added, if desired.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面板**：UI对象可以通过UI **面板**（逻辑上和物理上）组合在一起。**面板**可以扮演多个角色，包括为相关控制组在**层次结构**中提供一个GameObject父对象。它们可以提供视觉背景图像，以图形化地关联屏幕上的控件，并且如果需要，还可以添加脚本化的调整大小和拖动交互。'
- en: '**Visual UI** controls: The visible UI controls themselves include **Button**,
    **Image**, **Text**, **Toggle**, and so on.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉UI**控件：可见的UI控件包括**按钮**、**图像**、**文本**、**切换**等。'
- en: '**Interaction UI** controls: These are non-visible components that are added
    to GameObjects; examples include Input Field and Toggle Group.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互UI**控件：这些是非可见组件，被添加到GameObject中；例如包括输入字段和切换组。'
- en: 'The **Rect Transform** component: UI GameObjects can exist in a different space
    from that of the 2D and 3D scenes, which cameras render. Therefore, UI GameObjects
    all have the special **Rect Transform** component, which has some different properties
    to the scene''s GameObject **Transform** component (with its straightforward *X*/*Y*/*Z*
    position, rotation, and scale properties). Associated with **Rect Transforms**
    are pivot points (reference points for scaling, resizing, and rotations) and anchor
    points. Read more about these core features below.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rect Transform**组件：UI GameObjects可以存在于与2D和3D场景渲染的相机不同的空间中。因此，UI GameObjects都具有特殊的**Rect
    Transform**组件，它具有与场景的GameObject **Transform**组件（具有直接的 *X*/*Y*/*Z* 位置、旋转和缩放属性）不同的属性。与**Rect
    Transforms**相关联的是枢轴点（缩放、调整大小和旋转的参考点）和锚点。下面将详细介绍这些核心功能。'
- en: '**Sibling Depth**: The bottom-to-top display order (what appears on the top
    of what) for a UI element is determined initially by their sequence in the **Hierarchy**.
    At designtime, this can be manually set by dragging GameObjects into the desired
    sequence in the **Hierarchy**. At runtime, we can send messages to the **Rect
    Transforms** of GameObjects to dynamically change their **Hierarchy** position
    (and therefore, the display order), as the game or user interaction demands. This
    is illustrated in the *Organizing images inside panels and changing panel depths
    via buttons* recipe in this chapter.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟深度**：UI元素的从下到上的显示顺序（什么在什么上面显示）最初由它们在**层次结构**中的顺序决定。在设计时，可以通过将GameObject拖动到**层次结构**中所需的顺序来手动设置。在运行时，我们可以向GameObject的**Rect
    Transforms**发送消息以动态更改它们的**层次结构**位置（因此，显示顺序），以满足游戏或用户交互的需求。这在本章的*在面板内组织图像并通过按钮更改面板深度*食谱中得到了说明。'
- en: 'The following diagram shows how there are four main categories of UI controls,
    each in a **Canvas** GameObject and interacting via an **EventSystem** GameObject.
    UI Controls can have their own **Canvas**, or several UI controls can be in the
    same **Canvas**. The four categories are: static (display-only) and interactive
    UI controls, non-visible components (such as ones to group a set of mutually exclusive
    radio buttons), and C# script classes to manage UI control behavior through logic
    written in the program code. Note that UI controls that are not a child or descendent
    of a **Canvas** will not work properly, and interactive UI controls will not work
    properly if the **EventSystem** is missing. Both the **Canvas** and **EventSystem**
    GameObjects are automatically added to the Hierarchy as soon as the first UI GameObject
    is added to a scene.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了有四个主要的UI控件类别，每个类别都在一个**画布**GameObject中，并通过一个**事件系统**GameObject进行交互。UI控件可以有自己的**画布**，或者多个UI控件可以位于同一个**画布**中。这四个类别是：静态（仅显示）和交互式UI控件、不可见组件（例如用于分组一组互斥的单选按钮）以及C#脚本类，通过程序代码中编写的逻辑来管理UI控件的行为。请注意，不是**画布**的子控件或后代控件将无法正常工作，如果缺少**事件系统**，交互式UI控件也无法正常工作。**画布**和**事件系统**GameObject都会在将第一个UIGameObject添加到场景时自动添加到层次结构中。
- en: '![The big picture](img/1362OT_01_45.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![整体图景](img/1362OT_01_45.jpg)'
- en: UI **Rect Transforms** represents a rectangular area rather than a single point,
    which is the case for scene GameObject **Transforms**. **Rect Transforms** describe
    how a UI element should be positioned and sized relatively to its parent. **Rect
    Transforms** have a width and height that can be changed without affecting the
    local scale of the component. When the scale is changed for the **Rect Transform**
    of a UI element, then this will also scale font sizes and borders on sliced images,
    and so on. If all four anchors are at the same point, then resizing the **Canvas**
    will not stretch the **Rect Transform.** It will only affect its position. In
    this case, we'll see the **Pos X** and **Pos Y** properties, and the **Width**
    and **Height** of the rectangle. However, if the anchors are not all at the same
    point, then **Canvas** resizing will result in a stretching of the element's rectangle.
    So instead of the **Width**, we'll see the values for **Left** and **Right**—the
    position of the horizontal sides of the rectangle to the sides of the **Canvas**,
    where the **Width** will depend on the actual **Canvas** width (and the same for
    **Top/Bottom/Height**).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: UI **矩形变换**表示一个矩形区域，而不是一个单独的点，这与场景GameObject **变换**的情况不同。**矩形变换**描述了UI元素相对于其父元素应该如何定位和调整大小。**矩形变换**具有可以更改的宽度和高度，而不会影响组件的局部缩放。当对UI元素的**矩形变换**进行缩放时，这也会缩放切片图像上的字体大小和边框等。如果所有四个锚点都位于同一点，那么调整**画布**大小将不会拉伸**矩形变换**。它只会影响其位置。在这种情况下，我们将看到**X位置**和**Y位置**属性，以及矩形的**宽度**和**高度**。然而，如果锚点不在同一点，那么**画布**大小的调整将导致元素矩形的拉伸。因此，我们将看到**左**和**右**的值——矩形的水平边相对于**画布**边的位置，其中**宽度**将取决于实际的**画布**宽度（对于**上/下/高度**也是如此）。
- en: Unity provides a set of preset values for pivots and anchors, making the most
    common values very quick and easy to assign to an element's **Rect Transform**.
    The following screenshot shows the 3 x 3 grid that allows you quick choices about
    left, right, top, bottom, middle, horizontal, and vertical values. Also, the extra
    column on the right offers horizontal stretch presets, and the extra row at the
    bottom offers vertical stretch presets. Using the *SHIFT* and *ALT* keys sets
    the pivot and anchors when a preset is clicked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一套预设值用于旋转中心和锚点，使得最常见的值可以非常快速和容易地分配给元素的**矩形变换**。以下截图显示了3 x 3网格，它允许你快速选择左、右、上、下、中间、水平和垂直值。此外，右侧的额外列提供了水平拉伸预设，底部额外的行提供了垂直拉伸预设。使用*SHIFT*和*ALT*键在点击预设时设置旋转中心和锚点。
- en: '![The big picture](img/1362OT_01_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![整体图景](img/1362OT_01_03.jpg)'
- en: 'The Unity manual provides a very good introduction to the **Rect Transform.**
    In addition, Ray Wenderlich''s two-part Unity UI web tutorial also presents a
    great overview of the **Rect Transform**, pivots, and anchors. Both parts of Wenderlich''s
    tutorial make great use of animated GIFs to illustrate the effect of different
    values for pivots and anchors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Unity手册提供了对**矩形变换**的非常好的介绍。此外，Ray Wenderlich的两个部分Unity UI网络教程也展示了**矩形变换**、旋转中心和锚点的概述。Wenderlich教程的两个部分都很好地使用了动画GIF来展示旋转中心和锚点不同值的效应：
- en: '[http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档 - UI基本布局](http://docs.unity3d.com/Manual/UIBasicLayout.html)'
- en: '[http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity新GUI教程第1部分](http://www.raywenderlich.com/78675/unity-new-gui-part-1)'
- en: 'There are three **Canvas** render modes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种**画布**渲染模式：
- en: '**Screen Space – Overlay**: In this mode, the UI elements are displayed without
    any reference to any camera (there is no need for any **Camera** in the scene).
    The UI elements are presented in front of (overlaying) any sort of camera display
    of the scene contents.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕空间 - 覆盖**：在此模式下，UI元素显示时不参考任何摄像机（场景中不需要任何**摄像机**）。UI元素在场景内容的任何类型的摄像机显示之前（覆盖）呈现。'
- en: '**Screen Space – Camera**: In this mode, the **Canvas** is treated as a flat
    plane in the frustum (viewing space) of a **Camera** scene —where this plane is
    always facing the camera. So, any scene objects in front of this plane will be
    rendered in front of the UI elements on the **Canvas**. The **Canvas** is automatically
    resized if the screen size, resolution, or camera settings are changed.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕空间 - 摄像机**：在此模式下，**画布**被视为**摄像机**场景视锥体（观察空间）中的一个平面——其中此平面始终面向摄像机。因此，位于此平面之前的所有场景对象都将渲染在**画布**上的UI元素之前。如果屏幕大小、分辨率或摄像机设置发生变化，**画布**将自动调整大小。'
- en: '**World Space**: In this mode, the **Canvas** acts as a flat plane in the frustum
    (viewing space) of a **Camera** scene—but the plane is not made to always face
    the **Camera**. How the **Canvas** appears is just as with any other objects in
    the scene, relative to where (if anywhere) in the camera''s viewing frustum the
    **Canvas** plane is located and oriented.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界空间**：在此模式下，**画布**作为**摄像机**场景视锥体（观察空间）中的一个平面——但该平面不是始终面向**摄像机**。**画布**的显示方式与场景中的任何其他对象一样，相对于摄像机观察视锥体中（如果有的话）**画布**平面的位置和方向。'
- en: In this chapter, we have focused on the **Screen Space – Overlay** mode. But
    all these recipes can equally be used with the other two modes as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于**屏幕空间 - 覆盖**模式。但所有这些配方同样可以用于其他两种模式。
- en: Be creative! This chapter aims to act as a launching pad of ideas, techniques,
    and reusable **C#** scripts for your own projects. Get to know the range of Unity
    UI elements, and try to work smart. Often, a UI element exists with most of the
    components that you may need for something in your game, but you may need to adapt
    it somehow. An example of this can be seen in the recipe that makes a UI Slider
    non-interactive, instead using it to display a red-green progress bar for the
    status of a countdown timer. See this in the *Displaying a countdown timer graphically
    with a UI Slider* recipe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 发挥创意！本章旨在作为想法、技术和可重用**C#**脚本的发射台，用于您的项目。了解Unity UI元素的范畴，并尝试聪明地工作。通常，一个UI元素具有您可能需要的几乎所有组件，但您可能需要对其进行某种调整。一个例子可以在使UI滑块不可交互的配方中看到，而不是使用它来显示倒计时计时器的红色-绿色进度条。请参阅*使用UI滑块图形显示倒计时计时器*配方。
- en: Displaying a "Hello World" UI text message
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示“Hello World”UI文本消息
- en: The first traditional problem to be solved with a new computing technology is
    often to display the *Hello World* message. In this recipe, you'll learn to create
    a simple UI Text object with this message, in large white text with a selected
    font, and in the center of the screen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种新的计算技术要解决的第一个传统问题通常是显示*Hello World*消息。在本配方中，你将学习如何创建一个简单的UI Text对象，其中包含此消息，以大号白色文本和选定的字体显示，并在屏幕中央。
- en: '![Displaying a "Hello World" UI text message](img/1362OT_01_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![显示“Hello World”UI文本消息](img/1362OT_01_01.jpg)'
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the font that you need in a folder named `Fonts`
    in the `1362_01_01` folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`1362_01_01`文件夹中的`Fonts`文件夹中准备了您需要的字体。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display a **Hello World** text message, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示**Hello World**文本消息，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Import the provided `Fonts` folder.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Fonts`文件夹。
- en: 'In the **Hierarchy** panel, add a **UI** | **Text** GameObject to the scene
    – choose menu: **GameObject** | **UI** | **Text**. Name this GameObject **Text-hello**.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，将一个**UI** | **文本**GameObject添加到场景中 - 选择菜单：**GameObject** | **UI**
    | **文本**。将此GameObject命名为**Text-hello**。
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Alternatively, use the **Create** menu immediately below the **Hierarchy**
    tab, choosing menu: **Create** | **UI** | **Text**.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用位于**层次**标签下面的**创建**菜单，选择菜单：**创建** | **UI** | **文本**。
- en: 'Ensure that your new **Text-hello** GameObject is selected in the **Hierarchy**
    panel. Now, in the **Inspector**, ensure the following properties are set:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**面板中选中您的新**Text-hello**GameObject。现在，在**检查器**中，确保以下属性已设置：
- en: '**Text** set to read `Hello World`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**设置为读取`Hello World`'
- en: '**Font** set to `Xolonium-Bold`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体**设置为`Xolonium-Bold`'
- en: '**Font size** as per your requirements (large—this depends on your screen—try
    `50` or `100`)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体大小**根据您的需求设置（大——这取决于您的屏幕——尝试`50`或`100`）'
- en: '**Alignment** set to horizontal and vertical center'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**设置为水平和垂直居中'
- en: '**Horizontal** and **Vertical Overflow** set to `Overflow`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**和**垂直溢出**设置为`Overflow`'
- en: '**Color** set to white'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**设置为白色'
- en: 'The following screenshot shows the **Inspector** panel with these settings:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了具有这些设置的**检查器**面板：
- en: '![How to do it...](img/1362OT_01_02.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1362OT_01_02.jpg)'
- en: Now, in the **Rect Transform**, click on the **Anchor Presets** square icon,
    which should result in several rows and columns of preset position squares appearing.
    Hold down *SHIFT* and *ALT* and click on the center one (row **middle** and column
    **center**).![How to do it...](img/1362OT_01_03.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**Rect Transform**中，单击**锚点预设**方框图标，这将导致出现几行几列的预设位置方块。按住*SHIFT*和*ALT*并单击中心一个（行**中间**和列**中心**）。![如何操作...](img/1362OT_01_03.jpg)
- en: Your **Hello World** text will now appear, centered nicely in the **Game** panel.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的**Hello World**文本现在将出现在**游戏**面板中，居中显示。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You have added a new **Text-hello** GameObject to a scene. A parent **Canvas**
    and UI **EventSystem** will also have been automatically created.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将一个新的**Text-hello**GameObject添加到场景中。还会自动创建一个父**Canvas**和UI **EventSystem**。
- en: You set the text content and presentation properties, and use the **Rect Transform**
    anchor presets to ensure that whatever way the screen is resized, the text will
    stay horizontally and vertically centered.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您设置文本内容和展示属性，并使用**Rect Transform**锚点预设来确保无论屏幕如何调整大小，文本都将保持水平和垂直居中。
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some more details that you don't want to miss.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些您不想错过的更多细节。
- en: Styling substrings with Rich Text
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用富文本样式子字符串
- en: 'Each separate UI **Text** component can have its own color, size, boldness
    styling, and so on. However, if you wish to quickly add some highlighting style
    to a part of a string to be displayed to the user, the following are examples
    of some of the HTML-style markups that are available without the need to create
    separate UI **Text** objects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的UI **文本**组件都可以有自己的颜色、大小、粗体样式等。然而，如果您希望快速向要显示给用户的字符串的一部分添加一些突出显示样式，以下是一些不需要创建单独UI
    **文本**对象的HTML样式标记示例：
- en: 'Embolden text with the "`b`" markup: `I am <b>bold</b>`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用"`b`"标记加粗文本：`I am <b>bold</b>`
- en: 'Italicize text with the "`i`" markup: `I am <i>italic</i>`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用"`i`"标记斜体文本：`I am <i>italic</i>`
- en: 'Set the text color with hex values or a color name: `I am <color=green>green
    text</color>, but I am <color=#FF0000>red</color>`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用十六进制值或颜色名称设置文本颜色：`I am <color=green>green text</color>，但我现在是 <color=#FF0000>红色</color>`
- en: Note
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Learn more from the Unity online manual **Rich Text** page at: [http://docs.unity3d.com/Manual/StyledText.html](http://docs.unity3d.com/Manual/StyledText.html).'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Unity在线手册的**富文本**页面了解更多信息：[http://docs.unity3d.com/Manual/StyledText.html](http://docs.unity3d.com/Manual/StyledText.html)。
- en: Displaying a digital clock
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示数字时钟
- en: Whether it is the real-world time, or perhaps an in-game countdown clock, many
    games are enhanced by some form of clock or timer display. The most straightforward
    type of clock to display is a string composed of the integers for hours, minutes,
    and seconds, which is what we'll create in this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是现实世界的时间，还是游戏中的倒计时时钟，许多游戏都通过某种形式的时钟或计时器显示得到了增强。要显示的最直接的时钟类型是由小时、分钟和秒的整数组成的字符串，这就是我们在本菜谱中要创建的内容。
- en: 'The following screenshot shows the kind of clock we will be creating in this
    recipe:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将在这个菜谱中创建的时钟类型：
- en: '![Displaying a digital clock](img/1362OT_01_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![显示数字时钟](img/1362OT_01_04.jpg)'
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, we have prepared the font that you need in a folder named `Fonts`
    in the `1362_01_01` folder.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`1362_01_01`文件夹中的`Fonts`文件夹中准备了您需要的字体。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a digital clock, follow these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数字时钟，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Import the provided `Fonts` folder.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Fonts`文件夹。
- en: In the **Hierarchy** panel, add a **UI** | **Text** game object to the scene
    named **Text-clock**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将一个**UI** | **文本**游戏对象添加到场景中，命名为**Text-clock**。
- en: 'Ensure that GameObject **Text-clock** is selected in the **Hierarchy** panel.
    Now, in **Inspector**, ensure that the following properties are set:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**面板中选择GameObject **Text-clock**。现在，在**检查器**中，确保以下属性已设置：
- en: '**Text** set to read as `time goes here` (this placeholder text will be replaced
    by the time when the scene is running.)'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**设置为读取为`time goes here`（此占位文本将在场景运行时被时间替换。）'
- en: '**Font type** set to `Xolonium Bold`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体类型**设置为`Xolonium Bold`'
- en: '**Font Size** set to `20`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体大小**设置为`20`'
- en: '**Alignment** set to horizontal and vertical center'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**设置为水平和垂直居中'
- en: '**Horizontal** and **Vertical Overflow** settings set to **Overflow**'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**和**垂直溢出**设置设置为**溢出**'
- en: '**Color** set to white'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**设置为白色'
- en: Now, in the **Rect Transform**, click on the **Anchor Presets** square icon,
    which will result in the appearance of several rows and columns of preset position
    squares. Hold down *SHIFT* and *ALT* and click on the **top** and column **center**
    rows.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**矩形变换**中，单击**锚点预设**方图标，这将导致出现几行几列的预设位置方块。按住*SHIFT*和*ALT*，然后单击**顶部**和**列中心**行。
- en: 'Create a folder named `Scripts` and create a C# script class called `ClockDigital`
    in this new folder:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Scripts`的文件夹，并在该新文件夹中创建一个名为`ClockDigital`的C#脚本类：
- en: '[PRE0]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With GameObject **Text-clock** selected in the **Hierarchy** panel, drag your
    `ClockDigital` script onto it to add an instance of this script class as a component
    to GameObject **Text-clock**, as shown in the following screenshot:![How to do
    it...](img/1362OT_01_05.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择GameObject **Text-clock**，将您的`ClockDigital`脚本拖放到它上面，以将此脚本类的实例作为组件添加到GameObject
    **Text-clock**中，如图所示：![如何操作...](img/1362OT_01_05.jpg)
- en: When you run the scene, you will now see a digital clock, showing hours, minutes,
    and seconds, at the top-center part of the screen.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行场景时，您现在将看到一个数字时钟，显示在屏幕的顶部中央部分，显示小时、分钟和秒。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added a **Text** GameObject to a scene. You have added an instance of the
    `ClockDigital` C# script class to that GameObject.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将一个**文本**GameObject添加到场景中。您已将该GameObject添加了`ClockDigital` C#脚本类的一个实例。
- en: Notice that as well as the standard two C# packages (`UnityEngine` and `System.Collections`)
    that are written by default for every new script, you have added the `using` statements
    for two more C# script packages, `UnityEngine.UI` and `System`. The UI package
    is needed, since our code uses UI `Text` object; and the `System` package is needed,
    since it contains the `DateTime` class that we need to access the clock on the
    computer where our game is running.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了默认为每个新脚本编写的标准两个C#包（`UnityEngine`和`System.Collections`）之外，您还添加了两个额外的C#脚本包的`using`语句，即`UnityEngine.UI`和`System`。UI包是必需的，因为我们的代码使用了UI
    `Text`对象；而`System`包也是必需的，因为它包含我们需要的`DateTime`类，以便访问运行游戏的计算机上的时钟。
- en: There is one variable, `textClock`, which will be a reference to the `Text`
    component, whose text content we wish to update in each frame with the current
    time in hours, minutes, and seconds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个变量`textClock`，它将是一个对`Text`组件的引用，我们希望在每个帧中用当前的小时、分钟和秒更新其文本内容。
- en: The `Start()` method (executed when the scene begins) sets the `textClock` variable
    to be a reference to the `Text` component in the GameObject, to which our scripted
    object has been added.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景开始时执行的`Start()`方法将`textClock`变量设置为对GameObject中`Text`组件的引用，该组件已添加到我们的脚本对象中。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that an alternative approach would be to make `textClock` a `public` variable.
    This will allow us to assign it via drag-and-drop in the **Inspector** panel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，另一种方法是将`textClock`设置为`public`变量。这将允许我们在**检查器**面板中通过拖放来分配它。
- en: The `Update()`method is executed in every frame. The current time is stored
    in the `time` variable, and strings are created by adding leading zeros to the
    number values for the hours, minutes, and seconds properties of variable `time`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法在每一帧执行。当前时间存储在`time`变量中，并通过为变量`time`的小时、分钟和秒属性添加前导零来创建字符串。'
- en: This method finally updates the `text` property (that is, the letters and numbers
    that the user sees) to be a string, concatenating the hours, minutes, and seconds
    with colon separator characters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法最终更新`text`属性（即用户看到的字母和数字）为字符串，通过冒号分隔符连接小时、分钟和秒。
- en: The `LeadingZero(…)`method takes as input an integer and returns a string of
    this number with leading zeros added to the left, if the value was less than 10.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeadingZero(…)`方法接受一个整数作为输入，并返回一个字符串，如果该值小于10，则在左侧添加前导零。'
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: The Unity tutorial for animating an analogue clock
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity教程：如何为模拟时钟动画
- en: Unity has published a nice tutorial on how to create 3D objects, and animate
    them through C# script to display an analogue clock at [https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock](https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Unity发布了一个关于如何创建3D对象并通过C#脚本动画它们以显示模拟时钟的精彩教程，请参阅[https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock](https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock)。
- en: Displaying a digital countdown timer
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示数字倒计时计时器
- en: 'This recipe will show you how to display a digital countdown clock shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向你展示如何显示这里所示的数字倒计时时钟：
- en: '![Displaying a digital countdown timer](img/1362OT_01_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![显示数字倒计时计时器](img/1362OT_01_07.jpg)'
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是对之前的食谱的改编。因此，请复制之前食谱的项目，并在此基础上进行工作。
- en: For this recipe, we have prepared the script that you need in a folder named
    `Scripts` in the `1362_01_03` folder.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_01_03`文件夹下的`Scripts`文件夹中准备了你需要的脚本。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a digital countdown timer, follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数字倒计时计时器，请按照以下步骤操作：
- en: In the **Inspector** panel, remove the scripted component, `ClockDigital,` from
    GameObject **Text-clock**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，从GameObject **Text-clock**中移除脚本组件`ClockDigital`。
- en: 'Create a `DigitalCountdown` C# script class containing the following code,
    and add an instance as a scripted component to GameObject **Text-clock**:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的`DigitalCountdown` C#脚本类，并将其作为脚本组件添加到GameObject **Text-clock**中：
- en: '[PRE1]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the scene, you will now see a digital clock counting down from
    30\. When the countdown reaches zero, the message **countdown has finished** will
    be displayed.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行场景时，你现在将看到一个从30开始的数字时钟倒计时。当倒计时达到零时，将显示消息**倒计时已完成**。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added a **Text** GameObject to a scene. You have added an instance of the
    `DigitalCountdown` C# script class to that GameObject.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经向场景中添加了一个**Text** GameObject。你已向该GameObject添加了`DigitalCountdown` C#脚本类的实例。
- en: There is one variable, `textClock`, which will be a reference to the `Text`
    component, whose text content we wish to update in each frame with a time remaining
    message (or a timer complete message). Then, a call is made to the `CountdownTimerReset(…)`
    method, passing an initial value of 30 seconds.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个变量`textClock`，它将是一个对`Text`组件的引用，我们希望在每个帧中用剩余时间消息（或计时器完成消息）更新其文本内容。然后调用`CountdownTimerReset(…)`方法，传递一个初始值为30秒的值。
- en: The `Start()` method (executed when the scene begins) sets the `textClock` variable
    to find the `Text` component in the GameObject where our scripted object has been
    added.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法（在场景开始时执行）将`textClock`变量设置为在添加脚本对象的游戏对象中查找`Text`组件。'
- en: The `Update()` method is executed in every frame. This method initially sets
    the `timerMessage` variable to a message, stating that the timer has finished
    (the default message to display). Then the seconds remaining are tested to be
    greater than zero. And if so, then the message variable has its contents changed
    to display the integer (whole) number of the seconds remaining in the countdown—retrieved
    from the `CountdownTimerSecondsRemaining()` method. This method finally updates
    the `text` property (that is, the letters and numbers that the user sees) to be
    a string with a message about the remaining seconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法在每一帧执行。该方法最初将`timerMessage`变量设置为一条消息，表明计时器已完成（默认要显示的消息）。然后检查剩余秒数是否大于零。如果是这样，则将消息变量的内容更改为显示倒计时剩余的整数（整个）秒数——从`CountdownTimerSecondsRemaining()`方法中检索。该方法最后更新`text`属性（即用户看到的字母和数字）为包含关于剩余秒数消息的字符串。'
- en: The `CountdownTimerReset(…)` method records the number of seconds provided,
    and the time the method was called.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountdownTimerReset(…)`方法记录提供的秒数和调用该方法的时间。'
- en: The `CountdownTimerSecondsRemaining()` method returns an integer value of the
    number of seconds remaining.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountdownTimerSecondsRemaining()`方法返回剩余秒数的整数值。'
- en: Creating a message that fades away
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个渐隐的消息
- en: 'Sometimes, we want a message to display just for a certain time, and then fade
    away and disappear, which will appear as shown in this screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望消息只显示一段时间，然后渐隐并消失，这将在下面的屏幕截图中显示：
- en: '![Creating a message that fades away](img/1362OT_01_20.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![创建渐隐消息](img/1362OT_01_20.jpg)'
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adapts the first recipe in this chapter, so make a copy of that
    project to work on for this recipe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱改编了本章的第一个食谱，所以请复制那个项目来为这个食谱工作。
- en: For this recipe, we have prepared the script that you need in a folder named
    `Scripts` in the `1362_01_04` folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_01_04`文件夹中的`Scripts`文件夹里准备了一个你需要使用的脚本。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display a text message that fades away, follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示渐隐的文本消息，请按照以下步骤操作：
- en: Import the provided C# script class called `CountdownTimer`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的名为`CountdownTimer`的C#脚本类。
- en: Ensure that GameObject **Text-hello** is selected in the **Hierarchy** tab.
    Then, attach an instance of the `CountdownTimer` C# script class as a component
    of this GameObject.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**选项卡中选择GameObject **Text-hello**。然后，将`CountdownTimer` C#脚本类的实例作为此GameObject的组件附加。
- en: 'Create a C# script class, `FadeAway`, containing the following code, and add
    an instance as a scripted component to the GameObject **Text-hello**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的C#脚本类`FadeAway`，并将其作为脚本组件添加到GameObject **Text-hello**中：
- en: '[PRE2]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the scene, you will now see that the message on the screen slowly
    fades away, disappearing after 5 seconds.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行场景时，你现在会看到屏幕上的消息会慢慢渐隐，5秒后消失。
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: An instance of the provided `CountdownTimer` script class was added as a component
    to the GameObject **Text-hello**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供的`CountdownTimer`脚本类的实例添加为**Text-hello** GameObject的组件。
- en: You added to the GameObject **Text-hello** an instance of the scripted class,
    `FadeAway`. The `Start()`method caches references to the `Text` and `CountdownTimer`
    components in the `countdownTimer` and `textUI` variables. Then, it calls the
    `StartFading(…)`method, passing in the number 5, so that the message will have
    faded to invisible after 5 seconds.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你向GameObject **Text-hello**添加了`FadeAway`脚本类的实例。`Start()`方法将`Text`和`CountdownTimer`组件的引用缓存到`countdownTimer`和`textUI`变量中。然后，它调用`StartFading(…)`方法，传入数字5，这样消息将在5秒后变为不可见。
- en: The `StartFading(…)` method starts this timer scripted component to countdown
    to the given number of seconds. It also sets the `fading` Boolean flag variable
    to `true`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartFading(…)`方法启动这个计时器脚本组件，倒计时到指定的秒数。它还设置`fading`布尔标志变量为`true`。'
- en: The `Update()` method, in each frame, tests if the `fading` variable is `true`.
    If it is true, then the alpha (transparency) component of the color of the **Text-hello**
    object is set to a value between 0.0 and 1.0, based on the proportion of the time
    remaining in the `CountdownTimer` object. Finally, if the proportion of time remaining
    is less than a very small value (0.01), then the `fading` variable is set to `false`
    (to save the processing work since the text is now invisible).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法在每个帧中测试`fading`变量是否为`true`。如果是，则将**Text-hello**对象的颜色的alpha（透明度）组件设置为介于0.0和1.0之间的值，基于`CountdownTimer`对象剩余时间的比例。最后，如果剩余时间的比例小于一个非常小的值（0.01），则将`fading`变量设置为`false`（以节省处理工作，因为文本现在不可见）。'
- en: Displaying a perspective 3D text message
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示透视3D文本消息
- en: Unity provides an alternative way to display text in 3D via the `TextMesh` component.
    While this is really suitable for a text-in-the-scene kind of situation (such
    as billboards, road signs, and generally wording on the side of 3D objects that
    might be seen close up), it is quick to create, and is another way of creating
    interesting menus or instructions scenes, and the like.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个通过`TextMesh`组件显示3D文本的替代方法。虽然这非常适合场景中的文本（如广告牌、路标以及通常在可能近距离看到的3D物体旁边的文字），但它创建起来很快，是创建有趣菜单或指令场景等的一种方式。
- en: 'In this recipe, you''ll learn how to create a scrolling 3D text, simulating
    the famous opening credits of the movie **Star Wars**, which looks something like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何创建一个滚动的3D文字，模拟电影**星球大战**著名的开场字幕，看起来就像这样：
- en: '![Displaying a perspective 3D text message](img/1362OT_01_27.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![显示透视3D文本消息](img/1362OT_01_27.jpg)'
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the fonts that you need in a folder named
    `Fonts`, and the text file that you need in a folder named `Text`, in the `1362_01_04`
    folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_01_04`文件夹中的`Fonts`文件夹里准备了你需要使用的字体，以及`Text`文件夹里你需要使用的文本文件。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display perspective 3D text, follow these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示透视3D文本，请按照以下步骤操作：
- en: Create a new Unity 3D project (this ensures that we start off with a **Perspective**
    camera, suitable for the 3D effect that we want to create).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目（这确保我们从一个**透视**摄像机开始，适合我们想要创建的3D效果）。
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to mix 2D and 3D scenes in your project, you can always manually
    set any camera's **Camera Projection** property to **Perspective** or **Orthographic**
    via the **Inspector** panel.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你需要在项目中混合2D和3D场景，你总是可以通过**检查器**面板手动设置任何摄像机的**相机投影**属性为**透视**或**正交**。
- en: 'In the **Hierarchy** panel, select the **Main Camera** item, and, in the **Inspector**
    panel, set its properties as follows: **Camera Clear Flags** to **solid color**,
    **Field of View** to **150**. Also set the **Background color** to black.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，选择**主摄像机**项，并在**检查器**面板中设置其属性如下：**相机清除标志**为**纯色**，**视野**为**150**。还将**背景颜色**设置为黑色。
- en: Import the provided `Fonts` folder.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Fonts`文件夹。
- en: 'In the **Hierarchy** panel, add a **UI** | **Text** game object to the scene
    – choose menu: **GameObject** | **UI** | **Text**. Name this GameObject as `Text-star-wars`.
    Set its **Text Content** as Star Wars (with each word on a new line). Then, set
    its **Font** to `Xolonium Bold`, and its **Font Size** to `50`. Use the anchor
    presets in **Rect Transform** to position this UI **Text** object at the top center
    of the screen.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将一个**UI** | **文本**游戏对象添加到场景中 - 选择菜单：**GameObject** | **UI** | **Text**。将此GameObject命名为`Text-star-wars`。将其**文本内容**设置为星球大战（每个单词占一行）。然后，将其**字体**设置为`Xolonium
    Bold`，其**字体大小**为`50`。使用**Rect Transform**中的预设锚点将此UI **文本**对象定位在屏幕顶部中央。
- en: 'In the **Hierarchy** panel, add a **3D Text** game object to the scene – choose
    menu: **GameObject** | **3D Object** | **3D Text**. Name this GameObject `Text-crawler`.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将一个**3D文本**游戏对象添加到场景中 - 选择菜单：**GameObject** | **3D Object** | **3D
    Text**。将此GameObject命名为`Text-crawler`。
- en: 'In the **Inspector** panel, set the **Transform** properties for GameObject
    **Text-crawler** as follows: **Position** (`0`, `-300`, `-20`), **Rotation** (`15`,
    `0`, `0`).'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，设置GameObject **Text-crawler**的**变换**属性如下：**位置** (`0`, `-300`, `-20`),
    **旋转** (`15`, `0`, `0`)。
- en: 'In the **Inspector** panel, set the **Text Mesh** properties for GameObject
    **Text-crawler** as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将GameObject **Text-crawler**的**文本网格**属性设置如下：
- en: Paste the content of the provided text file, `star_wars.txt,` into **Text**.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将提供的文本文件`star_wars.txt`的内容粘贴到**文本**中。
- en: Set **Offset Z** = `20`, **Line Spacing** = `0.8`, and **Anchor** = Middle center
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置**偏移Z** = `20`，**行间距** = `0.8`，和**锚点** = 中间中心
- en: Set **Font Size** = `200`, **Font** = `SourceSansPro-BoldIt`
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置**字体大小** = `200`，**字体** = `SourceSansPro-BoldIt`
- en: When the scene is made to run, the Star Wars story text will now appear nicely
    squashed in 3D perspective on the screen.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当场景运行时，星球大战的故事文本现在将很好地以3D透视形式出现在屏幕上。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have simulated the opening screen of the movie *Star Wars*, with a flat
    UI **Text** object title at the top of the screen, and 3D **Text Mesh** with settings
    that appear to be disappearing into the horizon with 3D perspective 'squashing'.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经模拟了电影《星球大战》的开场屏幕，屏幕顶部有一个平面的UI **文本**对象标题，以及3D **文本网格**，其设置看起来像是随着3D透视而消失在地平线上。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are some details that you don't want to miss.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不应该错过。
- en: We have to make this text crawl like it does in the movie
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们必须让这段文字像电影中那样滚动
- en: 'With a few lines of code, we can make this text scroll in the horizon just
    as it does in the movie. Add the following C# script class, `ScrollZ,` as a component
    to GameObject **Text-crawler**:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几行代码，我们可以让这段文字在水平方向上滚动，就像电影中那样。将以下C#脚本类`ScrollZ`作为组件添加到GameObject **Text-crawler**：
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In each frame via the `Update()` method, the position of the 3D text object
    is moved in the direction of this GameObject's local up-direction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧通过`Update()`方法，将3D文本对象的位置移动到该GameObject的局部向上方向。
- en: Where to learn more
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多信息在哪里
- en: Learn more about 3D Text and Text Meshes in the Unity online manual at [http://docs.unity3d.com/Manual/class-TextMesh.html](http://docs.unity3d.com/Manual/class-TextMesh.html).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity在线手册中了解更多关于3D文本和文本网格的信息，请访问[http://docs.unity3d.com/Manual/class-TextMesh.html](http://docs.unity3d.com/Manual/class-TextMesh.html)。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: An alternative way of achieving perspective text like this would be to
    use a Canvas with render mode World Space.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：实现类似这种透视文本的另一种方法是将Canvas与世界空间渲染模式一起使用。
- en: Displaying an image
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示图像
- en: There are many cases where we wish to display an image onscreen, including logos,
    maps, icons, splash graphics, and so on. In this recipe, we will display an image
    at the top of the screen, and make it stretch to fit whatever width that the screen
    is resized to.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况我们希望在屏幕上显示图像，包括标志、地图、图标、启动图形等。在这个菜谱中，我们将在屏幕顶部显示一个图像，并使其拉伸以适应屏幕调整后的任何宽度。
- en: 'The following screenshot shows Unity displaying an image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Unity显示的图像：
- en: '![Displaying an image](img/1362OT_01_06.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![显示图像](img/1362OT_01_06.jpg)'
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the image that you need in a folder named
    `Images` in the `1362_01_06` folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`1362_01_06`文件夹中的`Images`文件夹中准备了您需要的图像。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display a stretched image, follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示拉伸的图像，请按照以下步骤操作：
- en: Create a new Unity 3D project.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: Note
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 3D projects will, by default, import images as a **Texture**, and 2D projects
    will import images as **Sprite (2D and UI)**. Since we're going to use a **RawImage**
    UI component, we need our images to be imported as textures.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，3D项目将图像导入为**纹理**，2D项目将图像导入为**精灵（2D和UI）**。由于我们将使用**原始图像**UI组件，我们需要将图像导入为纹理。
- en: 'Set the Game panel to a 400 x 300 size. Do this via menu: **Edit** | **Project
    Settings** | **Player**. Ensure that the **Resolution** | **Default is Full Screen**
    setting check is unchecked, and the width/height is set to 400 x 300\. Then, in
    the **Game** panel, select **Stand Alone (400 x 300)**. This will allow us to
    test the stretching of our image to a width of 400 pixels.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏面板设置为400 x 300的大小。通过菜单：**编辑** | **项目设置** | **玩家**。确保**分辨率** | **默认为全屏**设置未勾选，宽度和高度设置为400
    x 300。然后，在**游戏**面板中，选择**独立（400 x 300）**。这将允许我们测试图像拉伸至400像素的宽度。
- en: Import the provided folder, which is called `Images`. In the **Inspector** tab,
    ensure that the `unity5_learn` image has **Texture Type** set to **Texture**.
    If it does not, then choose **Texture** from the drop-down list, and click on
    the **Apply** button. The following screenshot shows the **Inspector** tab with
    the **Texture** settings:![How to do it...](img/1362OT_01_13.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的文件夹，该文件夹名为`Images`。在**检查器**选项卡中，确保`unity5_learn`图像的**纹理类型**设置为**纹理**。如果没有，则从下拉列表中选择**纹理**，并单击**应用**按钮。以下截图显示了带有**纹理**设置的**检查器**选项卡：![如何操作...](img/1362OT_01_13.jpg)
- en: In the **Hierarchy** panel, add a **UI** | **RawImage** GameObject to the scene
    named **RawImage-unity5**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，向场景添加一个名为**RawImage-unity5**的**UI** | **原始图像**游戏对象。
- en: Note
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to *prevent* the distortion and stretching of an image, then use
    the UI **Sprite** GameObject instead, and ensure that you check the **Preserve
    Aspect** option, in its **Image (Script)** component, in the **Inspector** panel.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您希望**防止**图像的扭曲和拉伸，则使用UI **精灵**游戏对象，并确保在**检查器**面板中其**图像（脚本）**组件中勾选**保留纵横比**选项。
- en: Ensure that the GameObject **RawImage-unity5** is selected in the **Hierarchy**
    panel. From your **Project** folder (`Images`), drag the `unity5_learn` image
    into the **Raw Image (Script)** public property **Texture**. Click on the **Set
    Native Size** button to preview the image before it gets stretched, as shown:![How
    to do it...](img/1362OT_01_14.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**面板中选择**RawImage-unity5**游戏对象。从您的**项目**文件夹（`Images`），将`unity5_learn`图像拖动到**原始图像（脚本）**公共属性**纹理**。单击**设置原生大小**按钮，在拉伸之前预览图像，如图所示：![如何操作...](img/1362OT_01_14.jpg)
- en: Now, in **Rect Transform**, click on the **Anchor Presets** square icon, which
    will result in several rows and columns of preset position squares appearing.
    Hold down *SHIFT* and *ALT* and click on the **top row** and the **stretch column**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**矩形变换**中，单击**锚点预设**方形图标，这将导致出现几行几列的预设位置方块。按住*SHIFT*和*ALT*，然后单击**顶部行**和**拉伸列**。
- en: The image will now be positioned neatly at the top of the **Game** panel, and
    will be stretched to the full width of 400 pixels.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在图像将被整齐地放置在**游戏**面板的顶部，并拉伸至400像素的全宽。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You have ensured that an image has **Texture Type** set to **Texture**. You
    added a **UI RawImage** control to the scene. The **RawImage** control has been
    made to display the `unity5_learn` image file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您已确保图像的**纹理类型**设置为**纹理**。您已向场景添加了一个**UI原始图像**控件。**原始图像**控件被设置为显示`unity5_learn`图像文件。
- en: The image has been positioned at the top of the **Game** panel, and using the
    anchor and pivot presets, it has made the image stretch to fill the whole width,
    which we set to 400 pixels via the **Player** settings.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图像已定位在**游戏**面板的顶部，并使用锚点和预设的枢轴，使图像拉伸以填充整个宽度，我们通过**玩家**设置将其设置为400像素。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are some details that you don''t want to miss:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过：
- en: Working with Sprites and UI Image components
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Sprite和UI Image组件一起工作
- en: If you simply wish to display non-animated images, then **Texture** images and
    UI **RawImage** controls are the way to go. However, if you want more options
    on how an image should be displayed (such as tiling, and animation), then the
    UI **Sprite** control should be used instead. This control needs image files to
    be imported as the **Sprite (2D and UI) type**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想显示非动画图像，那么**纹理**图像和UI **RawImage**控件就是你的选择。然而，如果你想有更多关于如何显示图像的选项（例如平铺和动画），那么应该使用UI
    **Sprite**控件。这个控件需要将图像文件导入为**Sprite（2D和UI）类型**。
- en: Once an image file has been dragged into the UI **Image** control's **Sprite**
    property, additional properties will be available, such as **Image Type**, options
    to preserve aspect ratio, and so on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像文件被拖动到UI **Image**控件的**Sprite**属性中，将提供额外的属性，例如**图像类型**、保留宽高比等选项。
- en: '![Working with Sprites and UI Image components](img/1362OT_01_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![与Sprite和UI Image组件一起工作](img/1362OT_01_15.jpg)'
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: An example of tiling a Sprite image can be found in the *Revealing icons for
    multiple object pickups by changing the size of a tiled image* recipe in [Chapter
    2](ch02.html "Chapter 2. Inventory GUIs"), *Inventory GUIs*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。库存GUI")中，*通过改变平铺图像的大小来显示多个对象拾取的图标*的配方中可以找到一个平铺Sprite图像的例子，*库存GUI*。
- en: Creating UI Buttons to move between scenes
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UI按钮在场景间切换
- en: As well as scenes where the player plays the game, most games will have menu
    screens, which display to the user messages about instructions, high scores, the
    level they have reached so far, and so on. Unity provides the UI **Buttons** to
    make it easy to offer users a simple way to indicate their choice of action on
    such screens.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了玩家玩游戏时的场景，大多数游戏都会有菜单屏幕，这些屏幕向用户显示有关说明、高分、他们已经达到的水平等信息。Unity提供了UI **按钮**，以便用户可以轻松地在这些屏幕上表示他们的选择。
- en: 'In this recipe, we''ll create a very simple game consisting of two screens,
    each with a button to load the other one, similar to the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个非常简单的游戏，包含两个屏幕，每个屏幕都有一个按钮来加载另一个屏幕，类似于以下截图：
- en: '![Creating UI Buttons to move between scenes](img/1362OT_01_29.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![创建UI按钮在场景间切换](img/1362OT_01_29.jpg)'
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a button-navigable multi-scene game, follow these steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个按钮可导航的多场景游戏，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Save the current (empty) scene, naming it **page1**.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前（空）场景，命名为**page1**。
- en: Add a UI **Text** object positioned at the top center of the scene, containing
    text `Main Menu / (page 1)` in a large font size.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景顶部中心位置添加一个UI **文本**对象，包含文本`主菜单 / (page 1)`，字体大小较大。
- en: Add a UI **Button** to the scene positioned in the middle center of the screen.
    In the **Hierarchy** panel, click on the show children triangle to display the
    UI **Text** child of this button GameObject. Select the **Text** button-child
    GameObject, and in the **Inspector** panel for the **Text** property of the **Text
    (Script)** component, enter the button text called `goto page 2`, as shown here:![How
    to do it...](img/1362OT_01_30.jpg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中间中心位置添加一个UI **按钮**。在**层次结构**面板中，点击显示子项三角形以显示此按钮GameObject的UI **文本**子项。选择**文本**按钮子项GameObject，并在**检查器**面板中，对于**文本（脚本）**组件的**文本**属性，输入按钮文本`goto
    page 2`，如图所示：![如何操作...](img/1362OT_01_30.jpg)
- en: 'Add the current scene to the build, choosing menu: **File** | **Build Settings…**.
    Then, click on the **Add Current** button so that the **page1** scene becomes
    the first scene on the list of **Scenes in the Build**.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前场景添加到构建中，选择菜单：**文件** | **构建设置…**。然后，点击**添加当前**按钮，使**page1**场景成为**构建中的场景**列表中的第一个场景。
- en: Note
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We cannot tell Unity to load a scene that has not been added to the list of
    scenes in the build. We use the `Application.LoadLevel(…)`code to tell Unity to
    load the scene name (or numeric index) that is provided.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不能告诉Unity加载尚未添加到构建场景列表中的场景。我们使用`Application.LoadLevel(…)`代码告诉Unity加载提供的场景名称（或数字索引）。
- en: 'Create a C# script class, `MenuActions,` containing the following code, and
    add an instance as a scripted component to the **Main Camera**:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的C#脚本类`MenuActions`，并将其作为脚本组件添加到**主相机**：
- en: '[PRE4]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ensure that the **Button** is selected in the **Hierarchy** and click on the
    plus sign "**+**" button at the bottom of the **Button (Script)** component, in
    the **Inspector view**, to create a new **OnClick** event handler for this button.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了**按钮**，然后在**Inspector视图**中点击**按钮（脚本）**组件底部的加号“**+**”按钮，为该按钮创建一个新的**OnClick**事件处理器。
- en: Drag the **Main Camera** from the **Hierarchy** over the **Object** slot—immediately
    below the menu saying **Runtime Only**. This means that when the **Button** receives
    an **OnClick** event, we can call a public method from a scripted object inside
    the **Main Camera**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主相机**从**层次结构**拖到**对象**槽中——位于说**仅运行时**的菜单下方。这意味着当**按钮**接收到**OnClick**事件时，我们可以从**主相机**内部的脚本对象中调用一个公共方法。
- en: Now, select the **MENU_ACTION_GotoPage()** method from the **MenuActions** drop-down
    list (initially showing **No Function**). Type `page2` (the name of the scene
    we want to be loaded when this button is clicked) in the text box, below the method's
    drop-down menu. This **page2** string will be passed to the method when the button
    receives an **OnClick** event message, as shown here:![How to do it...](img/1362OT_01_31.jpg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**MenuActions**下拉列表中选择**MENU_ACTION_GotoPage()**方法（最初显示**No Function**）。在方法下拉菜单下面的文本框中输入`page2`（当此按钮被点击时我们想要加载的场景的名称）。当按钮接收到**OnClick**事件消息时，此**page2**字符串将被传递给方法，如图所示：![如何操作...](img/1362OT_01_31.jpg)
- en: Save the current scene, create a new empty scene, and then save this new scene
    as **page2**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景，创建一个新的空场景，然后将这个新场景保存为**page2**。
- en: Follow the similar steps for this scene. Add a **UI Text** GameObject, displaying
    the text **Instructions / (page 2)** in a large font size. Add a UI **Button,**
    showing the **goto page 1 text.**
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照类似的步骤进行此场景。添加一个显示**Instructions / (page 2)**文本的**UI Text**游戏对象，字体大小要大。添加一个显示**goto
    page 1 text**的UI **按钮**。
- en: Add the current scene to the build (so now, both **page1** and **page2** will
    be listed in the build).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前场景添加到构建中（因此现在，**page1**和**page2**都将列在构建中）。
- en: Add an instance of `MenuActions` script class to the **Main Camera**.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MenuActions`脚本类的一个实例添加到**主相机**。
- en: Select the **Button** in the **Hierarchy** panel, and add an **On Click** event
    handler, which will pass the **MENU_ACTION_GotoPage()** method the string **page1**
    (the name of the scene we want to be loaded when this button is clicked).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**按钮**，并添加一个**On Click**事件处理器，该处理器将传递字符串**page1**（当此按钮被点击时我们想要加载的场景的名称）给`MENU_ACTION_GotoPage()**方法。
- en: Save the scene.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: When you run the **page1 scene,** you will be presented with your **Main Menu**
    text and a button, which when clicked, makes the game load the **page2 scene**.
    On scene **page2,** you'll have a button to take you back to **page1**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行**page1场景**时，你会看到你的**主菜单**文本和一个按钮，当点击此按钮时，游戏将加载**page2场景**。在场景**page2**中，你将有一个按钮可以带你回到**page1**。
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created two scenes, and added both of them to the game build. Each
    scene has a button, which when clicked (when the game is playing), makes Unity
    load the (named) other scene. This is made possible because when each button is
    clicked, it runs the `MENU_ACTION_GotoPage(…)`method from the scripted `MenuActions`
    component inside the **Main Camera**. This method inputs a text string of the
    name of the scene to be loaded, so that the button in the **page1 scene** gives
    the string name of **page2** as the scene to be loaded, and vice versa.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了两个场景，并将它们都添加到了游戏构建中。每个场景都有一个按钮，当点击（当游戏正在播放时），Unity将加载（命名）其他场景。这是可能的，因为当每个按钮被点击时，它会运行位于**主相机**内部的脚本`MenuActions`组件中的`MENU_ACTION_GotoPage(…)`方法。此方法输入要加载的场景的文本字符串名称，因此**page1场景**中的按钮给出**page2**的字符串名称作为要加载的场景，反之亦然。
- en: When a UI **Button** is added to the **Hierarchy** panel, a child UI **Text**
    object is also automatically created, and the content of the **Text** property
    of this UI **Text** child is the text that the user sees on the button.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个UI **按钮**被添加到**层次结构**面板时，一个子UI **文本**对象也会自动创建，并且这个UI **文本**子对象的**文本**属性内容是用户在按钮上看到的文本。
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不希望错过。
- en: Visual animation for the button mouse-over
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮鼠标悬停的视觉动画
- en: 'There are several ways in which we can visually inform the user that the button
    is interactive when they move their mouse cursor over it. The simplest is to add
    a color tint that will appear when the mouse is over the button—this is the default
    **Transition**. With the **Button** selected in the **Hierarchy**, choose a tint
    color (for example, red), for the **Highlighted Color** property of the **Button
    (Script)** component, in the **Inspector** tab, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以让我们在用户将鼠标光标移到按钮上时，从视觉上告知按钮是交互式的。最简单的是添加一个颜色渐变，当鼠标悬停在按钮上时会出现——这是默认的**Transition**。在**Hierarchy**中选择**Button**后，在**Inspector**选项卡中为**Button
    (Script)**组件的**Highlighted Color**属性选择一个渐变颜色（例如，红色），如图所示：
- en: '![Visual animation for the button mouse-over](img/1362OT_01_33.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![按钮鼠标悬停的视觉动画](img/1362OT_01_33.jpg)'
- en: 'Another form of visual **Transition** to inform the user of an active button
    is **Sprite Swap**. In this case, properties for different images for **Targeted**/**Highlighted**/**Pressed**/**Disabled**
    are available in the **Inspector** tab. The default **Targeted Graphic** is the
    built-in Unity **Button (image)** – this is the grey rounded rectangle default
    when GameObjects buttons are created. Dragging in a very different-looking image
    for the **Highlighted Sprite** is an effective alternative to set a color hint.
    We have provided a `rainbow.png` image with the project for this recipe that can
    be used for the **Button** mouse over **Highlighted Sprite**. The following screenshot
    shows the button with this rainbow background image:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通知用户按钮处于活动状态的可视**Transition**形式是**Sprite Swap**。在这种情况下，**Inspector**选项卡中提供了**Targeted**/**Highlighted**/**Pressed**/**Disabled**不同图像的属性。默认的**Targeted
    Graphic**是内置的Unity **Button (image)** – 这是当GameObject按钮创建时的灰色圆角矩形默认值。将一个看起来非常不同的图像拖入**Highlighted
    Sprite**是一个有效的替代方案来设置颜色提示。我们为这个配方提供了项目中的`rainbow.png`图像，可用于**Button**鼠标悬停时的**Highlighted
    Sprite**。以下截图显示了具有这种彩虹背景图像的按钮：
- en: '![Visual animation for the button mouse-over](img/1362OT_01_34.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![按钮鼠标悬停的视觉动画](img/1362OT_01_34.jpg)'
- en: Animating button properties on mouse over
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在鼠标悬停时动画化按钮属性
- en: 'Finally, animations can be created for dynamically highlighting a button to
    the user, for example, a button might get larger when the mouse is over it, and
    then it might shrink back to its original size when the mouse pointer is moved
    away. These effects are achieved by choosing the **Animation** option for the
    **Transition** property, and by creating an animation controller with triggers
    for the **Normal**, **Highlighted**, **Pressed** and **Disabled** states. To animate
    a button for enlargement when the mouse is over it (the highlighted state), do
    the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以为动态突出显示按钮给用户创建动画，例如，当鼠标悬停在按钮上时，按钮可能会变大，然后当鼠标指针移开时，它可能会缩小回原始大小。这些效果是通过为**Transition**属性的**Animation**选项选择，并创建一个具有**Normal**、**Highlighted**、**Pressed**和**Disabled**状态触发器的动画控制器来实现的。要为鼠标悬停时（高亮状态）的按钮动画放大，请执行以下操作：
- en: Create a new Unity 2D project.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Create a button.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按钮。
- en: In the **Inspector Button (Script)** component, set the **Transition** property
    to **Animation**.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector Button (Script)**组件中，将**Transition**属性设置为**Animation**。
- en: Click the **Auto Generate Animation** button (just below the **Disabled Trigger**
    property) for the **Button (Script)** component, as shown here:![Animating button
    properties on mouse over](img/1362OT_01_41.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Button (Script)**组件中（位于**Disabled Trigger**属性下方）的**Auto Generate Animation**按钮，如图所示：![在鼠标悬停时动画化按钮属性](img/1362OT_01_41.jpg)
- en: Save the new controller by naming it **button-animation-controller**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名为**button-animation-controller**保存新的控制器。
- en: Ensure that the **Button** GameObject is selected in the **Hierarchy**. Then,
    in the **Animation** panel, select the **Highlighted** clip from the drop-down
    menu, as shown here:![Animating button properties on mouse over](img/1362OT_01_42.jpg)
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**Hierarchy**中选择了**Button**GameObject。然后，在**Animation**面板中，从下拉菜单中选择**Highlighted**剪辑，如图所示：![在鼠标悬停时动画化按钮属性](img/1362OT_01_42.jpg)
- en: In the **Animation** panel, click on the red **record** circle button, and then
    click on the **Add Property** button, choosing to record changes to the **Rect
    Transform** | **Scale** property.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Animation**面板中，点击红色的**record**圆形按钮，然后点击**Add Property**按钮，选择记录对**Rect Transform**
    | **Scale**属性的更改。
- en: Two key frames will have been created, delete the second one at **1:00** (since
    we don't want a "bouncing" button), as shown in the following screenshot .![Animating
    button properties on mouse over](img/1362OT_01_43.jpg)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会创建两个关键帧，删除第二个在**1:00**（因为我们不希望有一个“弹跳”按钮），如下面的截图所示。![鼠标悬停时动画按钮属性](img/1362OT_01_43.jpg)
- en: Select the first key frame at **0:00** (the only one now!). Then, in the **Inspector**
    view, set the *X* and *Y* scale properties of the **Rect Transform** component
    to (`1.2`, `1.2`).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**0:00**的第一个关键帧（现在只有一个！）然后，在**检查器**视图中，将**Rect Transform**组件的**X**和**Y**缩放属性设置为（`1.2`，`1.2`）。
- en: Finally, click on the red **record** circle button for the second time to end
    the recording of the animation changes.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次点击红色**记录**圆形按钮以结束动画更改的录制。
- en: Save and run your scene, and you will see that the button smoothly animates
    to get larger when the mouse is over it, and then smoothly returns to its original
    size when the mouse is moved away.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行你的场景，你会看到当鼠标悬停在按钮上时，按钮会平滑地放大，当鼠标移开时，它会平滑地恢复到原始大小。
- en: 'The following web pages offer video and web-based tutorials on UI animations:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下网页提供了关于 UI 动画的视频和基于网页的教程：
- en: 'The Unity button transitions tutorial is available at:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 按钮过渡教程可在以下位置找到：
- en: '[http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions](http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Unity 3D 教程](http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions)'
- en: 'Ray Wenderlich''s tutorial (part 2), including the button animations, is available
    at:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ray Wenderlich 的教程（第 2 部分），包括按钮动画，可在以下位置找到：
- en: '[http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2](http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Unity 新 GUI 教程第 2 部分](http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2)'
- en: Organizing images inside panels and changing panel depths via buttons
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过按钮在面板内组织图像并更改面板深度
- en: UI **Panels** are provided by Unity to allow UI controls to be grouped and moved
    together, and also to visually group elements with an **Image** background (if
    desired). The **sibling depth** is what determines which UI elements will appear
    above or below others. We can see the sibling depth explicitly in the **Hierarchy**,
    since the top-to-bottom sequence of UI GameObjects in the **Hierarchy** sets the
    sibling depth. So, the first item has a depth of 1, the second has a depth of
    2, and so on. The UI GameObjects with larger sibling depths (further down the
    **Hierarchy**) appear above the UI GameObjects with lower sibling depths.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了 UI **面板**，允许将 UI 控件分组并一起移动，并且还可以（如果需要）通过**图像**背景视觉分组。**兄弟深度**决定了哪些
    UI 元素将出现在其他元素之上或之下。我们可以在**层次结构**中明确看到兄弟深度，因为**层次结构**中 UI GameObjects 的从上到下的顺序设置了兄弟深度。因此，第一个项目的深度为
    1，第二个项目的深度为 2，依此类推。具有较大兄弟深度（在**层次结构**中更靠下）的 UI GameObjects 会出现在具有较小兄弟深度（在**层次结构**中更靠上）的
    UI GameObjects 之上。
- en: In this recipe, we'll create three UI panels, each showing a different playing
    card image. We'll also add four triangle arrangement buttons to change the display
    order (move to bottom, move to top, move up one, and move down one).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建三个 UI 面板，每个面板显示不同的扑克牌图像。我们还将添加四个三角形排列按钮来更改显示顺序（移到底部，移到顶部，上移一个，下移一个）。
- en: '![Organizing images inside panels and changing panel depths via buttons](img/1362OT_01_28.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![通过按钮在面板内组织图像和更改面板深度](img/1362OT_01_28.jpg)'
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you need in a folder named
    `Images` in the `1362_01_08` folder.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在 `1362_01_08` 文件夹中的 `Images` 文件夹中准备了所需的图像。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create the UI **Panels** whose layering can be changed by the user-clicking
    buttons, follow these steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户可以通过点击按钮更改层级的 UI **面板**，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: Create a new UI **Panel** named `Panel-jack-diamonds`. Position it in the middle-center
    part of the screen, and size it 200 pixels wide by 300 pixels high. Uncheck the
    **Image (Script)** component for this panel (since we don't want to see the default
    semi-transparent rectangular grey background image of a panel).
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 UI **面板**，命名为 `Panel-jack-diamonds`。将其放置在屏幕中间部分，宽度为 200 像素，高度为 300 像素。取消选中此面板的**图像（脚本）**组件（因为我们不想看到面板的默认半透明灰色矩形背景图像）。
- en: Create a new UI **Image**, and child this image to **Panel-jack-diamonds**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 UI **图像**，并将此图像作为子项添加到 **Panel-jack-diamonds**。
- en: Position the **Panel-jack-diamonds** image at center-middle, and size it to
    200 x 300\. Drag the **Jack-of-diamonds** playing card image into the **Source
    Image** property, for the **Image (Script)** component in the **Inspector** tab.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Panel-jack-diamonds**图像定位在中心中间，并调整其大小为200 x 300。将**Jack-of-diamonds**扑克牌图像拖入**源图像**属性，用于**图像（脚本）**组件在**检查器**选项卡中。
- en: Create a UI **Button** named **Button-move-to-front**. Child this button to
    **Panel-jack-diamonds**. Delete the **Text** child GameObject of this button (since
    we'll use an icon to indicate what this button does).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Button-move-to-front**的UI**按钮**。将此按钮作为子项添加到**Panel-jack-diamonds**。删除此按钮的**Text**子GameObject（因为我们将使用图标来指示此按钮的功能）。
- en: Size the **Button-move-to-front** button to 16 x 16, and position it top-center
    of the player card image, so that it can be seen at the top of the playing card.
    Drag the `icon_move_to_front` arrangement triangle icon image into the **Source
    Image** property, for the **Image (Script)** component, in the **Inspector** view.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Button-move-to-front**按钮的大小调整为16 x 16，并将其定位在玩家卡片图像的顶部中心，以便在扑克牌的顶部可以看到它。将`icon_move_to_front`排列三角形图标图像拖入**源图像**属性，用于**图像（脚本）**组件，在**检查器**视图中。
- en: Ensure that the **Button-move-to-front** button is selected in the **Hierarchy**.
    Then, click on the plus sign (**+**) at the bottom of the **Button (Script)**
    component, in the **Inspector** view to create a new **OnClick** event handler
    for this button.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层级**中选择**Button-move-to-front**按钮。然后，在**检查器**视图中的**Button (Script)**组件底部点击加号（**+**）以为此按钮创建一个新的**OnClick**事件处理程序。
- en: Drag **Panel-jack-diamonds** from the **Hierarchy** over the **Object** slot
    (immediately below the menu saying **Runtime Only**).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Panel-jack-diamonds**从**层级**拖到**对象**槽位（位于说**仅限运行时**的菜单下方）。
- en: Now, select the **RectTransform.SetAsLastSibling** method from the drop-down
    function list (initially showing **No Function**).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从下拉函数列表中选择**RectTransform.SetAsLastSibling**方法（最初显示为**无函数**）。
- en: Note
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This means that when the **Button** receives an **OnClick** event, the **RectTransform**
    of the **Panel** will be sent the **SetAsLastSibling** message – this will move
    the **Panel** to the bottom of the GameObjects in the **Canvas**, and therefore
    will move this **Panel** in front of all other GameObjects in the **Canvas**.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当**按钮**接收到**OnClick**事件时，**Panel**的**RectTransform**将收到**SetAsLastSibling**消息——这将把**Panel**移到**Canvas**中GameObject的底部，因此将这个**Panel**移到**Canvas**中所有其他GameObject的前面。
- en: '![How to do it...](img/1362OT_01_35.jpg)'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/1362OT_01_35.jpg)'
- en: Repeat *step 2*; create a second **Panel** with a move-to-front button. Name
    this second Panel **Panel-2-diamonds**, then move and position it slightly to
    the right of **Panel-jack-diamonds**, allowing both the move-to-front buttons
    to be seen.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*；创建一个带有移至最前按钮的第二个**面板**。将这个第二个面板命名为**Panel-2-diamonds**，然后将其移动并稍微向**Panel-jack-diamonds**的右侧定位，以便两个移至最前按钮都能被看到。
- en: Save your scene and run the game. You will be able to click the move-to-front
    button on either of the cards to move that card's panel to the front. If you run
    the game with the Game panel not maximized, you'll actually see the panels changing
    order in the list of the children of the **Canvas** in the **Hierarchy**.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景并运行游戏。你将能够点击任意一张卡片上的“移至最前”按钮，将那张卡片的面板移至最前。如果你以未最大化的游戏面板运行游戏，你实际上会看到面板在**层级**中**Canvas**的子项列表中的顺序发生变化。
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You've created two UI **Panels**, each panel containing an image of a playing
    card and a button whose action will make its parent panel move to the front. The
    button's action illustrates how the **OnClick** function does not have to be the
    calling of a public method of a scripted component of an object, but it can be
    sending a message to one of the components of the targeted GameObject—in this
    instance we send the **SetAsLastSibling** message to the **RectTransform** of
    the **Panel** in which the **Button** is located.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了两个UI**面板**，每个面板都包含一张扑克牌的图片和一个按钮，该按钮的动作会使其父面板移至最前。按钮的动作说明了**OnClick**函数不必是调用对象脚本组件的公共方法，但它可以向目标GameObject的组件发送消息——在这个例子中，我们向**Panel**中的**RectTransform**发送了**SetAsLastSibling**消息。
- en: There's more...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Moving up or down by just one position, using scripted methods
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用脚本方法仅通过上下移动一个位置
- en: 'While the Rect Transform offers a useful **SetAsLastSibling** (move to front)
    and **SetAsFirstSibling** (move to back), and even **SetSiblingIndex** (if we
    knew exactly what position in the sequence to type in), there isn''t a built-in
    way to make an element move up or down, just a single position in the sequence
    of GameObjects in the **Hierarchy** panel. However, we can write two straightforward
    methods in C# to do this, and we can add buttons to call these methods, providing
    full control of the top-to-bottom arrangement of the UI controls on the screen.
    To implement four buttons (move-to-front/move-to-back/up one/down one), do the
    following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **Rect Transform** 提供了有用的 **SetAsLastSibling**（移动到前面）和 **SetAsFirstSibling**（移动到后面），以及
    **SetSiblingIndex**（如果我们知道确切的位置），但在 **层次** 面板中并没有内置的方法来使元素上下移动，只有一个在 GameObject
    序列中的单个位置。然而，我们可以用 C# 编写两个简单的方法来实现这一点，并且我们可以添加按钮来调用这些方法，从而提供对屏幕上 UI 控件从上到下排列的完全控制。要实现四个按钮（移动到前面/移动到后面/上移一个/下移一个），请执行以下操作：
- en: 'Create a C# script class called `ArrangeActions`, containing the following
    code, and add an instance as a scripted component to each of your **Panels**:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ArrangeActions` 的 C# 脚本类，包含以下代码，并将其作为脚本组件添加到每个 **面板** 上：
- en: '[PRE5]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add a second button to each card panel, this time, using the arrangement triangle
    icon image called `icon_move_to_front`, and set the **OnClick** event function
    for these buttons to **SetAsFirstSibling**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个卡片面板上添加第二个按钮，这次使用名为 `icon_move_to_front` 的排列三角形图标图像，并将这些按钮的 **OnClick** 事件函数设置为
    **SetAsFirstSibling**。
- en: 'Add two further buttons to each card panel with the up and down triangle icon
    images: `icon_down_one` and `icon_up_one`. Set the **OnClick** event handler function
    for the down-one buttons to call the `MoveDownOne()` method, and set the functions
    for the up-one buttons to call the `MoveUpOne()` method.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个卡片面板上添加两个带有上下三角形图标图像的按钮：`icon_down_one` 和 `icon_up_one`。将下移一个按钮的 **OnClick**
    事件处理函数设置为调用 `MoveDownOne()` 方法，并将上移一个按钮的函数设置为调用 `MoveUpOne()` 方法。
- en: Copy one of the panels to create a third card (this time showing the Ace of
    diamonds). Arrange the three cards so that you can see all four buttons for at
    least two of the cards, even when those cards are at the bottom (see the screenshot
    at the beginning of this recipe).
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制一个面板以创建第三个卡片（这次显示方块 A）。排列三个卡片，以便至少可以看到两张卡片的所有四个按钮，即使这些卡片在底部（参见本食谱开头的截图）。
- en: Save the scene and run your game. You will now have full control over the layering
    of the three card panels.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并运行你的游戏。现在你将完全控制三个卡片面板的分层。
- en: Displaying the value of an interactive UI Slider
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示交互式 UI 滑块的值
- en: This recipe illustrates how to create an interactive UI **Slider**, and execute
    a C# method each time the user changes the **Slider value**.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例说明如何创建一个交互式 UI **滑块**，并在用户更改 **滑块值** 时执行 C# 方法。
- en: '![Displaying the value of an interactive UI Slider](img/1362OT_01_08.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![显示交互式 UI 滑块的值](img/1362OT_01_08.jpg)'
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a UI Slider and display its value on the screen, follow these steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 UI 滑块并在屏幕上显示其值，请按照以下步骤操作：
- en: Create a new 2D project.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 2D 项目。
- en: Add a UI Text GameObject to the scene with a Font size of `30` and placeholder
    text such as `slider value here` (this text will be replaced with the slider value
    when the scene starts).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个 UI 文本 GameObject，字体大小为 `30`，占位文本为 `slider value here`（当场景开始时，此文本将被滑块值替换）。
- en: 'In the **Hierarchy** panel, add a **UI** | **Slider** game object to the scene—choose
    the menu: **GameObject** | **UI** | **Slider**.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次** 面板中，将一个 **UI** | **滑块** 游戏对象添加到场景中——选择菜单：**GameObject** | **UI** |
    **滑块**。
- en: In the **Inspector** tab, modify settings for the **Rect Transform** to position
    the slider on the top-middle part of the screen and the text just below it.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 选项卡中，修改 **Rect Transform** 的设置以将滑块放置在屏幕的顶部中间部分，并将文本放置在其下方。
- en: In the **Inspector** tab, set the **Min Value** of the slider to `0`, the **Max
    Value** to `20`, and check the **Whole Numbers** checkbox, as shown here:![How
    to do it...](img/1362OT_01_09.jpg)
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 选项卡中，将滑块的 **最小值** 设置为 `0`，**最大值** 设置为 `20`，并勾选 **整数** 复选框，如图所示：![如何操作...](img/1362OT_01_09.jpg)
- en: 'Create a C# script class called `SliderValueToText`, containing the following
    code, and add an instance as a scripted component to the GameObject called **Text**:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SliderValueToText` 的 C# 脚本类，包含以下代码，并将其作为脚本组件添加到名为 **Text** 的 GameObject
    上：
- en: '[PRE6]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ensure that the **Text** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector** view, drag the **Slider** GameObject into the public **Slider
    UI** variable slot for the `Slider Value To Text (Script)` scripted component,
    as shown here:![How to do it...](img/1362OT_01_12.jpg)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了**文本**GameObject。然后，在**检查器**视图中，将**滑块**GameObject拖动到`Slider Value
    To Text (Script)`脚本组件的公共**Slider UI**变量槽中，如图所示：![如何操作...](img/1362OT_01_12.jpg)
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector** view, drag the **Text** GameObject into the public **None
    (Object)** slot for the **Slider (Script)** scripted component, in the section
    for **On Value Changed (Single)**.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了**滑块**GameObject。然后，在**检查器**视图中，将**文本**GameObject拖动到**滑块（脚本）**脚本组件的公共**None
    (Object)**槽中，位于**On Value Changed (Single)**部分。
- en: Note
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You have now told Unity to which object a message should be sent each time the
    slider is changed.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在已经告诉Unity每次滑块改变时应该向哪个对象发送消息。
- en: '![How to do it...](img/1362OT_01_11.jpg)'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1362OT_01_11.jpg)'
- en: From the drop-down menu, select **SliderValueToText** and the `ShowSliderValue()`
    method, as shown in the following screenshot. This means that each time the slider
    is updated, the `ShowSliderValue()`method, in the scripted object, in GameObject
    **Text** will be executed.![How to do it...](img/1362OT_01_10.jpg)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**SliderValueToText**和`ShowSliderValue()`方法，如图所示。这意味着每次滑块更新时，脚本对象中的`ShowSliderValue()`方法，在GameObject
    **文本**中将被执行。![如何操作...](img/1362OT_01_10.jpg)
- en: When you run the scene, you will now see a slider. Below it, you will see a
    text message in the `Slider value = <n>` form.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行场景时，你现在会看到一个滑块。在其下方，你会看到一个`Slider value = <n>`形式的文本消息。
- en: Each time the slider is moved, the text value shown will be (almost) instantly
    updated. The values should range from `0` (the leftmost of the slider) to `20`
    (the rightmost of the slider).
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次移动滑块时，显示的文本值将（几乎）立即更新。值应从`0`（滑块的左侧）到`20`（滑块的右侧）。
- en: Note
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The update of the text value on the screen probably won't be instantaneous,
    as in happening in the same frame as the slider value is moved, since there is
    some computation involved in the slider deciding that an **On Value Changed**
    event message needs to be triggered, and then looking up any methods of objects
    that are registered as event handlers for such an event. Then, the statements
    in the object's method need to be executed in sequence. However, this should all
    happen within a few milliseconds, and should be sufficiently fast enough to offer
    the user a satisifyingly responsive UI for interface actions such as changing
    and moving this slider.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 屏幕上文本值的更新可能不会立即发生，就像滑块值移动时发生的那样，因为滑块在决定需要触发**On Value Changed**事件消息时涉及一些计算，然后查找已注册为该事件处理程序的对象的任何方法。然后，需要按顺序执行对象方法中的语句。然而，这一切都应该在几毫秒内完成，并且应该足够快，以便为用户界面操作如改变和移动此滑块提供令人满意的响应性UI。
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You have added to the **Text** GameObject a scripted instance of the `SliderValueToText`
    class.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为**文本**GameObject添加了`SliderValueToText`类的脚本实例。
- en: The `Start()` method, which is executed when the scene first runs, sets the
    variable to be a reference to the **Text** component inside the **Slider** item.
    Next, the `ShowSliderValue()` method is called, so that the display is correct
    when the scene begins (the initial slider value is displayed).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景首次运行时，会执行`Start()`方法，将变量设置为对**滑块**项内**文本**组件的引用。接下来，会调用`ShowSliderValue()`方法，以确保场景开始时显示正确（显示初始滑块值）。
- en: 'This contains the `ShowSliderValue()` method, which gets the value of the slider.
    It updates the text displayed to be a message in the form: `Slider value = <n>`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含`ShowSliderValue()`方法，它获取滑块的值。它更新显示的文本，使其成为以下形式的消息：`Slider value = <n>`。
- en: You created a **UI Slider** GameObject, and set it to be whole numbers in the
    0-20 range.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个**UI滑块**GameObject，并将其设置为0-20范围内的整数。
- en: You added to the **UI Slider** GameObject's list of **On Value Changed** event
    listeners the `ShowSliderValue()` method of the `SliderValueToText` scripted component.
    So, each time the slider value changes, it sends a message to call the `ShowSliderValue()`
    method, and so the new value is updated on the screen.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将`SliderValueToText`脚本组件的`ShowSliderValue()`方法添加到**UI滑块**GameObject的**On
    Value Changed**事件监听器列表中。因此，每次滑块值改变时，它会发送一个消息来调用`ShowSliderValue()`方法，因此新的值会在屏幕上更新。
- en: Displaying a countdown timer graphically with a UI Slider
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI滑块图形显示倒计时器
- en: There are many cases where we wish to inform the player of the proportion of
    time remaining, or at the completion of some value at a point in time, for example,
    a loading progress bar, the time or health remaining compared to the starting
    maximum, how much the player has filled up their water bottle from the fountain
    of youth, and so on. In this recipe, we'll illustrate how to remove the interactive
    'handle' of a **UI Slider**, and change the size and color of its components to
    provide us with an easy-to-use, general purpose progress/proportion bar. In this
    recipe, we'll use our modified slider to graphically present to the user how much
    time remains for a countdown timer.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况，我们希望通知玩家剩余时间的比例，或在某个时间点的某些值完成时，例如，加载进度条，剩余时间或健康与起始最大值的比较，玩家从青春之泉中填充了多少水壶，等等。在此配方中，我们将说明如何移除**UI滑块**的交互式'手柄'，并更改其组件的大小和颜色，以便我们有一个易于使用的通用进度/比例条。在此配方中，我们将使用修改后的滑块以图形方式向用户展示倒计时器剩余的时间。
- en: '![Displaying a countdown timer graphically with a UI Slider](img/1362OT_01_18.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![使用UI滑块图形显示倒计时器](img/1362OT_01_18.jpg)'
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy to follow this recipe.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于之前的配方进行修改。因此，请复制之前配方中的项目，并在此基础上工作以遵循此配方。
- en: For this recipe, we have prepared the script and images that you need in the
    folders named `Scripts` and `Images` in the `1362_01_10` folder.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，我们在`1362_01_10`文件夹中的`Scripts`和`Images`文件夹中准备了所需的脚本和图像。
- en: How to do it...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a digital countdown timer with a graphical display, follow these
    steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个带有图形显示的数字倒计时器，请按照以下步骤操作：
- en: Delete the **Text** GameObject.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**文本**GameObject。
- en: Import the `CountdownTimer` script and the `red_square` and `green_square` images
    to this project.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CountdownTimer`脚本和`red_square`、`green_square`图像导入到项目中。
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy** tab.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**标签中选择了**滑块**GameObject。
- en: Deactivate the **Handle Slide Area** child GameObject (by unchecking it)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用**手柄滑动区域**子GameObject（通过取消选中它）
- en: You'll see the "drag circle" disappear in the **Game** panel (the user will
    not be dragging the slider, since we want this slider to be display-only), as
    shown in the following screenshot:![How to do it...](img/1362OT_01_17.jpg)
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在**游戏**面板中看到“拖动圆圈”消失（用户不会拖动滑块，因为我们希望这个滑块仅用于显示），如下面的截图所示：![如何操作...](img/1362OT_01_17.jpg)
- en: 'Select the **Background** child:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**背景**子项：
- en: Drag the `red_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector** view
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`red_square`图像拖动到**图像（脚本）组件**的**源图像**属性中，该组件位于**检查器**视图中
- en: 'Select the **Fill** child:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**填充**子项：
- en: Drag the `green_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector** tab
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`green_square`图像拖动到**图像（脚本）组件**的**源图像**属性中，该组件位于**检查器**标签页
- en: 'Select the **Fill Area** child:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**填充区域**子项：
- en: In the **Rect Transform** component, use the **Anchors** preset position of
    **left-middle**
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**矩形变换**组件中，使用**锚点**预设位置为**左中**
- en: 'Set **Width** to 155 and **Height** to 12, as shown here:'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**宽度**设置为155，将**高度**设置为12，如图所示：
- en: '![How to do it...](img/1362OT_01_19.jpg)'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1362OT_01_19.jpg)'
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy**. Then,
    attach an instance of C# script class called `CountdownTimer` as a component of
    this GameObject.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了**滑块**GameObject。然后，将名为`CountdownTimer`的C#脚本类实例作为组件附加到此GameObject。
- en: 'Create a C# script class called `SliderTimerDisplay` containing the following
    code, and add an instance as a scripted component to the **Slider** GameObject:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SliderTimerDisplay`的C#脚本类，包含以下代码，并将其作为脚本组件添加到**滑块**GameObject中：
- en: '[PRE7]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run your game and you will see the slider move with each second, revealing more
    and more of the red background to indicate the time remaining.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的游戏，你会看到滑块每秒移动，逐渐显示更多的红色背景，以此表示剩余时间。
- en: How it works...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You hid the **Handle Slide Area** child so that **Slider** is for display only,
    and cannot be interacted with by the user. The **Background** color of the **Slider**
    was set to red, so that, as the counter goes down, more and more red is revealed—warning
    the user that the time is running out. The **Fill** of the **Slider** was set
    to green, so that the proportion remaining is displayed in green (the more green
    it becomes, the larger the value of the slider/timer).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你隐藏了**Handle Slide Area**子组件，使得**Slider**仅用于显示，用户无法与之交互。**Slider**的**背景**颜色设置为红色，因此，随着计数器的下降，越来越多的红色被揭示——警告用户时间正在流逝。**Slider**的**填充**设置为绿色，以便剩余的比例以绿色显示（绿色越多，滑块/计时器的值就越大）。
- en: An instance of the provided `CountdownTimer` script class was added as a component
    to the Slider. The `ResetTimer(…)` method records the number of seconds provided
    and the time the method was called. The `GetProportionRemaining()` method returns
    a value from 0.0-1.0, representing the proportion of the seconds remaining (1.0
    being all seconds, 0.5 half the seconds, and 0.0 meaning that no seconds are left).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供的`CountdownTimer`脚本类的一个实例添加为滑块的组件。`ResetTimer(…)`方法记录提供的秒数和方法被调用的时间。`GetProportionRemaining()`方法返回一个0.0-1.0之间的值，表示剩余秒数的比例（1.0代表所有秒数，0.5代表一半秒数，0.0表示没有剩余秒数）。
- en: You have added to the **Slider** GameObject an instance of the `SliderTimerDisplay`
    scripted class. The `Start()` method calls the `SetupSlider()` and `SetupTimer()`
    methods.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你在**Slider**GameObject中添加了`SliderTimerDisplay`脚本类的一个实例。`Start()`方法调用`SetupSlider()`和`SetupTimer()`方法。
- en: The `SetupSlider()` method sets the `sliderUI` variable to be a reference to
    the **Slider** component, and sets up this slider mapped to float (decimal) values
    between `0.0` and `1.0`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupSlider()`方法将`sliderUI`变量设置为对**Slider**组件的引用，并设置此滑块映射到0.0和1.0之间的浮点（小数）值。'
- en: The `SetupTimer()` method sets the `countdownTimer` variable to be a reference
    for the **CountdownTimer** component, and starts this timer scripted component
    to count down from 30 seconds.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupTimer()`方法将`countdownTimer`变量设置为**CountdownTimer**组件的引用，并启动此计时器脚本组件从30秒开始倒计时。'
- en: In each frame, the `Update()`method sets the slider value to the float returned
    by calling the `GetProportionRemaining()`method from the running timer.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，`Update()`方法将滑块值设置为从运行计时器中调用`GetProportionRemaining()`方法返回的浮点数。
- en: Note
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Try to work with floats between 0.0-1.0 whenever possible.**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽可能在0.0-1.0之间使用浮点数。**'
- en: Integers could have been used, setting the Slider min to 0 and max to 30 (for
    30 seconds). However, changing the total number of seconds would then also require
    the Slider settings to be changed. In most cases working with a float proportion
    between 0.0 and 1.0 is the more general-purpose and reusable approach to adopt.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 整数也可以使用，将滑块的最低值设置为0，最高值设置为30（代表30秒）。然而，改变总秒数时，也需要相应地更改滑块的设置。在大多数情况下，使用0.0到1.0之间的浮点比例是更通用和可重用的方法。
- en: Displaying a radar to indicate the relative locations of objects
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示雷达以指示物体的相对位置
- en: A radar displays the locations of other objects relative to the player, usually
    based on a circular display, where the center represents the player, and each
    graphical 'blip' indicates how far away and what relative direction objects are
    to the player. Sophisticated radar displays will display different categories
    of objects with different colored or shaped 'blip' icons.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达显示其他物体相对于玩家的位置，通常基于圆形显示，其中中心代表玩家，每个图形“亮点”表示物体距离玩家有多远以及相对方向。复杂的雷达显示将以不同颜色或形状的“亮点”图标显示不同类别的物体。
- en: In the screenshot, we can see 2 red square 'blips', indicating the relative
    position of the 2 red cube GameObjects tagged `Cube` near the player, and a yellow
    circle 'blip' indicating the relative position of the yellow sphere GameObject
    tagged `Sphere`. The green circle radar background image gives the impression
    of an aircraft control tower radar or something similar.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中，我们可以看到2个红色的正方形“亮点”，指示玩家附近的2个标记为`Cube`的红色立方体GameObject的相对位置，以及一个黄色的圆形“亮点”指示标记为`Sphere`的黄色球体GameObject的相对位置。绿色的圆形雷达背景图像给人一种飞机控制塔雷达或类似的感觉。
- en: '![Displaying a radar to indicate the relative locations of objects](img/1362OT_01_21.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![显示雷达以指示物体的相对位置](img/1362OT_01_21.jpg)'
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you need in a folder named
    `Images` in `1362_01_11`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_01_11`目录下的`Images`文件夹中准备了所需的图像。
- en: How to do it...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a radar to show the relative positions of the objects, follow these
    steps:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个雷达以显示对象的相对位置，请按照以下步骤操作：
- en: 'Create a new 3D project by importing the following standard assets:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导入以下标准资产创建一个新的3D项目：
- en: '**Environment**'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**'
- en: '**Characters**'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**'
- en: '**Cameras**'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**'
- en: Create a terrain by navigating to the **Create** | **3D Object** | **Terrain**
    menu.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**创建** | **3D对象** | **地形**菜单创建地形。
- en: Size the terrain 20 x 20, positioned at (-10, 0, -10)—so that its center is
    at (0, 0, 0), as shown in the following figure:![How to do it...](img/1362OT_01_47.jpg)
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地形设置为20 x 20，放置在(-10, 0, -10)的位置——这样其中心就在(0, 0, 0)，如图所示：![如何操作...](img/1362OT_01_47.jpg)
- en: Texture paint your terrain with the **SandAlbedo** option, as shown here:![How
    to do it...](img/1362OT_01_48.jpg)
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**SandAlbedo**选项对地形进行纹理绘制，如图所示：![如何操作...](img/1362OT_01_48.jpg)
- en: From the **Standard Assets** folder in the **Project** panel, drag the prefab
    **ThirdPersonController** into the scene and position it at (0, 1, 0).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板中的**标准资产**文件夹，将预制件**ThirdPersonController**拖动到场景中，并将其放置在(0, 1, 0)的位置。
- en: Tag this **ThirdPersonController** GameObject called **Player**.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记名为**Player**的**ThirdPersonController** GameObject。
- en: Remove the **Main Camera** GameObject.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**主相机** GameObject。
- en: From the **Standard Assets** folder in the **Project** panel, drag the prefab
    **Multi-PurposeCameraRig** into the scene.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板中的**标准资产**文件夹，将预制件**Multi-PurposeCameraRig**拖动到场景中。
- en: With **Multi-PurposeCameraRig** selected in the **Hierarchy**, drag the **ThirdPersonController**
    GameObject into the **Target** property of the **Auto Cam (Script)** public variable
    in the **Inspector** tab, as shown in the following screenshot:![How to do it...](img/1362OT_01_22.jpg)
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择**Multi-PurposeCameraRig**，将**ThirdPersonController** GameObject拖动到**检查器**选项卡中**Auto
    Cam (Script)**公共变量的**目标**属性中，如图所示：![如何操作...](img/1362OT_01_22.jpg)
- en: Import the provided folder known as `Images`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的名为`Images`的文件夹。
- en: In the **Hierarchy** panel, add a **UI** | **RawImage** GameObject to the scene
    named **RawImage-radar**.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，将名为**RawImage-radar**的**UI** | **原始图像** GameObject添加到场景中。
- en: Ensure that the **RawImage-radar** GameObject is selected in the **Hierarchy**
    panel. From your **Project** `Images` folder, drag the `radarBackground` image
    into the **Raw Image (Script)** public property **Texture**.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次**面板中选择了**RawImage-radar** GameObject。从你的**项目** `Images` 文件夹中，将 `radarBackground`
    图像拖动到**原始图像（脚本）**公共属性**纹理**中。
- en: Now, in **Rect Transform** position **RawImage-radar** at the top-left part
    using the **Anchor Presets** item. Then set the width and height to 200 pixels.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用**锚点预设**项将**Rect Transform**中的**RawImage-radar**放置在左上角。然后设置宽度和高度为200像素。
- en: Create another new UI **RawImage** named **RawImage-blip**. Assign the `yellowCircleBlackBorder`
    texture. Tag the **Blip** GameObject.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新的 UI **原始图像**，命名为**RawImage-blip**。分配 `yellowCircleBlackBorder` 纹理。标记**Blip**
    GameObject。
- en: In the **Project** panel, create a new empty prefab named **blip-sphere**, and
    drag the **RawImage-blip** GameObject into this prefab to store all its properties.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，创建一个名为**blip-sphere**的新空预制件，并将**RawImage-blip** GameObject拖动到这个预制件中以存储所有其属性。
- en: Now, change the texture of **RawImage-blip** to `redSquareBlackBorder`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将**RawImage-blip**的纹理更改为`redSquareBlackBorder`。
- en: In the Project panel, create a new empty prefab named **blip-cube**, and drag
    the **RawImage-blip** GameObject into this prefab to store all its properties.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，创建一个名为**blip-cube**的新空预制件，并将**RawImage-blip** GameObject拖动到这个预制件中以存储所有其属性。
- en: Delete the **RawImage-blip** GameObject from the **Hierarchy** panel.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次**面板中删除**RawImage-blip** GameObject。
- en: 'Create a C# script class called `Radar,` containing the following code, and
    add an instance as a scripted component to the **RawImage-radar** GameObject:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Radar`的C#脚本类，包含以下代码，并将其作为脚本组件添加到**RawImage-radar** GameObject中：
- en: '[PRE8]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create two cubes—tagged **Cube**, textured with a red image called **icon32_square_red**.
    Position each away from the player's character.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个标记为**Cube**的立方体，使用名为**icon32_square_red**的红色图像进行纹理处理。将每个立方体放置在玩家角色的远离位置。
- en: Create a sphere—tagged **Sphere**, textured with a red image called **icon32_square_yellow**.
    Position this away from the cubes and the player's character.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个标记为**Sphere**的球体，使用名为**icon32_square_yellow**的红色图像进行纹理处理。将这个球体放置在立方体和玩家角色的远离位置。
- en: Run your game. You will see two red squares and one yellow circle on the radar,
    showing the relative positions of the red cubes and yellow sphere. If you move
    too far away, then the blips will disappear.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的游戏。你将在雷达上看到两个红色方块和一个黄色圆圈，显示红色立方体和黄色球体的相对位置。如果你移动得太远，那么这些标记将会消失。
- en: Note
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This radar script scans 360 degrees all around the player, and only considers
    straight line distances in the X-Z plane. So, the distances in this radar are
    not affected by any height difference between the player and target GameObjects.
    The script can be adapted to ignore targets whose height is more than some threshold
    different to the player's height. Also, as presented, this recipe radar *sees*
    through everything, even if there are obstacles between the player and the target.
    The recipe can be extended to not show obscured targets through the user of the
    ray-casting techniques. See the Unity scripting reference for more details about
    ray-casting at [http://docs.unity3d.com/ScriptReference/Physics.Raycast.html](http://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个雷达脚本扫描玩家周围360度的所有区域，并且只考虑X-Z平面的直线距离。因此，这个雷达中的距离不受玩家和目标GameObject之间任何高度差异的影响。该脚本可以被修改以忽略高度超过玩家高度阈值的目标。此外，正如所展示的，这个雷达配方*可以看到*一切，即使玩家和目标之间存在障碍。该配方可以通过使用射线投射技术来扩展，以不显示被遮挡的目标。有关射线投射的更多详细信息，请参阅Unity脚本参考[http://docs.unity3d.com/ScriptReference/Physics.Raycast.html](http://docs.unity3d.com/ScriptReference/Physics.Raycast.html)。
- en: How it works...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A radar background is displayed on the screen. The center of this circular image
    represents the position of the player's character. You have created two prefabs;
    one for red square images to represent each red cube found within the radar distance,
    and one for yellow circles to represent yellow sphere GameObjects.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示雷达背景。这个圆形图像的中心代表玩家角色的位置。你已经创建了两个预制体；一个用于代表雷达距离内找到的每个红色立方体的红色方形图像，另一个用于代表黄色球体的黄色圆形GameObject。
- en: 'The `Radar` C# script class has been added to the radar UI Image GameObject.
    This class defines four public variables:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`Radar` C# 脚本类已被添加到雷达UI Image GameObject中。这个类定义了四个公共变量：'
- en: '`insideRadarDistance`: This value defines the maximum distance that an object
    may be from the player to still be included on the radar (objects further than
    this distance will not be displayed on the radar).'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insideRadarDistance`：此值定义了一个对象可能离玩家的最大距离，仍然可以包含在雷达上（距离超过此距离的对象将不会在雷达上显示）。'
- en: '`blipSizePercentage`: This public variable allows the developer to decide how
    large each ''blip'' will be, as a proportion of the radar''s image.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blipSizePercentage`：这个公共变量允许开发者决定每个''标记''的大小，作为雷达图像的比例。'
- en: '`rawImageBlipCube` and `rawImageBlipSphere`: These are references to the prefab
    UI **RawImages** that are to be used to visually indicate the relative distance
    and position of cubes and spheres on the radar.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rawImageBlipCube` 和 `rawImageBlipSphere`：这些是对要用于在雷达上视觉表示立方体和球体相对距离和位置的预制UI
    **RawImages** 的引用。'
- en: Since there is a lot happening in the code for this recipe, each method will
    be described in its own section.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个配方中的代码有很多操作，每个方法将在自己的部分中进行描述。
- en: The Start() method
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Start() 方法
- en: The `Start()` method caches a reference to the **Transform** component of the
    player's character (tagged as **Player**). This allows the scripted object to
    know about the position of the Player's character in each frame. Next, the width
    and height of the radar image are cached—so, the relative positions for 'blips'
    can be calculated, based on the size of this background radar image. Finally,
    the size of each blip (width and height) is calculated, using the `blipSizePercentage`
    public variable.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法缓存了玩家角色（标记为 **Player**）的 **Transform** 组件的引用。这允许脚本对象知道玩家角色在每个帧中的位置。接下来，缓存雷达图像的宽度和高度——因此，可以根据这个背景雷达图像的大小计算''标记''的相对位置。最后，使用
    `blipSizePercentage` 公共变量计算每个标记的大小（宽度和高度）。'
- en: The Update() method
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Update() 方法
- en: The `Update()` method calls the `RemoveAllBlips()` method, which removes any
    old **RawImage** UI GameObjects of cubes and spheres that might currently be displayed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法调用 `RemoveAllBlips()` 方法，该方法移除任何可能当前显示的立方体和球体的旧 **RawImage** UI
    GameObjects。'
- en: Next, the `FindAndDisplayBlipsForTag(…)`method is called twice. First, for the
    objects tagged **Cube**, to be represented on the radar with the `rawImageBlipCube`
    prefab and then again for objects tagged **Sphere**, to be represented on the
    radar with the `rawImageBlipSphere` prefab. As you might expect, most of the hard
    work for the radar is to be performed by the `FindAndDisplayBlipsForTag(…)` method.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`FindAndDisplayBlipsForTag(…)`方法两次。首先，为了在雷达上用`rawImageBlipCube`预制体表示的标签为**Cube**的对象，然后再次为标签为**Sphere**的对象，用`rawImageBlipSphere`预制体在雷达上表示。正如你所预期的那样，雷达的大部分工作将由`FindAndDisplayBlipsForTag(…)`方法来完成。
- en: The FindAndDisplayBlipsForTag(…) method
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`FindAndDisplayBlipsForTag(…)`方法'
- en: 'This method inputs two parameters: the string tag for the objects to be searched
    for; and a reference to the **RawImage** prefab to be displayed on the radar for
    any such tagged objects within the range.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法输入两个参数：要搜索的对象的字符串标签；以及要在雷达上显示的**RawImage**预制体的引用，用于任何此类标签对象在范围内。
- en: 'First, the current position of the player''s character is retrieved from the
    cached player transform variable. Next, an array is constructed, referring to
    all GameObjects in the scene that have the provided tag. This array of GameObjects
    is looped through, and for each GameObject, the following actions are performed:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从缓存的玩家变换变量中检索玩家角色的当前位置。接下来，构建一个数组，引用场景中所有具有提供标签的GameObject。这个GameObject数组被遍历，并对每个GameObject执行以下操作：
- en: The position of the target GameObject is retrieved
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取目标GameObject的位置
- en: 'The distance from this target position to the player''s position is calculated,
    and if this distance is within the range (less than or equal to `insideRadarDistance`),
    then three steps are now required to get the blip for this object to appear on
    the radar:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算从目标位置到玩家位置的距离，如果这个距离在范围内（小于或等于`insideRadarDistance`），那么现在需要三个步骤来使此对象的blip出现在雷达上：
- en: The normalized position of the target is calculated by calling `NormalisedPosition(…)`
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`NormalisedPosition(…)`计算目标的标准化位置
- en: The position of the blip on the radar is then calculated from this normalized
    position by calling `CalculateBlipPosition(…)`
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后通过调用`CalculateBlipPosition(…)`从这个标准化位置计算出雷达上blip的位置
- en: Finally, the **RawImage** blip is displayed by calling `DrawBlip(…)` and passing
    the blip position and the reference to the **RawImage** prefab that is to be created
    there
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过调用`DrawBlip(…)`并传递blip位置以及要创建的**RawImage**预制体的引用来显示**RawImage** blip
- en: The NormalisedPosition(…) method
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`NormalisedPosition(…)`方法'
- en: The `NormalisedPosition(…)` method inputs the player's character position and
    the target GameObject position. It has the goal of outputting the relative position
    of the target to the player, returning a Vector3 object with a triplet of *X*,
    *Y*, and *Z* values. Note that since the radar is only 2D, we ignore the *Y*value
    of target GameObjects. So, the *Y*value of the Vector3 object returned by this
    method will always be 0\. So, for example, if a target was at exactly the same
    location as the player, the returned *X*, *Y*, *Z* Vector3 object would be (0,
    0, 0).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalisedPosition(…)`方法输入玩家的角色位置和目标GameObject的位置。它的目标是输出目标相对于玩家的相对位置，返回一个包含*X*、*Y*和*Z*值的Vector3对象。请注意，由于雷达是2D的，我们忽略目标GameObject的*Y*值。因此，此方法返回的Vector3对象的*Y*值始终为0。例如，如果目标与玩家位于完全相同的位置，返回的*X*、*Y*、*Z*
    Vector3对象将是(0, 0, 0)。'
- en: Since we know that the target GameObject is no further from the player's character
    than `insideRadarDistance`, we can calculate a value in the -1 … 0 … +1 range
    for the *X* and *Z* axis by finding the distance on each axis from the target
    to the player, and then dividing it by `insideRadarDistance`. An *X* value of
    -1 means that the target is fully to the left of the player (at a distance that
    is equal to `insideRadarDistance`), and +1 means it is fully to the right. A value
    of 0 means that the target has the same *X* position as the player's character.
    Likewise, for -1 … 0 … +1 values in the *Z-axis* (this axis represents how far,
    in front or behind us an object, is located, which will be mapped to the vertical
    axis in our radar).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道目标GameObject距离玩家角色不超过`insideRadarDistance`，我们可以通过找到每个轴上从目标到玩家的距离，然后除以`insideRadarDistance`来计算*X*和*Z*轴的-1…0…+1范围内的值。*X*值为-1表示目标完全在玩家的左侧（距离等于`insideRadarDistance`），+1表示它完全在右侧。0值表示目标具有与玩家角色相同的*X*位置。同样，对于*Z轴*的-1…0…+1值（这个轴表示一个物体在我们前方或后方有多远，这将在我们的雷达中映射到垂直轴）。
- en: Finally, this method constructs and returns a new Vector3 object, with the calculated
    *X* and *Z* normalized values, and a *Y* value of zero.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个方法构建并返回一个新的Vector3对象，包含计算出的*X*和*Z*归一化值，以及*Y*值为零。
- en: Note
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The normalized position**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化位置**'
- en: A *normalized* value is one that has been simplified in some way, so the context
    has been abstracted away. In this recipe, what we are interested in is where an
    object is relative to the player. So, our normal form is to get a value of the
    *X* and *Z* position of a target in the -1 to +1 range for each axis. Since we
    are only considering GameObject within out `insideRadarDistance` value, we can
    map these normalized target positions directly onto the location of the radar
    image in our UI.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*归一化*的值是指以某种方式简化过的值，因此上下文已经被抽象化。在这个菜谱中，我们感兴趣的是对象相对于玩家的位置。因此，我们的常规做法是获取目标在-1到+1范围内的每个轴的*X*和*Z*位置值。由于我们只考虑`insideRadarDistance`值内的GameObject，我们可以直接将这些归一化的目标位置映射到UI中雷达图像的位置。
- en: The CalculateBlipPosition(…) method
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`CalculateBlipPosition(…)`方法'
- en: 'First, we calculate `angleToTarget`: the angle from (0, 0, 0) to our normalized
    target position.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算`angleToTarget`：从(0, 0, 0)到我们的归一化目标位置的角度。
- en: 'Next, we calculate `anglePlayer`: the angle the player''s character is facing.
    This recipe makes use of the **yaw** angle of the rotation, which is the rotation
    about the *Y-axis*—that is, the direction that a character controller is facing.
    This can be found in the *Y* component of a GameObject''s `eulerAngles` component
    of its transform. You can imagine looking from above and down at the character
    controller, and see what direction they are facing—this is just what we are trying
    to display graphically with the compass.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算`anglePlayer`：玩家角色面向的角度。这个菜谱使用了旋转的**偏航**角度，这是围绕*Y轴*的旋转——也就是说，角色控制器面向的方向。这可以在GameObject的transform组件的`eulerAngles`组件的*Y*分量中找到。你可以想象从上方向下看角色控制器，看看他们面向的方向——这正是我们试图用指南针图形显示的内容。
- en: Our desired radar angle (the `angleRadarDegrees` variable) is calculated by
    subtracting the player's direction angle from the angle between target and player,
    since a radar displays the relative angle from the direction that the player is
    facing, to the target object. In mathematics, an angle of zero indicates an *east*
    direction. To correct this, we need to also subtract 90 degrees from the angle.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的雷达角度（`angleRadarDegrees`变量）是通过从目标与玩家之间的角度中减去玩家的方向角度来计算的，因为雷达显示的是玩家面向的方向与目标对象之间的相对角度。在数学上，零角度表示*东方*方向。为了纠正这一点，我们还需要从角度中减去90度。
- en: 'The angle is then converted into radians, since this is required for the Unity
    trigonometry methods. We then multiply the `Sin()` and `Cos()` results by our
    normalized distances to calculate the *X* and *Y* values respectively (see the
    following figure):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 角度随后被转换为弧度，因为这是Unity三角函数方法所必需的。然后我们将`Sin()`和`Cos()`的结果乘以我们的归一化距离，分别计算出*X*和*Y*值（见下图）：
- en: '![The CalculateBlipPosition(…) method](img/1362OT_01_46.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![The CalculateBlipPosition(…) method](img/1362OT_01_46.jpg)'
- en: Our final position values need to be expressed as pixel lengths, relative to
    the center of the radar. So, we multiply our `blipX` and `blipY` values by half
    the width and the height of the radar; note that we multiply only with half the
    width, since these values are relative to the center of the radar.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的定位值需要以像素长度表示，相对于雷达的中心。因此，我们将 `blipX` 和 `blipY` 值乘以雷达宽度的一半和高度的一半；注意我们只乘以宽度的一半，因为这些值是相对于雷达中心的。
- en: Note
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: In this figure, alpha is the angle between player and target object,
    ''a'' is the adjacent side, ''h'' is the hypotenuse and ''o'' is the side opposite
    the angle.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在此图中，alpha 是玩家与目标对象之间的角度，'a' 是邻边，'h' 是斜边，'o' 是对边。
- en: We then add half the width and height of the radar image to the `blipX`/`Y`
    values. So, these values are now positioned relative to the center.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将雷达图像宽度的一半和高度的一半添加到 `blipX`/`Y` 值中。因此，这些值现在是相对于中心的定位。
- en: Finally a new **Vector2** object is created and returned, passing back these
    final calculated *X* and *Y* pixel values for the position of our blip icon.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后创建了一个新的 **Vector2** 对象并返回，传递回这些最终计算出的 *X* 和 *Y* 像素值，用于我们 blip 图标的定位。
- en: The DrawBlip() method
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DrawBlip()` 方法'
- en: The `DrawBlip()` method takes the input parameters of the position of the blip
    (as a `Vector2` *X*, *Y* pair), and the reference to the **RawImage** prefab to
    be created at that location on the radar.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawBlip()` 方法接受 blip 定位（作为一个 `Vector2` *X*，*Y* 对）的输入参数，以及要在雷达上该位置创建的 **RawImage**
    预制件的引用。'
- en: A new GameObject is created from the prefab, and is parented to the radar GameObject
    (of which the scripted object is also a component). A reference is retrieved to
    the **Rect Transform** of the new **RawImage** GameObject that has been created
    for the 'blip'. Calls to the Unity **RectTransform** method, `SetInsetAndSizeFromParentEdge(…),`
    result in the blip GameObject being positioned at the provided horizontal and
    vertical locations over the radar image, regardless of where in the **Game** panel
    the background radar image has been located.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 从预制件创建一个新的 GameObject，并将其作为父对象添加到雷达 GameObject（其中脚本对象也是一个组件）。检索到为 'blip' 创建的新
    **RawImage** GameObject 的 **Rect Transform** 引用。调用 Unity **RectTransform** 方法
    `SetInsetAndSizeFromParentEdge(…)`，结果是将 blip GameObject 定位在雷达图像上提供的水平和垂直位置，无论背景雷达图像在
    **游戏** 面板中的位置如何。
- en: Creating UIs with the Fungus open-source dialog system
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Fungus 开源对话框系统创建 UI
- en: Rather than constructing your own UI and interactions from scratch each time,
    there are plenty of UI and dialogue systems available for Unity. One powerful,
    free, and open source dialog system is called **Fungus**, which uses a visual
    flowcharting approach to dialog design.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都从头开始构建自己的 UI 和交互，Unity 中有很多 UI 和对话框系统可供选择。一个强大、免费且开源的对话框系统叫做 **Fungus**，它使用可视流程图方法进行对话框设计。
- en: In this recipe, we'll create a very simple, two-sentence dialogue, to illustrate
    the basics of Fungus. The following screenshot shows the Fungus-generated dialog
    for the first sentence ('**Hello, how are you**') and the interactive button (a
    triangle inside a circle) the user clicks to progress to the next piece of dialog
    (in the bottom-right part of the rectangle).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个非常简单的、两句话的对话，以说明 Fungus 的基本原理。以下截图显示了 Fungus 生成的第一句话（'**你好，你好吗**'）和用户点击以进入下一部分对话的交互按钮（一个圆圈内的三角形）（位于矩形的右下角）。
- en: '![Creating UIs with the Fungus open-source dialog system](img/1362OT_01_23.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Fungus 开源对话框系统创建 UI](img/1362OT_01_23.jpg)'
- en: How to do it...
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a two-sentence dialog using Fungus, follow these steps:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Fungus 创建两句话的对话，请按照以下步骤操作：
- en: Download the latest version of the Fungus **unitypackage** from the FungusGames
    website [http://www.fungusgames.com/](http://www.fungusgames.com/).
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 FungusGames 网站下载 Fungus 的最新版本 **unitypackage** [http://www.fungusgames.com/](http://www.fungusgames.com/)。
- en: Create a new Unity 2D project.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: Import the Fungus **unitypackage** by navigating to **Assets** | **Import Package**
    | **Custom Package...**, and then navigating to your downloaded file location.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **资产** | **导入包** | **自定义包...** 导入 Fungus **unitypackage**，然后导航到您下载的文件位置。
- en: 'Create a new Fungus **Flowchart** GameObject by choosing menu: **Tools** |
    **Fungus** | **Create** | **Flowchart**.'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：**工具** | **Fungus** | **创建** | **流程图**来创建一个新的 Fungus **流程图**GameObject。
- en: 'Display and dock the Fungus **Flowchart** window panel by choosing menu: **Tools**
    | **Fungus** | **Flowchart Window**.'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：**工具** | **Fungus** | **流程图窗口**来显示和停靠 Fungus **流程图**窗口面板。
- en: There will be a block in the **Flowchart** Window. Click on this block to select
    it (a green border appears around the block to indicate that it is selected),
    and then in the **Inspector** panel, change the name of this block to **Start**,
    as shown in the following screenshot:![How to do it...](img/1362OT_01_24.jpg)
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**流程图窗口**中会有一个块。点击此块以选择它（块周围出现绿色边框以指示已选择），然后在**检查器**面板中，将此块的名字改为**Start**，如图所示：![如何操作...](img/1362OT_01_24.jpg)
- en: Each **Block** in a Flowchart follows a sequence of commands. So, we are now
    going to create a sequence of commands to display two sentences to the user when
    the game runs.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流程图中的每个**块**都遵循一系列命令。因此，我们现在将创建一系列命令，以便在游戏运行时向用户显示两句话。
- en: Note
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sequence of **Commands** in a **Block**
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**块**中的**命令**序列'
- en: Each **Block** in a **Flowchart** follows a sequence of **Commands**, so to
    display two sentences to the user when the game runs, we need to create a sequence
    of two **Say** commands in the **Inspector** panel properties for our **Block**.
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流程图中的每个**块**都遵循一系列**命令**，所以当游戏运行时向用户显示两句话，我们需要在**检查器**面板的**块**属性中创建两个**说**命令的序列。
- en: Ensure that the **Start** block is still selected in the **Flowchart** panel.
    Now, click on the plus **+**' button at the bottom section of the **Inspector**
    panel to display the menu of **Commands**, and select the **Narrative** | **Say**
    command, as shown here:![How to do it...](img/1362OT_01_25.jpg)
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**流程图**面板中仍然选择了**Start**块。现在，点击**检查器**面板底部部分的加号**+**按钮以显示**命令**菜单，并选择**叙事**|**说**命令，如图所示：![如何操作...](img/1362OT_01_25.jpg)
- en: 'Since we only have one command for this block, that command will automatically
    be selected (highlighted green) in the top-half part of the **Inspector** view.
    The bottom half of the **Inspector** view presents the properties for the currently
    selected **Command**, as shown in the following screenshot. In the bottom-half
    part of the **Inspector** view, for the **Story Text** property, enter the text
    of the question that you wish to be presented to the user: `How are you today?`![How
    to do it...](img/1362OT_01_26.jpg)'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只为这个块有一个命令，因此该命令将自动在**检查器**视图的上半部分选中（高亮绿色）。**检查器**视图的下半部分显示当前选定的**命令**的属性，如图所示。在**检查器**视图的下半部分，对于**故事文本**属性，输入你想展示给用户的文本：`你今天怎么样？`![如何操作...](img/1362OT_01_26.jpg)
- en: 'Now, create another **Say Command**, and type the following for its **Story
    Text** property: `Very well thank you.`'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个**说命令**，并在其**故事文本**属性中输入以下内容：`非常好，谢谢。`
- en: 'When you run the game, the user will first be presented with the **How are
    you today?** text (hearing a clicking noise as each letter is *typed* on screen).
    After the user clicks on the ''continue'' triangle button (at the bottom-right
    part of the dialog window), they will then be presented with the second sentence:
    **Very well thank you.**'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行游戏时，用户首先会看到**你今天怎么样？**的文本（随着每个字母在屏幕上**输入**时，会听到点击声）。在用户点击对话框窗口右下角的'继续'三角形按钮后，他们将会看到第二句话：**非常好，谢谢**。
- en: How it works...
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created a new Unity project, and imported the Fungus asset package,
    containing the Fungus Unity menus, windows and commands, and also the example
    projects.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个新的Unity项目，并导入了Fungus资产包，其中包含Fungus Unity菜单、窗口和命令，以及示例项目。
- en: You have added a **Fungus Flowchart** to your scene with a single **Block**
    that you have named **Start**. Your block starts to execute when the game begins
    (since the default for the first block is to be executed upon receiving the **Game
    Started** event).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将一个名为**Start**的单个**Fungus 流程图**添加到场景中。当游戏开始时，你的块开始执行（因为第一个块的默认行为是在接收到**游戏开始**事件时执行）。
- en: In the **Start** block, you added a sequence of two **Say Commands**. Each command
    presents a sentence to the user, and then waits for the continue button to be
    clicked before proceeding to the next **Command**.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Start**块中，你添加了一系列两个**说命令**。每个命令向用户展示一句话，然后等待用户点击继续按钮，然后再进行到下一个**命令**。
- en: 'As can be seen, the Fungus system handles the work of creating a nicely presented
    panel to the user, displaying the desired text and continue button. Fungus offers
    many more features, including menus, animations, control of sounds and music,
    and so on, details of which can be found by exploring their provided example projects,
    and their websites:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，Fungus系统处理创建一个用户界面良好的面板的工作，显示所需的文本和继续按钮。Fungus提供许多其他功能，包括菜单、动画、声音和音乐的控件等，更多详细信息可以通过探索他们提供的示例项目和网站找到：
- en: '[http://fungusgames.com/](http://fungusgames.com/)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://fungusgames.com/](http://fungusgames.com/)'
- en: '[https://github.com/FungusGames/Fungus](https://github.com/FungusGames/Fungus)'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/FungusGames/Fungus](https://github.com/FungusGames/Fungus)'
- en: Setting custom mouse cursor images
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义鼠标光标图像
- en: 'Cursor icons are often used to indicate the nature of the interaction that
    can be done with the mouse. Zooming, for instance, might be illustrated by a magnifying
    glass. Shooting, on the other hand, is usually represented by a stylized target.
    In this recipe, we will learn how to implement custom mouse cursor icons to better
    illustrate your gameplay—or just to escape the Windows, OSX, and Linux default
    GUI. The following screenshot shows a custom magnifying glass mouse cursor when
    the use''s mouse pointer hovers over a **Button**:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 光标图标通常用于指示可以使用鼠标进行的交互性质。例如，缩放可能通过放大镜来表示。另一方面，射击通常由一个风格化的靶子表示。在本教程中，我们将学习如何实现自定义鼠标光标图标，以更好地说明您的游戏玩法——或者只是逃离Windows、OSX和Linux的默认GUI。以下截图显示了当用户的鼠标指针悬停在**按钮**上时，自定义放大镜鼠标光标：
- en: '![Setting custom mouse cursor images](img/1362OT_01_32.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![设置自定义鼠标光标图像](img/1362OT_01_32.jpg)'
- en: Getting ready
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you'll need in a folder named
    `IconsCursors` in the `1362_01_13` folder.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们在`1362_01_13`文件夹中的`IconsCursors`文件夹中准备了您需要的图像。
- en: How to do it...
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make a custom cursor appear when the mouse is over a GameObject, follow
    these steps:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 要在鼠标悬停在GameObject上时显示自定义光标，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Add a **Directional Light** item to the scene by navigating to **Create** |
    **Light** | **Directional light**.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**创建** | **灯光** | **方向光**，向场景中添加一个**方向光**项目。
- en: Add a 3D **Cube** to the scene, scaled to (5, 5, 5). Because it was created
    as a 2D project the cube will appear as a grey square in the **Game** panel (2D
    projects have an orthographic camera, so we won't see perspective effects).
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向场景中添加一个缩放为(5, 5, 5)的3D**Cube**。由于它是一个2D项目创建的，立方体将在**游戏**面板中显示为一个灰色正方形（2D项目具有正交相机，因此我们不会看到透视效果）。
- en: Import the provided folder called `IconsCursors`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入名为`IconsCursors`的提供文件夹。
- en: Tip
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ensure that each image in this folder has been imported as **Texture Type Cursor**.
    If they are not, then select this type for each image and click on the **Apply**
    button in the **Inspector** view.
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保这个文件夹中的每个图像都已导入为**纹理类型光标**。如果不是，则为每个图像选择此类型，并在**检查器**视图中单击**应用**按钮。
- en: 'Create a C# script class called `CustomCursorPointer`, containing the following
    code, and add an instance as a scripted component to the **Cube** GameObject:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomCursorPointer`的C#脚本类，包含以下代码，并将其作为脚本组件添加到**Cube**GameObject实例中：
- en: '[PRE9]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Event methods `OnMouseEnter()` and `OnMouseExit()` have been purposely declared
    as `public`. This will allow these methods to also be called from UI GameObjects
    when they receive the `OnPointerEnterExit` events.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 故事方法`OnMouseEnter()`和`OnMouseExit()`已被故意声明为`public`。这将允许这些方法在它们接收到`OnPointerEnterExit`事件时也能从UI
    GameObject中被调用。
- en: With the **Cube** item selected in the **Hierarchy** panel, drag the `CursorTarget`
    image into the public **Cursor Texture 2D** variable slot in the **Inspector**
    panel for the **Customer Cursor Pointer (Script)** component.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择**Cube**项目，将`CursorTarget`图像拖动到**检查器**面板中**Customer Cursor Pointer
    (Script)**组件的公共**Cursor Texture 2D**变量槽中。
- en: Save the current scene, and add it to the **Build**.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景，并将其添加到**构建**中。
- en: Tip
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will not be able to see the custom cursors in the Unity Editor. You must
    build your game application, and you'll see the custom cursors when you run the
    build app.
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您在Unity编辑器中看不到自定义光标。您必须构建您的游戏应用程序，当您运行构建的应用程序时，您将看到自定义光标。
- en: Build your project. Now, run your built application, and when the mouse pointer
    moves over the grey square of the **Cube**, it will change to the custom `CursorTarget`
    image that you chose.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您的项目。现在，运行您构建的应用程序，当鼠标指针移动到**Cube**的灰色正方形上时，它将更改为您选择的自定义`CursorTarget`图像。
- en: How it works...
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have added a scripted object to a cube that will tell Unity to change the
    mouse pointer when an **OnMouseEnter** message is received—that is, when the user's
    mouse pointer moves over the part of the screen where the cube is being rendered.
    When an **OnMouseExit** event is received (the users mouse pointer is no longer
    over the cube part of the screen), the system is told to go back to the operating
    system default cursor. This event should be received within a few milliseconds
    of the user's mouse exiting from the collider.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将一个脚本对象添加到一个立方体上，这将告诉Unity在接收到**OnMouseEnter**消息时更改鼠标指针——也就是说，当用户的鼠标指针移动到正在渲染立方体的屏幕部分时。当接收到**OnMouseExit**事件（用户的鼠标指针不再位于屏幕的立方体部分）时，系统会被告知返回到操作系统默认光标。此事件应在用户鼠标从碰撞器退出后的几毫秒内接收到。
- en: There's more...
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节您不容错过。
- en: Custom cursors for mouse over UI controls
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标悬停在UI控件上的自定义光标
- en: 'Unity 5 UI controls do not receive the **OnMouseEnter** and **OnMouseExit**
    events. They can respond to the **PointerEnter/Exit** events, but this requires
    adding the **Event Trigger** components. To change the mouse pointer when the
    mouse moves over a UI element, do the following:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5 UI控件不接收**OnMouseEnter**和**OnMouseExit**事件。它们可以响应**PointerEnter/Exit**事件，但这需要添加**事件触发器**组件。要更改鼠标指针在鼠标悬停在UI元素上时，请执行以下操作：
- en: Add a UI **Button** to the scene.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个UI**按钮**添加到场景中。
- en: Add an instance of the C# script class called `CustomCursorPointer` to the button.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`CustomCursorPointer`的C#脚本类的一个实例添加到按钮中。
- en: With **Button** selected in the **Hierarchy panel**, drag the `CursorZoom` image
    into the public **Cursor Texture 2D** variable slot in the **Inspector** panel
    for the **Customer Cursor Pointer (Script)** component.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构面板**中选择**按钮**，将`CursorZoom`图像拖放到**检查器**面板中**Customer Cursor Pointer (Script)**组件的公共**Cursor
    Texture 2D**变量槽中。
- en: 'In the **Inspector** view**,** add an **Event Triggers** component to the **Button**.
    Choose menu: **Add Component** | **Event** | **Event Trigger**.'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，将一个**事件触发器**组件添加到**按钮**上。选择菜单：**添加组件** | **事件** | **事件触发器**。
- en: Add a **Pointer Enter** event to your **Event Trigger** component, click on
    the plus (**+**) button to add an event handler slot, and drag the **Button**
    GameObject into the **Object** slot.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**事件触发器**组件中添加一个**指针进入**事件，点击加号（**+**）按钮以添加事件处理器槽，并将**按钮**游戏对象拖放到**对象**槽中。
- en: From the **Function** drop-down menu, choose **CustomCursorPointer** and then
    choose the **OnMouseEnter** method.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**函数**下拉菜单中选择**CustomCursorPointer**，然后选择**OnMouseEnter**方法。
- en: Note
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have added an Event Handler so that when the **Button** receives a **Pointer
    Enter** (mouse over) event, it will execute the **OnMouseEnter()** method of the
    **CustomCursorPointer** scripted object inside the **Button**.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已添加一个事件处理器，以便当**按钮**接收到**指针进入**（鼠标悬停）事件时，它将执行**按钮**内部**CustomCursorPointer**脚本对象的**OnMouseEnter()**方法。
- en: Add a **Pointer Exit** event to your **Event Trigger** component, and make it
    call the `OnMouseExit()`method from **CustomCursorPointer** when this event is
    received.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**事件触发器**组件中添加一个**指针退出**事件，并在接收到此事件时调用**CustomCursorPointer**中的`OnMouseExit()`方法。
- en: Save the current scene.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景。
- en: Build your project. Now, run your built application and when the mouse pointer
    moves over the **Button,** it will change to the custom `CursorZoom` image that
    you chose.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您的项目。现在，运行您构建的应用程序，当鼠标指针移动到**按钮**上时，它将更改为您选择的自定义`CursorZoom`图像。
- en: Input Fields component for text entry
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本输入字段组件
- en: While many times we just wish to display non-interactive text messages to the
    user, there are times (such as name entry for high scores) where we wish that
    the user was able to enter text or numbers into our game. Unity provides the **Input
    Field** UI component for this purpose. In this recipe, we'll create a simple text
    input UI by making use of the default Button image and text GameObjects, and we'll
    add a script to respond to each new value of the input field.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很多时候我们只想向用户显示非交互式文本消息，但有时（如输入高分时的名字）我们希望用户能够将文本或数字输入到我们的游戏中。Unity提供了**输入字段**UI组件来实现此目的。在本配方中，我们将通过使用默认按钮图像和文本游戏对象来创建一个简单的文本输入UI，并将添加一个脚本以响应输入字段的每个新值。
- en: Note
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can, of course, create a working text input quicker than this recipe''s
    method by choosing menu: **Create | UI | Input Field**, which creates a GameObject
    containing an Input Field component, child text, and placeholder GameObjects,
    as shown in the following screenshot. However, by following the steps in this
    recipe, you''ll learn the interrelationships between the different interface elements,
    because you''ll be creating these connections manually from the deconstructed
    parts of the UI Button GameObject.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过选择菜单：**创建 | UI | 输入字段**来更快地创建一个工作的文本输入，这将创建一个包含输入字段组件、子文本和占位符游戏对象的GameObject，如图下截图所示。然而，通过遵循本食谱中的步骤，您将了解不同界面元素之间的相互关系，因为您将手动从UI按钮游戏对象的拆解部分创建这些连接。
- en: '![Input Fields component for text entry](img/1362OT_01_37.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![文本输入字段组件](img/1362OT_01_37.jpg)'
- en: How to do it...
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a promoted text input box to the user with faint placeholder text,
    follow these steps:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 要为用户创建一个带有淡色占位符文本的推广文本输入框，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: In the **Inspector** view, change the background of the **Main Camera** to solid
    white.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，将**主摄像机**的背景更改为纯白色。
- en: Add a **UI Button** to the scene. Delete the **Button (Script)** component of
    the **Button** GameObject (since it won't be a button, it will be an interactive
    text input by the time we are finished with it!).
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向场景中添加一个**UI按钮**。删除**按钮**GameObject的**按钮（脚本）**组件（因为它将不是一个按钮，在我们完成它的时候，它将是一个交互式文本输入！）。
- en: Rename the **Text** child GameObject of the **Button** component to **Text-placeholder**.
    Uncheck the **Rich Text** option, change the text to **Enter name…**, change the
    **Alignment** in **Left** and **Top**, and in the **Rect Transform**, set **Left**
    to `4` and **Top** to `7`.![How to do it...](img/1362OT_01_38.jpg)
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**按钮**组件的**文本**子GameObject重命名为**文本占位符**。取消选择**富文本**选项，将文本更改为**输入名称…**，在**左**和**顶**中更改**对齐**，并在**矩形变换**中设置**左**为`4`和**顶**为`7`。![如何操作...](img/1362OT_01_38.jpg)
- en: Duplicate **Text-placeholder by** naming the copy **Text-prompt**. Change the
    **Text** of this GameObject to **Name:**, and set its **Left** position to `-50`.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名副本为**文本提示**来复制**文本占位符**。将此GameObject的**文本**更改为**名称**，并将其**左**位置设置为`-50`。
- en: Duplicate **Text-placeholder** again, naming this new copy **Text-input**. Delete
    all of the content of the **Text** property of this new GameObject.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次复制**文本占位符**，将新副本命名为**文本输入**。删除此新GameObject的**文本**属性中的所有内容。
- en: Select **Text-placeholder** in the **Hierarchy,** and we will now make the placeholder
    text mostly transparent. Set the **A** (alpha) **Color** value of the **Text (Script)**
    component of this GameObject to a value that is about a quarter of its maximum
    value (e.g. 64).
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**文本占位符**，现在我们将占位符文本设置为大部分透明。将此GameObject的**文本（脚本）**组件的**A（alpha）颜色**值设置为最大值的约四分之一（例如，64）。
- en: 'Select **Text-input** in the **Hierarchy,** and add an **Input Field** component
    by choosing menu: **Add Component** | **UI** | **Input Field**.'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**文本输入**，并通过选择菜单：**添加组件** | **UI** | **输入字段**来添加一个**输入字段**组件。
- en: Drag the **Text-input** GameObject into the **Text Component** property of **Input
    Field**, and drag the **Text-placeholder** GameObject into the **Placeholder**
    property.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**文本输入**GameObject拖动到**输入字段**的**文本组件**属性中，并将**文本占位符**GameObject拖动到**占位符**属性中。
- en: Save and run your scene. You now have a working text input UI for your user.
    When there is no text content, the faint placeholder text will be displayed. As
    soon as any characters have been typed, the placeholder will be hidden and the
    characters typed will appear in black text. Then, if all the characters are deleted,
    the placeholder will appear again.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行您的场景。现在您有一个为用户工作的文本输入UI。当没有文本内容时，将显示淡色占位符文本。一旦输入了任何字符，占位符将被隐藏，输入的字符将以黑色文本显示。然后，如果删除所有字符，占位符将再次出现。
- en: How it works...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core of interactive text input in Unity is the responsibility of the **Input
    Field** component. This needs a reference to a UI **Text** GameObject. To make
    it easier to see where the text can be typed, we have made use of the default
    rounded rectangle image that Unity provides when a **Button** GameObject is created.
    **Buttons** have both an **Image** component and a **Text** child GameObject.
    So, two items that we need can be acquired very easily by creating a new **Button,**
    and simply by removing the **Button (Script)** component.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中交互式文本输入的核心责任在于 **Input Field** 组件。这需要一个对 UI **Text** GameObject 的引用。为了更容易地看到可以输入文本的位置，我们使用了
    Unity 在创建 **Button** GameObject 时提供的默认圆角矩形图像。**Buttons** 具有图像组件和 **Text** 子 GameObject。因此，通过创建一个新的
    **Button** 并简单地移除 **Button (Script)** 组件，我们可以非常容易地获得所需的两个项目。
- en: 'There are usually three **Text** GameObjects involved with the user text input:
    the static prompt text (in our recipe, for example, the **Name:** text); then
    the faint placeholder text, reminding users where and what they should type; and
    finally the text object (with the font and color settings and so on) that is actually
    displayed to the user, showing the characters as they type.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 通常涉及三个 **Text** GameObject 与用户文本输入相关：静态提示文本（例如，在我们的配方中，**Name:** 文本）；然后是微弱的占位符文本，提醒用户在哪里以及应该输入什么；最后是实际显示给用户的文本对象（具有字体和颜色设置等），显示用户输入的字符。
- en: At runtime, a **Text-Input Input Caret** GameObject is created—displaying the
    blinking vertical line to inform the user where their next letter will be typed.
    Note that the **Content Type** of the **Input Field (Script)**, in the **Inspector**,
    can be set to several specific types of text input, including e-mail addresses,
    integer or decimal numbers only, or the password text (where an asterisk is displayed
    for each entered character).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，会创建一个 **Text-Input Input Caret** GameObject——显示闪烁的垂直线以告知用户下一个字母将被输入的位置。请注意，在
    **Inspector** 中的 **Input Field (Script)** 的 **Content Type** 可以设置为几种特定的文本输入类型，包括电子邮件地址、仅整数或小数，或密码文本（每个输入字符都会显示一个星号）。
- en: There's more...
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Executing a C# method to respond each time the user changes the input text content
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 C# 方法以响应用户更改输入文本内容
- en: Having interactive text on the screen isn't of much use unless we can retrieve
    the text entered to use in our game logic, and we may need to know each time the
    user changes the text content and act accordingly.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们能检索到用户输入的文本以用于游戏逻辑，否则屏幕上的交互式文本并没有太大的用处，我们可能还需要知道每次用户更改文本内容时的情况，并据此采取行动。
- en: 'To add code and events to respond each time the text content has been changed
    by the user, do the following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加代码和事件以响应用户每次更改文本内容的情况，请执行以下操作：
- en: 'Add an instance of the C# script class called `DisplayChangedTextContent` to
    the **Text-input** GameObject:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `DisplayChangedTextContent` 的 C# 脚本类实例添加到 **Text-input** GameObject 中：
- en: '[PRE10]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add an **End Edit (String)** event to the list of event handlers for the **Input
    Field (Script)** component. Click on the plus (**+**) button to add an event handler
    slot, and drag the **Text-input** GameObject into the **Object** slot.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **End Edit (String)** 事件添加到 **Input Field (Script)** 组件的事件处理程序列表中。点击加号 (**+**)
    按钮以添加事件处理程序槽位，并将 **Text-input** GameObject 拖动到 **Object** 槽位中。
- en: From the **Function** drop-down menu, choose **DisplayChangedTextContent** and
    then choose the **PrintNewValue** method.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Function** 下拉菜单中选择 **DisplayChangedTextContent**，然后选择 **PrintNewValue**
    方法。
- en: Save and run the scene. Each time the user types in new text and then presses
    *Tab* or *Enter*, the **End Edit** event will fire, and you'll see a new content
    text message printed in the **Console** window by our script, as shown in the
    following screenshot:![Executing a C# method to respond each time the user changes
    the input text content](img/1362OT_01_36.jpg)
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行场景。每次用户输入新文本然后按下 *Tab* 或 *Enter* 键时，**End Edit** 事件将被触发，你将看到我们的脚本在 **Console**
    窗口中打印出新的内容文本消息，如下面的截图所示：![执行 C# 方法以响应用户更改输入文本内容](img/1362OT_01_36.jpg)
- en: Toggles and radio buttons via Toggle Groups
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Toggle Groups 使用开关和单选按钮
- en: Users make choices, and often, these choices are either to have one of two available
    options (for example, sound on or off), or sometimes to choose one of several
    possibilities (for example, difficulty level easy/medium/hard). Unity UI **Toggles**
    allows users to turn options on and off; and when combined with **Toggle Groups**,
    they restrict choices to one of the group of items. In this recipe, we'll first
    explore the basic **Toggle**, and a script to respond to a change in values. Then
    in the *There's More* section, we'll extend the example to illustrate **Toggle
    Groups**, and styling these with round images to make them look more like traditional
    radio buttons.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 用户做出选择，通常这些选择要么是两个可用选项之一（例如，声音开或关），有时则是从几个可能性中选择一个（例如，难度级别简单/中等/困难）。Unity UI
    **Toggle**允许用户开启或关闭选项；当与**Toggle Groups**结合使用时，它们将选择限制在项目组中的一个。在本食谱中，我们将首先探索基本的**Toggle**，以及一个响应值变化的脚本。然后在*更多内容*部分，我们将扩展示例以说明**Toggle
    Groups**，并使用圆形图像进行样式化，使其看起来更像传统的单选按钮。
- en: 'The following screenshot shows how the button''s status changes are logged
    in the **Console** panel when the scene is running:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当场景运行时，按钮状态变化在**控制台**面板中的记录情况：
- en: '![Toggles and radio buttons via Toggle Groups](img/1362OT_01_39.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![通过Toggle Groups的Toggle和单选按钮](img/1362OT_01_39.jpg)'
- en: Getting ready
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you'll need in a folder named
    `UI Demo Textures` in the `1362_01_15` folder.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_01_15`文件夹中的`UI Demo Textures`文件夹中准备了你需要使用的图像。
- en: How to do it...
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display an on/off UI Toggle to the user, follow these steps:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 要向用户显示开/关UI Toggle，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: In the **Inspector** panel, change the **Background** color of the **Main Camera**
    to white.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，将**主摄像机**的**背景**颜色更改为白色。
- en: Add **UI Toggle** to the scene.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UI Toggle**添加到场景中。
- en: Enter `First Class` as **Text** for the **Label** child GameObject of the **Toggle**
    GameObject.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Toggle** GameObject的**Label**子GameObject的**文本**设置为`First Class`。
- en: 'Add an instance of the C# script class called `ToggleChangeManager` to the
    **Toggle** GameObject:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`ToggleChangeManager`的C#脚本类实例添加到**Toggle** GameObject中：
- en: '[PRE11]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the **Toggle** GameObject selected, add an **On Value Changed** event to
    the list of event handlers for the **Toggle (Script)** component, click on the
    plus (+) button to add an event handler slot, and drag **Toggle** into the **Object**
    slot.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Toggle** GameObject后，将**On Value Changed**事件添加到**Toggle (Script)**组件的事件处理器列表中，点击加号（+）按钮添加事件处理器槽位，并将**Toggle**拖入**对象**槽位。
- en: From the **Function** drop-down menu, choose **ToggleChangeManager** and then
    choose the **PrintNewToggleValue** method.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**功能**下拉菜单中选择**ToggleChangeManager**，然后选择**PrintNewToggleValue**方法。
- en: Save and run the scene. Each time you check or uncheck the **Toggle** GameObject,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the Console window by our script, stating the new Boolean true/false value
    of the **Toggle**.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行场景。每次检查或取消检查**Toggle** GameObject时，**On Value Changed**事件都会触发，你将看到我们的脚本在控制台窗口中打印出新的布尔值（true/false）的文本消息。
- en: How it works...
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you create a Unity UI **Toggle** GameObject, it comes with several child
    GameObjects automatically—**Background**, **Checkmark**, and the text **Label**.
    Unless we need to style the look of a **Toggle** in a special way, all that is
    needed is simply to edit the text **Label** so that the user knows what option
    or feature that this **Toggle** is going to turn on/off.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个Unity UI **Toggle** GameObject时，它将自动包含几个子GameObject——**背景**、**勾选标记**和文本**标签**。除非我们需要以特殊方式样式化**Toggle**的外观，否则只需要简单地编辑文本**标签**，以便用户知道这个**Toggle**将要开启/关闭哪个选项或功能。
- en: The C# scripted class called `ToggleChangeManager's` method called `Start()`
    gets a reference to the **Toggle** component in the GameObject, where the script
    instance is located. When the game is running, each time the user clicks on the
    **Toggle** to change its value, an **On Value Changed** event is fired. We then
    register the `PrintNewToggleValue()`method, which is supposed to be executed when
    such an event occurs. This method retrieves, and then prints out to the **Console**
    panel the new Boolean true/false value of the **Toggle**.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`ToggleChangeManager`的C#脚本类的方法`Start()`获取位于脚本实例所在游戏对象的**Toggle**组件的引用。当游戏运行时，每次用户点击**Toggle**以更改其值时，都会触发一个**On
    Value Changed**事件。我们随后注册`PrintNewToggleValue()`方法，该方法将在此类事件发生时执行。此方法检索，然后打印到**Console**面板的**Toggle**的新布尔值（真/假）。
- en: There's more...
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不应该错过。
- en: Adding more Toggles and a Toggle Group to implement mutually-exclusive radio
    buttons
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加更多Toggle和一个Toggle Group以实现互斥单选按钮
- en: 'The Unity UI **Toggles** are also the base components, if we wish to implement
    a group of mutually-exclusive options in the style of radio buttons. To create
    such a group of related choices, do the following:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI **Toggle**也是基础组件，如果我们希望以单选按钮的风格实现一组互斥选项，可以这样做：
- en: Import the `UI Demo Textures` folder into the project.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UI Demo Textures`文件夹导入到项目中。
- en: Remove the C# script class `ToggleChangeManager` component from the **Toggle**
    GameObject.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Toggle**游戏对象中移除C#脚本类`ToggleChangeManager`组件。
- en: Rename the **Toggle** GameObject as **Toggle-easy**.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Toggle**游戏对象重命名为**Toggle-easy**。
- en: Change the **Label** text to **Easy**, and tag this GameObject with a new tag
    called **Easy**.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Label**文本更改为**Easy**，并给这个游戏对象添加一个名为**Easy**的新标签。
- en: Select the **Background** child GameObject of **Toggle-easy**, and in the **Image
    (Script)** component, drag the `UIToggleBG` image into the **Source Image** property.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Toggle-easy**的**Background**子游戏对象，在**Image (Script)**组件中，将`UIToggleBG`图像拖动到**Source
    Image**属性。
- en: Ensure that the **Is On** property of the **Toggle (Script)** component is checked,
    and then select the **Checkmark** child GameObject of **Toggle-easy**. In the
    **Image (Script)** component, drag the `UIToggleButton` image into the **Source
    Image** property.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**Toggle (Script)**组件的**Is On**属性被勾选，然后选择**Toggle-easy**的**Checkmark**子游戏对象。在**Image
    (Script)**组件中，将`UIToggleButton`图像拖动到**Source Image**属性。
- en: Note
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of the three choices (easy, medium, and hard) that we'll offer to the user,
    we'll set the easy option to be the one that is supposed to be initially selected.
    Therefore, we need its **Is On** property to be checked, which will lead to its
    'checkmark' image being displayed.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们提供给用户的三个选项（简单、中等和困难）中，我们将简单选项设置为默认选中项。因此，我们需要将其**Is On**属性勾选，这将导致其“勾选”图像显示。
- en: To make these **Toggles** look more like radio buttons, the background of each
    is set to the circle image of `UIToggleBG`, and the checkmark (which displays
    the **Toggles** that are on) is filled with the circle image called `UIToggleButton`.
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使这些**Toggle**看起来更像单选按钮，每个的背景都设置为`UIToggleBG`的圆形图像，而勾选标记（显示开启的**Toggle**）则填充了名为`UIToggleButton`的圆形图像。
- en: Duplicate the **Toggle-easy** GameObject, naming the copy **Toggle-medium**.
    Set its **Rect Transform** property **Pos Y** to `-25` (so, this copy is positioned
    below the easy option), and uncheck the **Is On** property of the **Toggle (Script)**
    component. Tag this copy with a new tag called **Medium**.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Toggle-easy**游戏对象，将副本命名为**Toggle-medium**。将其**Rect Transform**属性的**Pos Y**设置为`-25`（这样副本就会位于简单选项下方），并取消勾选**Toggle
    (Script)**组件的**Is On**属性。给这个副本添加一个名为**Medium**的新标签。
- en: Duplicate the **Toggle-medium** GameObject, naming the copy **Toggle-hard**.
    Set its **Rect Transform** property **Pos Y** to `-50` (so this copy is positioned
    below the medium option). Tag this copy with a new tag called **Hard**.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Toggle-medium**游戏对象，将副本命名为**Toggle-hard**。将其**Rect Transform**属性的**Pos Y**设置为`-50`（这样副本就会位于中等选项下方）。给这个副本添加一个名为**Hard**的新标签。
- en: 'Add an instance of the C# script class called `RadioButtonManager` to the **Canvas**
    GameObject:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`RadioButtonManager`的C#脚本类实例添加到**Canvas**游戏对象：
- en: '[PRE12]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the **Toggle-easy** GameObject selected, add an **On Value Changed** event
    to the list of event handlers for the **Toggle (Script)** component. Click on
    the plus (**+**) button to add an event handler slot, and drag the **Canvas**
    GameObject into the Object slot.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**Toggle-easy** GameObject后，将**On Value Changed**事件添加到**Toggle (Script)**组件的事件处理器列表中。点击加号（**+**）按钮添加事件处理器槽，并将**Canvas**
    GameObject拖入对象槽中。
- en: From the **Function** drop-down menu, choose **RadioButtonManager**, and then
    choose the **PrintNewGroupValue** method. In the **Toggle** parameter slot, which
    is initially `None (Toggle)`, drag the **Toggle-easy** GameObject.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**功能**下拉菜单中选择**RadioButtonManager**，然后选择**PrintNewGroupValue**方法。在**Toggle**参数槽中，最初为`None
    (Toggle)`，拖入**Toggle-easy** GameObject。
- en: Do the same for the **Toggle-medium** and **Toggle-hard** GameObjects—so each
    **Toggle** object calls the `PrintNewGroupValue(…)`method of a C# scripted component
    called `RadioButtonManager` in the **Canvas** GameObject, passing itself as a
    parameter.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**Toggle-medium**和**Toggle-hard** GameObject执行相同的操作——这样每个**Toggle**对象都会调用**Canvas**
    GameObject中名为`RadioButtonManager`的C#脚本组件的`PrintNewGroupValue(…)`方法，并将自身作为参数传递。
- en: Save and run the scene. Each time you check one of the three radio buttons,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the **Console** window by our script, stating the tag of whichever **Toggle**
    (radio button) was just set to true (**Is On**).
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行场景。每次您检查三个单选按钮中的任何一个时，**On Value Changed**事件都会触发，您会看到我们的脚本在**控制台**窗口中打印出一条新的文本消息，指出刚刚设置为true（**开启**）的**Toggle**（单选按钮）的标签。
- en: The following screenshot shows how the value corresponding to the selected radio
    button is logged to the **Console** panel when the scene is running:![Adding more
    Toggles and a Toggle Group to implement mutually-exclusive radio buttons](img/1362OT_01_40.jpg)
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了当场景运行时，对应于所选单选按钮的值如何记录到**控制台**面板中：![添加更多切换和切换组以实现互斥的单选按钮](img/1362OT_01_40.jpg)
- en: Conclusion
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we have introduced recipes demonstrating a range of Unity 5
    UI components, and illustrated how the same components can be used in different
    ways (such as an interactive slider being used to display the status of a countdown
    timer). One set of UI components in many games are those that communicate to the
    user what they are carrying (or yet to pick up). We have dedicated another chapter
    in this book to inventories in [Chapter 2](ch02.html "Chapter 2. Inventory GUIs"),
    *Inventory GUIs*, which provides many inventory recipes and additional UI controls,
    such as adding interactive scroll bars.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种Unity 5 UI组件的食谱，并说明了相同的组件可以以不同的方式使用（例如，使用交互式滑块来显示倒计时计时器的状态）。许多游戏中的一组UI组件是那些向用户传达他们所携带的内容（或尚未拾取的内容）的组件。我们在本书中专门用另一章介绍了[第2章](ch02.html
    "第2章。库存GUI")中的库存，*库存GUI*，它提供了许多库存食谱和额外的UI控件，例如添加交互式滚动条。
- en: 'Here are some suggestions for further reading, tutorials, and resources to
    help you continue your learning of UI development in Unity:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些进一步阅读、教程和资源的建议，以帮助您继续在Unity中学习UI开发：
- en: Learn more about the Unity UI on manual pages at [http://docs.unity3d.com/Manual/UISystem.html](http://docs.unity3d.com/Manual/UISystem.html).
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://docs.unity3d.com/Manual/UISystem.html](http://docs.unity3d.com/Manual/UISystem.html)的手册页面上了解更多关于Unity
    UI的信息。
- en: Work through the Unity UI tutorial videos at [https://unity3d.com/learn/tutorials/topics/user-interface-ui](https://unity3d.com/learn/tutorials/topics/user-interface-ui).
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://unity3d.com/learn/tutorials/topics/user-interface-ui](https://unity3d.com/learn/tutorials/topics/user-interface-ui)上观看Unity
    UI教程视频。
- en: Ray Wenderlich's great tutorial on Unity UI development at [http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1).
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ray Wenderlich关于Unity UI开发的优秀教程，请访问[http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1)。
- en: 'Unity''s documentation pages about designing UI for multiple resolutions: [http://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html](http://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html).'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity关于为多分辨率设计UI的文档页面：[http://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html](http://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html)。
- en: 'Games need fonts in a style to match the gameplay and theme. Here are some
    of the sources of free personal/commercial fonts suitable for many games:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏需要与游戏玩法和主题相匹配的字体。以下是一些适合许多游戏的免费个人/商业字体的来源：
- en: All the fonts at FontSquirrel are 100% free for commercial use. They are available
    at [http://www.fontsquirrel.com/](http://www.fontsquirrel.com/).
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FontSquirrel上的所有字体均可100%免费用于商业用途。它们可在[http://www.fontsquirrel.com/](http://www.fontsquirrel.com/)找到。
- en: See each font for individual license at the DaFont website. Many people ask
    for a donation if these are used for commercial purposes. For more information,
    check out [http://www.dafont.com/xolonium.font](http://www.dafont.com/xolonium.font).
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DaFont网站上查看每个字体的单独许可。如果用于商业目的，许多人会要求捐赠。更多信息，请查看[http://www.dafont.com/xolonium.font](http://www.dafont.com/xolonium.font)。
- en: See each font for individual licenses available on the Naldz Graphics blog at
    [http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/).
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)的Naldz
    Graphics博客上查看每个字体的单独许可。
- en: 1001 Free Fonts (for personal use) are available at [http://www.1001freefonts.com/index.php](http://www.1001freefonts.com/index.php).
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001 Free Fonts (for personal use) are available at [http://www.1001freefonts.com/index.php](http://www.1001freefonts.com/index.php).
