- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Contributing to Existing Code Bases in Unity with C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#在Unity中为现有代码库做出贡献
- en: Welcome to [*Chapter 7*](B22017_07.xhtml#_idTextAnchor112). This chapter will
    equip you with essential collaboration skills for working in development teams
    using C#. We will explore **version control systems** (**VCSs**), code merging,
    and conflict resolution for seamless teamwork. We will also cover mastering version
    control, collaborating with shared repositories, and resolving conflicts using
    C#. Finally, we will get an understanding of existing code bases to navigate structures,
    review documentation, and communicate effectively. Mastering all these skills
    will promote effective team contribution and maintain code quality in Unity projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第7章*](B22017_07.xhtml#_idTextAnchor112)。本章将为您提供在C#开发团队中工作所需的基本协作技能。我们将探讨**版本控制系统**（**VCSs**）、代码合并和冲突解决，以实现无缝团队合作。我们还将涵盖掌握版本控制、使用共享仓库协作以及使用C#解决冲突。最后，我们将了解现有代码库，以便导航结构、审查文档和有效沟通。掌握所有这些技能将促进有效的团队贡献，并在Unity项目中保持代码质量。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing VCSs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍VCSs
- en: Collaborating and resolving conflicts with C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#协作和解决冲突
- en: Understanding existing code bases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现有代码库
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to follow this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下内容来跟随本章：
- en: '**Primary IDE - Visual Studio 2022**: The tutorials and code samples are crafted
    using Visual Studio 2022\. Ensure it’s installed to follow along seamlessly. Feel
    free to explore Rider or other IDEs if you prefer, though instructions are tailored
    for Visual Studio.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要IDE - Visual Studio 2022**：教程和代码示例使用Visual Studio 2022制作。请确保已安装，以便无缝跟随。如果您更喜欢Rider或其他IDE，请随意探索，尽管说明是为Visual
    Studio量身定制的。'
- en: '**GitHub Desktop**: Ensure it’s installed to follow along seamlessly.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub Desktop**：请确保已安装，以便无缝跟随。'
- en: Introducing VCSs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍VCSs
- en: A VCS is a tool used in software development to manage changes to files. It
    acts like a detailed record keeper, documenting every alteration made to project
    files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: VCS是软件开发中用于管理文件更改的工具。它就像一个详细的记录员，记录项目文件所做的每一项更改。
- en: 'Here’s why it matters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是为什么它很重要：
- en: '**Tracking changes**: In a collaborative project, multiple people may work
    on the same files. A VCS records all modifications, ensuring transparency and
    accountability.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪更改**：在协作项目中，多个人可能对同一文件进行工作。VCS记录所有修改，确保透明度和问责制。'
- en: '**Facilitating collaboration**: With a VCS, team members can see who made specific
    changes and when. This transparency fosters smooth collaboration and prevents
    conflicts.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进协作**：使用VCS，团队成员可以看到谁在何时进行了特定更改。这种透明度促进了顺畅的协作并防止了冲突。'
- en: '**Reverting changes**: Mistakes happen, but a VCS allows us to revert to earlier
    versions of files if needed. It acts as a safety net, providing a way to undo
    errors.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销更改**：错误是难免的，但VCS允许我们在需要时回滚到文件的早期版本。它充当安全网，提供撤销错误的方法。'
- en: '**Maintaining organization**: A VCS helps maintain orderliness by categorizing
    changes and providing a structured approach to managing project files. It enables
    teams to work efficiently and stay organized.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持组织**：VCS通过分类更改并提供管理项目文件的结构化方法来帮助保持秩序。它使团队能够高效工作并保持组织。'
- en: In conclusion, a VCS is a crucial tool for software development teams. It helps
    keep track of changes, encourages teamwork, allows for fixing mistakes, and ensures
    that projects stay organized.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，VCS是软件开发团队的关键工具。它有助于跟踪更改，鼓励团队合作，允许修复错误，并确保项目保持组织。
- en: 'In the upcoming section, we will delve into understanding VCSs, exploring the
    two main types: distributed and centralized systems.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入了解理解VCSs，探讨两种主要类型：分布式和集中式系统。
- en: Understanding VCSs
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解VCSs
- en: When you create a new repository in your VCS, you open up the main branch. This
    is also known as the trunk master. The trunk master serves as the starting point
    for the main code base, which then goes through compilation and deployment to
    reach the end user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在VCS中创建新仓库时，您将打开主分支。这也被称为主干master。主干master作为主代码库的起点，然后经过编译和部署到达最终用户。
- en: But what about branches? Branching occurs when code is extracted from the master
    branch to create separate paths. This allows us to modify the code without impacting
    the main version directly. By using branches, we avoid the need to consolidate
    all changes in one place; instead, we can track modifications to our code over
    time. The VCS can then integrate these separate branches back into the main one.
    If we’re not prepared to merge other changes into the main branch, we can store
    them in a separate branch and merge them later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但分支呢？分支是在从主分支提取代码以创建单独路径时发生的。这使我们能够在不影响主版本的情况下修改代码。通过使用分支，我们避免了需要在同一地点合并所有更改的需求；相反，我们可以随着时间的推移跟踪代码的修改。然后，版本控制系统可以将这些独立的分支重新集成到主分支中。如果我们不打算将其他更改合并到主分支中，我们可以将它们存储在单独的分支中，稍后进行合并。
- en: Having a good branching strategy is important to prevent conflicts and errors
    in the code. Luckily, robust VCSs make it easy for teams to sync with the main
    branch and resolve any potential conflicts – even after changes have been made
    to the main branch.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 制定良好的分支策略对于防止代码中的冲突和错误非常重要。幸运的是，健壮的版本控制系统使团队轻松与主分支同步并解决任何潜在冲突——即使主分支已经进行了更改。
- en: 'Now that we’ve grasped the fundamental workings of VCSs, let’s explore the
    two primary types that play a pivotal role in shaping collaborative development
    processes: distributed and centralized systems.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了VCS的基本工作原理，让我们探索两种在塑造协作开发过程中发挥关键作用的初级类型：分布式和集中式系统。
- en: Distributed VCSs
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式版本控制系统
- en: A **distributed VCS**, or **DVCS**, is a type of VCS where every user has a
    complete copy of the project’s repository on their local computer. This means
    that you can work on the project even when they’re offline.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式版本控制系统**（**DVCS**）是一种版本控制系统，其中每个用户都在他们的本地计算机上拥有项目仓库的完整副本。这意味着即使他们离线，你也可以继续在项目上工作。'
- en: 'The following diagram shows the structure of a DVCS:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了DVCS的结构：
- en: '![Figure 7.1 – DVCS structure](img/B22017_07_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – DVCS结构](img/B22017_07_01.jpg)'
- en: Figure 7.1 – DVCS structure
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – DVCS结构
- en: 'Here’s how it works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的：
- en: '**Local copies**: With a DVCS, each user has their own local copy of the entire
    project’s history, including all files and changes made over time. This allows
    you to work independently and make changes without relying on a central server.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地副本**：在DVCS中，每个用户都有整个项目历史的本地副本，包括所有文件和随时间进行的更改。这允许你独立工作并做出更改，而不需要依赖于中央服务器。'
- en: '**Flexible collaboration**: Since each user has their own copy of the repository,
    they can work on different features or fixes without interfering with each other’s
    work. They can commit changes to their local repository and share them with others
    later.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的协作**：由于每个用户都有自己的仓库副本，他们可以在不影响彼此工作的情况下工作在不同的功能或修复上。他们可以将更改提交到本地仓库，并在稍后与别人分享。'
- en: '**Enhanced security**: Because the entire project history is stored locally,
    a DVCS provides redundancy and security. Even if the central server goes down,
    you can continue working on your local copies and later sync changes with the
    central repository once it’s back online.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全性**：由于整个项目历史都存储在本地，DVCS提供了冗余和安全。即使中央服务器宕机，你仍然可以继续在本地副本上工作，并在服务器恢复在线后同步更改。'
- en: '**Efficient branching and merging**: DVCS systems such as **Git** offer powerful
    branching and merging capabilities. You can create branches to work on new features
    or experiment with changes without affecting the main project. You can later merge
    your changes back into the main branch when ready.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效的分支和合并**：如**Git**这样的DVCS系统提供了强大的分支和合并功能。你可以创建分支来处理新功能或实验性更改，而不会影响主项目。当你准备好时，可以将你的更改合并回主分支。'
- en: Git is an example of a DVCS. It allows users to maintain their own complete
    copy of the project’s repository on their local computer. This means that you
    have access to the entire project history and can work on it even when you’re
    offline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Git是DVCS的一个例子。它允许用户在本地计算机上维护项目仓库的完整副本。这意味着你可以访问整个项目历史，即使你离线也可以工作。
- en: With Git, you can create branches to work on new features or fixes without affecting
    the main code base. These branches can later be merged back into the main branch
    once your changes are complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git，你可以创建分支来处理新功能或修复，而不会影响主代码库。一旦你的更改完成，这些分支可以合并回主分支。
- en: Git also facilitates collaboration among team members by allowing you to share
    your changes with others through a shared remote repository. Other team members
    can then pull your changes from the remote repository to their local copies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Git还通过允许您通过共享远程仓库与他人共享您的更改来促进团队成员之间的协作。然后，其他团队成员可以从远程仓库拉取您的更改到他们的本地副本。
- en: Overall, Git’s distributed nature and powerful branching capabilities make it
    a preferred choice for many development teams. It provides flexibility, efficiency,
    and seamless collaboration for managing and tracking changes in software projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Git的分布式特性和强大的分支功能使其成为许多开发团队的优先选择。它为软件项目的管理和跟踪变更提供了灵活性、效率和无缝协作。
- en: In summary, a DVCS allows us to work independently, collaborate effectively,
    and maintain project history and integrity, even in decentralized environments.
    It provides flexibility, security, and powerful features for managing and tracking
    changes in software projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，DVCS使我们能够在去中心化的环境中独立工作，有效协作，并维护项目历史和完整性。它为软件项目的管理和跟踪变更提供了灵活性、安全性和强大的功能。
- en: Centralized VCSs
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式版本控制系统
- en: A **centralized VCS** (**CVCS**) is a type of VCS where there is a single central
    repository that stores all files and their respective versions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**集中式版本控制系统**（**CVCS**）是一种版本控制系统，其中有一个单一的中央仓库，存储所有文件及其相应的版本。'
- en: 'The following diagram shows the structure of a CVCS:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了CVCS的结构：
- en: '![Figure 7.2 – CVCS structure](img/B22017_07_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – CVCS结构](img/B22017_07_02.jpg)'
- en: Figure 7.2 – CVCS structure
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – CVCS结构
- en: 'Here’s how it works:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式：
- en: '**Single repository**: In a CVCS, all users access and work on the same central
    repository. This means that there is only one copy of the project’s history, stored
    on a central server.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一仓库**：在CVCS中，所有用户都访问并工作在同一个中央仓库上。这意味着项目的历史只有一个副本，存储在中央服务器上。'
- en: '**Limited offline access**: Since the repository is centralized, users typically
    need to be connected to the central server to access files and make changes. This
    can limit the ability to work offline or in environments with limited connectivity.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的离线访问**：由于仓库是集中的，用户通常需要连接到中央服务器才能访问文件并进行更改。这可能限制了离线工作或在连接有限的环境中的能力。'
- en: '**Collaborative workflow**: Users commit their changes directly to the central
    repository, where they are visible to all team members. This facilitates collaboration
    and ensures that everyone is working with the latest version of the code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作工作流程**：用户直接将更改提交到中央仓库，在那里它们对所有团队成员可见。这促进了协作并确保每个人都在使用代码的最新版本。'
- en: '**Potential bottlenecks**: In a CVCS, the central server can become a bottleneck,
    especially in large teams or projects with heavy usage. If the server goes down,
    developers may be unable to access or commit changes until it is restored.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的瓶颈**：在CVCS中，中央服务器可能成为瓶颈，尤其是在大型团队或使用量大的项目中。如果服务器宕机，开发者可能无法访问或提交更改，直到服务器恢复。'
- en: '**Limited branching**: CVCS systems typically offer limited branching capabilities
    compared to distributed systems such as Git. Users may need to coordinate closely
    to avoid conflicts when working on different features or changes.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的分支功能**：与Git这样的分布式系统相比，CVCS系统通常提供有限的分支功能。当在不同的功能或更改上工作时，用户可能需要紧密协调以避免冲突。'
- en: '**SVN**, or **Subversion**, is an example of a CVCS. In SVN, there is a single
    central repository that stores all project files and their respective versions.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**SVN**（或**Subversion**）是集中式版本控制系统（CVCS）的一个例子。在SVN中，有一个单一的中央仓库，存储所有项目文件及其相应的版本。'
- en: Unlike DVCSs such as Git, SVN does not provide users with their own local copies
    of the entire project’s history. Instead, users interact directly with the central
    repository to access files and make changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与Git这样的分布式版本控制系统（DVCS）不同，SVN不向用户提供整个项目历史的本地副本。相反，用户直接与中央仓库交互，以访问文件并进行更改。
- en: SVN facilitates a collaborative workflow by allowing developers to commit their
    changes directly to the central repository. This ensures that everyone is working
    with the latest version of the code and helps maintain project integrity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SVN通过允许开发者直接将更改提交到中央仓库来促进协作工作流程。这确保了每个人都在使用代码的最新版本，并有助于维护项目完整性。
- en: While SVN lacks some of the flexibility and offline capabilities of DVCSs, it
    remains a popular choice for many development teams, especially in centralized
    environments where strict control over the code base is desired.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SVN 缺乏一些分布式版本控制系统（DVCSs）的灵活性和离线功能，但它仍然是许多开发团队的首选，尤其是在需要严格控制代码库的中心化环境中。
- en: In summary, a CVCS relies on a single central repository for storing and managing
    project files and versions. While it facilitates collaboration and provides a
    centralized **source of truth** (**SoT**), it may pose challenges in terms of
    offline access, potential bottlenecks, and limited branching capabilities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，集中式版本控制系统（CVCS）依赖于单个中央仓库来存储和管理项目文件和版本。虽然它促进了协作并提供了一个集中的**真相来源**（**SoT**），但它可能在离线访问、潜在瓶颈和有限的分支能力方面带来挑战。
- en: Next, let’s delve into essential Git commands.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解必要的 Git 命令。
- en: 'In the following table, you’ll find essential Git commands. Make sure you have
    Git installed on your system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表格中，您将找到必要的 Git 命令。请确保您的系统已安装 Git：
- en: '| **Command** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| **git init** | Initializes a new Git repository in the current directory
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **git init** | 在当前目录中初始化一个新的 Git 仓库 |'
- en: '| **git clone [url]** | Clones an existing Git repository from a remote server
    to your local machine |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **git clone [url]** | 从远程服务器克隆现有的 Git 仓库到本地机器 |'
- en: '| **git add [file]** | Adds a file or changes to the staging area to be included
    in the next commit |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **git add [file]** | 将文件或更改添加到暂存区，以便包含在下一个提交中 |'
- en: '| **git commit -m "[message]"** | Commits changes to the local repository with
    a descriptive message |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **git commit -m "[message]"** | 使用描述性消息将更改提交到本地仓库 |'
- en: '| **git push** | Uploads local repository content to a remote repository |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **git push** | 将本地仓库内容上传到远程仓库 |'
- en: '| **git pull** | Downloads changes from a remote repository and merges them
    into the local repository |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **git pull** | 从远程仓库下载更改并将其合并到本地仓库 |'
- en: '| **git status** | Displays the status of the working directory and the staging
    area |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **git status** | 显示工作目录和暂存区的状态 |'
- en: '| **git log** | Shows a list of commits in the repository, along with details
    such as author, date, and commit message |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **git log** | 显示仓库中的提交列表，包括作者、日期和提交信息等详细信息 |'
- en: '| **git branch** | Lists all branches in the local repository |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **git branch** | 列出本地仓库中的所有分支 |'
- en: '| **git checkout [branch]** | Switches to the specified branch |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **git checkout [branch]** | 切换到指定的分支 |'
- en: '| **git merge [branch]** | Merges changes from the specified branch into the
    current branch |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **git merge [branch]** | 将指定分支的更改合并到当前分支 |'
- en: '| `git` `remote -v` | Lists all remote repositories associated with the local
    repository |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `git` `remote -v` | 列出与本地仓库关联的所有远程仓库 |'
- en: Many commands may be overwhelming, especially considering our book’s context.
    Instead, we’ll rely on **graphical user interface** (**GUI**) tools such as the
    GitHub Desktop app for version control, where most actions can be performed through
    the **user interface** (**UI**). Feel free to depend on the GUI for all processes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令可能令人感到不知所措，尤其是考虑到我们书籍的背景。因此，我们将依赖图形用户界面（**GUI**）工具，如 GitHub Desktop 应用程序进行版本控制，其中大多数操作都可以通过用户界面（**UI**）完成。请随意依赖
    GUI 来完成所有过程。
- en: In the next section, we will explore best practices for collaborating on code
    and resolving conflicts efficiently.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨代码协作的最佳实践和高效解决冲突的方法。
- en: Collaborating and resolving conflicts with C#
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 进行协作和解决冲突
- en: Navigating collaborative environments and maintaining code quality are vital
    aspects of software development. Let’s explore effective collaboration, conflict
    resolution, and code quality maintenance in the following sections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作环境中导航和维护代码质量是软件开发的重要方面。让我们在以下章节中探讨有效的协作、冲突解决和代码质量维护。
- en: Best practices for collaborating
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作的最佳实践
- en: 'Effective collaboration is essential for successful project development, and
    adopting best practices ensures smooth teamwork and code management throughout
    the process. The following are some best practices to follow when working with
    VCSs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的协作对于项目成功开发至关重要，采用最佳实践可以确保在整个过程中团队协作和代码管理顺畅。以下是一些在与其他版本控制系统（VCSs）一起工作时需要遵循的最佳实践：
- en: '**Frequent and incremental commits for a streamlined workflow**: Making small,
    frequent commits is an uncomplicated yet highly effective enhancement for your
    workflow, even though it poses a challenge for some developers. In the context
    of other project management tools, where tasks are typically broken down into
    manageable parts, the same approach should be applied to commits. Each commit
    should specifically correspond to one task or ticket unless a single line of code
    miraculously addresses multiple issues. For more extensive features, it’s beneficial
    to break them down into smaller tasks and create commits for each one. The primary
    advantage of opting for smaller commits is the increased ease of detecting and
    reverting undesired changes in case something goes wrong.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁和增量提交以实现流畅的工作流程**：进行小而频繁的提交是提高工作流程的简单而有效的方法，尽管这对一些开发者来说是一个挑战。在其他项目管理工具的背景下，任务通常被分解成可管理的部分，同样的方法也应该应用于提交。每个提交应专门对应一个任务或票据，除非一行代码奇迹般地解决了多个问题。对于更广泛的功能，将其分解成更小的任务并为每个任务创建提交是有益的。选择较小提交的主要优势是，在出现问题时，更容易检测和撤销不希望的变化。'
- en: '**Prioritize getting the latest changes**: Make it a habit to fetch the latest
    changes from the repository into your working copy whenever it’s feasible. It’s
    not advisable to work in isolation as this raises the risk of encountering merge
    conflicts.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先获取最新更改**：养成在可行时将仓库中的最新更改获取到工作副本中的习惯。不建议孤立工作，因为这会增加遇到合并冲突的风险。'
- en: '**Mindful committing for a smooth workflow**: Refrain from making hasty commits.
    The **commit -a** command, or its equivalents, should only be employed during
    the initial commit of a project, typically when the project consists solely of
    **README.md** files. A commit should exclusively encompass files pertinent to
    the specific change being committed to the repository. Exercise caution, especially
    when dealing with Unity projects, as certain modifications may inadvertently affect
    multiple files, such as scenes, Prefabs, or Sprite Atlases, even if not intended.
    Accidentally committing changes to a scene that another team member is concurrently
    editing can lead to complications for them during their own commit process, necessitating
    the merging of your changes beforehand.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谨慎提交以实现流畅的工作流程**：避免仓促提交。**commit -a** 命令或其等效命令仅在项目的初始提交时使用，通常情况下，项目仅包含**README.md**文件。提交应仅包含与提交到仓库的特定更改相关的文件。在处理Unity项目时，要格外小心，因为某些修改可能会意外地影响多个文件，例如场景、预制件或精灵图集，即使不是有意为之。不小心提交更改到另一个团队成员正在同时编辑的场景可能会导致他们在自己的提交过程中遇到问题，需要事先合并您的更改。'
- en: '**Crafting clear commit messages**: Maintain clarity in your commit messages
    as they narrate the evolution of your project. It’s more convenient to trace the
    addition of new gameplay mechanics in your game when the commit message explicitly
    states, “**implemented new enemy behavior for level 3" rather than opting for
    a more casual expression such as, "added some cool stuff to level 3**.” When utilizing
    a task ticketing system such as Jira or GitLab, it’s advantageous to include a
    ticket number in your commit message. Many systems can be configured to integrate
    with smart commits, enabling you to reference tickets and update their status
    directly from your commit message. For instance, a commit message such as “**JRA-123
    #close #comment task completed**” would close the JRA-123 Jira ticket and append
    the comment “task completed” to the ticket.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写清晰的提交信息**：保持提交信息的清晰性，因为它们讲述了项目的发展历程。当提交信息明确指出“**实现了第3关的新敌人行为**”而不是选择更随意的表达，例如“**第3关添加了一些酷炫的东西**”时，在游戏中追踪新游戏机制的增加会更加方便。当使用Jira或GitLab等任务跟踪系统时，在提交信息中包含一个任务编号是有利的。许多系统可以配置为与智能提交集成，使您可以直接从提交信息中引用任务并更新其状态。例如，一个提交信息如“**JRA-123
    #close #comment 任务完成**”将关闭JRA-123 Jira任务，并将注释“任务完成”附加到任务上。'
- en: In the realm of collaborative coding, mastering these best practices not only
    fosters seamless teamwork but also streamlines code management throughout project
    development.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作编码的领域，掌握这些最佳实践不仅能够促进团队协作的流畅性，还能在整个项目开发过程中简化代码管理。
- en: Mastering branching and merging in collaboration
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握协作中的分支和合并
- en: Understanding branching and merging strategies for collaborative development
    is crucial for effective teamwork in software projects. Next are some ideas and
    guidelines to assist you with this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 理解协作开发的分支和合并策略对于软件项目中的有效团队合作至关重要。以下是一些想法和指南，以帮助你实现这一点。
- en: 'The following are some crafting branching and merging strategies:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些构建分支和合并策略：
- en: '**Feature branches**: Work on new features or fixes in separate branches. This
    practice maintains the cleanliness of the main branch while enabling us to work
    independently.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能分支**：在单独的分支中工作于新功能或修复。这种做法保持了主分支的清洁性，同时使我们能够独立工作。'
- en: '**Release branches**: Create branches specifically for release candidates to
    stabilize the code base before deployment.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布分支**：创建专门用于发布候选人的分支，以便在部署前稳定代码库。'
- en: '**Hotfix branches**: Establish branches to address critical issues or bugs
    in production without disrupting ongoing development.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热修复分支**：建立分支以解决生产中的关键问题或错误，而不会干扰持续的开发。'
- en: '**Long-lived branches**: Some projects may require long-lived branches for
    ongoing development efforts or specific feature sets.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长期分支**：某些项目可能需要长期分支来支持持续的开发工作或特定的功能集。'
- en: 'Exploring branches, forks, and pull requests offers valuable insights into
    the intricacies of collaborative coding and VCSs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 探索分支、分叉和拉取请求为协作编码和版本控制系统提供了宝贵的见解：
- en: '**Branches**: Create feature branches for each new task or feature you work
    on. This keeps changes isolated and makes it easier to review and merge code.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支**：为每个你工作的新任务或功能创建功能分支。这有助于隔离更改，并使审查和合并代码变得更加容易。'
- en: '**Forks**: In open source projects, contributors often fork the main repository
    to work on changes independently. Forks allow for experimentation without affecting
    the original code base.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分叉**：在开源项目中，贡献者通常会分叉主存储库以独立工作。分叉允许在不影响原始代码库的情况下进行实验。'
- en: '**Pull requests**: Pull requests (or merge requests) are a key mechanism for
    proposing changes and initiating code review. They provide a structured way to
    discuss and approve modifications before merging them into the main branch.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取请求**：拉取请求（或合并请求）是提出更改和启动代码审查的关键机制。它们提供了一种结构化的方式来讨论和批准修改，在合并到主分支之前。'
- en: '**Code reviews**: Emphasize the importance of thorough code reviews in the
    pull request process. Reviewing code helps maintain code quality, identify potential
    issues, and share knowledge among team members.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码审查**：强调在拉取请求过程中进行彻底代码审查的重要性。审查代码有助于维护代码质量，识别潜在问题，并在团队成员之间分享知识。'
- en: Encouraging a clear branching and merging strategy, along with effective use
    of branches, forks, and pull requests, promotes collaboration, code quality, and
    project stability in software development teams.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励明确的分支和合并策略，以及有效使用分支、分叉和拉取请求，可以促进软件开发团队中的协作、代码质量和项目稳定性。
- en: Mastering code conflict management
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精通代码冲突管理
- en: Understanding the nature of code conflicts and how to resolve them is essential
    for seamless collaboration and project success. Let’s delve into common types
    of conflicts and learn practical techniques for resolving them in Unity projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码冲突的本质以及如何解决它们对于无缝协作和项目成功至关重要。让我们深入了解常见的冲突类型，并学习在Unity项目中解决它们的具体技巧。
- en: Exploring code conflict origins and navigating conflict resolution in Unity
    projects
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索代码冲突的起源和在Unity项目中导航冲突解决
- en: 'Understanding the origins of code conflicts is crucial for maintaining a harmonious
    development environment and ensuring smooth collaboration among team members,
    Let’s delve into specific points that contribute to these conflicts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码冲突的起源对于维护和谐的开发环境并确保团队成员之间协作顺畅至关重要。让我们深入了解导致这些冲突的具体因素：
- en: '**Merge conflicts**: When multiple contributors modify the same file or code
    block, conflicting changes can arise during merging'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合并冲突**：当多个贡献者修改相同的文件或代码块时，合并过程中可能会出现冲突'
- en: '**Structural changes**: Renaming files, relocating directories, or altering
    project structures can introduce conflicts'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构变更**：重命名文件、移动目录或更改项目结构可能会引入冲突'
- en: '**Dependency dilemmas**: Incompatible dependencies or divergent library versions
    across project components can lead to conflicts'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖困境**：项目组件之间的不兼容依赖或不同的库版本可能导致冲突'
- en: '**Branch divergence**: Significant deviations from the main branch make merging
    changes back into the main code base challenging'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支分歧**：与主分支的显著偏差使得将更改合并回主代码库变得具有挑战性'
- en: 'Next, we’ll explore two methods to resolve conflicts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨两种解决冲突的方法：
- en: '**Manual conflict resolution**: Learn to review conflicting changes in code
    files and decide which modifications to retain, modify, or discard'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动冲突解决**：学习如何审查代码文件中的冲突更改，并决定保留、修改或丢弃哪些修改'
- en: '**Version control integration**: Explore how Git and other VCSs integrate with
    Unity, offering built-in merge tools and third-party plugins for conflict resolution'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制集成**：探索 Git 和其他 VCS 如何与 Unity 集成，提供内置的合并工具和第三方插件以解决冲突'
- en: Next, let’s engage in practical conflict resolution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进行实际的冲突解决。
- en: Practical conflict solving
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践冲突解决
- en: After understanding the causes of conflicts, it’s essential to learn how to
    resolve them. I’ll share an example of a conflict from one of my current projects
    and how I successfully resolved it. While the conflict wasn’t significant, the
    approach used for resolving code conflicts applies universally. Let’s proceed
    with resolving code conflicts using GitHub Desktop and Visual Studio.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解冲突的原因后，学习如何解决它们是至关重要的。我将分享一个来自我当前项目的冲突示例以及我如何成功解决它。虽然冲突并不重大，但用于解决代码冲突的方法是普遍适用的。让我们继续使用
    GitHub Desktop 和 Visual Studio 解决代码冲突。
- en: 'When your local changes conflict with modifications made to the same file on
    the remote server, the following panel will be displayed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的本地更改与远程服务器上对同一文件的修改冲突时，将显示以下面板：
- en: '![Figure 7.3 – Resolve conflict panel in GitHub Desktop](img/B22017_07_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – GitHub Desktop 中的解决冲突面板](img/B22017_07_03.jpg)'
- en: Figure 7.3 – Resolve conflict panel in GitHub Desktop
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – GitHub Desktop 中的解决冲突面板
- en: 'When this panel appears, it signals the need to compare and decide between
    conflicting versions of the same file from different sources. In GitHub Desktop,
    this panel represents the conflict resolution interface. By clicking the drop-down
    button, you can select your preferred editing program, such as Visual Studio or
    Visual Studio Code. For this example, when you select Visual Studio as the default
    program, the editor will open. You can choose to click on the **Open Merge Editor**
    option, as illustrated in the following figure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当此面板出现时，表示需要比较并决定来自不同来源的同一文件的冲突版本。在 GitHub Desktop 中，此面板代表冲突解决界面。通过点击下拉按钮，你可以选择你偏好的编辑程序，例如
    Visual Studio 或 Visual Studio Code。对于此示例，当你选择 Visual Studio 作为默认程序时，编辑器将打开。你可以选择点击**打开合并编辑器**选项，如图所示：
- en: '![Figure 7.4 – Conflict mode in Visual Studio](img/B22017_07_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – Visual Studio 中的冲突模式](img/B22017_07_04.jpg)'
- en: Figure 7.4 – Conflict mode in Visual Studio
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Visual Studio 中的冲突模式
- en: 'In the Merge Editor, you’ll notice there are three sections: the incoming or
    remote version, the current or local version, and the resulting file after merging.
    Here, you need to review the changes and decide whether to combine them or keep
    one version based on the flow of the feature or task requirements. Once you or
    the responsible senior has finished editing, click on **Accept Merge**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并编辑器中，你会注意到有三个部分：传入或远程版本、当前或本地版本以及合并后的结果文件。在这里，你需要审查更改并决定是否合并它们或根据功能或任务需求保留一个版本。一旦你或负责的高级人员完成编辑，点击**接受合并**：
- en: '![Figure 7.5 – Merge Editor in Visual Studio](img/B22017_07_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – Visual Studio 中的合并编辑器](img/B22017_07_05.jpg)'
- en: Figure 7.5 – Merge Editor in Visual Studio
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – Visual Studio 中的合并编辑器
- en: 'After closing the Merge Editor, you’ll notice that the sidebar now includes
    an option to commit the changes. Then, you can click on **Commit Staged** in the
    side panel to push the changes after the merge, as you can see in the following
    figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭合并编辑器后，你会注意到侧边栏现在包括一个提交更改的选项。然后，你可以在侧面板中点击**提交暂存**来在合并后推送更改，如图所示：
- en: '![Figure 7.6 – File after editing the conflict](img/B22017_07_06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 编辑冲突后的文件](img/B22017_07_06.jpg)'
- en: Figure 7.6 – File after editing the conflict
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 编辑冲突后的文件
- en: Remember
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住
- en: You’ll need to focus, especially when the same file is involved in two different
    tasks, ensuring that the logic of both tasks continues to work properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要集中注意力，尤其是在同一文件涉及两个不同任务时，确保两个任务的逻辑都能正常工作。
- en: Let’s use the **command-line interface** (**CLI**) to resolve merge conflicts
    efficiently.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**命令行界面**（**CLI**）来高效地解决合并冲突。
- en: Exploring code conflict origins and navigating conflict resolution using the
    CLI
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索代码冲突起源并使用 CLI 导航冲突解决
- en: The CLI remains a fundamental and widely used method for resolving Git conflicts.
    While GUIs are available and can provide visual aids for conflict resolution,
    many developers, particularly those comfortable with terminal-based workflows,
    prefer the command line as their default approach. The CLI offers granular control,
    precise navigation through code changes, and efficient merging capabilities, making
    it a robust tool for managing Git conflicts effectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）是解决 Git 冲突的基本且广泛使用的方法。虽然提供了图形用户界面（GUI），并且可以提供冲突解决的视觉辅助，但许多开发者，尤其是那些习惯于基于终端的工作流程的开发者，更喜欢将命令行作为他们的默认方法。CLI
    提供了细粒度的控制、精确的代码更改导航和高效的合并能力，使其成为有效管理 Git 冲突的强大工具。
- en: 'To test this, ensure you have another branch in your project. We will then
    modify the same file in the two branches to create a conflict and resolve it.
    Let’s get started:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，请确保你在项目中还有一个分支。然后，我们将修改两个分支中的相同文件以创建冲突并解决它。让我们开始吧：
- en: Navigate to your project directory and open the terminal there, or use the **cd**
    command in the terminal to navigate to your project directory.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的项目目录并在那里打开终端，或者使用终端中的 **cd** 命令导航到你的项目目录。
- en: Alternatively, ensure that you are currently in one of your other branches.
    In my case, I have a branch called **feature/branch-name**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，确保你目前处于你的其他分支之一。以我的情况为例，我有一个名为 **feature/branch-name** 的分支。
- en: 'Use the **git checkout branch-name** command to switch to the desired branch,
    as demonstrated in the following figure:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **git checkout branch-name** 命令切换到所需的分支，如下图中所示：
- en: '![Figure 7.7 – Checkout feature branch](img/B22017_07_07.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 检出功能分支](img/B22017_07_07.jpg)'
- en: Figure 7.7 – Checkout feature branch
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 检出功能分支
- en: 'Now, let’s make a modification to a file. In my case, I’ll comment out a line
    in a script, as shown in the following figure:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改一个文件。以我的情况为例，我将在脚本中注释掉一行，如下图中所示：
- en: '![Figure 7.8 – Commenting out a line in a function](img/B22017_07_08.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 在函数中注释掉一行](img/B22017_07_08.jpg)'
- en: Figure 7.8 – Commenting out a line in a function
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 在函数中注释掉一行
- en: 'We need to add and commit that file using **git add filename** followed by
    **git commit -m "commit message"**, as you can see in the following figure:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用 **git add filename** 命令添加并提交该文件，然后使用 **git commit -m "commit message"**
    命令进行提交，正如以下图中所示：
- en: '![Figure 7.9 – Committing changes](img/B22017_07_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 提交更改](img/B22017_07_09.jpg)'
- en: Figure 7.9 – Committing changes
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 提交更改
- en: 'Push your changes:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送你的更改：
- en: '![Figure 7.10 – Pushing changes](img/B22017_07_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 推送更改](img/B22017_07_10.jpg)'
- en: Figure 7.10 – Pushing changes
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 推送更改
- en: 'Now, we can go to another branch; in my case, I will return to the main branch
    using the **git** **checkout** command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以转到另一个分支；以我的情况为例，我将使用 **git checkout** 命令返回到主分支：
- en: '![Figure 7.11 – Returning to the main branch](img/B22017_07_11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 返回主分支](img/B22017_07_11.jpg)'
- en: Figure 7.11 – Returning to the main branch
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 返回主分支
- en: Modify the same file to make a conflict, then we need to add, commit, and push
    changes.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改相同的文件以创建冲突，然后我们需要添加、提交和推送更改。
- en: Then, return to the feature branch again.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次回到功能分支。
- en: 'Next, execute the **merge** command from the main branch, as illustrated in
    the following figure:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从主分支执行 **merge** 命令，如下图中所示：
- en: '![Figure 7.12 – Merging from the main branch](img/B22017_07_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 从主分支合并](img/B22017_07_12.jpg)'
- en: Figure 7.12 – Merging from the main branch
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 从主分支合并
- en: 'We can also use the `git status` command to identify the file or files that
    require conflict resolution:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `git status` 命令来识别需要解决冲突的文件或文件：
- en: '![Figure 7.13 – Checking conflict files](img/B22017_07_13.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 检查冲突文件](img/B22017_07_13.jpg)'
- en: Figure 7.13 – Checking conflict files
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 检查冲突文件
- en: 'Open the file in the editor to resolve the conflict, as illustrated in the
    following figure:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开文件以解决冲突，如下图中所示：
- en: '![Figure 7.14 – Conflict code](img/B22017_07_14.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 冲突代码](img/B22017_07_14.jpg)'
- en: Figure 7.14 – Conflict code
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 冲突代码
- en: 'After making the necessary edits, add and commit the file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行必要的编辑后，添加并提交文件：
- en: '![Figure 7.15 – Commit after solving the conflict](img/B22017_07_15.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 解决冲突后的提交](img/B22017_07_15.jpg)'
- en: Figure 7.15 – Commit after solving the conflict
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 解决冲突后的提交
- en: 'Use **git status** to ensure everything is clear:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **git status** 命令确保一切清晰：
- en: '![Figure 7.16 – Checking status](img/B22017_07_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 检查状态](img/B22017_07_16.jpg)'
- en: Figure 7.16 – Checking status
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 检查状态
- en: 'Now, push the branch after resolving the conflict:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在解决冲突后推送分支：
- en: '![Figure 7.17 – Pushing the feature branch](img/B22017_07_17.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 推送功能分支](img/B22017_07_17.jpg)'
- en: Figure 7.17 – Pushing the feature branch
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 推送功能分支
- en: By using the CLI, we can efficiently resolve conflicts in Git repositories by
    navigating to the project directory, switching to the branch containing the conflict,
    modifying the conflicting file, adding and committing the changes, pushing the
    branch, and finally merging the changes with the main branch.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命令行界面（CLI），我们可以通过导航到项目目录、切换到包含冲突的分支、修改冲突文件、添加和提交更改、推送分支，最后将更改与主分支合并，来有效地在
    Git 仓库中解决冲突。
- en: In summary, mastering code conflict management involves understanding conflict
    origins and resolution techniques. In this section, we explored common conflict
    types such as merge conflicts and structural changes, and we delved into practical
    conflict resolution methods using tools such as GitHub Desktop, Visual Studio,
    and the CLI. By learning to navigate conflicts effectively, we ensure smooth collaboration
    and project success in Unity projects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，掌握代码冲突管理涉及理解冲突的起源和解决技术。在本节中，我们探讨了常见的冲突类型，如合并冲突和结构变化，并深入探讨了使用 GitHub Desktop、Visual
    Studio 和 CLI 等工具的实际冲突解决方法。通过有效地处理冲突，我们确保在 Unity 项目中实现顺利的合作和项目成功。
- en: In the upcoming section, we will explore how to effectively work with existing
    projects, providing instructions and a practical example for guidance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何有效地处理现有项目，提供指导和实际示例。
- en: Understanding existing code bases
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解现有代码库
- en: 'When delving into an existing code base, there are key steps to take to familiarize
    yourself with its structure and functionality:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究现有代码库时，有一些关键步骤可以帮助你熟悉其结构和功能：
- en: '**Project structure and organization**: Begin by exploring the project’s directory
    structure and organization. Understand how files and folders are arranged and
    grouped according to functionality or modules.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目结构和组织**：首先探索项目的目录结构和组织方式。了解文件和文件夹是如何根据功能或模块进行排列和分组的。'
- en: '**Review documentation**: Look for any available documentation, including README
    files, wiki pages, or inline comments within the code. Documentation can provide
    valuable insights into the project’s purpose, architecture, and design decisions.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审查文档**：寻找任何可用的文档，包括 README 文件、维基页面或代码中的内联注释。文档可以为项目的目的、架构和设计决策提供宝贵的见解。'
- en: '**Identify key components and relationships**: Identify key components, modules,
    and their relationships within the code base. Determine how different parts of
    the code interact with each other and understand the overall architecture.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别关键组件和关系**：识别代码库中的关键组件、模块及其关系。确定代码的不同部分是如何相互交互的，并理解整体架构。'
- en: '**Utilize code analysis tools and integrated development environment (IDE)
    features**: Make use of code analysis tools and features provided by your IDE
    to explore code dependencies, inheritance hierarchies, and function calls. Tools
    such as static code analyzers can help identify potential issues or areas for
    improvement.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用代码分析工具和集成开发环境（IDE）功能**：利用 IDE 提供的代码分析工具和功能来探索代码依赖、继承层次和函数调用。例如，静态代码分析工具可以帮助识别潜在问题或改进区域。'
- en: '**Understand coding standards and conventions**: Familiarize yourself with
    coding standards and conventions used in the project. Pay attention to naming
    conventions, code formatting, and documentation practices to ensure consistency
    across the code base.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解编码标准和规范**：熟悉项目中使用的编码标准和规范。注意命名规范、代码格式和文档实践，以确保代码库的一致性。'
- en: '**Communicate with team members**: Engage with team members or project leads
    to gain insights into the code base and its design decisions. Discuss any questions
    or uncertainties you have and leverage their expertise to deepen your understanding.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与团队成员沟通**：与团队成员或项目负责人沟通，以深入了解代码库及其设计决策。讨论你任何疑问或不确定性，并利用他们的专业知识来加深你的理解。'
- en: Beginning work on an existing project demands time and dedication to grasp its
    complexities. Yet, this initial exploration establishes a base for fruitful contributions,
    ensuring the project’s durability and ease of maintenance. As you familiarize
    yourself with the code base, you’ll gain the ability to suggest improvements,
    tackle problems, and engage in effective collaboration with the project team.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 开始处理现有项目需要时间和对复杂性的投入，但这个初步的探索为有成效的贡献奠定了基础，确保项目的耐用性和易于维护。随着你对代码库的熟悉，你将能够提出改进建议，解决难题，并与项目团队进行有效的协作。
- en: Practical exploration for the existing code base
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对现有代码库的实用探索
- en: We’ll illustrate the code review process with an example, either after following
    the preceding steps or by considering these steps beforehand.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过示例说明代码审查过程，无论是遵循前面的步骤之后，还是事先考虑这些步骤。
- en: If you’re assigned a task in a new project, you can either proceed independently
    following these steps, seek guidance from your senior or leader if needed, or
    check if there’s a similar approach already implemented in the game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个新项目中分配了一个任务，你可以独立地按照这些步骤进行，如果需要的话，向你的高级或领导寻求指导，或者检查游戏中是否已经实现了类似的方法。
- en: My preferred method is to begin at the end and work backward to the source.
    For example, if you’re dealing with UI logic, start by examining the button’s
    onclick action to determine which function it calls. Then, navigate to that script
    to review the function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我首选的方法是从终点开始，逆向工作到源头。例如，如果你在处理UI逻辑，首先检查按钮的onclick动作来确定它调用了哪个函数。然后，导航到那个脚本以审查该函数。
- en: Then, you can examine the logic and check for additional calls to other scripts.
    Continue this process until you reach the core of the logic. Sometimes, a function
    may involve numerous calls to other scripts, so review them one by one to comprehend
    how they interact. This process enhances your understanding of the project. If
    the logic involves managers, you’ll grasp their responsibilities. Consequently,
    when you tackle tasks related to these managers in the future, you’ll be better
    equipped to understand and connect the logic effectively.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以检查逻辑并检查对其他脚本的额外调用。继续这个过程，直到你达到逻辑的核心。有时，一个函数可能涉及对其他多个脚本的调用，因此需要逐个审查它们，以理解它们是如何交互的。这个过程增强了你对项目的理解。如果逻辑涉及管理者，你将掌握他们的责任。因此，当你未来处理与这些管理者相关的任务时，你将更有能力有效地理解和连接逻辑。
- en: If you’re assigned a new task and realize the manager, such as one handling
    player or game data, lacks a necessary function, you can simply append a new function
    to that manager. This approach allows you to expand the manager’s capabilities
    to accommodate your requirements seamlessly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分配了一个新任务，并意识到如处理玩家或游戏数据的管理者缺少必要的函数，你只需简单地向该管理者添加一个新函数。这种方法允许你无缝地扩展管理者的功能，以满足你的需求。
- en: When collaborating with a third party, it’s beneficial to examine example scenes
    or scripts to grasp their functionality. By experimenting with and modifying these
    examples, you can gain insights into their usage and adapt them for your own features,
    focusing only on the essential logic needed for your project.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当与第三方合作时，检查示例场景或脚本以了解其功能是有益的。通过实验和修改这些示例，你可以深入了解它们的用法，并将它们适应到自己的功能中，只关注项目所需的必要逻辑。
- en: Now, let’s see an example we will follow to see how we can understand the existing
    code base.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个示例，我们将遵循它来了解我们如何理解现有的代码库。
- en: '**Example**:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**:'
- en: 'I’m currently examining the sound toggle function in the `SettingsView` script,
    which handles muting or unmuting the sound effects in another project I’m involved
    in:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前正在审查`SettingsView`脚本中的声音切换功能，该功能处理我在另一个项目中参与的项目中的声音效果的开/关：
- en: I begin by navigating to the **SettingsView** script in the hierarchy and locating
    the toggle button.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我首先在层次结构中导航到**SettingsView**脚本，并定位到切换按钮。
- en: 'Then, I examine the action triggered when the value changes and identify the
    associated function or functions. Additionally, it’s important to verify if the
    toggle is referenced in the view script and if the function is attached through
    code. As illustrated in the following figure, the function can be found in the
    **Inspector**:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我检查值变化时触发的动作，并识别相关的函数或函数。此外，验证切换是否在视图脚本中引用，以及函数是否通过代码附加，也是非常重要的。如图所示，该函数可以在**检查器**中找到：
- en: '![Figure 7.18 – SoundToggle component](img/B22017_07_18.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18 – SoundToggle组件](img/B22017_07_18.jpg)'
- en: Figure 7.18 – SoundToggle component
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – SoundToggle 组件
- en: 'Next, we should navigate to the **SettingsView** script to examine the logic
    of **OnSoundClicked**, as illustrated in the following figure:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该导航到 **SettingsView** 脚本来检查 **OnSoundClicked** 的逻辑，如图所示：
- en: '![Figure 7.19 – OnSoundClicked function in the SettingsView script](img/B22017_07_19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – SettingsView 脚本中的 OnSoundClicked 函数](img/B22017_07_19.jpg)'
- en: Figure 7.19 – OnSoundClicked function in the SettingsView script
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – SettingsView 脚本中的 OnSoundClicked 函数
- en: 'In the `SetSFXVolume` function, as shown in the next figure, you can observe
    its associated logic:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SetSFXVolume` 函数中，如图所示，你可以观察到其相关的逻辑：
- en: '![Figure 7.20 – SetSFXVolume function in the AudioManager script](img/B22017_07_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – AudioManager 脚本中的 SetSFXVolume 函数](img/B22017_07_20.jpg)'
- en: Figure 7.20 – SetSFXVolume function in the AudioManager script
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – AudioManager 脚本中的 SetSFXVolume 函数
- en: In the **SetSFXVolume** function, we adjust the sound effects volume in the
    audio mixer, enabling us to control all audio sources linked to this mixer, muting
    or unmuting their sound. Additionally, the second line manages the sound state
    data, facilitating its persistence and storage locally or in the cloud.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SetSFXVolume** 函数中，我们在音频混音器中调整音效音量，使我们能够控制所有链接到该混音器的音频源，静音或取消静音它们的声音。此外，第二行管理声音状态数据，便于其持久化和本地或云端存储。
- en: 'We will now examine the function responsible for setting the sound state in
    the **GameData** script, which manages the game’s data, as you can see in the
    following figure:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将检查负责在 **GameData** 脚本中设置声音状态的函数，该脚本管理游戏数据，如图所示：
- en: '![Figure 7.21 – SetSoundState function in the GameData script](img/B22017_07_21.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – GameData 脚本中的 SetSoundState 函数](img/B22017_07_21.jpg)'
- en: Figure 7.21 – SetSoundState function in the GameData script
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – GameData 脚本中的 SetSoundState 函数
- en: In summary, the advantage we gain is the presence of a script dedicated to audio
    control within the game, equipped with functions that can be utilized in future
    tasks related to audio management. Additionally, there exists a script named `GameData`,
    tasked with managing the game’s data. This allows us to reference it later for
    any data-related requirements, such as retrieving saved data or storing new data
    states.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们获得的优势是游戏内存在一个专门用于音频控制的脚本，并配备了可用于未来音频管理相关任务的函数。此外，还有一个名为 `GameData` 的脚本，负责管理游戏数据。这使得我们可以在以后的数据相关需求中引用它，例如检索保存的数据或存储新的数据状态。
- en: This example is straightforward to follow, but the steps are comprehensive.
    Feel free to apply these steps to your projects or when you’re dealing with new
    ones.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很容易理解，但步骤很全面。请随意将这些步骤应用到你的项目中，或者当你处理新项目时。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about working with existing code in Unity using
    C#. We explored how to use VCSs, merge code, and fix conflicts when collaborating
    on projects. By understanding these concepts, we can work better with other developers
    and maintain code quality. The chapter also covered how to understand project
    structures, review documentation, and communicate effectively with team members.
    By taking the time to understand existing projects, we can contribute more effectively
    and make better decisions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用 C# 在 Unity 中处理现有代码。我们探讨了如何使用版本控制系统、合并代码以及在项目协作中解决冲突。通过理解这些概念，我们可以与其他开发者更好地合作并保持代码质量。本章还涵盖了如何理解项目结构、审查文档和与团队成员有效沟通。通过花时间理解现有项目，我们可以更有效地做出贡献并做出更好的决策。
- en: In [*Chapter 8*](B22017_08.xhtml#_idTextAnchor127), we’ll look at adding outside
    assets and features to Unity games using C#. We’ll learn how to use pre-made assets
    to improve game visuals and add new features such as analytics and monetization.
    Get ready for new ways to enhance your games in the upcoming chapter!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B22017_08.xhtml#_idTextAnchor127) 中，我们将探讨使用 C# 将外部资源和功能添加到 Unity
    游戏中。我们将学习如何使用预制资源来改善游戏视觉效果，并添加新的功能，如分析和货币化。准备好在下一章中学习新的游戏增强方法！
