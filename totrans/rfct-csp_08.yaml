- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoiding Code Anti-Patterns with SOLID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The right design principles can keep your code from quickly going stale. While
    there are many right ways of writing code, there are anti-patterns and code smells
    that constitute the wrong way of writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the community has identified several principles to keep in mind
    when building software that can help your code resist accumulating technical debt
    for as long as possible. In this chapter, we’ll cover a number of these principles,
    including the famous SOLID acronym, and see how they can help you build software
    that actively resists the gradual decline toward legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying anti-patterns in C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing SOLID code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering other architectural principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying anti-patterns in C# code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve often found myself telling new programmers that to build good software,
    you have to first build a lot of really bad software and learn from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this statement is somewhat in jest, there is some truth to it: almost
    every developer can recognize code that’s written the wrong way and discover things
    that make it difficult to work with, and doing so helps you write better code
    the next time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When your code is bad, there’s usually a part of you that knows it. You see
    little things that you don’t love: duplicated pieces of code, inconsistencies
    in naming or parameter ordering, passing too many parameters around, methods,
    or even classes that are just too big to manage effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: These symptoms are what we commonly refer to as **code smells**, and we’ll revisit
    them later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond code smells are something called **anti-patterns**, which is code that
    significantly deviates from community recommendations. Unfortunately, not all
    anti-patterns are easy to notice or discover on your own, and some even seem like
    good ideas to individuals or teams until they’re fully explored.
  prefs: []
  type: TYPE_NORMAL
- en: A few common C# anti-patterns I see include throwing and catching an `Exception`
    error instead of a specific type of `Exception` error, not disposing of resources
    that implement `IDisposable`, and inefficient **Language-Integrated Query** (**LINQ**)
    statements. See the *Further reading* section of this chapter for more details
    on these anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: There are far too many anti-patterns to cover in this book, and the established
    practices of .NET development evolve over time. Because of this constant change,
    Visual Studio offers code analysis tools to help spot and fix violations of community
    standards. These tools include code analysis rulesets and built-in **Roslyn Analyzers**,
    which we’ll cover at more length in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259),
    *Code Analysis in* *Visual Studio*.
  prefs: []
  type: TYPE_NORMAL
- en: Not all issues in code are specific to C# code. Many issues in code stem from
    how classes interact, pass data around to one another, manage variables, and are
    generally structured. These issues emerge even in code that you intended to be
    “well structured” as you start to see your systems scale up in size as new capabilities
    are added.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, even new developers have an innate ability to spot code that is
    difficult to follow, requires more work to maintain and expand than it should,
    or involves excessive duplication. These types of issues in code are commonly
    referred to as **code smells**.
  prefs: []
  type: TYPE_NORMAL
- en: What are code smells?
  prefs: []
  type: TYPE_NORMAL
- en: Code smells are prime indicators that your current architecture has some drawbacks
    and refactoring might be in order. Pay attention to these symptoms when you encounter
    them in systems, including the code you write yourself. Learning what makes code
    difficult to work with will help you write better code and refactor existing code
    into better forms.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s move on to talk about writing **SOLID code**, which can help
    you avoid some common code smells and build robust, maintainable, and testable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing SOLID code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SOLID** is an acronym introduced by Michael Feathers summarizing the words
    of Robert C. Martin. The intent of SOLID is to provide developers with a set of
    principles that will guide them toward more maintainable code that resists becoming
    technical debt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The five principles of SOLID code are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility** **Principle** (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-Closed** **Principle** (**OCP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution** **Principle** (**LSP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation** **Principle** (**ISP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion** **Principle** (**DIP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we’ll cover all five of these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Single Responsibility Principle** (**SRP)** says that a class should
    be responsible for one thing and one thing only. Here are a few examples of classes
    that follow the SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: A class responsible for saving application data to a specific file format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database access class dedicated to executing queries against a database table
    or set of tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API controller providing REST methods to interact with flight data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class representing the user interface in a specific part of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes violate the SRP by trying to do more than one type of thing in the same
    class. More formally, if there’s ever more than one reason to modify a class,
    the class violates the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a class is responsible for tracking a set of items in a user
    interface, responding to button presses, parsing user input, and asynchronously
    fetching data, that class very likely violates the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Classes that violate the SRP tend to be frequently modified, grow in complexity
    over time, and be very large classes compared to other classes in the system.
    These classes can be hard to fully understand or adequately test and can become
    brittle and buggy as they grow in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things that I do to help detect violations of the SRP is to have
    a class-level comment talking about what the class is responsible for. For example,
    the following XML comment describes the `FlightScheduler` class from *Part 1*
    of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the responsibility of `FlightScheduler` is clear: it exists to track
    active and pending flights within the system. Reasons for modifying this class
    should be related to the tracking of these flights and not related to other topics.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, I tend to put class-level comments in all classes whenever
    I define a new class to help that class stay focused on its mission over the course
    of its life.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you have a class that already exists and violates the SRP?
  prefs: []
  type: TYPE_NORMAL
- en: When you have a class that’s responsible for multiple things, I like to look
    at everything the class is currently responsible for and group them into related
    groups of members. For example, if a class has 10 fields, 25 methods, and 6 properties,
    I might go through them and try to find common topics that those things address.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `FlightScheduler` class violated the SRP, it might have
    members for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling and canceling flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning crew to flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booking flights for passengers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing seat assignments for passengers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving passengers to different flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating flight-scheduling documentation for management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class, clearly, is responsible for more than one type of thing. In a production
    system, this class might be 2,000 lines long or more and be difficult to fully
    understand and adequately test. Additionally, changes to one area of the class
    might impact other areas in unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the groups of things a class addresses, you can usually identify
    a few key groups. I like to do this and then focus on the largest group of related
    responsibilities that are not clearly related to the core goal of the class. Once
    you identify these groupings, you can extract a new class to manage these aspects.
    Your original class can reference this class or store it as a field if needed,
    or the new class could operate completely independently of the old class.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `FlightScheduler`, I would say that scheduling and canceling
    flights is the core part of the class, and other aspects currently in the class
    might belong more elsewhere. Looking at those other areas, there are several things
    related to managing flight reservations for passengers, so in this case, a `FlightBookingManager`
    class might be introduced to contain these related pieces of logic.
  prefs: []
  type: TYPE_NORMAL
- en: By iteratively introducing new classes from functionality not related to the
    core responsibility of a class, you can shrink large classes down to manageable
    sizes and resist the complexity, quality, and testability issues found in classes
    that ignore the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP doesn’t apply just to classes but can apply to methods as well. A method
    should have a single core task it is responsible for, and that purpose should
    be communicated by the name of the method. When a method is responsible for multiple
    things or starts getting too large, it’s a good sign that you might need to extract
    a method and pull some logic out of the original method to keep the size of the
    method maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, if there were one programming principle I could impart to my younger
    self –or most early/intermediate developers out there, it would be the importance
    of the SRP in keeping your code easy to understand, test, expand, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: My personal guideline is to strive for classes under 200 lines of code long
    and methods under 20 lines of code long, but both can be challenging, and there
    are certainly exceptions to be made to these guidelines depending on the nature
    of the code you’re maintaining – remember that these are principles and guidelines,
    not firm rules or commandments.
  prefs: []
  type: TYPE_NORMAL
- en: '*If you only remember one part of SOLID, remember the SRP; it’s that important
    to the health of your application.* However, there are four more principles to
    explore.'
  prefs: []
  type: TYPE_NORMAL
- en: Open-Closed Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes are said to follow the **Open-Closed Principle (OCP)** when they are
    *open to extension* but *closed* *to modification*.
  prefs: []
  type: TYPE_NORMAL
- en: This principle was originally written for C++ modules, and it doesn’t translate
    as cleanly to C# as some of the other SOLID principles, but this is essentially
    a principle about following **object-oriented programming** (**OOP**) principles
    when designing your classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you build something to follow the OCP, you are designing a class to have
    its behavior extended through other classes inheriting it, through customizable
    properties or parameters, or through composition where you compose your class
    of other objects that change how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using composition was covered in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101)*:
    Object-oriented Refactoring* and involved providing different cargo items for
    a flight.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section will focus on using inheritance to fulfill the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, methods do not allow overriding by default. This means you’ll need to
    explicitly opt-in to allow others to override your methods by declaring them as
    `virtual`.
  prefs: []
  type: TYPE_NORMAL
- en: Counterpoint
  prefs: []
  type: TYPE_NORMAL
- en: I’ve heard some developers argue that declaring methods as `virtual` without
    any classes overriding them is confusing, adds unnecessary keywords to your code,
    and even slightly harms the performance of your code at runtime. All these things
    can be true, but if you are in a scenario where you cannot predict how others
    will use your code and you know they won’t be able to modify your source code,
    marking key methods as `virtual` is usually a good idea. In these scenarios, `virtual`
    adds extra flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that SOLID principles *are guidelines to keep in mind* while building
    software, not firm rules you need to always follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a specific example of the OCP, let’s look at a sample `ItineraryManager`
    class representing information about a passenger’s flight itinerary as they travel
    via Cloudy Skies Airlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a class that tracks the total miles a passenger has accrued, as
    well as the next flight the passenger is scheduled to fly (which may be `null`
    when their trip is completed). The class has two `virtual` methods related to
    handling completed flights as well as canceled flights. Additionally, the class
    has a non-`virtual` method called `AccumulateMiles` that updates the miles the
    passenger has accumulated on this trip.
  prefs: []
  type: TYPE_NORMAL
- en: While this class meets the needs of the airline, let’s say that the airline
    wants to introduce a new logic for reward customers that gives them 100 extra
    miles for every flight they complete and rewards the scheduled mileage for a flight
    when the passenger is involuntarily moved to a new flight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the OCP, we should be able to do this without having to modify our base
    class, assuming that the class is open to modification. It turns out we can do
    this with the following `RewardsItineraryManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Without modifying our base class, we can extend the implementation of `ItineraryManager`
    with our new class that follows a slightly different logic. Thanks to the magic
    of polymorphism, we can use a `RewardsItineraryManager` class anywhere an `ItineraryManager`
    class is accepted, further supporting the closed-to-modification aspect of the
    OCP.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Liskov Substitution Principle** (**LSP**) says that polymorphic code should
    not need to be aware of what specific types of objects it is working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s still a somewhat vague description, so let’s take another look at the
    `FlightCompleted` method from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method takes in a flight that it stores in the `Flight` property. If a
    prior flight was stored in that `Flight` property, the code will call the `AccumulateMiles`
    method with that flight’s `Miles` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application has several classes that inherit from `FlightInfo`: `PassengerFlightInfo`
    and `CargoFlightInfo`. That means our `next` parameter may be any one of these
    three classes – or some other class that inherits from them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LSP says that *any* valid instance of `FlightInfo` should not error when
    you call its `Miles` property (or any other method). For example, this version
    of `CargoFlightInfo` would be a violation of the LSP because its `Miles` property
    errors when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, when following the LSP, the method should not have any reason to
    need to know which subclass of `FlightInfo` it’s dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: Because the LSP is focused on polymorphism, it applies to both class inheritance
    and interface implementations in .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of interfaces, let’s move on to the ISP.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Interface Segregation Principle** (**ISP**) is a fancy way of saying that
    you should prefer many smaller specialized interfaces focused on related capabilities
    over one large interface that encompasses everything your class does.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine we had a `FlightRepository` class that managed database
    access to individual flights. In many systems, this class might implement an `IFlightRepository`
    interface that could be defined as follows with all public members of the class
    as part of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this manages common operations related to flights and provides
    some means of finding information about many flights. In a more real-world example,
    there would likely be many additional methods that would need to be added over
    the years to support new features.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience with .NET code, it is very common to have a large interface
    per major class that includes all public methods in this class. This interface
    is usually named after the class it was based on and exists mostly to support
    testability through **dependency injection** (**DI**), as we’ll touch on in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach is usually a violation of the ISP. Because our interfaces
    are designed around classes instead of discrete sets of capabilities, it becomes
    harder to introduce a new class that meets some of those capabilities but not
    all.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say that Cloudy Skies Airlines wants to integrate with another
    subsidiary airline’s systems. It doesn’t need to add, update, or delete flights,
    but it does want a way of searching for flights. Under the `IFlightRepository`
    interface, the `AddFlight`, `UpdateFlight`, and `CancelFlight` methods would either
    need to do nothing or throw a `NotSupportedException` error when called. By the
    way, throwing the exception on a not-supported method call as part of a larger
    interface would be a violation of the LSP mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of having one large interface per major type, the ISP advocates for
    small interfaces for tightly related capabilities. In the case of `FlightRepository`,
    it’s essentially doing two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding, editing, and deleting flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for existing flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we wanted to introduce interfaces, we could introduce interfaces for these
    separate sets of related capabilities, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our `FlightRepository` class would implement both the `IFlightUpdater`
    interface and the `IFlightProvider` interface. If we wanted to integrate with
    another airline’s systems but didn’t have the ability to modify their flights,
    the `IFlightProvider` interface could be implemented without the `IFlightUpdater`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: By segmenting our interfaces into small interfaces that denote distinct sets
    of capabilities, we make it easier to provide alternative implementations of those
    capabilities as well as test our code later.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve touched on DI a few times now; let’s explore that topic in more detail
    by covering the DIP and rounding out our SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Dependency Inversion Principle** (**DIP**) states that your code should
    generally depend on abstractions instead of on specific implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let’s look at a `FlightBookingManager` class that helps
    passengers book flights. This class needs to register booking requests and send
    confirmation messages for the booking. Here’s its current code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code allows passengers to book a flight by checking if a seat is available,
    then reserving that seat and sending a message using the `_email` field. This
    field is set in the constructor to a new instance of `SpecificMailClient`, which
    is a made-up class representing some very specific implementation of an email
    client. The constructor needs to get a connection string to instantiate this class.
  prefs: []
  type: TYPE_NORMAL
- en: This code violates the DIP because our `FlightBookingManager` class is tightly
    coupled with a specific email client. If we ever wanted to write unit tests against
    this class, the class would always try to send messages to that email client,
    which usually isn’t what you want when testing.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if the organization wanted to change email providers and you needed
    to switch to a different email client, the `FlightBookingManager` class would
    need to change along with anywhere else in the system where we were tightly coupled
    to use the `SpecificMailClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion flips this on its head by having our classes instead depend
    on abstractions of the specific things they depend on. This is usually done by
    depending on a base class such as `EmailClientBase` that is then inherited or
    through taking in an interface such as `IEmailClient` that specific clients can
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We typically take in these dependencies in the constructor as a constructor
    parameter. This version of our `FlightBookingManager` class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of taking in a connection string, we now take in an `IEmailClient`
    class. This means our class doesn’t need to know which implementation it is dealing
    with or how to instantiate an instance of that class, doesn’t need a connection
    string, doesn’t need to change if the specific email provider ever changes, and
    can be tested easier by passing in a fake email client instead of a real one (we’ll
    talk more about this in the next chapter when discussing Moq).
  prefs: []
  type: TYPE_NORMAL
- en: This process of taking in a dependency from something else is called **Dependency
    Inversion** and is often an intimidating topic for new and intermediate developers,
    but at its core, Dependency Inversion is all about classes getting their dependencies
    passed into them instead of having to create specific instances themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Following the DIP leads to more maintainable, flexible, and testable code.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the five principles in SOLID, but we still have a few more design
    principles to cover before closing out the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Considering other architectural principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we close out the chapter, let me share three brief principles that have
    helped me in my own journey toward good software.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the DRY principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Don’t Repeat Yourself** (**DRY**) is an important tenant in software development.
    The DRY principle is oriented around making sure you don’t repeat the same patterns
    in code throughout your application. Code takes a while to write, read, and maintain,
    and bugs inevitably do occur at a certain rate per line of code. As a result,
    you want to strive to solve problems once in a centralized place and then reuse
    that solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some sample code that violates the DRY principle. This code takes
    in a `"CSA1234,CMH,ORD"` and translates it into a `FlightInfo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the logic for parsing in each part of the CSV string is wrapped in
    checks against `null` values and the array of parts is empty. This code is very
    repetitive, and it’s easy to imagine that if a new field got added to the CSV
    data, the developer making the change would just copy and paste those five lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few problems with repeating code patterns such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: It encourages copying and pasting, which tends to produce poor code or results
    in bugs due to things that should have been changed on paste not being changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the logic for parsing an individual field needs to change (for example, to
    protect against empty strings), it now needs to be changed in many places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can fix this by extracting a method containing the logic for parsing fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not only is this new version easier to maintain, but it also results in less
    code overall and helps focus your attention on parts of the logic that are different
    from section to section. This improves the readability of your code while also
    reducing your likelihood of making mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: KISS principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “**Keep it simple, stupid**” (abbreviated as **KISS** and sometimes called “**Keep
    it simple, silly**”) is a principle focused on the complexity of software systems.
    As software engineers, we sometimes overthink things and make things incredibly
    complex when they don’t need to be. KISS encourages you to keep your code and
    classes as simple as possible and expand the complexity only when truly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the more complexity you have in your systems, the longer it takes
    you to add new features, diagnose problems, onboard new team members, and resolve
    customer-facing issues. With more moving parts to your application, there are
    also more things that can break, meaning that complexity has a real chance of
    creating customer-facing issues—all for potential solutions to problems your organization
    won’t have for a few years.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity tends to grow over time and rarely ever decreases (particularly in
    database schemas). Keep it simple until you see a pressing and compelling reason
    to add more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding high cohesion and low coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let’s close the chapter out by reviewing two terms you’ll hear occasionally
    in software engineering: **cohesion** and **coupling**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cohesion has to do with how related different parts of the class are to the
    same thing. In a high-cohesion class, almost all parts of the class are oriented
    on the same types of capabilities. Let’s look again at the `IFlightUpdater` interface
    from earlier for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A class that implemented everything in this interface and added no other members
    would be a good example of *high cohesion* because all members in this interface
    are related to working with the same type of item. A *low-cohesion* class would
    start with these methods but also add many methods related to booking flights,
    generating reports, searching data, or other capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Classes that have low cohesion usually also violate the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling refers to how tightly paired together with other classes a single class
    is. The more classes an individual class needs to know about to do its job, the
    more tightly coupled it is. Classes with higher coupling are harder to test due
    to a larger number of dependencies and need to be modified more frequently as
    their related classes evolve over time.
  prefs: []
  type: TYPE_NORMAL
- en: The DIP provides a great way for classes to reduce their coupling.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you hear people talk about wanting high cohesion and low coupling,
    they’re advocating for classes that are very tightly focused on a specific area
    and rely on as few other classes as possible to achieve that objective. When this
    combination is met, classes tend to be very focused and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed code smells and anti-patterns. The right design
    principles can help keep your code focused and minimal and slow the rate at which
    it naturally accumulates complexity. This helps keep your code in good form and
    resist accumulating technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: The most common maxim for quality programming is SOLID, following the Single
    Responsibility Principle (SRP), making code open for extension while being closed
    to modification, the Liskov Substitution Principle (LSP) advocating for low coupling
    with polymorphic code, the interface segregation principle focused on several
    smaller interfaces over one larger interface, and the Dependency Inversion Principle
    (DIP) which talks about reducing coupling by having classes take in the things
    they need from outside of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established how to write SOLID code, we’ll explore some advanced
    testing techniques that can help test code built using these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the SRP affect cohesion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which areas of your code violate the SRP or DRY?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of DI? How does it affect coupling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about materials discussed in this chapter at
    these URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SOLID Principles in C# with* *Examples*: [https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/](https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*15 of the Worst C# Anti-Patterns Developers Keep Using (And How to Avoid*
    *Them)*:[https://methodpoet.com/worst-anti-patterns/](https://methodpoet.com/worst-anti-patterns/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Top 10 Dotnet Exception Anti-Patterns in* *C#*: [https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/](https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using objects that implement* *IDisposable*: [https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LINQ: Caveats and* *pitfalls*: [https://dev.to/samfieldscc/linq-37k3](https://dev.to/samfieldscc/linq-37k3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
