["```cs\n    using System;\n    using System.Threading;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    private delegate string RunOnThreadPool(out int threadId);\n\n    private static void Callback(IAsyncResult ar)\n    {\n      WriteLine(\"Starting a callback...\");\n      WriteLine($\"State passed to a callbak: {ar.AsyncState}\");\n      WriteLine($\"Is thread pool thread: {CurrentThread.IsThreadPoolThread}\");\n      WriteLine($\"Thread pool worker thread id: {CurrentThread.ManagedThreadId}\");\n    }\n\n    private static string Test(out int threadId)\n    {\n      WriteLine(\"Starting...\");\n      WriteLine($\"Is thread pool thread: {CurrentThread.IsThreadPoolThread}\");\n      Sleep(TimeSpan.FromSeconds(2));\n      threadId = CurrentThread.ManagedThreadId;\n      return $\"Thread pool worker thread id was: {threadId}\";\n    }\n    ```", "```cs\n    int threadId = 0;\n\n    RunOnThreadPool poolDelegate = Test;\n\n    var t = new Thread(() => Test(out threadId));\n    t.Start();\n    t.Join();\n\n    WriteLine($\"Thread id: {threadId}\");\n\n    IAsyncResult r = poolDelegate.BeginInvoke(out threadId, Callback, \"a delegate asynchronous call\");\n    r.AsyncWaitHandle.WaitOne();\n\n    string result = poolDelegate.EndInvoke(out threadId, r);\n\n    WriteLine($\"Thread pool worker thread id: {threadId}\");\n    WriteLine(result);\n\n    Sleep(TimeSpan.FromSeconds(2));\n    ```", "```cs\n    using System;\n    using System.Threading;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    private static void AsyncOperation(object state)\n    {\n      WriteLine($\"Operation state: {state ?? \"(null)\"}\");\n      WriteLine($\"Worker thread id: {CurrentThread.ManagedThreadId}\");\n      Sleep(TimeSpan.FromSeconds(2));\n    }\n    ```", "```cs\n    const int x = 1;\n    const int y = 2;\n    const string lambdaState = \"lambda state 2\";\n\n    ThreadPool.QueueUserWorkItem(AsyncOperation);\n    Sleep(TimeSpan.FromSeconds(1));\n\n    ThreadPool.QueueUserWorkItem(AsyncOperation, \"async state\");\n    Sleep(TimeSpan.FromSeconds(1));\n\n    ThreadPool.QueueUserWorkItem( state => {\n      WriteLine($\"Operation state: {state}\");\n      WriteLine($\"Worker thread id: {CurrentThread.ManagedThreadId}\");\n      Sleep(TimeSpan.FromSeconds(2));\n    }, \"lambda state\");\n\n    ThreadPool.QueueUserWorkItem( _ =>\n    {\n      WriteLine($\"Operation state: {x + y}, {lambdaState}\");\n      WriteLine($\"Worker thread id: {CurrentThread.ManagedThreadId}\");\n      Sleep(TimeSpan.FromSeconds(2));\n    }, \"lambda state\");\n\n    Sleep(TimeSpan.FromSeconds(2));\n    ```", "```cs\n    using System;\n    using System.Diagnostics;\n    using System.Threading;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    static void UseThreads(int numberOfOperations)\n    {\n      using (var countdown = new CountdownEvent(numberOfOperations))\n      {\n        WriteLine(\"Scheduling work by creating threads\");\n        for (int i = 0; i < numberOfOperations; i++)\n        {\n          var thread = new Thread(() =>\n          {\n            Write($\"{CurrentThread.ManagedThreadId},\");\n            Sleep(TimeSpan.FromSeconds(0.1));\n            countdown.Signal();\n          });\n          thread.Start();\n        }\n        countdown.Wait();\n        WriteLine();\n      }\n    }\n\n    static void UseThreadPool(int numberOfOperations)\n    {\n      using (var countdown = new CountdownEvent(numberOfOperations))\n      {\n        WriteLine(\"Starting work on a threadpool\");\n        for (int i = 0; i < numberOfOperations; i++)\n        {\n          ThreadPool.QueueUserWorkItem( _ => \n          {\n            Write($\"{CurrentThread.ManagedThreadId},\");\n            Sleep(TimeSpan.FromSeconds(0.1));\n            countdown.Signal();\n          });\n        }\n        countdown.Wait();\n        WriteLine();\n      }\n    }\n    ```", "```cs\n    const int numberOfOperations = 500;\n    var sw = new Stopwatch();\n    sw.Start();\n    UseThreads(numberOfOperations);\n    sw.Stop();\n    WriteLine($\"Execution time using threads: {sw.ElapsedMilliseconds}\");\n\n    sw.Reset();\n    sw.Start();\n    UseThreadPool(numberOfOperations);\n    sw.Stop();\n    WriteLine($\"Execution time using the thread pool: {sw.ElapsedMilliseconds}\");\n    ```", "```cs\n    using System;\n    using System.Threading;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    static void AsyncOperation1(CancellationToken token)\n    {\n      WriteLine(\"Starting the first task\");\n      for (int i = 0; i < 5; i++)\n      {\n        if (token.IsCancellationRequested)\n        {\n          WriteLine(\"The first task has been canceled.\");\n          return;\n        }\n        Sleep(TimeSpan.FromSeconds(1));\n      }\n      WriteLine(\"The first task has completed succesfully\");\n    }\n\n    static void AsyncOperation2(CancellationToken token)\n    {\n      try\n      {\n        WriteLine(\"Starting the second task\");\n\n        for (int i = 0; i < 5; i++)\n        {\n          token.ThrowIfCancellationRequested();\n          Sleep(TimeSpan.FromSeconds(1));\n        }\n        WriteLine(\"The second task has completed succesfully\");\n      }\n      catch (OperationCanceledException)\n      {\n        WriteLine(\"The second task has been canceled.\");\n      }\n    }\n\n    static void AsyncOperation3(CancellationToken token)\n    {\n      bool cancellationFlag = false;\n      token.Register(() => cancellationFlag = true);\n      WriteLine(\"Starting the third task\");\n      for (int i = 0; i < 5; i++)\n      {\n        if (cancellationFlag)\n        {\n          WriteLine(\"The third task has been canceled.\");\n          return;\n        }\n        Sleep(TimeSpan.FromSeconds(1));\n      }\n      WriteLine(\"The third task has completed succesfully\");\n    }\n    ```", "```cs\n    using (var cts = new CancellationTokenSource())\n    {\n      CancellationToken token = cts.Token;\n      ThreadPool.QueueUserWorkItem(_ => AsyncOperation1(token));\n      Sleep(TimeSpan.FromSeconds(2));\n      cts.Cancel();\n    }\n\n    using (var cts = new CancellationTokenSource())\n    {\n      CancellationToken token = cts.Token;\n      ThreadPool.QueueUserWorkItem(_ => AsyncOperation2(token));\n      Sleep(TimeSpan.FromSeconds(2));\n      cts.Cancel();\n    }\n\n    using (var cts = new CancellationTokenSource())\n    {\n      CancellationToken token = cts.Token;\n      ThreadPool.QueueUserWorkItem(_ => AsyncOperation3(token));\n      Sleep(TimeSpan.FromSeconds(2));\n      cts.Cancel();\n    }\n\n    Sleep(TimeSpan.FromSeconds(2));\n    ```", "```cs\n    using System;\n    using System.Threading;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    static void RunOperations(TimeSpan workerOperationTimeout)\n    {\n      using (var evt = new ManualResetEvent(false))\n      using (var cts = new CancellationTokenSource())\n      {\n        WriteLine(\"Registering timeout operation...\");\n        var worker = ThreadPool.RegisterWaitForSingleObject(evt\n                    , (state, isTimedOut) => WorkerOperationWait(cts, isTimedOut)\n                    , null\n                    , workerOperationTimeout\n                    , true);\n\n        WriteLine(\"Starting long running operation...\");\n        ThreadPool.QueueUserWorkItem(_ => WorkerOperation(cts.Token, evt));\n\n        Sleep(workerOperationTimeout.Add(TimeSpan.FromSeconds(2)));\n        worker.Unregister(evt);\n      }\n    }\n\n    static void WorkerOperation(CancellationToken token, ManualResetEvent evt)\n    {\n      for(int i = 0; i < 6; i++)\n      {\n        if (token.IsCancellationRequested)\n        {\n          return;\n        }\n        Sleep(TimeSpan.FromSeconds(1));\n      }\n      evt.Set();\n    }\n\n    static void WorkerOperationWait(CancellationTokenSource cts, bool isTimedOut)\n    {\n      if (isTimedOut)\n      {\n        cts.Cancel();\n        WriteLine(\"Worker operation timed out and was canceled.\");\n      }\n      else\n      {\n        WriteLine(\"Worker operation succeded.\");\n      }\n    }\n    ```", "```cs\n    RunOperations(TimeSpan.FromSeconds(5));\n    RunOperations(TimeSpan.FromSeconds(7));\n    ```", "```cs\n    using System;\n    using System.Threading;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    static Timer _timer;\n\n    static void TimerOperation(DateTime start)\n    {\n      TimeSpan elapsed = DateTime.Now - start;\n      WriteLine($\"{elapsed.Seconds} seconds from {start}. \" +\n        $\"Timer thread pool thread id: {CurrentThread.ManagedThreadId}\");\n    }\n    ```", "```cs\n    WriteLine(\"Press 'Enter' to stop the timer...\");\n    DateTime start = DateTime.Now;\n    _timer = new Timer(_ => TimerOperation(start), null\n        , TimeSpan.FromSeconds(1)\n        , TimeSpan.FromSeconds(2));\n    try\n    {\n      Sleep(TimeSpan.FromSeconds(6));\n\n      _timer.Change(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(4));\n\n      ReadLine();\n    }\n    finally\n    {\n      _timer.Dispose();\n    }\n    ```", "```cs\n    using System;\n    using System.ComponentModel;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    static void Worker_DoWork(object sender, DoWorkEventArgs e)\n    {\n      WriteLine($\"DoWork thread pool thread id: {CurrentThread.ManagedThreadId}\");\n      var bw = (BackgroundWorker) sender;\n      for (int i = 1; i <= 100; i++)\n      {\n        if (bw.CancellationPending)\n        {\n          e.Cancel = true;\n          return;\n        }\n        if (i%10 == 0)\n        {\n          bw.ReportProgress(i);\n        }\n\n        Sleep(TimeSpan.FromSeconds(0.1));\n      }\n\n      e.Result = 42;\n    }\n\n    static void Worker_ProgressChanged(object sender, ProgressChangedEventArgs e)\n    {\n      WriteLine($\"{e.ProgressPercentage}% completed. \" +\n        $\"Progress thread pool thread id: {CurrentThread.ManagedThreadId}\");\n    }\n\n    static void Worker_Completed(object sender, RunWorkerCompletedEventArgs e)\n    {\n      WriteLine($\"Completed thread pool thread id: {CurrentThread.ManagedThreadId}\");\n      if (e.Error != null)\n      {\n        WriteLine($\"Exception {e.Error.Message} has occured.\");\n      }\n      else if (e.Cancelled)\n      {\n        WriteLine($\"Operation has been canceled.\");\n      }\n      else\n      {\n        WriteLine($\"The answer is: {e.Result}\");\n      }\n    }\n    ```", "```cs\n    var bw = new BackgroundWorker();\n    bw.WorkerReportsProgress = true;\n    bw.WorkerSupportsCancellation = true;\n\n    bw.DoWork += Worker_DoWork;\n    bw.ProgressChanged += Worker_ProgressChanged;\n    bw.RunWorkerCompleted += Worker_Completed;\n\n    bw.RunWorkerAsync();\n\n    WriteLine(\"Press C to cancel work\");\n    do\n    {\n      if (ReadKey(true).KeyChar == 'C')\n      {\n        bw.CancelAsync();\n      }\n    }\n    while(bw.IsBusy);\n    ```"]