- en: Implementing the Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we went through a different level of knowledge crunching
    and domain analysis. We used EventStorming as our primary tool, so, as a result
    of our efforts, we got plenty of paper rolls, with lots of colorful sticky notes
    on them. But how can we make some working code from it? That is a good question,
    and this is precisely what we will start doing when moving along in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a basis for our domain model implemented
    in code. We will go through different styles of performing the behavior in domain
    entities and also write some tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project for the domain model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add domain objects to the new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the entities and value objects are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure that the domain model is always in a valid state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will provide guidelines to do some hands-on work. To follow up
    with that, you will need to have the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core 2.2.203 or higher ([https://www.asp.net/](https://www.asp.net/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2017 or higher ([https://www.visualstudio.com/vs/](https://www.visualstudio.com/vs/)),
    or JetBrains Rider ([https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no particular requirement on a platform since .NET Core, and the tooling
    is available almost everywhere. Throughout this book, I will be using Rider on
    macOS. Initial screenshots will be from Visual Studio 2017 for Windows since most
    readers would be using this IDE. Some dialog boxes vary significantly between
    Visual Studio for Windows, Visual Studio for Mac, and Rider.
  prefs: []
  type: TYPE_NORMAL
- en: I will be using some features of C# 8.0 in the code, so it is necessary to use
    .**NET Core SDK 2.2.203** or higher.
  prefs: []
  type: TYPE_NORMAL
- en: I assume that you are familiar with the tool that you are using and with the
    .NET Stack in general, so you know how to create projects, build them and execute
    applications in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a new project and add a domain project to it.
  prefs: []
  type: TYPE_NORMAL
- en: Since we plan to implement a web application, we will consider this from the
    beginning and will use a web application template. We will also add some projects
    to host different parts of our system and tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't familiar with tools for .NET, you can always check Mapt, the extensive
    library of Packt books and video courses, and use materials from there to improve
    your skills. In this book, we assume that readers have an adequate level of knowledge
    of C# and the tools to develop applications using .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Creating projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with an empty project. You need to create a .NET Core web application
    and don't forget to enable the creation of a Git repository so it can keep a history
    of your changes.
  prefs: []
  type: TYPE_NORMAL
- en: We would expect our system to get more substantial, but we start small. Let's
    call the solution `Marketplace`, and our first project would be called just that.
    The type of project to create is an ASP.NET Core Web Application. This project
    is our startup, which will be executed by the .NET runtime. You need to choose
    the  Empty project type for the new Web API project because we won't be using
    Razor or SPA (single page application) templates.
  prefs: []
  type: TYPE_NORMAL
- en: We already discussed that the domain model should not have dependencies on infrastructure.
    In general, it should not have references to anything but standard language types,
    itself, and some set of base classes and interfaces, if necessary. To enforce
    this, let's create a separate project where we will put all our domain objects.
    Add one more project to the solution and call it `Marketplace.Domain`. This project
    will not be executed by itself, so the project type should be Class Library (.NET
    Standard) and don't forget to change the framework for it to netstandard2.0 (or
    later). The .NET Standard is the default for class libraries, but feel free to
    use ASP.NET Core target framework as well if you aren't planning to use your library
    in the legacy .NET Framework applications.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to add one more project for unit tests. You can do it by adding
    a project to your solution, which would be called `Marketplace.Tests`. The project
    type is a unit test project, and type is xUnit since we will be using xUnit.net
    testing framework for our tests in this book. The xUnit.NET test project is one
    of the default test project templates of the ASP.NET Core SDK. Remember to add
    a reference to the `Marketplace.Domain` project to the test project, since we'll
    be mostly testing our domain code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution should now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06b99eb9-e0d9-40d7-bdd8-2b7ea7bed559.png)'
  prefs: []
  type: TYPE_IMG
- en: A glimpse of the solution structure
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to remove the `wwwroot` and `Properties` folders, `Class1.cs`
    and `UnitTest1.cs` files, since we will create new classes from scratch and we
    do not need empty folders to hang around.
  prefs: []
  type: TYPE_NORMAL
- en: The framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need somewhere to place *this set of base classes and interfaces* mentioned
    in the previous section. We might dispute whether these things are required at
    all. They are not required to start a simple `Hello World` style project, but,
    as we go along, we will need to create more abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will need some components that will allow our domain model to work
    with things like database, message bus, web server, and so on. According to onion
    architecture principles, these are** adapters**. Our project, in the end, will
    need to have a collection of adapters for all pieces of infrastructure that are
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: You might rightfully ask—are we going to build a framework? Aren't frameworks
    considered evil and shouldn't they be avoided? Well, we should take everything
    with a grain of salt and having a set of useful abstractions for our domain object
    and infrastructure would greatly help us while moving along. Also, we definitely
    will need to build some of the adapters, and although these can be separated in
    their own libraries, which will connect to our abstractions (hence ports and adapters),
    for the reason of simplicity, we will put most of these things in one project,
    and this project will be called `Marketplace.Framework`. You can choose any other
    name for this project if you don't like the name `Framework`, but in this book,
    we will be referencing it a lot, so I hope you don't get confused.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the abstractions and implementations in this framework would be production
    ready by the end of this book. And unlike third-party frameworks, you keep full
    control of what is inside it and how it works, so this should make it a milder
    evil, even if you don't like frameworks at all.
  prefs: []
  type: TYPE_NORMAL
- en: Many DDD practitioners keep reciting the mantra *you don't need DDD framework*,
    and this is partially true, but people always need to have some baseline for their
    applications to speed up the development. We use the .NET Framework, built by
    Microsoft, rather than creating all these classes from scratch for every project.
    When we get to the point of having a set of useful abstractions and components
    in our framework, we can use it, or something similar to it, in some other project
    and be entirely in control.
  prefs: []
  type: TYPE_NORMAL
- en: So, to finish up this section, add a class library project to the same solution.
    The framework for it should be netstandard2.0 (or later), just as it was for the
    `Marketplace.Domain` project. Call this new project `Marketplace.Framework`
  prefs: []
  type: TYPE_NORMAL
- en: Transferring the model to code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we aren't doing a `Hello World` exercise, we won't be using the executable
    project for a while. Instead, we will concentrate on writing things inside the
    domain project, adding some practical classes and interfaces to the framework
    projects, and writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to identify which building blocks our implementation will be
    based on. These building blocks are often referenced as **Domain-Driven Design**
    (**DDD**) tactical patterns, as opposed to DDD strategic patterns. Some even say
    that tactical patterns can be ignored in favor of strategic patterns. Although
    I agree that Ubiquitous Language, Bounded Context, and Context Map are the essential
    parts of DDD, I still believe that some tactical patterns are useful and bring
    clarity and common language for the implementation. This book is not a collection
    of tactical DDD patterns, and relevant concepts will only be used when necessary
    to implement the model.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get back to our EventStorming session and look at part of our model,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3376c726-aa18-4964-9d98-ed835ed7cd00.png)'
  prefs: []
  type: TYPE_IMG
- en: The core domain modeled with sticky notes
  prefs: []
  type: TYPE_NORMAL
- en: There is a repetition in all those commands. Can you see it? All those commands
    are being executed on something that is called a **Classified Ad**. Also, if you
    recall all those conversations with domain experts, our team members frequently
    referred to this term when talking about the business in general, and also about
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mainly, we have an entity here. Entities represent unique objects of the same
    type. In addition to classified ads, we might expect our system to hold information
    about sellers and buyers, and those might be entities too, apart from being just
    roles in the system. It is because we need to identify those people, so we need
    to have something unique, like username or email address, to understand who is
    who. The same is valid for a classified ad. Imagine ads like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8866b7-3a3f-4597-972b-c469605f5798.png)'
  prefs: []
  type: TYPE_IMG
- en: Draft sketch of the user interface
  prefs: []
  type: TYPE_NORMAL
- en: Both ads are the same if we ignore who is selling and for what price. But, most
    probably, these are two different objects. Because of the mass-production of IKEA,
    there is a significant chance that multiple similarly used objects are being sold
    at the same time, but for us, those objects are different. It is because we are
    not using object properties, like model and size, to find out if two objects are
    identical. In our system, these objects will be represented in two different classified
    ads and will have separate identities.
  prefs: []
  type: TYPE_NORMAL
- en: Identities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned a username or email as an identity of users in the system, but
    what can be used as an identity for objects? In real life, many objects are already
    identified. The most common identity is an item serial number. Complex objects
    like smartphones, TV sets, computers, and cars have unique identifiers that help
    manufacturers to know in what configuration these objects were produced, and therefore,
    they can provide better support. Also, due to the significant price of such objects,
    they are usually tracked individually.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we talk about our system, most of the time we need to use our
    own identity. The only important rule, really, is that all entities need to be
    uniquely identified. There are a few ways to get such an identity, and you might
    already be familiar with some. Probably the most frequently used method to get
    unique identities today (later referenced as **IDs**) is to use unique database
    keys. It is because most systems out there are data-oriented and designed with
    persistence-first in mind. Such a system will not work without persisting stuff
    to a particular database. Such a method has at least one definite advantage—such
    IDs are usually numeric and incremental, so it is straightforward to dictate such
    an ID over the phone. But the most significant disadvantage comes from the ID
    source—the database must be present to get such an identity, even if later in
    the flow, the system will decide not to accept the object and drop it instead,
    so it never gets persisted. Most of the experienced developers have seen weird
    constructs in the code where an empty or dummy row is being inserted into some
    table to get an object ID, and later, such a row either needs to be populated
    with real values or removed. Such an approach creates a whole load of issues,
    and we will not be using it.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we will use generated unique IDs. Because we would prefer not to use
    any infrastructure to create our IDs, we will use one reliable method and identity
    type—a **globally unique identifier** (**GUID**), more commonly known as a **universally
    unique identifier** (**UUID**). Such an ID can be generated using the current
    time and some information about the computer, where it is produced. There is a
    very high probability that such an ID is globally unique. When using GUIDs, we
    can generate identities for objects before touching any infrastructure and therefore,
    for example, create references to an object that only exists in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Classified ad entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have understood from our EventStorming model, we most probably need an
    entity to represent a classified ad. It seems to be one of the central concepts
    of our system. We spent a great deal of time discussing our model with domain
    experts, and this term kept coming up in the conversation. It is a perfect indicator
    that we have identified some vital domain concept also, because we keep getting
    a repeated pattern when one command results in one event, and we keep having a
    *classified ad* as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entities are represented in code as objects, and, therefore, we need a class
    so we can create instances of such a class. Here is our first attempt to create
    a class to represent a classified ad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You might feel puzzled about this class, and you'd be right to question this
    kind of entity implementation. It looks like a property bag, and the only difference
    with a **DTO** (short for **data transfer object**) here, is that this class only
    has one property, and all other details are represented by private fields. This
    class will compile, but it is practically unusable because even the single public
    property can only be set from inside the class, but we have not exposed any way
    of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: However, despite being useless, this implementation demonstrates two essential
    principles that we need to keep in mind while going further. First, all entities
    need to have an ID, and it must be accessible from outside the entity. Second,
    since we are using an object-oriented language, we shall try to encapsulate as
    much as we can, and keep our internals safe, and preferably invisible to the outside
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to instantiate this class correctly, let''s create a constructor
    that will at least allow us to set the entity `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following things are added here:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we only set the `Id` property value in the constructor, we can make it
    a read-only property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating an instance of `ClassifiedAd`, we must supply `id`, because there
    is no parameterless constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The supplied `id` must be valid. Otherwise, the constructor will throw an argument
    exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right here, we enforced the rule that our entity can only be created giving
    a valid set of arguments (currently only one), and any created entity of the given
    type will be, by definition, legitimate. You might be concerned that a classified
    ad without some human-readable attributes, like title and price, is in fact not
    correct, but this concern is not technical. The business might decide that this
    is indeed a valid entity.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing for us to do is to figure out what we can tell our entity to
    do. Remember, we need to design (and implement) behavior-first. The only reason
    for us to add those `private` fields to the entity was actually to support the
    behavior. As we discussed before, each action that is performed in the system
    amends the system state, and those `private` fields represent just that—state.
    But again, encapsulation being enforced, we shall not allow manipulating the entity
    state by changing property values from outside the entity; this will lead us to
    the dusty land of CRUD. Let''s see how we can breathe life into the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have added three straightforward methods, and you might feel a bit disappointed
    because these are property setters (not even glorified). But, what we do here
    is express the idea of using Ubiquitous Language in code, and transfer words from
    sticky notes (commands in this case) to methods.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just a start. In the following section, we will look deeper
    into our entity implementation, and find out how methods that express behavior
    can become more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we were checking the entity constructor parameter to
    be valid to ensure the newly created entity object is also correct. We applied
    a constraint, which does not allow creating a new entity without specifying the
    valid parameter value. By doing this, we are guarding our domain model against
    getting objects that aren't valid. It is one of the essential functions of the
    domain model as such, and since we are embracing *the behavior-first* approach,
    this type of code needs to be a part of the domain model implementation and not
    outsourced to external layers, like UI or application service layer. Of course,
    since our domain model is the system core, it takes a few hops for data to move
    from the user interface to domain objects. It is a valid approach to do a preliminary
    quality check on the data that tries to enter the domain model before it does.
    It improves the user experience due to much faster feedback. However, the ultimate
    control is always performed inside the domain model itself, since it shall never
    come to an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints for input values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have recognized some flaws in the entity implementation in the previous
    section. There are quite a few of them at the moment, but let''s look at the most
    obvious one. What is sorely missing here is the owner ID. It is hard to believe
    we can allow having ads without anyone owning them. How in this case will we understand
    who can modify the content of such ads? Plus, we already have the `_ownerId` field
    in this class. So, let''s add one more parameter to the constructor to enforce
    this constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From this moment on, we will not list the whole class, but just a part of it
    that is being changed.
  prefs: []
  type: TYPE_NORMAL
- en: We have not only added one more parameter but also added one more check. So
    now, our entity is guaranteed to be valid after it is created, since the client
    must supply both the ad ID and the owner ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that creates a classified ad entity would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are adding more parameters to the entity constructor, and the
    constructor itself grows since we add more checks for these parameters. In the
    end, it is not very easy to understand what is going on, because many rules are
    mixed in one large chunk of code. Also, it is quite evident that we are not checking
    core complex rules, which involve multiple properties of the entity. In our case,
    all we control is that each parameter has a value. This approach is not wrong
    but is also not ideal. Instead, we can check the validity of such values, even
    before reaching the entity constructor, using **value objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Value object pattern is not unique to DDD, but it probably became most popular
    within the DDD community. It probably happened due to such characteristics of
    value objects as expressiveness and strong encapsulation. Fundamentally, value
    objects allow declaring entity properties with explicit types that use Ubiquitous
    Language. Besides, such objects can explicitly define how they can be created
    and what operations can be performed within and between them. It is a perfect
    example of making implicit, explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look closer at what a value object is, by creating one in our code. Before,
    we were taking the `ownerId` parameter in the entity constructor, and checking
    it to have a non-default GUID. What we want here is a user ID, since we know that
    the ad owner is one of our users, because people need to be registered in the
    system before creating classified ads. It means that we can embrace the type system
    and make implicit more explicit by using a new type called `UserId`, instead of
    using `Guid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new class in the `Marketplace.Domain` project and call it `UserId`.
    The initial code for this class would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we moved the assertion that the identity value is not an empty
    GUID, to the `UserId` constructor. It means that we can change our entity constructor
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our entity has no check for the `ownerId`, since, by receiving the argument
    of type `UserId`, we guarantee that the value is valid. Of course, we do not check
    here if the supplied GUID points to a valid user, but this was not our intention,
    at least for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we still have one more check for the argument validity in the entity
    constructor. Let''s make the entity `id` type a value object too by adding a `ClassifiedAdId`
    class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our constructor has no checks at all, and it still makes a valid entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we move to the application layer, where our entity would be constructed,
    we could imagine that calls to the constructor would look like this (assuming
    that `id` and `ownerId` are of type `Guid`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code clearly says that we are sending the classified ad ID first,
    and the owner ID second to the entity constructor. When we use `Guid` as the type
    for both parameters, if we accidentally change the order of parameters, our application
    would still compile, but of course, our entities will be constructed incorrectly,
    and the whole system would break somewhere deep down the execution pipeline. Strongly
    typed parameters of value object types force the compiler to engage type checking,
    and if we messed up arguments, the code won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: But value objects aren't just wrapper types around primitive types. As we learned
    before, entities are considered equal if their identities are the same. Value
    objects are different since their equality is establishing by value, hence the
    pattern name. A classical example of a value object is money. If we take two €5
    banknotes, they represent two different entities, since they are in fact two distinctly
    different objects, and even have unique numbers printed on them. But for payment,
    both are entirely identical, since they have the same value of €5.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do we represent it in code? Let''s create the `Money` class and give
    it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a simple test to check whether two objects of the `Money`
    type are equal if the amount is equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this test fails because a class instance is a reference object, and
    two instances of the same class are different objects, no matter what their properties
    and fields contain. We can conclude that neither the `Money` class nor our `UserId`
    and `ClassifiedAdId` classes can represent value objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the `Money` class closer to proper value object type, we need it to
    implement the `IEquatable` interface. The class instance will need to be compared
    with instances of the same type, so we need `Money` to implement `IEquatable<Money>`.
    If you add this interface to the class, in Rider, and in Visual Studio with Resharper,
    there will be an option to generate the necessary code automatically using the
    Generate equality to members refactoring suggestion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb68a9dd-bc5b-4174-8732-b9762ca373e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Generate equality members in Rider
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if the Overload equality operators option is enabled, code for implicit
    equality operators will also be created. So, the code for our `Money` class will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we run the same test now, it will pass, because, when we call `Assert.Equals(firstAmount,
    secondAmount)`, the preceding code will compare the values of the `_value` field
    for both instances when these values are the same. Because we also created code
    for implicit equality operators, we can use comparisons like `if (firstAmount
    == secondAmount)` in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine we need all this code for each value object type we create. Yes,
    with some nice auto-magic from Resharper, we can generate this code very quickly,
    and then hide it in a region, which will always be collapsed. But, if we decide
    to add one more attribute to the value object, we will need to reopen this region
    and add this new attribute in several places.
  prefs: []
  type: TYPE_NORMAL
- en: We can reduce the amount of boilerplate code, and provide the ability for equality
    comparison methods to be dynamic, by using a base class. There are at least two
    ways to create such a base class. One includes using reflections to discover all
    fields in the implementation type, and use all of them for equality purposes.
    Another method involves creating an abstract method that needs to be overridden
    in each implementation to provide specific values that are used for equality.
    While the first method allows writing less code since all fields are automatically
    discovered and used, the second method allows us to choose which attributes will
    be used for equality.
  prefs: []
  type: TYPE_NORMAL
- en: In one of the next versions of C#, which might already be available when you
    read this book, the new feature will be introduced that is called record types.
    On a high level, record types will be similar to F# records. Using record types,
    declaration of value objects would become very short, and all boilerplate code
    for equality (and more) will be generated by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, declaring the `Money` type earlier would be done in one line like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public class Money(double amount);`'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, I use classes, which are reference types, unlike structs,
    which are value types. It means that those value objects aren't completely following
    the immutability principle. We, however, will try to do as much as we can to ensure
    that these objects cannot be changed freely, but using the assignment operator
    for the object instance will only assign the reference to the original object,
    which is different for value types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the abstract base class in the `Marketplace.Framework` project, we can
    now refactor the `Money` class to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the boilerplate code is now moved to the base class, and
    we get back to essentials. The test, however, still passes because of the proper
    equality implementation in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only had straightforward rules in value objects, but when we
    work with money, we should be adding one useful check. Rarely, if we talk about
    money, we mean a negative amount. Yes, such amounts exist in accounting, but we
    are not building an accounting system. In our domain, classified ads need to have
    a price, and the price cannot be negative, as our domain expert explained. So,
    we can represent this rule in a new value object, shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Thus, despite our base, `Money` class still allows its amount to be negative
    or zero; the price will always be positive and, as a result, valid in our domain.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about immutability, we must ensure that there are no methods that our
    value objects expose, which allow changing field values inside these objects.
    If we want to do some operation on a value object instance, it needs to produce
    a new instance of the same type, but with a new value. By doing this, we ensure
    that the original object will retain its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `Money` example and add some useful operations to it, keeping
    immutability in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a sum of €1 coin and two €2 coins, the total value is €5\. If we
    compare it with a banknote of €5, its value is the same. Since we aren''t interested
    in shape, size, and weight of those monetary instruments and we are only interested
    in value, we can conclude that those two have equal value. Our preceding new `Money`
    class lets us express this statement in the test code, which will be green when
    we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finally rewrite our identity classes to proper value object implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's have a more in-depth look at more advanced ways to instantiate value
    objects and entities.
  prefs: []
  type: TYPE_NORMAL
- en: Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can implement more value objects that will be used for other fields
    in our entity. Remember, we have three methods in the entity that expressed its
    basic behaviour—`SetTitle(string)`, `UpdateText(string)`, and `UpdatePrice(double)`.
    The easiest one to deal with would be the last one since we already have a value
    object type for it—`Price`. Let's focus on the other two methods and see what
    constraints we can implement using value objects instead of plain strings for
    ad title and text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete value object class for the classified ad title could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through it to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use our abstract `Value<T>` base class to remove the boilerplate code,
    just as we did before in the identity and `price` value objects. Then, skipping
    the `static` method, you can see the `private` value field, again, like in other
    value objects we have created before. However, then we have a private constructor,
    which accepts a regular string argument. Inside the constructor, we enforce the
    constraint that the ad title cannot be longer than `100` characters. It will not
    allow us to spread such checks to other parts of the application. You might ask
    the question—why is the constructor `private` in this case? It is because we might
    have different sources of data for the title string, and, before calling the constructor,
    we might need to take some additional operations. It is not done in the preceding
    code snippet just yet, but we will add such functionality later. The next question
    would be—how do we construct new instances of this class if the constructor is
    `private`? It is where the **factory** pattern becomes useful.
  prefs: []
  type: TYPE_NORMAL
- en: Factories are functions that are used to create instances of domain objects,
    which are, by definition, valid. Factory functions can execute some logic to construct
    valid instances, and such logic could be different per factory. It is why we would
    expect to have multiple factory methods in one value object class, although this
    is not a requirement. Factories also help to make implicit things more explicit
    by using proper naming. In our `ClassifiedAdTitle` class, we only have one factory,
    which converts the string to the value object instance. It is quite clear what
    it does and what kind of argument it accepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use factories to handle different use cases. Imagine
    that we get a requirement for ad title to support `Markdown` partially. In fact,
    we only need to support italic and bold. We do need to validate the existing factory
    argument since any string is a valid `Markdown` string anyway. But, if we can
    get input from some online editor that can only produce pure HTML, we can do a
    conversion in a new factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I have to admit that this function is not perfect because it is insufficient
    in the number of tags it handles. It also cannot correctly handle HTML tags that
    are written using capital letters. But it is good enough for demo purposes to
    give you an idea of what kind of logic can be included in factory functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move to the `Price` class and see if it can create some factories
    and apply more rules to it. Since `Price` inherits from `Amount`, we can look
    to make the `Amount` class more strict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, `Money` class now has a `protected` constructor, which
    cannot be called from outside, except inherited classes like `Price`. The constructor
    now checks if the amount argument has more than two decimal points, and throws
    an exception if this is the case. Finally, we have two factory functions that
    create instances of `Money` from decimal or string arguments. Most probably, we
    will receive strings from the API so we can try parsing them inside the factory.
    It will, of course, throw the decimal parsing exception should the given string
    not represent a valid number.
  prefs: []
  type: TYPE_NORMAL
- en: We are checking if an amount of money has two decimal places, and usually, this
    is what we need to do. However, bear in mind that not all currencies support two
    decimals. For example, the Japanese Yen must have no decimals at all. Amounts
    in Yen are always round. You'd probably be surprised to know that Omani Rial supports
    three decimal places, so if you plan to deliver your application in Oman, you
    should not use the `Money` class from this book, or at least change the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Always check if rules that you apply are valid on all markets that you plan
    to support. Things like currencies, date and time formats, people names, bank
    accounts, and addresses can have surprisingly large varieties across the globe,
    and it is always worth checking if you are applying rules that make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine that our application needs to support different currencies.
    I mean that currency information would also need to be included in this value
    object. After adding it, we get code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we passed currency information to the constructor and both factory methods.
    By default, factories will use `EUR` if no currency is specified. We also keep
    currency information inside the class. Second, `Add` and `Subtract` methods started
    to check if both operands have the same currency. In case currencies of operands
    don't match, these methods throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a domain-specific exception that explicitly tells us that operations
    on two instances of `Money` cannot be completed because they have different currencies.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine how many bugs such simple technique can prevent in a multicurrency system,
    where developers too often forget that monetary value for the same decimal amount
    can be drastically different, depending on which currency this amount of money
    is issued? For example, one US Dollar is roughly equal to 110 Japanese Yen and
    adding `1` to `110`, in this case, won't give you the right result.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that remains uncovered with our `Money` object is that we can supply
    any string as currency code and it will be accepted. As you might imagine we can
    have this failure very easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the `Money` class code, we can quickly conclude that no operations
    can be performed on combinations of these objects. `firstAmount + secondAmount`
    will crash because our class will decide that they have different currencies.
    The `thirdAmount` is utterly invalid because the Dollar sign is not a valid currency
    code, but our class still accepts it. Let's see what can we do to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to check the currency code validity, we either need to keep all valid
    country codes inside the code of our value object class or use some external service
    to do the check. The first option is self-contained, so we will not have any dependencies
    for the value object class. However, by doing this, we will inject a somewhat
    alien concept to the value object code, which we will need to change each time
    something happens in the world of finances. One might argue that new currencies
    do not appear every day, but at the same time, Eurozone has been expanded during
    the last few years, and each time a new country starts using Euro, their old currency
    disappears, and this needs to be taken into account. These factors are utterly
    external to our system, and it would not be smart to create such an easy-to-forget
    time bomb in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Domain services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can go for a dependency on some external service, but we know that domain
    models should not have external dependencies, so how do we solve this issue? We
    can use a pattern called **domain service**. In DDD, domain services can perform
    different kinds of tasks, and here, we will look into one type of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our domain service needs to check if a given country code is valid. The `Money`
    class will get it as a dependency, so we need to declare the domain service inside
    our domain model. Because we do not want to depend on anything on the outside
    of our domain model, we should not put any implementation details inside the domain
    model. It means that the only thing we are going to have inside the domain project
    is the domain service interface, shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The new interface will not just check if a given currency code can be matched
    with some currency. Since we already discussed that different currencies might
    have a different number of decimal places, the service will return an instance
    of `CurrencyDetails` class with this information included. If there is no currency
    found for the given code, the service will return `CurrencyDetails.None` constant.
  prefs: []
  type: TYPE_NORMAL
- en: It is very common in C#, that if a function is expected to return an instance
    of a reference type, it also can return null to indicate that there is no valid
    result that the function can produce. Although, at first, this approach might
    seem easy, it creates massive problems. Our code becomes full of null checks because
    we suspect that every function can return null, so we must trust no one to avoid `NullReferenceException`.
    Null has a specific null-type, and it is too easy to assign null to something
    that should never be null.
  prefs: []
  type: TYPE_NORMAL
- en: Sir Charles Antony Richard Hoare, better known as Tony Hoare, introduced null
    references to the Algol programming language back in 1965\. He remembers doing
    this because it was so easy to implement. Much later, at the QCon conference in
    London in 2009, he apologized for null reference saying *I call it my billion
    dollar mistake*.
  prefs: []
  type: TYPE_NORMAL
- en: Video: [https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare).
  prefs: []
  type: TYPE_NORMAL
- en: In most functional languages, the null reference does not exist, because it
    can easily break the functional composition. Instead, optional types are being
    used. In the preceding code snippet, we use a similar technique to return a pre-defined
    value that indicates that there is no currency found for a given code. This constant
    has the proper type and proper name, and we should never check the function output
    for null.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate the null reference issue, Microsoft decided to allow explicit declaration
    of nullable reference types. By default, reference types will be assumed as non-nullable.
    This feature will remain until the next version of C#, and you can get more details
    about the proposal here: [https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md](https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the interface is there, we can change our value object like to look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of new things going on here, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We give the value object a dependency on the currency lookup domain service.
    Since we are using the interface, our domain model still has no external dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are not using the null reference to indicate that there is no currency
    found for the specified code, we do not use null checks. Instead, we check if
    the returned currency is valid or not. Since the `CurrencyDetails.NotFound` constant
    has its `InUse` property set to `false`, we will throw an exception just as we
    would do for any currency that exists, but is not in use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not use two as the maximum number of decimal places. Instead, we get this
    number from the currency lookup, so our value object becomes more flexible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our public methods, we need a simplified constructor, since these methods
    control that both operands have the same (valid) currency. Because we only trust
    our internals to use this constructor, it needs to be private. Both `Add` and
    `Subtract` methods use this constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `ToString` override to be able to see the human-readable value of the
    value object, for example, in test results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `Money` value object is still very much testable since we can supply a
    fake currency lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation in place, we can refactor the tests for `Money` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that we are testing some positive and some adverse scenarios
    to ensure those valid operations are correctly completed, and also, those invalid
    operations aren't allowed to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Entity invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through using value objects to protect invalid values from being
    even used as parameters for entity constructors and methods. This technique allows
    moving a lot of checks to value objects, provides nice encapsulation, and enables
    type safety. Then, when we create a new entity or execute some behavior using
    entity methods, we need to do some more checks. Since we can be quite sure that
    all parameters already contain valid individual values, we need to ensure that
    a given combination of parameters, current entity state, and execute behavior,
    is not going to bring the entity to some invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what complex rules we have for our classified ad entity. To
    find such rules, we can use some sticky notes from our detailed EventStorming
    session in [Chapter 3](07ee37fb-0189-467c-865d-18e72868b137.xhtml), *EventStorming*,
    and put them on a chart like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73066e67-6f7e-4849-a927-d016e8486af9.png)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing constraints for a command
  prefs: []
  type: TYPE_NORMAL
- en: We put the command to the left side, the event to the right side, and try to
    find out what could prevent our command being executed in a way that produces
    the desired outcome (the event). In our case here, we need to ensure that, before
    an ad can be put to the review queue, it must have a non-empty title, text, and
    price. By using value objects alone, we cannot guarantee that our entity state
    is correct as a whole. The entity state validity can change depending on what
    state the entity has at a particular moment of its life cycle. Only when a given
    command is being executed, we need to check if these constraints are satisfied. It
    is what we can call an invariant for this entity—an ad that is in a pending review
    cannot have an empty title, an empty text, or zero price.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least two ways to ensure that our entity never gets to an invalid
    state. The first and most obvious way is to add checks to the operation code.
    We have no method to request the ad to be published, so let''s add it and make
    some changes related to the fact of using value objects for entity state as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the new entity code, we have all properties to be typed as value objects,
    and we got one more property for the classified ad current state. In the beginning,
    it is set to `Inactive`, and when the ad is requested to be published, we change
    the state to `PendingReview`. However, we only do it when all the checks are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To let the caller know if our entity is not ready to be published when some
    of those checks fail, we use our custom exception, which is implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method of checking constraints before executing the operation, in the operation
    method itself, has one disadvantage. If we now change the price to zero, it will
    go through, because `UpdatePrice` method is not checking the price value.
  prefs: []
  type: TYPE_NORMAL
- en: We could, of course, copy the price check to the `UpdatePrice` method too, but
    there might be more methods that need the same tests, and we will keep copying
    control blocks. It will lead to a situation when, if we need to change any of
    those rules, we need to go to numerous places to replace all of the checks; this
    is very error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: To combine rules in one place, we can use techniques of contract programming.
    Part of contract programming can be seen in value objects since we evaluate pre-conditions
    for each parameter of the operation method. When we execute the operation without
    doing any additional checks, we will need to do a combined test (post-condition
    control). This check can be implemented in one place for the whole entity, and
    each operation will need to call it at the last line in the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our classified ad entity, it could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added one method called `EnsureValidState` checking
    that, in any situation, the entity state is valid, and, if it is not valid, an
    exception will be thrown. When we call this method from any operation method,
    we can be sure that, no matter what we are trying to do, our entity will always
    be in a valid state or the caller will get an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we converted all `private` fields to public read-only properties. We need
    public properties to write tests, although we don't necessarily need to expose
    the internal entity state. To prevent setting values of these properties outside
    of operation methods, all properties have private setters, or no setters, for
    properties that are set in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some tests to ensure that our constraints work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This spec contains several tests for one operation (publish, or submit for review)
    with different pre-conditions. Here, we test a happy path when all necessary details
    are correctly set before the ad can be sent for review; we also test several negative
    cases when publishing is not allowed, due to missing mandatory information. Perhaps
    testing negative scenarios is even more essential, since it is straightforward
    to find out when the happy path does not work—your users will immediately complain.
    Testing negative scenarios prevents bugs in controlling entity invariants, which,
    in turn, prevents entities from becoming invalid.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you might be wondering why we spent so much time talking about domain
    events and have not seen a single one in code? We will be discussing this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Domain events in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EventStorming allowed us to make useful domain discoveries. We gained some knowledge
    about the domain and managed to visualize it for shared understanding. Commands
    also appeared on the more detailed model. In this chapter, we learned how to create
    entities that protect themselves from executing invalid operations and never come
    to an invalid state. Operations on entities are performed by executing methods,
    which quite closely resemble commands that we discovered on our detailed model.
    So, this part is more or less clear, but events have never appeared in our code
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you can implement a system using DDD principles and patterns without
    having any domain events. It might sound strange after spending so much time working
    with them using sticky notes, but this is a fact. When we execute an entity method,
    it changes the entity state. This state change is an implicit event. For example,
    when our system executes the `RequestToPublish` method of the `ClassifiedAd` entity,
    it will set the entity `State` property to `ClassifiedAdState.PendingReview` value.
    Effectively, this can be translated to **classified ad sent to revie****w**, and
    this is what we wrote on an orange sticky a while ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, most of the time, making domain events first-class citizens in the
    domain model has excellent benefits. There are two primary use cases for domain
    events that are implemented explicitly as part of the domain model, listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing one part of the system to inform other parts of the system about its
    state changes, using Ubiquitous Language, and state change details: we already
    discussed the idea of splitting the system into multiple pieces, and those pieces
    need to play well together by listening to each others'' events and executing
    necessary operations. If a system is built in such a way that different parts
    of the system react to each others'' changes, such a system is called a **reactive
    system**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Persisting domain events to get a full history of state changes inside the
    domain model: then, the state for any entity can be reconstructed by reading those
    events and reapplying them to the entity. This pattern is known as **Event Sourcing**,
    and we will spend a great deal of time discussing it in this book, especially
    in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two techniques can be combined, so when we persist domain events, we can
    also listen to everything that is being written in other parts of the system,
    and execute reactions to those events.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at how we can bring domain events to code,
    and how our entity methods can raise them so we can use these events later.
  prefs: []
  type: TYPE_NORMAL
- en: Domain events as objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bringing domain events to code is easy. Each event is an object. It means that
    we can represent event types as classes or structs. Since we will need to serialize
    events later, and structs aren't playing nicely with serializers, we will implement
    domain events as classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following basic operations on our `ClassifiedAd` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new classified ad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the ad title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish the ad (send for review)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of those operations changes the state of our entity, and by doing this,
    raises an imaginary domain event. We have all those events on our sticky notes,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca6ec97c-790d-4cdb-abf9-d7e87311f639.png)'
  prefs: []
  type: TYPE_IMG
- en: The full picture for the core business domain
  prefs: []
  type: TYPE_NORMAL
- en: Classes that represent events need to clearly describe events (what happened)
    and contain the necessary information that explains how the system state has changed.
    Usually, events are reactions to executions of commands. Therefore, data in events
    typically represent data in commands, and maybe some other details from the entity
    from which the event has been raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some domain event classes now. Bear in mind that this is our
    first ever implementation of domain events, and if you were reading about things
    like Event Sourcing, you might find it oversimplified, but this is intentional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Event classes are wrapped inside the `Events` static class, which gives us some
    namespace.. Therefore, all properties in these classes are of primitive types.
    We do not use value objects in events. It is a significant thing to remember.
    The reason for only using primitive types in events is because domain events,
    as mentioned before, are often used *across* systems. Events can be seen as our
    system published contract. If we use Event Sourcing, and events are being persisted,
    we also cannot tolerate a situation where the rules in some value objects have
    changed. Furthermore, we cannot load our event anymore, because the data for the
    value object is now considered to be invalid. Of course, not using value objects
    in events mean that some more complex value objects need to be flattered. In our
    case, we extract values from the `Price` property to two properties of the `ClassifiedAdPriceUpdated`: `Price`,
    which represents the amount, and `CurrencyCode`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that each event has the `Id` property because it makes no sense
    to raise an event without knowing which entity it comes from. So, each operation
    needs to take care that the entity `id` is populated in the events that it raises.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the most critical thing about domain events is to represent things that
    happened, and these things cannot be changed, because we have no time machine
    or TARDIS to erase or fix the past. Therefore, events should be as simple as possible
    so we can always load past events, and this should never fail.
  prefs: []
  type: TYPE_NORMAL
- en: Raising events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how domain events are being used in our entity. First, we need
    to raise events from our methods. To do this, we need some event list inside the
    entity so we can keep events that are being created. Otherwise, there is little
    point in creating event instances in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Since we expect this functionality of keeping events in some sort of a list
    inside the entity, we can move this to a base class for entities, which we didn't
    have before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an abstract class and call it `Entity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since raised events will represent changes in the entity, methods that retrieve
    the list of events and clear this list are called `GetChanges` and `ClearChanges`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add this base class to our entity and start raising events
    from methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, if we imagine how our entity is used from the application service layer
    (which we will be discussing in detail later in this book), it could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code is not production ready, as you could imagine, but serves the purpose
    of demonstrating how domain events can be used for integration between different
    parts of the system. If we publish events to some message bus, and other components
    in our system subscribe to those messages, they can execute reactive behavior,
    and make some changes in their domain models, or execute some particular actions,
    like sending emails, text messages, or real-time notifications. With modern single-page
    application frameworks that embrace client-side state management, you can even
    update information that your users currently have in their browsers, to enable
    real-time updates in web applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth adding one small remark about the code that instantiates events.
    There we assign values of value objects to primitive types directly. It is done
    using the implicit conversion feature of C#, and the implementation looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Implicit conversion allows us to simplify the assignments between entity properties
    and event properties significantly, although they are of incompatible types.
  prefs: []
  type: TYPE_NORMAL
- en: Events change state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we move on to the idea of Event Sourcing, events represent the fact of state
    change. It means that an entity state cannot be changed without some interaction
    with a domain event. However, in our code so far, the fact of changing the system
    state and raising a domain event is completely separated. Let's see how we can
    change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make some changes in the `Entity` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have renamed the `Raise` method to `Apply` since it will not only add events
    to the list of changes but physically apply the content of each event to the entity
    state. We do it by using the `When` method, which each entity needs to implement.
    The `Apply` method also calls the `EnsureValidState` method, which we previously
    had in the entity, but not in the base class. By doing this, we remove the need
    to call this method for each operation on the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step would be to apply domain events and move all state changes to
    the `When` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two essential things that we changed in the entity class, listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All public methods to amend the entity state (operations) now apply to domain
    events. There are no state changes or validity checks left in those methods. As
    you remember, the validity contract method is now being called from the `Apply`
    method in the `Entity` base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have added a `When` method override, where the advanced pattern matching
    feature of C# 7.1 is being used to identify what kind of event is being applied,
    and how the entity state needs to be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, there are no changes in tests. If we execute all tests in the solution
    that have been created so far, they will all pass. It means that raising domain
    events and applying them to change the entity state can be considered as implementation
    details. Indeed, this is a style of working with domain events, typically used
    when DDD is applied with Event Sourcing, which we will be discussing later.
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that using DDD in general and domain events, in particular,
    does not imply using Event Sourcing, and vice versa. This book has more of a focus
    on Event Sourcing; therefore, this technique to change the state of the domain
    by applying events is presented quite early.
  prefs: []
  type: TYPE_NORMAL
- en: Some further changes are not that obvious but were required to make the whole
    thing work. If you look closely at the `When` method, entity properties that are
    still of value object types, use constructors for value objects instead of factory
    functions. It is because factory functions apply constraints and perform checks
    while constructing valid value objects. However, domain events represent something
    that already happened, so there is no point in checking these past facts for validity.
    If they were valid at the time, they should be just let through. Even if the logic
    in value object has changed, this should never have any effects on applying events
    with historical data.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we needed to change value objects, so they have internal constructors
    instead of private ones. Also, checks are moved from constructors to factory functions,
    so constructors are now accepting any value. For the more complex `Price` object,
    we needed to add a constructor that does not require a currency lookup service.
    Even if the currency is not valid anymore, when we are trying to load some past
    event, it should get through. However, it does not change the use of factory functions.
    They still require the lookup service and will be using it as soon as we create
    new instances of the value objects in our application service layer. It will keep
    protecting us from executing commands that have some incorrect information, and
    therefore, can bring our model to an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, you can find changed value object for the classified ad text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the full code for the value object that represents the ad title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Price` class, which is based on the `Money` class but has some
    additional rules in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, although these changes might seem significant, we were not changing any
    domain logic and constraints. We have all existing tests intact, and they are
    still passing, so our refactoring was successful, and we managed to change implementation
    details while keeping the essence of our domain model intact.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to write a lot of code and learned the basics of
    implementing domain models in code. We looked at entities and value objects, what
    they are needed for, and how different they are. Explaining the power of value
    objects consumed a significant part of this chapter, but this topic is vital since
    value objects are often overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: We used factory functions to create different ways of constructing value objects.
    A similar technique can be used to form valid entities, but we were not touching
    this topic just yet. We also used a domain service to make use of some external
    services inside our value object, while keeping the domain model itself clean
    from any external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints and invariants that play such an important role in keeping the state
    of the system valid at all times were also discussed, and we used different techniques
    to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we moved on to domain events and implemented some events that we previously
    only saw on orange stickies, directly in our code. Going forward, we learned how,
    from being a supportive tool, domain events could become the driver for state
    change in our model, and this lays a strong foundation for us before we move on
    to Event Sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also wrote some tests. Writing tests and keeping them actual
    is crucial in any programming work, but when using DDD and being in an explorative
    mode inside the model, tests become one of the most important instruments to handle
    regression, and even express and document business rules, as we will see in the
    following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Since we started to move some of our sticky notes to code, in the next chapter,
    we will look at how to implement commands, and how commands are the glue between
    our domain model and the world outside it. In this state, we will learn how to
    make our model useful by letting people interact with it.
  prefs: []
  type: TYPE_NORMAL
