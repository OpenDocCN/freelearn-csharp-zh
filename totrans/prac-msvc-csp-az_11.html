<html><head></head><body>
		<div><h1 id="_idParaDest-264" class="chapter-number"><a id="_idTextAnchor263"/>11</h1>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor264"/>Logging and Monitoring</h1>
			<p>With a microservices solution, many services can interact with each other. When one service fails, the complete solution should not break. In the previous chapter, we covered different kinds of tests to find issues early. Here, we’ll look at finding issues in production as early as possible – probably before a user sees a problem.</p>
			<p>To find issues when the application is running and see how the application runs successfully, the solution needs to be enhanced to offer telemetry data. With <strong class="bold">logging</strong>, we see what’s going on; based<a id="_idIndexMarker822"/> on different log levels, we can differentiate between informational logs and errors. With <strong class="bold">metrics</strong> data, we can monitor counters, such as memory and CPU<a id="_idIndexMarker823"/> consumption, and the number of HTTP requests. We will also write custom counters to see the number of games played and the number of game moves needed for a win. <strong class="bold">Distributed tracing</strong> gives information on how services interact. Who is making <a id="_idIndexMarker824"/>calls to this service? Where does this error originate from?</p>
			<p><strong class="bold">OpenTelemetry</strong> is an <a id="_idIndexMarker825"/>industry standard – a collection of APIs that allows different languages and tools to instrument, generate, collect, and export telemetry data. The .NET APIs for logging, metrics, and distributed tracing support OpenTelemetry, and this is what this chapter is about. We’ll <a id="_idIndexMarker826"/>use <strong class="bold">Prometheus</strong> and <strong class="bold">Grafana</strong>, which<a id="_idIndexMarker827"/> have great graphical views for an on-premises solution, as well as <strong class="bold">Azure Application Insights</strong> for <a id="_idIndexMarker828"/>the solution to run with the Microsoft Azure cloud.</p>
			<p>In this chapter, you’ll learn how to do the following:</p>
			<ul>
				<li>Add log messages</li>
				<li>Use and create metrics data</li>
				<li>Use distributed tracing</li>
				<li>Monitor with Azure Application Insights</li>
				<li>Monitor with Prometheus and Grafana</li>
			</ul>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor265"/>Technical requirements</h1>
			<p>With this chapter, as with the previous chapters, you need an Azure subscription and Docker Desktop. To create all the Azure resources for the solution, you can use the Azure Developer CLI – <code>azd up</code> creates all the resources. Check the README file of this chapter in the repository for details.</p>
			<p>The code for this chapter can be found in this GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</a>.</p>
			<p>In the <code>ch11</code> folder, you’ll see these projects with the result of this chapter. This chapter adds the Prometheus launch profile with the <code>launchsettings.json</code> file of the <code>AppHost</code> project. This also sets the <code>ASPNETCORE_ENVIRONMENT</code> and <code>DOTNETCORE_ENVIRONMENT</code> environment variables to <code>Prometheus</code>. The default launch profile uses services running with Microsoft Azure. The Prometheus launch profile is used to run Prometheus and Grafana, which can be used easily in an on-premises environment.</p>
			<p>These are the important projects for this chapter:</p>
			<ul>
				<li><code>Codebreaker.AppHost</code> – The .NET Aspire host project.</li><li><code>Codebreaker.ServiceDefaults</code> – Common service configuration. This project is enhanced with service configurations for monitoring.</li></ul></li>
				<li><code>Codebreaker.GamesAPI</code> – The service project is enhanced with logging, metrics, and distributed tracing.</li><li><code>Codebreaker.Bot</code> – This project has monitoring information included and will be used to play games that can be monitored.</li></ul></li>
				<li><code>grafana</code> folder contains configuration files that are used within the Grafana Docker container.</li><li>The <code>prometheus</code> folder contains a configuration file that is used by the Prometheus Docker container.</li></ul></li>
			</ul>
			<p>You can start with the source code from the previous chapter to integrate the features from this chapter.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor266"/>Adding log messages</h1>
			<p>To see what’s going on successfully or not when running the solution, we add log messages. The important parts of understanding the concept of logging are the following:</p>
			<ul>
				<li><strong class="bold">The source</strong>: Who writes<a id="_idIndexMarker829"/> log information – what is the category name?</li>
				<li><strong class="bold">The log provider</strong>: Where is log<a id="_idIndexMarker830"/> information written to?</li>
				<li><strong class="bold">The log level</strong>: What is the <a id="_idIndexMarker831"/>level of the log message? Is it just information or an error?</li>
				<li><strong class="bold">Filtering</strong>: What<a id="_idIndexMarker832"/> information is logged?</li>
			</ul>
			<p>The source is defined using the <code>ILogger&lt;T&gt;</code> generic interface. With this generic interface, the category name is taken from the class name of the generic parameter type. In case you use the <code>ILoggerFactory</code> interface instead of <code>ILogger&lt;T&gt;</code>, the category name is passed by invoking the <code>CreateLogger</code> method. Examples of category names used by .NET are <code>Microsoft.EntityFrameworkCore.Database.Command</code>, <code>System.Net.Http.HttpClient</code>, and <code>Microsoft.Hosting.Lifetime</code>. Having hierarchical names helps with common configuration settings.</p>
			<p>To define where<a id="_idIndexMarker833"/> log messages are written, log providers are configured with the startup of the application. The <code>CreateBuilder</code> method of the <code>WebApplication</code> class configures multiple log providers:</p>
			<ul>
				<li><code>ConsoleLogProvider</code> to write log messages to the console</li>
				<li><code>DebugLoggerProvider</code>, which only writes messages to the debug output window when a debugger is attached</li>
				<li><code>EventSourceLoggerProvider</code>, which writes log messages using <strong class="bold">Event Tracing for Windows</strong> (<strong class="bold">ETW</strong>) on<a id="_idIndexMarker834"/> Windows and <a id="_idIndexMarker835"/>the <strong class="bold">Linux Trace Toolkit: next generation</strong> (<strong class="bold">LTTng</strong>) on Linux</li>
			</ul>
			<p>With the AOT ASP.NET <a id="_idIndexMarker836"/>Core application that was created in <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, the <code>CreateSlimBuilder</code> method was used. <code>CreateSlimBuilder</code> only configures the console provider; other providers need to be added manually.</p>
			<p>The <code>ILogger</code> interface defines a <code>Log</code> method with a <code>LogLevel</code> enum value containing <code>Trace</code> (0) – <code>Debug</code> – <code>Information</code> – <code>Warning</code> – <code>Error</code> – <code>Critical</code> (5) – <code>None</code> (6) values. With this, we can configure to only write <code>Warning</code>-level messages and higher or write every message specifying the <code>Trace</code> level and higher). This configuration can be different based on the provider and the source.</p>
			<p>The following snippet shows a customized configuration with a JSON configuration file:</p>
			<pre class="source-code">
{
  "<strong class="bold">Logging</strong>": {
    "<strong class="bold">LogLevel</strong>": {
      "<strong class="bold">Default</strong>": "Information",
      "<strong class="bold">Microsoft.AspNetCore</strong>": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning",
      "Codebreaker": "Trace"
    },
    "<strong class="bold">EventSource</strong>": {
      "LogLevel": {
        "<strong class="bold">Default</strong>": "Warning"
      }
    }
  }
}</pre>
			<p>The <code>Logging</code> section with the configuration is accessed within the implementation of the <code>CreateBuilder</code> method at startup. Here, we can customize the logging configuration. With this configuration file, the default log level is specified with the <code>LogLevel:Default</code> key. Here, logging is set to <code>Information</code>, thus <code>Debug</code> and <code>Trace</code> log messages are not written. This default configuration is changed with log categories that start with <code>Microsoft.AspNetCore</code>. With this category, only warnings, errors, and critical messages are written. With the <code>LogLevel</code> key as a subkey to <code>Logging</code>, all log providers are configured, unless the configuration for the provider is overwritten. Here, this<a id="_idIndexMarker837"/> is done for the <code>EventSource</code> log provider. The <code>Default</code> log level is set to <code>Warning</code>.</p>
			<p>Next, let’s add logging to the games API.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/>Creating strongly typed log messages</h2>
			<p>The games<a id="_idIndexMarker838"/> API service makes use of <code>ILogger</code> extension methods such as <code>LogError</code> and <code>LogInformation</code>, when writing log messages, we use custom log methods as shown next. Let’s add a <code>Log</code> class to define all log messages with the games API project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/Log.cs</p>
			<pre class="source-code">
public static partial class Log
{
  <strong class="bold">[LoggerMessage(</strong>
<strong class="bold">    EventId = 3001,</strong>
<strong class="bold">    Level = LogLevel.Warning,</strong>
<strong class="bold">    Message = "Game {GameId} not found")]</strong>
<strong class="bold">  public static partial void GameNotFound(this ILogger logger, </strong>
    <strong class="bold">Guid gameId);</strong>
  // code removed for brevity
  [LoggerMessage(
    EventId = 4001,
    Level = LogLevel.Information,
    Message = "The move {Move} was set for {GameId} with result {Result}")]
  public static partial void SendMove(this ILogger logger, string 
    move, Guid gameId, string result);
  // code removed for brevity
}</pre>
			<p>The <code>LoggerMessage</code> attribute<a id="_idIndexMarker839"/> is used by a source generator. For methods that are annotated with this attribute, the logger source generator creates an implementation. The method needs to be <code>void</code> with an <code>ILogger</code> parameter. The method can also be defined as an extension method, as is the case here. Parameter names need to match the expressions used within the <code>Message</code> property, such as <code>gameId</code>, <code>move</code>, and <code>result</code>.</p>
			<p>Before the log message is written, the generated logging code checks if the log level is enabled. Sometimes, it can be useful to create custom methods that make use of generated methods, as shown in the next code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/Log.cs</p>
			<pre class="source-code">
[LoggerMessage(
  EventId = 4003,
  Level = LogLevel.Information,
  Message = "Game lost after {Seconds} seconds with game {Gameid}")]
private static partial void GameLost(this ILogger logger, int seconds, Guid gameid);
<strong class="bold">public static void GameEnded(this ILogger logger, Game game)</strong>
<strong class="bold">{</strong>
<strong class="bold">  if (logger.IsEnabled(LogLevel.Information))</strong>
<strong class="bold">  {</strong>
<strong class="bold">    if (game.IsVictory)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      logger.GameWon(game.Moves.Count, game.Duration?.Seconds ?? 0, </strong>
        <strong class="bold">game.Id);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else</strong>
<strong class="bold">    {</strong>
<strong class="bold">      logger.GameLost(game.Duration?.Seconds ?? 0, game.Id);</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
<strong class="bold">}</strong></pre>
			<p>The <code>GameEnded</code> method checks the <code>Game</code> object to see if it’s a victory or not, and depending on this, either the <code>GameWon</code> or the <code>GameLost</code> logging method is invoked. Before using any CPU and memory for this process (logging could also need to enumerate collections to produce useful log messages), it’s good practice to verify if this should be done at all – if the<a id="_idIndexMarker840"/> log level is enabled. This is checked using the <code>logger.IsEnabled</code> method and passing the log level.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Writing logs, don’t use interpolated strings such as <code>logger.LogInformation($"log message {expression}");</code>. Instead, use <code>logger.LogInformation("log message {expression}", expression);</code>. The second form supports structured logging. The message string passed is a template. With this template, the content within the curly braces can be used to create an index, and (depending on the log collector) you can query for all log entries containing this term. Also, using the formatted string allocates a new string that needs to be garbage-collected. With the second version, there’s just one string for all log entries written.</p>
			<p>Check the<a id="_idIndexMarker841"/> GitHub repo for more methods defined with the <code>Log</code> class. Next, let’s use this class to write log messages.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor268"/>Writing log messages</h2>
			<p>Log messages are mainly <a id="_idIndexMarker842"/>written from the <code>GamesService</code> class, thus we need to change the constructor:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public class GamesService(
  IGamesRepository dataRepository,
  <strong class="bold">ILogger&lt;GamesService&gt; logger</strong>) : IGamesService
{
  // code removed for brevity
}</pre>
			<p>With the updated constructor, the generic version of the <code>ILogger</code> interface is injected. The type parameter specifies the category name for logging.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this chapter, the <code>GamesService</code> class is enhanced with logging, distributed tracing, and metrics functionality. That’s why you see all these changes in the final code in the source code repository.</p>
			<p>The <code>StartGameAsync</code> method is<a id="_idIndexMarker843"/> enhanced with logging:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public async Task&lt;Game&gt; StartGameAsync(
  string gameType,
  string playerName,
  CancellationToken cancellationToken = default)
{
  Game game;
<strong class="bold">  try</strong>
<strong class="bold">  {</strong>
    game = GamesFactory.CreateGame(gameType, playerName);
    await dataRepository.AddGameAsync(game, cancellationToken);
<strong class="bold">    </strong><strong class="bold">logger.GameStarted(game.Id);</strong>
  }
<strong class="bold">  catch (CodebreakerException ex) when (ex.Code is </strong>
<strong class="bold">    CodebreakerExceptionCodes.InvalidGameType)</strong>
<strong class="bold">  {</strong>
<strong class="bold">    logger.InvalidGameType(gameType);</strong>
<strong class="bold">    throw;</strong>
<strong class="bold">  }</strong>
<strong class="bold">  catch (Exception ex)</strong>
<strong class="bold">  {</strong>
<strong class="bold">    logger.Error(ex, ex.Message);</strong>
<strong class="bold">    throw;</strong>
<strong class="bold">  }</strong>
  return game;
}</pre>
			<p>The <code>GamesFactory</code> class can throw an exception of type <code>CodebreakerException</code>. This is caught to write a log message and to re-throw the exception. The exception will be dealt with by the endpoint implementation to finally return a specific HTTP result. Here, we just want to log this information and re-throw the exception.</p>
			<p>For generic exceptions, a strongly typed <code>Error</code> method is defined by the <code>Log</code> class and used to write this message. The <code>InvalidGameType</code> method writes a log message with the <code>Warning</code> level. Here, the client probably sent an invalid (or currently not accepted) game type. While this shouldn’t happen, it’s usually an issue with the client, and we don’t have to deal with it on the service side. It’s just good to know about such clients. The <code>Error</code> method writes a log message with the <code>Error</code> level. It could be useful to check for more specific error types and create additional messages.</p>
			<p>On a successful invocation, a<a id="_idIndexMarker844"/> log message is written by invoking the <code>GameStarted</code> method of the <code>Log</code> class, which has the <code>Informational</code> level set.</p>
			<p>Let’s check the log messages with .NET Aspire next.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/>Viewing logs with the .NET Aspire dashboard</h2>
			<p>The .NET <a id="_idIndexMarker845"/>Aspire-generated <code>Codebreaker.ServiceDefaults</code> library<a id="_idIndexMarker846"/> contains logging configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static IHostApplicationBuilder <strong class="bold">ConfigureOpenTelemetry</strong>(this IHostApplicationBuilder builder)
{
<strong class="bold">  builder.Logging.AddOpenTelemetry(logging =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    logging.IncludeFormattedMessage = true;</strong>
<strong class="bold">    logging.IncludeScopes = true;</strong>
<strong class="bold">  });</strong>
  // code removed for brevity
}</pre>
			<p>The <code>AddOpenTelemetry</code> method adds the <code>OpenTelemetry</code> logger to the logger factory. This<a id="_idIndexMarker847"/> provider is configured to include formatted<a id="_idIndexMarker848"/> messages and to include logging scopes. Setting <code>IncludeFormattedMessage</code> to <code>true</code> specifies that if log templates are used (which we did), formatted messages are also included when creating log records for OpenTelemetry. By default, this would not be the case. Setting <code>IncludeScopes</code> to <code>true</code> specifies to include logging scope IDs with logs, which allows us to see a hierarchy of log messages when using the <code>BeginScope</code> method of the <code>ILogger</code> interface to define scopes. The <code>ConfigureOpenTelemetry</code> method is invoked from within the <code>AddServiceDefaults</code> method, which in turn is invoked both from the games API and the bot service.</p>
			<p>With this logging configuration in place, it’s time to start the services locally, running the .NET Aspire dashboard. Start the application and solution and let the bot service play some games. Then, open the .NET Aspire dashboard and select <strong class="bold">Console Logs</strong> within the <strong class="bold">Monitoring</strong> category. Here, you’ll see log outputs for games that have been started, as shown in <em class="italic">Figure 11</em><em class="italic">.1</em>. You can also<a id="_idIndexMarker849"/> see log outputs from <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>), including queries done and ASP.NET Core logs – unless the level is set to not show informational messages:</p>
			<div><div><img src="img/B21217_11_01.jpg" alt="Figure 11.1 – Logs with the .NET Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Logs with the .NET Aspire dashboard</p>
			<p>Also, open the <a id="_idIndexMarker850"/>logs from the bot service. The bot service writes log output with every move set after the result is received to show how <a id="_idIndexMarker851"/>successful the move was and how many remaining options are available, as shown in <em class="italic">Figure 11</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21217_11_02.jpg" alt="Figure 11.2 – Logs from the bot service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Logs from the bot service</p>
			<p>When you open <code>GameId</code> placeholder we’ve written with the <code>GameStarted</code> event, as shown in <em class="italic">Figure 11</em><em class="italic">.3</em>. Other data, such as the <code>RequestPath</code> placeholder, is coming from .NET activities, which we’ll look at later in the <em class="italic">Using distributed </em><em class="italic">tracing</em> section:</p>
			<div><div><img src="img/B21217_11_03.jpg" alt="Figure 11.3 – Structured logging"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Structured logging</p>
			<p>With the <code>GameId</code>, set the game<a id="_idIndexMarker853"/> identifier as the value, and read all the logs related to this game. Here, you easily can follow a single gameplay with the moves set, as shown in <em class="italic">Figure 11</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B21217_11_04.jpg" alt="Figure 11.4 – Structured logging with a GameId filter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Structured logging with a GameId filter</p>
			<p>After writing logs, let’s get started with metrics data.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor270"/>Using metrics data</h1>
			<p>Metrics data is <a id="_idIndexMarker854"/>used to monitor counts such as CPU and memory consumption or the length of an HTTP queue. This information can be used to analyze resources needed by services and can scale the services accordingly.</p>
			<p>With metrics data, we get some counts. Such counts can be used for scaling services, based on memory or CPU consumption, or the length of an HTTP queue.</p>
			<p>Let’s check the built-in metrics data before we add custom metrics.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor271"/>Monitoring built-in .NET metrics</h2>
			<p>As mentioned, .NET offers <a id="_idIndexMarker855"/>much built-in metrics data that can be monitored using the <code>dotnet counters</code> .NET tool (install it via <code>dotnet tool install dotnet-counters -g</code> as a global tool), and many counts are already available from the .NET Aspire dashboard by opening the <strong class="bold">Metrics</strong> view. <em class="italic">Figure 11</em><em class="italic">.5</em> shows the .NET-managed heap size of the games API service at a time the bot played several games in parallel:</p>
			<div><div><img src="img/B21217_11_05.jpg" alt="Figure 11.5 – Metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Metrics</p>
			<p>With many <a id="_idIndexMarker856"/>applications, you don’t need to create custom metrics data – but some custom counts might be interesting to see, and it’s not hard to add these, as shown in the next section.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor272"/>Creating custom metrics data</h2>
			<p>With the <code>Codebreaker</code> solution, we are <a id="_idIndexMarker857"/>interested in knowing about the number of active games that are just played, the time it takes from one game move to another, the time it takes to complete a game, and how many games are won versus lost.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With all the data we collect, we need to pay<a id="_idIndexMarker858"/> attention to the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>). Not storing any user-related data with logging and metrics information, we are on the safe side.</p>
			<p>Let’s <a id="_idIndexMarker859"/>create a new <code>GamesMetrics</code> class that contains all the counters needed:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs</p>
			<pre class="source-code">
public sealed class GamesMetrics : IDisposable
{
  public const string MeterName = "Codebreaker.Games";
  public const string Version = "1.0";
  private readonly Meter _meter;
  private readonly UpDownCounter&lt;long&gt; _activeGamesCounter;
  private readonly Histogram&lt;double&gt; _gameDuration;
  private readonly Histogram&lt;double&gt; _moveThinkTime;
  private readonly Histogram&lt;int&gt; _movesPerGameWin;
  private readonly Counter&lt;long&gt; _invalidMoveCounter;
  private readonly Counter&lt;long&gt; _gamesWonCounter;
  private readonly Counter&lt;long&gt; _gamesLostCounter;
  private readonly ConcurrentDictionary&lt;Guid, DateTime&gt; _moveTimes = new();</pre>
			<p>The fields defined within the <code>GameMetrics</code> class are for the <code>Meter</code> class, which is needed to create all the different metric instruments. This class is defined within the <code>System.Diagnostics.Metrics</code> namespace. This class is responsible for creating all the different instruments needed to monitor metrics data. The <code>Meter</code> type needs a name that is used to specify what metrics data we are interested in. The value for the version is optional.</p>
			<p>The <code>Counter</code> type is used to count the number of games won and lost and for all invalid game moves. <code>Counter</code> can be used for positive values, and most metrics viewers show the number of counts per second but can also show cumulative values. The <code>UpDownCounter</code> type is used for positive and negative values. We use this for the number of games active. Every time a game ends, a decrement will be made. The <code>Histogram</code> type is of special interest. This metrics instrument can be used to show arbitrary values. Here, this instrument is used to show the time it takes to complete a game, the time a user needs between game moves, and the number of moves needed to win a game.</p>
			<p>With the<a id="_idIndexMarker860"/> constructor of the <code>GamesMetrics</code> class, the <code>Meter</code> class and the instruments are created and initialized:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs</p>
			<pre class="source-code">
<strong class="bold">public GamesMetrics(IMeterFactory meterFactory)</strong>
{
<strong class="bold">  _meter = meterFactory.Create(MeterName, Version);</strong>
<strong class="bold">  _activeGamesCounter = _meter.CreateUpDownCounter&lt;long&gt;(</strong>
<strong class="bold">    "codebreaker.active_games",</strong>
<strong class="bold">    unit: "{games}",</strong>
<strong class="bold">    description: "Number of games that are currently active on the </strong>
<strong class="bold">      server.");</strong>
<strong class="bold">  _gameDuration = _meter.CreateHistogram&lt;double&gt;(</strong>
<strong class="bold">    </strong><strong class="bold">"codebreaker.game_duration",</strong>
<strong class="bold">    unit: "s",</strong>
<strong class="bold">    description: "Duration of a game in seconds.");</strong>
  // code removed for brevity
}</pre>
			<p><code>IMeterFactory</code> is a new interface since .NET 8. This allows the creation of <a id="_idIndexMarker861"/>metrics types via <code>IMeterFactory</code> is injected with the <code>GamesMetrics</code> constructor to create a <code>Meter</code> instance and instruments. <code>CreateCounter</code>, <code>CreateUpDownCounter</code>, and <code>CreateHistogram</code> are the methods to create the different metric instruments. The name of the instrument, the unit, and the <a id="_idIndexMarker862"/>description are assigned upon creating the instruments.</p>
			<p>Before using these counters, let’s add tags.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor273"/>Creating tags</h2>
			<p>Writing metrics data, <code>GameMetrics</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs</p>
			<pre class="source-code">
private static KeyValuePair&lt;string, object?&gt; <strong class="bold">CreateGameTypeTag(string gameType)</strong> =&gt;
  KeyValuePair.Create&lt;string, object?&gt;("GameType", gameType);
private static KeyValuePair&lt;string, object?&gt; <strong class="bold">CreateGameIdTag(Guid id)</strong> =&gt;
  KeyValuePair.Create&lt;string, object?&gt;("GameId", id.ToString());</pre>
			<p><code>CreateGameTypeTag</code> is a helper method to create a tag with the name <code>GameType</code> and set the value passed with the method parameter. Similarly, <code>CreateGameIdTag</code> is a method to create a tag for <code>GameId</code>.</p>
			<p>Now, we are ready to create methods using the instruments.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor274"/>Creating strongly typed methods for metrics data</h2>
			<p>The <code>GameStarted</code> method is for<a id="_idIndexMarker864"/> writing metrics data on creating a new game:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs</p>
			<pre class="source-code">
public void GameStarted(Game game)
{
  if (_moveThinkTime.<strong class="bold">Enabled</strong>)
  {
<strong class="bold">     _moveTimes.TryAdd(game.Id, game.StartTime);</strong>
  }
  if (_activeGamesCounter.<strong class="bold">Enabled</strong>)
  {
<strong class="bold">    </strong><strong class="bold">_activeGamesCounter.Add(1, CreateGameTypeTag(game.GameType));</strong>
  }
}</pre>
			<p>When <a id="_idIndexMarker865"/>nobody listens to metrics data, there’s no need to take any action. Before writing values to an instrument, it should be verified that the instrument is enabled. If nobody listens to the meter, the counters are disabled.</p>
			<p>To write the delta time between moves, we need to remember the time of the previous move. For this, the <code>GameMetrics</code> class holds the <code>_moveTimes</code> dictionary. This dictionary uses the game ID for the key and the last time for the latest move (or game start) value. Calculating this information is only necessary when the <code>_moveThinkTime</code> instrument is used.</p>
			<p>The counter that’s incremented at the start of the game is <code>_activeGamesCounter</code>. With <code>UpDownCounter</code>, the <code>Add</code> method is used to change the counter value. The second – optional – argument of the <code>Add</code> method allows passing tags. Here, a tag for the game type is added. This allows us to check the metrics data filtered based on the game type. It’s interesting to compare the active game counts based on the different game types.</p>
			<p>To <a id="_idIndexMarker866"/>write a histogram value, we implement the <code>MoveSet</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs</p>
			<pre class="source-code">
public void MoveSet(Guid id, DateTime moveTime, string gameType)
{
  if (_moveThinkTime.Enabled)
  {
<strong class="bold">    _moveTimes.AddOrUpdate</strong>(id, moveTime, (id1, prevTime) =&gt;
    {
      <strong class="bold">_moveThinkTime.Record((moveTime - prevTime).TotalSeconds, </strong>
<strong class="bold">        [CreateGameIdTag(id1), CreateGameTypeTag(gameType)]);</strong>
      return moveTime;
    });
  }
}</pre>
			<p>With the implementation of <code>MoveSet</code>, for the received game ID, we get the previous recorded time from the dictionary, calculate the delta with the new time, use the <code>Record</code> method of the <code>Histogram</code> instrument to write the data, and write the new received time to the dictionary.</p>
			<p>On ending the game, the <code>GameEnded</code> method is implemented. Here, multiple instruments are used, but this method just needs a simple implementation to check for every instrument to be enabled and write the counts accordingly. Check the source code repository for the complete code.</p>
			<p>Next, we can change the implementation of the <code>GamesService</code> class to use a <code>GamesMetrics</code> instance.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor275"/>Injecting and using metrics</h2>
			<p>Let’s update<a id="_idIndexMarker867"/> the <code>GamesService</code> class for <a id="_idIndexMarker868"/>metrics data:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public class GamesService(
  IGamesRepository dataRepository,
  ILogger&lt;GamesService&gt; logger,
  <strong class="bold">GamesMetrics metrics</strong>) : IGamesService
{
  public async Task&lt;Game&gt; StartGameAsync(
    string gameType,
    string playerName,
    CancellationToken cancellationToken = default)
  {
    Game game;
    try
    {
      game = GamesFactory.CreateGame(gameType, playerName);
      await dataRepository.AddGameAsync(game, cancellationToken);
<strong class="bold">            metrics.GameStarted(game);</strong>
            logger.GameStarted(game.Id);
        }
      // code removed for brevity
  return game;
}</pre>
			<p>All that needs to be done is to inject the <code>GamesMetrics</code> class and invoke the <code>GameStarted</code> method.</p>
			<p>Of course, the <code>GamesMetrics</code> class<a id="_idIndexMarker869"/> needs<a id="_idIndexMarker870"/> configuration within<a id="_idIndexMarker871"/> the <strong class="bold">DI </strong><strong class="bold">container</strong> (<strong class="bold">DIC</strong>):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
builder.Services.<strong class="bold">AddMetrics</strong>();
builder.Services.<strong class="bold">AddSingleton&lt;GamesMetrics&gt;();</strong>
<strong class="bold">builder.Services.AddOpenTelemetry()</strong>
<strong class="bold">  .WithMetrics(m =&gt; m.AddMeter(GamesMetrics.MeterName));</strong></pre>
			<p>The <code>AddMetrics</code> extension method registers an implementation for the <code>IMeterFactory</code> interface. The <code>GamesMetrics</code> class is registered as a singleton – to create the instruments once. We also configure the <code>GamesMetrics</code> class with OpenTelemetry – this way, we have a listener, and these metrics will be shown with the .NET Aspire dashboard.</p>
			<p>With this, we could run the application. However, the unit tests for the <code>GamesService</code> class no longer compile because of this additional parameter. Let’s update this before we continue.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor276"/>Updating unit tests to inject metrics types</h2>
			<p>The <code>GamesService</code> class uses a <a id="_idIndexMarker872"/>concrete type – it injects <a id="_idIndexMarker873"/>the <code>GamesMetrics</code> type. This cannot be mocked directly, but we can mock the <code>IMeterFactory</code> interface to create a <code>GamesMetrics</code> instance.</p>
			<p>The following code snippet shows an implementation of the <code>IMeterFactory</code> interface to be used for unit tests:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/TestMeterFactory.cs</p>
			<pre class="source-code">
internal sealed class <strong class="bold">TestMeterFactory : IMeterFactory</strong>
{
  public List&lt;Meter&gt; Meters { get; } = [];
  <strong class="bold">public Meter Create(MeterOptions options)</strong>
  {
    Meter meter = new(options.Name, options.Version, Array.
<strong class="bold">      </strong>Empty&lt;KeyValuePair&lt;string, object?&gt;&gt;(), scope: this);
    Meters.Add(meter);
    return meter;
  }
  public void Dispose()
  {
    foreach (var meter in Meters)
    {
      meter.Dispose();
    }
    Meters.Clear();
  }
}</pre>
			<p>To implement the <code>IMeterFactory</code> interface, <code>Create</code> and <code>Dispose</code> methods need to be implemented. With the <code>Create</code> method, a new <code>Meter</code> instance is created using name, version, and<a id="_idIndexMarker874"/> tag <a id="_idIndexMarker875"/>information.</p>
			<p>This <code>TestMeterFactory</code> class can now be used to create an instance of the <code>GamesService</code> class for the unit test:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
<strong class="bold">private GamesService GetGamesService()</strong>
{
  IMeterFactory meterFactory = new TestMeterFactory();
<strong class="bold">  GamesMetrics metrics = new(meterFactory);</strong>
  return new GamesService(
    _gamesRepositoryMock.Object,
    NullLogger&lt;GamesService&gt;.Instance,
    <strong class="bold">metrics</strong>);
}</pre>
			<p>Creating a new <code>GamesMetrics</code> instance, the <code>TestMeterFactory</code> class is created. The unit test <a id="_idIndexMarker876"/>for<a id="_idIndexMarker877"/> the <code>GamesService</code> class now builds successfully again.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The GitHub contains an additional parameter, <code>ActivitySource</code>, when invoking the <code>GamesService</code> constructor. The <code>ActivitiySource</code> is added in the section <em class="italic">Using distributed tracing</em>, and requires an adaption of the unit tests.</p>
			<p>There’s also a unit test for the <code>GamesMetrics</code> class needed, which we’ll do next.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor277"/>Creating unit tests to verify metrics</h2>
			<p>Metric data can be <a id="_idIndexMarker878"/>important business information easily shown<a id="_idIndexMarker879"/> on monitors in the office. What’s going on with the application? How active are users? Is an error rate going up? While metrics information is not important for orders coming in and being processed, if metrics data is not written, it can easily be missed that something is not working – thus creating unit tests for metrics data should be part of creating custom metric types.</p>
			<p>First, let’s create a skeleton to return an <code>IMeterFactory</code> instance and a <code>GamesMetrics</code> instance.</p>
			<h3>Meter factory skeleton</h3>
			<p>The following code snippet defines <a id="_idIndexMarker880"/>the skeleton used by the <code>GamesMetrics</code> unit tests:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs</p>
			<pre class="source-code">
private static IServiceProvider CreateServiceProvider()
{
  ServiceCollection services = new();
  service.AddMetrics();
  services.AddSingleton&lt;GamesMetrics&gt;();
  return serviceCollection.BuildServiceProvider();
}
private static (IMeterFactory MeterFactory, GamesMetrics Metrics) <strong class="bold">CreateMeterFactorySkeleton()</strong>
{
  var container = CreateServiceProvider();
  GamesMetrics metrics = container.GetRequiredService&lt;GamesMetrics&gt;();
  IMeterFactory meterFactory = container.GetRequiredService&lt;IMeterFactory&gt;();
  return (meterFactory, metrics);
}</pre>
			<p>Here, we need the real implementation of the <code>IMeterFactory</code> Interface. This is configured with the DIC for the unit test – along with the <code>GamesMetrics</code> singleton. The <code>CreateMeterFactorySkelton</code> method now gets the <code>IMeterFactory</code> and <code>GameMetrics</code> instances <a id="_idIndexMarker881"/>from the DIC.</p>
			<h3>Unit tests</h3>
			<p>Using this skeleton, we can create unit tests<a id="_idIndexMarker882"/> for all <code>GameMetrics</code> methods:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs</p>
			<pre class="source-code">
public class GamesMetricsTests
{
  private Guid _gameId = Guid.Parse("DBDF4DD9-3A02-4B2A-87F6-FFE4BA1DCE52");
  private DateTime <strong class="bold">_gameStartTime </strong>= new DateTime(2024, 1, 1, 12, 10, 5);
  private DateTime <strong class="bold">_gameMove1Time </strong>= new DateTime(2024, 1, 1, 12, 10, 15);
  [Fact]
  public void MoveSet_Should_Record_ThinkTime()
  {
    // arrange
    (IMeterFactory meterFactory, GamesMetrics metrics) = 
<strong class="bold">      </strong>CreateMeterFactorySkeleton();
    <strong class="bold">MetricCollector</strong>&lt;double&gt; collector = new(meterFactory, 
<strong class="bold">      </strong>GamesMetrics.MeterName, "codebreaker.move_think_time");
    var game = GetGame();
    metrics.GameStarted(game);
    // act
    metrics.MoveSet(game.Id, _gameMove1Time, "Game6x4");
    // assert
<strong class="bold">    var measurements = collector.GetMeasurementSnapshot();</strong>
<strong class="bold">    Assert.Single(measurements);</strong>
<strong class="bold">    </strong><strong class="bold">Assert.Equal(10, measurements[0].Value);</strong>
  }
  // code removed for brevity</pre>
			<p>For easy unit testing<a id="_idIndexMarker883"/> of metrics classes, the <code>MetricCollector</code> class defined in the <code>Microsoft.Extensions.Diagnostics.Testing</code> NuGet package in the <code>Microsoft.Extensions.Diagnostics.Metrics.Testing</code> namespace can register as a listener for the metrics data and collect this information. It’s also great for debugging purposes to have the metrics instruments enabled.</p>
			<p>After the <code>IMeterFActory</code> and <code>GamesMetrics</code> objects are returned from the skeleton, a collector is created. You need to create a collector for every instrument that needs to be tested. The generic type parameter and the name of the instrument need to match. The <code>MoveSet</code> method of the <code>GamesMetrics</code> class records the time between the previous move (or the game start) and the current move. Using <code>Assert.Single</code>,<code> </code>it’s verified that exactly one measurement is written to the collector. With <code>Assert.Equal</code>, it’s checked that this one recording contains the value 10. If you calculate the values from <code>_gameStartTime</code> and <code>_gameMove1Time</code>, this matches the time difference passed with the test data.</p>
			<p>As the <code>GameMetrics</code> class tests successfully, let’s go to the .NET Aspire dashboard to see the custom metrics data.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor278"/>Viewing metrics data with the .NET Aspire dashboard</h2>
			<p>We injected<a id="_idIndexMarker884"/> metrics and configured our<a id="_idIndexMarker885"/> custom <code>GamesMetrics</code> class with OpenTelemetry in the game APIs project. Now, we can use the .NET Aspire dashboard to see the games played!</p>
			<p>Running the<a id="_idIndexMarker886"/> services and starting the bot to run <a id="_idIndexMarker887"/>multiple games in parallel, we can see interesting outcomes. Sometimes, the bot doesn’t find an answer within 12 moves because it lost the game, as shown in <em class="italic">Figure 11</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21217_11_06.jpg" alt="Figure 11.6 – Counter for games lost"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Counter for games lost</p>
			<p><em class="italic">Figure 11</em><em class="italic">.7</em> shows the number of games won by the bot is much higher. This figure also shows the filter for the game type that can be selected because of the tag specified:</p>
			<div><div><img src="img/B21217_11_07.jpg" alt="Figure 11.7 – Counter for games won"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Counter for games won</p>
			<p>While games <a id="_idIndexMarker888"/>won and lost used simple<a id="_idIndexMarker889"/> counters, <em class="italic">Figure 11</em><em class="italic">.8</em> shows the up-down counter with the number of active games:</p>
			<div><div><img src="img/B21217_11_08.jpg" alt="Figure 11.8 – Up-down counter for active games"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Up-down counter for active games</p>
			<p><em class="italic">Figure 11</em><em class="italic">.9</em> shows <a id="_idIndexMarker890"/>a histogram that allows <a id="_idIndexMarker891"/>checking the duration of games:</p>
			<div><div><img src="img/B21217_11_09.jpg" alt="Figure 11.9 – Histogram showing the game duration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Histogram showing the game duration</p>
			<p>A histogram<a id="_idIndexMarker892"/> graph shows <strong class="bold">P50</strong>, <strong class="bold">P90</strong>, and <strong class="bold">P99</strong> values. These <a id="_idIndexMarker893"/>names are marks for percentiles. 50% of the finished games are within the lowest values: over the complete time, 50% of the games were finished within 25 seconds. The next higher line marks 90% of the game runs. Over time, with some peaks, we can see that sometimes 90% of the games were finished within 25 seconds, but it also took up to 50 seconds. To get to a higher number of games, 99% of the games were finished within 50 to 75 seconds. At peak time, it took 250 seconds. If a user is playing the game, this can be expected. We need more time than the bot to solve this. But here, it was just the bot playing. With different games, the bot was configured to take different times between game moves. However, the bot was never configured to take that long. Thus, this<a id="_idIndexMarker894"/> needs to be another issue, probably too high a<a id="_idIndexMarker895"/> load on the service. To find the reason more easily for such behavior, the next section covering distributed tracing will help.</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor279"/>Using distributed tracing</h1>
			<p>If errors happen on the service, where is this request coming from, and from where does it originate? With <a id="_idIndexMarker896"/>distributed tracing, we can see the interaction of services and resources and can easily follow information on how requests from a client flow to the different services and see when errors occur, going from the error up to the stack.</p>
			<p>Using .NET, we use <code>ActivitySource</code> and <code>Activity</code> classes to specify information for distributed tracing.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor280"/>Creating an ActivitySource class with the DIC</h2>
			<p>When<a id="_idIndexMarker897"/> writing trace information, you’ll usually have <a id="_idIndexMarker898"/>one <code>ActivitySource</code> class in a project that’s used by all classes that write trace information. With the games client library, an <code>ActivitySource</code> class is used as a static member. Using an <code>ActivitySource</code> class from an executable project such as the games API, we can register this in the DIC:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationTelemetry(this IhostApplicationBuilder builder)
{
  // code removed for brevity
  const string ActivitySourceName = "Codebreaker.GameAPIs";
  const string ActivitySourceVersion = "1.0.0";
<strong class="bold">  builder.Services.AddKeyedSingleton(ActivitySourceName, (services, _) </strong>
<strong class="bold">  =&gt;</strong>
<strong class="bold">    new ActivitySource(ActivitySourceName,</strong>
<strong class="bold">      </strong><strong class="bold">ActivitySourceVersion));</strong></pre>
			<p>The<a id="_idIndexMarker899"/> ASP.NET Core initialization already registers<a id="_idIndexMarker900"/> an <code>ActivitySource</code> class with the name <code>Microsoft.AspNetCore</code> as a singleton for the <code>ActivitySource</code> type. We don’t want to overwrite this setting with our name. The ASP.NET Core features injecting this <code>ActivitySource</code> instance should still get this instance, but for our own trace messages, the <code>Codebreaker.GameAPIs</code> activity source should be used. With .NET 8 enhancements on the DIC, we can register a named service within the DIC by invoking the <code>AddKeyedSingleton</code> method and specifying the name and version strings. One instance is created using the factory defined with the lambda expression.</p>
			<p>Next, we can inject this singleton instance with the <code>GamesService</code> class.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor281"/>Writing trace messages</h2>
			<p>With the constructor<a id="_idIndexMarker901"/> of the <code>GamesService</code> class, we can now inject the configured <code>ActivitySource</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public class GamesService(
  IGamesRepository dataRepository,
  ILogger&lt;GamesService&gt; logger,
  GamesMetrics metrics,
<strong class="bold">  [FromKeyedServices("Codebreaker.GameAPIs")] ActivitySource </strong>
    <strong class="bold">activitySource)</strong> :
    IGamesService
{
  // code removed for brevity</pre>
			<p>Using the <code>FromKeyedServices</code> attribute, we get the named instance from the DIC.</p>
			<p>Next, let’s <a id="_idIndexMarker902"/>update the creation of a new game by creating an <code>Activity</code> object:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public async Task&lt;Game&gt; StartGameAsync(string gameType, string playerName, CancellationToken cancellationToken = default)
{
  Game game;
<strong class="bold">  using var activity = activitySource.CreateActivity("StartGame", </strong>
    <strong class="bold">ActivityKind.Server);</strong>
  try
  {
    game = GamesFactory.CreateGame(gameType, playerName);
<strong class="bold">    activity?.AddTag(GameTypeTagName, game.GameType)</strong>
<strong class="bold">      </strong><strong class="bold">.AddTag(GameIdTagName, game.Id.ToString())</strong>
<strong class="bold">      .Start();</strong>
    await dataRepository.AddGameAsync(game, cancellationToken);
    metrics.GameStarted(game);
    logger.GameStarted(game.Id);
<strong class="bold">    activity?.SetStatus(ActivityStatusCode.Ok);</strong>
  }
  catch (CodebreakerException ex) when (ex.Code is CodebreakerExceptionCodes.InvalidGameType)
  {
    logger.InvalidGameType(gameType);
<strong class="bold">    activity?.SetStatus(ActivityStatusCode.Error, ex.Message);</strong>
    throw;
  }
  catch (Exception ex)
  {
    logger.Error(ex, ex.Message);
<strong class="bold">    activity?.SetStatus(ActivityStatusCode.Error, ex.Message);</strong>
    throw;
  }
  return game;
}</pre>
			<p>The <code>Activity</code> object<a id="_idIndexMarker903"/> is created by invoking the <code>CreateActivity</code> method. The parameters used here are the name of the activity and the activity kind. The service specifies <code>ActivityKind.Server</code>, whereas the client library uses <code>ActivityKind.Client</code>. Other types available are <code>Producer</code> and <code>Consumer</code>.</p>
			<p>The methods creating an <code>Activity</code> object might return <code>null</code>. If no one adds a listener to the <code>ActivitySource</code> class, the <code>CreateActivity</code> method returns <code>null</code>. This reduces the overhead but also means we always need to check for <code>null</code> values before using an <code>Activity</code> object. Using the <code>null</code> conditional operator, this is easy to do.</p>
			<p>Using the <code>StartActivity</code> method instead of the <code>CreateActivity</code> method would immediately start the activity. Here, we want to add some data to the activity that is shown with the log output. The <code>AddTag</code> method is used to add the game type and the game ID. This method adds key-value pairs to the log entries, which allows filtering and searching. The <code>SetBaggage</code> method allows adding information not only to this activity output – this information is passed to the child activities. Baggage information is used across processes and thus needs to be serializable. Invoking the <code>Start</code> method starts the activity – this writes the first log record along with tag and baggage information.</p>
			<p>An activity ends when the <code>Stop</code> method is invoked. Here, the <code>using</code> declaration is used to dispose of the activity when the <code>activity</code> variable goes out of scope. This stops the activity implicitly.</p>
			<p>Before the activity ends, the <code>SetStatus</code> method is invoked. This method specifies the outcome of the activity and is written when the activity ends. With a successful start of the game, <code>ActivityStatusCode.Ok</code> is the status of the activity. In case of errors, the status code is <code>ActivityStatusCode.Error</code> and an exception message is written.</p>
			<p>Check the <a id="_idIndexMarker904"/>other source code repo for the other activities created with the <code>GamesService</code> class.</p>
			<p>With this implementation, we just need to configure the service defaults library to monitor the custom <code>ActivitySource</code> class.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor282"/>Viewing distributed traces with the .NET Aspire dashboard</h2>
			<p>First, let’s<a id="_idIndexMarker905"/> add a custom <code>ActivitySource</code> class to<a id="_idIndexMarker906"/> the configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static IHostApplicationBuilder ConfigureOpenTelemetry(this IHostApplicationBuilder builder)
{
  // code removed for brevity
  builder.Services.AddOpenTelemetry()
    .<strong class="bold">WithTracing</strong>(tracing =&gt;
    {
      if (builder.Environment.IsDevelopment())
      {
        tracing.SetSampler(new AlaysOnSampler());
      }
      <strong class="bold">tracing.AddSource</strong>(
        "<strong class="bold">Codebreaker.GameAPIs.Client</strong>",
        "<strong class="bold">Codebreaker.GameAPIs</strong>")
        .AddAspNetCoreInstrumentation()
        .AddGrpcClientInstrumentation()
        .AddHttpClientInstrumentation();</pre>
			<p>The <code>WithTracing</code> method configures the distributed trace settings. The <code>AddSource</code> method of the <code>TracerProviderBuilder</code> class sets the sources that should be subscribed to. <code>Codebreaker.GameAPIs</code> is the activity source name that has been configured <a id="_idIndexMarker907"/>with the games API<a id="_idIndexMarker908"/> service. <code>Codebreaker.GameAPIs.Client</code> is the activity source name used from the client library, which is referenced by the bot service. The next methods invoked configure the built-in sources with ASP.NET Core, gRPC, and <code>HttpClient</code>.</p>
			<p>Now, running a few games using the bot, you can see <em class="italic">traces</em> in the .NET Aspire dashboard, as shown in <em class="italic">Figure 11</em><em class="italic">.10</em>:</p>
			<div><div><img src="img/B21217_11_10.jpg" alt="Figure 11.10 – Tracing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Tracing</p>
			<p>Sending a <code>POST</code> request <a id="_idIndexMarker909"/>to the bot to play multiple <a id="_idIndexMarker910"/>games, the request immediately returns (the one request in the figure lists 4,84 ms). The figure also shows activities started from this request from within a background task. This task is to play games. How this relates to multiple activities (or <code>bot POST bot/bots</code>, is an activity created from ASP.NET Core. The next activity, <code>bot StartGameAsync</code>, is a custom activity that was created from the games client library. <code>bot POST</code> is the next activity from <code>HttpClient</code>. From there, we switch over to the <code>gameapis</code> service. The custom activities created with the games API are <code>gameapis StartGame</code> and <code>gameapis SetMove</code>.</p>
			<p>With every one of these activities, you can dig deeper and get the data written, including the tags for the game ID and the game type, as shown in <em class="italic">Figure 11</em><em class="italic">.11</em>:</p>
			<div><div><img src="img/B21217_11_11.jpg" alt="Figure 11.11 – Trace data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Trace data</p>
			<p>While monitoring<a id="_idIndexMarker911"/> this data, also switch<a id="_idIndexMarker912"/> to <strong class="bold">Structured Logs</strong>. With these logs, you can see a <strong class="bold">Trace</strong> identifier. Clicking on this, you switch from the log to the trace information. It’s also working the other way around. While opening a trace, you can switch to the log information associated with the trace.</p>
			<p>Using the .NET Aspire dashboard is now great in the development environment. For production environments, we have different needs. Let’s switch over to using .NET Azure services for monitoring.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor283"/>Monitoring with Azure Application Insights</h1>
			<p>Creating an Azure<a id="_idIndexMarker913"/> Container Apps environment (starting with <a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>) also <a id="_idIndexMarker914"/>creates an <strong class="bold">Azure Log Analytics</strong> resource. In this chapter, we add an <strong class="bold">Azure Application Insights</strong> resource, and add a<a id="_idIndexMarker915"/> Log Analytics respource explicitly to the app<a id="_idIndexMarker916"/> model. Log Analytics and Application Insights are both part of the <strong class="bold">Azure </strong><strong class="bold">Monitor</strong> service.</p>
			<p>Log Analytics is used to monitor the amount of log data created and the cost associated and gives reasons when there is a higher-than-expected usage. Application Insights has a focus on application telemetry data and user data.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor284"/>Configuring the .NET Aspire host for Application Insights</h2>
			<p>To add<a id="_idIndexMarker917"/> Application Insights, add the <a id="_idIndexMarker918"/>NuGet package <code>Aspire.Hosting.Azure.ApplicationInsights</code>, and update the <code>Program.cs</code> file of the .NET Aspire <code>AppHost</code> project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
// code removed for brevity
<strong class="bold">var logs = builder.AddAzureLogAnalyticsWorkspace("logs");</strong>
<strong class="bold">var appInsights = builder.AddAzureApplicationInsights("insights", logs);</strong>
var cosmos = builder.AddAzureCosmosDB("codebreakercosmos")
  .AddDatabase("codebreaker");
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
    .WithReference(cosmos)
<strong class="bold">    .WithReference(appInsights);</strong>
var bot = builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")
    .WithReference(gameAPIs)
<strong class="bold">    </strong><strong class="bold">.WithReference(appInsights);</strong>
builder.Build().Run();
// code removed for brevity</pre>
			<p>The <a id="_idIndexMarker919"/>Application Insights resource is <a id="_idIndexMarker920"/>added invoking the AddAzureApplicationInsights method. This method requires a name and a log analytics workspace resource which is created invoking the AddAzureLogAnalytics method. Both the games API and the bot services will use this resource, thus it is forwarded using Aspire orchestration by using the <code>WithReference</code> method.</p>
			<p>With this, we can configure the services to use Application Insights.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/>Configuring the services to use Application Insights</h2>
			<p>To use Application Insights, the <a id="_idIndexMarker921"/>common configuration project can be updated:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
private static IHostApplicationBuilder AddOpenTelemetryExporters(
  this IHostApplicationBuilder builder)
{
<strong class="bold">  builder.Services.AddOpenTelemetry()</strong>
<strong class="bold">    .UseAzureMonitor(options =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      options.ConnectionString = builder.Configuration[</strong>
<strong class="bold">        "APPLICATIONINSIGHTS_CONNECTION_STRING"];</strong>
<strong class="bold">    });</strong>
  // code removed for brevity
  return builder;
}</pre>
			<p>The <code>AddOpenTelemetryExporters</code> method is invoked from the <code>AddServiceDefaults</code> method in the same class. <code>AddServiceDefaults</code> is called with the <code>WebApplication</code> configuration of every service project. The <code>AddOpenTelemetry</code> method is part of the OpenTelementry SDK to configure services for logging, metrics, and distributed tracing. The <code>UseAzureMonitor</code> extension method configures <a id="_idIndexMarker922"/>providers to write this information to Azure Monitor.</p>
			<p>This is all that we need to do. Let’s check the information we get from the application.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor286"/>Monitoring the solution with Application Insights</h2>
			<p>As before, upon<a id="_idIndexMarker923"/> running the application when monitoring using the Aspire dashboard, use the bot to run multiple games. As Application Insights is configured, it’s not necessary to have the solution deployed to Azure; monitoring information will be available within Azure when running the application locally as well. After starting a few game runs using the bot, open the Azure Application Insights resource within the Azure portal.</p>
			<p>After playing a few games, check the Azure portal. With Application Insights, in the <strong class="bold">Investigate</strong> category on the left pane, select <strong class="bold">Application map</strong>. Here, you see how the different services communicate, as shown in <em class="italic">Figure 11</em><em class="italic">.12</em>:</p>
			<div><div><img src="img/B21217_11_12.jpg" alt="Figure 11.12 – Application map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Application map</p>
			<p>The previous figure <a id="_idIndexMarker924"/>shows the bot service invokes the game API service, and this communicates with the Azure Cosmos database. The count of messages, the time used, and errors can easily be seen from this information. Clicking on a connection, it’s possible to investigate performance by seeing the slowest calls and directly accessing log information.</p>
			<p>With the <strong class="bold">Investigate</strong> category in the Azure portal, you can dig into other interesting information such as <strong class="bold">Performance</strong>, where you get insights into slow operations, and <strong class="bold">Failures</strong>, where you can dive into errors and exceptions. Smart detection can give you notifications (alerts) when services are not behaving with usual, expected values.</p>
			<p>Within the <code>codebreaker.active_games</code> and <code>codebreaker.game_moves-per-win</code>, where you can select the metric name and the aggregation type to calculate values and see graphical results, as shown in <em class="italic">Figure 11</em><em class="italic">.13</em>:</p>
			<div><div><img src="img/B21217_11_13.jpg" alt="Figure 11.13 – Metrics via Application Insights"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Metrics via Application Insights</p>
			<p>With this figure, the first line shows the average duration of a game (seconds), the second line shows the average number of moves needed, and the third line shows the number of games currently active.</p>
			<p>Clicking <code>customMetrics</code> table, you can query all the metrics data.</p>
			<p>Use this KQL query to get the average EF Core queries on a time chart:</p>
			<pre class="source-code">
customMetrics
| where name == "ec.Microsoft.EntityFrameworkCore.queries-per-second"
| summarize avg(value) by bin(timestamp, 5min)
| render timechart</pre>
			<p>This query accesses the <code>customMetrics</code> table filtered by the <code>name</code> column to get the EF Core queries by second. This result (you can see every record fitting this query by clicking on <strong class="bold">Results</strong>) is then used to show the average values and a timestamp rendered on a time chart. Your result might<a id="_idIndexMarker927"/> look like the one shown in <em class="italic">Figure 11</em><em class="italic">.14</em>:</p>
			<div><div><img src="img/B21217_11_14.jpg" alt="Figure 11.14 – EF Core average queries using KQL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – EF Core average queries using KQL</p>
			<p>The Application Insights resource can be used no matter where your services are running if they have access to this resource on Microsoft Azure. In case the complete solution needs to run on-premises, you can use Prometheus and Grafana, as we’ll do next.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor287"/>Monitoring with Prometheus and Grafana</h1>
			<p>For monitoring microservices solutions, Prometheus and Grafana<a id="_idIndexMarker928"/> are often used. <strong class="bold">Prometheus</strong> uses a pull model <a id="_idIndexMarker929"/>to collect data from services. Using this data, the <strong class="bold">PromQL</strong> query language<a id="_idIndexMarker930"/> analyzes this information. <strong class="bold">Grafana</strong> can access the data collected <a id="_idIndexMarker931"/>from Prometheus to show a graphical view.</p>
			<p>We’ll use Docker containers<a id="_idIndexMarker932"/> running Prometheus and Grafana. Microsoft Azure also offers managed services for Prometheus and Grafana that can be used as well.</p>
			<p>Let’s configure Docker containers for Prometheus and Grafana next.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor288"/>Adding Docker containers for Prometheus and Grafana</h2>
			<p>To<a id="_idIndexMarker933"/> use the solution with Prometheus and <a id="_idIndexMarker934"/>Grafana, you need to select the launch<a id="_idIndexMarker935"/> profile – using Visual Studio, select <strong class="bold">OnPremises</strong> in the toolbar after the project selection.</p>
			<p>Using the command line, use the <code>--</code><code>launch-profile</code> parameter:</p>
			<pre class="console">
dotnet run --project Codebreaker.AppHost.csproj --launch-profile OnPremises</pre>
			<p>To also use SQL Server within a Docker container, set the <code>DataStore</code> configuration to <code>SQLServer</code> (see <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a> for details); you could also use in-memory or Cosmos instead with the same build configuration.</p>
			<p>For using a Prometheus Docker container, we need to change the .NET Aspire <code>AppHost</code> implementation:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
var sqlServer = builder.AddSqlServer("sql")
  .WithDataVolume()
  .PublishAsContainer()
  .AddDatabase("CodebreakerSql");
<strong class="bold">var prometheus = builder.AddContainer("prometheus", "prom/prometheus")</strong>
<strong class="bold">  .WithBindMount("../prometheus", "/etc/prometheus", isReadOnly: true)</strong>
<strong class="bold">  .WithHttpEndpoint(9090, hostPort: 9090);</strong>
// code removed for brevity</pre>
			<p>The first <a id="_idIndexMarker936"/>Docker container we used <a id="_idIndexMarker937"/>was the container for SQL Server. For using the Docker image for SQL Server, the <code>AddSqlServerContainer</code> extension method was used. To use the Prometheus Docker image, we need <a id="_idIndexMarker938"/>to use the <code>AddContainer</code> generic method, which allows adding any Docker image. The Docker image for Prometheus can be pulled from Docker Hub using <code>prom/prometheus</code>. For the Prometheus configuration, we use the <code>prometheus</code> folder, which is stored outside of the container. Using <code>WithBindMount</code>, the <code>prometheus</code> host directory is mapped to the <code>/etc/prometheus</code> folder within the container. Prometheus used port <code>9090</code> to access its services. This port is mapped to the host port <code>9090</code> with the <code>WithHttpEndpoint</code> method to make Prometheus available.</p>
			<p>Next, add a Docker container for Grafana with the same file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var grafana = builder.AddContainer("grafana", "grafana/grafana")</strong>
<strong class="bold">  .WithBindMount("../grafana/config", "/etc/grafana",</strong>
<strong class="bold">    isReadOnly: true)</strong>
<strong class="bold">  .WithBindMount("../grafana/dashboards",</strong>
<strong class="bold">    "/var/lib/grafana/dashboards", isReadOnly: true)</strong>
<strong class="bold">  .WithHttpEndpoint(containerPort: 3000, hostPort: 3000,</strong>
<strong class="bold">    name: "grafana-http");</strong>
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithReference(sqlServer)
  .WithEnvironment("DataStore", dataStore)
<strong class="bold">  .WithEnvironment("GRAFANA_URL",</strong>
<strong class="bold">    grafana.GetEndpoint("grafana-http"));</strong>
<strong class="bold">  .WithEnvironment("StartupMode", startupMode);</strong>
  builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")
    .WithReference(gameAPIs);
    .WithEnvironment<strong class="bold">("StartupMode", startupMode);</strong>
// code removed for brevity</pre>
			<p>The <a id="_idIndexMarker939"/>Docker image for Grafana is pulled from <a id="_idIndexMarker940"/>Docker Hub with the <a id="_idIndexMarker941"/>name <code>grafana/grafana</code>. This container needs mounts within the <code>/etc/grafana</code> and <code>/var/lib/grafana/dashboards</code> Docker container directories for the Grafana configuration and dashboard configurations used. For both mounts, we’ll have a local <code>grafana</code> directory. The Grafana service will be available on port <code>3000</code>.</p>
			<p>After configuring the Docker containers, let’s add the configuration for Prometheus.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>Configuring Prometheus</h2>
			<p>Prometheus is configured with <a id="_idIndexMarker942"/>this YML file in the <code>prometheus</code> folder that’s referenced with the Docker container configuration specified previously:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">prometheus/prometheus.yml</p>
			<pre class="source-code">
global:
<strong class="bold">  scrape_interval: 1s</strong>
scrape_configs:
<strong class="bold">  - job_name: 'codebreakergames'</strong>
<strong class="bold">    static_configs:</strong>
<strong class="bold">      - targets: ['host.docker.internal:9400']</strong>
<strong class="bold">  - job_name: 'codebreakerbot'</strong>
<strong class="bold">    static_configs:</strong>
<strong class="bold">      </strong><strong class="bold">- targets: ['host.docker.internal:5141']</strong></pre>
			<p>Prometheus<a id="_idIndexMarker943"/> pulls telemetry data from services. How often this is done from Prometheus is defined by the <code>scrape_interval</code> parameter. To run tests and get fast information, here, 1 second is configured. On a production system, you might increase this value to, for example, 30 seconds to decrease the load on the services. The services that are accessed from Prometheus are the games API and the bot service. Make sure to configure the ports to the port numbers of your service projects. You can see these values with the <code>Properties/launchsettings.json</code> files.</p>
			<p>To add an API endpoint that’s accessed by Prometheus for scraping telemetry data, the <code>MapDefaultEndpoints</code> method of the <code>Extensions</code> class needs an update:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static WebApplication MapDefaultEndpoints(this WebApplication app)
{
  if (Environment.GetEnvironmentVariable("StartupMode") == "OnPremises")
  {
<strong class="bold">    app.MapPrometheusScrapingEndpoint();</strong>
<strong class="bold">  }</strong>
// code removed for brevity
  return app;
}</pre>
			<p>The <code>MapPrometheusScrapingEndpoint</code> method configures an endpoint and maps the <code>PrometheusExporterMiddleware</code> middleware.</p>
			<p>The <code>AddOpenTelemetryExporters</code> method needs an update as well:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
private static IHostApplicationBuilder AddOpenTelemetryExporters(this IHostApplicationBuilder builder)
{
  // code removed for brevity
<strong class="bold">  builder.Services.AddOpenTelemetry()</strong>
<strong class="bold">    .WithMetrics(metrics =&gt; metrics.AddPrometheusExporter());</strong>
  return builder;
}</pre>
			<p>With Azure <a id="_idIndexMarker944"/>Application Insights, we used the <code>UseAzureMonitor</code> method. For Prometheus, we use the <code>WithMetrics</code> method, and <code>AddPrometheusExporter</code> adds the exporter for Prometheus.</p>
			<p>After the configuration of Prometheus, let’s configure Grafana.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>Configuring Grafana</h2>
			<p>With this configuration of the<a id="_idIndexMarker945"/> Grafana Docker container, we defined using the <code>grafana</code> host folder. Here, we need to create a <code>grafana.ini</code> configuration file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">grafana/grafana.ini</p>
			<pre class="source-code">
[auth.anonymous]
enabled = true
org_name = Main Org.
org_role = Admin
hide_version = false
[dashboards]
default_home_dashboard_path = /var/lib/grafana/dashboards/aspnetcore.json
min_refresh_interval = 1s</pre>
			<p>For simple tests locally, we allow anonymous authentication and specify that non-authenticated users have admin access to change settings and customize dashboards. The home dashboard that’s used is the ASP.NET Core dashboard.</p>
			<p>To access Prometheus from <a id="_idIndexMarker946"/>Grafana, the data source needs to be specified with a YML file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">grafana/config/provisioning/datasources/default.yaml</p>
			<pre class="source-code">
apiVersion: 1
<strong class="bold">datasources:</strong>
<strong class="bold">  - name: Prometheus</strong>
<strong class="bold">    type: prometheus</strong>
<strong class="bold">    access: proxy</strong>
<strong class="bold">    </strong><strong class="bold">url: http://host.docker.internal:9090</strong>
<strong class="bold">    uid: PBFA97CFB590B2093</strong></pre>
			<p>The <code>datasources</code> folder contains the configuration file for the Prometheus data source. This uses port <code>9090</code> used by Prometheus.</p>
			<p>The default dashboard is configured with a YML file as well:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">grafana/config/provisioning/dashbaords/default.yml</p>
			<pre class="source-code">
apiVersion: 1
providers:
  - name: Default
    folder: .NET
    type: file
    options:
      path:
        /var/lib/grafana/dashboards</pre>
			<p>The dashboards themselves are stored within the <code>grafana/dashboards</code> folder. You can get pre-built dashboards at <a href="https://grafana.com/grafana/dashboards">https://grafana.com/grafana/dashboards</a>. The ASP.NET Core team provides the dashboards for .NET 8 named <em class="italic">ASP.NET Core Endpoint</em> (ID: 19925) and <em class="italic">ASP.NET Core</em> (ID: 19924) to monitor request durations, error rates, current connections, total requests… for ASP.NET Core metrics. Both dashboards are <a id="_idIndexMarker947"/>copied to the final solution of this chapter.</p>
			<p>When this configuration is in place, we are ready to start the solution again – running all services on the local system.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/>Monitoring the solution with Prometheus and Grafana</h2>
			<p>When you run the <a id="_idIndexMarker948"/>application now, three Docker containers<a id="_idIndexMarker949"/> are running: SQL Server, Prometheus, and Grafana, and the bot and game APIs projects, as shown in <em class="italic">Figure 11</em><em class="italic">.15</em>. Grafana lists an endpoint that’s accessible from the host:</p>
			<div><div><img src="img/B21217_11_15.jpg" alt="Figure 11.15 – Aspire dashboard with Prometheus and Grafana"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Aspire dashboard with Prometheus and Grafana</p>
			<p>By accessing the bot <a id="_idIndexMarker950"/>service again to let it play some games, we can<a id="_idIndexMarker951"/> access the configured dashboards from the Grafana Docker container, as shown in <em class="italic">Figure 11</em><em class="italic">.16</em>:</p>
			<div><div><img src="img/B21217_11_16.jpg" alt="Figure 11.16 – Grafana Dashboards"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Grafana Dashboards</p>
			<p>This page is opened by selecting <strong class="bold">Dashboards</strong> in the left pane. There, you can open both configured ASP.NET Core dashboards to see these metrics.</p>
			<p>You can also see the custom metric counts written, as shown in <em class="italic">Figure 11</em><em class="italic">.17</em>:</p>
			<div><div><img src="img/B21217_11_17.jpg" alt="Figure 11.17 – Active games with Grafana"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Active games with Grafana</p>
			<p>The preceding <a id="_idIndexMarker952"/>figure shows the active game count (all started from the bot). To<a id="_idIndexMarker953"/> see this screen, open the <strong class="bold">Explore</strong> menu in the left pane. Then, select the value of the metric from a combobox and click the <strong class="bold">Query</strong> button. With the graph, you can select from different display types.</p>
			<p>In the previous section, you’ve seen Azure services to monitor the solution. With Prometheus and Grafana, you’ve seen services that can easily be used in an on-premises environment. In case you prefer Prometheus and Grafana while running within Microsoft Azure, one way of use is to run these services in Azure Container Apps. Azure-managed services are available as well: Azure offers Managed Grafana and Azure Monitor Managed Service for Prometheus. Using these services, the same service is available but with reduced management needs.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor292"/>Summary</h1>
			<p>In this chapter, you learned about offering telemetry data from a microservice solution covering logging, metrics, and distributed tracing. With logging, you used high-performance, strongly typed logging to write information-level logs as well as errors. For metrics, you created custom metric data using the <code>Meter</code> class with instruments created. For distributed tracing, you used the <code>ActivitySource</code> and <code>Activity</code> classes.</p>
			<p>To monitor all this telemetry data, you used the .NET Aspire dashboard, Azure Application Insights, and Prometheus with Grafana.</p>
			<p>In the next chapter, we’ll look into how to use metrics data to scale the services running with Azure Container Apps. We’ll find out about the memory and CPU usage of services using load tests we created in <a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>, combine this with metrics information from this chapter, learn about scaling services to be ready no matter how demand grows, and implement health checks to recover services when not healthy.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor293"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li>OpenTelemetry: <a href="https://opentelemetry.io/">https://opentelemetry.io/</a></li>
				<li>High-performance logging in .NET: <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging">https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging</a></li>
				<li>Application Insights: <a href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview">https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview</a></li>
				<li>KQL repo: <a href="https://github.com/microsoft/Kusto-Query-Language">https://github.com/microsoft/Kusto-Query-Language</a></li>
				<li>Prometheus: <a href="https://prometheus.io/">https://prometheus.io/</a></li>
				<li>Grafana repo: <a href="https://github.com/grafana/grafana">https://github.com/grafana/grafana</a></li>
				<li>Grafana Dashboards: <a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a></li>
			</ul>
		</div>
	</body></html>