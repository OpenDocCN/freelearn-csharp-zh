<html><head></head><body>
		<div id="_idContainer141">
			<h1 id="_idParaDest-352"><em class="italic"><a id="_idTextAnchor476"/>Chapter <a id="_idTextAnchor477"/>17</em>: Building Automated Tests</h1>
			<p>Building automated tests is an essential <strong class="source-inline">GetRegistrationOrNull</strong> practice to create maintainable software solutions and is a fast and repeatable way of validating the software. ABP Framework and the ABP startup solution template are designed with testability in mind. We've already seen an example of writing a simple integration test with ABP Framework in <a href="B17287_03_Epub_AM.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Step-By-Step Application Development</em>.</p>
			<p>In this chapter, you will understand the ABP test infrastructure and build unit and integration tests for your ABP-based solutions. You will learn about data seeding for tests, mocking the database, and testing different kinds of objects. You will also learn the basics of automated tests such as assertions, mocking and replacing services, and dealing with exceptions.</p>
			<p>Here is a list of the main topics covered in this chapter:</p>
			<ul>
				<li>Understanding the ABP test infrastructure</li>
				<li>Building unit tests</li>
				<li>Building integration tests</li>
			</ul>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor478"/>Technical requirements</h1>
			<p>If you want to follow the examples in this chapter, you need to have an IDE/editor that supports ASP.NET Core development.</p>
			<p>The examples in this chapter are mostly based on the EventHub solution I introduced in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>. Please refer to that chapter to learn how to download the source code of the EventHub solution. </p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor479"/>Understanding the ABP test infrastructure</h1>
			<p>ABP's startup <a id="_idIndexMarker1092"/>solution template includes preconfigured test projects to build unit and integration tests for your solution. While you can write your tests without understanding the complete structure, I think it is worth exploring this so that you can understand how it works and customize it when you need it. We'll start by exploring the <strong class="source-inline">test</strong> projects.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor480"/>Exploring the test projects</h2>
			<p>The following <a id="_idIndexMarker1093"/>screenshot shows the <strong class="source-inline">test</strong> projects that get created when you create a new ABP solution:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_17.01_B17287.jpg" alt="Figure 17.1 – Test projects in the ABP startup solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.1 – Test projects in the ABP startup solution</p>
			<p>The preceding screenshot shows the <strong class="source-inline">test</strong> projects for a solution named <strong class="source-inline">ProductManagement</strong>, with <a id="_idIndexMarker1094"/>the MVC/Razor Pages UI and the <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>) database provider. The <strong class="source-inline">test</strong> project list may be slightly different if you use a different UI or database provider, but the fundamental logic is the same. The following list explains the projects in general:</p>
			<ul>
				<li><strong class="source-inline">ProductManagement.HttpApi.Client.ConsoleTestApp</strong>: A very simple console application <a id="_idIndexMarker1095"/>to manually test the HTTP API endpoints of your application. So, this is not a part of our automated test infrastructure, and you can ignore it for this chapter.</li>
				<li><strong class="source-inline">ProductManagement.TestBase</strong>: A <a id="_idIndexMarker1096"/>project that is shared by the other test projects. It has references to the base test libraries and includes data seeding and some other base configuration code. It doesn't contain any test class normally.</li>
				<li><strong class="source-inline">ProductManagement.EntityFrameworkCore.Tests</strong>: You can build tests for EF Core <a id="_idIndexMarker1097"/>integration code in this project, such as your custom repositories. This project also configures a SQLite in-memory database for your tests.</li>
				<li><strong class="source-inline">ProductManagement.Domain.Tests</strong>: Use <a id="_idIndexMarker1098"/>this project to build tests for your domain layer.</li>
				<li><strong class="source-inline">ProductManagement.Application.Tests</strong>: Use <a id="_idIndexMarker1099"/>this project to build tests for your application layer.</li>
				<li><strong class="source-inline">ProductManagement.Web.Tests</strong>: Use <a id="_idIndexMarker1100"/>this project to build tests for your MVC/Razor Pages UI.</li>
			</ul>
			<p>The solution uses some libraries as the test infrastructure, as explained in the next section.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor481"/>Exploring the test libraries</h2>
			<p>The <strong class="source-inline">ProductManagement.TestBase</strong> project <a id="_idIndexMarker1101"/>has reference <a id="_idIndexMarker1102"/>to the following NuGet packages:</p>
			<ul>
				<li><strong class="source-inline">xunit</strong>: xUnit is one of the most popular test frameworks for .NET.</li>
				<li><strong class="source-inline">Shouldly</strong>: A library to write the assertion code in an easy and readable format.</li>
				<li><strong class="source-inline">NSubstitute</strong>: A library to mock objects in unit tests.</li>
				<li><strong class="source-inline">Volo.Abp.TestBase</strong>: ABP's package to easily create ABP-integrated test classes.</li>
			</ul>
			<p>We will see how to use the basics of these libraries in the <em class="italic">Building unit tests</em> and <em class="italic">Building integration tests</em> sections. Before starting to write our tests, let's see how we can run the tests.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor482"/>Running the tests</h2>
			<p>In this section, I will show two ways of running the tests. The first way is to use an IDE that supports <a id="_idIndexMarker1103"/>running test execution. I will use Visual Studio as an example. You can open the <strong class="bold">Test Explorer</strong> window from the <strong class="bold">Test</strong> | <strong class="bold">Test Explorer</strong> item on the main menu:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_17.02_B17287.jpg" alt="Figure 17.2 – Test Explorer in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.2 – Test Explorer in Visual Studio</p>
			<p><strong class="bold">Test Explorer</strong> automatically discovers all the tests in your solution and allows you to run some or all of them. In <em class="italic">Figure 17.2</em>, I ran all the tests, and all of them succeeded. This screenshot has been taken from the <strong class="source-inline">ProductManagement</strong> application built in <a href="B17287_03_Epub_AM.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Step-By-Step Application Development</em>, and the source code can be found at <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<p>Visual Studio runs the tests one by one by default, and thus it takes a long time to run all the tests. You can click the down arrow icon near the cog icon in <strong class="bold">Text Explorer</strong> and select the <strong class="bold">Run Tests In Parallel</strong> option (see <em class="italic">Figure 17.3</em>) to run the tests in parallel so that it takes significantly less time to run them all:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_17.03_B17287.jpg" alt="Figure 17.3 – Running tests in parallel in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.3 – Running tests in parallel in Visual Studio</p>
			<p>ABP Framework <a id="_idIndexMarker1104"/>and the startup solution template have been designed to support running tests in parallel so that tests don't affect each other.</p>
			<p>An alternative way to run tests is to use the <strong class="source-inline">dotnet test</strong> command in the root directory of your solution. It automatically discovers and runs all the tests and reports the test result in the command-line terminal. This command exits with a <strong class="source-inline">0</strong> (success) return code if all the tests succeed; otherwise, if any test fails, it exits with a <strong class="source-inline">1</strong> return code. This command is <a id="_idIndexMarker1105"/>especially useful if you build a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline where you automatically run the tests.</p>
			<p>You've learned the test structure of the ABP startup solution and have run the automated tests. Now, we can start to build our tests.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor483"/>Building unit tests</h1>
			<p>In this section, we will <a id="_idIndexMarker1106"/>see different types of unit tests. We will begin by testing a static class, then we will write tests for a class with no dependencies. We will continue with a class with dependent services and learn how to mock these dependencies to unit test that class. We will learn the basics of writing automated test code with examples.</p>
			<p>Let's begin with the simplest case—testing static classes.</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor484"/>Testing static classes</h2>
			<p>A static class with <a id="_idIndexMarker1107"/>no state and external dependencies is the easiest class to test. <strong class="source-inline">EventUrlHelper</strong> is a <a id="_idIndexMarker1108"/>static class (in the <strong class="source-inline">EventHub.Domain</strong> project of the EventHub solution) and is used to convert an event's title to a proper URL part. The following test class (in the <strong class="source-inline">EventHub.Domain.Tests</strong> project of the EventHub solution) tests the <strong class="source-inline">EventUrlHelper</strong> class:</p>
			<p class="source-code">public class EventUrlHelper_Tests</p>
			<p class="source-code">{</p>
			<p class="source-code">    [Fact]</p>
			<p class="source-code">    public void Should_Convert_Title_To_Proper_Urls()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var url = EventUrlHelper.ConvertTitleToUrlPart(</p>
			<p class="source-code">                  "Introducing ABP Framework!");</p>
			<p class="source-code">        Assert.Equal("introducing-abp-framework", url);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The first rule is that the test class should be <strong class="source-inline">public</strong>. Otherwise, you can't see it in <strong class="bold">Test Explorer</strong>. The <strong class="source-inline">[Fact]</strong> attribute is defined by the <strong class="source-inline">xUnit</strong> library. Any public method with the <strong class="source-inline">[Fact]</strong> attribute is considered a test case and is automatically discovered by <strong class="bold">Test Explorer</strong>. You can give your method whatever name you want, but the suggested naming pattern is reflected in this example. You can even name it more specifically, such as <strong class="source-inline">Should_Convert_Url_To_Kebab_Case</strong>, and only test the functionality related to <strong class="source-inline">kebab-case</strong>.</p>
			<p>The test code in this example is very simple. We call the static <strong class="source-inline">EventUrlHelper.ConvertTitleToUrlPart</strong> method with a sample title value, then compare the result with the value we expect it to be. The <strong class="source-inline">Assert</strong> class is defined by <strong class="source-inline">xUnit</strong>, with many methods to define our expectations. The test case succeeds only if the given values are equal. Otherwise, we see a red icon for the test case in <strong class="bold">Test Explorer</strong> with an error message indicating what's wrong with the test.</p>
			<p>You can <a id="_idIndexMarker1109"/>right-click on a specific test in <strong class="bold">Test Explorer</strong> to run it and see the result, as depicted in the following screenshot:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_17.04_B17287.jpg" alt="Figure 17.4 – Running a specific test in Test Explorer in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.4 – Running a specific test in Test Explorer in Visual Studio</p>
			<p>Another common <strong class="source-inline">xUnit</strong> attribute is <strong class="source-inline">[Theory]</strong>, which provides parameters to a test method and tests it for each parameter set. Assuming that we want to run the test with different event URLs, we can rewrite the test method, as shown in the following code block:</p>
			<p class="source-code">public class EventUrlHelper_Tests</p>
			<p class="source-code">{</p>
			<p class="source-code">    [Theory]</p>
			<p class="source-code">    [InlineData("Introducing ABP Framework!",</p>
			<p class="source-code">                "introducing-abp-framework")]</p>
			<p class="source-code">    [InlineData("Blazor: UI Messages", </p>
			<p class="source-code">                "blazor-ui-messages")]</p>
			<p class="source-code">    [InlineData("What's new in .NET 6", </p>
			<p class="source-code">                "whats-new-in-net-6")]</p>
			<p class="source-code">    public void Should_Convert_Title_To_Proper_Urls(</p>
			<p class="source-code">        string title, string url)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var result = </p>
			<p class="source-code">            EventUrlHelper.ConvertTitleToUrlPart(title);</p>
			<p class="source-code">        result.ShouldBe(url);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">xUnit</strong> runs this <a id="_idIndexMarker1110"/>test method for each <strong class="source-inline">[InlineData]</strong> set separately and passes the <strong class="source-inline">title</strong> and <strong class="source-inline">url</strong> parameters as the given data. If you look at <strong class="bold">Test Explorer</strong> again, you will see these three test cases there:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_17.05_B17287.jpg" alt="Figure 17.5 – Using the [Theory] attribute for unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.5 – Using the [Theory] attribute for unit tests</p>
			<p>I also <a id="_idIndexMarker1111"/>used the <strong class="source-inline">Shouldly</strong> library for the assertion in this example. The <strong class="source-inline">result.ShouldBe(url)</strong> expression is simpler to write and read than the <strong class="source-inline">Assert.Equal(url, result)</strong> expression. The <strong class="source-inline">Shouldly</strong> library works with extension methods such as that, and I will use it in future examples.</p>
			<p>Testing static classes (with no state and external dependencies) was easy. We've also learned some <strong class="source-inline">xUnit</strong> and <strong class="source-inline">Shouldly</strong> features. The next section continues with testing simple classes without a service dependency.</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor485"/>Testing classes with no dependencies</h2>
			<p>Some <a id="_idIndexMarker1112"/>classes, such as entities, may have no dependency on other services. Testing these classes is relatively easy since we don't need to prepare the dependencies to make the class work properly.</p>
			<p>The following test method tests the <strong class="source-inline">Event</strong> class's constructor:</p>
			<p class="source-code">public class Event_Tests</p>
			<p class="source-code">{</p>
			<p class="source-code">    [Fact]</p>
			<p class="source-code">    public void Should_Create_A_Valid_Event()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        new Event(</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            "1a8j3v0d",</p>
			<p class="source-code">            "Introduction to the ABP Framework",</p>
			<p class="source-code">            DateTime.Now,</p>
			<p class="source-code">            DateTime.Now.AddHours(2),</p>
			<p class="source-code">            "In this event, we will introduce the ABP </p>
			<p class="source-code">             Framework..."</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In <a id="_idIndexMarker1113"/>this example, I've passed a valid list of parameters so that it doesn't throw an exception, and the test succeeds. The following example tests for an exception case:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public void </p>
			<p class="source-code">    Should_Not_Allow_End_Time_Earlier_Than_Start_Time()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var exception = Assert.Throws&lt;BusinessException&gt;(() =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        new Event(</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            "1a8j3v0d",</p>
			<p class="source-code">            "Introduction to the ABP Framework",</p>
			<p class="source-code">            DateTime.Now, // Start time</p>
			<p class="source-code">            DateTime.Now.AddDays(-2), // End time</p>
			<p class="source-code">            "In this event, we will introduce the ABP</p>
			<p class="source-code">             Framework..."</p>
			<p class="source-code">        );</p>
			<p class="source-code">    });</p>
			<p class="source-code">    exception.Code.ShouldBe(EventHubErrorCodes</p>
			<p class="source-code">        .EventEndTimeCantBeEarlierThanStartTime);</p>
			<p class="source-code">}</p>
			<p>I intentionally <a id="_idIndexMarker1114"/>passed the end time as 2 days earlier than the start time. I am expecting the constructor to throw a <strong class="source-inline">BusinessException</strong> exception by using the <strong class="source-inline">Assert.Throws&lt;T&gt;</strong> method. If the code block inside the <strong class="source-inline">Throws</strong> method throws an exception of type <strong class="source-inline">BusinessException</strong>, then the test passes; otherwise, the test will fail. I am also checking the error code with the <strong class="source-inline">ShouldBe</strong> extension method.</p>
			<p>Let's write a method that tests another method of the <strong class="source-inline">Event</strong> class. The following example creates a valid <strong class="source-inline">Event</strong> object, then changes its start and end times, and finally checks whether the times were changed:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public void Should_Update_Event_Time()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // ARRANGE</p>
			<p class="source-code">    var evnt = new Event(</p>
			<p class="source-code">        Guid.NewGuid(),</p>
			<p class="source-code">        Guid.NewGuid(),</p>
			<p class="source-code">        "1a8j3v0d",</p>
			<p class="source-code">        "Introduction to the ABP Framework",</p>
			<p class="source-code">        DateTime.Now,</p>
			<p class="source-code">        DateTime.Now.AddHours(2),</p>
			<p class="source-code">        "In this event, we will introduce the ABP</p>
			<p class="source-code">         Framework..."</p>
			<p class="source-code">    );</p>
			<p class="source-code">    var newStartTime = DateTime.Now.AddHours(1);</p>
			<p class="source-code">    var newEndTime = DateTime.Now.AddHours(2);</p>
			<p class="source-code">    //ACT</p>
			<p class="source-code">    evnt.SetTime(newStartTime, newEndTime);</p>
			<p class="source-code">    //ASSERT</p>
			<p class="source-code">    evnt.StartTime.ShouldBe(newStartTime);</p>
			<p class="source-code">    evnt.EndTime.ShouldBe(newEndTime);</p>
			<p class="source-code">    evnt.GetLocalEvents()</p>
			<p class="source-code">        .ShouldContain(x =&gt; x.EventData</p>
			<p class="source-code">                       is EventTimeChangingEventData);</p>
			<p class="source-code">}</p>
			<p>This <a id="_idIndexMarker1115"/>example fully implements <a id="_idIndexMarker1116"/>the common <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>) test pattern, detailed as follows:</p>
			<ul>
				<li>The <em class="italic">Arrange</em> part prepares the objects we need to work on.</li>
				<li>The <em class="italic">Act</em> part executes the actual code we want to test.</li>
				<li>The <em class="italic">Assert</em> part checks whether the expectations are met.</li>
			</ul>
			<p>I suggest separating your test method's body with these comment lines to make what you are testing <a id="_idIndexMarker1117"/>and asserting explicit. In this example, we used the <strong class="source-inline">SetTime</strong> method of the <strong class="source-inline">Event</strong> class to change the event times. The <strong class="source-inline">SetTime</strong> method also publishes a local event, so I checked it too in the <em class="italic">Assert</em> part.</p>
			<p>As you see in the examples, if the class we want to test has no external dependencies, we can simply create an instance and execute the methods on it. In the next section, we will see how to deal with external dependencies.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor486"/>Testing classes with dependencies</h2>
			<p>Most services <a id="_idIndexMarker1118"/>have dependencies <a id="_idIndexMarker1119"/>on other services. We use the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) system to take these dependencies into the service's constructor. The purpose of unit testing is to test a class as isolated from other classes because unit tests should generally have only one reason to fail. We should somehow exclude the dependencies while testing the target class. In this way, our test is affected by the changes in the target class but not affected by changes in other classes.</p>
			<p>Mocking is a <a id="_idIndexMarker1120"/>technique used in unit testing to replace a target class's dependencies with fake implementations so that the test isn't affected by the target class's dependencies.</p>
			<p>I will test the <strong class="source-inline">IsPastEvent</strong> method of the <strong class="source-inline">EventRegistrationManager</strong> class as an example. The <strong class="source-inline">IsPastEvent</strong> method gets an event. </p>
			<p><strong class="source-inline">EventRegistrationManager</strong> is a domain service and takes three external services in its constructor, as shown in the following simplified code block:</p>
			<p class="source-code">public class EventRegistrationManager : IDomainService</p>
			<p class="source-code">{</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    public EventRegistrationManager(</p>
			<p class="source-code">        IEventRegistrationRepository </p>
			<p class="source-code">            eventRegistrationRepository,</p>
			<p class="source-code">        IGuidGenerator guidGenerator,</p>
			<p class="source-code">        IClock clock)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _eventRegistrationRepository = </p>
			<p class="source-code">            eventRegistrationRepository;</p>
			<p class="source-code">        _guidGenerator = guidGenerator;</p>
			<p class="source-code">        _clock = clock;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public bool IsPastEvent(Event @event)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return _clock.Now &gt; @event.EndTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We should <a id="_idIndexMarker1121"/>pass instances of these three external services to be able to create an <strong class="source-inline">EventRegistrationManager</strong> object. The following code block shows how I've written a test method for the <strong class="source-inline">IsPastEvent</strong> method of that class:</p>
			<p class="source-code">public class EventRegistrationManager_UnitTests</p>
			<p class="source-code">{</p>
			<p class="source-code">    [Fact]</p>
			<p class="source-code">    public void IsPastEvent()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var clock = Substitute.For&lt;IClock&gt;();</p>
			<p class="source-code">        clock.Now.Returns(DateTime.Now);</p>
			<p class="source-code">        var registrationManager = new </p>
			<p class="source-code">            EventRegistrationManager(null, null, clock</p>
			<p class="source-code">        );</p>
			<p class="source-code">        var evnt = new Event(</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            "1a8j3v0d",</p>
			<p class="source-code">            "Introduction to the ABP Framework",</p>
			<p class="source-code">            DateTime.Now.AddDays(-10), // Start time</p>
			<p class="source-code">            DateTime.Now.AddDays(-9), // End time</p>
			<p class="source-code">            "In this event, we will introduce the ABP</p>
			<p class="source-code">             Framework..."</p>
			<p class="source-code">        );</p>
			<p class="source-code">        registrationManager.IsPastEvent(evnt)</p>
			<p class="source-code">            .ShouldBeTrue();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The test <a id="_idIndexMarker1122"/>code starts by creating a fake <strong class="source-inline">IClock</strong> object using the <strong class="source-inline">Substitute.For&lt;T&gt;</strong> utility method of the <strong class="source-inline">NSubstitute</strong> library. The <strong class="source-inline">clock.Now.Returns(DateTime.Now)</strong> statement configures the fake object so that it returns <strong class="source-inline">DateTime.Now</strong> whenever the <strong class="source-inline">clock.Now</strong> property is called. We do that since the <strong class="source-inline">IsPastEvent</strong> method will call the <strong class="source-inline">clock.Now</strong> property. That means we should know the internal implementation details of the unit-tested method to test it properly.</p>
			<p>Since I know that the <strong class="source-inline">IsPastEvent</strong> method won't use the <strong class="source-inline">IEventRegistrationRepository</strong> and <strong class="source-inline">IGuidGenerator</strong> services, I can pass them as <strong class="source-inline">null</strong> in the constructor of the <strong class="source-inline">EventRegistrationManager</strong> class.</p>
			<p>Finally, I've called <a id="_idIndexMarker1123"/>the <strong class="source-inline">IsPastEvent</strong> method of the <strong class="source-inline">EventRegistrationManager</strong> class with an example event and checked the result.</p>
			<p>Let's see <a id="_idIndexMarker1124"/>a more complex example. This time, we <a id="_idIndexMarker1125"/>are testing the <strong class="source-inline">RegisterAsync</strong> method of the <strong class="source-inline">EventRegistrationManager</strong> class. The code is illustrated in the following snippet:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task </p>
			<p class="source-code">    Valid_Registrations_Should_Be_Inserted_To_Db()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var evnt = new Event(/* some valid arguments */);</p>
			<p class="source-code">    var user = new IdentityUser(/* some valid arguments </p>
			<p class="source-code">                                */);</p>
			<p class="source-code">    var repository =</p>
			<p class="source-code">        Substitute.For&lt;IEventRegistrationRepository&gt;();</p>
			<p class="source-code">    repository</p>
			<p class="source-code">        .ExistsAsync(evnt.Id, user.Id)</p>
			<p class="source-code">        .Returns(Task.FromResult(false));</p>
			<p class="source-code">    var clock = Substitute.For&lt;IClock&gt;();</p>
			<p class="source-code">    clock.Now.Returns(DateTime.Now);</p>
			<p class="source-code">    var guidGenerator = SimpleGuidGenerator.Instance;</p>
			<p class="source-code">    var registrationManager = new EventRegistrationManager(</p>
			<p class="source-code">        repository, guidGenerator, clock</p>
			<p class="source-code">    );</p>
			<p class="source-code">    await registrationManager.RegisterAsync(evnt, user);</p>
			<p class="source-code">    await repository</p>
			<p class="source-code">        .Received()</p>
			<p class="source-code">        .InsertAsync(</p>
			<p class="source-code">            Arg.Is&lt;EventRegistration&gt;(</p>
			<p class="source-code">            er =&gt; er.EventId == evnt.Id &amp;&amp; er.UserId == </p>
			<p class="source-code">                user.Id)</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>First, I've <a id="_idIndexMarker1126"/>created an <strong class="source-inline">Event</strong> object and an <strong class="source-inline">IdentityUser</strong> object because the <strong class="source-inline">RegisterAsync</strong> method gets these parameters. Then, I've mocked the <strong class="source-inline">EventRegistrationManager</strong> dependencies. Since the <strong class="source-inline">RegisterAsync</strong> method uses all the dependencies, I had to mock them all. See how I configured the fake repository to return <strong class="source-inline">false</strong> when the <strong class="source-inline">ExistsAsync</strong> method is called. The <strong class="source-inline">RegisterAsync</strong> method uses the <strong class="source-inline">ExistsAsync</strong> method to check whether there is already a registration with the same event and user.</p>
			<p>After executing the <strong class="source-inline">RegisterAsync</strong> method, I should somehow check whether the registration is complete. I can use the <strong class="source-inline">Received</strong> method of <strong class="source-inline">NSubstitute</strong> to check whether the repository's <strong class="source-inline">InsertAsync</strong> method is called with an <strong class="source-inline">EventRegistration</strong> object with the specified event <a id="_idIndexMarker1127"/>and <strong class="bold">user identifiers</strong> (<strong class="bold">UIDs</strong>).</p>
			<p>In this section, I've covered the basics of unit testing. Unit tests have two main advantages compared to integration tests, as outlined here:</p>
			<ul>
				<li>They run fast because only the tested class really works. All others are mocked and typically <a id="_idIndexMarker1128"/>have no execution cost.</li>
				<li>They make it easier to investigate problems. If a class doesn't work properly, only the tests working on that class fail, so you can easily find the problem's source.</li>
			</ul>
			<p>However, writing and maintaining unit tests is hard when your classes have dependencies. Unit tests also can't tell much about whether your class will properly work at runtime integrated with other services. That brings us to integration tests.</p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor487"/>Building integration tests</h1>
			<p>In this section, we will see how to build automated tests for your services as integrated into ABP <a id="_idIndexMarker1129"/>Framework and other infrastructure components. We will start by understanding ABP integration, how the database is used in integration tests, and how to create initial test data. Then, we will write example tests for repositories, domain, and application services. Let's start with ABP integration.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor488"/>Understanding ABP integration</h2>
			<p>ABP <a id="_idIndexMarker1130"/>provides the <strong class="source-inline">Volo.Abp.TestBase</strong> NuGet package, which includes the <strong class="source-inline">AbpIntegratedTest&lt;TStartupModule&gt;</strong> base class for our integration tests. We <a id="_idIndexMarker1131"/>can inherit from that class to write tests as completely integrated to ABP Framework. The following example shows the main parts of such a test class:</p>
			<p class="source-code">public class SampleTestClass</p>
			<p class="source-code">    : AbpIntegratedTest&lt;MyTestModule&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    private IMyService _myService;</p>
			<p class="source-code">    public SampleTestClass()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _myService = GetRequiredService&lt;IMyService&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    [Fact]</p>
			<p class="source-code">    public async Task TestMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await _myService.DoItAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this <a id="_idIndexMarker1132"/>example, I've inherited from the <strong class="source-inline">AbpIntegratedTest&lt;MyTestModule&gt;</strong> class, where <strong class="source-inline">MyTestModule</strong> is my startup module class. <strong class="source-inline">MyTestModule</strong> should depend on <strong class="source-inline">AbpTestBaseModule</strong>, as shown in the following example:</p>
			<p class="source-code">[DependsOn(typeof(AbpTestBaseModule))]</p>
			<p class="source-code">public class MyTestModule : AbpModule</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker1133"/>constructor of <strong class="source-inline">SampleTestClass</strong>, I've resolved an example service using the <strong class="source-inline">GetRequiredService</strong> method and assigned it to a class field. We could resolve a service from the DI system since all the infrastructure is available, just like at runtime. I don't need to care about the dependencies of the service. Finally, I called a method of the example service in my test method.</p>
			<p>While writing integration tests is that simple, test projects in the startup template have a little more. Check the <strong class="source-inline">EventHubTestBaseModule</strong> class (in the <strong class="source-inline">EventHub.TestBase</strong> project of the EventHub solution). You will see that it is disabling background jobs and authorization, seeding some test data, and doing other configurations.</p>
			<p>We've learned the basics of integrating with ABP in our test classes. In the next section, you will learn how to deal with the database in tests.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor489"/>Mocking the database</h2>
			<p>The database is one of the most fundamental aspects when you are building integration tests. Assume <a id="_idIndexMarker1134"/>that you are using SQL Server in your solution. Using a real SQL Server database has some fundamental problems; your tests affect each other since they will work on the same database. A test's change in the database may break subsequent tests. You may not run tests in parallel. Test execution speed will be slow since your application will communicate to SQL Server as an external process. No need to mention that SQL Server should be installed and available in your test environment.</p>
			<p>EF Core provides an in-memory database option, but it is very limited. For example, it has no transaction support and cannot execute SQL commands. So, I don't suggest using it at all.</p>
			<p>The ABP startup template has been configured to use SQLite in-memory database for EF Core (it also uses an in-memory database for MongoDB using the <strong class="source-inline">Mongo2Go</strong> library). SQLite is a real relational database management system and will be sufficient for most of the applications.</p>
			<p>Check the <strong class="source-inline">EventHubEntityFrameworkCoreTestModule</strong> class (in the <strong class="source-inline">EventHub.EntityFrameworkCore.Tests</strong> project of the EventHub solution) to see the SQLite setup. It creates a separate in-memory SQLite database for each test case, creates tables inside the database, and seeds the test data. In this way, every test method starts with the same initial state and doesn't affect other tests. We will see seeding the test data in the next section.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor490"/>Seeding the test data</h2>
			<p>Writing tests against an empty database is not so practical. Assume that you want to query <a id="_idIndexMarker1135"/>events in the database or want to test whether the event registration code works. You first need to insert some entities into the database. It can be tedious to prepare the database for each test. Instead, we can create some initial entities in the database that are available for each test.</p>
			<p>The ABP startup solution template uses ABP's data seeding system to fill some initial data into the database. See the <strong class="source-inline">EventHubTestDataSeedContributor</strong> class (in the <strong class="source-inline">EventHub.TestBase</strong> project of the EventHub solution). It creates some users, organizations, and events in the database, so we can directly write tests assuming that the initial data exists.</p>
			<p>We've talked about ABP's integration test infrastructure, mocking and seeding the database. Now, we can write some integration tests, starting from the repositories.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor491"/>Testing repositories</h2>
			<p>Let's see <a id="_idIndexMarker1136"/>the <strong class="source-inline">EventRegistrationRepository_Tests</strong> class (in the <strong class="source-inline">EventHub.Domain.Tests</strong> project of the EventHub solution) as an example:</p>
			<p class="source-code">public class EventRegistrationRepository_Tests</p>
			<p class="source-code">    : EventHubDomainTestBase</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IEventRegistrationRepository </p>
			<p class="source-code">        _repository;</p>
			<p class="source-code">    private readonly EventHubTestData _testData;</p>
			<p class="source-code">    public EventRegistrationRepository_Tests()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _repository = GetRequiredService&lt;</p>
			<p class="source-code">                      IEventRegistrationRepository&gt;();</p>
			<p class="source-code">        _testData = GetRequiredService&lt;EventHubTestData&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // TODO: Test methods come here...</p>
			<p class="source-code">}</p>
			<p>This class inherits the <strong class="source-inline">EventHubDomainTestBase</strong> class, which is indirectly inherited from the <strong class="source-inline">AbpIntegratedTest&lt;T&gt;</strong> class we've explored in the <em class="italic">Understanding the ABP integration</em> section. So, in the constructor, we could resolve the <strong class="source-inline">IEventRegistrationRepository</strong> and <strong class="source-inline">EventHubTestData</strong> services from the DI system. You can investigate the <strong class="source-inline">EventHubTestData</strong> class yourself (in the <strong class="source-inline">EventHub.TestBase</strong> project of the EventHub solution). It basically stores the <strong class="source-inline">Id</strong> values of the entities that are initially seeded into the database to reach them in the tests.</p>
			<p>Let's see the first test method of the <strong class="source-inline">EventRegistrationRepository_Tests</strong> class. Here it is:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task</p>
			<p class="source-code">    Exists_Should_Return_False_If_Not_Registered()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var exists = await _repository.ExistsAsync(</p>
			<p class="source-code">        _testData.AbpMicroservicesFutureEventId, </p>
			<p class="source-code">        _testData.UserJohnId);</p>
			<p class="source-code">    exists.ShouldBeFalse();</p>
			<p class="source-code">}</p>
			<p>This test <a id="_idIndexMarker1137"/>simply executes the <strong class="source-inline">ExistsAsync</strong> method and checks the result to be <strong class="source-inline">false</strong>. It should return <strong class="source-inline">false</strong> because we know the user <strong class="source-inline">John</strong> has not registered to the given event. We know that because we've written the initial data in the database (see the <em class="italic">Seeding the test data</em> section). Let's write another test, as follows:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task Exists_Should_Return_True_If_Registered()</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _repository.InsertAsync(</p>
			<p class="source-code">        new EventRegistration(</p>
			<p class="source-code">            Guid.NewGuid(),</p>
			<p class="source-code">            _testData.AbpMicroservicesFutureEventId,</p>
			<p class="source-code">            _testData.UserJohnId));</p>
			<p class="source-code">    </p>
			<p class="source-code">    var exists = await _repository.ExistsAsync(</p>
			<p class="source-code">        _testData.AbpMicroservicesFutureEventId, </p>
			<p class="source-code">        _testData.UserJohnId);</p>
			<p class="source-code">    exists.ShouldBeTrue();</p>
			<p class="source-code">}</p>
			<p>This time, we <a id="_idIndexMarker1138"/>are creating the registration record in the database, so we expect the same <strong class="source-inline">ExistsAsync</strong> call to return <strong class="source-inline">true</strong>. In this way, we can prepare the database for a particular test to get the expected result.</p>
			<p>ABP's <a id="_idIndexMarker1139"/>repositories provide the <strong class="source-inline">GetQueryableAsync</strong> method, so <a id="_idIndexMarker1140"/>we can directly use <strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>) on the database. See the following example test method (this test is not included in EventHub but is provided here to be an example of using <strong class="source-inline">queryable</strong> in tests):</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task Test_Querying()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var queryable = await _repository.GetQueryableAsync();</p>
			<p class="source-code">    var exists = await queryable.Where(</p>
			<p class="source-code">        x =&gt; x.EventId ==</p>
			<p class="source-code">             _testData.AbpMicroservicesFutureEventId &amp;&amp;</p>
			<p class="source-code">             x.UserId == _testData.UserJohnId</p>
			<p class="source-code">        ).FirstOrDefaultAsync();</p>
			<p class="source-code">    exists.ShouldBeNull();</p>
			<p class="source-code">}</p>
			<p>This method queries the same registration using the <strong class="source-inline">Where</strong> and <strong class="source-inline">FirstOrDefaultAsync</strong> LINQ extension methods. If you try to run this test, you will see it throws an exception (of type <strong class="source-inline">ObjectDisposedException</strong>) because the <strong class="source-inline">GetQueryableAsync</strong> method requires <a id="_idIndexMarker1141"/>an active <strong class="bold">unit of work</strong> (<strong class="bold">UoW</strong>) (see the <em class="italic">Understanding the UoW system</em> section of <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure,</em> to remember ABP's UoW system). The base test class provides the <strong class="source-inline">WithUnitOfWorkAsync</strong> method to <a id="_idIndexMarker1142"/>execute code in a UoW, so we can fix the test code as shown in the following code block:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task Test_Querying_With_Uow()</p>
			<p class="source-code">{</p>
			<p class="source-code">    await WithUnitOfWorkAsync(async () =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var queryable = </p>
			<p class="source-code">            await _repository.GetQueryableAsync();</p>
			<p class="source-code">        var exists = await queryable.Where(</p>
			<p class="source-code">            x =&gt; x.EventId ==</p>
			<p class="source-code">                 _testData.AbpMicroservicesFutureEventId &amp;&amp;</p>
			<p class="source-code">                 x.UserId == _testData.UserJohnId</p>
			<p class="source-code">        ).FirstOrDefaultAsync();</p>
			<p class="source-code">        exists.ShouldBeNull();</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>You can <a id="_idIndexMarker1143"/>see the source code of the <strong class="source-inline">WithUnitOfWorkAsync</strong> method. It just uses <strong class="source-inline">IUnitOfWorkManager</strong> to create a UoW scope.</p>
			<p>We've created some test methods for repositories. You can test any service (that was registered to the DI system) in the same way. I will show some example tests for domain and application services in the next two sections.</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor492"/>Testing domain services</h2>
			<p>Testing domain <a id="_idIndexMarker1144"/>services is similar to testing repositories since you should also care about the UoW for domain services. The following code block shows an example test case from the <strong class="source-inline">EventManager_Tests</strong> class (in the <strong class="source-inline">EventHub.Domain.Tests</strong> project of the EventHub solution):</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task Should_Update_The_Event_Capacity()</p>
			<p class="source-code">{</p>
			<p class="source-code">    const int newCapacity = 42;</p>
			<p class="source-code">    await WithUnitOfWorkAsync(async () =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var @event = await _eventRepository.GetAsync(</p>
			<p class="source-code">            _testData.AbpMicroservicesFutureEventId);</p>
			<p class="source-code">        await _eventManager.SetCapacityAsync(</p>
			<p class="source-code">            @event,</p>
			<p class="source-code">            newCapacity</p>
			<p class="source-code">        );</p>
			<p class="source-code">    });</p>
			<p class="source-code">    </p>
			<p class="source-code">    var @event = await _eventRepository.GetAsync(</p>
			<p class="source-code">        _testData.AbpMicroservicesFutureEventId);</p>
			<p class="source-code">    @event.Capacity.ShouldBe(newCapacity);</p>
			<p class="source-code">}</p>
			<p>The test's purpose is to increase the capacity of an event using the <strong class="source-inline">EventManager</strong> domain service and see whether it works. It uses the <strong class="source-inline">WithUnitOfWorkAsync</strong> method to call the <strong class="source-inline">SetCapacityAsync</strong> method because the <strong class="source-inline">SetCapacityAsync</strong> method internally executes the <strong class="source-inline">CountAsync</strong> LINQ extension method and requires an active UoW. If you don't want to check the domain service's internals in every case, I suggest always starting a UoW while using domain services or repositories in your tests. After the UoW, I've re-queried <a id="_idIndexMarker1145"/>the same event from the database to check whether the capacity has been updated.</p>
			<p>You can explore the <strong class="source-inline">EventManager_Tests</strong> class and other test classes inside the <strong class="source-inline">EventHub.Domain.Tests</strong> project for all details and more complex test cases. In the next section, I will show testing application services.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor493"/>Testing application services</h2>
			<p>In this <a id="_idIndexMarker1146"/>section, we will examine one more test, written for the <strong class="source-inline">EventRegistrationAppService</strong> class (defined in the <strong class="source-inline">EventHub.Application</strong> project of the EventHub solution). <strong class="source-inline">EventRegistrationAppService_Tests</strong> (defined in the <strong class="source-inline">EventHub.Application.Tests</strong> project of the EventHub solution) is the test class that contains tests for that application service. You can explore the class inside the solution. Here, I will show it partially to explain how it works.</p>
			<p>Let's start with the test method for registering an event by the current user. You can see this here:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task Should_Register_To_An_Event()</p>
			<p class="source-code">{</p>
			<p class="source-code">    Login(_testData.UserAdminId);</p>
			<p class="source-code">    await _eventRegistrationAppService.RegisterAsync(</p>
			<p class="source-code">        _testData.AbpMicroservicesFutureEventId</p>
			<p class="source-code">    );</p>
			<p class="source-code">    var registration = await GetRegistrationOrNull(</p>
			<p class="source-code">        _testData.AbpMicroservicesFutureEventId,</p>
			<p class="source-code">        _currentUser.GetId()</p>
			<p class="source-code">    );    </p>
			<p class="source-code">    registration.ShouldNotBeNull();</p>
			<p class="source-code">}</p>
			<p>The first <a id="_idIndexMarker1147"/>line sets the current user to <a id="_idIndexMarker1148"/>the admin user, which is needed because the <strong class="source-inline">EventRegistrationAppService.RegisterAsync</strong> method works for the current user. Let's see how the <strong class="source-inline">Login</strong> method was implemented, as follows:</p>
			<p class="source-code">private void Login(Guid userId)</p>
			<p class="source-code">{</p>
			<p class="source-code">    _currentUser.Id.Returns(userId);</p>
			<p class="source-code">    _currentUser.IsAuthenticated.Returns(true);</p>
			<p class="source-code">}</p>
			<p>It configures the <strong class="source-inline">_currentUser</strong> object to return the given <strong class="source-inline">userId</strong> value when we use its <strong class="source-inline">Id</strong> property. As you may guess, <strong class="source-inline">_currentUser</strong> is a mock (fake) object of type <strong class="source-inline">ICurrentUser</strong>. The mock object is configured in the <strong class="source-inline">AfterAddApplication</strong> method, as illustrated in the following code snippet:</p>
			<p class="source-code">protected override void AfterAddApplication(</p>
			<p class="source-code">    IServiceCollection services)</p>
			<p class="source-code">{</p>
			<p class="source-code">    _currentUser = Substitute.For&lt;ICurrentUser&gt;();</p>
			<p class="source-code">    services.AddSingleton(_currentUser);</p>
			<p class="source-code">}</p>
			<p>This method overrides the <strong class="source-inline">AfterAddApplication</strong> method of the <strong class="source-inline">AbpIntegratedTest&lt;T&gt;</strong> base class. We can override this method to make a last touch to the DI configuration before the initialization phase completes. Here, I've created a mock object using the <strong class="source-inline">NSubstitute</strong> library and added the object as a singleton service (remember that the last registered class/object is used for a service). In this way, I can change its value, and all the services using <strong class="source-inline">ICurrentUser</strong> are affected.</p>
			<p>After <a id="_idIndexMarker1149"/>setting the current user, the test method calls the <strong class="source-inline">EventRegistrationAppService.RegisterAsync</strong> method as you normally <a id="_idIndexMarker1150"/>do. Finally, I checked the database to see whether a registration record was saved. The <strong class="source-inline">GetRegistrationOrNull</strong> method's implementation is shown in the following code block:</p>
			<p class="source-code">private async Task&lt;EventRegistration&gt;</p>
			<p class="source-code">    GetRegistrationOrNull(Guid eventId, Guid userId)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return await WithUnitOfWorkAsync(async () =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return await _eventRegistrationRepository</p>
			<p class="source-code">           .FirstOrDefaultAsync(</p>
			<p class="source-code">                x =&gt; x.EventId == eventId &amp;&amp; x.UserId == </p>
			<p class="source-code">                    userId</p>
			<p class="source-code">        );</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>I've used <strong class="source-inline">WithUnitOfWorkAsync</strong> here again because the <strong class="source-inline">FirstOrDefaultAsync</strong> method requires an active UoW.</p>
			<p>As we've seen in the examples, writing integration tests is easy and mostly straightforward with ABP Framework. We rarely need to mock services and deal with the dependencies of the service we are targeting for the test.</p>
			<p>Integration tests run slower than unit tests, but they allow you to test the integration between components and additionally test database queries in a way you can't with unit tests. I suggest going balanced and pragmatic—build both unit and integration tests for your solutions.</p>
			<h1 id="_idParaDest-369"><a id="_idTextAnchor494"/>Summary</h1>
			<p>Preparing tests is an essential practice for building any kind of software solution. As we've seen in this chapter, ABP provides the fundamental infrastructure to help you write tests for your applications.</p>
			<p>We have explored unit and integration testing with ABP Framework with examples. I've selected examples from the EventHub solution. That solution also contains more complex tests, and I suggest you explore them.</p>
			<p>By now, you should be writing automated tests to cover your server-side code. You've seen how the ABP startup solution is structured and how the database was mocked. You've learned how to deal with exceptions, UoWs, data seeding, object mocking, and other common test patterns.</p>
			<p>This was the last chapter of the book. If you've read so far and followed the examples, you've learned the fundamentals, features, and best practices of using ABP Framework. You are more than ready to build your ABP based solutions to realize your software ideas.</p>
			<p>You can refer to this book on your development journey, and also check ABP Framework's documentation on <a href="https://docs.abp.io">https://docs.abp.io</a> whenever you need more details and up-to-date information.</p>
			<p>Lastly, feel free to create issues on ABP Framework's GitHub repository if you have any problem: <a href="https://github.com/abpframework/abp">https://github.com/abpframework/abp</a>. I will continue to be one of the active contributors of this great project and try to answer your questions.</p>
			<p>I am Halil İbrahim Kalkan, author of Mastering ABP Framework. I really hope you enjoyed reading this book and found it useful for increasing your productivity and efficiency in ABP Framework. </p>
			<p>It would really help me (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on Mastering ABP Framework here. </p>
			<p>Go to the link below or scan the QR code to leave your review:</p>
			<p><a href="https://packt.link/r/1801079242">https://packt.link/r/1801079242</a></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/QR_Code.jpg" alt=""/>
				</div>
			</div>
			<p>Your review will help me to understand what’s worked well in this book, and what could be improved upon for future editions, so it really is appreciated.</p>
			<p>Best Wishes,</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Author_signature.jpg" alt=""/>
				</div>
			</div>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Author_photo.jpg" alt=""/>
				</div>
			</div>
			<p>Halil İbrahim Kalkan</p>
		</div>
		<div id="_idContainer142" class="Basic-Text-Frame">
			<p class="hidden">     </p>
		</div>
	</body></html>