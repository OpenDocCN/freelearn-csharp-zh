- en: Playing with Physics and Fire
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与物理和火焰玩耍
- en: In this chapter, we will use physics and other Unity features to build variations
    of an interactive ball game. Along the way, we explore managing objects, Rigidbody
    physics, and adding more interactivity to the virtual experience. You will see
    how properties and materials based on physics can be added to objects, as well
    as more on C# scripting, particle effects, and music.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用物理和其他 Unity 功能来构建交互式球类游戏的变体。在这个过程中，我们将探讨管理对象、Rigidbody 物理以及增加虚拟体验的交互性。您将看到如何将基于物理的属性和材料添加到对象中，以及更多关于
    C# 脚本、粒子效果和音乐的内容。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: The Unity physics engine, the Unity Rigidbody component, and Physic Materials
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 物理引擎、Unity Rigidbody 组件和物理材料
- en: Using velocity and gravity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用速度和重力
- en: Managing object lifetime and object pooling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理对象生命周期和对象池
- en: Interacting with objects in VR using your head and hands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用头部和双手在 VR 中与对象交互
- en: Building a fireball using particle effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子效果构建火球
- en: Synchronizing with music
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与音乐同步
- en: Note that the projects in this chapter are separate and are not directly required
    by the other chapters in this book. If you decided to skip any of it or not save
    your work, that's OK.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的项目是独立的，并不直接需要本书其他章节中的其他章节。如果您决定跳过其中任何部分或未保存您的作品，那都是可以的。
- en: Unity physics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 物理引擎
- en: 'In Unity, the behavior of an object that is based on physics is defined separately
    from its mesh (shape), materials (UV texture), and the renderer properties. The
    items that play into physics include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，基于物理的对象的行为与其网格（形状）、材质（UV 纹理）和渲染器属性是分开定义的。影响物理的项包括以下内容：
- en: '**Rigidbody**: Enables the object to act under the control of the physics engine,
    receive forces and torque to move in a realistic way'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rigidbody**：使对象能够在物理引擎的控制下行动，接收力矩以实现现实的方式移动'
- en: '**Collider**: Defines a simplified, approximated shape of the object used for
    calculating collisions with other objects'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collider**：定义了用于计算与其他对象碰撞的简化、近似形状的对象'
- en: '**Physic Material**: Defines friction and bounce effects of colliding objects'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Physic Material**：定义了碰撞对象的摩擦和弹跳效果'
- en: '**Physics Manager**: Applies global settings for 3D physics for your project'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Physics Manager**：为您的项目应用 3D 物理的全局设置'
- en: Basically, physics (in this context) is defined by the positional and rotational
    forces that affect the transform of an object, such as gravity, friction, momentum,
    and collisions with other objects. It is not necessarily a perfect simulation
    of physics in the real world because it's optimized for performance and separation
    of concerns to facilitate animation. Besides, virtual worlds might just need their
    own laws of physics that aren't found in our God-given universe!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，物理（在此上下文中）是由影响对象变换的位置和旋转力定义的，例如重力、摩擦、动量和与其他对象的碰撞。它并不一定是现实世界中物理的完美模拟，因为它针对性能和关注点的分离进行了优化，以促进动画。此外，虚拟世界可能只需要它们自己的物理定律，而这些定律在我们的宇宙中是找不到的！
- en: Unity integrates the **NVIDIA PhysX** engine, a real-time physics calculation
    middleware, which implements classical Newtonian mechanics for games and 3D applications.
    This multiplatform software is optimized to utilize fast hardware processors when
    present. It is accessible via the Unity scripting API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 集成了 **NVIDIA PhysX** 引擎，这是一种实时物理计算中间件，为游戏和 3D 应用实现了经典牛顿力学。此多平台软件在存在时针对快速硬件处理器进行了优化。它可以通过
    Unity 脚本 API 访问。
- en: A key to physics is the Rigidbody component that you add to objects. Rigidbodies
    have parameters for gravity, mass, and drag, among others. Rigidbodies can automatically
    react to gravity and collisions with other objects. No extra scripting is needed
    for this. During gameplay, the engine calculates each rigid object's momentum
    and updates its transform position and rotation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 物理的关键是添加到对象中的 Rigidbody 组件。Rigidbody 具有重力、质量、阻力等参数。Rigidbody 可以自动对重力和其他对象的碰撞做出反应。无需额外的脚本编写。在游戏过程中，引擎计算每个刚体对象的动量并更新其变换位置和旋转。
- en: Details on Rigidbodies can be found at [http://docs.unity3d.com/ScriptReference/Rigidbody.html](http://docs.unity3d.com/ScriptReference/Rigidbody.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Rigidbody 的详细信息可以在 [http://docs.unity3d.com/ScriptReference/Rigidbody.html](http://docs.unity3d.com/ScriptReference/Rigidbody.html)
    找到。
- en: Unity projects have a global gravity setting, found in the project's Physics
    Manager by navigating to Edit | Project Settings | Physics. As you might expect,
    the default gravity setting is a Vector3 with values (`0`, `-9.81`, `0`) that
    apply a downward force to all Rigidbodies. Gravity is in meters per second squared.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 项目有一个全局重力设置，可以在项目设置中的物理管理器中找到，方法是导航到 Edit | Project Settings | Physics。正如您所期望的，默认的重力设置是一个具有值的
    Vector3 (`0`, `-9.81`, `0`)，它对所有 Rigidbody 应用向下的力。重力以每秒平方米计算。
- en: Rigidbodies can automatically react to gravity and collisions with other objects.
    Extra scripting is not needed for this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体可以自动对重力和其他物体的碰撞做出反应。不需要额外的脚本编写。
- en: In order to detect a collision, both the colliding objects must have a `Collider`
    component. There are built-in colliders with basic geometric shapes such as a
    cube, sphere, cylinder, and a capsule. A mesh collider can assume an arbitrary
    shape. If you can, it's best to use one or more basic collider shapes that approximately
    fit the actual object, rather than a mesh collider to reduce the expense of calculating
    the actual collisions during gameplay. Unity requires that if your object will
    be used in physics and has a Rigidbody, then its mesh collider must be marked
    as convex and be limited to 255 triangles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测碰撞，碰撞的物体都必须具有 `Collider` 组件。有内置的具有基本几何形状的碰撞器，例如立方体、球体、圆柱体和胶囊。网格碰撞器可以假设任意形状。如果可能的话，最好使用一个或多个基本碰撞器形状，这些形状大致适合实际物体，而不是使用网格碰撞器，以减少游戏过程中实际碰撞计算的消耗。Unity
    要求，如果您的对象将用于物理并且具有 Rigidbody，则其网格碰撞器必须标记为凸形，并且限制为 255 个三角形。
- en: When rigid objects collide, the forces pertinent to each object in the collision
    are applied to the others. The values of the resulting forces are calculated based
    on the objects' current velocity and body mass. Other factors are also taken into
    consideration, such as gravity and drag (that is, resistance). Furthermore, you
    have options to add constraints to freeze the position or rotation of a given
    object in any of its *x*, *y*, and *z* axes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚性物体碰撞时，碰撞中每个物体的相关力会作用于其他物体。这些力的值是根据物体的当前速度和体重计算的。还会考虑其他因素，例如重力（即阻力）。此外，您可以选择添加约束来冻结给定物体在任何
    *x*、*y* 和 *z* 轴上的位置或旋转。
- en: The calculations can be further affected when a Physic Material is assigned
    to the object's collider, which adjusts the friction and the bounciness effects
    of the colliding objects. These properties will be applied only to the object
    that owns the Physic Material. (Note that it's really spelled *Physic Material*
    rather than *Physics Material* for historical reasons.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当将物理材料分配给对象的碰撞器时，计算可以进一步受到影响，这会调整碰撞物体的摩擦和弹性效果。这些属性仅适用于拥有物理材料的对象。（注意，由于历史原因，它实际上拼写为
    *Physic Material* 而不是 *Physics Material*。）
- en: So, let's say that Object A (Ball) hits Object B (Brick). If Object A has bounciness
    and Object B does not, Object A will have an impulse applied in the collision,
    but Object B will not. However, you have options to determine how their friction
    and bounciness combine, as we'll see next. It's not necessarily an accurate simulation
    of real-world physics. It's a game engine, not a computer-aided engineering modeler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设对象 A（球）击中对象 B（砖块）。如果对象 A 有弹性而对象 B 没有，则在碰撞中对象 A 将会有一个冲量，但对象 B 不会有。然而，您可以选择确定它们的摩擦和弹性的组合方式，正如我们接下来将要看到的。这并不一定是一个真实世界物理的准确模拟。这是一个游戏引擎，而不是计算机辅助工程模型器。
- en: From a scripting point of view, Unity will trigger events when objects collide
    (`OnTriggerEnter`), each frame while objects are colliding (`OnTriggerStay`),
    and when they've stopped colliding (`OnTriggerExit`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本的角度来看，Unity 会在物体碰撞时触发事件（`OnTriggerEnter`），在物体碰撞的每一帧触发（`OnTriggerStay`），以及当它们停止碰撞时（`OnTriggerExit`）。
- en: If this sounds daunting, read on. The rest of this chapter breaks it down into
    understandable bits and pieces.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来令人畏惧，请继续阅读。本章的其余部分将将其分解成可理解的部分。
- en: Bouncy balls
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性球
- en: The feature we'll implement here is, when a ball drops from mid-air and hits
    the ground, it bounces back up and down, and up again, diminished over time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要实现的功能是，当一个球从空中落下并击中地面时，它会弹起并上下跳动，然后再次弹起，随着时间的推移逐渐减弱。
- en: 'We are going to start simply with a new scene that consists of a ground plane
    and a sphere. Then, we''ll add physics to it, a bit at a time, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的场景开始，该场景由地面平面和球体组成。然后，我们将逐步添加物理效果，如下所示：
- en: Create a new scene by navigating to File | New Scene.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 File | New Scene 创建一个新的场景。
- en: Then, navigate to File | Save Scene As... and name it `BallsFromHeaven`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到文件 | 保存场景为... 并将其命名为 `BallsFromHeaven`。
- en: Create a new plane by navigating to GameObject | 3D Object | Plane and reset
    its transform using the `Transform` component's *gear* icon | Reset.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 GameObject | 3D Object | Plane 创建一个新的平面，并使用 `Transform` 组件的 *齿轮* 图标重置其变换。
- en: Create a new sphere by navigating to GameObject | 3D Object | Sphere and rename
    it `BouncyBall`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 GameObject | 3D Object | Sphere 创建一个新的球体，并将其重命名为 `BouncyBall`。
- en: Set its Scale to (`0.5`, `0.5`, `0.5`) and Position to (`0`, `5`,`0`) so that
    it's above the center of the plane.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为 (`0.5`, `0.5`, `0.5`) 并将其位置设置为 (`0`, `5`,`0`)，使其位于平面的中心上方。
- en: Drag the Red material from Project Assets (created in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects and Scale*) onto it so that it looks like a bouncy ball.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目资产中的红色材质拖到它上面，使其看起来像一个弹跳球。
- en: The new Unity scene defaults come with Directional Light and Main Camera. It's
    OK to use this Main Camera for the time being.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Unity 场景默认包含方向光和主摄像机。暂时使用这个主摄像机是可以的。
- en: Click on the *Play* button. Nothing happens. The ball just sits in mid-air and
    doesn't move.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 *播放* 按钮。没有任何事情发生。球就停在空中，不动。
- en: 'Now, let''s give it a Rigidbody, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给它一个 Rigidbody，如下所示：
- en: With `BouncyBall` selected, in Inspector, navigate to Add Component | Physics
    | Rigidbody.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BouncyBall` 选择的情况下，在检查器中，导航到添加组件 | 物理 | Rigidbody。
- en: Click on the *Play* button. It drops like a lead balloon.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *播放* 按钮。它像铅球一样掉落。
- en: 'Let''s make it bounce, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让它弹跳，如下所示：
- en: In the Project panel, select the top-level Assets folder, navigate to Create
    | Folder, and rename it to `Physics`
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，选择顶级资产文件夹，导航到创建 | 文件夹，并将其重命名为 `Physics`
- en: With the `Physics` folder selected, create a material by navigating to Assets
    | Create | Physic Material (or right-click within the folder)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Physics` 文件夹中选择，通过导航到 Assets | 创建 | 物理材质 （或在该文件夹内右键单击）创建一个材质。
- en: Name it `Bouncy`
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `Bouncy`
- en: Set its Bounciness value to `1`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其弹跳性值设置为 `1`
- en: With the `BouncyBall` sphere selected in Hierarchy, drag the `Bouncy` asset
    from Project onto the sphere's Collider material field in Inspector
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 `BouncyBall` 球体，将 `Bouncy` 资产从项目拖到检查器中球体的碰撞器材质字段。
- en: 'Click on the *Play* button. It bounces, but it does not go very high. We used
    the maximum value for Bounciness as `1.0`. What''s slowing it down? It''s not
    the Friction settings. Rather, the Bounce Combine is set to Average, which determines
    how much of the bounciness of the ball (1) is mixed with that of the plane (0).
    So, it diminishes rapidly over time. We want the ball to retain all its bounciness.
    We will accomplish this, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 *播放* 按钮。球弹跳了，但并没有跳得很高。我们使用了最大值 `1.0` 作为弹跳性。是什么让它减速？不是摩擦设置。而是弹跳组合设置为平均，这决定了球（1）的弹跳性与平面（0）的弹跳性混合的程度。因此，它随时间迅速减弱。我们希望球保持所有的弹跳性。我们将按以下方式实现：
- en: Change the `Bouncy` object's Bounce Combine to Maximum.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Bouncy` 对象的弹跳组合改为最大。
- en: Click on the *Play* button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *播放* 按钮。
- en: Much better. Actually, too much better. The ball keeps bouncing back up to its
    original height, ignoring gravity. Now, change the Bounciness to `0.8`. The bounces
    diminish, and the ball will eventually come to a stop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。实际上，好得太多了。球一直弹跳回到原来的高度，忽略了重力。现在，将弹跳性改为 `0.8`。弹跳减弱，球最终会停下来。
- en: 'Let''s check it out in VR, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 VR 中检查它，如下所示：
- en: Delete the default Main Camera from the Hierarchy root.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构根删除默认的主摄像机。
- en: Drag the `MeMyselfEye` prefab from Project Assets into the scene. Set its Position
    to (`0`, `0`, `-4`).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MeMyselfEye` 预制件从项目资产拖到场景中。将其位置设置为 (`0`, `0`, `-4`)。
- en: Run it in VR. Pretty neat! Even the simplest things look impressive in VR.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VR 中运行它。非常酷！即使在 VR 中最简单的东西看起来也很令人印象深刻。
- en: Unity's Standard Assets package includes a handful of example physic materials,
    including Bouncy, Ice, Meta, Rubber, and Wood.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的标准资产包包括一些示例物理材质，包括 Bouncy、Ice、Meta、Rubber 和 Wood。
- en: 'OK, let''s have some fun. Make it rain bouncy balls! To do this, we''ll make
    the ball a prefab and write a script that instantiates new balls, dropping them
    from random positions, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来点乐趣。让它下起弹跳球雨！为此，我们将球体制作成预制件，并编写一个脚本，实例化新的球体，从随机位置掉落，如下所示：
- en: Drag the `BouncyBall` object from Hierarchy into the `Project Assets/Prefabs`
    folder, making it a prefab.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BouncyBall` 对象从层次结构拖到 `Project Assets/Prefabs` 文件夹中，使其成为一个预制件。
- en: Delete the `BouncyBall` object from the Hierarchy, since we'll be instantiating
    it with a script.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中删除 `BouncyBall` 对象，因为我们将通过脚本实例化它。
- en: Create an empty game controller object to attach the script to by navigating
    to GameObject | Create Empty. Rename it `GameController`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 GameObject | 创建空对象来创建一个空的游戏控制器对象，并将其命名为 `GameController`。
- en: In Inspector, navigate to Add Component | New Script, name it `BallsFromHeaven`,
    and open the script for editing.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，导航到添加组件 | 新脚本，将其命名为 `BallsFromHeaven`，并打开脚本进行编辑。
- en: 'Edit the script so that it looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑脚本，使其看起来像这样：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script drops a new ball from `startHeight` at the rate of every `interval`
    seconds (an interval of 0.5 means that a new ball is dropped every half second).
    The new ball position is at a random X-Z coordinate between `-4` and `4`. The
    `Instantiate()` function adds a new ball into the scene Hierarchy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本以每 `interval` 秒的速率从 `startHeight` 位置掉落一个新的球体（0.5 的间隔意味着每半秒掉落一个新的球体）。新球的位置在
    `-4` 和 `4` 之间的随机 X-Z 坐标。`Instantiate()` 函数将一个新的球体添加到场景层次结构中。
- en: 'Save the script. We now need to populate the Ball field with the `BouncyBall`
    prefab, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。我们现在需要用 `BouncyBall` 预制件填充 Ball 字段，如下所示：
- en: With `GameController` selected in Hierarchy, drag the `BouncyBall` prefab from
    the `Project Assets/Prefabs` folder onto the Ball Prefab slot in the Balls From
    Heaven (Script) panel in Inspector.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 `GameController`，将 `BouncyBall` 预制件从 `Project Assets/Prefabs` 文件夹拖到检查器中
    Balls From Heaven（脚本）面板的 Ball 预制件槽中。
- en: Be sure to use the `BouncyBall` prefab from Project Assets so that can be instantiated.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保使用来自项目资源的 `BouncyBall` 预制件，以便可以实例化。
- en: Save the scene. Run it in VR. Fun!
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。在 VR 中运行它。很有趣！
- en: 'This is what I get:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我得到的结果：
- en: '![](img/e7f360b3-958d-4b64-9112-97115152fc74.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7f360b3-958d-4b64-9112-97115152fc74.png)'
- en: In summary, we created a sphere with a Rigidbody and added a Physic Material
    with a Bounciness property of `0.8` and Bounce Combine to Maximum. Then, we saved
    the `BouncyBall` as a prefab and wrote a script to instantiate new balls that
    drop from above.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们创建了一个带有 Rigidbody 的球体，并添加了一个具有 `0.8` 弹性系数和最大弹跳组合的物理材质。然后，我们将 `BouncyBall`
    保存为预制件，并编写了一个脚本以实例化从上方掉落的新的球体。
- en: Managing game objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理游戏对象
- en: Whenever you have a script that instantiates objects, you must be aware of the
    life cycle of the object and possibly arrange to destroy it when it is no longer
    needed. You can destroy game objects, for example, after it is no longer visible
    in the scene, or after a specific life duration, or limit the scene to a maximum
    number of balls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个实例化对象的脚本时，你必须意识到对象的生命周期，并可能安排在不再需要时销毁它。例如，你可以销毁游戏对象，在它不再在场景中可见后，或者在特定的生命周期后，或者限制场景中球体的最大数量。
- en: Destroying fallen objects
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁掉落的对象
- en: 'In our scene, we have a limited size ground plane and as balls hit one another,
    some will fall off the plane into oblivion. At that point, we can remove the fallen
    ball from the scene. Watch the Hierarchy panel as new balls are instantiated.
    Note that some balls end up bouncing off the plane platform but remain in the
    Hierarchy panel. We need to clean this up by adding a script that destroys the
    balls that are out of play, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们有一个有限大小的地面平面，当球体相互碰撞时，一些球体会掉落到平面之外。在那个时刻，我们可以从场景中移除掉落的球体。观察层次结构面板，注意新球体的实例化。注意，一些球体最终会从平面平台上弹跳出来，但仍然留在层次结构面板中。我们需要通过添加一个脚本来清理这些球体，如下所示：
- en: Select the `BouncyBall` prefab in `Project Assets/Prefabs`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Project Assets/Prefabs` 中选择 `BouncyBall` 预制件
- en: Navigate to Add Component | New Script and name it `DestroyBall`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到添加组件 | 新脚本，并将其命名为 `DestroyBall`
- en: 'Here''s a `DestroyBall.cs` script, which will destroy the object if its Y position
    is well below the ground plane (Y = `0`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 `DestroyBall.cs` 脚本，如果对象的 Y 位置低于地面平面很多（Y = `0`），则会销毁该对象：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting a limited lifetime
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置有限的生命周期
- en: Another strategy for managing object life cycle is to limit their duration.
    This is especially effective for things like projectiles (bullets, arrows, bouncyballs)
    or other objects that the player cares about most when its instantiated and then
    isn't paying attention to as gameplay moves on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象生命周期的一种策略是限制它们的持续时间。这对于像弹射物（子弹、箭矢、弹跳球）或其他玩家在实例化时最关心的对象，在游戏进行时不再关注的情况尤其有效。
- en: To implement, you could put a timer on the object prefab itself to destroy itself
    when time runs out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现，你可以在对象预制件本身上设置一个计时器，当时间耗尽时销毁它。
- en: 'Modify the `DestroyBall.cs` script to destroy the object after `delay` seconds:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`DestroyBall.cs`脚本，在`delay`秒后销毁对象：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you play, notice that the ground plane remains substantially less crowded
    than before. Each BouncyBall will be destroyed after 15 seconds or when it has
    fallen off the plane, whichever comes first.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩游戏时，注意地面平面比以前少得多。每个BouncyBall将在15秒后或当它从平面上掉落时被销毁，以先发生者为准。
- en: Implementing an object pool
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对象池
- en: If your `GameController` Interval is 0.5 seconds and the destroy timer is 15,
    then (do the math) there will be at most 30 balls in play at a time. Or less,
    if some have fallen over the edge. In that case, we do not need to make our app
    continuously allocate new memory for a new instance of BouncyBall, only to delete
    that object up to 15 seconds later. Too much instantiation and destroying of objects
    results in fragmented memory. Unity will periodically go through and clean this
    up, a computationally expensive process called **garbage collection** (**GC**)
    that is best to be avoided whenever possible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`GameController`间隔是0.5秒，销毁计时器是15秒，那么（进行计算）一次最多有30个球在游戏中。如果有些球掉落边缘，则更少。在这种情况下，我们不需要让我们的应用程序持续分配新的内存来创建新的BouncyBall实例，只为了在15秒后删除该对象。过多的实例化和销毁对象会导致内存碎片化。Unity将定期进行清理，这是一个计算成本高昂的过程，称为**垃圾回收**（**GC**），最好尽可能避免。
- en: Object pooling is when you create a list of reusable objects to be used in your
    game, rather than continuously instantiating new ones. You will activate/deactivate
    the objects instead of instantiate/destroy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池是在游戏中创建一个可重复使用的对象列表，而不是持续实例化新的对象。您将激活/停用对象，而不是实例化/销毁。
- en: To implement this, we will write a generic object pooler and add it to the `GameController`
    in the scene.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将编写一个通用的对象池器并将其添加到场景中的`GameController`。
- en: 'For this, we are also introducing you to the concept of lists in C#. As the
    name indicates, a list is an ordered collection of objects, like an array. Lists
    can be searched, sorted, and otherwise manipulated (see the documentation here: [https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx](https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx)).
    We will use them simply to hold our pre-instantiated objects. Let''s name the
    script `ObjectPooler`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还向您介绍了C#中的列表概念。正如其名所示，列表是有序对象集合，类似于数组。列表可以进行搜索、排序和其他操作（请参阅此处文档：[https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx](https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx)）。我们将简单地使用它们来存储预先实例化的对象。让我们将脚本命名为`ObjectPooler`：
- en: Select the `GameController` in Hierarchy
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`GameController`
- en: Navigate to Add Component | New Script and name it `ObjectPooler`
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“添加组件”|“新建脚本”，并将其命名为`ObjectPooler`。
- en: 'Open for editing. Let''s start by declaring several variables at the top:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打开进行编辑。让我们首先在顶部声明几个变量：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The public `prefab` will get the prefab object we want to instantiate, namely `BouncyBall`.
    And `pooledAmount` says how many objects to initially instantiate. The actual
    list is held in `pooledObjects`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的`prefab`将获取我们想要实例化的预制体对象，即`BouncyBall`。而`pooledAmount`表示初始实例化的对象数量。实际列表存储在`pooledObjects`中。
- en: 'Now, when the scene starts, we initialize the list as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当场景开始时，我们初始化列表如下：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We allocate a new list and populate it in the `for` loop, by instantiating our
    prefab, initially making it inactive, and adding it to the list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for`循环中分配一个新的列表，并通过实例化我们的预制体来填充它，最初使其不活动，并将其添加到列表中。
- en: 'Now when we want a new object, we''ll call `GetPooledObject`, which looks for
    one in the list that is presently not active. If all of them are active and none
    is available for reuse, we return `null`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要一个新对象时，我们将调用`GetPooledObject`，它将在列表中寻找当前不活动的对象。如果所有对象都处于活动状态且没有可重复使用的对象，则返回`null`：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: 'We can also enhance the script to optionally grow the list so it never returns
    null. Add the option at the top:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以增强脚本，使其可选地扩展列表，使其永远不会返回null。在顶部添加选项：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add the following statements to `GetPooledObject` after the `for` loop:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环之后向`GetPooledObject`添加以下语句：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save the script, attach it to `GameController`, and drag the `BouncyBall` prefab
    onto the Prefab slot for the component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，将其附加到`GameController`，并将`BouncyBall`预制体拖放到组件的预制体槽中。
- en: 'Now we need to modify our `BallsFromHeaven` script to call `GetPooledObject`
    from `ObjectPooler` instead of `Instantiate`. The updated `BallsFromHeaven` script
    is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改我们的`BallsFromHeaven`脚本，使其从`ObjectPooler`调用`GetPooledObject`而不是`Instantiate`。更新的`BallsFromHeaven`脚本如下：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we added a directive, `[RequireComponent(typeof(ObjectPooler)]`, to
    ensure the object has an `ObjectPooler` component (and we also double-check in
    the `Start` function).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了一个指令`[RequireComponent(typeof(ObjectPooler))]`，以确保对象具有`ObjectPooler`组件（我们还在`Start`函数中进行了双重检查）。
- en: It's important to note that since we're not instantiating new objects but reusing
    them, you may need to reset any object properties to their starting values. In
    this case, we reset not just the transform but the RigidBody's velocity to zero.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，由于我们不是实例化新对象而是重用它们，你可能需要将任何对象属性重置为其起始值。在这种情况下，我们不仅重置了变换，还将RigidBody的速度重置为零。
- en: 'The last part is we modify `DestroyBall` to just disable (deactivate) the object
    rather than literally destroying it. Initially, handle the *fallen off the ground
    plane* case as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是我们修改`DestroyBall`，使其只是禁用（非激活）对象而不是真正销毁它。最初，处理*掉落在地面平面之外*的情况如下：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of calling `Destroy`, we changed `Update` to call a new function, `DisableMe`,
    which simply deactivates the object, returning it to the pool of available objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有调用`Destroy`，而是将`Update`改为调用一个新的函数`DisableMe`，该函数简单地禁用对象，将其返回到可用对象池中。
- en: 'For the timed destroy, there''s a number of different ways to implement this.
    Earlier, we called `Destroy(gameObject, timer)` from `Start()`. We can do something
    similar, using `OnEnable` instead of `Start`, since that''s when this instance
    starts. And it calls  `Invoke()`, instead of destroy directly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于定时销毁，有几种不同的实现方式。之前，我们从`Start()`中调用了`Destroy(gameObject, timer)`。我们可以做类似的事情，使用`OnEnable`而不是`Start`，因为这是这个实例开始的时候。它调用`Invoke()`而不是直接销毁：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We also provide an `OnDisable` to cancel the `Invoke`, since the object could
    be disabled should the ball fall over the edge before the timer is done and potentially
    re-enabled, we should make sure it's not being invoked twice at the same time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个`OnDisable`来取消`Invoke`，因为如果球在计时器完成之前掉落边缘，对象可能会被禁用并可能重新启用，我们应该确保它不会同时被调用两次。
- en: 'Now when you press Play, you can see in Inspector that new BouncyBalls are
    instantiated at the start to initialize the list, and then as it plays the objects
    are disabled and reactivated as they are returned to the pool and reused, as shown
    here (deactivated BouncyBall(Clone) objects are dimmer than the activated ones):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你按下播放时，你可以在检查器中看到，新的BouncyBalls在开始时被实例化以初始化列表，然后随着游戏的进行，对象被禁用并在返回池中重新激活，如图所示（禁用的BouncyBall(Clone)对象比激活的对象暗淡）：
- en: '![](img/5d35d2d7-88a8-45a7-baa1-6506d9bd3ac9.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d35d2d7-88a8-45a7-baa1-6506d9bd3ac9.png)'
- en: Headshot game
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部瞄准游戏
- en: Wouldn't it be fun to actually play with these bouncy balls? Let's make a game
    where you aim the ball at a target using headshots. For this game, balls drop
    one at a time from above and bounce off your forehead (face), aiming for a target.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上玩这些弹跳球会很有趣吗？让我们制作一个游戏，你可以用头部瞄准目标。在这个游戏中，球一个接一个地从上方落下，弹在你的额头（脸部）上，瞄准目标。
- en: The feature we'll implement here is, when a ball drops from above your head,
    you bounce it off your face and aim for a target.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要实现的功能是，当球从你头顶上方落下时，你将其弹回你的脸部，并瞄准目标。
- en: To implement this, create a cube as a child of the camera object (much like
    we did for the reticle cursor in [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml),
    *World Space UI*).  This provides a collider parented by the VR camera, so our
    head pose will move the face of the cube. I decided a cube-shaped collider will
    be better for this game than a sphere or capsule because it provides a flat face
    that will make the bounce direction more predictable. Balls will drop out of the
    sky. For a target, we'll use a flattened cylinder. We'll add audio cues to indicate
    when a new ball has been released and when a ball hits the target.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，创建一个作为相机对象子对象的立方体（就像我们在第6章中为瞄准十字准星所做的），*世界空间UI*。这提供了一个由VR相机父化的碰撞器，因此我们的头部姿态会移动立方体的面。我决定立方体形状的碰撞器比球体或胶囊体更适合这个游戏，因为它提供了一个平坦的面，这将使弹跳方向更加可预测。球将从天空中落下。我们将使用一个压扁的圆柱体作为目标。我们将添加音频提示，以指示何时释放新球以及何时球击中目标。
- en: 'Create a new scene or, more simple, start here by doing a Save As, and implement
    the head as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，或者更简单地说，通过执行“另存为”操作从这里开始，并按照以下方式实现头部动作：
- en: Navigate to File | Save Scene As and name it `BallGame`
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“文件”|“另存场景为”，并将其命名为`BallGame`
- en: Delete the `BallsFromHeaven` script component attached to `GameController` using
    the *gear* icon Remove Component. We won't need it
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*齿轮*图标删除附加到`GameController`的`BallsFromHeaven`脚本组件。我们不需要它
- en: In Hierarchy, unfold `MeMyselfEye`, drilling down to the `Camera` object and
    selecting it (for OpenVR that might be  `[CameraRig]/Camera (head)`; for Daydream,
    it may be  `Player/Main Camera/`)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中展开`MeMyselfEye`，钻到`Camera`对象并选择它（对于OpenVR可能是`[CameraRig]/Camera (head)`；对于Daydream，可能是`Player/Main
    Camera/`）
- en: Create a new 3D Object | Cube
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D对象 | 立方体
- en: With `GameController` selected, navigate to Add Component | Audio | Audio Source
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`GameController`后，导航到添加组件 | 音频 | 音频源
- en: Click on the small *circle-shaped* icon on the far right of the AudioClip field
    of Audio Source to open the Select AudioClip dialog box and choose the clip named
    `Jump`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击音频源音频剪辑字段最右侧的小*圆形*图标以打开选择音频剪辑对话框，并选择名为`Jump`的剪辑
- en: With `GameController` selected, navigate to Add Component | New Script, name
    it `BallGame`, and open it for editing
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`GameController`后，导航到添加组件 | 新脚本，将其命名为`BallGame`，并打开它进行编辑
- en: You can decide to disable the cube's Mesh Renderer, but I think it's cool to
    watch it in the Scene window as you play. Since the camera is inside the cube,
    the player will not see it (since only the outward facing surfaces are rendered
    in the game view).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择禁用立方体的网格渲染器，但我觉得在场景窗口中观看它很酷。由于摄像机在立方体内部，玩家将看不到它（因为游戏视图中只渲染面向外部的表面）。
- en: We'll play the `Jump` sound clip (provided with the `Characters` package of
    Unity's Standard Assets) to indicate when a new ball is dropped. You might try
    another, perhaps more interesting, effect.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将播放“跳跃”声音剪辑（Unity标准资产包中的“角色”包提供），以指示新球被放下。你可能尝试另一个，可能更有趣的效果。
- en: 'Here''s the `BallGame.cs` script. It looks a lot like the `BallsFromHeaven`
    one with just a few differences:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`BallGame.cs`脚本。它看起来与`BallsFromHeaven`非常相似，只是有一些不同：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We instantiate a new ball every 3 seconds ( `interval` ) from a `startHeight`
    position above the current head position.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每3秒（`interval`）从当前头部位置上方的`startHeight`位置实例化一个新的球。
- en: 'The drop point defaults to directly above the player''s head position, as defined
    by the VR camera. That may feel uncomfortable on your neck, so let''s extent it
    in front a little, 0.2 units:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 放下点默认直接位于玩家头部位置的正上方，如VR摄像机定义。这可能会让你的脖子感到不舒服，所以让我们稍微向前延伸，0.2个单位：
- en: As a child of `MeMyselfEye` (or as a child of your head or main camera object),
    create an empty game object and name it `Drop Point`
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`MeMyselfEye`（或作为你的头部或主摄像机对象的孩子），创建一个空的游戏对象，并将其命名为`Drop Point`
- en: Set its Position to (`0`, `0`, `0.2`)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为（`0`, `0`, `0.2`）
- en: Drag this `Drop Point` onto the `GameController`'s Ball Game Drop Point slot
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此`Drop Point`拖动到`GameController`的球游戏放下点槽中
- en: On positionally tracked VR rigs, if your drop point is relative to the camera,
    it will follow the player around. If it's relative to `MeMyselfEye`, it will be
    relative to your play space while the player can move around.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置跟踪的VR设备上，如果你的放下点相对于摄像机，它将跟随玩家移动。如果它相对于`MeMyselfEye`，它将相对于你的游戏空间，而玩家可以四处移动。
- en: Try it in VR.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中尝试一下。
- en: When you hear the ball, look up and aim the angle of your face to direct the
    bounce of the ball. *COOOL!*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到球的声音时，抬头并调整你脸的角度以引导球的弹跳。*酷！*
- en: 'Now, we need the target. Perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要目标。执行以下步骤：
- en: Create a flat cylinder for the target, navigate to Game Object | 3D Object |
    Cylinder, and name it `Target`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为目标创建一个平面圆柱体，导航到游戏对象 | 3D对象 | 圆柱体，并将其命名为`Target`。
- en: Set its Scale to (`3`, `0.1`, `3`) and Position to (`1`, `0.2`, `2.5`) so that
    it's out in front of you on the ground.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为（`3`, `0.1`, `3`）并将位置设置为（`1`, `0.2`, `2.5`），使其位于你前面的地面上。
- en: Drag the `Blue` material from the `Project Assets/Materials` folder (created
    in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects
    and Scale*) onto it, or make a new one.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“项目资产/材质”文件夹（在[第2章](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml)，*内容、对象和比例*中创建）拖动“蓝色”材质到它上面，或者创建一个新的材质。
- en: Note that its default Capsule Collider is domed, and it really won't do. On
    the Capsule Collider, select its *gear* icon | Remove Component.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，它的默认胶囊碰撞体是圆顶形的，这实际上并不合适。在胶囊碰撞体上，选择其*齿轮*图标 | 删除组件。
- en: Then, navigate to Add Component | Physics | Mesh Collider.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到添加组件 | 物理 | 网格碰撞体。
- en: In the new Mesh Collider, enable the Convex checkbox and the Is Trigger checkbox
    too.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的网格碰撞体中，启用凸多边形复选框和触发器复选框。
- en: Add an audio source by navigating to Add Component | Audio | Audio Source.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到添加组件 | 音频 | 音频源来添加音频源。
- en: With the `Target` selected, click on the small *circle* icon on the far right
    of the AudioClip field to open the Select AudioClip dialog box, and choose the
    clip named `Land` (found in Standard Assets).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择“Target”的情况下，点击音频剪辑字段右侧的小*圆圈*图标以打开选择音频剪辑对话框，并选择名为`Land`的剪辑（位于标准资产中）。
- en: Uncheck the Play On Awake checkbox.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中“唤醒时播放”复选框。
- en: And a new script, navigate to Add Component | New Script, name it `TriggerSound`,
    and open it in MonoDevelop.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个新的脚本，导航到添加组件 | 新脚本，将其命名为`TriggerSound`，并在MonoDevelop中打开它。
- en: 'Since we enabled Is Trigger, when something hits the collider, the `OnTriggerEnter`
    and other event handlers will get a call when present on the target object. The
    following `TriggerSound.cs` script will play a sound clip when you hit the target
    with a ball:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们启用了Is Trigger，当某物撞击碰撞器时，如果目标对象上存在，`OnTriggerEnter`和其他事件处理程序将得到调用。以下`TriggerSound.cs`脚本将在你用球击中目标时播放声音：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The ball enters the target's collider and the physics engine invokes a trigger
    enter event. The script uses the `OnTriggerEnter()` handler to play the audio
    clip.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 球进入目标的碰撞器，物理引擎调用触发进入事件。脚本使用`OnTriggerEnter()`处理程序来播放音频剪辑。
- en: For a full list of the collider properties and trigger events, including `OnTrggerEnter`
    and `OnTriggerExit`, see the documentation at [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的碰撞器属性和触发事件列表，包括`OnTriggerEnter`和`OnTriggerExit`，请参阅[https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html)中的文档。
- en: 'Try it in VR. It''s a VR game! The following image shows the scene with the
    first person''s colliders and a ball bouncing off the cube collider towards the
    target:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中尝试。这是一个VR游戏！以下图像显示了带有第一人称碰撞器和球从立方体碰撞器弹跳向目标的场景：
- en: '![](img/491546fa-fc3c-4d53-a7f8-179256fdd125.png)**Extra challenge**: Keep
    score. Provide an aiming reticle. Add a backboard. Add other features to make
    the game more challenging. For instance, you can vary the fire interval or increase
    the initial ball velocity.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/491546fa-fc3c-4d53-a7f8-179256fdd125.png)**额外挑战**：记录得分。提供一个瞄准十字线。添加篮板。添加其他功能使游戏更具挑战性。例如，你可以改变射击间隔或增加初始球的速度。'
- en: Up to this point, we assigned Bounciness through a Physic Material attached
    to a sphere object. When the ball collides with another object, the Unity physics
    engine considers this bounciness to determine the ball's new velocity and direction.
    In the following section, we'll look at how one can transfer a bounce force from
    one object to another.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过附加到球体对象的物理材料来分配弹跳性。当球与另一个对象碰撞时，Unity物理引擎考虑这种弹跳性来确定球的新速度和方向。在下一节中，我们将探讨如何将弹跳力从一个对象传递到另一个对象。
- en: Paddle ball game
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拍球游戏
- en: Next, we'll add hand controlled paddles to hit the ball. To keep things somewhat
    generic, our game paddles will be simple objects parented by the hand controllers
    in your camera rig. We'll move the target to be on a wall instead of the floor,
    and serve the balls a little further out in front of you so they're reachable
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加由手控制器控制的拍子来击打球。为了保持一定的通用性，我们的游戏拍子将是作为你相机装置中手控制器父级的一些简单对象。我们将目标移动到墙上而不是地板上，并将球发到你前方稍远的位置，以便可以触及
- en: To set up the scene, you can Save As a new name and we'll work from here. I'll
    name my `PaddleBallGame`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置场景，你可以另存为新的名称，然后从这里开始工作。我会将我的命名为`PaddleBallGame`。
- en: Select File | Save Scene As and name it `PaddleBallGame`
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 保存场景为，并将其命名为`PaddleBallGame`
- en: Disable the head Cube we previously added as child of the camera, if present
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，禁用之前作为相机子元素的头部立方体
- en: First, let's create a paddle. We'll construct a very simple model using cylinders.
    You can find better ones, shaped and textured, online.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个拍子。我们将使用圆柱体构建一个非常简单的模型。你可以在网上找到更好的，形状和纹理的模型。
- en: In the Hierarchy root, Create | Create Empty, name it `Paddle`, and reset its
    Transform
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构根目录下，创建 | 创建空对象，并将其命名为`Paddle`，然后重置其变换
- en: Add a child cylinder object (Create | 3D Object | Cylinder) and name it `Handle`
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个子圆柱体对象（创建 | 3D 对象 | 圆柱体），并将其命名为`Handle`
- en: Set the Handle's Scale to (`0.02`, `0.1`, `0.02`)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Handle”的缩放设置为(`0.02`, `0.1`, `0.02`)
- en: Add another Cylinder as a sibling of Handle and name it `Pad`
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Handle”旁边添加另一个圆柱体作为其兄弟元素，并将其命名为`Pad`
- en: Set the pad's Scale to (`0.2`, `0.005`, `0.2`), Rotation (`90`, `0`, `0`), and
    Position (`0`, `0.2`, `0`)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将垫的缩放设置为(`0.2`, `0.005`, `0.2`), 旋转(`90`, `0`, `0`), 和位置(`0`, `0.2`, `0`)
- en: In your Project Materials folder, create a new material (Create | Material)
    and name it `Paddle` `Material`
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目材质文件夹中，创建一个新的材质（创建 | 材质）并命名为 `Paddle` `Material`
- en: Give the material Albedo a wooden color, such as (`107`, `79`, `54`, `255`),
    then drag the material onto the Handle and Pad objects
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给材料Albedo一个木色，例如 (`107`, `79`, `54`, `255`), 然后将材料拖到把手和垫子对象上
- en: 'Now, modify the colliders:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改碰撞体：
- en: Select the Handle, and delete its Capsule Collider
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择把手，并删除其胶囊碰撞体
- en: Select the Pad, and delete its Capsule Collider
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择垫子，并删除其胶囊碰撞体
- en: With Pad selected, add a Mesh Collider (Add Component | Physics | Mesh Collider)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择垫子，添加一个网格碰撞体（添加组件 | 物理 | 网格碰撞体）
- en: Check the Convex checkbox
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择凸多边形复选框
- en: 'Save the paddle as a prefab:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将桨保存为预制件：
- en: Drag the Paddle into your Project Prefabs folder
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将桨拖到你的项目预制件文件夹中
- en: Delete the Paddle from your Hierarchy
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的层级中删除桨
- en: We want to parent the Paddle to your hands. This is platform-specific. If you
    are using OpenVR, for example, that may be `MeMyselfEye / [CameraRig] / Controller`
    *(right)*. On Daydream, that might be `MeMyselfEye / Player / GvrControllerPointer.`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将桨作为你的手的父对象。这是平台特定的。例如，如果你使用OpenVR，那可能就是 `MeMyselfEye / [CameraRig] / Controller`
    *(right)*。在Daydream上，那可能就是 `MeMyselfEye / Player / GvrControllerPointer`。
- en: In Hierarchy, select the hand controller within `MeMyselfEye` (such as Controller
    (right). or `GvrControllerPointer`)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中，选择 `MeMyselfEye` 内的手控制器（例如 Controller (right) 或 `GvrControllerPointer`)
- en: Create Empty child game object and name it `Hand` (reset its Transform if needed)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建空的子游戏对象并命名为 `Hand`（如果需要，重置其变换）
- en: Create another Empty child beneath Hand and name it `Attach Point` (and reset
    its Transform if needed)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手下面创建另一个空的子对象，并命名为 `Attach Point`（如果需要，重置其变换）
- en: Drag the Paddle prefab from Project into Hierarchy as a child of Attach Point
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将桨预制件从项目拖到层级中，作为 Attach Point 的子对象
- en: 'Now, we can adjust the paddle''s relative position and rotation so its grip
    feels natural within your hand. The follow values seem to work for me:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调整桨的相对位置和旋转，使其握感自然。以下值对我来说似乎有效：
- en: In OpenVR, use the attach point Rotation (`20`, `90`, `90`)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenVR中，使用附加点旋转 (`20`, `90`, `90`)
- en: In Daydream, use Position (`0`,  `0`,  `0`, `05)` and Rotation (`0`, `90`, `90`)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Daydream中，使用位置 (`0`, `0`, `0`, `05`) 和旋转 (`0`, `90`, `90`)
- en: 'On Daydream, the `GvrControllerPointer` includes a `GvrArmModel` component
    that can be configured for simulating arm, elbow, and wrist movement with the
    simple 3DOF controller. Setting this up yourself can be confusing. Fortunately,
    a bunch of examples are provided in the ArmModelDemo scene the Daydream Elements
    package (in the `DaydreamElements/Elements/ArmModels/D*emo/*` folder) including
    prefabs with some preconfigured arm models. Let''s add one. If you are on Daydream:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Daydream上，`GvrControllerPointer` 包含一个 `GvrArmModel` 组件，该组件可以配置为使用简单的3自由度控制器模拟手臂、肘部和手腕的运动。自己设置可能会很复杂。幸运的是，Daydream
    Elements包中的 ArmModelDemo 场景提供了一系列示例（在 `DaydreamElements/Elements/ArmModels/D*emo/*`
    文件夹中），包括一些预配置的手臂模型预制件。让我们添加一个。如果你在Daydream上：
- en: Find the `Elements/ArmModels/Prefabs` folder in Project Assets
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资产中找到 `Elements/ArmModels/Prefabs` 文件夹
- en: Drag the `SwingArm` prefab into `MeMyselfEye / Player` as a sibling of `GvrControllerPointer`
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SwingArm` 预制件拖到 `MeMyselfEye / Player` 中，作为 `GvrControllerPointer` 的同级
- en: Move `GvrControllerPointer` as a child of SwingArm
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GvrControllerPointer` 移动为 SwingArm 的子对象
- en: This will give more arm extension for using the paddle. You can further adjust
    the settings as needed, including try moving the SwingArm transform Position further
    in front (`0`, `0`, `0.3`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为使用桨提供更多的手臂延伸。你可以根据需要进一步调整设置，包括尝试将 SwingArm 变换的位置向前移动更多 (`0`, `0`, `0.3`).
- en: Lastly, you might want to extend the ball drop location a little further out
    in front of you so it's more readily within hand reach. In the earlier version
    of the project, we defined a Drop Point; modify its position as desired (for example,
    z = `0.6`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能还想将球体下落的位置稍微向前延伸，使其更容易触及手。在项目的早期版本中，我们定义了一个下落点；根据需要修改其位置（例如，z = `0.6`）。
- en: 'The paddle in play using HTC Vive is shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了使用HTC Vive时使用的桨：
- en: '![](img/c6906466-5459-4ca2-8771-c2f6d179bedf.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6906466-5459-4ca2-8771-c2f6d179bedf.png)'
- en: Deflector versus paddle
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射器与桨
- en: 'As implemented, our paddle acts more like a deflector shield than a paddle.
    The ball will bounce off the paddle''s Pad in a direction based on the Pad''s
    surface normal orientation. But if you whack the ball, that doesn''t transfer
    any physics. We can change this by adding a RigidBody to the Pad, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如此实现，我们的桨更像是一个防御盾牌而不是桨。球会根据垫子的表面法线方向从桨的垫子弹跳出去。但如果你击打球，则不会传递任何物理效果。我们可以通过向垫子添加一个刚体来改变这一点，如下所示：
- en: Select the Pad of your Paddle
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的桨的垫子
- en: Add Component | Physics | RigidBody
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件 | 物理 | 刚体
- en: Uncheck Use Gravity checkbox
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中使用重力复选框
- en: Check the Is Kinematic checkbox
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中 Is Kinematic 复选框
- en: Click the Apply button at top of Inspector to save your changes in the prefab
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Inspector 顶部的 Apply 按钮以保存对预制体的更改
- en: By making it kinematic, our Pad will apply physics to objects colliding with
    it, but will not react to collisions itself. This is good, otherwise, the paddle
    would shatter when hit by a ball.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使其成为运动学，我们的垫子将对与之碰撞的对象应用物理效果，但不会对碰撞做出反应。这是好的，否则当球击中时，桨会破碎。
- en: One important lesson in this project is the use of attach points for defining
    relative positions for specific behaviors. We used a Drop Point to mark the X,
    Z position where balls are dropped from. We used an Attach Point to mark the relative
    position and rotation of the paddle in your hand. We could have added a Grip Point
    to the paddle itself to specify its relative origin. And so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，一个重要的教训是使用附加点来定义特定行为的相对位置。我们使用了一个 Drop Point 来标记球从哪里掉落的 X、Z 位置。我们使用了一个
    Attach Point 来标记你手中的桨的相对位置和旋转。我们可以在桨本身添加一个 Grip Point 来指定其相对原点。等等。
- en: Shooter ball game
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击球游戏
- en: For the next iteration of this project, we'll shoot balls at the player and
    you have to hit them at a target on a wall. There's not a lot of innovation in
    this version, but it shows how you can take an existing mechanic and turn it on
    its side (both literally and figuratively).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目的下一个迭代，我们将向玩家射击球，你必须击中墙上的目标。这个版本没有太多创新，但它展示了你可以如何将现有的机制翻转过来（字面和比喻意义上）。
- en: 'To begin, lets make a wall and put the target on it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们制作一面墙并将目标放在上面：
- en: In the Hierarchy root, create an Empty game object named `TargetWall` and
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 根目录下创建一个名为 `TargetWall` 的空游戏对象，并
- en: Position it at (`0`, `0`, `5`)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在 (`0`, `0`, `5`)
- en: Create a child Cube and name it `Wall`
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子对象立方体并将其命名为 `Wall`
- en: Set the Wall Scale to (`10`, `5`, `0.1`) and Position (`0`, `2.5`, `0`)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将墙的缩放设置为 (`10`, `5`, `0.1`) 和位置 (`0`, `2.5`, `0`)
- en: Create a new Material named `Wall Material`
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质名为 `Wall Material`
- en: Set its Rendering Mode to Transparent, and its Albedo color to (`85`, `60`,
    `20`, `75`) so it's a translucent glassy color
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其渲染模式设置为透明，并将其 Albedo 颜色设置为 (`85`, `60`, `20`, `75`) 以使其成为半透明的玻璃色
- en: Move the Target to a child of `TargetWall`
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标移动到 `TargetWall` 的子对象
- en: Modify the Target Transform Scale to (`1.5`, `0.1`, `1.5`), Rotation (`90`,
    `0`, `0`), and Position (`0`, `2.5`, `-0.25`) so it's smaller and just in front
    of the wall itself
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改目标变换的缩放为 (`1.5`, `0.1`, `1.5`)、旋转 (`90`, `0`, `0`) 和位置 (`0`, `2.5`, `-0.25`)，使其更小，正好在墙的前面
- en: 'Next, instead of serving balls by dropping them out of the sky and relying
    on gravity, we''ll shoot balls at you from a source on the wall:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不再是从空中抛球并依赖重力来服务球，而是从墙上的一个源头向你射击球：
- en: Create a Sphere game object as a child of `TargetWall`, named `Shooter`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Shooter` 的球体游戏对象，作为 `TargetWall` 的子对象
- en: Set its Scale to (`0.5`, `0.5`, `0.5`) and Position (`4`, `2.5`, `-0.25`)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其缩放为 (`0.5`, `0.5`, `0.5`) 和位置 (`4`, `2.5`, `-0.25`)
- en: Disable or remove its Sphere Collider component
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用或移除其球体碰撞器组件
- en: Create a new Material named `Shooter Material`, with Albedo color (`45`, `22`,
    `12`, `255`)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质名为 `Shooter Material`，其 Albedo 颜色为 (`45`, `22`, `12`, `255`)
- en: 'We''ll add a gun barrel to the shooter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在射击器上添加一个枪管：
- en: Create another Sphere object as a child of Shooter, named `Barrel`
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `Barrel` 的球体对象，作为 `Shooter` 的子对象
- en: Set its Scale (`0.1`, `0.1`, `0.1`), Rotation (`90`, `0`, `0`), and Position
    (`0`, `0`, `-0.25`)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其缩放 (`0.1`, `0.1`, `0.1`)、旋转 (`90`, `0`, `0`) 和位置 (`0`, `0`, `-0.25`)
- en: 'Duplicate the Shooter and set the second one''s Position to (`-4`, `2.5`, `-0.25`)
    so there''s one on either side of the Target. Here is a capture of the Scene view
    of the `TargetWall` with its sexy shooters:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 `Shooter` 并将第二个的 `Position` 设置为 (`-4`, `2.5`, `-0.25`), 这样目标的两边就有一个。以下是 `TargetWall`
    的场景视图截图，其中包含其性感的射击器：
- en: '![](img/e290e704-61dc-4e23-8b3d-5290aa045ee6.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e290e704-61dc-4e23-8b3d-5290aa045ee6.png)'
- en: 'The game controller script is similar to the BallGame one we have, but sufficiently
    different we should create a new one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器脚本与我们的 BallGame 脚本类似，但足够不同，我们应该创建一个新的：
- en: In Hierarchy, select `GameController` and disable or remove the `BallGame` component
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择 `GameController` 并禁用或删除 `BallGame` 组件
- en: Create a new C# script named `ShooterBallGame` and open it for editing
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ShooterBallGame` 的新 C# 脚本并打开它进行编辑
- en: 'Write the `ShooterBallGame` script as follows. We give it two shooters and
    the script alternates between them to shoot balls in the direction of a `shootAt`
    location. We play a sound effect each time a ball is shot. First, let''s define
    the public and private variable we will need:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ShooterBallGame` 脚本编写如下。我们给它两个发射器，脚本在它们之间交替以向 `shootAt` 位置射击球体。每次发射球体时都会播放音效。首先，让我们定义我们将需要的公共和私有变量：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Start` function initializes the variable we get at runtime:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start` 函数初始化我们在运行时获取的变量：'
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the `Update` function shoots the balls at specified intervals, alternating
    between the two shooter locations:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `Update` 函数会在指定的时间间隔内射击球体，在两个发射器位置之间交替：
- en: '[PRE15]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, here''s the `ShootBall()` code we extracted into its own function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们提取到其自身函数中的 `ShootBall()` 代码：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ShootBall` grabs a new ball from the object pool and initializes its position
    based on the shooter position. It then rotates the shooter to be pointing at the
    `shootAt` position (using `transform.LookAt`) and uses its forward vector to define
    the ball''s RigidBody velocity vector.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShootBall` 从对象池中获取一个新的球体，并根据发射器位置初始化其位置。然后，它将发射器旋转到指向 `shootAt` 位置（使用 `transform.LookAt`），并使用其前向向量定义球体的
    RigidBody 速度向量。'
- en: 'Back in Unity, we need to populate the public variable slots:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，我们需要填充公共变量槽位：
- en: Drag the `Shooter` object (child of `TargetWall`) on to the Shooter 0 slot
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Shooter` 对象（`TargetWall` 的子对象）拖到 `Shooter 0` 槽位上
- en: Drag the other `Shooter` object on to the Shooter 1 slot
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个 `Shooter` 对象拖到 `Shooter 1` 槽位上
- en: Leave the Shoot At slot empty for now, so it will default to the player's live
    head position.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 目前先保留 `Shoot At` 槽位为空，这样它将默认为玩家的实时头部位置。
- en: 'Press Play. *Not bad*. The balls are too big and heavy. Let''s create new ball
    prefabs with different properties:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。*还不错*。球太大太重了。让我们创建具有不同属性的新的球体预制件：
- en: Drag the `BouncyBall` prefab from `Project` folder into the Hierarchy
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BouncyBall` 预制件从 `Project` 文件夹拖到层次结构中
- en: Rename it `ShooterBall`
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `ShooterBall`
- en: Set its Scale to (`0.25`, `0.25`, `0.25`)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为 (`0.25`, `0.25`, `0.25`)
- en: Uncheck the Use Gravity checkbox (alternatively, you could play with its RigidBody
    Mass property)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中使用重力复选框（或者，你可以玩一下它的 RigidBody 质量属性）
- en: Drag the ShooterBall from Hierarchy into your `Prefabs` folder, creating a new
    prefab for it
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ShooterBall` 从层次结构拖到你的 `Prefabs` 文件夹中，为它创建一个新的预制件
- en: Delete the ShooterBall from the Hierarchy
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中删除 `ShooterBall`
- en: Select `GameController` in Hierarchy, and drag the ShooterBall onto its Object
    Pooler Prefab slot
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 `GameController`，并将 ShooterBall 拖到其 Object Pooler 预制件槽位上
- en: Now, the object pool will instantiate a collection of the new prefab objects.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对象池将实例化一组新的预制对象。
- en: Press Play. *Oh yeah!* The game is now much more challenging. Also, try modifying
    the Interval and Speed settings.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。*哦，是的!* 现在游戏变得更加具有挑战性。同时，尝试修改间隔和速度设置。
- en: It may be awkward that the ball is always shooting towards your head, especially
    on Daydream where you have limited hand control. You can adjust the scene, for
    example, positioning the ShootAt empty game object, as child of `MeMyselfEye`,
    at Position (`0`, `0.9`, `0.6`), and setting it into the `GameController`'s ShootAt
    slot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 球体总是朝向你的头部射击，尤其是在 Daydream 上，你只有有限的手部控制，这可能会有些尴尬。你可以调整场景，例如，将 `ShootAt` 空游戏对象定位为
    `MeMyselfEye` 的子对象，位置为 (`0`, `0.9`, `0.6`), 并将其设置到 `GameController` 的 `ShootAt`
    槽位中。
- en: Some obvious gameplay improvement ideas should come to mind. You could make
    a moving target, perhaps in a predictable oscillating motion, or completely random.
    You could introduce some random variation in the ball velocity direction and speed
    or the intervals between shots. You could keep score, using `OnTriggerEnter` on
    the Target. You could disqualify bank shots that bounce first on the floor (using
    `OnTriggerEnter` on the ground plane).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一些明显的游戏玩法改进想法应该会浮现在脑海中。你可以制作一个移动的目标，可能是可预测的振荡运动，或者完全随机。你可以在球体速度方向和速度或射击间隔之间引入一些随机变化。你可以使用
    `OnTriggerEnter` 在目标上记分。你可以取消资格在地板上首先弹跳的银行球（使用地面平面的 `OnTriggerEnter`）。
- en: Juicing the scene
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强场景效果
- en: Having the basic mechanics implemented, we can now *juice it*! One of my favorite
    VR games is the popular Audio Shield ([http://audio-shield.com/](http://audio-shield.com/)).
    We're almost there building our own, we just need to add fireballs, a compelling
    environment scene, and synchronizing the fireball shots with music!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了基本机制后，我们现在可以给它添加活力！我最喜欢的VR游戏之一是流行的音频盾牌([http://audio-shield.com/](http://audio-shield.com/))。我们几乎完成了自己的构建，我们只需要添加火焰球、引人入胜的环境场景，以及将火焰球射击与音乐同步！
- en: The term *juice it* for game design was popularized by Jonasson and Purho in
    their presentation talk from 2012,  *Juice it or lose it - a talk by Martin Jonasson
    & Petri Purho* ([https://www.youtube.com/watch?v=Fy0aCDmgnxg](https://www.youtube.com/watch?v=Fy0aCDmgnxg)). <q
    class="calibre65">A juicy game feels alive and responds to everything you do,
    tons of cascading action and response for minimal user input.</q>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计中的术语*juice it*由Jonasson和Purho在2012年的演讲中普及，演讲主题为*Juice it or lose it - Martin
    Jonasson & Petri Purho的演讲*([https://www.youtube.com/watch?v=Fy0aCDmgnxg](https://www.youtube.com/watch?v=Fy0aCDmgnxg))。 <q
    class="calibre65">一个充满活力的游戏感觉充满生机，对你的每一个动作都做出反应，有大量的连锁动作和反应，而用户输入却很少。</q>
- en: Great balls of fire
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火球
- en: In the previous section, we disabled Use Gravity on the shooting balls. We did
    this in anticipation of changing the balls from being bouncy balls to balls of
    fire. Let's make that magic happen now. We will use the Particle System to render
    it instead of mesh geometry.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们禁用了射击球上的重力使用。我们这样做是为了预期将球从弹跳球变为火焰球。现在让我们实现这个魔法。我们将使用粒子系统来渲染它，而不是网格几何体。
- en: There are a lot of ways to get particle effects into your Unity project. If
    you recall, in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we added a water hose, spark emitter, and explosion effects from the
    `Unity Standard Assets` package. Here, we'll build our own, but use one of the
    materials, `ParticleFireCloud`, provided with the package. In the Unity Asset
    Store, you can find many offerings of particle effects and system enhancements
    too.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将粒子效果添加到Unity项目中有许多方法。如果你还记得，在[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)“基于注视的控制”中，我们从`Unity标准资产`包中添加了水龙带、火花发射器和爆炸效果。在这里，我们将构建自己的，但使用包中提供的材料之一，`ParticleFireCloud`。在Unity资产商店中，你还可以找到许多粒子效果和系统增强的提供。
- en: 'First, make a new prefab derived from ShooterBall, named `FireBall`, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的从ShooterBall派生的预制件，命名为`FireBall`，如下所示：
- en: Drag a copy of `ShooterBall` prefab from the `Project` folder into Hierarchy
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“项目”文件夹中将`ShooterBall`预制件的副本拖动到层次结构中
- en: Rename it FireBall
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为FireBall
- en: Drag FireBall into the `Project` *Prefabs* folder to create a new prefab
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将FireBall拖动到“项目”*预制件*文件夹中创建一个新的预制件
- en: Select the `GameController` from Hierarchy
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择`GameController`
- en: Drag the `FireBall` prefab from `Project` *Prefabs* folder onto the Object Pooler
    Prefab slot
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“项目”*预制件*文件夹中将`FireBall`预制件拖动到对象池器预制件槽中
- en: 'OK, now we can add the particle system:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以添加粒子系统：
- en: Select the FireBall from Hierarchy
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择FireBall
- en: Disable its Mesh Renderer, as we will render it with particles instead
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用其网格渲染器，因为我们将以粒子形式渲染它
- en: Right-click FireBall and select Create | Effects | Particle System
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击FireBall并选择创建 | 效果 | 粒子系统
- en: Rename it Fireball Particle System
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为Fireball Particle System
- en: There are a lot of details in working with particles, many options and configuration
    parameters. As we step through this quick implementation of fireballs, observe
    the effects of each change as we make them one at a time. Note that you can preview
    the particle effects in the Scene window. Feel free to experiment on your own.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理粒子时有很多细节，很多选项和配置参数。随着我们逐步实现火焰球的快速实现，注意我们逐个更改时每个更改的效果。请注意，你可以在场景窗口中预览粒子效果。请随意进行实验。
- en: First, at the bottom of the Particle System Inspector, find the Renderer panel.
    In its Material slot, click the doughnut icon and choose the ParticleFireCloud material
    (located in `Standard Assets/Particle Systems/Materials`. If not present, you
    may need to import it using Assets | Import Package | ParticleSystems).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在粒子系统检查器的底部，找到渲染器面板。在其材质槽中，点击甜甜圈图标并选择ParticleFireCloud材质（位于`Standard Assets/Particle
    Systems/Materials`。如果不存在，你可能需要使用“资产 | 导入包 | 粒子系统”导入它）。
- en: 'Near the top of the Particle System inspector, find the Shape panel. Select
    Shape: Sphere, and set its Radius to `0.1`.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粒子系统检查器的顶部附近，找到形状面板。选择形状：球体，并将其半径设置为`0.1`。
- en: Find the Emission panel, and set Rate of Time to `15`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发射面板中，将时间速率设置为`15`。
- en: 'At the top of the inspector, set Duration: `2.00`.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器的顶部，设置持续时间：`2.00`。
- en: 'Start Lifetime: `1`.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起始生命周期：`1`。
- en: 'Start Speed: `0`.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起始速度：`0`。
- en: 'Start Size: `0.5`.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起始大小：`0.5`。
- en: 'For Start Rotation, click the selector icon on the right and choose Random
    Between Two Curves. Then click the slot and scroll to the Curve Editor at the
    bottom of the Inspector. If you''re not familiar, the editor can take some getting
    used to. Choose a full range of values from `180` (at top of graph) to `-180`
    (bottom of graph), as shown:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于起始旋转，点击右侧的选择器图标，并选择“在两个曲线之间随机”。然后点击槽位，滚动到检查器底部的曲线编辑器。如果你不熟悉，编辑器可能需要一些时间来适应。选择从`180`（图表顶部）到`-180`（图表底部）的全范围值，如图所示：
- en: '![](img/fe543e26-4c2e-4f6f-9d52-b08c61e2317c.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe543e26-4c2e-4f6f-9d52-b08c61e2317c.png)'
- en: 'Enable Color Over Lifetime and click the slot to open its Gradient Editor.
    We want to adjust the Alpha curve so it starts at Alpha `0` at Location `0%`,
    then becomes Alpha `255` at `10%`, then fades out over time back to Alpha `0`
    at `100%`. The editor is shown here:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用生命周期内颜色，并点击槽位以打开其渐变编辑器。我们想要调整Alpha曲线，使其在位置`0%`时Alpha为`0`，然后在`10%`时变为Alpha
    `255`，然后随着时间的推移逐渐淡出到`100%`的Alpha `0`。编辑器如图所示：
- en: '![](img/c43d9d6a-184a-4caf-8fed-69ba777f9a68.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c43d9d6a-184a-4caf-8fed-69ba777f9a68.png)'
- en: 'Set the Start Color, as Gradient (right-side selector) and then pick a range
    of colors such as yellow to red, as shown here:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置起始颜色，作为渐变（右侧选择器），然后选择一系列颜色，如黄色到红色，如图所示：
- en: '![](img/c67f1214-4127-43fd-9b2f-6c17a6d9b4f4.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c67f1214-4127-43fd-9b2f-6c17a6d9b4f4.png)'
- en: Next, set the Velocity Over Lifetime, using Random Between Two Curves. For each
    X, Y, Z, use the Curve Editor to set max and min values of `0.05` and `-0.05`
    respectively. (You can modify the vertical axis of the graph by clicking the axis
    label and typing a number; you can copy curves, for example, by right-clicking
    the Z slot, choosing Copy, then right-clicking the Y slot and choosing Paste.)
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置生命周期内的速度，使用“在两个曲线之间随机”。对于每个X、Y、Z，使用曲线编辑器设置最大和最小值分别为`0.05`和`-0.05`。（你可以通过点击轴标签并输入数字来修改图表的垂直轴；例如，你可以通过右键点击Z槽位，选择复制，然后右键点击Y槽位并选择粘贴来复制曲线。）
- en: 'At this point, we should adjust the fireball so it''s about the same size as
    our original BouncyBall. To check:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该调整火球，使其大小大约与我们的原始BouncyBall相同。检查方法如下：
- en: Re-enable the FireBall's Mesh Renderer. Adjust the particle system by changing
    the Renderer's Max Particle Size to `0.1`, or using the Transform Scale
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用火球的网格渲染器。通过更改渲染器的最大粒子大小到`0.1`，或使用变换缩放来调整粒子系统。
- en: Save your work by selecting Apply at the top of Inspector, to update your prefab
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在检查器顶部选择应用来保存你的工作，以更新你的预制件。
- en: Now when you press Play, the Shooters will fire FireBalls. *Oh wow!*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你按下播放时，射手将发射火球。*哇！*
- en: 'If you''d like to add some sparkle effect to the fireball, we can do that with
    the Trail panel:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在火球上添加一些闪光效果，我们可以通过轨迹面板来实现：
- en: Enable the Trail panel
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用轨迹面板
- en: A warning may pop up tell you to add a trails material to the Renderer
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能会弹出警告提示你向渲染器添加轨迹材质。
- en: In the Renderer panel, select the doughnut icon on the Trail Material slot,
    and choose ParticleFireCloud as we use for the main fireball
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染器面板中，选择轨迹材质槽位上的甜甜圈图标，并选择我们用于主火球的ParticleFireCloud。
- en: 'Speaking of trails, if you''d like to also implement trail effects on the fireball,
    there are several ways to do this too.  A quick solution is to duplicate our fireball
    particle system and modify it to use a Cone shape instead of Sphere, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 说到轨迹，如果你也想在火球上实现轨迹效果，也有几种方法可以做到。一个快速的解决方案是复制我们的火球粒子系统，并将其修改为使用圆锥形状而不是球体，如下所示：
- en: Select the Fireball Particle System in Hierarchy.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择火球粒子系统。
- en: Right-click to Duplicate, move the duplicate as a child of Fireball Particle
    System and name it Trail Particle System.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击以复制，将复制品移动为火球粒子系统的子项，并命名为轨迹粒子系统。
- en: Change its Shape to Cone.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其形状更改为圆锥。
- en: Change its Velocity Over Lifetime. The Z curve needs a higher value range, such
    as `0.75` to `0.25`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变其生命周期内的速度。Z曲线需要更高的值范围，例如`0.75`到`0.25`。
- en: The X and Y velocity curves should be smaller for some variation, such as `0.2`
    to `-0.2`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: X和Y速度曲线应该更小，以产生一些变化，例如`0.2`到`-0.2`。
- en: Set the Size Over Lifetime range to `1.0` to `0.5`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置生命周期内大小范围到`1.0`到`0.5`。
- en: In its Transform, set Position to (`0`, `0`, `0.5`) to give it an extra tail.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其变换中，将位置设置为(`0`, `0`, `0.5`)以给它一个额外的尾巴。
- en: Here is a screenshot of the gameplay window paddling an incoming fireball!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是游戏窗口中击打即将到来的火球的截图！
- en: '![](img/c52a7b5d-8b8d-4cc0-88ca-fe7b40ea2df9.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c52a7b5d-8b8d-4cc0-88ca-fe7b40ea2df9.png)'
- en: 'Special thanks to Tyler Wissler for his instructional video *How To: Basic
    Fireballs in Unity* (June 2014), which was very helpful is developing this topic
    ([https://www.youtube.com/watch?v=OWShSR6Tr50](https://www.youtube.com/watch?v=OWShSR6Tr50)).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '特别感谢 Tyler Wissler 的教学视频 *How To: Basic Fireballs in Unity*（2014年6月），这对开发这个主题非常有帮助
    ([https://www.youtube.com/watch?v=OWShSR6Tr50](https://www.youtube.com/watch?v=OWShSR6Tr50))。'
- en: Skull environment
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 骷髅环境
- en: To spice up our game, even more, we should find an exciting environment and
    scene. Searching the Asset Store, I found the *Skull Platform* free asset ([https://assetstore.unity.com/packages/3d/props/skull-platform-105664](https://assetstore.unity.com/packages/3d/props/skull-platform-105664)).
    You can use it too, or find something different.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的游戏更加精彩，我们应该找到一个令人兴奋的环境和场景。在资产商店中搜索，我发现了一个免费的资产 *Skull Platform* ([https://assetstore.unity.com/packages/3d/props/skull-platform-105664](https://assetstore.unity.com/packages/3d/props/skull-platform-105664))。你也可以使用它，或者寻找其他的东西。
- en: 'Assuming you''ve found and installed the Skull Platform asset, we''ll add it
    to our scene. First, let''s render our target as a skull:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经找到了并安装了 Skull Platform 资产，我们将将其添加到我们的场景中。首先，让我们将目标渲染成骷髅：
- en: Drag Platform_Skull_o1 as a child of Target (under `TargetWall`).
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Platform_Skull_o1 作为目标（在 `TargetWall` 下）的子对象。
- en: Set its Transform Rotation (`0`, `0`, `180`) and Scale (`0.3`, `0.3`, `0.3`).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其变换旋转 (`0`, `0`, `180`) 和缩放 (`0.3`, `0.3`, `0.3`)。
- en: Select the Target and disable its Mesh Renderer.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择目标并禁用其网格渲染器。
- en: 'Also, create a new Spotlight (Create | Light | Spotlight) to shine on the skull.
    As a child of Target, I used the following settings: Position (`-1`, `-30`, `-0.6`),
    Rotation (`-60`, `60`, `0`), Range: `10`, Spot Angle: `30`, Color: `#FFE5D4FF`,
    Intensity: `3`.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，创建一个新的聚光灯（创建 | 光 | 聚光灯），使其照在骷髅上。作为目标的子对象，我使用了以下设置：位置 (`-1`, `-30`, `-0.6`),
    旋转 (`-60`, `60`, `0`), 范围：`10`，聚光灯角度：`30`，颜色：`#FFE5D4FF`，强度：`3`。
- en: 'Next, let''s add the big platform as a backdrop behind the wall. The quickest
    way is to merge in the Demoscene they provide:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将大平台作为墙壁背后的背景添加。最快的方法是合并他们提供的 Demoscene：
- en: Create an Empty game object in the Hierarchy root, name it SkullPlatform, reset
    its transform.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构根目录下创建一个空的游戏对象，命名为 SkullPlatform，重置其变换。
- en: Drag a copy of the Skull Platform's demo scene named Platform (`Assets/Skull
    Platform/Demo/` folder) into the Hierarchy.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Skull Platform 的演示场景副本 Platform（`Assets/Skull Platform/Demo/` 文件夹）拖动到层次结构中。
- en: Select the Demo's Scene, Lighting, and Particles objects and drag them as children
    of SkullPlatform.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择演示的场景、照明和粒子对象，并将它们拖动到 SkullPlatform 的子对象。
- en: Now that we have the assets we want, right-click the Platform scene in Hierarchy
    and choose Remove Scene. When prompted, choose Don't Save.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了想要的资产，在层次结构中右键单击平台场景，选择移除场景。当提示时，选择不保存。
- en: Set the SkullPlatform Position to (`0`, `-1.5`, `0`) so it's just below the
    ground plane.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SkullPlatform 位置设置为 (`0`, `-1.5`, `0`)，使其刚好在地面平面下方。
- en: Select the GroundPlane and disable its Mesh Renderer.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 GroundPlane 并禁用其网格渲染器。
- en: 'Now, we''ll set up the scene environment lighting:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置场景环境照明：
- en: Delete the Directional Light from the scene Hierarchy.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景层次结构中删除方向光。
- en: Open the Lighting window. If its not already a tab in your editor, use Window
    | Lighting | Settings and dock it next to the Inspector.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开照明窗口。如果它还不是你的编辑器中的一个标签，请使用窗口 | 照明 | 设置并将其停靠在检查器旁边。
- en: Set its Skybox Material to Sky (provided in the Skull Platform package).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其天空盒材质设置为 Sky（在 Skull Platform 包中提供）。
- en: 'In the Environmental Lighting section, set Source: Color to `#141415`.'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在环境照明部分，将源：颜色设置为 `#141415`。
- en: 'Check the Fog checkbox (in Other Settings), Color to `#8194A1FF`, Mode: Exponential,
    and Density to 0.`03`.'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查雾选项（在其他设置中），颜色为 `#8194A1FF`，模式：指数，密度为 0.`03`。
- en: Here is a screen capture of the scene with the skull platform environment and
    lighting. *Sweet!*
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有骷髅平台环境和照明的场景截图。*太棒了*！
- en: '![](img/eaf4de82-7717-4dd4-995f-811d6347dab9.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eaf4de82-7717-4dd4-995f-811d6347dab9.png)'
- en: Audio synchronization
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频同步
- en: We're almost there building our own version of Audio Shield, we just need to
    add synchronizing the fireball shots with music!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了构建我们自己的音频盾版本，我们只需要添加同步火球射击与音乐！
- en: Unity provides an API for sampling audio source data, including `AudioSource.GetSpectrumData`
    and `GetOutputData`. Extracting actual beats in the music from this data is not
    trivial and requires a lot of math and some understanding of how music encoding
    works.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个API用于采样音频源数据，包括`AudioSource.GetSpectrumData`和`GetOutputData`。从这些数据中提取音乐的实际节拍并不简单，需要大量的数学知识和对音乐编码工作方式的一些理解。
- en: Fortunately, we found an open source script that does this for us, called Unity-Beat-Detection
    ([https://github.com/allanpichardo/Unity-Beat-Detection](https://github.com/allanpichardo/Unity-Beat-Detection)).
    It conveniently provides Unity Events for `onBeat`, which we'll use. (It also
    provides  `onSpectrum` events, with music frequency bands per frame, which you
    could use too, for example, to change the color of the fireball or other things
    based on frequency bands.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们找到了一个开源脚本，名为Unity-Beat-Detection ([https://github.com/allanpichardo/Unity-Beat-Detection](https://github.com/allanpichardo/Unity-Beat-Detection))，它可以为我们完成这项工作。它方便地提供了`onBeat`的Unity事件，我们将使用它。（它还提供了`onSpectrum`事件，每帧提供音乐频率带，你也可以使用它，例如，根据频率带改变火球或其他东西的颜色。）
- en: Download the `AudioProcessor.cs` script from GitHub (we've provided a copy with
    the files for this book for your convenience)
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载`AudioProcessor.cs`脚本（我们已提供与本书文件一起的副本，以方便您使用）
- en: Drag the file into your `Scripts` folder (or use Assets | Import New Asset)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件拖入你的`Scripts`文件夹（或使用Assets | Import New Asset）
- en: For your music, find any MP3 or WAV file that has a nice beat, and import it
    into your project. We looked on SoundCloud NoCopyrightSounds track ([https://soundcloud.com/nocopyrightsounds/tracks](https://soundcloud.com/nocopyrightsounds/tracks))
    to find one named *Third Prototype - Dancefloor* ([http://ncs.io/DancefloorNS](http://ncs.io/DancefloorNS)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的音乐，找到任何有良好节拍的MP3或WAV文件，并将其导入到你的项目中。我们在SoundCloud NoCopyrightSounds轨道 ([https://soundcloud.com/nocopyrightsounds/tracks](https://soundcloud.com/nocopyrightsounds/tracks))
    中找到了一个名为*Third Prototype - Dancefloor* ([http://ncs.io/DancefloorNS](http://ncs.io/DancefloorNS))。
- en: In Project window, create a folder named Audio
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，创建一个名为Audio的文件夹
- en: Drag your music file into the Audio folder (or use Assets | Import New Asset)
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的音乐文件拖到音频文件夹中（或使用Assets | Import New Asset）
- en: 'To implement this feature, we''ll make a MusicController and then modify the
    `ShooterBallGame` script to use its beats to fireballs. In Unity, do the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们将创建一个MusicController，然后修改`ShooterBallGame`脚本以使用其节拍发射火球。在Unity中，执行以下操作：
- en: In Hierarchy, create an Empty game object and name it MusicController
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，创建一个空的游戏对象并命名为MusicController
- en: Add the AudioProcessor script as a component
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将AudioProcessor脚本作为组件添加
- en: Note that it automatically adds an Audio Source component too
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意它还会自动添加一个Audio Source组件
- en: Drag your imported music file onto AudioClip slot
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你导入的音乐文件拖到AudioClip槽中
- en: Drag MusicController itself onto Audio Source slot
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MusicController本身拖到Audio Source槽中
- en: Note the G Threshold parameter on Audio Process. You can use this to adjust
    the sensitivity of the beat recognition algorithm.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意音频处理中的G Threshold参数。你可以使用它来调整节拍识别算法的灵敏度。
- en: 'Now, update the `ShooterBallGame` script on `GameController` as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式更新`GameController`上的`ShooterBallGame`脚本：
- en: '[PRE17]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's very similar to the previous version, but instead of calling `ShootBall`
    from `Update`, based on the time interval, we call it from `onBeatDetected`. In
    `Start`, we add `onBeatDetected` as an `onBeat` event listener.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 它与上一个版本非常相似，但不是从`Update`中调用`ShootBall`，而是根据时间间隔从`onBeatDetected`中调用它。在`Start`中，我们将`onBeatDetected`添加为`onBeat`事件监听器。
- en: Also, we've decided to randomly decide which shooter to use rather than just
    alternating back and forth.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们决定随机选择使用哪种射击方式，而不是简单地来回交替。
- en: 'Press Play and go at it! *Whoohoo,* we have our own version of Audio Shield!
    A screenshot of active gameplay is shown here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放并开始游戏！*哇哦，*我们有了自己的音频盾牌版本！以下是活跃游戏截图：
- en: '![](img/9c0c2270-17b5-46db-bebf-6ec52f55ca40.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c0c2270-17b5-46db-bebf-6ec52f55ca40.png)'
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a game that uses Unity's Physics Engine and a number
    of other features. First, we explained in layman's terms the relationship between
    Rigidbody, Colliders, and Physic Materials, and explored how the physics engine
    uses these to determine the velocity and collision of objects in the scene.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个使用Unity物理引擎和其他一些功能的游戏。首先，我们用通俗易懂的语言解释了Rigidbody、Collider和Physic
    Materials之间的关系，并探讨了物理引擎如何使用这些来决定场景中物体的速度和碰撞。
- en: Then, we considered the life cycle of game objects and implemented an object
    pooler that helps avoid memory fragmentation and garbage collection, which can
    lead to performance problems and VR discomfort.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考虑了游戏对象的整个生命周期，并实现了一个对象池器，它有助于避免内存碎片化和垃圾回收，这些问题可能导致性能问题和VR体验不适。
- en: Using what we learned, we implemented several variations of a ball game, first
    aiming for a target with your head, then using hand paddles. We modified the game
    so that, instead of serving balls from above-using gravity, we shoot them from
    in front and apply a velocity vector. Lastly, we juiced up our game, changing
    the bouncy balls into fireballs, adding a cool level environment, and synchronizing
    the fireballs to music beats. In the end, we have a good start to making our own
    version of the Audio Shield VR game.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们所学的知识，我们实现了几个球类游戏的变体，首先是用头部瞄准目标，然后使用手柄。我们修改了游戏，使其不是从上方使用重力来发球，而是从前面发射并应用一个速度向量。最后，我们增强了我们的游戏，将弹跳球变成了火球，添加了一个酷炫的关卡环境，并将火球与音乐节拍同步。最终，我们为制作我们自己的音频盾VR游戏版本迈出了良好的开端。
- en: In the next chapter, we will see another more practical example of a virtual
    interactive space. We are going to build an interactive art gallery space that
    you can move through and query the artwork for information and details.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到另一个更实用的虚拟交互空间示例。我们将构建一个互动艺术画廊空间，你可以在其中移动并查询艺术品的详细信息。
