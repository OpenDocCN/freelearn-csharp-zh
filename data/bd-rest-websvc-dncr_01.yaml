- en: Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Modern web development demands interaction with servers without any hassle.
    What this means is that with the evolution of different UI and backend frameworks,
    developers need to find a way of sharing data with any available framework without
    any dependencies. This means there should be a way of sharing data from the server
    with clients, irrespective of their language and framework. To bring a uniformity
    to sharing data, the first thing that comes to mind is `.xml` and `.json`. These
    formats are supported by every framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web开发要求与服务器交互时没有麻烦。这意味着随着不同UI和后端框架的演变，开发者需要找到一种方法，在不依赖任何框架的情况下与任何可用的框架共享数据。这意味着应该有一种方法从服务器向客户端共享数据，无论它们的语言和框架如何。为了使数据共享统一，首先想到的是`.xml`和`.json`格式。这些格式被每个框架所支持。
- en: In this chapter, we will look at an architectural style by which we can get
    or send data from any program written in any language using any framework. With
    REST, the architecture we will be discussing, we can bring in methods that can
    be easily consumed by clients for data operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一种架构风格，通过它可以从任何语言使用任何框架编写的任何程序中获取或发送数据。使用REST，我们将讨论的架构可以引入客户端易于消费的数据操作方法。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: RESTful services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful服务
- en: Why should we use RESTful services? The difference between RESTful and RESTless
    services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用RESTful服务？RESTful和RESTless服务之间的区别
- en: Client-server architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: ASP.NET Core and RESTful services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core和RESTful服务
- en: Discussing RESTful services
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论RESTful服务
- en: '**REST** stands for **representational state transfer**. It is an architectural
    style that defines a set of guidelines for building web services.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表征状态转移**。它是一种定义构建Web服务的一组指南的架构风格。'
- en: What is an architectural style? It's nothing but a concept with predefined principles.
    We will talk about these principles in a moment. When you follow REST, you are
    actually implementing the principles that are the building blocks of REST in your
    application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是架构风格？它不过是一个具有预定义原则的概念。我们稍后将讨论这些原则。当你遵循REST时，你实际上是在你的应用程序中实现REST的构建块原则。
- en: However, the implementation of REST will definitely differ from developer to
    developer. There is no fixed implementation style. Don't get confused with **architectural
    patterns**, which are not concepts but the actual implementations. MVC is an architectural
    pattern as it has a fixed structure that defines how the components interact with
    each other where they can't be differently implemented.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，REST的实现方式肯定会有所不同，每个开发者都有自己的实现风格。没有固定的实现方式。不要与**架构模式**混淆，架构模式不是概念，而是实际的实现。MVC就是一个架构模式，因为它有一个固定的结构，定义了组件之间如何交互，以及它们不能有不同的实现方式。
- en: 'The following is a very simple diagram of a REST-based service:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基于REST的服务非常简单的图示：
- en: '![](img/641c4372-c171-4dd6-b846-750dd2afd7d7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/641c4372-c171-4dd6-b846-750dd2afd7d7.png)'
- en: To simplify things, consider the preceding diagram, which shows you a service
    that has certain methods, such as `GET`, `POST`, `PUT`, and `DELETE`. That is
    what this style is all about. When you design your service, which will have all
    these methods—with the intended operations inside them—we can consider it as a
    REST-based service, otherwise known as a RESTful service. More importantly, the
    service can be called from an application built in any platform and language as
    the service has a standard architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，考虑前面的图示，它展示了具有某些方法的服务，例如`GET`、`POST`、`PUT`和`DELETE`。这就是这种风格的核心所在。当你设计你的服务时，它将包含所有这些方法——以及它们内部预期的操作——我们可以将其视为基于REST的服务，也称为RESTful服务。更重要的是，服务可以从任何平台和任何语言构建的应用程序中调用，因为服务具有标准化的架构。
- en: As discussed, a RESTful service is a service that supports REST. Let's talk
    about the characteristics of REST so that we can understand what is expected from
    a service that is RESTful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，RESTful服务是一种支持REST的服务。让我们来谈谈REST的特性，以便我们了解对RESTful服务的期望。
- en: REST characteristics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 特性
- en: The main building blocks of web services are the client and server architectures.
    The response sent from the server is actually a reply to the client's request.
    It's like you are asking a question and the server responds if it finds the answer.
    The response that comes from the server is actually a resource in a certain format
    or representation. The formats that are usually seen are `.json`, `.xml`, `.pdf`,
    `.doc`, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务的主要构建块是客户端和服务器架构。从服务器发送的响应实际上是针对客户端请求的回复。这就像你提出一个问题，服务器在找到答案时会做出回应。从服务器返回的响应实际上是以某种格式或表示的资源。常见的格式有`.json`、`.xml`、`.pdf`、`.doc`等等。
- en: REST is stateless. **Stateless** means that the state of the system is always
    different. So, when a request comes to the server, it is served and forgotten.
    Thus, the next request does not depend on the state of the previous one. Each
    request is handled by the server independently.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: REST是无状态的。**无状态**意味着系统的状态始终不同。因此，当请求到达服务器时，它会被服务并遗忘。因此，下一个请求不依赖于前一个请求的状态。每个请求都由服务器独立处理。
- en: The requests are performed in an HTTP connection. They each take the form of
    a **u****niform resource identifier** (**URI**). This identifier helps us to locate
    the required resource on the web server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请求是在HTTP连接中执行的。它们各自都采取**统一资源标识符**（**URI**）的形式。这个标识符帮助我们定位互联网服务器上的所需资源。
- en: 'Roy Fielding’s PhD dissertation, entitled *Architectural Styles and the Design
    of Network-Based Software Architectures*, defined REST. The following are some
    key points extracted from his research:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding的博士论文，题为《架构风格和网络软件架构设计》，定义了REST。以下是他研究中的几个关键点：
- en: Like many distributed architectures, REST imposes layers, statelessness, and
    caching.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与许多分布式架构一样，REST强加了层、无状态和缓存。
- en: REST improves efficiency, interoperability, and overall performance.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST提高了效率、互操作性和整体性能。
- en: REST introduces uniformity by following a set of rules on how to identify and
    manipulate resources, along with the process to simplify the description about
    its operations through metadata so that the messages passed will be self-explanatory.
    We will talk more about this uniformity, which is called the **u****niform interface**.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST通过遵循一系列关于如何标识和操作资源以及通过元数据简化其操作描述的过程来引入一致性。我们将更多地讨论这种一致性，这被称为**统一接口**。
- en: As REST is an architectural style, a service can be developed using any language
    or platform as long as it supports HTTP.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于REST是一种架构风格，只要支持HTTP，就可以使用任何语言或平台来开发服务。
- en: You can read the whole dissertation at [https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)阅读完整的论文。
- en: Resource-oriented architecture
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源导向架构
- en: Every resource on the web has been given a unique identifier, otherwise known
    as a URI. The **uniform resource locator** (**URL**) is the most common type of
    URI used on the web today. The URL [https://www.packtpub.com/](https://www.packtpub.com/) identifies
    and locates the Packt Publishing site.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 网上的每个资源都已被赋予一个唯一的标识符，也称为URI。**统一资源定位符**（**URL**）是今天在互联网上使用最广泛的URI类型。URL [https://www.packtpub.com/](https://www.packtpub.com/)
    识别并定位Packt Publishing网站。
- en: 'Let''s look at a quick picture of the architecture. In the following diagram,
    a client is trying to access a resource through an identifier (URL). The resource
    is present on the server and has a representation that can be returned to the
    client when requested:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下架构的图片。在下面的图中，客户端正在尝试通过一个标识符（URL）访问资源。资源存在于服务器上，并且有一个可以在请求时返回给客户端的表示：
- en: '![](img/bc2b638a-ee53-42e8-96dc-e7bd8f7b1943.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc2b638a-ee53-42e8-96dc-e7bd8f7b1943.png)'
- en: As the name suggests, the URL is something that is tied to only one resource;
    therefore, if I want to point someone to one resource, I can easily share that
    identifier in email, chat, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，URL是与单一资源相关联的；因此，如果我想指向一个资源，我可以在电子邮件、聊天中等轻松地共享该标识符。
- en: These identifiers can by easily remembered if they are named with company or
    resource names. The best example is [www.google.com](https://www.google.com/), which
    is very easy to remember as the name Google is present. Therefore, we can spread
    the resource link by word of mouth and you can enter it into a web browser, such
    as Chrome or Firefox, within seconds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用公司或资源名称命名，这些标识符很容易记住。最好的例子是 [www.google.com](https://www.google.com/)，因为Google这个名字很容易记住。因此，我们可以通过口碑传播资源链接，你可以在几秒钟内将其输入到网络浏览器中，例如Chrome或Firefox。
- en: You might find hyperlinks on a particular web page that link to another website
    for another resource. That means that resources are now interconnected because
    of the hyperlinks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在某个网页上找到超链接，链接到另一个网站上的另一个资源。这意味着由于超链接的存在，资源现在是相互关联的。
- en: These interconnected resources form the resource-oriented architecture. Hyperlinks
    make it easy to navigate from one resource to another by using the target resource
    URI.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相互关联的资源构成了面向资源的架构。超链接使得通过目标资源URI从一个资源导航到另一个资源变得容易。
- en: 'For example, in HTML, you link to another resource through the anchor element.
    The following is one anchor element that links to Packt''s IoT book catalog page:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在HTML中，你通过锚元素链接到另一个资源。以下是一个链接到Packt的物联网图书目录页面的锚元素：
- en: '`<a href="https://www.packtpub.com/tech/Internet%20of%20 Things">Packt IoT
    Books</a>`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<a href="https://www.packtpub.com/tech/Internet%20of%20%20Things">Packt IoT
    Books</a>`'
- en: 'By default, the anchor element is rendered as an underlined text. When you
    hover over it, you can see the attached URI at the bottom, as shown in the following
    screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，锚元素被渲染为带下划线的文本。当你悬停在它上面时，你可以在下面的截图看到附加的URI：
- en: '![](img/88e544c6-dead-49bb-bf36-e490df4a8afd.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88e544c6-dead-49bb-bf36-e490df4a8afd.png)'
- en: You can click on the anchor text (Packt IoT Books), which then fires a `GET`
    request for the target resource URI.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击锚文本（Packt IoT Books），然后对目标资源URI发起一个 `GET` 请求。
- en: Note that the moment you click the hyperlink, you will land on a web page that
    is actually a representation of a resource. The most common representation you
    will encounter is in HTML format. Some other common formats are (X)HTML, JPEG,
    GIF, WMV, SWF, RSS, ATOM, CSS, JavaScript/JSON, and so on. When a browser receives
    one of these representations, it tries to parse it and then renders it for viewing,
    if parsing succeeds.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你点击超链接时，你会跳转到实际上是一个资源表示的网页。你将遇到的最常见的表示形式是HTML格式。其他一些常见的格式包括（X）HTML、JPEG、GIF、WMV、SWF、RSS、ATOM、CSS、JavaScript/JSON等等。当浏览器收到这些表示之一时，它会尝试解析它，并在解析成功后将其渲染供查看。
- en: URI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI
- en: We have talked a lot about resources. They are actually the pages that we see
    on a particular website. However, resources in HTTP are not just simple files
    in the form of HTML web pages. Generally, a resource is defined as any piece of
    information that can be uniquely  identified by a URI, such as [http://packtpub.com/](http://packtpub.com/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈了很多关于资源的内容。实际上，它们是我们在一个特定网站上看到的页面。然而，HTTP中的资源不仅仅是简单的HTML网页形式的文件。通常，资源被定义为任何可以通过URI唯一识别的信息，例如
    [http://packtpub.com/](http://packtpub.com/)。
- en: 'Let''s talk about URIs for a moment. A URI consists of a few components: a
    URI scheme name, such as `http` or `ftp` is the first part, followed by a colon
    character. After the colon character comes the hierarchical part:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时谈谈URI。一个URI由几个组件组成：一个URI方案名称，例如 `http` 或 `ftp` 是第一部分，后面跟着一个冒号字符。冒号字符之后是层次结构部分：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s analyze one URI:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一个URI：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the preceding URI:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的URI：
- en: The scheme name is `https`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方案名称是 `https`。
- en: The scheme name is followed by the hierarchical part, `//www.flipkart.com/men/tshirts/pr`.
    The hierarchical part starts with `//`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方案名称后面跟着层次结构部分，`//www.flipkart.com/men/tshirts/pr`。层次结构部分以 `//` 开头。
- en: The hierarchical part also contains an optional query, which is `sid=2oq%2Cs9b%2Cj9y`,
    in this case.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次结构部分还包含一个可选的查询，例如在这个例子中是 `sid=2oq%2Cs9b%2Cj9y`。
- en: 'The following is an example of a URI containing the optional fragment part:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含可选片段部分的URI示例：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: REST constraints
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST约束
- en: 'REST is defined by six constraints, as shown in the following diagram. One
    of them is optional:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: REST由六个约束定义，如下所示图所示。其中一个是可选的：
- en: '![](img/e2cdfe5c-ba40-4e18-90eb-9fa10d21acce.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2cdfe5c-ba40-4e18-90eb-9fa10d21acce.png)'
- en: Each of these constraints enforce a design decision for the service that is
    to be followed. If it is not followed, the service can't be denoted as RESTful.
    Let's discuss these constraints one by one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束中的每一个都强制服务遵循一个设计决策。如果不遵循，则该服务不能被视为RESTful。让我们逐一讨论这些约束。
- en: Client-server architecture
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: The client or the consumer of the service should not worry about how the server
    processes the data and stores it in the database. Similarly, the server does not
    need to depend on the client's implementation, especially the UI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端或服务的消费者不需要担心服务器如何处理数据并将其存储在数据库中。同样，服务器也不需要依赖于客户端的实现，尤其是用户界面。
- en: Think of an *internet of things* device or *sensor* that doesn't have much of
    a UI. However, it interacts with the server to store data using APIs, which are
    programmed to be fired on specific events. Suppose you are using an IoT device
    that alerts you when your car runs out of petrol. At the time of a petrol shortage
    detection by the sensor in the IoT device, it calls the configured API, which
    then finally sends an alert to the owner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个没有太多用户界面的物联网设备或**传感器**。然而，它通过与服务器交互使用API来存储数据，这些API被编程在特定事件上触发。假设你正在使用一个物联网设备，当你的车耗尽汽油时它会提醒你。当物联网设备中的传感器检测到汽油短缺时，它会调用配置好的API，然后最终向车主发送警报。
- en: 'What that means is that the client and server are not one entity and each can
    live without the other. They can be designed and evolved independently. Now you
    might ask, *How can a client **work **without knowing about the server''s architecture,
    and vice versa?* Well, that is what these constraints are meant for. The service,
    when interacted with by the clients, provides enough information about its nature:
    how to consume it, and what operations you can carry out using it.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端和服务器不是同一个实体，它们可以独立存在。它们可以独立设计和演进。现在你可能想知道，**客户端如何在没有了解服务器架构的情况下工作，反之亦然**？好吧，这正是这些约束的目的所在。当服务被客户端交互时，提供了足够的信息关于其本质：如何消费它，以及你可以使用它执行哪些操作。
- en: As we go ahead in this section, you will realize that there is absolutely no
    relation between the client and the server, and they can be completely decoupled
    if they adhere to all these constraints perfectly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本节内容，你会发现客户端和服务器之间完全没有关系，并且如果它们完美地遵守所有这些约束，它们可以完全解耦。
- en: Stateless
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: The term stateless means that the state in which the application remains for
    a particular time may not persist to the next moment. A RESTful service does not
    maintain the application's state, and thus it is stateless.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态这个术语意味着应用程序在特定时间内保持的状态可能不会持续到下一个时刻。RESTful服务不维护应用程序的状态，因此它是无状态的。
- en: A request in a RESTful service does not depend on a past request. The service
    treats each request independently. On the other hand, a stateful service needs
    to record the application's current state when the request is performed so that
    it can act as required for the next request.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务中的请求不依赖于过去的请求。服务独立处理每个请求。另一方面，有状态服务需要在请求执行时记录应用程序的当前状态，以便它可以针对下一个请求采取必要的行动。
- en: Moreover, because of an absence of these complications, stateless services become
    very easy to host. As we need not worry about the state of the application, it
    becomes easy to implement, and maintenance becomes smooth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于没有这些复杂性，无状态服务变得非常容易托管。因为我们不需要担心应用程序的状态，所以实现起来变得容易，维护也变得顺畅。
- en: Caching
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: To avoid generating the same data with every request, there is a technique called
    **caching** that is used to store the data either on the client's or the server's
    side. This cached data may be used for further reference whenever it is required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次请求都生成相同的数据，存在一种称为**缓存**的技术，用于在客户端或服务器端存储数据。这些缓存数据可以在需要时用于进一步参考。
- en: When using caching, it is important that you manage it properly. The reason
    for this is simple. We are storing data that won't be replaced by fresh data from
    the server. While this is an advantage that increases the performance of the service,
    at the same time, if we are not careful as to what to cache and configure during
    its lifetime, we might end up seeing outdated data. For example, suppose we are
    showing the live price of gold on our website and we cached this figure. The next
    time the price changes, it won't be reflected unless we expire the cache that
    was previously stored.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用缓存时，正确管理它非常重要。原因很简单。我们正在存储不会被服务器的新数据替换的数据。虽然这增加了服务的性能，但同时，如果我们不小心缓存什么以及在其生命周期内如何配置，我们可能会看到过时的数据。例如，假设我们在网站上显示黄金的实时价格，并且我们缓存了这个数字。下次价格变化时，除非我们过期之前存储的缓存，否则它不会反映出来。
- en: 'Let''s look at the different kinds of HTTP headers and how to configure caches:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同类型的HTTP头以及如何配置缓存：
- en: '| **Header** | **Application** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **头** | **应用** |'
- en: '| Date | Date and time of the generation of the representation. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 表示生成的日期和时间。 |'
- en: '| Last modified | Date and time when this representation was last modified
    by the server. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 最后修改 | 服务器最后修改此表示的时间戳。 |'
- en: '| Cache-control | The HTTP 1.1 header used to control caching. We will look
    at this in more detail after this table. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Cache-control | 这是用于控制缓存的HTTP 1.1头。我们将在表格之后更详细地讨论这一点。 |'
- en: '| Expires | This header helps to tag an expiration date and time for this representation.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Expires | 此头帮助为表示标记一个过期日期和时间。 |'
- en: '| Age | Denotes the time in seconds since the representation was fetched from
    the server. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| Age | 表示自表示从服务器获取以来经过的秒数。 |'
- en: The configuration of the preceding five headers depends upon the nature of the
    service. Take the example of the service that provides the live price of gold—ideally,
    it would have the cache age limit as low as possible, or even have caching turned
    off, because users should see the latest results every time they refer to the
    site.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前五个头的配置取决于服务的性质。以提供实时黄金价格的服务的例子来说，理想情况下，它应该将缓存年龄限制尽可能低，或者甚至关闭缓存，因为用户每次访问网站时都应该看到最新的结果。
- en: However, a site that contains many images would hardly change or update them.
    In that case, the cache can be configured to store them for a longer duration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，包含许多图像的网站几乎不会更改或更新它们。在这种情况下，缓存可以配置为存储更长时间。
- en: These header values are consulted in accordance with the cache-control header
    to check whether the cached results are still valid or not.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头值将根据cache-control头进行咨询，以检查缓存的结果是否仍然有效。
- en: 'The following are the most common values for the cache-control header:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的cache-control头值：
- en: '| **Directive** | **Application** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **应用** |'
- en: '| Public | This is the default directive. This allows every component to cache
    the representation. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 公共 | 这是默认指令。这允许每个组件缓存表示。 |'
- en: '| Private | Only the client or server can cache the representation. However, intermediary
    components are restricted. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 私有 | 只有客户端或服务器可以缓存表示。但是，中间组件受到限制。 |'
- en: '| no-cache/no-store | With this value, we can turn off caching. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| no-cache/no-store | 使用此值，我们可以关闭缓存。 |'
- en: '| max-age | This value is the time in seconds after the date and time is mentioned
    in the *Date* header, which denotes the validity of the representation. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| max-age | 此值表示自*日期*头中提到的日期和时间起，经过的秒数，该头表示表示的有效性。 |'
- en: '| s-maxage | This does the same as max-age, but only targets intermediary caching.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| s-maxage | 这与max-age的功能相同，但仅针对中间缓存。 |'
- en: '| must-revalidate | This states that the representation must be revalidated
    if the max-age has passed. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| must-revalidate | 这表示如果max-age已过，则必须重新验证表示。 |'
- en: '| proxy-validate | This does the same as max-revalidate, but only targets intermediary
    caching. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| proxy-validate | 这与max-revalidate的功能相同，但仅针对中间缓存。 |'
- en: Code on demand (optional)
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要时按需提供代码（可选）
- en: As the phrase *code on demand* suggests, the service may try to execute code
    on the client to extend the functionality. However, this is optional, and not
    every service does this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如短语*按需代码*所暗示的，服务可能会尝试在客户端执行代码以扩展功能。然而，这是可选的，并不是每个服务都这样做。
- en: Consider an example of a web application that calls a ticketing service to fetch
    all the available tickets. The service wants always to show this information in
    an alert. In order to do this, the service can return a JavaScript code along
    with the data, which has an alert message with the number of available tickets.
    Thus, as soon as the client receives the response from the service, an alert is
    executed and the data is shown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个网络应用的例子，该应用调用票务服务以获取所有可用的票。该服务总是希望在警报中显示此信息。为此，服务可以返回与数据一起的JavaScript代码，其中包含带有可用票数警报的消息。因此，一旦客户端从服务接收到响应，就会执行警报并显示数据。
- en: Uniform interface
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一接口
- en: When we encounter the word *interface*, the first thing that comes to our mind
    is decoupling. We create interfaces to have loosely coupled architecture, and
    the same type of architecture is seen in the case of RESTful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到“接口”这个词时，首先想到的是解耦。我们创建接口以实现松散耦合的架构，在RESTful的案例中也可以看到同样的架构。
- en: While implementing REST, we use the same concept to decouple the client from
    the implementation of the REST service. However, to implement such a decoupling
    between the client and the service, standards are defined that every RESTful service
    supports.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现REST时，我们使用相同的概念来解耦客户端和REST服务的实现。然而，为了在客户端和服务之间实现这种解耦，定义了标准，每个RESTful服务都支持这些标准。
- en: Note the word *standard* in the preceding line. We have so many services in
    the world and, obviously, the consumers outnumber the services. As a result, we
    have to follow some rules while designing the services because every client should
    understand the service easily without any hassle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上一行中的“标准”一词。世界上有如此多的服务，显然，消费者数量超过了服务。因此，在设计服务时，我们必须遵循一些规则，因为每个客户端都应该能够轻松地理解服务，而无需任何麻烦。
- en: 'REST is defined by four interface constraints:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: REST由四个接口约束定义：
- en: '**Identification of resources**: A URI is used to identify a resource. The
    resource is a web document.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的标识**：URI用于标识资源。资源是一个网络文档。'
- en: '**Manipulation of resources through representations**: When a client has a
    given resource—along with any metadata—they should have enough information to
    either modify or delete the resource. So, for example, `GET` means that you want
    to retrieve data about the URI-identified resource. You can describe an operation
    with an `HTTP` method and a URI.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示操作资源**：当客户端拥有一个给定的资源——以及任何元数据——他们应该有足够的信息来修改或删除资源。例如，`GET`意味着你想要检索关于URI标识的资源的数据。你可以使用HTTP方法和URI来描述一个操作。'
- en: '**Self-descriptive messages**: The messages passed should contain enough information
    about the data to be understood and processed for further operations. MIME types
    are used for this purpose.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自描述消息**：传递的消息应包含足够的数据信息，以便理解和处理以进行后续操作。MIME类型用于此目的。'
- en: '**Hypermedia as the engine of the application state** (**HATEOAS**): The representation
    returned from the service should contain all the future actions as links. It is
    the same as visiting a website in which you find different hyperlinks providing
    you with the different types of available operations.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用程序状态引擎**（**HATEOAS**）：服务返回的表示应包含所有未来操作作为链接。这就像访问一个网站，你可以在其中找到不同的超链接，为你提供不同类型的可用操作。'
- en: 'HTTP 1.1 provides a set of methods, called verbs. Implementing these verbs
    in our services would mark them as standardized. The important verbs are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1提供了一套称为动词的方法。在我们的服务中实现这些动词将使它们成为标准化的。重要的动词如下：
- en: '| **Method** | **Operation Performed on Server** | **Method Type** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **在服务器上执行的操作** | **方法类型** |'
- en: '| `GET` | Read/retrieve a resource. | Safe |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 读取/检索一个资源。 | 安全 |'
- en: '| `PUT` | Either insert a new resource or update the resource if it already
    exists. | Idempotent |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 要么插入一个新资源，要么如果它已经存在，则更新该资源。 | 幂等 |'
- en: '| `POST` | Insert a new resource. Can be used to update an existing resource
    as well. | Nonidempotent |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 插入一个新资源。也可以用来更新现有资源。 | 非幂等 |'
- en: '| `DELETE` | Delete a resource . | Idempotent |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除一个资源。 | 幂等 |'
- en: '| `OPTIONS` | Get a list of all the allowed operations for a resource. | Safe
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 获取一个资源的所有允许的操作列表。 | 安全 |'
- en: '| `HEAD` | Return only the response headers with no response body. | Safe |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 仅返回响应头，不返回响应体。 | 安全 |'
- en: The preceding table is quite self-explanatory, except the *Method Type* column.
    Let me clarify this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格相当直观，除了“方法类型”列。让我澄清这一点。
- en: A s*afe* operation when performed on the service does not have any effect on
    the original value of the resource. As the `GET`, `OPTIONS`, and `HEAD` verbs
    only retrieve or read the resource-related stuff and does not update that, they
    are safe.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当在服务上执行时，一个安全的操作不会对资源的原始值产生影响。由于`GET`、`OPTIONS`和`HEAD`动词仅检索或读取与资源相关的信息，并不更新它，因此它们是安全的。
- en: An *idempotent (can be repeated)* operation when performed gives the same result
    no matter how many times we perform it. For example, when you make a `DELETE`
    or `PUT` operation, you are actually operating on a particular resource, and the
    operation can be repeated with no issues.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行幂等（可重复）操作时，无论我们执行多少次，都会得到相同的结果。例如，当你进行`DELETE`或`PUT`操作时，你实际上是在操作一个特定的资源，并且操作可以重复执行而不会出现任何问题。
- en: '`POST` versus `PUT`: This is a very common topic of discussion on the internet,
    and one that is very easy to understand. Both `POST` and `PUT` can be used to
    insert or update a resource. However, `POST` is nonidempotent, meaning that it
    isn''t repeatable. The reason is that each time you call using `POST`, it will
    create a new resource if you don''t provide the exact URI of the resource. The
    next time you use `POST`, it will again create a new resource. However, in `PUT`,
    it will first validate the existence of the resource. If it exists, it will update
    it; otherwise, it will create it.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`与`PUT`：这是互联网上非常常见的讨论话题，也是很容易理解的一个话题。`POST`和`PUT`都可以用来插入或更新资源。然而，`POST`是非幂等的，这意味着它不可重复。原因是每次你使用`POST`调用时，如果你没有提供资源的精确URI，它将创建一个新的资源。下次你使用`POST`时，它将再次创建一个新的资源。但在`PUT`中，它将首先验证资源是否存在。如果存在，它将更新它；否则，它将创建它。'
- en: More explanation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多解释
- en: Among all the available methods, `GET` is the most popular one, as it is used
    to fetch the resource.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用方法中，`GET`是最受欢迎的，因为它用于获取资源。
- en: The `HEAD` method will only return the response headers with an empty body.
    This is mostly only required when we don't need the whole representation of the
    resource.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD`方法只会返回带有空体的响应头。这通常只在不需要整个资源表示的情况下才需要。'
- en: The `OPTIONS` method is used to get a list of the allowed or available operations
    on the resource.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONS`方法用于获取资源上允许或可用的操作列表。'
- en: 'Consider the following request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下请求：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the request is authorized and authenticated, it might return something like
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求被授权和验证，它可能会返回以下内容：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The response is actually saying that the service can be called using only all
    these methods.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 响应实际上是在说，服务只能使用所有这些方法来调用。
- en: Make sure you use the HTTP methods according to their specification. If you
    design the service to allow `GET`, but perform a delete operation inside that,
    then clients will get confused. As they try to `GET` something, it will actually
    delete the resource, which is weird.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你根据规范使用HTTP方法。如果你设计的服务允许`GET`，但在其中执行删除操作，那么客户端会感到困惑。因为他们试图`GET`一些内容，实际上会删除资源，这是很奇怪的。
- en: 'The following is a request that is made with `GET`, but it actually deletes
    the resource inside the server (just imagine):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`GET`发出的请求，但实际上它删除了服务器内的资源（只需想象）：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding request might work and delete the resource, but this is not regarded
    as a RESTful design. The recommended operation would be to use `DELETE` method
    to delete a resource like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的请求可能可以工作并删除资源，但这不被视为RESTful设计。推荐的操作是使用`DELETE`方法删除资源，如下所示：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: POST versus PUT explained
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST与PUT解释
- en: 'The use of `POST` and `PUT `can be summarized in the following two points:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`和`PUT`的使用可以总结为以下两点：'
- en: '`PUT` is idempotent—it can be repeated, and yields the same result every time.
    If the resource does not exist, it will create it; otherwise, it will update it.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`是幂等的——它可以重复执行，并且每次都产生相同的结果。如果资源不存在，它将创建它；否则，它将更新它。'
- en: '`POST` is nonidempotent—multiple resources will be created if it is called
    more than once.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`是非幂等的——如果多次调用，将会创建多个资源。'
- en: 'The preceding contrast between these verbs is just a general difference. However,
    there is a very important and significant difference. When using `PUT`, specifying
    the complete URI of the resource is necessary. Otherwise, it won''t work. For
    example, the following won''t work as it does not specify the exact URI of the
    author, which can be done by specifying an ID:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动词之间的先前对比只是一个一般性的差异。然而，有一个非常重要且显著的区别。当使用`PUT`时，指定资源的完整URI是必要的。否则，它将不起作用。例如，以下将不起作用，因为它没有指定作者的确切URI，这可以通过指定一个ID来完成：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To fix this, you can send an ID with this URI using something like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以使用以下类似的方法通过此URI发送一个ID：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that the author with the ID `19` will be processed, but if that does
    not exist, it will be created first. Subsequent requests with this URI will be
    considered as requests to modify the author resource with an ID of `19`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着具有ID `19`的作者将被处理，但如果该作者不存在，它将首先被创建。随后的对此URI的请求将被视为修改具有ID `19`的作者资源的更新请求。
- en: 'On the other hand, if we do the same with a `POST` request like the following,
    it will create a new author resource with the posted data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们使用以下类似的`POST`请求，它将创建一个新的作者资源，并使用发布的数据：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Interestingly, if you repeat this, you will be responsible for duplicate records
    with the same data. That is why it is *nonidempotent* in nature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果你重复这样做，你将负责具有相同数据的重复记录。这就是为什么它在本质上是非幂等的。
- en: 'Note the following request with `POST` with an ID. Unlike `PUT`, `POST` won''t
    consider this for a new resource, if that is does not exist. It will always be
    treated as an update request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下带有ID的`POST`请求。与`PUT`不同，如果该资源不存在，`POST`不会将其视为新资源的请求。它始终被视为更新请求：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following are the main points to focus on in this section:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，以下是一些需要关注的主要点：
- en: '`PUT` creates or updates one resource, as long as you are calling the same
    URI'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`在调用相同的URI时创建或更新一个资源'
- en: '`PUT` and `POST` behave the same, if the resource already exists'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果资源已经存在，`PUT`和`POST`的行为相同
- en: '`POST`, without an ID, will create a resource each time it is fired'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`，如果没有ID，每次触发时都会创建一个资源'
- en: Layered system
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层系统
- en: Most modern applications are designed using multiple layers, and the same is
    expected from a RESTful service. In a layered system, each layer is restricted
    to only seeing or knowing the next layer in the hierarchy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序都是使用多层设计的，RESTful服务也期望如此。在分层系统中，每一层都限制在只能看到或知道层次结构中的下一层。
- en: Having a layered architecture helps improve the code's readability, hides complexities,
    and improves the code's maintainability. Imagine that you have one layer and everything
    takes place in it, from authentication to database operations. This is absolutely
    not recommended, as the primary components, such as authentications, business
    logic, and database operations, are not separated out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有分层架构有助于提高代码的可读性，隐藏复杂性，并提高代码的可维护性。想象一下，你只有一个层，从身份验证到数据库操作的一切都在其中进行。这绝对是不推荐的，因为主要组件，如身份验证、业务逻辑和数据库操作，并没有分离出来。
- en: Thus, this constraint is expected from a RESTful service, and no client can
    actually say that it is connected to the final layer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从RESTful服务中期望这种约束，并且没有任何客户端实际上可以说它连接到了最终层。
- en: Advantages and disadvantages of RESTful services
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful服务的优缺点
- en: 'The following are some advantages and disadvantages of RESTful services:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些RESTful服务的优缺点：
- en: Advantages
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: 'The advantages of using RESTful services are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful服务的优势如下：
- en: No dependency on a platform or any programming language
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不依赖于平台或任何编程语言
- en: Standardized methods through HTTP
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP标准化的方法
- en: It doesn't store the state of the clients on the server
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会在服务器上存储客户端的状态
- en: Supports caching
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持缓存
- en: Accessible to any type of client, such as mobile, web, or desktop
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可供任何类型的客户端访问，例如移动、Web或桌面
- en: Disadvantages
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'While there are advantages, there must be some cons. Let''s look at some disadvantages
    of RESTful services:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有优势，但肯定也有一些缺点。让我们来看看RESTful服务的缺点：
- en: If the standards are not followed correctly, they are difficult for clients
    to understand
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不正确遵循标准，它们对客户端来说很难理解
- en: Documentation becomes problematic as no such metadata is provided
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有提供此类元数据，文档变得有问题
- en: Security is a concern, if no such process is followed to restrict the access
    of resources
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有遵循任何过程来限制资源的访问，安全性是一个关注点
- en: ASP.NET Core and RESTful services
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core和RESTful服务
- en: .NET Core is defined as a cross-platform, open-source, cloud-ready, and modular
    .NET platform for creating modern web apps, microservices, libraries, and console
    applications that run everywhere (Windows, Linux, and macOS).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 被定义为用于创建现代 Web 应用程序、微服务、库和控制台应用程序的跨平台、开源、云就绪和模块化 .NET 平台，这些应用程序可以在任何地方（Windows、Linux
    和 macOS）运行。
- en: ASP.NET Core is a free and open-source web framework, and the next generation
    of ASP.NET. It is a modular framework consisting of small packages of framework
    components that run on both the full .NET Framework, Windows, and the cross-platform
    .NET Core.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 是一个免费的开源 Web 框架，是 ASP.NET 的下一代。它是一个模块化框架，由运行在完整 .NET Framework、Windows
    和跨平台 .NET Core 上的小型框架组件包组成。
- en: The framework is a complete rewrite from the ground up. It unites the previously
    separate ASP.NET MVC and ASP.NET Web API into a single programming model.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架是从头开始完全重写的。它将之前分开的 ASP.NET MVC 和 ASP.NET Web API 统一成一个单一的编程模型。
- en: ASP.NET Web API has been built to map the web/HTTP programming model to the
    .NET Framework programming model. It uses familiar constructs, such as Controller,
    Action, Filter, and so on, which are used in ASP.NET MVC.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Web API 是为了将 Web/HTTP 编程模型映射到 .NET Framework 编程模型而构建的。它使用熟悉的结构，如 Controller、Action、Filter
    等，这些在 ASP.NET MVC 中使用。
- en: ASP.NET Web API is designed on top of the ASP.NET MVC runtime, along with some
    components that simplify HTTP programming. We can leverage Web API technology
    to perform actions on the server with .NET Framework; however, to be RESTful,
    we should adhere to the standards that we discussed earlier in this chapter. Fortunately,
    Web API automatically manages all the low-level transport details of HTTP while
    maintaining all the required constraints.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Web API 是在 ASP.NET MVC 运行时之上设计的，包括一些简化 HTTP 编程的组件。我们可以利用 Web API 技术在
    .NET Framework 上执行服务器端操作；然而，为了遵循 RESTful，我们应该遵守我们在本章前面讨论的标准。幸运的是，Web API 自动管理所有
    HTTP 的底层传输细节，同时保持所有必需的约束。
- en: 'Because of the uniformity that Web API provides, enforcing the RESTful principles,
    clients such as mobiles, web applications, the cloud, and so on can easily access
    it without any problem:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Web API 提供的统一性，强制执行 RESTful 原则，客户端（如移动设备、Web 应用程序、云等）可以轻松访问它而不会出现任何问题：
- en: '![](img/8c703ef2-d204-4aea-ae42-52884f2b364e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c703ef2-d204-4aea-ae42-52884f2b364e.png)'
- en: Prior to ASP.NET Core, MVC and Web API were different as they inherited `Controller`
    and `ApiController` classes respectively. On the other hand, in ASP.NET Core,
    they follow the same structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 之前，MVC 和 Web API 是不同的，因为它们分别继承了 `Controller` 和 `ApiController`
    类。另一方面，在 ASP.NET Core 中，它们遵循相同的结构。
- en: 'The following is the Solution Explorer view of both MVC and Web API. You can
    see that they have a similar structure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 MVC 和 Web API 的解决方案资源管理器视图。您可以看到，它们具有相似的结构：
- en: '![](img/8294820e-a200-4a3f-ac9a-0aa7ac67d764.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8294820e-a200-4a3f-ac9a-0aa7ac67d764.png)'
- en: 'The following is a controller that was automatically created when I clicked
    on File | New | Project | ASP.NET Core Web Application | Web API. You can see
    the base class of the controller is `Controller` instead of `ApiController`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在我点击 File | New | Project | ASP.NET Core Web Application | Web API 时自动创建的控制器。您可以看到，控制器的基类是
    `Controller` 而不是 `ApiController`：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Don't worry about codes now; we will discuss everything later in this book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不用担心代码了；我们将在本书的后面讨论所有这些内容。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: REST defines how to use the uniform interface through additional constraints,
    how to identify resources, how to manipulate resources through representations,
    and how to include metadata that makes messages self-describing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: REST 定义了如何通过额外的约束使用统一接口，如何识别资源，如何通过表示来操作资源，以及如何包含使消息自我描述的元数据。
- en: The web is built on HTTP’s uniform interface, and the focus is on interacting
    with resources and their representations. REST isn’t tied to any specific platform
    or technology; the web is the only major platform that fully embodies REST. The
    basic style of the architecture of RESTful web services is client–server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网建立在 HTTP 的统一接口之上，重点是交互资源和它们的表示。REST 与任何特定的平台或技术无关；互联网是唯一一个完全体现 REST 的主要平台。RESTful
    Web 服务的架构风格的基本风格是客户端-服务器。
- en: Here, the client requests a resource and the server processes and responds to
    the requested resource. The response of the server is user-based and platform-independent.
    The separation of concerns is the principle behind the client–server constraints.
    Because in client–server architecture, the storage and user interfaces are roles
    taken by the server and client respectively, it has improved portability of the
    user interface across multiple platforms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户端请求一个资源，服务器处理并响应所请求的资源。服务器的响应是基于用户和平台无关的。关注点的分离是客户端-服务器约束背后的原则。因为在客户端-服务器架构中，存储和用户界面是由服务器和客户端分别承担的角色，这提高了用户界面在多个平台上的可移植性。
- en: We should document every resource and URI for client developers. We can use
    any format for structuring our document, but it should contain enough information
    about resources, URIs, available methods, and any other information required for
    accessing the service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为客户端开发者记录下每一个资源和URI。我们可以使用任何格式来结构化我们的文档，但它应该包含足够关于资源、URI、可用方法以及访问服务所需的其他信息的描述。
- en: '*Swagger* is a tool that can be used for documentation purposes, and provides
    all the information regarding the API endpoints on one screen, where you can visualize
    the API and test it by sending parameters as well. Developers can use another
    tool called *Postman* for testing out APIs. Both of these tools will be explained
    with examples in the upcoming chapters of this book.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*Swagger* 是一个可以用于文档的工具，它在一个屏幕上提供了关于API端点的所有信息，你可以通过发送参数来可视化API并测试它。开发者可以使用另一个名为
    *Postman* 的工具来测试API。这两种工具将在本书的后续章节中通过示例进行解释。'
- en: ASP.NET Web API is a development environment constructed to develop RESTful
    web services that allow applications to send and receive HTTP requests (*web requests*) easily and
    perform operations based on the types of requests that are made to it (such as
    providing information about a user when given their ID, and so on).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Web API是一个开发环境，用于开发RESTful Web服务，允许应用程序轻松地发送和接收HTTP请求（*Web请求*），并根据对它提出的请求类型（如提供用户信息等）执行操作。
- en: Web API design in ASP.NET Core has been simplified following the same programming
    model as MVC.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core中的Web API设计遵循与MVC相同的编程模型而简化。
- en: In the next chapter, we will start coding by setting up the environment and
    look into the various fundamentals of the HTTP verbs in Web API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过设置环境和查看Web API中HTTP动词的各种基本原理来开始编码。
