- en: '*Chapter 2*: Implementing C# Interoperability'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：实现 C# 互操作性'
- en: This chapter is an optional chapter for those who would like to or need to use
    C# to interoperate with Excel, Python, C++, and **Visual Basic 6** (**VB6**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是针对那些希望或需要使用 C# 与 Excel、Python、C++ 和 **Visual Basic 6** (**VB6**) 进行互操作的用户的一个可选章节。
- en: Python has become a very popular programming language in recent months and is
    now a very big player in data science and machine learning. Since big data employs
    various technologies that are required to work with each other under various business
    scenarios, in this chapter, you will learn how to execute Python scripts and code
    from C#. You can also use IronPython.NET on the .NET platform, but since this
    book is for C# programmers, we will not be considering IronPython.NET in this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近几个月中，Python 已经成为一门非常流行的编程语言，现在在数据科学和机器学习领域扮演着非常重要的角色。由于大数据需要各种技术，这些技术需要在各种业务场景下相互协作，在本章中，您将学习如何从
    C# 中执行 Python 脚本和代码。您还可以在 .NET 平台上使用 IronPython.NET，但由于本书是为 C# 程序员编写的，因此我们不会在本章中考虑
    IronPython.NET。
- en: There are times when it is necessary to access libraries written in C++ – especially
    when performance is an issue, and you need that extra performance in advanced
    games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，访问用 C++ 编写的库是必要的——尤其是在性能是问题的时候，您需要额外的性能来开发高级游戏。
- en: In this chapter, you will learn about Microsoft .NET interoperability. It is
    advantageous to move your complete code base to a single code base that uses a
    familiar language that your whole development team is comfortable with using.
    But sometimes, to do this in one move is often not practical or cost-effective,
    or even safe. And that is where interoperability comes in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 Microsoft .NET 互操作性。将您的整个代码库迁移到使用您整个开发团队都熟悉的单一语言的代码库是有利的。但有时，一次性完成这一操作往往不切实际、成本效益低，甚至不安全。这就是互操作性的作用所在。
- en: In this chapter, you will learn how to interact with managed and unmanaged code.
    You will be looking at using unsafe code, unmanaged code with **Platform Invoke**
    (**P/Invoke**), COM interoperability, and disposing of unsafe code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何与托管和非托管代码进行交互。您将了解使用不安全代码、使用 **平台调用** (**P/Invoke**) 的非托管代码、COM 互操作性和处理不安全代码。
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using unmanaged code in C# does not always improve performance. Sometimes, it
    degrades it. But the logic of including this chapter within this book on high
    performance is to provide the knowledge and tools you will need to gradually replace
    your unmanaged code base with a managed code base. By doing so, all your developers
    only work with a single language and its supporting languages (in this case, C#).
    Your software can use the high-performing and highly scalable features of Azure
    or any other .NET cloud provider to build world-class cloud-based systems. The
    other advantage of doing this is that it makes code management and maintenance
    much easier.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中使用非托管代码并不总是能提高性能。有时，它甚至会降低性能。但将本章包含在这本关于高性能的书中，是为了提供您将需要了解的知识和工具，以逐步将您的非托管代码库替换为托管代码库。通过这样做，所有开发人员只需使用一种语言及其支持的语言（在这种情况下，是
    C#）。您的软件可以使用 Azure 或任何其他 .NET 云提供商的高性能和高度可扩展的功能来构建世界级的基于云的系统。这样做的好处之一是它使代码管理和维护变得更加容易。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Using unsafe code**: C# does a good job of shielding programmers from having
    to deal with pointers. But sometimes, it is necessary to use pointers to improve
    performance. Due to this, in this section, we will be looking at what unsafe code
    is and how to implement them.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不安全代码**：C# 有效地保护程序员免于处理指针。但有时，使用指针来提高性能是必要的。因此，在本节中，我们将探讨不安全代码是什么以及如何实现它们。'
- en: '**Exposing static entry points using Platform Invoke**: P/Invoke allows you
    to access code in unmanaged libraries from your managed C# code. In this section,
    we will learn how to access code that hasn''t been built using .NET.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用平台调用公开静态入口点**：P/Invoke 允许您从您的托管 C# 代码中访问未托管库中的代码。在本节中，我们将学习如何访问未使用 .NET
    构建的代码。'
- en: '**Performing COM interoperability**: In this section, we will learn how to
    make COM components and libraries visible for C# projects to use. We will also
    look at how to make our components and libraries visible to COM components to
    use.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行 COM 互操作性**：在本节中，我们将学习如何使 COM 组件和库对 C# 项目可见，以便使用。我们还将探讨如何使我们的组件和库对 COM
    组件可见，以便使用。'
- en: '**Safely disposing of unsafe code**: C# does a very good job of performing
    garbage collection to free up resources when code is finished with, but when you''re
    dealing with unmanaged code, you are responsible for cleaning up unmanaged resources.
    So, in this section, you will be shown how to do this.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全地处理不安全代码**：C# 在代码执行完毕后执行垃圾回收以释放资源方面做得非常好，但当您处理非托管代码时，您需要负责清理非托管资源。因此，在本节中，您将了解如何进行此操作。'
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够做到以下事项：
- en: Understand the use of unsafe code in C#
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 C# 中不安全代码的使用
- en: Call native code from managed code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从托管代码调用本地代码
- en: Use COM libraries and components in managed and unmanaged code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在托管和非托管代码中使用 COM 库和组件
- en: Release unsafe resources when they're no longer needed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不再需要时释放不安全资源
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, some of the code includes interoperability between C# managed
    assemblies and COM-based ActiveX UserControls, DLLs, and executables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，一些代码包括 C# 托管程序集与基于 COM 的 ActiveX 用户控件、DLL 和可执行文件之间的互操作性。
- en: 'To write the code and build the projects in this chapter, you will need the
    following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写本章的代码和构建项目，您需要以下内容：
- en: Visual Studio 2022
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: The latest x86 preview of .NET 6
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6 的最新 x86 预览版
- en: The latest x64 preview of .NET 6
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6 的最新 x64 预览版
- en: 'Optional: Visual C++'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：Visual C++
- en: 'Optional: Visual Studio Tools for Microsoft Office'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：Microsoft Office 的 Visual Studio 工具
- en: 'Optional: Visual Basic 6'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：Visual Basic 6
- en: 'The code files for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH02](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH02).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH02](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH02)。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although Visual Basic 6 is obsolete and no longer supported by Microsoft, it
    is still heavily used in production code within various businesses and sectors,
    such as automotive software providers and the education sector. Interoping with
    VB6 and .NET enables phased migrations from VB6 to .NET. By modernizing applications
    built with old technology, you can make them highly scalable across time zones
    using various cloud providers, such as Azure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Visual Basic 6 已过时，不再由 Microsoft 支持，但它仍然在各种业务和行业中的生产代码中被广泛使用，例如汽车软件提供商和教育行业。与
    VB6 和 .NET 的互操作使得从 VB6 到 .NET 的逐步迁移成为可能。通过现代化使用旧技术构建的应用程序，您可以使用各种云提供商（如 Azure）使它们在时区上具有高度的可扩展性。
- en: We will start this chapter by looking at unsafe code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看不安全代码。
- en: Using Platform Invocation (P/Invoke)
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台调用（P/Invoke）
- en: P/Invoke is a **Common Language Infrastructure** (**CLI**) feature that enables
    native code to be called by managed applications. Native code is not managed by
    the **Common Language Runtime** (**CLR**), so, the code's safety is firmly placed
    in the hands of the programmer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: P/Invoke 是 **通用语言基础设施**（**CLI**）的一个功能，它允许托管应用程序调用本地代码。本地代码不受 **通用语言运行时**（**CLR**）的管理，因此，代码的安全性牢牢掌握在程序员手中。
- en: In managed code, the garbage collector automatically cleans up objects in memory
    and is responsible for assigning generations to objects. We will cover the garbage
    collector in more detail in [*Chapter 4*](B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072),
    *Memory Management*. A new object always starts life as generation zero when it
    is less than 80,000 bytes in size and will be placed on the small object heap.
    Objects equal to or greater than 80,000 bytes in size are placed on the large
    object heap. Objects that survive generation zero get promoted by the garbage
    collector to generation one. Finally, objects that survive generation one get
    promoted to generation two.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管代码中，垃圾回收器自动清理内存中的对象，并负责为对象分配代数。我们将在 [*第 4 章*](B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072)，*内存管理*中更详细地介绍垃圾回收器。新对象在大小小于
    80,000 字节时总是以零代开始其生命周期，并将放置在小型对象堆上。大小等于或大于 80,000 字节的对象放置在大型对象堆上。在零代中存活的对象会被垃圾回收器提升到一代。最后，在一代中存活的对象会被提升到二代。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instantiated objects equal to or greater than 80,000 bytes may start as generation
    zero but be promoted, so they would not be seen as generation zero.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化对象的大小等于或大于 80,000 字节可能最初是零代，但可能会提升，因此它们不会被看作是零代。
- en: When an object is promoted from one generation to another by the garbage collector,
    its memory address changes. This breaks any pointers that refer to that address.
    To prevent the address from being modified by the garbage collector, the pointer
    code must be declared using the `fixed` keyword.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾回收器将对象从一个代提升到另一个代时，其内存地址会改变。这会破坏任何指向该地址的指针。为了防止垃圾回收器修改地址，必须使用`fixed`关键字声明指针代码。
- en: Now, let's look at using the `unsafe` and `fixed` keywords.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何使用`unsafe`和`fixed`关键字。
- en: Using unsafe and fixed code
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不安全和固定代码
- en: To remind the programmer of their responsibility for ensuring code safety, unmanaged
    code is wrapped in a code block marked as unsafe using the `unsafe` keyword. Unsafe
    code makes use of pointers to refer to locations in memory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒程序员确保代码安全性的责任，未管理代码被包裹在一个使用`unsafe`关键字标记的代码块中。不安全代码利用指针来引用内存中的位置。
- en: '**Unsafe code** provides programmers with access to pointer types in C#, which
    can be necessary when they''re working with the underlying operating system, system
    drivers, or working on time-critical code that needs to be executed in the smallest
    amount of time.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全代码**为程序员提供了访问C#中指针类型的权限，这在他们与底层操作系统、系统驱动程序或需要以最短时间执行的时间关键代码工作时是必要的。'
- en: Even though we say the code that deals with pointers is unsafe code, it is safe
    to work with. Such code is marked with the `unsafe` keyword. Despite being called
    unsafe, such code is safe to use in managed code – it is just not verified by
    the CLR. Therefore, it is possible to introduce security risks and/or pointer
    errors. You can have an unsafe `pointer_type`, `value_type`, or `reference_type`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们说处理指针的代码是不安全代码，但它是安全的。这样的代码用`unsafe`关键字标记。尽管被称为不安全，但这种代码在托管代码中是安全的——它只是没有经过CLR的验证。因此，可能会引入安全风险和/或指针错误。你可以有一个不安全的`pointer_type`、`value_type`或`reference_type`。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The topic of unsafe code is deep, so if you wish to learn more, please view
    the language specification that discusses unsafe code at https://docs.microsoft.com/dotnet/csharp/language-reference/language-specification/unsafe-code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全代码的主题很深，所以如果你想了解更多，请查看讨论不安全代码的语言规范，网址为https://docs.microsoft.com/dotnet/csharp/language-reference/language-specification/unsafe-code。
- en: In this section, we will write a console application that puts the various unsafe
    code mechanisms to work. You can view the project's source code at [https://github.com/PacktPublishing/C-9-and-.NET-5-High-Performance/tree/master/CH02/CH02_UnsafeCode](https://github.com/PacktPublishing/C-9-and-.NET-5-High-Performance/tree/master/CH02/CH02_UnsafeCode).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个控制台应用程序，将各种不安全代码机制付诸实践。你可以在[https://github.com/PacktPublishing/C-9-and-.NET-5-High-Performance/tree/master/CH02/CH02_UnsafeCode](https://github.com/PacktPublishing/C-9-and-.NET-5-High-Performance/tree/master/CH02/CH02_UnsafeCode)查看项目的源代码。
- en: 'Consider the following computer program:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下计算机程序：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, you can see that we allocate memory space for an array
    of five `int` values using the `new` keyword. We can do the same thing using unsafe
    code. But instead of using the `new` keyword, we can use `stackalloc` and wrap
    the code in a code block marked as `unsafe`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到我们使用`new`关键字为包含五个`int`值的数组分配内存空间。我们也可以使用不安全代码来完成同样的操作。但是，我们不是使用`new`关键字，而是使用`stackalloc`，并将代码包裹在一个标记为`unsafe`的代码块中。
- en: When dealing with unsafe code such as array pointers, it is necessary to use
    the `fixed` keyword. To understand why the `fixed` keyword is important, you need
    to understand garbage collection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理像数组指针这样的不安全代码时，使用`fixed`关键字是必要的。要理解为什么`fixed`关键字很重要，你需要了解垃圾回收。
- en: When objects are created, they are generation-zero objects. The garbage collector
    will remove any unreferenced generation one objects. If the space for allocating
    generation zero objects becomes full, the garbage collector moves the generation
    zero objects to generation one. Then, new objects can be added to generation zero.
    If the generation one and generation two objects become full, and all the objects
    are in use, then the garbage collector moves the generation one objects to generation
    two. This, in turn, moves the generation zero objects to generation one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被创建时，它们是零代对象。垃圾回收器将删除任何未引用的一代对象。如果分配零代对象的空間变满，垃圾回收器会将零代对象移动到一代。然后，新的对象可以添加到零代。如果一代和二代对象变满，并且所有对象都在使用中，那么垃圾回收器会将一代对象移动到二代。这反过来又会将零代对象移动到一代。
- en: 'New objects are then added to generation zero. At this point, if the generation
    two, generation one, and generation zero storage spaces are full, which means
    that no new objects can be added, then you end up with an out-of-memory exception.
    The following diagram shows this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 新对象随后被添加到零代。此时，如果第二代、第一代和零代存储空间已满，这意味着无法添加新对象，那么你最终会得到一个内存不足异常。以下图表显示了这一点：
- en: '![Figure 2.1 – Garbage collection management of object generations'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Garbage collection management of object generations](img/Figure_2.1_B16617.jpg)'
- en: '](img/Figure_2.1_B16617.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Garbage collection management of object generations](img/Figure_2.1_B16617.jpg)'
- en: Figure 2.1 – Garbage collection management of object generations
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 对象代际的垃圾回收管理
- en: Since the garbage collector is moving the items from one generation to another,
    the memory locations change. However, the pointers to those objects in your code
    do not change. Therefore, when retrieving the information from the pointer address,
    the data will be incorrect.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于垃圾回收器正在将项目从一个代际移动到另一个代际，内存位置会发生变化。然而，代码中指向这些对象的指针不会改变。因此，当从指针地址检索信息时，数据将是错误的。
- en: 'To prevent this from happening, we can use the `fixed` keyword. The `fixed`
    keyword tells the garbage collector to leave the address space that `arrayPointer`
    is pointing to alone. This means that we can ensure that the pointer will be pointing
    to the correct address space and data. The following code shows the `unsafe` and
    `fixed` keywords being used to deal with an array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们可以使用 `fixed` 关键字。`fixed` 关键字告诉垃圾回收器不要单独处理 `arrayPointer` 指向的地址空间。这意味着我们可以确保指针将指向正确的地址空间和数据。以下代码展示了如何使用
    `unsafe` 和 `fixed` 关键字来处理数组：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, because we are using unsafe code, we used an `unsafe`
    code block. Since we don't want the array to be affected by the garbage collector,
    we kept the object at its current generation by using the `fixed` code block.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，因为我们使用了不安全代码，所以我们使用了 `unsafe` 代码块。由于我们不希望数组受到垃圾回收器的影响，我们通过使用 `fixed`
    代码块来保持对象在其当前代际。
- en: 'One caveat you need to be aware of when using unsafe code is the effect of
    accessing an array that''s out of bounds. When you access an array that''s out
    of bounds in managed code, you are presented with `IndexOutOfBoundsException`.
    You do not have that luxury with unmanaged code. You are responsible for ensuring
    that the correct indexes are accessed. If you happen to access an index that is
    outside the bounds of the array, then you will not have `IndexOutOfBoundsException`
    thrown. Instead, you will have whatever is at that memory address returned to
    you. In that case, you may or may not end up with some type of exception being
    thrown. The following code demonstrates this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不安全代码时，你必须注意访问超出范围的数组的影响。在托管代码中访问超出范围的数组时，你会得到 `IndexOutOfBoundsException`。在非托管代码中，你没有这样的奢侈。你必须确保访问正确的索引。如果你意外地访问了数组范围之外的索引，那么你将不会抛出
    `IndexOutOfBoundsException`。相反，你会得到该内存地址上的任何内容返回给你。在这种情况下，你可能或可能不会抛出某种类型的异常。以下代码演示了这一点：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the array is added to the stack. The value of the array at position `99`
    is correct, but the array position of `100` is out of bounds, so an incorrect
    value is returned. This means that `IndexOutOfBoundsException` is thrown. That
    is why you must be careful with unmanaged code when dealing with indexes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数组被添加到栈上。数组在位置 `99` 的值是正确的，但数组位置 `100` 超出了范围，因此返回了一个错误值。这意味着会抛出 `IndexOutOfBoundsException`。这就是为什么在处理索引时必须小心处理非托管代码。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason for the `unsafe` keyword is to alert the programmer to their responsibility
    for code safety. When dealing with pointers, runtime exceptions aren't raised.
    Instead, whatever is at that memory location is returned. That's why you must
    take extra care when programming unsafe code. You must also use the `fixed` keyword
    when you can't afford for the garbage collector to switch the generations of your
    objects and move them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe` 关键字的原因是提醒程序员对代码安全性负责。在处理指针时，不会引发运行时异常。相反，返回该内存位置上的任何内容。这就是为什么在编写不安全代码时必须格外小心。当无法承受垃圾回收器切换对象代际并移动它们时，你也必须使用
    `fixed` 关键字。'
- en: In C#, you can only use structs and primitives with unsafe and fixed code. Classes
    and strings that access the heap are not allowed. This means that nothing that
    will be garbage collected can be referenced using unsafe code. So, when using
    C# pointers, you can use value types, but you cannot use reference types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，您只能使用具有 unsafe 和 fixed 代码的结构体和原始类型。不允许访问堆的类和字符串。这意味着任何将被垃圾回收的内容都不能使用
    unsafe 代码引用。因此，当使用 C# 指针时，您可以使用值类型，但不能使用引用类型。
- en: 'For example, the following code will not compile:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将无法编译：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `testObject` variable is a reference type pointer, so the compiler throws
    an exception if you build the code. This code returns the following exception:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`testObject` 变量是一个引用类型指针，如果构建代码，编译器会抛出异常。此代码返回以下异常：'
- en: '`CS0208`: Cannot take the address of, get the size of, or declare a pointer
    to a managed type (`''TestObject''`)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CS0208`：无法获取托管类型（`''TestObject''`）的地址、大小或声明指针'
- en: 'The `text` variable is a string pointer, and the compiler throws an exception
    if you build the code. This code returns the following exception:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 变量是一个字符串指针，如果构建代码，编译器会抛出异常。此代码返回以下异常：'
- en: '`CS0208`: Cannot take the address of, get the size of, or declare a pointer
    to a managed type (`''string''`)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CS0208`：无法获取托管类型（`''string''`）的地址、大小或声明指针'
- en: Note
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Using fixed objects can result in memory fragmentation. So, avoid using the
    `fixed` keyword until you need to, and only use it for as long as you need it.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用固定对象可能会导致内存碎片化。因此，除非您真的需要，否则请避免使用 `fixed` 关键字，并且只使用您需要的最长时间。
- en: Now, let's look at exposing static entry points using P/Invoke.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 P/Invoke 暴露静态入口点。
- en: Exposing static entry points using P/Invoke
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 P/Invoke 暴露静态入口点
- en: P/Invoke allows you to make static entry points available to other applications.
    If you have ever used WinAPI, then you have accessed code in DLLs via their public
    static entry points. These access points would have been made available using
    P/Invoke.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: P/Invoke 允许您使静态入口点对其他应用程序可用。如果您曾经使用过 WinAPI，那么您已经通过它们的公共静态入口点访问了 DLL 中的代码。这些访问点是通过
    P/Invoke 提供的。
- en: 'To use P/Invoke, you will need to import the `System.Runtime.InteropServices`
    namespace. Then, you must make the static entry call using `DllImportAttribute`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 P/Invoke，您需要导入 `System.Runtime.InteropServices` 命名空间。然后，您必须使用 `DllImportAttribute`
    来进行静态入口调用：
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To identify the static entry points of a file, you can use the `dumpbin.exe`
    file that's located in the `C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\VC\Tools\MSVC\14.28.29115\bin\Hostx64\x64`
    folder. This version of 14.28.29.115 was correct at the time of writing. When
    you come to execute the following code, this version will have changed. Use the
    latest version that you have installed on your computer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别文件的静态入口点，您可以使用位于 `C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\VC\Tools\MSVC\14.28.29115\bin\Hostx64\x64`
    文件夹中的 `dumpbin.exe` 文件。在写作时，14.28.29.115 版本正确。当您执行以下代码时，此版本将已更改。使用您在电脑上安装的最新版本。
- en: 'Now, let''s learn how to use `dumpbin` to see what methods and properties the
    `User32.dll` system library exports using the command line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 `dumpbin` 通过命令行查看 `User32.dll` 系统库导出的方法和属性：
- en: 'Open the command line or developer command prompt. Then, enter the following
    command (note that there might be a different version on your computer – use the
    latest version number you have):'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行或开发者命令提示符。然后，输入以下命令（注意，您电脑上可能版本不同——使用您拥有的最新版本号）：
- en: '[PRE34]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see something like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下类似的内容：
- en: '![Figure 2.2 – Command line showing the outcome from executing dumpbin on User32.dll'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 命令行显示在 User32.dll 上执行 dumpbin 的结果'
- en: '](img/Figure_2.2_B16617.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.2_B16617.jpg)'
- en: Figure 2.2 – Command line showing the outcome from executing dumpbin on User32.dll
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 命令行显示在 User32.dll 上执行 dumpbin 的结果
- en: 'Let''s write a C++ library and call it from C# using P/Invoke. First, we must
    create a new empty C++ project, as shown in the following screenshot:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个 C++ 库，并将其命名为 `Product`，然后从 C# 使用 P/Invoke 调用它。首先，我们必须创建一个新的空 C++ 项目，如下截图所示：
- en: '![Figure 2.3 – Creating a new empty C++ project'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 创建一个新的空 C++ 项目'
- en: '](img/Figure_2.3_B16617.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B16617.jpg)'
- en: Figure 2.3 – Creating a new empty C++ project
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 创建一个新的空 C++ 项目
- en: Delete the `Header Files`, `Resource File`, and `Source Files` folders. Add
    a new class called `Product`. Delete the header file that has the `.h` file extension.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `Header Files`、`Resource File` 和 `Source Files` 文件夹。添加一个名为 `Product` 的新类。删除具有
    `.h` 文件扩展名的头文件。
- en: 'Modify the `Product.cpp` file so that it contains the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Product.cpp` 文件，使其包含以下代码：
- en: '[PRE35]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we must import three libraries: `string`, `iostream`, and `comdef.h`.
    Then, we must declare a struct with `Id` and `Name` values. In C++, strings are
    typically defined using `std::string`, but when it comes to.NET, we declare strings
    as the BSTR type for OLE/automation by convention. The BSTR APIs use the `CoTask*`
    memory allocator, which is the implied interop contract for native on Windows.
    On non-Windows systems, .NET 5 uses `malloc`/`free`. We also have a void method
    called `BuyProduct()` that prints the `Id` and `Name` values as well as a newline,
    to the console''s output window.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须导入三个库：`string`、`iostream` 和 `comdef.h`。然后，我们必须声明一个包含 `Id` 和 `Name` 值的结构体。在
    C++ 中，字符串通常使用 `std::string` 定义，但在 .NET 中，我们按照惯例将字符串声明为 OLE/自动化中的 BSTR 类型。BSTR
    API 使用 `CoTask*` 内存分配器，这是 Windows 上本机隐含的互操作性合同。在非 Windows 系统上，.NET 5 使用 `malloc`/`free`。我们还有一个名为
    `BuyProduct()` 的 void 方法，它将 `Id` 和 `Name` 值以及换行符打印到控制台输出窗口。
- en: The next thing we must do is export two methods called `CreateProduct()` and
    `BuyProduct(Product product)`. Now, `CreateProduct()` creates a new `Product`
    and returns it to the caller, while `BuyProduct(Product product)` calls the `BuyProduct()`
    method on the passed-in `Product` struct.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来必须导出两个方法，分别命名为 `CreateProduct()` 和 `BuyProduct(Product product)`。现在，`CreateProduct()`
    方法创建一个新的 `Product` 对象并将其返回给调用者，而 `BuyProduct(Product product)` 方法则调用传入的 `Product`
    结构体的 `BuyProduct()` 方法。
- en: 'Add a new class called `Greeting`. Delete the `Greeting.h` file. Update the
    `Greeting.cpp` file so that it contains the following source code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Greeting` 的新类。删除 `Greeting.h` 文件。更新 `Greeting.cpp` 文件，使其包含以下源代码：
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have included `iostream` and `comdef.h`. We have four methods called
    `SendGreeting()`, `Add(int x, int y)`, `IsLengthGreaterThan5(const char* value)`,
    and `GetName()`. We expose these methods to external callers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了 `iostream` 和 `comdef.h`。我们有四个方法：`SendGreeting()`、`Add(int x, int y)`、`IsLengthGreaterThan5(const
    char* value)` 和 `GetName()`。我们将这些方法暴露给外部调用者。
- en: '`SendGreeting()` takes no parameters and outputs a string to the standard output
    window. `Add(int x, int y)` adds to integers passed in by the caller and returns
    the result. `IsLengthGreaterThan5(const char* value)` checks if the length of
    the string that''s been passed in by the caller is greater than `5`. If it is,
    then `true` is returned. Otherwise, `false` is returned. `GetName()` returns a
    string. The return type for a string must be `BSTR`. To return a string in a method,
    you must call `SysAllocString(L"the string you want returning")`. This correctly
    initializes the string to a wide-character array and initializes the count.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendGreeting()` 不接受任何参数，并将字符串输出到标准输出窗口。`Add(int x, int y)` 将调用者传入的两个整数相加并返回结果。`IsLengthGreaterThan5(const
    char* value)` 检查调用者传入的字符串的长度是否大于 `5`。如果是，则返回 `true`。否则，返回 `false`。`GetName()`
    返回一个字符串。字符串的返回类型必须是 `BSTR`。要在方法中返回字符串，必须调用 `SysAllocString(L"the string you want
    returning")`。这将正确地将字符串初始化为宽字符数组并初始化计数。'
- en: 'That is all there is to our C++ library. Now, we just need to configure it.
    But before we do that, we will write our C# client, which will consume the C++
    library. The reason for doing this is that once we have the build folder for our
    C# client, we will get our C++ library to output the DLL to the C# build folder.
    Follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 C++ 库的全部内容。现在，我们只需要配置它。但在做之前，我们将编写我们的 C# 客户端，该客户端将使用 C++ 库。这样做的原因是，一旦我们有了
    C# 客户端的构建文件夹，我们就会将 C++ 库输出的 DLL 文件放入 C# 构建文件夹中。按照以下步骤操作：
- en: 'Add a new .NET Core 3.1 console application project to your solution, and then
    set it as the startup project. Add a class called `Product`. Update the contents
    of the `Product.cs` file, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的解决方案中添加一个新的 .NET Core 3.1 控制台应用程序项目，并将其设置为启动项目。添加一个名为 `Product` 的类。更新 `Product.cs`
    文件的内容，如下所示：
- en: '[PRE37]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we have created a mirror of the C++ struct in our C# client and included
    the `System.Runtime.InteropServices` library. Our C# struct has the same two fields
    as our C++ struct and they are in the same order. The struct itself is annotated
    with `[StructLayout(LayoutKind.Sequential)]`, which states that the field order
    must be processed sequentially. This ensures a match between the fields in the
    C++ library and the fields in the C# library. Additionally, the `Name` property
    is a string, so it needs to be annotated with the `[MarshalAs(UnmanagedType.Bstr)]`
    annotation. This tells the compiler that the C# string is to be treated as a C++
    BSTR.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经在我们的 C# 客户端中创建了一个 C++ 结构的镜像，并包含了 `System.Runtime.InteropServices` 库。我们的
    C# 结构与我们的 C++ 结构具有相同的两个字段，并且它们的顺序相同。结构本身使用 `[StructLayout(LayoutKind.Sequential)]`
    进行了注释，这表示字段顺序必须按顺序处理。这确保了 C++ 库中的字段与 C# 库中的字段相匹配。此外，`Name` 属性是一个字符串，因此需要使用 `[MarshalAs(UnmanagedType.Bstr)]`
    注释。这告诉编译器将 C# 字符串视为 C++ BSTR。
- en: 'Modify the `Program.cs` file, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改 `Program.cs` 文件：
- en: '[PRE38]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we imported the `System` and `System.Runtime.InteropServices` libraries,
    and then modified the `Main(string[] args)` method by replacing the `args` parameter's
    name with the default operator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了 `System` 和 `System.Runtime.InteropServices` 库，然后通过将 `args` 参数的名称替换为默认操作符来修改
    `Main(string[] args)` 方法。
- en: Set the build configuration to x64.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建配置设置为 x64。
- en: 'Append the following line to the `PropertyGroup` section of your C++ project
    file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到你的 C++ 项目文件的 `PropertyGroup` 部分：
- en: '[PRE39]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Build the project. This will produce our output folder where we will place our
    compiled C++ library.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。这将生成我们的输出文件夹，我们将在此处放置编译后的 C++ 库。
- en: 'Right-click on the C++ project and select **Properties**. You should see the
    **CH02_NativeLibrary Property Pages** dialog box:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 C++ 项目并选择 **属性**。你应该会看到 **CH02_NativeLibrary 属性页** 对话框：
- en: '![Figure 2.4 – CH02_NativeLibrary Property Pages'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – CH02_NativeLibrary 属性页'
- en: '](img/Figure_2.4_B16617.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.4_B16617.jpg)'
- en: Figure 2.4 – CH02_NativeLibrary Property Pages
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – CH02_NativeLibrary 属性页
- en: Change **Output Directory** to your C# project's output directory. Then, change
    **Configuration Type** to **Dynamic Library (.dll)**. Build the C++ library.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **输出目录** 更改为你的 C# 项目的输出目录。然后，将 **配置类型** 更改为 **动态库 (.dll)**。构建 C++ 库。
- en: Back in your C# project, add the COM library by browsing for it in your C# build
    folder.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 C# 项目中，通过在 C# 构建文件夹中浏览来添加 COM 库。
- en: 'Add the following DLL imports to the `Program` class, above the `Main` method:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，在 `Main` 方法之上添加以下 DLL 导入：
- en: '[PRE40]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These `DllImport` statements make our `CH02_NativeLibrary.dll` methods available
    to C#. Update the `Main` method, as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些 `DllImport` 语句使我们的 `CH02_NativeLibrary.dll` 方法对 C# 可用。按照以下方式更新 `Main` 方法：
- en: '[PRE41]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our `Main` method calls the methods that were imported from our `CH02_NativeLibrary.dll`
    binary. We pass values in and receive values and structures back.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Main` 方法调用从我们的 `CH02_NativeLibrary.dll` 二进制文件中导入的方法。我们传递值并接收值和结构返回。
- en: Now that you know what unsafe and fixed code is, let's learn how to interact
    with Python code in C#.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了什么是非安全代码和固定代码，让我们学习如何在 C# 中与 Python 代码交互。
- en: Interacting with Python code
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Python 代码交互
- en: Python is one of the world's top programming languages and is a favorite of
    data scientists and programmers working in the field of artificial intelligence
    and machine learning. Automation of day-to-day mundane infrastructure tasks has
    been carried out by infrastructure professionals using the Python programming
    language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是世界上最顶尖的编程语言之一，是数据科学家和人工智能与机器学习领域的程序员的宠儿。基础设施专业人员使用 Python 编程语言自动化日常的平凡基础设施任务。
- en: Python code has been designed in such a way that programmers can code tasks
    quicker than they can in C#. So, the programming writing experience in Python
    can be quicker than in C#. Some programmers state that Python can be more readable
    than C#, although I find C# easier to read and understand when compared to Python.
    This means that readability is rather subjective, but more programmers create
    programs in Python than they do in C#.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码的设计使得程序员可以比在 C# 中更快地编码任务。因此，Python 的编程编写体验可能比 C# 更快。一些程序员表示，Python
    可能比 C# 更易读，尽管我认为与 Python 相比，C# 更容易阅读和理解。这意味着可读性相当主观，但使用 Python 编写程序的程序员比使用 C#
    的更多。
- en: C# beats Python when it comes to compiled code performance. Python can be quicker
    to write but requires a lot of testing and its garbage collector and interpreter
    can affect the performance of Python applications. C# uses JIT, AOT, and Ngen,
    which are also available to VB.NET, C#, F#, and other .NET languages, to perform
    various types of compilation. The result is that C# produces native code on the
    target machine, thus providing much faster-executing code than Python. And with
    the advent of further performance improvements being added to .NET 5 and C# 9.0
    by Microsoft, C# will be even faster than it was in its previous versions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译代码性能方面，C# 优于 Python。Python 可以更快地编写，但需要大量的测试，其垃圾回收器和解释器可能会影响 Python 应用程序的性能。C#
    使用 JIT、AOT 和 Ngen，这些技术也适用于 VB.NET、C#、F# 和其他 .NET 语言，以执行各种类型的编译。结果是，C# 在目标机器上生成原生代码，从而提供比
    Python 更快的执行代码。随着 Microsoft 为 .NET 5 和 C# 9.0 添加更多性能改进，C# 将比之前的版本更快。
- en: With so much good work being accomplished in the Python arena, it is good for
    C# programmers to be able to capitalize on Python by using Python code from C#.
    At the same time, some companies are striving to have all their code in a single
    code base, so they want to move away from languages such as Java and Python and
    become fully C#-oriented. Another advantage of moving the existing Python code
    over to C# is that the same tasks will be much faster in C# than they are in Python.
    The first step in being able to move away from Python to C# is to be able to use
    the existing Python code within the C# programming language.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 领域取得如此多的成就之后，对于 C# 程序员来说，能够通过在 C# 中使用 Python 代码来利用 Python 是很有好处的。同时，一些公司正努力将所有代码放在单个代码库中，因此他们希望摆脱
    Java 和 Python 等语言，完全转向 C#。将现有的 Python 代码迁移到 C# 的另一个优点是，相同的任务在 C# 中的执行速度将比在 Python
    中快得多。从 Python 迁移到 C# 的第一步是能够在 C# 编程语言中使用现有的 Python 代码。
- en: 'In this section, you will learn how to execute Python code inside C#. You will
    also learn how to call and execute an external Python script. Follow these steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在 C# 中执行 Python 代码。您还将学习如何调用和执行外部 Python 脚本。按照以下步骤操作：
- en: First, make sure you add the Python payload from within Visual Studio Installer
    and add Python to your `PATH` environment variable.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请确保您在 Visual Studio 安装程序中添加了 Python 负载，并将 Python 添加到您的 `PATH` 环境变量中。
- en: 'Start a new .NET Core 3.1 console application. Then, add the `IronPython` NuGet
    package. This will only work with Python 2.x code. If you require Python 3.x support,
    then use Python.NET, which is available at http//pythonnet.github.io. You will
    need the following `using` statements:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 .NET Core 3.1 控制台应用程序。然后，添加 `IronPython` NuGet 包。这仅适用于 Python 2.x 代码。如果您需要
    Python 3.x 支持，则使用 Python.NET，可在 http//pythonnet.github.io 获取。您需要以下 `using` 语句：
- en: '[PRE42]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We need `System` because we will be outputting text to the console window. The
    `IronPython.Hosting` library is needed to host and execute Python code in C#.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `System`，因为我们将在控制台窗口中输出文本。需要 `IronPython.Hosting` 库来在 C# 中托管和执行 Python
    代码。
- en: 'Add a file called `welcome.py` to the project, set it to `Copy` always, and
    add the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `welcome.py` 的文件添加到项目中，将其设置为始终 `Copy`，并添加以下代码：
- en: '[PRE43]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This Python code will print out the text to our console window. Add the following
    code to the `Main` method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此 Python 代码将在我们的控制台窗口中打印出文本。将以下代码添加到 `Main` 方法中：
- en: '[PRE44]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we are prompting the user to input some text. Then, we read the line of
    text the user enters. A variable is created that can be used to execute Python
    code. A `try`/`catch`/`finally` block is then used to execute the Python code.
    First, we execute pure Python code directly from within C#. Then, we execute the
    code that was executed in our Python script. Any exceptions are caught with the
    exception message that was written to the console window. Finally, we wait for
    the user to press any key before we exit.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在提示用户输入一些文本。然后，我们读取用户输入的文本行。创建一个变量，可以用来执行 Python 代码。然后使用 `try`/`catch`/`finally`
    块来执行 Python 代码。首先，我们从 C# 中直接执行纯 Python 代码。然后，我们执行在 Python 脚本中执行的代码。任何异常都会捕获到写入控制台窗口的异常消息。最后，我们在退出之前等待用户按下任意键。
- en: And that is all there is to executing Python code directly within C# and via
    external Python scripts. Now, let's learn the COM interface.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是直接在 C# 中执行 Python 代码以及通过外部 Python 脚本执行的全部内容。现在，让我们学习 COM 接口。
- en: Performing Component Object Model (COM) interoperability
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行组件对象模型 (COM) 互操作性
- en: The **Component Object Model** (**COM**) is an interface standard that was introduced
    by Microsoft in 1993\. It enables components written in the same or different
    languages to communicate with each other, and COM components can pass data between
    each other. Communication is accomplished through **Inter-Process Communication**
    (**IPC**) and dynamic object creation. COM is not a programming language; it provides
    a software architecture that consists of binary and network standards.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件对象模型** (**COM**) 是微软在 1993 年引入的一个接口标准。它使得用相同或不同语言编写的组件能够相互通信，并且 COM 组件可以在彼此之间传递数据。通信是通过
    **进程间通信** (**IPC**) 和动态对象创建来完成的。COM 不是一个编程语言；它提供了一个由二进制和网络标准组成的软件架构。'
- en: Many business employees use spreadsheets because they are an easy way to combine
    and manipulate data for various reasons. Spreadsheets are also the perfect tools
    for statistical analysis. Many companies expand the power of spreadsheets by building
    useful add-ons using C# and other languages. But spreadsheets are also useful
    for ingesting data into databases for day-to-day operations and reporting purposes.
    In this section, you will learn how to create and manipulate spreadsheets in C#,
    as well as write C# plugins for Excel.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业员工使用工作表，因为它们是结合和操作数据的简单方式，出于各种原因。工作表也是统计分析的完美工具。许多公司通过使用 C# 和其他语言构建有用的附加组件来扩展工作表的功能。但工作表对于将数据摄入数据库以进行日常操作和报告目的也是很有用的。在本节中，你将学习如何使用
    C# 创建和操作工作表，以及编写 Excel 插件。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Visual Studio Tools for Office** (**VSTO**) is only available in .NET 4.8
    and below. It will not work in C# 9 and .NET 5.0\. Due to this, we will perform
    C# interoperability using .NET 4.8\. Microsoft has moved away from VSTO and the
    COM model to focus on the cross-platform extensibility of Excel using JavaScript.
    Since this book is on C#, we will focus on VSTO in .NET 4.8\. To find out more
    about Microsoft Office extensibility using the JavaScript API, please read the
    following documentation: [https://docs.microsoft.com/office/dev/add-ins/develop/understanding-the-javascript-api-for-office](https://docs.microsoft.com/office/dev/add-ins/develop/understanding-the-javascript-api-for-office).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Tools for Office** (**VSTO**) 仅在 .NET 4.8 及以下版本中可用。它将不支持 C#
    9 和 .NET 5.0。因此，我们将使用 .NET 4.8 进行 C# 互操作性。由于微软已经从 VSTO 和 COM 模型转向使用 JavaScript
    进行 Excel 的跨平台扩展，因此我们将专注于 .NET 4.8 中的 VSTO。要了解更多关于使用 JavaScript API 扩展 Microsoft
    Office 的信息，请阅读以下文档：[https://docs.microsoft.com/office/dev/add-ins/develop/understanding-the-javascript-api-for-office](https://docs.microsoft.com/office/dev/add-ins/develop/understanding-the-javascript-api-for-office)。'
- en: In this section, we will provide two demonstrations. The first demonstration
    will read data from an existing spreadsheet. It is useful to know how to do this
    as there is often a business need for programmers to work with spreadsheet data.
    After that, we will add an Excel VSTO add-in for Excel. It can be very useful
    to provide add-ins to end users that make their work more expedient and enjoyable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供两个演示。第一个演示将从现有工作表中读取数据。了解如何做这一点是有用的，因为程序员经常有与工作表数据一起工作的业务需求。之后，我们将添加一个
    Excel VSTO 扩展程序。为最终用户提供扩展程序，使他们的工作更加便捷和愉快是非常有用的。
- en: Reading data from an Excel spreadsheet
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Excel 工作表中读取数据
- en: 'In this section, we are going to write a small program to read an Excel file,
    count the number of lines, and then update the Excel spreadsheet with the used
    line count from within C#. Follow these steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个小程序来读取 Excel 文件，计算行数，然后使用 C# 从内部更新 Excel 工作表中的使用行数。请按照以下步骤操作：
- en: Add a folder called `C:\Temp`. Then, create a new spreadsheet in it called `LineCount.xlsx`.
    Add 10 rows of text in the first column. Save and close the spreadsheet.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `C:\Temp` 中添加一个名为 `C:\Temp` 的文件夹。然后，在该文件夹中创建一个新的工作表，命名为 `LineCount.xlsx`。在第一列中添加
    10 行文本。保存并关闭工作表。
- en: 'Add a new .NET 4.8 console application. Add the following reference using the
    NuGet package manager to install the latest versions:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 .NET 4.8 控制台应用程序。使用 NuGet 包管理器添加以下引用以安装最新版本：
- en: '[PRE45]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following namespaces to the `Program` class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命名空间添加到 `Program` 类中：
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With that, we can interact with Excel from C#. Now, modify the `Main` method,
    as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样，我们就可以从 C# 与 Excel 进行交互。现在，修改 `Main` 方法，如下所示：
- en: '[PRE47]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code creates a new Excel application. The workbook we created
    and modified earlier on is opened. At this point, we can obtain the actively used
    range on the active sheet and the count of how many rows there are. The count
    is then saved on a new row, after which we can close the workbook and quit Excel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个新的 Excel 应用程序。我们之前创建和修改的工作簿已打开。此时，我们可以获取活动工作表上正在使用的范围以及行数。然后将计数保存在新行上，之后我们可以关闭工作簿并退出
    Excel。
- en: 'Run the code as many times as you like and then open the spreadsheet. You should
    see something similar to the following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码可以运行多次，然后打开电子表格。你应该会看到以下类似的内容：
- en: '![Figure 2.5 – Excel showing rows added by C#'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.5 – Excel showing rows added by C#'
- en: '](img/Figure_2.5_B16617.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B16617.jpg)'
- en: Figure 2.5 – Excel showing rows added by C#
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Excel 显示由 C# 添加的行
- en: As you can see, working with Excel files is straightforward.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与 Excel 文件一起工作很简单。
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The most performant way to populate an Excel spreadsheet from a database result
    set is to use `Worksheet.Range.CopyFromRecordset(Object, Object, Object)`. See
    the official Microsoft documentation at [https://docs.microsoft.com/dotnet/api/microsoft.office.interop.excel.range.copyfromrecordset?view=excel-pia](https://docs.microsoft.com/dotnet/api/microsoft.office.interop.excel.range.copyfromrecordset?view=excel-pia).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库结果集填充 Excel 工作表的最高效方式是使用 `Worksheet.Range.CopyFromRecordset(Object, Object,
    Object)`。请参阅官方 Microsoft 文档 [https://docs.microsoft.com/dotnet/api/microsoft.office.interop.excel.range.copyfromrecordset?view=excel-pia](https://docs.microsoft.com/dotnet/api/microsoft.office.interop.excel.range.copyfromrecordset?view=excel-pia)。
- en: Now, let's create an Excel add-in.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 Excel 外接程序。
- en: Creating an Excel add-in
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Excel 外接程序
- en: 'What does creating an Excel add-in have to do with.NET high performance? Well,
    VSTO performance can be improved by implementing the following strategies:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Excel 外接程序与 .NET 高性能有什么关系？嗯，通过实施以下策略可以提高 VSTO 的性能：
- en: Load VSTO add-ins on demand.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需加载 VSTO 外接程序。
- en: Publish Office solutions by using Windows Installer.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Windows Installer 发布 Office 解决方案。
- en: Bypass Ribbon reflection.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过功能区反射。
- en: Perform expensive operations in a separate thread.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的线程中执行昂贵的操作。
- en: 'In this section, we are going to write an Excel add-in that will appear on
    the **Add-ins** tab within Excel. When the button is clicked, it will read the
    text in the currently selected cell and display the contents in a message box.
    Follow these steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个 Excel 外接程序，该程序将出现在 Excel 的 **外接程序** 选项卡中。当按钮被点击时，它将读取当前选中单元格中的文本，并在消息框中显示内容。按照以下步骤操作：
- en: Create a new Excel VSTO add-in project. This will target .NET 4.8\. You cannot
    use VSTO with .NET 5.0.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Excel VSTO 外接程序项目。这将针对 .NET 4.8。您不能使用 VSTO 与 .NET 5.0。
- en: Add a new Ribbon (Visual Designer) and call it `CsRibbonExtension`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的功能区（Visual Designer）并命名为 `CsRibbonExtension`。
- en: Rename `group1` to `CsGroup` and change the label to `C# Group`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `group1` 重命名为 `CsGroup` 并将标签更改为 `C# Group`。
- en: Add a button to `CsGroup`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `CsGroup` 添加一个按钮。
- en: Change the button's name to `GetCellValueButton` and change its label to `Get
    Cell Value`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的名称更改为 `GetCellValueButton` 并将其标签更改为 `Get Cell Value`。
- en: 'Double-click the button to generate the click event. Update the click event
    like so:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击按钮以生成点击事件。更新点击事件如下：
- en: '[PRE48]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In our click event, we save the current language and then change it to American
    English. Then, we obtain the active cell. The `Value2` property is a dynamic type.
    We check if the value for the active cell is null. If the cell is not null, then
    we display the active cell's value in a message box. Finally, we return the language
    to its original language.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的点击事件中，我们保存当前语言并将其更改为美式英语。然后，我们获取活动单元格。`Value2` 属性是动态类型。我们检查活动单元格的值是否为 null。如果单元格不是
    null，则我们在消息框中显示活动单元格的值。最后，我们将语言恢复到其原始语言。
- en: Build the project.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: Then, press F5 to deploy the solution.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按 F5 部署解决方案。
- en: Open Excel and start a blank workbook.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Excel 并创建一个新的空白工作簿。
- en: 'On the ribbon, if the **Add-ins** tab is not visible, click on **Customize
    Quick Access Toolbar** and then **More Commands…** to bring up the **Excel Options**
    dialog, as shown in the following screenshot:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在功能区上，如果 **外接程序** 选项卡不可见，请单击 **自定义快速访问工具栏**，然后单击 **更多命令…** 以打开 **Excel 选项**
    对话框，如以下截图所示：
- en: '![Figure 2.6 – The Excel Options dialog'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.6 – The Excel Options dialog'
- en: '](img/Figure_2.6_B16617.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.6_B16617.jpg)'
- en: Figure 2.6 – The Excel Options dialog
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – Excel 选项对话框
- en: Make sure that the **Add-ins** option is ticked, as shown in the preceding screenshot.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选 **外接程序** 选项，如前面的截图所示。
- en: 'Click on **OK** to close the dialog. Type anything you like in a cell and then
    click on the **Add-ins** tab. You should see something similar to the following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭对话框。在单元格中输入任何内容，然后点击**添加插件**选项卡。你应该看到以下类似的内容：
- en: '![Figure 2.7 – Excel showing the Add-ins tab'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – Excel 显示“插件”选项卡'
- en: '](img/Image87430.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Image87430.jpg)'
- en: Figure 2.7 – Excel showing the Add-ins tab
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – Excel 显示“插件”选项卡
- en: 'Make sure that your text cell is selected. Then, click on the **Get Cell Value**
    ribbon item. You should see a message similar to the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的文本单元格被选中。然后，点击**获取单元格值**功能区项。你应该看到以下类似的消息：
- en: '![Figure 2.8 – Excel message displaying the text in the active cell'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – Excel 显示活动单元格中的文本'
- en: '](img/Image87438.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Image87438.jpg)'
- en: Figure 2.8 – Excel message displaying the text in the active cell
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – Excel 显示活动单元格中的文本
- en: Loading our VSTO add-in on demand
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按需加载我们的 VSTO 插件
- en: 'Now, let''s add a performance improvement to our Excel add-in by only loading
    it when the customer demands it instead of at startup. Follow these steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过仅在客户需求时加载而不是在启动时加载来为我们的 Excel 插件添加性能改进。按照以下步骤操作：
- en: Right-click on the Excel add-in project and select **Properties**.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 Excel 插件项目并选择**属性**。
- en: Then, select the **Publish** page.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**发布**页面。
- en: On the **Publish** page, click on the **Options** button.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发布**页面上，点击**选项**按钮。
- en: On the **Publish Options** dialog, select **Office Settings**.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发布选项**对话框中，选择**Office 设置**。
- en: Select the **Load on Demand** option and click on the **OK** button.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**按需加载**选项，然后点击**确定**按钮。
- en: Bypassing Ribbon reflection
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过功能区反射
- en: You can bypass Ribbon reflection by overriding `Microsoft.Office.Core.IRibbonExtensibility.CreateRibbonExtensibleObject()`.
    Instead of letting VSTO reflect what Ribbon object to load, you must use a conditional
    statement to explicitly load the correct Ribbon.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过覆盖 `Microsoft.Office.Core.IRibbonExtensibility.CreateRibbonExtensibleObject()`
    来跳过功能区反射。而不是让 VSTO 反射要加载的 Ribbon 对象，你必须使用条件语句来显式加载正确的 Ribbon。
- en: Executing expensive operations in a separate thread of execution
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单独的执行线程中执行昂贵的操作
- en: Any time-consuming tasks such as database operations and transferring objects
    over a network should be carried out in separate threads.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 任何耗时任务，如数据库操作和网络上的对象传输，都应该在单独的线程中执行。
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You must execute calls to the Office object model in the main thread.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在主线程中执行对 Office 对象模型的调用。
- en: Further performance improvements
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步的性能改进
- en: 'For further guidance on performance improvements that you can make to VSTO
    add-ins, check out the official Microsoft documentation: [https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有关您可以对 VSTO 插件进行的性能改进的进一步指导，请参阅官方 Microsoft 文档：[https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019)。
- en: So far, we have looked at various methods of interacting with other programs
    and programming languages. Now, let's learn how to safely dispose of unmanaged
    code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了与其他程序和编程语言交互的各种方法。现在，让我们学习如何安全地处理未托管代码。
- en: Safely disposing of unmanaged code
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地处理未托管代码
- en: When working with unmanaged resources, you must explicitly dispose of them yourself
    to free up resources. If you do not, then you may end up with exceptions being
    raised or, worse, your application completely crashing. You must make sure that
    your applications don't continue running and supplying wrong data when exceptions
    are encountered. Should exceptions be encountered where the data would become
    invalid if the application were to continue, then it is better to exit the program.
    You must also make sure that if your application encounters a catastrophic exception
    that it is unable to recover from, either a message is displayed or some kind
    of logging takes place before it shuts down.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理未托管资源时，你必须显式地释放它们以释放资源。如果不这样做，可能会导致异常被抛出，或者更糟的是，你的应用程序可能会完全崩溃。你必须确保你的应用程序在遇到异常时不会继续运行并提供错误数据。如果在应用程序继续运行的情况下数据会变得无效，那么退出程序会更好。你还必须确保如果应用程序遇到无法恢复的灾难性异常，则在关闭之前显示消息或进行某种类型的记录。
- en: 'In C#, there are two ways to dispose of unmanaged resources: using the disposable
    pattern and using finalizers. We will discuss both methods in this section via
    code examples.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有两种处理非托管资源的方法：使用可处置模式和终结器。我们将通过代码示例在本节中讨论这两种方法。
- en: Understanding C# finalization
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解C#终结化
- en: A **finalizer** is a destructor in C# and is used to perform any necessary final
    cleanup that needs to be performed manually. You can use finalizers in classes,
    but you cannot use them in structs. A class can have one finalizer, but a class
    cannot inherit or overload finalizers. You cannot call finalizers as they are
    invoked automatically when the class is destroyed. Also, modifiers do not accept
    modifiers or have any parameters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**终结器**是C#中的析构函数，用于执行任何必要的手动清理操作。你可以在类中使用终结器，但不能在结构体中使用。一个类可以有一个终结器，但不能继承或重载终结器。你不能显式调用终结器，因为它们在类被销毁时自动调用。此外，修饰符不接受修饰符或没有参数。'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You have no control over when a finalizer runs. If the GC was to run too infrequently,
    then you could experience `OutOfMemory` exceptions. Instead of relying on finalizers,
    you should implement the Dispose design pattern best practice, which will call
    the finalizer as a last resort. Consider finalizer code running as a bug when
    you're disposing of managed and unmanaged objects.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法控制终结器何时运行。如果GC运行得太频繁，那么你可能会遇到`OutOfMemory`异常。与其依赖终结器，你应该实现Dispose设计模式的最佳实践，这将在最后作为后备调用终结器。当你正在处理托管和非托管对象时，将终结器代码视为一个错误。
- en: 'There are two syntactic ways to write finalizers in C#. The first is the classic
    method, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中有两种编写终结器的语法方式。第一种是经典方法，如下所示：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The second way to write a finalizer is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编写终结器的第二种方式如下：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As a programmer, you must know that, despite using finalizers to clean up code,
    you have no control over whether or when the garbage collector will call them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名程序员，你必须知道，尽管使用终结器来清理代码，但你无法控制垃圾回收器何时以及是否调用它们。
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a rule of thumb, most of your code is managed code. This means that there
    should never be a need for you to touch finalizers. Only use them if you need
    to when cleaning up unmanaged objects.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，你的大部分代码是托管代码。这意味着你永远不需要触摸终结器。只有在你需要清理非托管对象时才使用它们。
- en: Using the disposable pattern to release managed and unmanaged resources
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可处置模式释放托管和非托管资源
- en: 'When you''re dealing with managed and unmanaged objects, it is necessary to
    implement the disposable design pattern. The disposable pattern implements the
    `Dispose(bool disposing)` method, as shown in the source code for the `CH02_ObjectCleanup`
    project on GitHub. This is what we will do in this demonstration. Follow these
    steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理托管和非托管对象时，实现可处置设计模式是必要的。可处置模式实现了`Dispose(bool disposing)`方法，如GitHub上`CH02_ObjectCleanup`项目的源代码所示。这就是我们在本次演示中要做的。按照以下步骤操作：
- en: 'Start a new .NET console application. Then, add a class called `DisposableBase`,
    as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的.NET控制台应用程序。然后，添加一个名为`DisposableBase`的类，如下所示：
- en: '[PRE61]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we declared the class abstract and implemented the `IDisposable` interface.
    Our `_disposed` Boolean value will be accessed by subclasses, so we need to declare
    that it is protected. Add the `Dispose()` method, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们声明了该类为抽象类并实现了`IDisposable`接口。我们的`_disposed`布尔值将被子类访问，因此我们需要声明它是受保护的。添加`Dispose()`方法，如下所示：
- en: '[PRE62]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This method calls the `Dispose(bool disposing)` method, which cleans up both
    managed and unmanaged resources. Then, it stops the finalizer from being executed.
    Let''s add the finalizer:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法调用`Dispose(bool disposing)`方法，它清理了托管和非托管资源。然后，它停止终结器的执行。让我们添加终结器：
- en: '[PRE63]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Should our finalizer run – and it is not guaranteed to run – it will call the
    `Dispose(bool disposing)` method when the programmer fails to call the `Dispose()`
    method. Now, let''s add the final part of our `DisposableBase` class – that is,
    the `Disposable(bool disposing)` method:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的终结器运行了——并且它并不保证一定会运行——当程序员未能调用`Dispose()`方法时，它将调用`Dispose(bool disposing)`方法。现在，让我们添加`DisposableBase`类的最后一部分——即`Disposable(bool
    disposing)`方法：
- en: '[PRE64]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If our class has already been disposed of, then we can exit the method. If the
    class has not been disposed of, then we must free up managed resources. Once the
    managed resources have been cleaned up, we can clean up the unmanaged objects
    and set large fields to null. Finally, we must set the `_disposed` Boolean to
    `true`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的类已经被处置，那么我们可以退出方法。如果类尚未被处置，那么我们必须释放托管资源。一旦托管资源被清理，我们可以清理非托管对象并将大字段设置为null。最后，我们必须将`_disposed`布尔值设置为`true`。
- en: When a class inherits our abstract class, its finalizer will call `Dispose(false)`.
    The subclass will override the `Dispose(bool disposing)` method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类继承我们的抽象类时，其终结器将调用`Dispose(false)`。子类将重写`Dispose(bool disposing)`方法。
- en: 'To create an object and destroy it, you can use the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建对象和销毁它，你可以使用以下代码：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, the `ObjectThree` class is instantiated and then disposed of by calling
    the `Dispose()` method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ObjectThree`类被实例化，然后通过调用`Dispose()`方法被处置。
- en: That brings us to the end of this chapter on C# interoperability. Let's summarize
    what we have learned.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章关于C#互操作性的内容。让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by looking into P/Invoke regarding C# interoperability
    using pointer code. We looked at unsafe and fixed code. Unsafe code is code that
    is not managed by the .NET platform, while mixed code is objects fixed in memory
    that are not promoted by the garbage collector because they are accessed using
    pointers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用指针代码来探讨C#互操作性方面的P/Invoke。我们研究了不安全代码和固定代码。不安全代码是.NET平台未管理的代码，而混合代码是内存中固定的对象，由于使用指针访问，因此不会被垃圾回收器提升。
- en: Then, we learned how to call methods in a C++ DLL, including passing parameters
    and returning structs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何调用C++ DLL中的方法，包括传递参数和返回结构体。
- en: Next, we learned how to interact with Python code. We learned how to install
    Python and then add the IronPython NuGet package. This allows us to execute Python
    2.x code directly in a C# class and execute Python code that resides in a Python
    script. The ironPython 2.7.10 library only supports Python 2.x versions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何与Python代码交互。我们学习了如何安装Python，然后添加IronPython NuGet包。这使我们能够直接在C#类中执行Python
    2.x代码，并执行位于Python脚本中的Python代码。IronPython 2.7.10库仅支持Python 2.x版本。
- en: Then, we learned how to perform COM interoperability by reading data from an
    Excel spreadsheet. We also built an Excel add-in that was able to read the data
    of the active cell and display a message box.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过从Excel电子表格中读取数据学习了如何执行COM互操作性。我们还创建了一个Excel插件，该插件能够读取活动单元格的数据并显示一个消息框。
- en: Finally, we learned how to safely dispose of managed and unmanaged objects.
    We built a reusable abstract class called `DisposableBase`. At this point, you
    know to call `Disposable(false)` in subclass finalizers if `Dispose()` is not
    called, as well as how to override `Disposable(bool disposing)` in your base classes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何安全地处理托管和非托管对象。我们创建了一个可重用的抽象类，名为`DisposableBase`。此时，你知道在子类终结器中调用`Disposable(false)`，如果未调用`Dispose()`，以及如何在基类中重写`Disposable(bool
    disposing)`。
- en: Now, it is time for you to answer some questions to reinforce your learning
    before moving on to the *Further reading* section. In the next chapter, we will
    learn about primitives and object types.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回答一些问题来巩固你的学习，然后再进入*进一步阅读*部分。在下一章中，我们将学习关于基本类型和对象类型的内容。
- en: Questions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is P/Invoke short for?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P/Invoke的缩写是什么？
- en: Explain what P/Invoke is.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释P/Invoke是什么。
- en: What is the `unsafe` keyword used for?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unsafe`关键字用于什么？'
- en: Explain object generations.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释对象生成。
- en: What is the `fixed` keyword used for?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fixed`关键字用于什么？'
- en: What is the C++ type for a string?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++的字符串类型是什么？
- en: What NuGet package do you have to import to work with Python code?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要导入哪个NuGet包来处理Python代码？
- en: What pattern do you use to safely dispose of managed and unmanaged objects?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用什么模式来安全地处理托管和非托管对象？
- en: How do you dispose of large fields?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何处置大字段？
- en: Further reading
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: '*Unsafe code language specification*: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非安全代码语言规范*: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code).'
- en: '*C# tutorial for beginners: What is Unsafe Code?* [https://www.youtube.com/watch?v=oIqEBMw_Syk](https://www.youtube.com/watch?v=oIqEBMw_Syk).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#入门教程：什么是非安全代码?* [https://www.youtube.com/watch?v=oIqEBMw_Syk](https://www.youtube.com/watch?v=oIqEBMw_Syk).'
- en: '*Interoperating with unmanaged code*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/](https://docs.microsoft.com/en-us/dotnet/framework/interop/).'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与未管理代码交互*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/](https://docs.microsoft.com/en-us/dotnet/framework/interop/).'
- en: '*Interop Marshaling*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling](https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling).'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*互操作整理*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling](https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling).'
- en: '*Marshalling Data with Platform Invoke*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke](https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用平台调用整理数据*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke](https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke).'
- en: '*P/Invoke Tips*: [http://benbowen.blog/post/pinvoke_tips/](http://benbowen.blog/post/pinvoke_tips/).'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P/Invoke技巧*: [http://benbowen.blog/post/pinvoke_tips/](http://benbowen.blog/post/pinvoke_tips/).'
- en: '*Debugging Finalizers*: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/net-matters-debugging-finalizers](https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/net-matters-debugging-finalizers).'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试终结器*: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/net-matters-debugging-finalizers](https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/net-matters-debugging-finalizers).'
- en: '*Destructors in C#*: [https://www.geeksforgeeks.org/destructors-in-c-sharp/](https://www.geeksforgeeks.org/destructors-in-c-sharp/).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的析构函数*: [https://www.geeksforgeeks.org/destructors-in-c-sharp/](https://www.geeksforgeeks.org/destructors-in-c-sharp/).'
- en: '.NET Memory Performance Analysis: [https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#The-effect-of-a-generational-GC](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#The-effect-of-a-generational-GC).'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET内存性能分析: [https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#The-effect-of-a-generational-GC](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#The-effect-of-a-generational-GC).'
- en: '*Improving the performance of a VSTO add-in*: [https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019).'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高VSTO插件性能*: [https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019).'
- en: '*When everything you know is wrong, part one*: [https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/](https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/).'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当你知道的一切都是错误的时候，第一部分*: [https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/](https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/).'
- en: '*.NET Memory Performance Analysis*: [https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md.](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md.)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET内存性能分析*: [https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md.](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md.)'
- en: '*OLE/Automation BSTR (String Manipulation Functions)*: [https://docs.microsoft.com/previous-versions/windows/desktop/automat/string-manipulation-functions](https://docs.microsoft.com/previous-versions/windows/desktop/automat/string-manipulation-functions)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OLE/Automation BSTR (字符串操作函数)*: [https://docs.microsoft.com/previous-versions/windows/desktop/automat/string-manipulation-functions](https://docs.microsoft.com/previous-versions/windows/desktop/automat/string-manipulation-functions)'
- en: '*How to pass arrays of objects from C# to C++*: [https://alekdavis.blogspot.com/2012/07/how-to-pass-arrays-of-objects-from-c-to.html](https://alekdavis.blogspot.com/2012/07/how-to-pass-arrays-of-objects-from-c-to.html).'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何从C#传递对象数组到C++*: [https://alekdavis.blogspot.com/2012/07/how-to-pass-arrays-of-objects-from-c-to.html](https://alekdavis.blogspot.com/2012/07/how-to-pass-arrays-of-objects-from-c-to.html).'
