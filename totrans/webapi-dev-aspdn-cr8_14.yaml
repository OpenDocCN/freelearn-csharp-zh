- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: CI/CD for ASP.NET Core Using Azure Pipelines and GitHub Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure Pipelines 和 GitHub Actions 进行 ASP.NET Core 的 CI/CD
- en: In the previous chapters, we have explored the fundamentals of building, testing,
    and running ASP.NET Core applications. We have also discussed how to access data
    from a database using `dotnet run` command to run our applications locally. Now,
    it is time to take the next step in our ASP.NET Core journey and learn how to
    deploy our applications to the cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经探讨了构建、测试和运行 ASP.NET Core 应用程序的基础知识。我们还讨论了如何使用 `dotnet run` 命令从数据库中访问数据以在本地运行我们的应用程序。现在，是我们继续我们的
    ASP.NET Core 之旅并学习如何将我们的应用程序部署到云中的时候了。
- en: 'In this chapter, we will explore the concept of **continuous integration and
    continuous delivery/deployment** (**CI/CD**). This chapter will focus on two popular
    CI/CD tools and platforms: Azure Pipelines and GitHub Actions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 **持续集成和持续交付/部署**（**CI/CD**）的概念。本章将重点介绍两个流行的 CI/CD 工具和平台：Azure Pipelines
    和 GitHub Actions。
- en: 'We will discuss the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Introduction to CI/CD
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 简介
- en: Containerizing ASP.NET Core applications using Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化 ASP.NET Core 应用程序
- en: CI/CD using Azure Pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure Pipelines 进行 CI/CD
- en: GitHub Actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: Upon completion of this chapter, you will have a basic understanding of containerization
    concepts and the ability to build and deploy your ASP.NET Core applications to
    the cloud using either of these tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将基本了解容器化概念，并能够使用这些工具中的任何一个构建和部署您的 ASP.NET Core 应用程序到云中。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/)
    找到。
- en: Introduction to CI/CD
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 简介
- en: Developers work on code every day – they may create new features, fix bugs,
    or refactor existing code. In a team environment, multiple developers may be working
    on the same code base. A developer may create a new feature, while another developer
    may be fixing a bug. The code base is constantly changing, and it is important
    to ensure that the code changes made by different developers do not conflict with
    each other and do not break any existing functionalities. To avoid such issues,
    developers should integrate their code changes frequently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者每天都在编写代码——他们可能创建新功能、修复错误，或者重构现有代码。在团队环境中，多个开发者可能正在同一个代码库上工作。一个开发者可能正在创建新功能，而另一个开发者可能正在修复错误。代码库不断变化，确保不同开发者所做的代码更改不会相互冲突，并且不会破坏任何现有功能，这一点非常重要。为了避免此类问题，开发者应频繁地集成他们的代码更改。
- en: Additionally, when the application is ready to be deployed, it is important
    to consider the different environments it may be deployed to, such as development,
    staging, or production. Different environments may have different configurations,
    and the deployment process may be different for each environment. To ensure that
    the application is deployed correctly and consistently, it is ideal to automate
    the deployment process. This is where CI/CD comes in.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当应用程序准备部署时，考虑它可能部署到的不同环境（如开发、测试或生产）也很重要。不同的环境可能有不同的配置，部署过程也可能因环境而异。为了确保应用程序被正确且一致地部署，自动化部署过程是理想的。这就是
    CI/CD 发挥作用的地方。
- en: The acronym *CI/CD* can have different interpretations depending on the context.
    **CI**, a development practice that allows developers to integrate code changes
    regularly. **CD** can refer to either **continuous delivery** or **continuous
    deployment**, which are often used interchangeably. It is not worth debating the
    exact definitions of these terms, as in most cases, *CD* means building, testing,
    and deploying the applications to the production environment (and, potentially,
    other environments) frequently and automatically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写 *CI/CD* 的含义可能因上下文而异。**CI** 是一种开发实践，允许开发者定期集成代码更改。**CD** 可以指 **持续交付** 或 **持续部署**，这两个术语通常可以互换使用。在大多数情况下，*CD*
    指的是频繁且自动地将应用程序构建、测试和部署到生产环境（以及可能的其他环境），因此没有必要对这些术语的确切定义进行争论。
- en: CI/CD pipelines are key components of **DevOps**, a combination of the words
    **development** and **operations**. DevOps has evolved over the years and is generally
    defined as a set of practices, tools, and processes that enable continuous delivery
    of value to end users. While DevOps is a vast topic, this chapter will focus on
    CI/CD pipelines specifically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流水线是**DevOps**的关键组件，DevOps是**开发**和**运维**两个词的组合。DevOps在过去几年中不断发展，通常被定义为一系列实践、工具和流程，这些流程能够使最终用户持续获得价值。虽然DevOps是一个广泛的话题，但本章将专注于CI/CD流水线。
- en: 'A typical CI/CD process is shown in the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的CI/CD流程如下所示：
- en: '![Figure 14.1 – A typical CI/CD process](img/B18971_14_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 典型的CI/CD流程](img/B18971_14_01.jpg)'
- en: Figure 14.1 – A typical CI/CD process
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 典型的CI/CD流程
- en: 'The steps in *Figure 14**.1* are described as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1中的步骤描述如下：
- en: The developer creates a new feature or fixes a bug in the code base and then
    commits the changes to the shared code repository. If the team is using Git as
    its **version control system** (**VCS**), the developer will create a pull request
    to submit the changes.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者创建新的功能或修复代码库中的错误，然后将更改提交到共享代码仓库。如果团队使用Git作为其**版本控制系统**（**VCS**），开发者将创建一个拉取请求来提交更改。
- en: The pull request will initiates the CI pipeline, which will build the application
    and execute tests. If the build or tests fail, the developer will be notified,
    allowing them to address the issue promptly.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取请求将启动CI流水线，该流水线将构建应用程序并执行测试。如果构建或测试失败，开发者将收到通知，使他们能够及时解决问题。
- en: If the build and tests are successful and the pull request is approved by the
    team, the code changes will be merged into the `main` branch. This ensures that
    the code is up to date and aligns with the team’s standards.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果构建和测试成功，并且拉取请求得到团队的批准，代码更改将被合并到`main`分支。这确保了代码是最新的，并且与团队的标准保持一致。
- en: The merge will trigger the CI pipeline to build the application and publish
    the artifacts (for example, binaries, configuration files, Docker images, and
    so on) to the artifact repository.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并操作将触发CI流水线构建应用程序并将工件（例如，二进制文件、配置文件、Docker镜像等）发布到工件存储库。
- en: The CD pipeline can be triggered manually or automatically. The CD pipeline
    then deploys the application to the target environment (for example, development,
    staging, or production environment).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD流水线可以手动或自动触发。然后CD流水线将应用程序部署到目标环境（例如，开发、测试或生产环境）。
- en: The CI/CD process can be more complex than what is shown in *Figure 14**.1*.
    For example, the CI pipeline may require static code analysis, code test coverage,
    and other quality checks. The CD pipeline may need to apply different configurations
    for different environments or have different deployment strategies, such as blue/green
    deployment or canary deployment. With the increasing complexity of CI/CD pipelines,
    DevOps engineers are in high demand as they possess the skills to implement these
    pipelines using the various tools and platforms available.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流程可能比图14.1中显示的更复杂。例如，CI流水线可能需要静态代码分析、代码测试覆盖率和其他质量检查。CD流水线可能需要为不同的环境应用不同的配置或采用不同的部署策略，例如蓝绿部署或金丝雀部署。随着CI/CD流水线复杂性的增加，DevOps工程师的需求也在增加，因为他们拥有使用各种工具和平台实施这些流水线的技能。
- en: Before we delve into the details of CI/CD, let us first introduce some concepts
    and terminologies that are commonly used in CI/CD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨CI/CD的细节之前，让我们首先介绍一些在CI/CD中常用的概念和术语。
- en: CI/CD concepts and terminologies
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD概念和术语
- en: 'It is essential to understand key concepts and terminologies commonly used
    in CI/CD. The following are some of the most common terms used in CI/CD:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理解CI/CD中常用的一些关键概念和术语至关重要。以下是一些CI/CD中最常用的术语：
- en: '**Pipeline**: A pipeline is an automated process used to build, test, and deploy
    applications. They can be triggered manually or automatically and can even be
    set up to be triggered by other pipelines. This helps streamline the development
    process, ensuring that applications are built, tested, and deployed quickly and
    efficiently.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流水线**：流水线是一种用于构建、测试和部署应用程序的自动化过程。它们可以手动或自动触发，甚至可以设置由其他流水线触发。这有助于简化开发过程，确保应用程序能够快速高效地构建、测试和部署。'
- en: '**Build**: A build is a process that involves compiling the source code and
    creating the necessary binaries or Docker images. This ensures that the code is
    ready for deployment.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：构建是一个涉及编译源代码并创建必要的二进制文件或Docker镜像的过程。这确保了代码已准备好部署。'
- en: '**Test**: A pipeline may include automated tests, such as unit tests, integration
    tests, performance tests, or **end-to-end** (**E2E**) tests. These tests can be
    incorporated into the pipeline to ensure that the code changes do not break any
    existing functionalities. This helps to ensure that the software remains stable
    and reliable.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：管道可能包括自动化测试，如单元测试、集成测试、性能测试或**端到端**（**E2E**）测试。这些测试可以集成到管道中，以确保代码更改不会破坏任何现有功能。这有助于确保软件的稳定性和可靠性。'
- en: '**Artifact**: An artifact is a file or collection of files – normally, the
    output of a build process. Examples of artifacts include binary files, a Docker
    image, or a ZIP file containing the binary files. These artifacts can then be
    used as inputs for the deployment process.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工件**：工件是一个文件或文件集合——通常是构建过程的输出。工件示例包括二进制文件、Docker镜像或包含二进制文件的ZIP文件。然后，这些工件可以用作部署过程的输入。'
- en: '**Containerization**: Containerization is a method of packaging an application
    and its dependencies into a container image, which can be deployed and run in
    a consistent environment, regardless of the host operating system. One of the
    most popular containerization tools is Docker. Containerization offers numerous
    benefits, such as improved scalability, portability, and resource utilization.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化**：容器化是一种将应用程序及其依赖项打包到容器镜像中的方法，可以在一致的环境中部署和运行，不受主机操作系统的限制。最流行的容器化工具之一是Docker。容器化提供了许多好处，如提高可伸缩性、便携性和资源利用率。'
- en: '**VCS**: VCSs are an essential tool for software development, allowing developers
    to track and manage changes to source code. Git is one of the most widely used
    VCSs, providing developers with an effective way to manage their code base.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制系统**（VCS）：VCS是软件开发的重要工具，允许开发者跟踪和管理源代码的更改。Git是最广泛使用的VCS之一，为开发者提供了一种有效管理其代码库的方法。'
- en: '**Deployment**: Deployment is the process of deploying the application to the
    target environment. It involves configuring the application to meet the requirements
    of the environment, as well as ensuring that it is secure and ready for use.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：部署是将应用程序部署到目标环境的过程。它涉及配置应用程序以满足环境的要求，并确保其安全且可供使用。'
- en: '`main` branch can trigger the CI pipeline to build and publish artifacts. The
    successful CI pipeline can trigger the CD pipeline to deploy the application to
    non-production environments. However, the CD pipeline may need to be triggered
    manually to deploy the application to the production environment as a safety measure.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`分支可以触发CI管道构建和发布工件。成功的CI管道可以触发CD管道将应用程序部署到非生产环境。然而，为了安全起见，CD管道可能需要手动触发以将应用程序部署到生产环境。'
- en: Gaining an understanding of the fundamental concepts and terminologies associated
    with CI/CD is essential for successful implementation. As many different tools
    and platforms can be used to implement CI/CD pipelines, we will discuss the details
    in the following sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解与CI/CD相关的根本概念和术语对于成功实施至关重要。由于可以用于实现CI/CD管道的工具有很多，我们将在以下章节中详细讨论。
- en: Understanding the importance of CI/CD
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解CI/CD的重要性
- en: CI/CD plays an important role in DevOps. It helps the team respond to changes
    and deliver value to end users frequently, safely, and reliably. As CI/CD pipelines
    are automated, they can streamline the process of delivering software and reduce
    the time and effort needed to deploy applications to the production environment.
    Additionally, CI/CD helps maintain a stable and reliable code base.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD在DevOps中扮演着重要角色。它帮助团队快速响应变化，并频繁、安全、可靠地向最终用户提供价值。由于CI/CD管道是自动化的，它们可以简化软件交付的过程，并减少将应用程序部署到生产环境所需的时间和精力。此外，CI/CD有助于维护一个稳定可靠的代码库。
- en: In order to successfully implement a CI/CD pipeline, the team must adhere to
    certain practices. Automated tests should be conducted to ensure that code changes
    do not break any existing functionalities. Additionally, a well-defined deployment
    strategy should be established, such as staging the application in a development
    environment before deploying it to the production environment. By following these
    practices, the team can reduce **time to market** (**TTM**) and deliver the application
    to end users faster and more frequently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功实施 CI/CD 流水线，团队必须遵守某些实践。应进行自动测试以确保代码更改不会破坏任何现有功能。此外，应建立明确的部署策略，例如在将应用程序部署到生产环境之前，在开发环境中进行应用程序的预部署。通过遵循这些实践，团队可以缩短**上市时间**（**TTM**），更快更频繁地将应用程序交付给最终用户。
- en: 'CI/CD practices help development teams in the following ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 实践以以下方式帮助开发团队：
- en: '**Faster feedback**: CI/CD pipelines can be triggered automatically when code
    changes are committed to the shared code repository. This provides developers
    with faster feedback on code changes, allowing them to address any issues early
    in the development process.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快地获得反馈**：当代码更改提交到共享代码仓库时，CI/CD 流水线可以自动触发。这为开发者提供了关于代码更改的更快反馈，使他们能够在开发过程的早期阶段解决任何问题。'
- en: '**Reduced manual effort and risk**: CI/CD pipelines automate the deployment
    process, reducing manual effort and risk. This decreases the time and effort needed
    for production deployment, eliminating manual and error-prone processes.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少手动努力和风险**：CI/CD 流水线自动化了部署过程，减少了手动努力和风险。这减少了生产部署所需的时间和精力，消除了手动和容易出错的流程。'
- en: '**Consistency**: Automated builds and deployments ensure consistency across
    different environments. This reduces the risk of deployment failures due to configuration
    issues or *it works on my* *machine* problems.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：自动构建和部署确保了不同环境之间的一致性。这减少了由于配置问题或“在我的机器上运行正常”问题导致的部署失败的风险。'
- en: '**Enhanced quality**: Automated tests can be integrated into CI/CD pipelines,
    which helps to ensure that the code base remains stable and reliable. CI/CD pipelines
    can also run other quality checks, such as static code analysis and code test
    coverage, which leads to higher-quality code.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高质量**：可以将自动测试集成到 CI/CD 流水线中，这有助于确保代码库保持稳定和可靠。CI/CD 流水线还可以运行其他质量检查，如静态代码分析和代码测试覆盖率，从而提高代码质量。'
- en: '**Rapid delivery and agility**: CI/CD pipelines enable the team to release
    new features and bug fixes to end users faster and more frequently. This allows
    businesses to respond quickly to customer needs and market changes.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速交付和敏捷性**：CI/CD 流水线使团队能够更快更频繁地向最终用户发布新功能和错误修复。这使企业能够快速响应客户需求和市场需求。'
- en: With these benefits in mind, it is clear that CI/CD is a must-have for any development
    team. No one would want to go back to the days of manual builds and deployments
    anymore, as it is time-consuming and error-prone.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些好处，很明显，CI/CD 对于任何开发团队来说都是必不可少的。没有人愿意回到手动构建和部署的时代，因为那既耗时又容易出错。
- en: We have now learned some concepts of CI/CD and why it is important. In the next
    section, we will discuss how to containerize ASP.NET Core applications using Docker.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了 CI/CD 的某些概念以及为什么它很重要。在下一节中，我们将讨论如何使用 Docker 容器化 ASP.NET Core 应用程序。
- en: Containerizing ASP.NET Core applications using Docker
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化 ASP.NET Core 应用程序
- en: Many years ago, when we deployed applications to the production environment,
    we needed to ensure that the target environment had the correct version of the
    .NET Framework installed. Developers were struggling with the *it works on my
    machine* problem, as development environments may have had different configurations
    than the production environment, including software versions, operating systems,
    and hardware. This often led to deployment failures due to configuration issues.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，当我们向生产环境部署应用程序时，我们需要确保目标环境已安装正确的 .NET Framework 版本。开发者们在与生产环境可能不同的配置中挣扎，包括软件版本、操作系统和硬件。这通常会导致由于配置问题而导致的部署失败。
- en: The introduction of .NET Core, a cross-platform and open-source framework, has
    enabled us to deploy our applications on any platform, including Windows, Linux,
    and macOS. However, for successful deployment, we still need to ensure that the
    target environment has the correct runtime installed. This is where containerization
    comes in.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的引入，这是一个跨平台和开源框架，使我们能够在任何平台上部署我们的应用程序，包括Windows、Linux和macOS。然而，为了成功部署，我们仍然需要确保目标环境已安装正确的运行时。这就是容器化发挥作用的地方。
- en: What is containerization?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化是什么？
- en: Containers are lightweight, isolated, and portable environments that contain
    all the necessary dependencies for running an application. Unlike **virtual machines**
    (**VMs**), they do not require a separate guest operating system as they share
    the host operating system kernel. This makes them more lightweight and portable
    than VMs, as they can run on any platform that supports the container runtime.
    Containers also provide isolation, ensuring that applications are not affected
    by changes in the environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是轻量级、隔离和可移植的环境，包含运行应用程序所需的所有依赖项。与**虚拟机**（**VMs**）不同，它们不需要单独的客户端操作系统，因为它们共享宿主操作系统的内核。这使得它们比VM更轻量级和可移植，因为它们可以在支持容器运行时的任何平台上运行。容器还提供隔离，确保应用程序不受环境变化的影响。
- en: Containerization is a powerful tool that enables us to package our applications
    and their dependencies into a single container image. **Docker** is one of the
    most popular containerization solutions, offering support for Windows, Linux,
    and macOS for development purposes, as well as many variants of Linux, such as
    Ubuntu, Debian, and CentOS, for production environments. Additionally, Docker
    is compatible with cloud platforms, including Azure, **Amazon Web Services** (**AWS**),
    and **Google Cloud Platform** (**GCP**). If we use Docker as the container runtime,
    then the container images are called **Docker images**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是一个强大的工具，使我们能够将应用程序及其依赖项打包到单个容器镜像中。**Docker**是最受欢迎的容器化解决方案之一，为开发目的提供对Windows、Linux和macOS的支持，以及许多Linux变体，如Ubuntu、Debian和CentOS，用于生产环境。此外，Docker与云平台兼容，包括Azure、**亚马逊网络服务**（**AWS**）和**谷歌云平台**（**GCP**）。如果我们使用Docker作为容器运行时，那么这些容器镜像就被称为**Docker镜像**。
- en: Docker images are a convenient way to package an application and its dependencies.
    They contain all the components necessary to run an application, such as the application
    code (binaries), runtime or SDK, system tools, and configurations. Docker images
    are immutable, meaning they cannot be changed once they are created. To store
    these images, they are placed in a registry, such as Docker Hub, **Azure Container
    Registry** (**ACR**), or AWS **Elastic Container Registry** (**ECR**). Docker
    Hub is a public registry that offers many pre-built images. Alternatively, a private
    registry can be created to store custom Docker images.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是一种方便的方式来打包应用程序及其依赖项。它们包含运行应用程序所需的所有组件，例如应用程序代码（二进制文件）、运行时或SDK、系统工具和配置。Docker镜像是不可变的，这意味着一旦创建就无法更改。为了存储这些镜像，它们被放置在注册表中，例如Docker
    Hub、**Azure容器注册表**（**ACR**）或AWS **弹性容器注册表**（**ECR**）。Docker Hub是一个公共注册表，提供许多预构建的镜像。或者，可以创建一个私有注册表来存储自定义Docker镜像。
- en: Once a Docker image has been created, it can be used to create a Docker container.
    A Docker container is an isolated, in-memory instance of a Docker image, with
    its own filesystem, network, and memory. This makes creating a container much
    faster than booting up a VM and also allows for fast destruction and rebuilding
    of a container from the same image. In addition, multiple containers can be created
    from the same image, which is useful for scaling out applications. If any container
    fails, it can be destroyed and rebuilt from the same image in a matter of seconds,
    making containerization a powerful tool.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个Docker镜像，就可以用它来创建Docker容器。Docker容器是Docker镜像的隔离、内存实例，具有自己的文件系统、网络和内存。这使得创建容器比启动虚拟机（VM）要快得多，同时也允许快速销毁和从同一镜像重建容器。此外，可以从同一镜像创建多个容器，这对于扩展应用程序非常有用。如果任何容器失败，可以在几秒钟内将其销毁并从同一镜像重建，这使得容器化成为一个强大的工具。
- en: 'The files in a Docker image are stackable. *Figure 14**.2* shows an example
    of a container filesystem that contains an ASP.NET Core app and its dependencies:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像中的文件是可堆叠的。*图14.2*展示了包含ASP.NET Core应用程序及其依赖项的容器文件系统示例：
- en: '![Figure 14.2 – Docker container file system](img/B18971_14_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – Docker容器文件系统](img/B18971_14_02.jpg)'
- en: Figure 14.2 – Docker container file system
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – Docker 容器文件系统
- en: '*Figure 14**.2* illustrates the layers of a Docker container. On top of the
    kernel layer is the base image layer, which is an empty container image created
    from Ubuntu. On top of the base image layer is the ASP.NET Core runtime layer,
    then the ASP.NET Core app layer. When a container is created, Docker adds a final
    writeable layer on top of the other layers. This writeable layer can be used to
    store temporary files, such as logs. However, as we mentioned earlier, Docker
    images are immutable, so any changes made to the writeable layer will be lost
    when the container is destroyed. This is why we should not store any persistent
    data in a container. Instead, we should store the data in a volume, which is a
    directory on the host machine that is mounted into the container.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.2* 展示了 Docker 容器的层。在内核层之上是基础镜像层，它是由 Ubuntu 创建的空容器镜像。在基础镜像层之上是 ASP.NET
    Core 运行时层，然后是 ASP.NET Core 应用层。当创建容器时，Docker 在其他层之上添加一个可写层。这个可写层可以用来存储临时文件，例如日志。然而，正如我们之前提到的，Docker
    镜像是不可变的，因此对可写层的任何更改在容器销毁时都会丢失。这就是为什么我们不应该在容器中存储任何持久数据。相反，我们应该将数据存储在卷中，卷是主机机器上的一个目录，该目录被挂载到容器中。'
- en: This is a very simplified explanation of Docker images and containers. Next,
    let us install Docker and create a Docker image for our ASP.NET Core application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对 Docker 镜像和容器的非常简化的解释。接下来，让我们安装 Docker 并为我们的 ASP.NET Core 应用程序创建一个 Docker
    镜像。
- en: Installing Docker
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'You can download Docker Desktop from the following links:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接下载 Docker Desktop：
- en: 'Windows: [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/
    )'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/
    )'
- en: 'Mac: [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/
    )'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mac: [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/
    )'
- en: 'Linux: [https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/
    )'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: [https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/
    )'
- en: Please follow the official documentation to install Docker on your machine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循官方文档在您的机器上安装 Docker。
- en: If you use Windows, please use the **Windows Subsystem for Linux 2** (**WSL
    2**) backend instead of Hyper-V. WSL 2 is a compatibility layer that allows Linux
    binary executables to be run natively on Windows. Using WSL 2 as the backend for
    Docker Desktop on Windows provides better performance than the Hyper-V backend.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Windows，请使用 **Windows Subsystem for Linux 2** （**WSL 2**） 后端而不是 Hyper-V。WSL
    2 是一个兼容层，允许 Linux 二进制可执行文件在 Windows 上原生运行。使用 WSL 2 作为 Windows 上 Docker Desktop
    的后端比 Hyper-V 后端提供更好的性能。
- en: 'To install WSL 2 on Windows, please follow the instructions at this link: [https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install).
    By default, WSL 2 uses the Ubuntu distribution. You can also install other Linux
    distributions, such as Debian, CentOS, or Fedora.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上安装 WSL 2，请遵循此链接的说明：[https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)。默认情况下，WSL
    2 使用 Ubuntu 发行版。您还可以安装其他 Linux 发行版，如 Debian、CentOS 或 Fedora。
- en: 'After installing WSL 2, you can check the version of WSL by running the following
    command in PowerShell:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 WSL 2 后，您可以在 PowerShell 中运行以下命令来检查 WSL 的版本：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you see the `VERSION` field shows `2`, that means WSL 2 is installed correctly.
    Then, you can install Docker Desktop and choose WSL 2 as the backend. If you have
    multiple Linux distributions installed, you can choose the default distribution
    to use with Docker Desktop. Go to **Settings** | **Resources** | **WSL integration**,
    and choose the distribution you want to use with Docker Desktop, as shown in *Figure
    14**.3*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到 `VERSION` 字段显示 `2`，这意味着 WSL 2 已正确安装。然后，您可以安装 Docker Desktop 并选择 WSL 2
    作为后端。如果您安装了多个 Linux 发行版，您可以选择与 Docker Desktop 一起使用的默认发行版。转到 **设置** | **资源** |
    **WSL 集成**，并选择您想要与 Docker Desktop 一起使用的发行版，如图 *图 14.3* 所示：
- en: '![Figure 14.3 – Choosing the default Linux distribution to use with Docker
    Desktop](img/B18971_14_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 选择与 Docker Desktop 一起使用的默认 Linux 发行版](img/B18971_14_03.jpg)'
- en: Figure 14.3 – Choosing the default Linux distribution to use with Docker Desktop
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 选择与 Docker Desktop 一起使用的默认 Linux 发行版
- en: 'Here is the example output of the `wsl -l -v` command, which shows two Linux
    distros installed on this machine; the default distro is `Ubuntu-22.04`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `wsl -l -v` 命令的示例输出，它显示了安装在此机器上的两个 Linux 发行版；默认发行版是 `Ubuntu-22.04`：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Docker Desktop installs two internal Linux distros:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop安装了两个内部Linux发行版：
- en: '`docker-desktop`: This is used to run the Docker engine'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-desktop`：用于运行Docker引擎'
- en: '`docker-desktop-data`: This is used to store containers and images'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-desktop-data`：用于存储容器和镜像'
- en: 'Note that Docker may consume a lot of resources on your machine. If you feel
    that Docker slows down your machine or consumes too many resources, you can configure
    the resources allocated to WSL 2 following the instructions in this link: [https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig](https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Docker可能会在您的机器上消耗大量资源。如果您觉得Docker使您的机器变慢或消耗了太多资源，您可以按照以下链接中的说明配置分配给WSL 2的资源：[https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig](https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig)。
- en: After installing Docker Desktop, we can now create a Docker image for our ASP.NET
    Core application. In the next section, we will discuss some commands that are
    commonly used in Docker.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Docker Desktop之后，我们现在可以为我们的ASP.NET Core应用程序创建Docker镜像。在下一节中，我们将讨论一些在Docker中常用的命令。
- en: Understanding Dockerfiles
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Dockerfile
- en: 'To demonstrate how to build and run Docker images, we will need a sample ASP.NET
    Core application. You can create a new ASP.NET Core web API project using the
    following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何构建和运行Docker镜像，我们需要一个示例ASP.NET Core应用程序。您可以使用以下命令创建一个新的ASP.NET Core Web
    API项目：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alternatively, you can clone the sample code from the `/samples/chapter14/MyBasicWebApiDemo`
    folder in the book's GitHub repository.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以从书籍GitHub仓库中的`/samples/chapter14/MyBasicWebApiDemo`文件夹克隆示例代码。
- en: 'Docker images can be built using a Dockerfile, a text file containing a list
    of instructions used to build the image. You can create a Dockerfile in the root
    directory of the ASP.NET Core project manually, or you can use VS 2022 to create
    it for you. To create a Dockerfile using VS 2022, right-click on the project in
    Solution Explorer, then select **Add** | **Docker Support**. You will see the
    following dialog:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像可以使用Dockerfile构建，这是一个包含用于构建镜像的指令列表的文本文件。您可以在ASP.NET Core项目的根目录中手动创建Dockerfile，或者使用VS
    2022为您创建它。要使用VS 2022创建Dockerfile，请在解决方案资源管理器中右键单击项目，然后选择**添加** | **Docker支持**。您将看到以下对话框：
- en: '![Figure 14.4 – Adding Docker support to an ASP.NET Core project in VS 2022](img/B18971_14_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 在VS 2022中为ASP.NET Core项目添加Docker支持](img/B18971_14_04.jpg)'
- en: Figure 14.4 – Adding Docker support to an ASP.NET Core project in VS 2022
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 在VS 2022中为ASP.NET Core项目添加Docker支持
- en: 'There are two options here: **Linux** and **Windows**. It is recommended to
    use Linux for development purposes, as the Linux image is smaller than the Windows
    image. Docker was originally designed for Linux, so it is more mature on Linux
    than on Windows. Many cloud platforms, such as Azure, AWS, and GCP, support Linux
    containers. However, not all Windows servers support Windows containers. Unless
    you have strong reasons to host your application on a Windows server, you should
    choose **Linux** here.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个选项：**Linux**和**Windows**。建议用于开发目的使用Linux，因为Linux镜像比Windows镜像小。Docker最初是为Linux设计的，因此在Linux上的成熟度高于Windows。许多云平台，如Azure、AWS和GCP，支持Linux容器。但是，并非所有Windows服务器都支持Windows容器。除非您有强烈的理由在Windows服务器上托管您的应用程序，否则您应该在这里选择**Linux**。
- en: 'Once you have selected the `Dockerfile` without any file extension. This allows
    us to build the Docker image using the `docker build` command without needing
    to specify the Dockerfile name. The default Dockerfile created by VS 2022 will
    resemble the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了没有任何文件扩展名的`Dockerfile`。这允许我们使用`docker build`命令构建Docker镜像，而无需指定Dockerfile的名称。VS
    2022默认创建的Dockerfile将类似于以下内容：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us go through the Dockerfile line by line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析Dockerfile：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `FROM` instruction specifies the base image to use. The `FROM` instruction
    must be the first instruction in a Dockerfile. In this case, we are using the
    `mcr.microsoft.com/dotnet/aspnet:8.0` image, which is the ASP.NET Core runtime
    image. This image is provided by Microsoft. `mcr.microsoft.com` is the domain
    name of the `AS base` means we are giving this image a name, which is `base`.
    This name can be used later in the Dockerfile to refer to this image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令指定要使用的基镜像。`FROM`指令必须是Dockerfile中的第一个指令。在这种情况下，我们使用的是`mcr.microsoft.com/dotnet/aspnet:8.0`镜像，这是ASP.NET
    Core运行时镜像。此镜像由Microsoft提供。`mcr.microsoft.com`是`AS base`的域名，我们正在给这个镜像起一个名字，即`base`。这个名称可以在Dockerfile的后续部分用来引用这个镜像。'
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, the `USER` instruction specifies the username or `app` user is created
    by the base image. This user is not a superuser, so it is more secure than the
    root user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`USER` 指令指定了用户名或由基本镜像创建的 `app` 用户。此用户不是超级用户，因此比 root 用户更安全。
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `WORKDIR` instruction sets the working directory inside of the container
    for these instructions: `RUN`, `CMD`, `COPY`, `ADD`, `ENTRYPOINT`, and so on.
    This instruction is similar to the `cd` command in the terminal. It supports both
    absolute and relative paths. If the directory does not exist, it will be created.
    In this example, the working directory is set to `/app`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR` 指令为这些指令设置容器内部的工作目录：`RUN`、`CMD`、`COPY`、`ADD`、`ENTRYPOINT` 等。此指令类似于终端中的
    `cd` 命令。它支持绝对路径和相对路径。如果目录不存在，它将被创建。在这个例子中，工作目录被设置为 `/app`。'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `EXPOSE` instruction exposes the specified port(s) to the container when
    it is running. Note that this instruction does not actually publish the port to
    the host machine. It just means the container will listen on the specified port(s).
    By default, the `EXPOSE` instruction exposes the port(s) on the TCP protocol.
    In this case, the container will listen on ports `8080` and `8081`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令在容器运行时将指定的端口（端口）暴露给容器。请注意，此指令实际上并不会将端口发布到主机机器。它只是意味着容器将监听指定的端口（端口）。默认情况下，`EXPOSE`
    指令暴露 TCP 协议上的端口。在这种情况下，容器将监听端口 `8080` 和 `8081`。'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding lines, we are using a different image, which is the `mcr.microsoft.com/dotnet/sdk:8.0`
    image, and naming it `build`. This image contains the .NET SDK, which is used
    to build the application. The `ARG` instruction defines a variable that can be
    used later in the Dockerfile. In this case, we are defining a variable called
    `BUILD_CONFIGURATION` and setting its default value to `Release`. The `WORKDIR`
    instruction sets the working directory to `/src`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们使用了一个不同的镜像，即 `mcr.microsoft.com/dotnet/sdk:8.0` 镜像，并将其命名为 `build`。此镜像包含
    .NET SDK，用于构建应用程序。`ARG` 指令定义了一个可以在 Dockerfile 中稍后使用的变量。在这种情况下，我们定义了一个名为 `BUILD_CONFIGURATION`
    的变量，并将其默认值设置为 `Release`。`WORKDIR` 指令将工作目录设置为 `/src`。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `COPY` instruction copies files or directories from the source (on the local
    machine) to the destination (the filesystem of the container). In this case, we
    are copying the `.csproj` file to the current directory. The `RUN` instruction
    executes the specified command on top of the current image and creates a new layer,
    then commits the results. The new layer will be used for the next step in the
    Dockerfile. In this case, we are running the `dotnet restore` command to restore
    the NuGet packages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令将文件或目录从源（本地机器上的）复制到目标（容器的文件系统）。在这种情况下，我们正在将 `.csproj` 文件复制到当前目录。`RUN`
    指令在当前镜像上执行指定的命令，创建一个新的层，然后提交结果。新层将被用于 Dockerfile 中的下一步。在这种情况下，我们正在运行 `dotnet restore`
    命令来还原 NuGet 包。'
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding lines, we are copying all the files from the local machine
    to the current directory in the container. Then, we are setting the working directory
    to `/src`. Finally, we are running the `dotnet build` command to build the application.
    Note that we are using the `BUILD_CONFIGURATION` variable defined earlier in the
    Dockerfile.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们正在将本地机器上的所有文件复制到容器当前目录。然后，我们将工作目录设置为 `/src`。最后，我们运行 `dotnet build`
    命令来构建应用程序。请注意，我们正在使用 Dockerfile 中之前定义的 `BUILD_CONFIGURATION` 变量。
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, the `FROM` instruction uses the `build` image we defined earlier and
    names it `publish`. Then, the `RUN` instruction runs the `dotnet publish` command
    to publish the application. The `$BUILD_CONFIGURATION` variable is used again.
    The published application will be placed in the `/``app/publish` directory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`FROM` 指令使用我们之前定义的 `build` 镜像，并将其命名为 `publish`。然后，`RUN` 指令运行 `dotnet publish`
    命令来发布应用程序。再次使用 `$BUILD_CONFIGURATION` 变量。发布的应用程序将被放置在 `/app/publish` 目录中。
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we rename the `base` image as `final` and set the working directory to
    `/app`. To run the application, we only need the runtime, so we do not need the
    SDK image. Then, the `COPY` instruction copies the published application from
    the `app/publish` directory of the `publish` image to the current directory. Finally,
    the `ENTRYPOINT` instruction specifies the command to run when the container starts.
    In this case, we are running the `dotnet BasicWebApiDemo.dll` command to start
    the ASP.NET Core application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`base`镜像重命名为`final`，并将工作目录设置为`/app`。要运行应用程序，我们只需要运行时，因此不需要SDK镜像。然后，`COPY`指令将发布的应用程序从`publish`镜像的`app/publish`目录复制到当前目录。最后，`ENTRYPOINT`指令指定了容器启动时要运行的命令。在这种情况下，我们运行`dotnet
    BasicWebApiDemo.dll`命令来启动ASP.NET Core应用程序。
- en: 'You can find more information about Dockerfile instructions in the official
    documentation provided by Docker: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
    Next, let us move on to building a Docker image.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Docker官方提供的文档中找到有关Dockerfile指令的更多信息：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。接下来，让我们继续构建Docker镜像。
- en: Building a Docker image
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: 'Docker provides a set of commands that can be used to build, run, and manage
    Docker images and containers. To build a Docker image, go to the root directory
    of the ASP.NET Core project we created earlier, then run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一套可用于构建、运行和管理Docker镜像和容器的命令。要构建一个Docker镜像，请转到我们之前创建的ASP.NET Core项目的根目录，然后运行以下命令：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `-t` option is used to tag the image with a name. `.` at the end means the
    current directory. Docker expects to find a file named `Dockerfile` in the current
    directory. If you have renamed the Dockerfile or the Dockerfile is not located
    in the current directory, you can use the `-f` option to specify the Dockerfile
    name, such as `docker build -t basicwebapidemo -f` `MyBasicWebApiDemo/MyDockerfile
    MyBasicWebApiDemo`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`选项用于给镜像添加一个名称。末尾的`.`表示当前目录。Docker期望在当前目录中找到一个名为`Dockerfile`的文件。如果您已重命名Dockerfile或Dockerfile不在当前目录中，可以使用`-f`选项指定Dockerfile的名称，例如`docker
    build -t basicwebapidemo -f` `MyBasicWebApiDemo/MyDockerfile MyBasicWebApiDemo`。'
- en: The output shows that Docker is building the image layer by layer. Each instruction
    in the Dockerfile will create a layer in the image and add more content on top
    of the previous layer. The layers are cached, so if a layer has not changed, it
    will not be rebuilt for the next build. But if a layer has changed (for example,
    if we update the source code), then the layer that copies the source code will
    be rebuilt, and all the layers after that will be affected and need to be rebuilt
    as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，Docker正在逐层构建镜像。Dockerfile中的每条指令都会在镜像中创建一个层，并在上一层的上方添加更多内容。这些层被缓存，所以如果某个层没有改变，它将不会在下一个构建过程中被重建。但是，如果某个层发生了变化（例如，如果我们更新了源代码），那么复制源代码的那个层将被重建，并且所有随后的层都将受到影响，需要被重建。
- en: Now, let us review the default Dockerfile generated by VS 2022\. Why does it
    copy all the files after running the `dotnet restore` command? It is because if
    we only update the source code but the NuGet packages have not changed, then the
    `dotnet restore` command will not be executed again as the layer is cached. This
    can improve the build performance. However, if we update the NuGet packages, meaning
    the `.csproj` file has changed, then the `dotnet restore` command will be executed
    again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下由VS 2022生成的默认Dockerfile。为什么它会在运行`dotnet restore`命令后复制所有文件？这是因为如果我们只更新了源代码，但NuGet包没有改变，那么由于层被缓存，`dotnet
    restore`命令将不会再次执行。这可以提高构建性能。然而，如果我们更新了NuGet包，这意味着`.csproj`文件已更改，那么`dotnet restore`命令将再次执行。
- en: 'Here are some tips for writing Dockerfiles:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编写Dockerfile的技巧：
- en: Consider the order of layers. Layers that are less likely to change should be
    placed before layers that are more likely to change.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑层的顺序。不太可能改变的层应该放在更可能改变的层之前。
- en: 'Keep layers small as much as possible. Do not copy unnecessary files. You can
    configure the `.dockerignore` file to exclude files or directories from the build
    context. If you use VS 2022 to create the Dockerfile, it will generate a `.dockerignore`
    file for you. Alternatively, you can manually create a text file named `.dockerignore`
    and then edit it. Here is a sample `.``dockerignore` file:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能保持层的大小小。不要复制不必要的文件。您可以通过配置 `.dockerignore` 文件来排除构建上下文中的文件或目录。如果您使用 VS 2022
    创建 Dockerfile，它将为您生成一个 `.dockerignore` 文件。或者，您可以手动创建一个名为 `.dockerignore` 的文本文件，然后编辑它。以下是一个示例
    `.dockerignore` 文件：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For more information about the `.dockerignore` file, please refer to the official
    documentation here: [https://docs.docker.com/engine/reference/builder/#dockerignore-file](https://docs.docker.com/engine/reference/builder/#dockerignore-file).'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解更多关于 `.dockerignore` 文件的信息，请参阅以下官方文档：[https://docs.docker.com/engine/reference/builder/#dockerignore-file](https://docs.docker.com/engine/reference/builder/#dockerignore-file).
- en: Keep as few layers as possible. For example, to host an ASP.NET Core application,
    we can reduce the number of layers by using the `mcr.microsoft.com/dotnet/aspnet`
    image. This image contains the ASP.NET Core runtime already, eliminating the need
    to install the SDK in the container. You can also combine commands into a single
    `RUN` instruction.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能保持层数最少。例如，为了托管 ASP.NET Core 应用程序，我们可以通过使用 `mcr.microsoft.com/dotnet/aspnet`
    镜像来减少层数。这个镜像已经包含了 ASP.NET Core 运行时，消除了在容器中安装 SDK 的需要。您还可以将命令组合成一个单独的 `RUN` 指令。
- en: 'Use multi-stage builds. Multi-stage builds allow us to use multiple `FROM`
    instructions in a Dockerfile. Each `FROM` instruction can be used to create a
    new image. The final image will only contain the layers from the last `FROM` instruction.
    This can reduce the size of the final image. For example, we can use the `mcr.microsoft.com/dotnet/sdk`
    image to build the application and then use the `mcr.microsoft.com/dotnet/aspnet`
    image to run the application. This way, the final image will only contain the
    ASP.NET Core runtime, and it will not contain the SDK, which is not needed for
    running the application. To learn more about multi-stage builds, please refer
    to the official documentation here: [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段构建。多阶段构建允许我们在 Dockerfile 中使用多个 `FROM` 指令。每个 `FROM` 指令都可以用来创建一个新的镜像。最终的镜像将只包含最后一个
    `FROM` 指令的层。这可以减小最终镜像的大小。例如，我们可以使用 `mcr.microsoft.com/dotnet/sdk` 镜像来构建应用程序，然后使用
    `mcr.microsoft.com/dotnet/aspnet` 镜像来运行应用程序。这样，最终的镜像将只包含 ASP.NET Core 运行时，而不会包含
    SDK，因为 SDK 对运行应用程序不是必需的。要了解更多关于多阶段构建的信息，请参阅以下官方文档：[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).
- en: 'For more information on optimizing Docker builds, please refer to the official
    documentation here: [https://docs.docker.com/build/cache/](https://docs.docker.com/build/cache/).'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解更多关于优化 Docker 构建的信息，请参阅以下官方文档：[https://docs.docker.com/build/cache/](https://docs.docker.com/build/cache/).
- en: 'We can use the following command to list all Docker images on our machine:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令列出我们机器上的所有 Docker 镜像：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should be similar to this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `basicwebapidemo` image is the one we just built. Each image has a `TAG`
    value and an `IMAGE ID` value. The `TAG` value is a human-readable name for the
    image. By default, the tag is `latest`. We can specify a different tag when building
    the image. For example, we can use the following command to build the image with
    the `v1` tag:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`basicwebapidemo` 镜像是我们刚刚构建的。每个镜像都有一个 `TAG` 值和一个 `IMAGE ID` 值。`TAG` 值是镜像的一个可读名称。默认情况下，标签是
    `latest`。我们可以在构建镜像时指定不同的标签。例如，我们可以使用以下命令使用 `v1` 标签构建镜像：'
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding command, the `-t` option is used to tag the image with a name,
    which is separated from the tag with a colon.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`-t` 选项用于给镜像添加一个名称，该名称与标签之间用冒号分隔。
- en: 'To remove an image, use the `docker rmi <container name or ID>` command followed
    by the image name or image ID:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个镜像，使用 `docker rmi <container name or ID>` 命令，后跟镜像名称或镜像 ID：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that if the image is used by a container, you will need to stop the container
    first before removing the image.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果镜像被容器使用，您需要先停止容器，然后再删除镜像。
- en: We now have a Docker image for our ASP.NET Core application. All the necessary
    dependencies are included in the image. Next, let us run the Docker image.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的 ASP.NET Core 应用程序的 Docker 镜像。所有必要的依赖都包含在镜像中。接下来，让我们运行这个 Docker 镜像。
- en: Running a Docker container
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Docker 容器
- en: 'To run a Docker image in the container, we can use the `docker run` command.
    The following command will run the `basicwebapidemo` image we just built:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器中运行 Docker 镜像，我们可以使用 `docker run` 命令。以下命令将运行我们刚刚构建的 `basicwebapidemo` 镜像：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s take a closer look at this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个：
- en: The `-d` option is used to run the container in detached mode, meaning the container
    will run in the background. You can omit this option and then the container will
    run in the foreground, which means if you exit the terminal, the container will
    stop.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 选项用于以分离模式运行容器，这意味着容器将在后台运行。您可以省略此选项，然后容器将在前台运行，这意味着如果您退出终端，容器将停止。'
- en: The `-p` option is used to publish a container’s port(s) to the host. In this
    case, we are publishing port 8080 of the container to port 80 of the host.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 选项用于将容器的端口（端口）发布到主机。在这种情况下，我们将容器的端口 8080 发布到主机的端口 80。'
- en: The `--name` option is used to specify a name for the container. The last argument
    is the name of the image to run.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name` 选项用于指定容器的名称。最后一个参数是要运行的镜像的名称。'
- en: You can also use the `-it` option to run the container in interactive mode.
    This option allows you to run a command in the container.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用 `-it` 选项以交互式模式运行容器。此选项允许您在容器中运行命令。
- en: When we wrote the Dockerfile, we explained that the `EXPOSE` instruction exposes
    ports 8080 and 8081 to the container only. To publish the internal container port
    to the host, we need to use the `-p` option. The first port number is the port
    of the host machine, and the second port number is the internal container port.
    In this example, we are exposing the container port 8080 to the host port 80\.
    This may confuse some people. So, please check the port numbers carefully. Also,
    sometimes the port number of the host machine may be occupied by another process.
    In this case, you will need to use a different port number.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 Dockerfile 时，我们解释了 `EXPOSE` 指令仅将端口 8080 和 8081 暴露给容器。要将内部容器端口发布到主机，我们需要使用
    `-p` 选项。第一个端口号是主机机的端口，第二个端口号是内部容器端口。在这个例子中，我们将容器端口 8080 暴露给主机端口 80。这可能会让一些人感到困惑。所以，请仔细检查端口号。此外，有时主机机的端口号可能已被另一个进程占用。在这种情况下，您需要使用不同的端口号。
- en: 'The output should return the container ID, which is a UID for the container,
    such as this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应返回容器 ID，它是容器的 UID，例如这样：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the `docker ps` command to list all running containers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker ps` 命令列出所有正在运行的容器：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be similar to this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于这样：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the output, we can see that port 8080 of the container has been mapped to
    port 80 of the host.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到容器的端口 8080 已被映射到主机的端口 80。
- en: 'To list all containers in all states, just add a `-``a` option:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有状态的容器，只需添加 `-a` 选项：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can check the status of containers. If the container is running, the status
    should be `Up`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查容器的状态。如果容器正在运行，状态应该是 `Up`。
- en: 'We can use the following commands to manage containers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来管理容器：
- en: 'To pause a container: `docker pause <container name` `or ID>`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要暂停一个容器：`docker pause <容器名称` `或 ID>`
- en: 'To restart a container: `docker restart <container name` `or ID>`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重启一个容器：`docker restart <容器名称` `或 ID>`
- en: 'To stop a container: `docker stop <container name` `or ID>`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要停止一个容器：`docker stop <容器名称` `或 ID>`
- en: 'To remove a container: `docker rm <container name` `or ID>`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除容器：`docker rm <容器名称` `或 ID>`
- en: 'If the container is running, you can test the endpoint by sending a request
    to this URL: `http://localhost/weatherforecast`. You will see the response from
    the ASP.NET Core application. If you change the port number of the host machine,
    you will need to use the correct port number in the URL. For example, if you use
    `-p 5000:8080`, then you will need to use [http://localhost:5000/weatherforecast](http://localhost:5000/weatherforecast)
    to access the endpoint.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器正在运行，您可以通过向此 URL 发送请求来测试端点：`http://localhost/weatherforecast`。您将看到 ASP.NET
    Core 应用程序的响应。如果您更改主机机的端口号，您需要在 URL 中使用正确的端口号。例如，如果您使用 `-p 5000:8080`，那么您需要使用 [http://localhost:5000/weatherforecast](http://localhost:5000/weatherforecast)
    来访问端点。
- en: 'We can use the `docker logs <container name or ID>` command to show logs from
    a container:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker logs <容器名称或 ID>` 命令来显示容器的日志：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see logs such as these:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到如下日志：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To check the stats of a container, you can use the `docker stats <container
    name or` `ID>` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查容器的状态，您可以使用 `docker stats <容器名称或` `ID>` 命令：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see the stats of the container as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到容器的状态如下：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can send a request to the `/weatherforecast` endpoint to get the response
    from the ASP.NET Core application. Note that the container is running in the production
    environment, so the Swagger UI is not available. This is because in the `Program.cs`
    file, we enabled the Swagger UI only in the development environment. To enable
    the Swagger UI, we can stop and delete the current container, then create a new
    one in development environment. Alternatively, you can create a new container
    with a different name. For example, you can stop the container by running the
    following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向`/weatherforecast`端点发送请求来获取ASP.NET Core应用程序的响应。请注意，容器正在生产环境中运行，因此Swagger
    UI不可用。这是因为我们在`Program.cs`文件中只启用了开发环境中的Swagger UI。要启用Swagger UI，我们可以停止并删除当前容器，然后在开发环境中创建一个新的容器。或者，你也可以创建一个具有不同名称的新容器。例如，你可以通过运行以下命令来停止容器：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then remove the container by running the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过运行以下命令来移除容器：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, add an environment variable to the `docker run` command to set the environment
    to development:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将环境变量添加到`docker run`命令中，以设置环境为开发模式：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, you can view the Swagger UI by navigating to the `/swagger` endpoint in
    the browser.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在浏览器中导航到`/swagger`端点来查看Swagger UI。
- en: 'So far, we have learned how to build and run Docker images. Docker has many
    other commands that can be used to manage Docker images and containers. To summarize,
    here are some of the most commonly used Docker commands from Docker official documents:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何构建和运行Docker镜像。Docker有许多其他命令可以用来管理Docker镜像和容器。为了总结，以下是Docker官方文档中一些最常用的Docker命令：
- en: '`docker build`: Build a Docker image'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker build`：构建Docker镜像'
- en: '`docker run`: Run a Docker image'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run`：运行Docker镜像'
- en: '`docker images`: List all images'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker images`：列出所有镜像'
- en: '`docker ps`: List all running containers'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps`：列出所有正在运行的容器'
- en: '`docker ps -a`: List all containers in all states'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps -a`：列出所有状态的容器'
- en: '`docker logs`: Show logs from a container'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker logs`：显示容器的日志'
- en: '`docker stats`: Show stats of a container'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stats`：显示容器的统计信息'
- en: '`docker pause`: Pause a container'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker pause`：暂停容器'
- en: '`docker restart`: Restart a container'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker restart`：重启容器'
- en: '`docker stop`: Stop a container'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stop`：停止容器'
- en: '`docker rm`: Remove a container'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rm`：删除容器'
- en: '`docker rmi`: Remove an image'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rmi`：删除镜像'
- en: '`docker exec`: Run a command in a running container'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec`：在运行的容器中运行命令'
- en: '`docker inspect`: Display detailed information on one or more containers or
    images'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker inspect`：显示一个或多个容器或镜像的详细信息'
- en: '`docker login`: Log in to a Docker registry'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker login`：登录到Docker注册库'
- en: '`docker logout`: Log out from a Docker registry'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker logout`：从Docker注册库注销'
- en: '`docker pull`: Pull an image from a registry'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker pull`：从注册库拉取镜像'
- en: '`docker push`: Push an image to a registry'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker push`：将镜像推送到注册库'
- en: '`docker tag`: Create a `TARGET_IMAGE` tag that refers to `SOURCE_IMAGE`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker tag`：创建一个指向`SOURCE_IMAGE`的`TARGET_IMAGE`标签'
- en: '`docker volume`: Manage volumes'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker volume`：管理卷'
- en: '`docker network`: Manage networks'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker network`：管理网络'
- en: '`docker system`: Manage Docker'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker system`：管理Docker'
- en: '`docker version`: Show the Docker version information'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker version`：显示Docker版本信息'
- en: '`docker info`: Show Docker system-wide information'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker info`：显示Docker系统级别的信息'
- en: '`docker port`: List port mappings or a specific mapping for a container'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker port`：列出端口映射或容器的特定映射'
- en: 'You can find more information about Docker commands here: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多关于Docker命令的信息：[https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).
- en: We have now learned how to build a Docker image for our ASP.NET Core application
    and run it in a container. Even though the container is running on our local machine,
    there is not much difference from running it in a production environment. The
    container is isolated from the host machine. The portable nature of containers
    makes it easy to deploy the application to any environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何为我们的ASP.NET Core应用程序构建Docker镜像并在容器中运行它。尽管容器在我们的本地机器上运行，但与在生产环境中运行并没有太大区别。容器与主机机器隔离。容器的便携性使得将应用程序部署到任何环境变得容易。
- en: We can also use Docker commands to push the image to a registry, such as Docker
    Hub, ACR, and so on. However, manual deployment is error-prone and time-consuming.
    That is why we need a CI/CD pipeline to automate the deployment process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用Docker命令将镜像推送到注册库，例如Docker Hub、ACR等。然而，手动部署容易出错且耗时。这就是为什么我们需要CI/CD管道来自动化部署过程。
- en: In the next section, we will discuss how to deploy the containerized application
    to the cloud using Azure DevOps and Azure Pipelines.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何使用 Azure DevOps 和 Azure Pipelines 将容器化应用程序部署到云中。
- en: CI/CD using Azure DevOps and Azure Pipelines
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 和 Azure Pipelines 进行 CI/CD
- en: 'Azure DevOps is a cloud-based service that provides a set of tools for managing
    the software development process. It includes the following services:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 是一个基于云的服务，提供了一套用于管理软件开发流程的工具。它包括以下服务：
- en: '**Azure Boards**: A service for managing work items, such as user stories,
    tasks, and bugs.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 板**：一个用于管理工作项的服务，例如用户故事、任务和错误。'
- en: '**Azure Repos**: A service for hosting code repositories. It supports Git and
    **Team Foundation Version Control** (**TFVC**). The repositories can be public
    or private.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 代码仓库**：一个用于托管代码仓库的服务。它支持 Git 和 **团队基础版本控制**（**TFVC**）。仓库可以是公开的或私有的。'
- en: '**Azure Pipelines**: A service for building, testing, and deploying applications
    with any language, platform, and cloud.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 管道**：一个用于使用任何语言、平台和云构建、测试和部署应用程序的服务。'
- en: '**Azure Test Plans**: A service for manual and exploratory testing tools.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 测试计划**：一个用于手动和探索性测试工具的服务。'
- en: '`Maven`, `npm`, `NuGet`, and `Python` packages.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Maven`、`npm`、`NuGet` 和 `Python` 包。'
- en: Azure DevOps is free for open-source projects and small teams. We will not cover
    all the features of Azure DevOps in this book. Let us focus on Azure Pipelines.
    In this section, we will discuss how to use Azure Pipelines to build and deploy
    our ASP.NET Core application to Azure App Service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 对开源项目和小型团队是免费的。在这本书中，我们不会涵盖 Azure DevOps 的所有功能。让我们专注于 Azure Pipelines。在本节中，我们将讨论如何使用
    Azure Pipelines 构建和部署我们的 ASP.NET Core 应用程序到 Azure App Service。
- en: 'We will need these resources before we can deploy the application to Azure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序部署到 Azure 之前，我们需要以下资源：
- en: '**Azure DevOps** **account**: [https://azure.microsoft.com/en-us/products/devops](https://azure.microsoft.com/en-us/products/devops).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure DevOps 账户**：[https://azure.microsoft.com/en-us/products/devops](https://azure.microsoft.com/en-us/products/devops)。'
- en: '**Azure subscription**: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
    You can sign up for a free account here. You will get some free credits to use
    Azure services.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 订阅**：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。您可以在这里注册一个免费账户。您将获得一些免费积分来使用
    Azure 服务。'
- en: '**GitHub repository**: You need a GitHub repository to host the source code.
    The pipeline will be triggered when code changes are committed to the repository.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub 仓库**：您需要一个 GitHub 仓库来托管源代码。当代码更改提交到仓库时，将触发管道。'
- en: Preparing the source code
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备源代码
- en: GitHub is one of the most popular source control solutions. It is free for public
    repositories. We suppose you already have a GitHub account.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 是最受欢迎的源代码控制解决方案之一。对于公开仓库，它是免费的。我们假设您已经有了 GitHub 账户。
- en: 'Download the example code from [/chapter14/MyBasicWebApiDemo](https://h/chapter14/MyBasicWebApiDemo).
    This is a simple ASP.NET Core web API application with its unit tests and integration
    tests. Create a new repository on GitHub, then push the source code to the repository.
    The directory structure of the repository should look like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [/chapter14/MyBasicWebApiDemo](https://h/chapter14/MyBasicWebApiDemo) 下载示例代码。这是一个简单的
    ASP.NET Core Web API 应用程序，包括其单元测试和集成测试。在 GitHub 上创建一个新的仓库，然后将源代码推送到该仓库。仓库的目录结构应如下所示：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding directory structure, the main ASP.NET Core web API project
    is placed in the `src` folder, and the unit tests and integration tests are placed
    in the `tests` folder. This can better organize the solution structure. But it
    is just a personal preference. You can also place the unit tests and integration
    tests in the same folder as the main project. If you use a different directory
    structure, please update the paths in the pipeline accordingly in the following
    sections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述目录结构中，主要的 ASP.NET Core Web API 项目位于 `src` 文件夹中，单元测试和集成测试位于 `tests` 文件夹中。这可以更好地组织解决方案结构。但这只是个人偏好。您也可以将单元测试和集成测试放在与主要项目相同的文件夹中。如果您使用不同的目录结构，请在以下章节中相应地更新管道中的路径。
- en: We will use this repository for the pipeline. Next, let us create the required
    Azure resources.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此仓库进行管道。接下来，让我们创建所需的 Azure 资源。
- en: Creating Azure resources
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure 资源
- en: In today’s technology landscape, cloud computing has become the backbone of
    modern software development. Cloud computing provides many benefits, such as scalability,
    **high availability** (**HA**), and cost efficiency. Among the various cloud providers,
    such as AWS, GCP, and Alibaba Cloud, Microsoft Azure stands out as a robust and
    versatile platform for hosting and orchestrating your applications. Azure provides
    many services for hosting applications, such as Azure App Service, **Azure Kubernetes
    Service** (**AKS**), **Azure Container Instances** (**ACI**), Azure VMs, and Azure
    Functions. In this book, we will use Azure as the cloud platform to host our applications.
    For other cloud platforms, the concepts are similar.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的技术格局中，云计算已成为现代软件开发的核心。云计算提供了许多好处，例如可扩展性、**高可用性**（**HA**）和成本效益。在各种云服务提供商中，如
    AWS、GCP 和阿里云，Microsoft Azure 作为一种强大且灵活的平台脱颖而出，用于托管和编排您的应用程序。Azure 为托管应用程序提供了许多服务，例如
    Azure App Service、**Azure Kubernetes Service**（**AKS**）、**Azure Container Instances**（**ACI**）、Azure
    VM 和 Azure Functions。在这本书中，我们将使用 Azure 作为云平台来托管我们的应用程序。对于其他云平台，概念是相似的。
- en: 'We will need the following Azure resources:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下 Azure 资源：
- en: '**Azure Container Registry**: A private registry for storing Docker images.
    You can create a new Azure container registry in the Azure portal. Please refer
    to the official documentation here: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal).'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Container Registry**：一个用于存储 Docker 镜像的私有注册库。您可以在 Azure 门户中创建一个新的 Azure
    容器注册库。请参阅以下官方文档：[https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal)。'
- en: '**Azure Web App for Containers**: A service for hosting containerized web applications.
    It provides a quick and easy way to build, deploy, and scale enterprise-grade
    web, mobile, and API apps on any platform. You can create a new Azure Web App
    for Containers instance in the Azure portal. Please refer to the official documentation
    here: [https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&pivots=container-linux-azure-portal](https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&pivots=container-linux-azure-portal).
    Please select **Docker Container** for the **Publish** option, and select **Linux**
    for the **Operating System** option when creating the Web App for Containers instance
    because we are using Linux containers in this chapter.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Web App for Containers**：一个用于托管容器化 Web 应用的服务。它提供了一种快速简单的方式，在任何平台上构建、部署和扩展企业级
    Web、移动和 API 应用。您可以在 Azure 门户中创建一个新的 Azure Web App for Containers 实例。请参阅以下官方文档：[https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&pivots=container-linux-azure-portal](https://learn.microsoft.com/en-us/azure/app-service/quickstart-custom-container?tabs=dotnet&pivots=container-linux-azure-portal)。在创建
    Web 应用容器实例时，请选择**Docker 容器**作为**发布**选项，并选择**Linux**作为**操作系统**选项，因为我们在这个章节中使用的是
    Linux 容器。'
- en: 'Note that you can also choose Azure App Service to host your application without
    containerization. Azure App Service supports many programming languages and frameworks,
    such as .NET, .NET Core, Java, Node.js, Python, and so on. It also supports containers.
    You can learn more about Azure App Service here: [https://docs.microsoft.com/en-us/azure/app-service/overview](https://docs.microsoft.com/en-us/azure/app-service/overview).
    In this section, we will explore how to deploy applications in containers, so
    we will use Azure Web App for Containers in the following example.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还可以选择 Azure App Service 来托管您的应用程序而无需容器化。Azure App Service 支持许多编程语言和框架，例如
    .NET、.NET Core、Java、Node.js、Python 等。它还支持容器。您可以在以下链接中了解更多关于 Azure App Service
    的信息：[https://docs.microsoft.com/en-us/azure/app-service/overview](https://docs.microsoft.com/en-us/azure/app-service/overview)。在本节中，我们将探讨如何部署容器中的应用程序，因此以下示例我们将使用
    Azure Web App for Containers。
- en: 'To better manage these resources, it is recommended to create a resource group
    to group these resources together. You can create a new resource group in the
    Azure portal or create a new resource group when you create a new resource. Here
    is key information on the resources we need to prepare for the pipelines:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地管理这些资源，建议创建一个资源组将这些资源分组在一起。您可以在 Azure 门户中创建一个新的资源组，或者在创建新资源时创建一个新的资源组。以下是我们需要为管道准备的关键资源信息：
- en: Resource group
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 资源组
- en: 'name: `devops-lab`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: `devops-lab`'
- en: Container registry
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册库
- en: 'name: `devopscrlab`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: `devopscrlab`'
- en: 'Web App for Containers instance:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 容器实例 Web 应用：
- en: 'name: `azure-pipeline-demo`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: `azure-pipeline-demo`'
- en: "You can use either the Azure portal or Azure CLI to create these resources.\
    \ Defining the scripts to create the resources in code is a good practice, which\
    \ is called **infrastructure as code** (**IaC**). However, we will not cover IaC\
    \ here because it is out of the scope of this book. You can learn more about IaC\
    \ here: [https://learn.microsoft.com/en-us/devops/deliver/what-is-infrastructure-as-code](https://learn.microsoft.com/en-us/devops/deliver/what-is\uFEFF\
    -infrastructure-as-code)."
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: "您可以使用 Azure 门户或 Azure CLI 来创建这些资源。在代码中定义创建资源的脚本是一种良好的实践，这被称为**基础设施即代码**（**IaC**）。然而，我们在这里不会涵盖\
    \ IaC，因为它超出了本书的范围。您可以在以下链接中了解更多关于 IaC 的信息：[https://learn.microsoft.com/en-us/devops/deliver/what-is-infrastructure-as-code](https://learn.microsoft.com/en-us/devops/deliver/what-is\uFEFF\
    -infrastructure-as-code)。"
- en: Next, let us create an Azure DevOps project.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个 Azure DevOps 项目。
- en: Creating an Azure DevOps project
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure DevOps 项目
- en: 'As the official documentation provides detailed instructions on how to create
    an Azure DevOps project, we will not cover the details here. Please refer to the
    official documentation here: [https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops](https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于官方文档提供了如何创建 Azure DevOps 项目的详细说明，我们在这里不会涵盖细节。请参考以下官方文档：[https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops](https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/pipelines-sign-up?view=azure-devops)。
- en: You need to follow the official documentation to create an Azure DevOps account.
    You can sign up with a Microsoft account or a GitHub account. Once you create
    an Azure DevOps account, you can create a new organization. An organization is
    a container for projects and teams. You can create multiple organizations with
    one Azure DevOps account.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要遵循官方文档来创建 Azure DevOps 账户。您可以使用 Microsoft 账户或 GitHub 账户注册。一旦创建了 Azure DevOps
    账户，您就可以创建一个新的组织。组织是项目和团队的一个容器。您可以使用一个 Azure DevOps 账户创建多个组织。
- en: 'Next, you can create a new project in Azure DevOps. Click the **New project**
    button on the home page, then follow the instructions to create a new project
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以在 Azure DevOps 中创建一个新项目。点击主页上的 **New project** 按钮，然后按照以下说明创建新项目：
- en: '![Figure 14.5 – Creating a new project in Azure DevOps](img/B18971_14_05.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 在 Azure DevOps 中创建新项目](img/B18971_14_05.jpg)'
- en: Figure 14.5 – Creating a new project in Azure DevOps
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 在 Azure DevOps 中创建新项目
- en: 'We will create these pipelines in the project in the next sections:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中创建这些管道：
- en: '**Pull request build pipeline**: A pipeline for building the application and
    running tests when a pull request is created. This pipeline will be triggered
    when a pull request is created in the GitHub repository. If the build fails or
    the tests fail, the pull request cannot be merged.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取请求构建管道**：当创建拉取请求时构建应用程序并运行测试的管道。当在 GitHub 仓库中创建拉取请求时，此管道将被触发。如果构建失败或测试失败，则无法合并拉取请求。'
- en: '`main` branch.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` 分支。'
- en: '**Release pipeline**: A pipeline for deploying the application to Azure Container
    Apps. This pipeline can be triggered when a new image is published to ACR, or
    it can be triggered manually.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布管道**：将应用程序部署到 Azure Container Apps 的管道。此管道可以在将新镜像发布到 ACR 时触发，也可以手动触发。'
- en: Creating a pull request pipeline
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建拉取请求管道
- en: 'In this section, we will create a pull request build pipeline. Follow the steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个拉取请求构建管道。请按照以下步骤操作：
- en: 'Navigate to the Azure DevOps portal, click the **Pipelines** tab on the left
    side, and then click the **Create Pipeline** button. You will see a page like
    this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Azure DevOps 门户，点击左侧的 **Pipelines** 选项卡，然后点击 **Create Pipeline** 按钮。您将看到一个类似这样的页面：
- en: '![Figure 14.6 – Creating a new pipeline in Azure DevOps](img/B18971_14_06.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – 在 Azure DevOps 中创建新管道](img/B18971_14_06.jpg)'
- en: Figure 14.6 – Creating a new pipeline in Azure DevOps
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 在 Azure DevOps 中创建新管道
- en: 'Azure DevOps Pipelines supports various sources, such as Azure Repos, GitHub,
    Bitbucket, and Subversion. We already have a GitHub repository, so we will use
    GitHub as the source. Click the **GitHub** button, then follow the instructions
    to authorize Azure DevOps to access your GitHub account. Once you have authorized
    Azure DevOps to access your GitHub account, you will see a list of repositories
    in your GitHub account. Select the repository we created earlier; you will be
    navigated to GitHub and see a page where you can install Azure Pipelines to the
    repository. Click the **Approve and install** button to install Azure Pipelines
    to the repository. Then, you will be navigated back to Azure DevOps. You will
    see a page like this:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure DevOps 管道支持各种源，例如 Azure Repos、GitHub、Bitbucket 和 Subversion。我们已经有了一个 GitHub
    仓库，所以我们将使用 GitHub 作为源。点击 **GitHub** 按钮，然后按照说明授权 Azure DevOps 访问您的 GitHub 账户。一旦您授权
    Azure DevOps 访问您的 GitHub 账户，您将看到您 GitHub 账户中的仓库列表。选择我们之前创建的仓库；您将被导航到 GitHub 并看到一个可以安装
    Azure Pipelines 到仓库的页面。点击 **批准并安装** 按钮将 Azure Pipelines 安装到仓库。然后，您将被导航回 Azure
    DevOps。您将看到一个类似这样的页面：
- en: '![Figure 14.7 – Configuring the pipeline](img/B18971_14_07.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 配置管道](img/B18971_14_07.jpg)'
- en: Figure 14.7 – Configuring the pipeline
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 配置管道
- en: 'Azure DevOps Pipelines can provide various templates for your project. In this
    case, you can choose the **ASP.NET** template to start with. Azure DevOps Pipelines
    can automatically detect the source code and generate a basic pipeline for you.
    The default pipeline is a YAML file, which may look like this:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure DevOps 管道可以为您的项目提供各种模板。在这种情况下，您可以选择 **ASP.NET** 模板开始。Azure DevOps 管道可以自动检测源代码并为您生成一个基本管道。默认管道是一个
    YAML 文件，可能看起来像这样：
- en: '[PRE32]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The default pipeline is targeting Windows. We will run the application in a
    Linux container, so we need to make some changes to the pipeline. Delete the default
    content and we will start from scratch.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认管道针对 Windows。我们将在一个 Linux 容器中运行应用程序，因此需要对管道进行一些修改。删除默认内容，我们将从头开始。
- en: 'First, rename the pipeline to `pr-build-pipeline`. You can rename the pipeline
    by clicking the `.``yml` filename:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将管道重命名为 `pr-build-pipeline`。您可以通过点击 `.``yml` 文件名来重命名管道：
- en: '![Figure 14.8 – Renaming the pipeline](img/B18971_14_08.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 重命名管道](img/B18971_14_08.jpg)'
- en: Figure 14.8 – Renaming the pipeline
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 重命名管道
- en: 'Then, we need to update the trigger to make the pipeline run when a pull request
    is opened or updated for one of the target branches. Use the `pr` keyword to indicate
    that the pipeline will be triggered by a pull request for the `main` branch:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新触发器，以便在为目标分支之一打开或更新拉取请求时运行管道。使用 `pr` 关键字表示管道将由 `main` 分支的拉取请求触发：
- en: '[PRE33]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, set `pool` to use the `ubuntu-latest` image. The `ubuntu-latest` image
    is a Linux image, which is smaller than a Windows image. Also, the application
    is targeting Linux containers, so it is better to use a Linux image:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `pool` 设置为使用 `ubuntu-latest` 镜像。`ubuntu-latest` 镜像是 Linux 镜像，比 Windows
    镜像小。此外，应用程序针对 Linux 容器，因此最好使用 Linux 镜像：
- en: '[PRE34]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, create some variables for the solution path, build configuration, and
    so on:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为解决方案路径、构建配置等创建一些变量：
- en: '[PRE35]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we need to add some tasks. Add a `steps:` section, then add the following
    tasks:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一些任务。添加一个 `steps:` 部分，然后添加以下任务：
- en: '[PRE36]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `UseDotNet@2` task is used to install the .NET SDK so that we can use the
    .NET CLI to execute commands. In this case, we are installing the .NET 8.0 SDK.
    The `includePreviewVersions` option is used to include preview versions of the
    .NET SDK. We need to use the preview version because the .NET 8.0 SDK is still
    in preview at the time of writing this book. If you are reading this book after
    the .NET 8.0 SDK is released, you can remove the `includePreviewVersions` option.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UseDotNet@2` 任务用于安装 .NET SDK，以便我们可以使用 .NET CLI 执行命令。在这种情况下，我们正在安装 .NET 8.0
    SDK。`includePreviewVersions` 选项用于包含 .NET SDK 的预览版本。我们需要使用预览版本，因为本书编写时 .NET 8.0
    SDK 仍在预览中。如果您在 .NET 8.0 SDK 发布后阅读此书，您可以删除 `includePreviewVersions` 选项。'
- en: 'The online pipeline editor provides IntelliSense for the YAML file like this:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在线管道编辑器为 YAML 文件提供了类似于这样的 IntelliSense：
- en: '![Figure 14.9 – IntelliSense for YAML file](img/B18971_14_09.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – YAML 文件的 IntelliSense](img/B18971_14_09.jpg)'
- en: Figure 14.9 – IntelliSense for YAML file
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – YAML 文件的 IntelliSense
- en: 'You can click the **Settings** link above the task to configure the task in
    a dialog box:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以点击任务上方的 **设置** 链接，在对话框中配置任务：
- en: '![Figure 14.10 – Configuring the task in a dialog box](img/B18971_14_10.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 在对话框中配置任务](img/B18971_14_10.jpg)'
- en: Figure 14.10 – Configuring the task in a dialog box
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 在对话框中配置任务
- en: 'Next, add a `DotNetCoreCLI@2` task to build the application:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个 `DotNetCoreCLI@2` 任务来构建应用程序：
- en: '[PRE37]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `DotNetCoreCLI@2` task is used to run dotnet CLI commands. In this case,
    we are running the `dotnet build` command to build the application. The `--configuration`
    option is used to specify the build configuration. The `--runtime` option is used
    to specify the target runtime. In this case, we are targeting the Linux runtime.
    The `projects` option is used to specify the path to the `.csproj` file or solution
    file. In this case, we are using the `$(solution)` variable we defined earlier.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DotNetCoreCLI@2` 任务用于运行 dotnet CLI 命令。在这种情况下，我们正在运行 `dotnet build` 命令来构建应用程序。`--configuration`
    选项用于指定构建配置。`--runtime` 选项用于指定目标运行时。在这种情况下，我们针对 Linux 运行时。`projects` 选项用于指定 `.csproj`
    文件或解决方案文件的路径。在这种情况下，我们使用我们之前定义的 `$(solution)` 变量。'
- en: 'Next, add tasks to run unit tests and integration tests:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加任务来运行单元测试和集成测试：
- en: '[PRE38]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding tasks, we are running the `dotnet test` command to run unit
    tests and integration tests. The `--no-build` option is used to skip building
    the application. The `--no-restore` option is used to skip restoring the NuGet
    packages because we have already restored the packages and built the application
    in the previous tasks. The other options are used to specify the logger and collect
    code coverage.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的任务中，我们正在运行 `dotnet test` 命令来运行单元测试和集成测试。`--no-build` 选项用于跳过构建应用程序。`--no-restore`
    选项用于跳过还原 NuGet 包，因为我们已经在前面的任务中还原了包并构建了应用程序。其他选项用于指定记录器和收集代码覆盖率。
- en: 'Click the **Save and run** button to commit the changes and run the pipeline.
    You will see the pipeline is running. After a while, the pipeline will be completed:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存并运行** 按钮提交更改并运行管道。你会看到管道正在运行。过了一会儿，管道将完成：
- en: '![Figure 14.11 – The pipeline is successful](img/B18971_14_11.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 管道成功](img/B18971_14_11.jpg)'
- en: Figure 14.11 – The pipeline is successful
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 管道成功
- en: 'Click the **Tests** tab and you will then see the test results:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **测试** 选项卡，然后你会看到测试结果：
- en: '![Figure 14.12 – The test results](img/B18971_14_12.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 测试结果](img/B18971_14_12.jpg)'
- en: Figure 14.12 – The test results
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 测试结果
- en: 'You can also check the code coverage as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以按照以下方式检查代码覆盖率：
- en: '![Figure 14.13 – The code coverage](img/B18971_14_13.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13 – 代码覆盖率](img/B18971_14_13.jpg)'
- en: Figure 14.13 – The code coverage
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 – 代码覆盖率
- en: We just manually triggered the first run of the pipeline. Next, let us create
    a pull request and see how the pipeline is triggered.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚手动触发了管道的第一次运行。接下来，让我们创建一个拉取请求并看看管道是如何触发的。
- en: 'Create a new branch and make some changes to the source code. For example,
    we can return 6 items instead of 5 items in `WeatherForecastController`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的分支并对源代码进行一些更改。例如，我们可以在 `WeatherForecastController` 中返回 6 个项目而不是 5 个项目：
- en: '[PRE39]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, commit the changes and push the changes to the remote repository. You
    will find the pipeline runs for the new branch as well. That is because YAML pipelines
    are enabled by default for all branches. You can disable this feature by using
    the `trigger none` option. Add the following line to the beginning of the YAML
    file:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，提交更改并将更改推送到远程仓库。你会发现管道也会为新分支运行。这是因为 YAML 管道默认对所有分支启用。你可以使用 `trigger none`
    选项禁用此功能。将以下行添加到 YAML 文件的开始部分：
- en: '[PRE40]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then, this pipeline will not be triggered automatically for new branches but
    will be triggered by pull requests.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，此管道不会自动为新分支触发，而是由拉取请求触发。
- en: 'Next, create a new pull request in the GitHub repository. You will see the
    pipeline is triggered automatically and then fails:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 GitHub 仓库中创建一个新的拉取请求。你会看到管道会自动触发然后失败：
- en: '![Figure 14.14 – The pipeline is triggered by the pull request but fails](img/B18971_14_14.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14 – 拉取请求触发的管道但失败](img/B18971_14_14.jpg)'
- en: Figure 14.14 – The pipeline is triggered by the pull request but fails
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 – 拉取请求触发的管道但失败
- en: 'In this case, we cannot merge the pull request because the build pipeline failed.
    You can check the logs to see what is wrong with the pipeline. In this case, the
    pipeline failed because the unit tests failed:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们无法合并拉取请求，因为构建管道失败了。你可以检查日志来查看管道哪里出了问题。在这种情况下，管道失败是因为单元测试失败了：
- en: '![Figure 14.15 – The unit tests failed](img/B18971_14_15.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图14.15 – 单元测试失败](img/B18971_14_15.jpg)'
- en: Figure 14.15 – The unit tests failed
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 – 单元测试失败
- en: 'Click the **Tests** tab and you will then see the test results:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试**选项卡，然后您将看到测试结果：
- en: '![Figure 14.16 – The unit tests results](img/B18971_14_16.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图14.16 – 单元测试结果](img/B18971_14_16.jpg)'
- en: Figure 14.16 – The unit tests results
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 – 单元测试结果
- en: The details of the failed test case can help us to identify the problem. Next,
    you can fix the error and push the changes to the remote repository. Then, the
    pipeline will be triggered again. If the pipeline is successful, you can merge
    the pull request.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 失败测试用例的详细信息可以帮助我们识别问题。接下来，您可以修复错误并将更改推送到远程仓库。然后，管道将被再次触发。如果管道成功，您可以将提交请求合并。
- en: The pull request build pipeline is used to ensure that code changes do not break
    the application. It is important to run the tests before merging the pull request.
    Next, let us create a CI build pipeline to build the Docker image and publish
    it to ACR.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 提交请求构建管道用于确保代码更改不会破坏应用程序。在合并提交请求之前运行测试非常重要。接下来，让我们创建一个CI构建管道来构建Docker镜像并将其发布到ACR。
- en: Publishing the Docker image to ACR
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Docker镜像发布到ACR
- en: In the previous section, we created a pull request build pipeline to validate
    code changes in pull requests. The pipeline will be triggered when a pull request
    is created or updated. Once the pull request is merged to the `main` branch, we
    can automatically build the Docker image and publish it to ACR. To do that, we
    will create a CI build pipeline following these steps
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个提交请求构建管道来验证提交请求中的代码更改。当创建或更新提交请求时，该管道将被触发。一旦提交请求合并到`main`分支，我们就可以自动构建Docker镜像并将其发布到ACR。为此，我们将按照以下步骤创建CI构建管道
- en: 'Create a new pipeline following the same steps as we did in the previous section.
    In the configure step, we can choose the `pr-build-pipeline.yml` file we created
    in the previous section:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照上一节中的步骤创建一个新的管道。在配置步骤中，我们可以选择上一节中创建的`pr-build-pipeline.yml`文件：
- en: '![Figure 14.17 – Choosing an existing YAML file to start with](img/B18971_14_17.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图14.17 – 选择一个现有的YAML文件开始](img/B18971_14_17.jpg)'
- en: Figure 14.17 – Choosing an existing YAML file to start with
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 – 选择一个现有的YAML文件开始
- en: 'A better way is to choose the **Docker - Build and push an image to Azure Container
    Registry** template, which is exactly what we need. You will be prompted to configure
    your Azure subscription, ACR, and so on:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的方法是选择**Docker - 构建并推送镜像到Azure容器注册库**模板，这正是我们需要的。您将被提示配置您的Azure订阅、ACR等：
- en: '![Figure 14.18 – Configuring ACR, Dockerfile, and image name](img/B18971_14_18.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图14.18 – 配置ACR、Dockerfile和镜像名称](img/B18971_14_18.jpg)'
- en: Figure 14.18 – Configuring ACR, Dockerfile, and image name
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 – 配置ACR、Dockerfile和镜像名称
- en: 'Azure Pipelines will automatically detect the Dockerfile and generate a pipeline
    for you. The default pipeline may look like this:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Pipelines将自动检测Dockerfile并为您生成一个管道。默认管道可能看起来像这样：
- en: '[PRE41]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Azure Pipelines has recognized the path of the Dockerfile in the preceding pipeline.
    Additionally, several variables must be configured, such as the image name and
    container registry. The `tag` variable is used to tag the image with the build
    ID. Note that we added a `latest` tag to the image. The `latest` tag is used to
    indicate the latest version of the image.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Azure Pipelines已识别前一个管道中Dockerfile的路径。此外，必须配置一些变量，例如镜像名称和容器注册库。`tag`变量用于使用构建ID标记镜像。请注意，我们在镜像中添加了一个`latest`标记。`latest`标记用于指示镜像的最新版本。
- en: Azure Pipelines predefined variables
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines预定义变量
- en: 'Azure Pipelines provides many predefined variables that can be used in a pipeline.
    For example, the `$(Build.SourcesDirectory)` variable is used to obtain the local
    path on the agent where the source code files have been downloaded. You can find
    all the predefined variables here: [https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml](https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines提供了许多预定义变量，可以在管道中使用。例如，`$(Build.SourcesDirectory)`变量用于获取代理上已下载源代码文件的本地路径。您可以在以下位置找到所有预定义变量：[https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml](https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml)。
- en: 'The difference from a pull request build pipeline is that we have **stages**
    and **jobs** in the pipeline. *Figure 14**.19* shows the structure of a pipeline:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 与拉取请求构建流水线的不同之处在于，我们在流水线中拥有**阶段**和**作业**。*图14*.*19*显示了流水线的结构：
- en: '![Figure 14.19 – The structure of a pipeline](img/B18971_14_19.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图14.19 – 流水线的结构](img/B18971_14_19.jpg)'
- en: Figure 14.19 – The structure of a pipeline
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19 – 流水线的结构
- en: 'The components in *Figure 14**.19* are explained as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14*.*19*中的组件解释如下：'
- en: A trigger is used to specify when the pipeline should run. It can be a schedule,
    a pull request, a commit to a specific branch, or a manual trigger.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器用于指定流水线何时运行。它可以是计划、拉取请求、对特定分支的提交或手动触发。
- en: A pipeline contains one or more stages. A stage is used to organize jobs. In
    the pull request build pipeline, the stage is omitted. You can have multiple stages
    in one pipeline for different purposes. For example, you can have a build stage,
    a test stage, and a deploy stage. The stage can be also used to set boundaries
    for security and approvals.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线包含一个或多个阶段。阶段用于组织作业。在拉取请求构建流水线中，阶段被省略。您可以在一个流水线中拥有多个阶段，用于不同的目的。例如，您可以有一个构建阶段、测试阶段和部署阶段。阶段还可以用于设置安全和审批的边界。
- en: Each stage contains one or more jobs. A job is a container of steps. A job can
    run on one agent or without an agent. For example, you can have a job that runs
    on a Windows agent, and another job that runs on a Linux agent.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个阶段包含一个或多个作业。作业是一系列步骤的容器。作业可以在一个代理上运行，也可以在没有代理的情况下运行。例如，您可以有一个在Windows代理上运行的作业，另一个在Linux代理上运行的作业。
- en: 'Each job contains one or more steps. A step is the smallest building block
    in a pipeline. A step is normally a task or a script. Azure Pipelines provides
    many built-in tasks, such as the `Docker@2` task we are using in this pipeline.
    A built-in task is a predefined packaged script that performs an action. You can
    also write your own custom tasks. A task can be a command-line tool, a script,
    or a compiled program. You can find all built-in tasks here: [https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines).'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个作业包含一个或多个步骤。步骤是流水线中最小的构建块。步骤通常是一个任务或脚本。Azure Pipelines提供了许多内置任务，例如我们在这个流水线中使用的`Docker@2`任务。内置任务是一个预定义的打包脚本，用于执行操作。您也可以编写自己的自定义任务。任务可以是命令行工具、脚本或编译程序。您可以在以下位置找到所有内置任务：[https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/?view=azure-pipelines)。
- en: In the preceding pipeline, we have one stage, one job, and one step. The step
    is the `Docker@2` task. The `Docker@2` task is used to build and push a Docker
    image to a container registry. Using this task simplifies the process of building
    and pushing a Docker image so that we do not need to write `docker build` commands
    manually.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的流水线中，我们有一个阶段、一个作业和一个步骤。步骤是`Docker@2`任务。`Docker@2`任务用于构建和推送Docker镜像到容器注册库。使用此任务简化了构建和推送Docker镜像的过程，因此我们不需要手动编写`docker
    build`命令。
- en: 'Rename this pipeline to `docker-build-pipeline`. Similarly to `pr-build-pipeline`,
    we need to exclude the `docker-build-pipeline` pipeline from running for new branches
    and pull requests. Add the following line to the beginning of the YAML file:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此流水线重命名为`docker-build-pipeline`。类似于`pr-build-pipeline`，我们需要排除`docker-build-pipeline`流水线在新分支和拉取请求中的运行。将以下行添加到YAML文件的开始部分：
- en: '[PRE42]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, when we create a new branch or a new pull request, the `docker-build-pipeline`
    will not be triggered automatically. We will trigger the pipeline manually or
    by merging a pull request.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，当我们创建一个新的分支或新的拉取请求时，`docker-build-pipeline`不会自动触发。我们将手动触发流水线或通过合并拉取请求来触发。
- en: Click the `docker-build-pipeline` is triggered automatically.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`docker-build-pipeline`将自动触发。
- en: 'If everything is fine, you will see the `docker-build-pipeline` pipeline is
    successful and the Docker image is published to ACR:'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切正常，您将看到`docker-build-pipeline`流水线成功，并且Docker镜像已发布到ACR：
- en: '![Figure 14.20 – The Docker image is published to ACR](img/B18971_14_20.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图14.20 – Docker镜像已发布到ACR](img/B18971_14_20.jpg)'
- en: Figure 14.20 – The Docker image is published to ACR
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20 – Docker镜像已发布到ACR
- en: 'A CI pipeline is a good practice to ensure that code changes can be built successfully
    without breaking the application. However, some changes may not need running tests
    or rebuilding the Docker image. For example, if you only change the documentation,
    (for example, the `README` file), you do not need to run the tests or rebuild
    the Docker image. In this case, you have a few options:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: CI管道是一个良好的实践，以确保代码更改可以在不破坏应用程序的情况下成功构建。然而，某些更改可能不需要运行测试或重新构建Docker镜像。例如，如果你只更改了文档（例如，`README`文件），你不需要运行测试或重新构建Docker镜像。在这种情况下，你有几种选择：
- en: 'You can exclude some files from the pipeline. For example, you can exclude
    the `README.md` file from the pipeline. You can use the `paths` option to specify
    paths to include or exclude, as follows:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以排除一些文件从管道中。例如，你可以排除`README.md`文件。你可以使用`paths`选项来指定包含或排除的路径，如下所示：
- en: '[PRE43]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can skip CI pipelines for some commits. Use `[skip ci]` in the commit message
    to skip CI pipelines. For example, you can use `[skip ci] update README` in the
    commit message to skip CI pipelines for this commit. Some variations include `[ci
    skip]`, `[skip azurepipelines]`, `[skip azpipelines]`, `[skip azp]`, and so on.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以跳过某些提交的CI管道。在提交信息中使用`[skip ci]`来跳过CI管道。例如，你可以在提交信息中使用`[skip ci] update README`来跳过此提交的CI管道。一些变体包括`[ci
    skip]`、`[skip azurepipelines]`、`[skip azpipelines]`、`[skip azp]`等等。
- en: 'You may encounter some errors when creating pipelines. Here are some troubleshooting
    tips:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建管道时可能会遇到一些错误。以下是一些故障排除技巧：
- en: Check the logs carefully. The logs can help you to identify the problem.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细检查日志。日志可以帮助你识别问题。
- en: Check the variables. Make sure the variables are correct.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查变量。确保变量正确。
- en: Check the permissions. Make sure the service connection has the correct permissions.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查权限。确保服务连接具有正确的权限。
- en: Check the YAML syntax. Make sure the YAML file is valid. YAML files use indentation
    to indicate the structure. Make sure the indentation is correct.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查YAML语法。确保YAML文件有效。YAML文件使用缩进来表示结构。请确保缩进正确。
- en: Check the pipeline structure. Make sure the pipeline structure is correct. For
    example, make sure the `steps` section is under the `jobs` section and the `jobs`
    section is under the `stages` section.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查管道结构。确保管道结构正确。例如，确保`steps`部分位于`jobs`部分之下，而`jobs`部分位于`stages`部分之下。
- en: Check the pipeline triggers. Make sure the pipeline is triggered by the correct
    event. You can use `branches`, `paths`, `include`, and `exclude` to specify branches
    and paths to trigger the pipeline.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查管道触发器。确保管道由正确的事件触发。你可以使用`branches`、`paths`、`include`和`exclude`来指定触发管道的分支和路径。
- en: Note that if you edit the pipeline YAML file in the online editor, you will
    commit the changes to the `main` branch directly. Your local `feature` branch
    will not be updated automatically. When you push a change to your feature branch,
    whether the pipeline should be triggered depends on the settings in the YAML file
    in your feature branch, not the `main` branch. So, make sure your feature branch
    keeps synchronized with the `main` branch.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，如果你在在线编辑器中编辑管道YAML文件，你将直接将更改提交到`main`分支。你的本地`feature`分支将不会自动更新。当你将更改推送到feature分支时，是否触发管道取决于你feature分支中的YAML文件设置，而不是`main`分支。因此，请确保你的feature分支与`main`分支保持同步。
- en: If you use VS to create the Dockerfile, double-check the paths in the Dockerfile.
    Sometimes, VS cannot detect the correct paths if you use a custom solution structure.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用VS创建Dockerfile，请仔细检查Dockerfile中的路径。有时，如果你使用自定义解决方案结构，VS可能无法检测到正确的路径。
- en: We have now pushed the Docker image to ACR. Next, let's create a release pipeline
    to deploy the application to Azure Web App for Containers.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将Docker镜像推送到ACR。接下来，让我们创建一个发布管道，将应用程序部署到Azure Web App for Containers。
- en: Deploying the application to Azure Web App for Containers
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用程序部署到Azure Web App for Containers
- en: In the previous section, we created a CI build pipeline to build the Docker
    image and publish it to ACR. In this section, we will create a release pipeline
    to pull the Docker image from ACR and deploy it to Azure Web App for Containers.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个CI构建管道来构建Docker镜像并将其发布到ACR。在本节中，我们将创建一个发布管道，从ACR拉取Docker镜像并将其部署到Azure
    Web App for Containers。
- en: 'Follow the steps in the previous section to create a new pipeline. When we
    configure the pipeline, choose the **Starter pipeline** template because we will
    start from scratch. The default starter pipeline has two scripts as examples.
    Delete the scripts, and it should look like this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一节中的步骤创建一个新的管道。当我们配置管道时，选择**入门级管道**模板，因为我们将从零开始。默认的入门级管道包含两个脚本作为示例。删除这些脚本，它应该如下所示：
- en: '[PRE44]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can disable the triggers for the pipeline because we will manually run the
    pipeline when we need to deploy the application. Rename the pipeline as `release-pipeline`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以禁用管道的触发器，因为我们将在需要部署应用程序时手动运行管道。将管道重命名为`release-pipeline`。
- en: 'Next, add some variables to the pipeline:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向管道中添加一些变量：
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we need to configure the username and password to authenticate the pipeline
    to pull the Docker image from ACR. You can find the username and password of your
    ACR instance in the Azure portal. Click the **Access keys** button on the left
    side, and you will then see the username and password.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置用户名和密码以验证管道从 ACR 拉取 Docker 镜像。您可以在 Azure 门户中找到您的 ACR 实例的用户名和密码。点击左侧的**访问密钥**按钮，然后您将看到用户名和密码。
- en: 'As the password is a secret, we cannot use it in the YAML file directly, otherwise
    the password will be exposed in the GitHub repository. Azure Pipelines provides
    a way to store secrets in the pipeline. Click the **Variables** button in the
    top-right corner, then click the **New variable** button to add a new variable:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密码是秘密，我们无法直接在 YAML 文件中使用它，否则密码将在 GitHub 仓库中暴露。Azure Pipelines 提供了一种在管道中存储秘密的方法。点击右上角的**变量**按钮，然后点击**新建变量**按钮以添加新变量：
- en: '![Figure 14.21 – Adding a new variable to store the password](img/B18971_14_21.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.21 – 添加新变量以存储密码](img/B18971_14_21.jpg)'
- en: Figure 14.21 – Adding a new variable to store the password
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21 – 添加新变量以存储密码
- en: Check the `$(acrpassword)` variable to refer to the password.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`$(acrpassword)`变量以引用密码。
- en: 'Next, add a task to set up the Azure App Service settings. Choose the **Azure
    App Service Settings** task from the task assistant. We need to add the credentials
    to authenticate the Azure Web App to pull the Docker image from ACR. Azure Pipelines
    will prompt you to configure the task. Note that the **App settings** field is
    a JSON string. The tasks should look like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个任务来设置 Azure App Service 设置。从任务助手中选择**Azure App Service 设置**任务。我们需要添加凭据以验证
    Azure Web App 从 ACR 拉取 Docker 镜像。Azure Pipelines 将提示您配置任务。请注意，**应用设置**字段是一个 JSON
    字符串。任务应如下所示：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the `appSettings` field, we use the `$(acrpassword)` variable to refer to
    the password we created earlier.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在`appSettings`字段中，我们使用`$(acrpassword)`变量来引用我们之前创建的密码。
- en: 'Next, click the **Show assistant** button in the top-right corner to open the
    assistant. The assistant helps us to use the built-in tasks easily. Choose the
    **Azure Web App for Containers** task that is used to deploy the Docker image
    from ACR to Azure Web App for Containers. Azure Pipelines will prompt you to configure
    the task. Configure the task as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击右上角的**显示助手**按钮以打开助手。助手帮助我们轻松使用内置任务。选择**用于容器的 Azure Web App**任务，该任务用于将
    ACR 中的 Docker 镜像部署到 Azure Web App for Containers。Azure Pipelines 将提示您配置任务。按照以下方式配置任务：
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alternatively, you can use the **Azure App Service Deploy** task from the assistant.
    This task is used to deploy the application to Azure Web App that supports either
    native deployment or container deployment. You need to configure the Azure subscription,
    App Service type, and so on. When you choose the **Web App for Containers (Linux)**
    option for **App Service type**, you will be prompted to configure the ACR name,
    Docker image name, tag, and so on. The task should look like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用助手中的**Azure App Service 部署**任务。此任务用于将应用程序部署到支持原生部署或容器部署的 Azure Web App。您需要配置
    Azure 订阅、App Service 类型等。当您为**App Service 类型**选择**Web App for Containers (Linux)**选项时，您将被提示配置
    ACR 名称、Docker 镜像名称、标签等。任务应如下所示：
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that we also need to specify a `StartupCommand` value. In this case, we
    use `dotnet MyBasicWebApiDemo.dll` to start the application.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还需要指定一个`StartupCommand`值。在这种情况下，我们使用`dotnet MyBasicWebApiDemo.dll`来启动应用程序。
- en: Now, we can manually trigger the pipeline to deploy the application. If everything
    is fine, you will see the deployment is successful.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以手动触发管道以部署应用程序。如果一切正常，您将看到部署成功。
- en: 'Check the configuration of the Azure Web App. You will see the **Application
    settings** are updated:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Azure Web App 的配置。您将看到 **应用程序设置** 已更新：
- en: '![Figure 14.22 – The application settings are updated](img/B18971_14_22.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.22 – 应用设置已更新](img/B18971_14_22.jpg)'
- en: Figure 14.22 – The application settings are updated
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22 – 应用设置已更新
- en: Navigate to the Azure portal and check the details of the Azure Web App we created
    earlier. You can find the URL of the Azure Web App, such as `azure-pipeline-demo.azurewebsites.net`.
    Open the URL in the browser and check the controller endpoint, such as `https://azure-pipeline-demo.azurewebsites.net/WeatherForecast`.
    You will see the response from the application.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 Azure 门户并检查我们之前创建的 Azure Web App 的详细信息。您可以在其中找到 Azure Web App 的 URL，例如 `azure-pipeline-demo.azurewebsites.net`。在浏览器中打开此
    URL 并检查控制器端点，例如 `https://azure-pipeline-demo.azurewebsites.net/WeatherForecast`。您将看到应用程序的响应。
- en: 'So far, we have created three pipelines:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了三个管道：
- en: '**Pull request build pipeline**: This pipeline is to validate the code changes
    in pull requests. It will be triggered when a pull request is created or updated.
    If the build fails or the tests fail, the pull request cannot be merged. This
    pipeline does not produce any artifacts.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取请求构建管道**：此管道用于验证拉取请求中的代码更改。当创建或更新拉取请求时，它将被触发。如果构建失败或测试失败，则无法合并拉取请求。此管道不生成任何工件。'
- en: '`main` branch. This pipeline produces a Docker image as the artifact.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` 分支。此管道生成一个 Docker 镜像作为工件。'
- en: '**Release pipeline**: This pipeline is to pull the Docker image from ACR and
    deploy it to Azure Web App for Containers. This pipeline can be triggered manually
    or automatically when a new Docker image is published to ACR. This pipeline does
    not produce any artifacts.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布管道**：此管道用于从 ACR 拉取 Docker 镜像并将其部署到 Azure Web App for Containers。此管道可以在将新的
    Docker 镜像发布到 ACR 时手动或自动触发。此管道不生成任何工件。'
- en: Configuring settings and secrets
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置设置和秘密
- en: In the previous section, we created a release pipeline to deploy the application
    to Azure Web App for Containers. We may also need to deploy the application to
    other environments, such as staging. These different environments may have different
    settings, such as database connection strings, API keys, and so on. So, how can
    we configure the settings for different environments?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个发布管道，用于将应用程序部署到 Azure Web App for Containers。我们可能还需要将应用程序部署到其他环境，例如预发布环境。这些不同的环境可能具有不同的设置，例如数据库连接字符串、API
    密钥等。那么，我们如何为不同的环境配置设置呢？
- en: There are various ways to achieve this. A simple way is to configure variables
    for different environments. You can define variables in each pipeline directly.
    Azure Pipelines also provides a **Library** to manage variables. You can group
    variables into a variable group and then use the variable group in the pipeline.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种实现方式。一种简单的方法是为不同的环境配置变量。您可以直接在每个管道中定义变量。Azure Pipelines 还提供了一个 **库** 来管理变量。您可以将变量分组到变量组中，然后在管道中使用该变量组。
- en: Storing confidential information securely is essential to any organization.
    To ensure the safety of your secrets, you can use a variety of key vaults, such
    as Azure Key Vault and AWS Secrets Manager. Azure Pipelines offers a Key Vault
    task to fetch secrets from the vault. With the Azure Key Vault task, you can easily
    retrieve secrets from the vault and use them in your pipeline. To learn more about
    the Key Vault task, please visit [https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project](https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 安全地存储机密信息对任何组织都至关重要。为确保您的秘密安全，您可以使用各种密钥保管库，例如 Azure Key Vault 和 AWS Secrets
    Manager。Azure Pipelines 提供了一个密钥保管库任务来从保管库中检索秘密。使用 Azure Key Vault 任务，您可以轻松地从保管库检索秘密并在管道中使用它们。有关密钥保管库任务的更多信息，请访问
    [https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project](https://learn.microsoft.com/en-us/azure/devops/pipelines/release/key-vault-in-own-project)。
- en: This chapter is not intended to cover all the details of Azure Pipelines, but
    you should now have a basic understanding of Azure Pipelines. Using CI/CD pipelines
    can help you to automate the build, test, and deployment process, which eliminates
    manual work and reduces the risk of human errors. It is more and more important
    to use CI/CD pipelines in modern software development. Every developer should
    learn how to use them.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是涵盖 Azure Pipelines 的所有细节，但你现在应该对 Azure Pipelines 有一个基本的了解。使用 CI/CD 管道可以帮助你自动化构建、测试和部署过程，从而消除人工工作并减少人为错误的风险。在现代软件开发中，使用
    CI/CD 管道变得越来越重要。每个开发者都应该学习如何使用它们。
- en: In the next section, we will explore GitHub Actions, which is another popular
    CI/CD tool.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 GitHub Actions，这是另一个流行的 CI/CD 工具。
- en: GitHub Actions
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: In the previous section, we explored Azure Pipelines. Next, let us explore GitHub
    Actions. GitHub Actions is a CI/CD tool provided by GitHub. It is quite similar
    to Azure Pipelines. In this section, we will use GitHub Actions to build and test
    the application and push the Docker image to ACR.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了 Azure Pipelines。接下来，让我们来了解 GitHub Actions。GitHub Actions 是由 GitHub
    提供的 CI/CD 工具，它与 Azure Pipelines 非常相似。在本节中，我们将使用 GitHub Actions 来构建和测试应用程序，并将 Docker
    镜像推送到 ACR。
- en: Preparing the project
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备项目
- en: 'To demonstrate how to use GitHub Actions, we will use the same source code
    as we used in the previous section. You can download the source code from the
    GitHub repository here: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo).
    Create a new GitHub repository and push the source code to the repository. The
    directory structure of the source code is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用 GitHub Actions，我们将使用与上一节相同的源代码。你可以从这里下载源代码：[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter14/MyBasicWebApiDemo)。创建一个新的
    GitHub 仓库并将源代码推送到仓库。源代码的目录结构如下：
- en: '[PRE49]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you use a different directory structure, please update the paths in the pipeline
    accordingly in the following sections. We will use this repository to demonstrate
    how to configure GitHub Actions.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用不同的目录结构，请在以下章节中相应地更新管道中的路径。我们将使用这个仓库来演示如何配置 GitHub Actions。
- en: Creating GitHub Actions
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GitHub Actions
- en: We will reuse the Azure resources we created in the previous section. If you
    have not created the Azure resources, please refer to the *Creating Azure resources*
    section to create the resources.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用上一节中创建的 Azure 资源。如果你还没有创建 Azure 资源，请参阅 *创建 Azure 资源* 部分，以创建资源。
- en: 'On the GitHub repository page, click the **Actions** tab, and you can see many
    templates for different programming languages and frameworks:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库页面上，点击 **操作** 选项卡，你可以看到许多针对不同编程语言和框架的模板：
- en: '![Figure 14.23 – Choosing a template for GitHub Actions](img/B18971_14_23.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.23 – 为 GitHub Actions 选择模板](img/B18971_14_23.jpg)'
- en: Figure 14.23 – Choosing a template for GitHub Actions
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23 – 为 GitHub Actions 选择模板
- en: 'In the **Continuous integration** section, you can find the **.NET** template.
    Click the **Configure** button to create a new workflow. The workflow is a YAML
    file that defines the CI/CD pipeline. The default workflow may look like this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **持续集成** 部分，你可以找到 **.NET** 模板。点击 **配置** 按钮创建一个新的工作流程。工作流程是一个 YAML 文件，它定义了
    CI/CD 管道。默认工作流程可能看起来像这样：
- en: '[PRE50]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The syntax of the workflow is quite similar to Azure Pipelines. The workflow
    is triggered when a pull request is created or updated, or when a commit is pushed
    to the `main` branch.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程的语法与 Azure Pipelines 非常相似。工作流程在创建或更新拉取请求时触发，或者当向 `main` 分支推送提交时触发。
- en: 'On the right side, you can find the **Marketplace** panel. The Marketplace
    is similar to the assistants of Azure DevOps Pipelines and provides many built-in
    actions that you can use in your workflow:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，你可以找到 **Marketplace** 面板。Marketplace 与 Azure DevOps Pipelines 的助手类似，提供了许多内置操作，你可以在工作流程中使用：
- en: '![Figure 14.24 – The Marketplace panel](img/B18971_14_24.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.24 – Marketplace 面板](img/B18971_14_24.jpg)'
- en: Figure 14.24 – The Marketplace panel
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24 – Marketplace 面板
- en: 'The sample application uses .NET 8\. So, we need to update `dotnet-version`
    to `8.0.x`. Click the `dotnet.yml` file is committed to the `/.github/workflows`
    directory. Make a change to the source code or create a new branch and push the
    changes to the remote repository. For example, you can change the controller to
    return six items instead of five items:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序使用.NET 8。因此，我们需要将`dotnet-version`更新为`8.0.x`。点击已提交到`/.github/workflows`目录的`dotnet.yml`文件。对源代码进行更改或创建一个新的分支，并将更改推送到远程仓库。例如，您可以将控制器更改回返回六个项目而不是五个项目：
- en: '[PRE51]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also create a pull request. You will see the workflow is triggered
    automatically and the test is failed:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个拉取请求。您将看到工作流程会自动触发，但测试失败：
- en: '![Figure 14.25 – The workflow is triggered automatically and then fails](img/B18971_14_25.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图14.25 – 工作流程自动触发然后失败](img/B18971_14_25.jpg)'
- en: Figure 14.25 – The workflow is triggered automatically and then fails
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.25 – 工作流程自动触发然后失败
- en: Click the links in the logs to see details of the code that caused the test
    failure. It is handy to review code changes in the pull request. If everything
    is fine, you can merge the pull request.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 点击日志中的链接以查看导致测试失败的代码的详细信息。在审查拉取请求中的代码更改时，这非常方便。如果一切正常，您可以合并拉取请求。
- en: 'To clarify that it works for pull request builds, we can rename this file to
    `pr-build.yml` and update the `on` section to make the workflow run for pull requests:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确它适用于拉取请求构建，我们可以将此文件重命名为`pr-build.yml`，并更新`on`部分以使工作流程在拉取请求中运行：
- en: '[PRE52]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, let us build a Docker image and push it to ACR.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建一个Docker镜像并将其推送到ACR。
- en: Pushing a Docker image to ACR
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Docker镜像推送到ACR
- en: 'Create a new YAML file named `docker-build.yml` in the `.github\workflows`
    folder. Update the content of the file as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.github\workflows`文件夹中创建一个名为`docker-build.yml`的新YAML文件。更新文件内容如下：
- en: '[PRE53]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This workflow is triggered when a commit is pushed to the `main` branch or a
    pull request is merged into the `main` branch.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`main`分支推送提交或拉取请求合并到`main`分支时，此工作流程会被触发。
- en: To authenticate the action to access ACR, we need to configure the username
    and password of ACR in GitHub secrets. Find the username and password by clicking
    the **Access keys** menu of ACR in the Azure portal.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证操作以访问ACR，我们需要在GitHub密钥中配置ACR的用户名和密码。通过在Azure门户中点击ACR的**访问密钥**菜单来查找用户名和密码。
- en: 'Go to **Settings** in the GitHub repository and click **Secrets and variables**
    in the **Security** category. Then, click **Actions**, and you will see the secrets
    and variables page. There are two types of secrets: environment secrets and repository
    secrets. You can store the username and password in repository secrets directly.
    To demonstrate how to use environment secrets, we will use environment secrets
    in this example. Click the **Manage environments** button to create a new environment
    named **Production**. Then, click the **Add secret** button to add a username
    and password:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 前往GitHub仓库的**设置**，然后在**安全**类别中点击**密钥和变量**。然后，点击**操作**，您将看到密钥和变量页面。有两种类型的密钥：环境密钥和仓库密钥。您可以直接在仓库密钥中存储用户名和密码。为了演示如何使用环境密钥，我们将在这个示例中使用环境密钥。点击**管理环境**按钮以创建一个名为**生产**的新环境。然后，点击**添加密钥**按钮以添加用户名和密码：
- en: 'Name: `REGISTRY_USERNAME`. Value: The username of ACR.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`REGISTRY_USERNAME`。值：ACR的用户名。
- en: 'Name: `REGISTRY_PASSWORD`. Value: The password of ACR.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`REGISTRY_PASSWORD`。值：ACR的密码。
- en: You can change the environment secret names, but make sure you use the same
    names in the following workflow.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改环境密钥的名称，但请确保在以下工作流程中使用相同的名称。
- en: 'Now, the environment secrets should look like this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，环境密钥应该看起来像这样：
- en: '![Figure 14.26 – The Actions secrets and variables page](img/B18971_14_26.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图14.26 – Actions密钥和变量页面](img/B18971_14_26.jpg)'
- en: Figure 14.26 – The Actions secrets and variables page
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.26 – Actions密钥和变量页面
- en: 'Add the following content to the `docker-build.yml` file:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`docker-build.yml`文件中：
- en: '[PRE54]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding is similar to the `pr-build.yml` file, but we made some changes:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容与`pr-build.yml`文件类似，但我们做了一些更改：
- en: We added an `environment` section to specify the environment so that we can
    refer to the environment secrets later.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`environment`部分来指定环境，以便我们可以在以后引用环境密钥。
- en: We added a new `azure/docker-login@v1` step to log in to ACR. In this step,
    we specified the login server, username, and password using the environment secrets.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个新的`azure/docker-login@v1`步骤来登录到ACR。在这个步骤中，我们使用环境密钥指定了登录服务器、用户名和密码。
- en: We added a new step to build the Docker image and push it to ACR. In this step,
    we used the `github.run_id` variable to tag the image with the run ID. We also
    tagged the image with `latest`.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个新步骤来构建 Docker 镜像并将其推送到 ACR。在这个步骤中，我们使用了 `github.run_id` 变量来使用运行 ID 标记镜像。我们还使用
    `latest` 标记了镜像。
- en: GitHub Actions context
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 上下文
- en: 'GitHub Actions supports many built-in context variables, such as `github.run_id`,
    `github.run_number`, `github.sha`, `github.ref`, and so on. You can find all the
    context variables here: [https://docs.github.com/en/actions/learn-github-actions/contexts](https://docs.github.com/en/actions/learn-github-actions/contexts).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 支持许多内置上下文变量，例如 `github.run_id`、`github.run_number`、`github.sha`、`github.ref`
    等。你可以在这里找到所有上下文变量：[https://docs.github.com/en/actions/learn-github-actions/contexts](https://docs.github.com/en/actions/learn-github-actions/contexts)。
- en: 'Commit the changes and push the changes to the remote repository. Next time
    you merge a pull request, you will see the workflow is triggered automatically
    and the Docker image is pushed to ACR:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改并将更改推送到远程仓库。下次你合并拉取请求时，你会看到工作流程会自动触发，并将 Docker 镜像推送到 ACR：
- en: '![Figure 14.27 – The GitHub Actions workflow is triggered automatically](img/B18971_14_27.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.27 – GitHub Actions 工作流程自动触发](img/B18971_14_27.jpg)'
- en: Figure 14.27 – The GitHub Actions workflow is triggered automatically
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.27 – GitHub Actions 工作流程自动触发
- en: 'As there are many similarities between Azure Pipelines and GitHub Actions,
    we will not cover all the details of GitHub Actions. Maybe it is your turn to
    create a GitHub Actions workflow to deploy the Docker image to Azure Web App for
    Containers? You can find more information about GitHub Actions here: [https://docs.github.com/en/actions](https://docs.github.com/en/actions).'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Azure Pipelines 和 GitHub Actions 之间有许多相似之处，我们不会涵盖 GitHub Actions 的所有细节。也许轮到你来创建一个
    GitHub Actions 工作流程，将 Docker 镜像部署到 Azure Web App for Containers？你可以在这里找到有关 GitHub
    Actions 的更多信息：[https://docs.github.com/en/actions](https://docs.github.com/en/actions)。
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the fundamentals of CI/CD. We discussed how to
    use Docker to containerize ASP.NET web API applications, including how to create
    a Dockerfile, build a Docker image, and run a Docker container locally. We then
    looked at Azure DevOps Pipelines, a powerful CI/CD platform from Microsoft, and
    how to create CI/CD pipelines in YAML files. We covered configuring triggers,
    using built-in tasks, and using variables. We created three pipelines for builds,
    Docker image builds, and releases. We also briefly discussed GitHub Actions, another
    popular CI/CD tool, and created a GitHub Actions workflow to build and test the
    application, then build the Docker image and push it to ACR. After reading this
    chapter, you should have a basic understanding of CI/CD and be able to use CI/CD
    pipelines to automate the build, test, and deployment process.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 CI/CD 的基础知识。我们讨论了如何使用 Docker 来容器化 ASP.NET Web API 应用程序，包括如何创建 Dockerfile、构建
    Docker 镜像以及在本地运行 Docker 容器。然后我们了解了 Azure DevOps Pipelines，这是微软的一个强大的 CI/CD 平台，以及如何在
    YAML 文件中创建 CI/CD 管道。我们涵盖了配置触发器、使用内置任务和使用变量。我们创建了三个管道，用于构建、Docker 镜像构建和发布。我们还简要讨论了
    GitHub Actions，这是另一个流行的 CI/CD 工具，并创建了一个 GitHub Actions 工作流程来构建和测试应用程序，然后构建 Docker
    镜像并将其推送到 ACR。阅读本章后，你应该对 CI/CD 有基本的了解，并能够使用 CI/CD 管道来自动化构建、测试和部署过程。
- en: In the next chapter, we will examine some common practices for building ASP.NET
    web APIs, including caching, `HttpClient` factory, and so on.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将检查构建 ASP.NET Web API 的一些常见做法，包括缓存、`HttpClient` 工厂等。
