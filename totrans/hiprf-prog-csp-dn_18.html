<html><head></head><body>
		<div><h1 id="_idParaDest-260"><em class="italic"><a id="_idTextAnchor266"/>Chapter 15</em>: Parallel Programming</h1>
			<p>In this chapter, you will learn how to take advantage of the multiple CPU cores that are available in today’s modern computers. You will learn how to process your code by distributing the work between processes concurrently, as well as how to use the <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>) and <strong class="bold">Parallel LINQ</strong> (<strong class="bold">PLINQ</strong>) to run code in parallel. Throughout this book, you will learn how to use parallel data structures and use the Visual Studio debugger to diagnose tasks and parallel stacks. You will also learn about the Concurrency Visualizer.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><strong class="bold">Using the Task Parallel Library (TPL)</strong>: In this section, we will compare parallel and non-parallel code and its effect on CPU core utilization using <em class="italic">perfmon</em>.</li>
				<li><strong class="bold">Using Parallel LINQ (PLINQ)</strong>: In this section, we will look at PLINQ and how it can be used to execute LINQ statements with varying degrees of parallelism.</li>
				<li><strong class="bold">Programming parallel data structures</strong>: In this section, we will review some of the thread-safe collections you can use for programming parallel data structures.</li>
				<li><strong class="bold">Benchmarking with BenchmarkDotNet</strong>: In this section, we will look at benchmarking our parallel code and find that, in some instances, it can be faster than non-parallel code, and at other times, it can be slower.</li>
				<li><code>Func</code> and <code>Action</code> delegates.</li>
			</ul>
			<p>By the end of this chapter, you will be able to do the following:</p>
			<ul>
				<li>Use TPL and PLINQ for parallel programming tasks.</li>
				<li>Program parallel data structures.</li>
				<li>Diagnose issues with tasks and parallel data structures.</li>
				<li>Use lambda expressions in TPL and PLINQ queries.</li>
			</ul>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor267"/>Technical requirements</h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>This book’s source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15</a></li>
				<li>Concurrency Visualizer for Visual Studio 2022: <a href="https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview">https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview</a></li>
			</ul>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor268"/>Using the Task Parallel Library (TPL)</h1>
			<p>In this chapter, we will be working<a id="_idIndexMarker1456"/> with TPL to enhance the performance of our programs by making use of the available processor power on a machine.</p>
			<p>We learned how to write threads and execute them in <a href="B16617_14_Final_SB_Epub.xhtml#_idTextAnchor254"><em class="italic">Chapter 14</em></a>, <em class="italic">Multi-Threaded Programming</em>. When multiple threads are running on a single processor, providing the illusion that they are running in parallel, they are running concurrently.</p>
			<p>When threads run concurrently, the processor uses a scheduling algorithm and/or interrupts to determine the switching and prioritization between threads. Parallel programming, however, runs different threads on different processors so that threads execute in parallel to each other with a reduced need for switching and thread interrupts.</p>
			<p>As its name suggests, TPL is used to run tasks in parallel. Tasks are run in parallel by running each task against a separate core of the computer’s processor. So, for example, say your computer has four cores and you have four tasks. Each task would run on a separate core, and each task would be run parallel to the other three. This helps improve the overall performance of the code as you can have as many tasks executing in parallel as you have processor cores.</p>
			<p>Also, if you have a big dataset<a id="_idIndexMarker1457"/> that needs to process many records and store them in a variable, you can partition the task so that the records are split into different threads running on different processors. These are then synced backed together and stored in a variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Code that cannot be parallelized will slow down parallel tasks, as will code that must be partitioned and scheduled by the task scheduler. It is always a good idea to profile your code to see if the methods you are employing will speed up or slow things down.</p>
			<p>A good way to see the value in parallel programming is to compare a thread running on a single processor against the same code split between different processors. Let’s write some code for this comparison:</p>
			<ol>
				<li>Start a new console application and call it <code>CH15_ParallelProgramming</code>. Then, check the checkbox that says <strong class="bold">do not use top-level statements</strong>.</li>
				<li>Add the following <code>using</code> statement:<pre>using System.Threading.Tasks;</pre></li>
			</ol>
			<p>This <code>using</code> statement gives us access to TPL.</p>
			<ol>
				<li value="3">Update the <code>Main</code> method in the <code>Program</code> class, as follows:<pre>static void Main(string[] _)
{
  RunSingleProcessorExample();
}</pre></li>
			</ol>
			<p>This method calls the <code>RunSingleProcessorExample</code> method.</p>
			<ol>
				<li value="4">Add the <code>RunSingleProcessorExample</code> method:<pre>static void RunSingleProcessorExample()
{
  Thread thread = new(SingleProcessorExample);
  thread.Start();
}</pre></li>
			</ol>
			<p>This method creates a new thread<a id="_idIndexMarker1458"/> and assigns it the <code>SingleProcessorExample</code> method, which it will invoke. The method is then invoked using the <code>Start</code> method.</p>
			<ol>
				<li value="5">Now, add <code>SingleProcessorMethod</code>:<pre>static void SingleProcessorExample()
{
string output = “Index: “;
    for (int index = 0; index &lt; 1000000; index++)
{
      Console.WriteLine($”{output}{index}”);
}
    Console.ReadKey();
}</pre></li>
			</ol>
			<p>This method writes the value of the <code>for</code> loop index to the console window 1 million times and then pauses until it receives a user keypress.</p>
			<ol>
				<li value="6">Type <code>Performance Monitor</code> into your task bar’s search area and open it. Then, remove the existing counter, and then add a counter to view the processor time for all the processors on your computer. If you need to, you can change the thickness of the lines.</li>
				<li>Clear out the <strong class="bold">Performance Monitor</strong> screen and then run the console app. You should see something similar to the following:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_15.1.jpg" alt="Figure 15.1 – Performance Monitor with our console application running&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Performance Monitor with our console application running</p>
			<p>As you can see, processor<a id="_idIndexMarker1459"/> instance 1 is the most utilized processor. What we need to do is modify the program to utilize all available processors.</p>
			<ol>
				<li value="8">Comment out the method call in the <code>Main</code> method and add the following code after the commented-out method:<pre>Parallel.For(
    0, 1000000, x =&gt; MultipleProcessorExample(x)
);</pre></li>
			</ol>
			<p>This code uses a parallel <code>for</code> loop to process the <code>MultipleProcessorExample</code> method 1 million times.</p>
			<ol>
				<li value="9">Run the code again. You should see the following in Performance Monitor:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_15.2.jpg" alt="Figure 15.2 – Performance Monitor showing all our processors being used by our modified program&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – Performance Monitor showing all our processors being used by our modified program</p>
			<p>As you can see, with very minimal<a id="_idIndexMarker1460"/> code, you can go from utilizing a single processor to utilizing all the processors using TPL. In previous chapters, you learned how to use <em class="italic">BenchmarkDotNET</em> to benchmark the performance of different variations of the same code. When deciding whether to turn your single processor code into multiple processor code, it’s a good idea to benchmark. There is an overhead to using parallel code, so you need to ensure that parallel code will improve your program.</p>
			<p>Now, let’s learn how to use PLINQ.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor269"/>Using Parallel LINQ (PLINQ)</h1>
			<p>In this section, you will learn<a id="_idIndexMarker1461"/> how to convert your sequential LINQ queries into parallel LINQ using PLINQ. Take a look at the following code:</p>
			<pre class="source-code">var productNames = GetProductNames();</pre>
			<pre class="source-code">var names = from name in productNames</pre>
			<pre class="source-code">           where name.Length &gt; 8</pre>
			<pre class="source-code">           select name;</pre>
			<p>The preceding code calls the <code>GetProductNames</code> method and stores the results in the <code>productNames</code> variable. A LINQ statement is then performed on the <code>productNames</code> list to extract a list of all product names greater than eight characters in length. The result of this LINQ statement is then stored in the <code>names</code> variable.</p>
			<p>The following code is identical to the preceding code, except we have modified it so that it operates in parallel across multiple processors:</p>
			<pre class="source-code">var productNames = GetProductNames();</pre>
			<pre class="source-code">var names = from name in productNames.AsParallel()</pre>
			<pre class="source-code">           where name.Length &gt; 8</pre>
			<pre class="source-code">           select name;</pre>
			<p>Here, we can see that the only change to the LINQ statement to get it to execute as parallel LINQ is to add the <code>AsParallel()</code> method call. The rest of the code stays the same.</p>
			<p>If you want the data to be returned from the PLINQ statement, then suffix the <code>AsParallel()</code> call with the <code>AsOrdered()</code> call:</p>
			<pre class="source-code">var productNames = GetProductNames();</pre>
			<pre class="source-code">var names = from name in productNames</pre>
			<pre class="source-code">             .AsParallel().AsOrdered()</pre>
			<pre class="source-code">           where name.Length &gt; 8</pre>
			<pre class="source-code">           select name;</pre>
			<p>The preceding code will return a list of product names whose lengths are greater than <code>8</code> in alphabetical order.</p>
			<p>PLINQ utilizes all the processors<a id="_idIndexMarker1462"/> on the executing computer. However, you can limit the number of processors that are used by PLINQ using the <code>WithDegreeOfParallelism</code> call, passing in the number of processors you want to limit PLINQ being executed on:</p>
			<pre class="source-code">var productNames = GetProductNames();</pre>
			<pre class="source-code">var names = from name in productNames</pre>
			<pre class="source-code">             .AsParallel()</pre>
			<pre class="source-code">             .WithDegreeOfParallelism(2)</pre>
			<pre class="source-code">           where name.Length &gt; 8</pre>
			<pre class="source-code">           select name;</pre>
			<p>The preceding code has been limited to running on only two processors.</p>
			<p>The following are some performance considerations<a id="_idIndexMarker1463"/> when using PLINQ:</p>
			<ul>
				<li>Don’t use PLINQ on single-core computers. This would result in slower performance than using standard LINQ.</li>
				<li><code>AsOrdered()</code> will slow PLINQ down. Only use it if you need to. Benchmark alternative ordering techniques to see which is quickest, and then implement the quickest method.</li>
				<li>Employ production-sized datasets when developing and testing your PLINQ code. This will reveal performance issues sooner rather than later!</li>
				<li>Avoid using PLINQ on small collections since this could provide less performance. This is because PLINQ has been optimized for large datasets.</li>
			</ul>
			<p>In the next section, we will consider some data structures that are suitable for parallel programming.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor270"/>Programming parallel data structures</h2>
			<p>When we do parallel programming, we should<a id="_idIndexMarker1464"/> always consider that we are using threads. Therefore, we should use data structures that are thread-safe.</p>
			<p>For types that implement the <code>IProducerConsumerCollection&lt;T&gt;</code> interface, you should use the generic <code>BlockingCollection&lt;T&gt;</code> class, which provides bounding and blocking functionality. Use the <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> class for thread-safe dictionaries. For thread-safe FIFO queues, use the <code>ConcurrentQueue&lt;T&gt;</code> class. Use the <code>ConcurrentStack&lt;T&gt;</code> class for LIFO stacks. For a thread-safe implementation of a collection of elements, use the <code>ConcurrentBag&lt;T&gt;</code> class. Finally, for types to be used in a <code>BlockingCollection</code>, implement the <code>IProducerConsumerCollection&lt;T&gt;</code> class.</p>
			<p>You can read more about thread-safe collections<a id="_idIndexMarker1465"/> on the Microsoft Docs website: <a href="https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/">https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/</a>. </p>
			<p>Next, we’ll look at benchmarking loops, LINQ, and PLINQ.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor271"/>Benchmarking with BenchmarkDotNet</h1>
			<p>In this section, we will benchmark<a id="_idIndexMarker1466"/> some methods to determine which method gives us the best performance. Keep in mind that there is some initial expense when running code in parallel. So, sometimes, parallel code may not be the best option for improving code performance. Let’s get started:</p>
			<ol>
				<li value="1">Comment out the code in the <code>Main</code> method and add the following line:<pre>BenchmarkRunner.Run&lt;Benchmarks&gt;();</pre></li>
				<li>Add a class called <code>Benchmarks</code>.</li>
				<li>Add the following <code>NuGet</code> packages:<ol><li><code>BenchmarkDotNet</code></li><li><code>LinqOptimizer.Csharp</code></li></ol></li>
				<li>Add the <code>using</code> statements for each of the <code>NuGet</code> packages to the <code>Benchmarks</code> class.</li>
				<li>Add the following<a id="_idIndexMarker1467"/> code to set up our benchmarks:<pre>private short[] data;
[GlobalSetup]
public void GlobalSetup()
{
     integers = new Int16[Int16.MaxValue];
     for (short x = 1; x &lt;= integers.Length - 1; x++)
     { 
     integers[x] = x; 
     }
}</pre></li>
			</ol>
			<p>Here, we are declaring an array that’s a short data type. The array is then initialized and filled with values. This array will be used by two of the following six methods.</p>
			<ol>
				<li value="6">Add the <code>StandardForLoopExample</code> method:<pre>[Benchmark]
public void StandardForEachLoopExample()
{
     foreach (int x in integers)
             Console.WriteLine($”Item {x}: {x}”);
}</pre></li>
			</ol>
			<p>The preceding code uses a standard <code>foreach</code> loop to loop through the values in the data array and then writes<a id="_idIndexMarker1468"/> the value of the array at the given index to the console window.</p>
			<ol>
				<li value="7">Add the <code>ParallelForLoopExample</code> method:<pre>[Benchmark]
public void ParallelForEachLoopExample()
{
     Parallel.ForEach(integers, x =&gt; {
         Console.WriteLine($”Item {x}: {x}”);
     });
}</pre></li>
			</ol>
			<p>The preceding code does the same as the preceding code but executes the code using PLINQ.</p>
			<ol>
				<li value="8">Add the <code>UrlDownloader1</code> method:<pre> public List&lt;string&gt; DownloadWebsites1()
        {
            List&lt;string&gt; websitesContent = new();
            HttpClient httpClient = new();
 
            string[]? websites = new[]
            {
            “https://docs.microsoft.com”,      
             “https://ownCloud.com”,       
             “https://www.oanda.com/uk-en/”,     
             “https://azure.microsoft.com/en-gb/”  
            };
 
            foreach (string? website in websites)
            {
                Console.WriteLine($”Downloading of 
                    {website} content has started.”);
                string websiteContent = 
                httpClient.GetStringAsync(website)
                .GetAwaiter().GetResult();
                websitesContent.Add(websiteContent);
                Console.WriteLine($”Downloading of 
                    {website} content has finished.”);
            }
 
            httpClient.Dispose();
 
            return websitesContent;
        }</pre></li>
			</ol>
			<p>The preceding code creates<a id="_idIndexMarker1469"/> an array of URLs and downloads their content using a <code>foreach</code> loop.</p>
			<ol>
				<li value="9">Add the <code>UrlDownloader2</code> method:</li>
			</ol>
			<pre class="source-code"> [Benchmark]</pre>
			<pre class="source-code">        public List&lt;string&gt; DownloadWebsites2()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            List&lt;string&gt; websitesContent = new();</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            string[]? websites = new[]</pre>
			<pre class="source-code">                {</pre>
			<pre class="source-code">            "https://docs.microsoft.com",              </pre>
			<pre class="source-code">            "https://ownCloud.com",</pre>
			<pre class="source-code">            "https://www.oanda.com/uk-en/",        </pre>
			<pre class="source-code">            "https://azure.microsoft.com/en-gb/"</pre>
			<pre class="source-code">                };</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            Task[]? downloadJobs = websites</pre>
			<pre class="source-code">                .Select(jobs =&gt; Task.Factory.StartNew(</pre>
			<pre class="source-code">                    state =&gt;</pre>
			<pre class="source-code">                    {</pre>
			<pre class="source-code">                        using HttpClient? httpClient = new </pre>
			<pre class="source-code">                            HttpClient();</pre>
			<pre class="source-code">                        string? website = state == null ? </pre>
			<pre class="source-code">                            String.Empty : (string)state;</pre>
			<pre class="source-code">                        Console.WriteLine($"Downloading of </pre>
			<pre class="source-code">                          {website} content has started.");</pre>
			<pre class="source-code">                        string result = </pre>
			<pre class="source-code">                        httpClient.GetStringAsync(website)</pre>
			<pre class="source-code">                        .GetAwaiter().GetResult();</pre>
			<pre class="source-code">                        websitesContent.Add(result);</pre>
			<pre class="source-code">                        Console.WriteLine($"Downloading of </pre>
			<pre class="source-code">                        {website} content has finished.");</pre>
			<pre class="source-code">                    }, jobs)</pre>
			<pre class="source-code">                )</pre>
			<pre class="source-code">                .ToArray();</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            Task.WaitAll(downloadJobs);</pre>
			<pre class="source-code">            return websitesContent;</pre>
			<pre class="source-code">        }</pre>
			<p>The preceding code creates<a id="_idIndexMarker1470"/> an array of URLs and downloads them as a set of tasks. The code waits for all the tasks to complete before the content is returned.</p>
			<ol>
				<li value="10">Add the <code>Urldownloader3</code> method:</li>
			</ol>
			<pre class="source-code"> [Benchmark]</pre>
			<pre class="source-code">        public List&lt;string&gt; DownloadWebsites3()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            List&lt;string&gt; websitesContent = new();</pre>
			<pre class="source-code">            HttpClient httpClient = new();</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            List&lt;string&gt; websites = new()</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">            "https://docs.microsoft.com",           </pre>
			<pre class="source-code">            "https://ownCloud.com",</pre>
			<pre class="source-code">             "https://www.oanda.com/uk-en/",               </pre>
			<pre class="source-code">             "https://azure.microsoft.com/en-gb/"</pre>
			<pre class="source-code">            };</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            websites.ForEach(website =&gt;</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                Console.WriteLine($"Downloading of </pre>
			<pre class="source-code">                    {website} content has started.");</pre>
			<pre class="source-code">                string result = </pre>
			<pre class="source-code">                  httpClient.GetStringAsync(website)</pre>
			<pre class="source-code">                    .GetAwaiter().GetResult();</pre>
			<pre class="source-code">                websitesContent.Add(result);</pre>
			<pre class="source-code">                Console.WriteLine($"Downloading of </pre>
			<pre class="source-code">                    {website} content has finished.");</pre>
			<pre class="source-code">            });</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            httpClient.Dispose();</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            return websitesContent;</pre>
			<pre class="source-code">        }</pre>
			<p>The preceding code uses a <code>Parallel.ForeEach</code> loop to download the contents of URLs<a id="_idIndexMarker1471"/> stored in an array.</p>
			<ol>
				<li value="11">Make sure that your project is set to Release mode, and then run your program. The program will take some time to execute. However, once it has finished executing, you should see something similar to the following:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_15.3.jpg" alt="Figure 15.3 – BenchmarkDotNet results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – BenchmarkDotNet results</p>
			<p>Looking at the <code>ForEachLoop</code> examples, we can see<a id="_idIndexMarker1472"/> that the standard <code>foreach</code> loop executed faster than our <code>Parallel.ForEach</code> loop. And so, in this example, using parallel code was slightly slower than using non-parallel code. But if the dataset was much larger and the data type was more complex, then the results could show that parallel code performs faster.</p>
			<p>When looking at our <code>UrlDownloader</code> methods, <code>UrlDownloader4</code> uses the <code>Parallel.ForEach</code> loop, which is much faster than the two methods that use the <code>foreach</code> loop and <code>foreach</code> with lambda methods. However, the method that creates an array of tasks and waits for them all to complete is slightly faster than the <code>Parallel.ForEach</code> loop.</p>
			<p>From these test results, we can see that we have different ways to perform the same actions, and each method’s processing speed is different. In some cases, we have seen that parallel code is slower than non-parallel code, while in others, we have seen that parallel code is faster than non-parallel code.</p>
			<p>When performance is an issue, you can use BenchmarkDotNet to test the efficiency of different approaches to the same task. Then, you can choose the most efficient option for the problem that you are trying to solve.</p>
			<p>In the next section, we will learn how to use lambda expressions with TPL and LINQ.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor272"/>Using lambda expressions with TPL and LINQ</h1>
			<p>There are several methods in TPL<a id="_idIndexMarker1473"/> that take a <code>System.Func&lt;TResult&gt;</code> or <code>System.Action</code> delegate as an input<a id="_idIndexMarker1474"/> parameter. These<a id="_idIndexMarker1475"/> can be used to pass<a id="_idIndexMarker1476"/> custom logic into a task, query, or parallel loop. Inline blocks can be used when creating delegates.</p>
			<p>Use <code>Func</code> delegates to encapsulate methods that return a value and use <code>Action</code> delegates to encapsulate methods that do not return values. Let’s review the following example:</p>
			<pre class="source-code">        static void FuncAction()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            int[] numbers = { 15, 10, 12, 17, 11, 13, 16, </pre>
			<pre class="source-code">                14, 18 };</pre>
			<pre class="source-code">            int additionResult = 0;</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            try</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                Parallel.ForEach(</pre>
			<pre class="source-code">                    numbers,</pre>
			<pre class="source-code">                    () =&gt; 0,</pre>
			<pre class="source-code">                    (number, currentState, addition) =&gt;</pre>
			<pre class="source-code">                    {</pre>
			<pre class="source-code">                        addition += number;</pre>
			<pre class="source-code">                        Console.WriteLine($"Thread: </pre>
			<pre class="source-code">                       {Thread.CurrentThread.</pre>
			<pre class="source-code">                        ManagedThreadId}, Number: </pre>
			<pre class="source-code">                        {number}, Addition: {addition}");</pre>
			<pre class="source-code">                        return addition;</pre>
			<pre class="source-code">                    },</pre>
			<pre class="source-code">                    (addition) =&gt; Interlocked.Add(ref </pre>
			<pre class="source-code">                         additionResult, addition)</pre>
			<pre class="source-code">                );</pre>
			<pre class="source-code">                Console.WriteLine($"Addition Result: </pre>
			<pre class="source-code">                    {additionResult}");</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            catch (AggregateException e)</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                Console.WriteLine($"Aggregate Exception: </pre>
			<pre class="source-code">                    FuncAction.\n{e.Message}");</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<p>The preceding code<a id="_idIndexMarker1477"/> shows how to use the <code>Parallel.ForEach</code> method<a id="_idIndexMarker1478"/> and a thread-local state. We expect<a id="_idIndexMarker1479"/> the code to execute<a id="_idIndexMarker1480"/> in parallel and sum up all the values stored in the <code>int</code> array. Each thread of the <code>Parallel.For</code> loop maintains a local addition variable. This addition variable is set to <code>0</code> when each thread is initialized. With each iteration, the addition is incremented with the number value. Once the thread has completed its task, the local sum for that thread is safely added to the global sum. The global sum is then printed out once the loop is complete.</p>
			<p>The preceding code also demonstrates how to use lambda expressions to express both <code>Func</code> and <code>Action</code> delegates: </p>
			<pre class="source-code">]Parallel.ForEach&lt;TSource,TLocal&gt;(IEnumerable&lt;TSource&gt;, </pre>
			<pre class="source-code">    Func&lt;TLocal&gt;, Func&lt;TSource,ParallelLoopState,Tlocal</pre>
			<pre class="source-code">        ,TLocal&gt;, Action&lt;TLocal&gt;).</pre>
			<p>In the<a id="_idIndexMarker1481"/> next<a id="_idIndexMarker1482"/> section, we<a id="_idIndexMarker1483"/> will look at some<a id="_idIndexMarker1484"/> parallel debugging tools.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor273"/>Parallel debugging and profiling tools</h1>
			<p>In this section, we will look<a id="_idIndexMarker1485"/> at three parallel application debugging and profiling<a id="_idIndexMarker1486"/> tools. These are the <code>CH15_ParallelProgrammingDebuggingAndProfilingSample</code> project for this. We will be using this project as we work through the next three sections.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor274"/>The Parallel Stacks window</h2>
			<p>Run the program<a id="_idIndexMarker1487"/> until it is paused by the debugger. Then, from the <strong class="bold">Visual Studio</strong> menu, select <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Parallel Tasks</strong>. This will display the <strong class="bold">Parallel Tasks</strong> window. You should see the following:</p>
			<div><div><img src="img/B16617_Figure_15.4.jpg" alt="Figure 15.4 – The Parallel Stacks thread view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4 – The Parallel Stacks thread view</p>
			<p>As you can see, our main thread<a id="_idIndexMarker1488"/> is initiated via our <code>Program.Main</code> method. We can see that the debugger is paused in <code>Program.MethodC</code>. There are four threads – one each for methods A, B, and C, and a fourth in external code. There are also five threads running – these are external code threads.</p>
			<p>If you hover over the methods, you will see the following popup:</p>
			<div><div><img src="img/B16617_Figure_15.5.jpg" alt="Figure 15.5 – The Parallel Stacks thread view with the Thread and Stack Frame view displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.5 – The Parallel Stacks thread view with the Thread and Stack Frame view displayed</p>
			<p>By hovering over each method group, you get to see a table of threads and their stack frames. These stack frames provide the method name and line number. The active stack frame of the current thread is identified by the yellow arrow. If you right-click while hovering over the stack frame, you can select what details to show, including parameter values, as shown here:</p>
			<div><div><img src="img/B16617_Figure_15.6.jpg" alt="Figure 15.6 – The Thread and Stack Frame view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.6 – The Thread and Stack Frame view</p>
			<p>Here, we can see the values of each of the parameters of our thread methods. Next, we will look at the <strong class="bold">Tasks</strong> window.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor275"/>The Tasks window</h2>
			<p>To view the <strong class="bold">Tasks</strong> window, from<a id="_idIndexMarker1489"/> the <strong class="bold">Parallel Tasks</strong> tab, select <strong class="bold">Tasks</strong> from the dropdown. You should see the following:</p>
			<div><div><img src="img/B16617_Figure_15.7.jpg" alt="Figure 15.7 – The Tasks view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.7 – The Tasks view</p>
			<p>The preceding screenshot shows the async logical stacks. If you hover over each method, you will see the following window pop up, as you did with the threads view:</p>
			<div><div><img src="img/B16617_Figure_15.6.jpg" alt="Figure 15.8 – The Thread and Stack Frame view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.8 – The Thread and Stack Frame view</p>
			<p>From the <strong class="bold">Visual Studio</strong> menu, select <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Tasks</strong>. You should see the following pane:</p>
			<div><div><img src="img/B16617_Figure_15.9.jpg" alt="Figure 15.9 – The Tasks pane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.9 – The Tasks pane</p>
			<p>This view shows<a id="_idIndexMarker1490"/> you the various tasks and their states, along with other information. You can right-click on the columns to customize what columns you want to see. Clicking on a line should take you to the source location for you to view the code.</p>
			<p>In the next section, we will look at the Concurrency Visualizer.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor276"/>The Concurrency Visualizer</h2>
			<p>The Concurrency Visualizer<a id="_idIndexMarker1491"/> is a command-line utility that allows you to collect traces from the command line. These can be viewed in the Concurrency Visualizer for Visual Studio 2022, which can be used on computers that don’t have Visual Studio installed. Web projects are not supported by the Concurrency Visualizer; it relies on Windows event tracing.</p>
			<p>By default, <code>CVCollectionCmd.exe</code> is installed in <code>C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\IDE\Extensions\rf2nfg00.o0t</code> and/or <code>C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\rf2nfg00.o0t</code>.</p>
			<p>To begin collecting a trace, you can use a command such as the following:</p>
			<pre class="source-code">C:\Program Files\Microsoft Visual </pre>
			<pre class="source-code">Studio\2022\Preview\Common7\IDE\Extensions\rf2nfg00.o0t\CVC</pre>
			<pre class="source-code">ollectionCmd.exe" /launch D:\dev\CH15_ParallelProgrammingDe</pre>
			<pre class="source-code">buggingAndProfilingSample\CH15_ParallelProgrammingDebugging</pre>
			<pre class="source-code">AndProfilingSample\bin\Debug\net6.0\CH15_ParallelProgrammin</pre>
			<pre class="source-code">gDebuggingAndProfilingSample.exe /outdir D:\Debugging</pre>
			<pre class="source-code">    \TraceData</pre>
			<p>This will start our application<a id="_idIndexMarker1492"/> and log trace data to the location specified by the <code>/outdir</code> command-line argument. Several files will be generated by the tool. They will have <code>.etl</code> and <code>.cvtrace</code> file extensions.</p>
			<p>From the <strong class="bold">Visual Studio</strong> menu, select <strong class="bold">Analyze</strong> | <strong class="bold">Concurrency Visualizer</strong> | <strong class="bold">Open Trace</strong> to view the generated trace file. You should see something similar to the following:</p>
			<div><div><img src="img/B16617_Figure_15.10.jpg" alt="Figure 15.10 – The Contextual Visualizer Utilization tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.10 – The Contextual Visualizer Utilization tab</p>
			<p>This screen shows the number of logical cores that are being utilized by the program you have traced. As you can see, my computer has 16 logical cores. Out of those 16, only 12 are being utilized. Clicking on the <strong class="bold">Threads</strong> tab gives you the following view:</p>
			<div><div><img src="img/B16617_Figure_15.11.jpg" alt="Figure 15.11 – The Contextual Visualizer Threads tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.11 – The Contextual Visualizer Threads tab</p>
			<p>This screen gives us a good, detailed<a id="_idIndexMarker1493"/> breakdown of the threads that were used, their functionality, and the time they took to execute. Clicking on the <strong class="bold">Cores</strong> tab will display the following view:</p>
			<div><div><img src="img/B16617_Figure_15.12.jpg" alt="Figure 15.12 – The Contextual Visualizer Cores tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.12 – The Contextual Visualizer Cores tab</p>
			<p>This view shows the logical cores<a id="_idIndexMarker1494"/> and their usage by the main thread and worker thread. You will see the thread ID, its name, the number of cross-core context switches, total context switches, and the percent of context switches.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Microsoft provides a more detailed look into the Concurrency Visualizer. I have just provided you with a brief overview<a id="_idIndexMarker1495"/> of the tool and how to use it. If you would like to learn more about how to use this tool, then you can view Microsoft’s documentation at <a href="https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022">https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022</a>.</p>
			<p>With that, we’ve reached the end of this chapter. Now, let’s summarize what we’ve learned.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor277"/>Summary</h1>
			<p>In this chapter, we looked at how to use TPL and PLINQ to execute code in parallel. At this point, we understand that the main difference between TPL and PLINQ is that TPL does not efficiently utilize all the cores on a computer, whereas PLINQ does.</p>
			<p>We also saw how we can view the computer’s CPU utilization. Using PLINQ enables us to utilize all the cores of a CPU efficiently to improve code performance. However, when benchmarking parallel code, we saw that it is sometimes faster than non-parallel code, while other times, it is faster. Therefore, it pays to benchmark your code to see what method works best for you.</p>
			<p>We also reviewed a piece of code that demonstrates the use of lambda expressions for expressing both <code>Func</code> and <code>Action</code> delegates. </p>
			<p>Finally, we looked at debugging parallel applications with a code sample that employed the Parallel Tasks window, the Tasks pane, and the Concurrency Visualizer.</p>
			<p>In the next chapter, we will look at asynchronous programming. But before we do, try and answer the questions to see how well you have retained what you have read. Then, check out the <em class="italic">Further reading</em> section to enhance your knowledge.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor278"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What does TPL stand for?</li>
				<li>What does PLINQ stand for?</li>
				<li>What Windows program can you use to view CPU core usage?</li>
				<li>Is parallel code always faster than non-parallel code?</li>
				<li>How can you measure the code performance of parallel methods?</li>
			</ol>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor279"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li><em class="italic">Lambda Expressions in PLINQ and TPL</em>: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl</a></li>
				<li><em class="italic">Task Parallel Library (TPL)</em>: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl</a></li>
				<li><em class="italic">Introduction to PLINQ</em>: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq</a></li>
				<li><em class="italic">Parallel Diagnostic Tools</em>: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools</a></li>
				<li><em class="italic">Debugging Async Code: Parallel Stacks for Tasks</em>: <a href="https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/">https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/</a></li>
				<li><em class="italic">Walkthrough: Debugging a Parallel Application in Visual Studio (C#, Visual Basic, C++)</em>: <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&amp;tabs=csharp#main">https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&amp;tabs=csharp#main</a></li>
			</ul>
		</div>
	</body></html>