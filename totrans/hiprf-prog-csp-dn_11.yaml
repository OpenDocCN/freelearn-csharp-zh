- en: '*Chapter 9*: Enhancing the Performance of Networked Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be very hard pressed when you turn your computer on to not have a single
    application using some kind of network application. Your operating system connects
    to a network to download and install Windows updates. Installed applications will
    poll (check at regular intervals) application servers over the internet to see
    if there are newer versions available for download.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers download audio and visual data over the internet, and websites allow
    you to upload and download files. Business applications communicate with database
    servers. Communication applications send large volumes of textual, audio, and
    visual data over networks – often with multiple people from various parts of the
    world involved in online video meetings and training sessions. Your fintech applications
    communicate with your financial providers over the internet. This is only just
    scratching the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Our world is very interconnected via technology, and it is networks that make
    all this possible. I am sure that you have felt some frustration as a user of
    a website or application when it experiences a slowdown, an application hang,
    or the application temporarily freezes while some other tasks block the UI until
    they have been completed, preventing you from doing any work.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, having applications that are highly performant over a network is
    crucial in today’s fast-paced world. And that is why Microsoft is busy working
    to always improve the efficiency and speed of their software. One such piece of
    software that is relatively new on the scene is **Google Remote Procedural Calls**
    (**gRPCs**). A software framework for making **Remote Procedural Calls** (**RPCs**),
    gRPC/gRPC-Web has received a performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to speed up the performance of network applications.
    You will also learn how to communicate over a network using the `System.IO.Pipelines`
    to provide performant streaming capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the network layers and protocols**: To produce working network
    software, you don’t necessarily need to know anything about networks and how they
    work – that is, unless you are writing low-level software to improve the network
    performance of networked applications. In this section, we will start looking
    at improving the network performance of software by looking at the different layers
    of a network and the protocols that live in those layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improving web-based network traffic**: Many of us use the internet daily
    during our work, family, education, and leisure time. The internet works over
    a web-based network that covers the globe. This network is made up of very slow
    copper wire networks to ultra-fast fiber-optic networks, and many computers with
    varying degrees of processing power. In this section, we will learn how to improve
    traffic over the internet to improve internet resource transfer. You will also
    learn how to monitor web application performance using Microsoft Edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance communication using gRPC**: In this section, we will learn
    how to perform high-speed network inter-process communication using gRPC and gRPC-Web.
    When it comes to gRPC-Web, we will be using Blazor Server for the server-side
    code and Blazor WebAssembly for the client-side code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizing internet resources**: To improve resource upload and download
    times, it pays for you to spend time performing the right kinds of resource optimization.
    In this section, we will learn how to optimize images, text characters, and data
    transmission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using pipelines for content streaming**: In this section, you will learn
    how to break down the data processing, data transmission, and data reception phases
    into several atomic tasks that work together using pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching resources in memory**: In this section, you will learn how to cache
    resources in memory to reduce page transfer and display times. This can help reduce
    network load for other users and prevent bottlenecks and throttling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon completing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand and apply UDP-based and TCP-based network protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor and identify problems with network traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the network retrieval performance of resources using caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue web requests and process responses securely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently stream content over a network such as the internet using pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with all performance-sensitive work, all the techniques and examples in this
    chapter, as well as throughout this book, should be measured in the context of
    your application. The overhead of certain techniques mentioned may not be necessary,
    depending on the scale your networking applications need to handle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the contents of this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book’s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the network layers and protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing applications that interact with networks, it is very useful to
    know what **network protocols** are used. A network protocol is a defined set
    of rules that defines how data is formatted, transmitted, and received between
    different devices and applications over a network. Different network protocols
    are used for different tasks. Some protocols are secure by nature, while some
    protocols are insecure by nature. The **OSI network layer reference model** is
    a good place to start in understanding the layers of a device’s networking capabilities
    and the associated protocols for those layers.
  prefs: []
  type: TYPE_NORMAL
- en: '**OSI** stands for **Open Standards Institute**. The OSI network layer reference
    model is a conceptual model that defines and standardizes the communication between
    computers and telecommunication devices. It is independent of the technology that
    underpins such communication, so it is a technology-agnostic representation of
    the layers and protocols of a device’s network layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – The OSI network layer reference model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Table_9.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1 – The OSI network layer reference model
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a network has seven layers of operation. These layers are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application layer**: The application layer provides a user interface that
    allows users to send and receive data over a network. This layer contains all
    the applications you use and that operate behind the scenes to interact with the
    presentation level. For example, your internet browser employs the HTTP, HTTPS,
    and FTP protocols for transmitting and receiving files over the internet, while
    email clients use POP3, SMTP, and IMAP for sending and receiving email data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presentation layer**: The presentation layer encrypts, formats, and compresses
    the data ready for network transmission. The protocols that are employed in this
    layer include POP/SMTP, Usenet, HTTP, FTP, Telnet, DNS, SNMP, and NFS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session layer**: The session layer initiates and terminates sessions with
    remote systems. This is the layer where ports are assigned for network communication.
    Examples include port 25 for POP/SMTP, port 532 for Usenet, port 80 for HTTP,
    port 443 for HTTPS, ports 20 and 21 for FTP, port 23 for Telnet, port 53 for DNS,
    ports 161 and 162 for SNMP, and the use of an RPC Portmapper for NFS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport layer**: The transport layer breaks down data streams into smaller
    data delivery segments using either TCP or UDP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network layer**: The network layer provides logical addressing using either
    the original IPv4 or the newer IPv6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Link layer**: The data link layer prepares the data for transmission.
    This layer translates information from the network layer into a format that can
    be easily transmitted over the required network type using the SLIP, PPP, 802.2
    SNAP, and Ethernet II protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical layer**: The physical layer is responsible for moving data between
    device locations. The types of physical network connections that this layer can
    make available include RS-X, CAT1 to CAT8, ISDN, ADSL, ATM, FDDI, and Coaxial
    Cable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following protocols are used in these various levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Name Service** (**DNS**): The purpose of the DNS protocol is to translate
    host names into IP addresses and vice versa using what is known as domain name
    resolution. Port 53 is the default port for DNS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Host Configuration Protocol** (**DHCP**): The purpose of DHCP is
    to assign IP address-related information dynamically to networked devices. Ports
    67 and 68 are the default ports for DHCP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypertext Transfer Protocol** (**HTTP**): The purpose of HTTP is to enable
    the transfer of web pages and supporting material over the internet. Port 80 is
    the default port for the HTTP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypertext Transfer Protocol Secure** (**HTTPS**): The purpose of HTTPS is
    to enable the safe transfer of web pages and their supporting material securely
    over the internet. Port 443 is the default port for HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Shell** (**SSH**): The purpose of the SSH protocol is to securely
    connect to a remote computer and move files around and execute various commands.
    The default port for SSH is port 22.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Socket Layer** (**SSL**): The purpose of the SSL protocol is to secure
    the data that is transferred between a server and a web browser. Port 443 is the
    default port for SSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**): The purpose of FTP is to transfer files
    over the internet. Ports 20 and 21 are the default ports for FTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telnet**: Telnet provides insecure two-way interactive text-based communication
    between two computers using virtual terminal connections. Port 23 is the default
    port for Telnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trivial File Transfer Protocol** (**TFTP**): The default port for TFTP is
    port 69\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Mail Transfer Protocol** (**SMTP**): The purpose of SMTP is to ensure
    the safe transmission of emails over the network. Port 25 is the default for the
    SMTP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post Office Protocol version 3** (**POP3**): The purpose of POP3 is to download
    and read emails from email servers. Port 110 is the default port for POP3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Message Access Protocol 4** (**IMAP4**): The purpose of IMAP is
    to access emails on a remote email server without the need to download them. Port
    143 is the default port for IMAP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote Desktop Protocol** (**RDP**): The purpose of RDP is to establish a
    remote connection to a computer and take control of it. Port 3389 is the default
    for RDP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmission Control Protocol** (**TCP**): The purpose of TCP is to provide
    trustworthy assurance that transmitted data will be received. TCP enables data
    sending and receiving. Different protocols come under the banner of TCP and each
    TCP protocol has a default port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Datagram Protocol** (**UDP**): The purpose of UDP is to provide untrusted
    data transmission without the assurance that the data will be received. UDP only
    allows data to be transmitted. Different protocols come under the banner of UDP
    and each UDP protocol has a default port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Protocol** (**IP**): The purpose of the IP is to address how data
    packets are routed between host computers on a TCP/IP network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ethernet**: The purpose of the Ethernet protocol is to provide control over
    how data is transmitted over a LAN per the IEEE 802.3 protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point-to-Point** (**PPP**): The purpose of the PPP protocol is to establish
    a data link connection between two routers using authentication, transmission
    encryption, and data compression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Time Protocol** (**NTP**): The purpose of NTP is to provide clock
    synchronization between computer systems over packet-switched data networks with
    variable latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network News Transport Protocol** (**NNTP**): The purpose of NNTP is to transport
    Usenet articles (*netnews*) between news servers. It is also used by end user
    client applications to read and post articles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only a small subset of the various network protocols that are used
    in today’s world. You are encouraged to further research the various protocols
    in use if you do a lot of programming that requires network access. You can find
    some useful articles to assist your advancement in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand what network protocols are used for, you can select the
    protocol that best suits your need. This helps reduce overhead. For example, if
    you only want to transmit data and do not wish to receive it or care whether it
    is received or not, then you would use the UDP network protocol. However, if you
    must guarantee that data is sent and received, then you must use TCP instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Internet Engineering Task Force** (**IETF**) has defined two **Request
    For Comments** (**RFCs**) network transport protocols that have become internet
    standards. RFC 768 (UDP) defines UDP, whereas RFC 793 (TCP) defines TCP. Here
    are the official links for these RFCs for you to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 768 (UDP): [https://tools.ietf.org/html/rfc768](https://tools.ietf.org/html/rfc768.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC 793 (TCP): [https://tools.ietf.org/html/rfc793](https://tools.ietf.org/html/rfc793)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP is a connection-oriented protocol responsible for ensuring that data is
    transferred reliably across networks via sessions. The sender and receiver agree
    on what data will be transferred. Packet error checking is performed on the received
    data. If there are errors, then a request is submitted to re-transmit the packet
    that failed. TCP is often used with **IP**. Packets are made aware of where to
    go and how to get there by IP. The combination of the TCP and IP protocols, when
    they work together, is defined as TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: UDP differs from TCP as it is connectionless. UDP receivers listen for UDP packets
    with sessions being established. No error checking is performed with UDP. Therefore,
    packets may be lost with the receiver being unaware of the loss of those packets.
    UDP does not acknowledge the sender when data is received or when packets are
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: With TCP establishing connections for communication sessions and performing
    error checking and resubmitting lost or corrupted packets, it is generally considered
    slower than UDP. UPD is faster than TCP because it does not establish connections
    for sessions or perform error checking. Therefore, TCP is the best option when
    data must be received without errors, such as with financial transactions. However,
    UDP is the best option when it comes to streaming live images, such as when you
    are watching a movie. That’s why movies can sometimes appear a bit grainy at times.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, the OSI model does not exist in all practicality. Instead,
    the universally accepted network model that is tangible in a practical way is
    the TCP/IP model.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TCP/IP model differs from the OSI model in that there are only four layers
    that make up the TCP/IP model. These layers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network interface layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how do the layers of the TCP/IP model map to the OSI model? The following
    table presents both models and their layers side by side for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.2 – Comparison between the TCP/IP model and the OSI model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Table_9.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.2 – Comparison between the TCP/IP model and the OSI model
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s describe each layer in the TCP/IP model:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Application layer** enables users to initiate communication between applications
    and systems over a network. This can be sending an email, opening a web page,
    running an application over a network, accessing application information from
    a database, and performing file transfers over a network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transport layer** resolves host-to-host communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Internet layer** connects different networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Network Interface layer** is the physical hardware that enables network
    communication between a server and its hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned about the TCP/IP model, in the next section, we will
    write a simple email application and discuss how it relates to the TCP/IP model.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an example email application with the TCP/IP model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to write a simple console application that sends
    an email using SMTP. Then, we will discuss how this email is sent through the
    TCP/IP model. To write a simple console application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6.0 Console Application and call it `CH09_OsiReferenceModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class called `EmailServer` with the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need these two namespaces for handling exceptions and sending emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code takes the necessary parameters for sending our email programmatically.
    A `MailMessage` is built up from those parameters. Then, we initialize and configure
    a `SmtpClient` to connect to a networked-host email server that sends our email.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Program` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are writing a greeting to the console window. Then, we are calling
    `SendMail()` to send our email, and then finishing with a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `SendMail()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace the email addresses with valid ones. This method calls the `SendMail`
    method in the `EmailServer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Run the program; you should have an email in your email account.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your project working, it is time to discuss how your project links in
    with the TCP/IP network model. Let’s start by looking at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Sending and receiving an email over a network via SMTP using
    the TCP/IP protocol'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Sending and receiving an email over a network via SMTP using the
    TCP/IP protocol
  prefs: []
  type: TYPE_NORMAL
- en: First, start with your email client putting together an email, and the user
    clicking **Send**. When the data hits the Application layer, this is where the
    SMTP protocol comes into play. In this layer, the recipient is contacted, and
    the data is formatted and prefixed with an SMTP header.
  prefs: []
  type: TYPE_NORMAL
- en: The email is then passed to the Transport layer. TCP is employed in this layer
    and is used to break down messages into smaller packets prefixed with a TCP header.
  prefs: []
  type: TYPE_NORMAL
- en: From the transport layer, the email is passed to the Internet layer. IP formats
    the email packets so that they’re ready to be transmitted over the internet and
    prefixes them with an IP header. These formatted TCP/IP packets are then passed
    to the Network interface layer.
  prefs: []
  type: TYPE_NORMAL
- en: At the network interface layer, the sender and receiver IP addresses are added
    to the header that is prefixed to the email. The email is then sent to the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: When the email packet reaches the receiver, it first hits the network layer.
    The header for the network layer is removed, and the email packet is passed to
    the Internet layer. The IP header is removed, and the email packet is passed to
    the transport layer.
  prefs: []
  type: TYPE_NORMAL
- en: At the transport layer, the email packets are then reassembled. Once all the
    packets have been assembled with the TCP headers removed, they are passed to the
    application layer, where the SMTP protocol removes the SMTP header, passes the
    pure email data to the client, and closes the session.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have covered the conceptual OSI model and the practical four-layer
    TCP/IP model. Sending an email was the example we used to discuss the journey
    from the sender to the receiver over the four-layer TCP/IP layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the different layers that make up a network and some
    of the different network protocols and their uses, let’s look at network tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Improving web-based network traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a good idea to keep an eye on the performance of your web applications.
    This helps you see how well your application transmits and receives information
    from the network we all know as the internet or, as it is increasingly being referred
    to, the cloud. You can even track down those calls that are taking a long time
    to complete, enabling you to improve the responsive performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways that you can accomplish this task. But we will only focus
    on one way, and that way is to record your application’s performance in the web
    browser using the in-built development tools performance analyzer. Specifically,
    we will be looking at using Microsoft Edge’s **development tools**. This will
    be the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Recording your web-applications performance using Microsoft Edge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will be using the Microsoft Edge web browser to analyze
    the performance of your web applications. Internet is the name given to the **Wide
    Area Network** (**WAN**) that we use every day to browse the web. Sometimes, web
    applications can be slow, and they are often much slower than their desktop counterparts.
    That is where the developer tools provided by various browsers come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the browser developer tools, you have some powerful capabilities for seeing
    what your application is doing behind the scenes. The main features that are provided
    by various browsers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to navigate the elements of the currently loaded website to view
    the HTML structure, styles employed, computed styles, layout, event listeners,
    DOM breakpoints, properties, and accessibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view console messages, including any error messages raised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view all the resources that make up a page with sources, synchronize
    changes with the local filesystem, override page assets with files from a local
    folder, view content scripts served by extensions, and create and save code snippets
    for later reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can record and view the network traffic generated by a page, including information
    such as name, status, type, initiator, size, time, and waterfall with the **Network**
    tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can record a process. This information can be extremely detailed and you
    can save screenshots, record memory usage, and view the web vitals for the page
    with the **Performance** tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can profile memory usage and have the option to record a heap snapshot,
    allocate instrumentation on time, and allocate a sample.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see and debug the background services for your applications on the **Application**
    tab, including their storage and caches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security, which enables you to view the main origin and secure origins of your
    application, along with its security information, such as whether it has a valid
    **SSL certificate**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each browser from various vendors works in subtly different ways. Developers
    each have their preferences as to which browser and set of developer tools they
    like to use. In this section, we will be using the **Microsoft Edge Network**
    and **Performance** tabs to analyze the performance of a web page. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Microsoft Edge** and press *F12* to open the developer tools. The following
    screen should appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Microsoft Edge developer tools displaying the default tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Microsoft Edge developer tools displaying the default tab
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the address box, type `docs.microsoft.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The website will now load. As it does, you will see the network traffic being
    generated and logged. The following screenshot shows a portion of the data that’s
    been ordered by the resources that took the longest time to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The Microsoft Edge developer tools'' Network tab displaying
    network traffic data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The Microsoft Edge developer tools' Network tab displaying network
    traffic data
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Network** tab is useful for seeing what resource has been
    requested (**name**), the **status** and **type** values of the request, what
    initiated the request (**initiator**), the request **size** and **time** to process,
    and its visual representation on the **Waterfall** chart. This information can
    be applied to your pages and their resources to reduce the overall size of a complete
    request and reduce the time it takes to complete the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen the **Network** tab in action, let’s look at the **Performance**
    tab in action. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Performance** tab, and then click on the **record** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `docs.microsoft.com` into the address bar and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the page has fully loaded, stop the recording by clicking on the popup
    dialog’s **Stop** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The profile that has just been captured will now be loaded and presented to
    you. How long this process will take varies based on how long you were recording
    and how much traffic was generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the profile has finished loading, you should be presented with the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The Microsoft Edge performance profile for docs.microsoft.com'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – The Microsoft Edge performance profile for docs.microsoft.com
  prefs: []
  type: TYPE_NORMAL
- en: You may be unable to read the contents of the preceding screenshot. That’s okay
    – this screenshot just represents the amount of data that you can glean using
    the performance profiler. You have screenshots, a Waterfall chart, a breakdown
    of all the methods and properties that were utilized to load the URL, and a summary
    of the types of traffic by time, such as loading time, scripting time, rendering
    time, painting time, system time, and idle time.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this information to find where most of the time is being taken up
    for a request and identify the method where the time is being consumed. This will
    help you identify the areas of your web projects that may be candidates for performance
    improvement.
  prefs: []
  type: TYPE_NORMAL
- en: There is a wealth of information that can be gathered regarding the performance
    of your application using browser tools. And not all that information has been
    covered here. For instance, we have not even touched on the memory profiling tab
    in Microsoft Edge Developer Tools due to this chapter’s page length restrictions.
    However, you are actively encouraged to try out all the different features available
    in the web browser’s development tools for yourself to help you profile and improve
    the performance of your web applications and their network utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to use browser development tools to profile the
    internet traffic that’s produced by our application requests and responses, let’s
    look at the performance-enhanced **gRPC Remote Procedural Call** (**gRPC**) framework
    for high-speed network data transfer and communication.
  prefs: []
  type: TYPE_NORMAL
- en: High-performance communication using gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is gRPC? It is an open source **RPC** framework. Applications use RPC to
    talk to each other. gRPC is built upon the modern technologies of HTTP/2 for the
    **transport protocol layer** and **protocol buffers** (**Protobuf**) for serializing
    technology for messages. Protobuf also provides a language-neutral contract language.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC has been designed with modern high-performance and cross-platform applications
    in mind. There are implementations for all manner of programming languages. This
    enables applications developed on different operating systems and in different
    programming languages to talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is in an opinionated contract-first framework with the contract being defined
    in a **proto file**. This proto file contains your API definitions and the messages
    they will send and receive. Code generation is then used to generate strongly
    typed clients and messages for your language and platforms, which in our case
    will be C# and .NET. The language of gRPC is binary and designed for computers.
    This makes gRPC perform better than text-based HTTP APIs. The complexity of remoting
    is hidden from the programmer in the gRPC framework. Much of the work you would
    normally have to do by hand as a programmer is done for you by code generation
    tools. And so, all you must do is call methods on your clients and await the results.
    For increased developer productivity and application performance, you are better
    off using gRPC over HTTP APIs.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP APIs are content-first and consider the shape of URLs, HTTP methods, JSON
    and XML, and more. REST APIs are code-first. Normally, you would write your code
    and then generate Swagger or RAML contracts afterward. REST APIs are human-readable
    as they are text-based. This makes them easy to debug with the right tools, but
    these APIs perform slower than gRPC. REST APIs deal with low-level HTTP, so you
    have more to think about in terms of HTTP requests, responses, and routing. This
    is more complicated than using gRPC, but you do end up with a high degree of control.
    So, even though HTTP APIs are not big on performance, they will appeal to the
    widest developer audience. They can be easier to get started with. However, they
    can become incredibly complex and deep-routed when you’re working on complicated
    enterprise software.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about gRPC and HTTP, you will appreciate that the fastest
    network and inter-application communication will be carried out by gRPC and not
    HTTP. And since this book is about performance, we will now demonstrate gRPC at
    work with a simple demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: Programming a simple gRPC client/server application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be building a gRPC service that returns a single message.
    Then, we will write a client to call the gRPC service and update our client and
    server so that we can stream messages. Let’s begin by writing our gRPC service.
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we are going to build a gRPC service in **Visual Studio**.
    Later in this chapter, we will consume this service. To build a gRPC service in
    Visual Studio, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and select **Start a new project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for and select the ASP.NET Core **gRPC Service** template and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `CH09_GrpcService`, and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then be presented with the **Additional information** page. Ensure
    the latest version of .NET Framework is selected from the drop-down; this should
    be .NET 6.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `appsettings.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the project is set as the startup project, and then run it. You should
    be presented with a **Trust ASP.NET Core SSL Certificate** dialog. Click on **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will now be presented with a security dialog, informing you that you are
    about to install a security certificate. Click **Yes** to install it. Once the
    certificate has been installed, your service should [be running. The gRPC](http://localhost:5000)
    service URLs are [http://localhost:5000](http://localhost:5000) and [https://localhost:5001](https://localhost:5001).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ports 5000 and 5001 may be different on your system if they are already in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter https://localhost:5001 in a browser; you should get the following message:
    **Communication with gRPC endpoints must be made through a gRPC client.** To learn
    how to create a client, visit [https://go.microsoft.com/fwlink/?linkid=2086909](https://go.microsoft.com/fwlink/?linkid=2086909).
    This message informs us that the next step is for us to write a client that will
    be able to communicate with the service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that is how easy it is to get started with a gRPC service. Open the `greet.proto`
    file in the `Proto` folder and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the proto language is straightforward. In this file, we stated
    the language’s syntax, assembly namespace, and the name of the package. We then
    provided a service definition, which defines the RPC request and response, followed
    by the request and response messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of code generation that goes on under the hood. So, in case you
    are wondering where certain files are located, you will find them hiding away
    in your `Obj\Debug\net6.0\Protos` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using gRPC for our service, we need a client. So, in the next section,
    we will build our client.
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a gRPC client project that will consume
    our gRPC service. Also, for our client project, we will write a simple console
    application. To add a client project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6.0 Console Application project named `CH09_GrpcServiceClient`
    and change the target framework to `.NET 6.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project’s **Service dependences** node in the Solution Explorer
    and select the **Add Connected Service** menu option. This will present you with
    the following tab:![Figure 9.5 – The Connected Services tab in Visual Studio
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.5 – The Connected Services tab in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Add** button under the **Service References (OpenAPI, gRPC)**
    section. This will bring up the **Add service reference** dialog, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The Add service reference dialog in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – The Add service reference dialog in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **gRPC** option and then click on the **Next** button. The wizard
    dialog presented in the preceding screenshot will move to the **Add a new gRPC
    service reference** page, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The Add a new gRPC service reference page of the Add service
    reference dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – The Add a new gRPC service reference page of the Add service reference
    dialog
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `greet.proto` file in your gRPC service project, and select it.
    Ensure the **client** option is selected from the dropdown list. Then, click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The dialog will change to **Service reference configuration progress**. When
    you get a message stating **Successfully added service reference(s)**, click the
    **Close** button. Your gRPC connected service will now appear in the **Service
    References** section of the **Connected Services** tab, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The Connected Services tab displaying our connected gRPC service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – The Connected Services tab displaying our connected gRPC service
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you have added a client project to your gRPC service. With the client
    projected added, we can now write the console applications. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `CH09_GrpcServiceClient.csproj` file by selecting it in the Solution
    Explorer. You should see the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding XML code, you can see the references to Google’s `Protobuf`
    library and the `gRPC` libraries. You will also see a Protobuf link to your proto
    file in the gRPC service, which indicates that your project is taking on the role
    of the client.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Program` class in your client project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `Main(string[] args)` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our entry point method, we call the asynchronous `ExecuteGrpClient()` method.
    However, because we cannot mark our main method as async, we have to call `Wait()`
    on the `ExecuteGrpcClient()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because we will be awaiting an asynchronous call, we must make the `ExecuteGrpcClient()`
    method asynchronous with the async modifier. This method does not return anything.
    However, it cannot be declared void, so we must provide `Task` as the return type.
    Then, we must declare our gRPC channel by pointing it to our gRPC HTTPS address.
    Then, we must declare our client by passing in the gRPC channel we have just declared
    and initialized. Next, we must obtain a reply by awaiting our asynchronous call
    to our server method and passing in a message request where we set the properties
    as necessary. Finally, we must print the response from the server to the console
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Open the server project in the terminal and type `dotnet run`. The server will
    be running locally on port 5001.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open the client project in the terminal window and type `dotnet run`.
    It will print the following message in the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have successfully written a gRPC server and consumed its message
    by writing and running a gRPC client. So what? What does this mean for you? It
    means that you now have a cross-platform way of communication between different
    applications using a common protocol. And what is the big deal in this regard?
    Well, say that you have several legacy applications written in various languages
    and you want to migrate them all to a common platform and programming language
    such as .NET or C# – you now have a straightforward way to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: By using gRPC, you can provide a phased migration from legacy platforms to the
    .NET 5 and higher platforms and C# 9 and higher programming language. You would
    accomplish this by writing gRPC clients for your .NET clients and legacy clients.
    This would enable you to start using .NET and C# as you incrementally replace
    older systems. Then, gradually, as the older systems are replaced by one modern
    system, you can fully utilize .NET and C# and benefit from all the performance
    improvements the Microsoft teams have made to the language and framework. Plus,
    you can leverage all the business and performance benefits of using the Microsoft
    ecosystem, which includes the Microsoft Azure Cloud services that have been built
    with security, scalability, and performance in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it is worth noting the various languages that are officially
    supported by gRPC. The officially supported languages, operating systems, compilers,
    and SDKs are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.3 – Officially supported languages by gRPC'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Table_9.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.3 – Officially supported languages by gRPC
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, gRPC is well supported across languages, operating systems, SDKs,
    and compilers. So, gRPC is the perfect networking technology to bring disparate
    systems together using one harmonious messaging framework.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have consumed a unary request and know that gRPC can be used with
    various operating systems and programming languages. But what if you need to handle
    a whole batch of gRPC requests? How do we do that? Good question. We’ll learn
    how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming multiple gRPC requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will be modifying our client and server gRPC projects to
    send and process message streams. By the end of this project, you will be sending
    10 messages from the server to the client. On the client, you will process each
    message as it comes in and write it to the console window. To do so, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `greet.proto` file in the `CH09_GrpcService` project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see that you have added a new message stream to our service definition.
    Instead of returning a single `HelloReply` message, the message stream returns
    a stream of messages of the `HelloReply` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GreeterService` class of the `CH09_GrpcServer` project, add the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, you are iterating 10 times. For each iteration, you await the
    `responseStream.WriteAsync(HelloReply)` method. In this asynchronous call, you
    set the message on the `HelloReply` object. With each iteration taking only milliseconds,
    you will purposefully slow down the processing of the task for human eyes to see
    each method being written one after the other. This delay slows down your task
    by 10 seconds – a second for each iteration. In a normal application, you would
    normally not have such a delay in place.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have updated your server project, rebuild both projects to see
    the changes and move to your `CH09_GrpcServiceClient` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program` class, move the code inside the `ExecuteGrpcClient()` method
    into its own method called `SingleGrpcMessageClient()`. Then, add the following
    two lines of code to the `ExecuteGrpcClient()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code contains two asynchronous calls: one for a single message,
    and one for streaming multiple messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GrpcMessageResponseStream()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GrpcMessageResponseStream()` creates a `GrpcChannel` and assigns it to a new
    client. A call is then made to a gRPC stream. This iterates through all the items
    in the stream that have been sent back to the client from the server, and then
    prints the message for each item to the console window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open each of the projects in their own terminals and type the `dotnet run`
    command. This will start the server and run the client. You should see the following
    console window output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now know how to use gRPC with desktop applications. In the next section,
    you will learn how to use gRPC with Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Programming a simple gRPC Blazor application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Blazor** is a web programming model. With Blazor, you can have server-side
    Blazor projects that you would write when you have sensitive information that
    you need to keep secret. You can have client-side Blazor projects when application
    performance is of the utmost importance. As part of an organization’s enterprise
    application, you have many different Blazor server-side and client-side applications
    working together as one.'
  prefs: []
  type: TYPE_NORMAL
- en: For gRPC to work with web projects, a wrapper called gRPC-Web has been developed.
    This enables you to have both gRPC-Web services and gRPC-Web clients. With gRPC-Web,
    it is possible to build end-to-end pipelines that are compatible with the HTTP/1.1
    and HTTP/2 protocols. This provides a competitive edge over browser APIs that
    are unable to call gRPC HTTP/2, especially when you consider that not all .NET
    platforms have support for HTTP/2 via the `HttpClient` class. Another benefit
    of gRPC-Web is that you don’t have to use just TCP for **Inter-Process Communication**
    (**IPC**). For IPC, you can also use named pipes (UDP) and **Unix domain sockets**
    (**UDS**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The default template app for Blazor has a fetch data page that uses JSON for
    its data backend. The data size for this JSON file is 627 bytes. But when JSON
    is replaced with gRPC, the size of the data is reduced to 309 bytes. This example
    shows that data transfer is quicker using gRPC-Web than it is using JSON, as there
    is not so much data to transmit and receive over the network. The reduced size
    of the data transmission using gRPC-Web means that more requests can be made over
    the network before the requests need to be throttled.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 6.0, applications are made smaller via aggressive trimming. You can
    aggressively trim gRPC-based applications to reduce their size and increase their
    performance, especially when it comes to sending data over networks. This is because
    of the in-built code generation that is part of gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: In web projects, gRPC cannot be directly accessed. Therefore, a proxy project
    known as gRPC-Web was introduced to enable the use of gRPC with web projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will be writing a Blazor client and Server gRPC
    application consisting of a Blazor Server Application and a Blazor WebAssembly
    Application. Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: The blank solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to start with a blank solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and search for `Blank Solution`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the blank solution and name it `CH09_BlazorGrpc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will provide a blank solution to which we can add our client and server
    Blazor applications. Next, we will work on our client project.
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor client project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will build our Blazor client gRPC application. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `CH09_BlazorGrpc.Client`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following NuGet packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Google.Protobuf`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Grpc.Net.Client`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Grpc.Net.Client.Web`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Grpc.Tools`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder called `Protos` and a file to that folder called `person.proto`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `person.proto` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our proto file defines the proto definition version as proto3\. So, the `proto3`
    syntax will be used. The namespace for our service definition is `CH09_BlazorGrpc.Client`.
    The name that’s been given to our package is `grpcpeople`. There are three messages
    called `PeopleRequest`, `PeopleResponse`, and `PersonResponse`. Finally, we define
    our service as `Person` with an RPC called `GetPeople` that takes a `PeopleRequest`
    and returns a `PeopleResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following imports to the `_Imports.razor` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These imports will be available to all our files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `Pages`/`Index.razor` page and replace its contents with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will call the gRPC service that has been located by the service
    app and list the people that have been returned.
  prefs: []
  type: TYPE_NORMAL
- en: That’s our client application completed. Now, let’s write our server application.
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor server project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will write our server application, which will contain our
    service responsible for returning the requested data to the client. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Blazor Server app called `CH09_BlazorGrpc.Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Grpc.AspNetCore` and `Grpc.AspNetCore.Web` NuGet packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Protos` folder and its contents from the client project and paste
    it into the server project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `PeopleService` class to the root of the server project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the `PeopleService` class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This service has a single method that returns a list of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code in the `Program.cs` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code configures our Blazor application to use gRPC and sets up
    our `PeopleService` class so that our client application can use it. We also configured
    `Cors` so that our gRPC requests and responses don’t get blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the solution and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Startup Project**, select **Multiple startup projects** and change **Action**
    to **Start** for both the client and the server projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to close the property dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the project. Two browser and two console windows should open. If all goes
    well, then you should see the following browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The client Blazor application showing the response from the
    gRPC service in the server app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – The client Blazor application showing the response from the gRPC
    service in the server app
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The port numbers depend on the ports that are available on a system. So, alternative
    ports will be used if ports 5000 and 5001 are already in use. This has happened
    here, in which port 7272 is being used for the server app and port 7108 is being
    used for the client app.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have learned about desktop and web-based network data transmission
    and communication using gRPC and gRPC-Web, both of which have received several
    performance enhancements along with C# and .NET Framework. You have also used
    the Blazor server and Blazor WebAssembly to perform web data transmissions and
    receive data.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this information to replace your code that uses the JSON data format
    with the binary format of gRPC. This should cut down the size of your data transmissions
    and reduce the time it takes for the data to be transmitted and received, thus
    improving the performance of your networked applications – especially those applications
    that deal with huge volumes of data.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing internet resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best web page is a web page that does the minimum it needs to present the
    necessary data that you want your users to view. Noisy web pages take longer to
    load and can be a source of irritation to your end users.
  prefs: []
  type: TYPE_NORMAL
- en: When you use advert services and analytical and health monitoring services,
    these can produce unnecessary network traffic and an increase in page load time.
    So, you need to be concise in what data you gather regarding the page that is
    loading. You also need to reduce the number of resources that your page is downloading.
    Some of these resources will be explained here.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Images** are one of the resources that can significantly increase the time
    it takes to load a page. Therefore, it is important to use the right image format
    and compression for your images. It is often necessary to reduce the file size
    of images. Images usually come in three file formats: **JPEG/JPG**, **PNG**, and
    **GIF/animated GIF**. When it comes to image optimization, you are best off experimenting
    based on your website requirements. This is because you will need to factor in
    the tradeoff between image quality and image size, depending on your specific
    requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a tool that you can use for PNG optimization is PNGGauntlet by
    Ben Hollis: [https://pnggauntlet.com/](https://pnggauntlet.com/). This tool creates
    small PBGs by combining PNGOUT, OptiPNG, and DeflOpt with no loss of image quality.
    It can also convert the JPG, GIF, TIFF, and BMP file formats into PNG. You can
    configure the tool to your liking.'
  prefs: []
  type: TYPE_NORMAL
- en: Text characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When transmitting text over the internet, the more characters you have, the
    larger the file you will have. As a page grows, the time to load that page increases.
    You can reduce the size of each request and response by enabling deflate or `gzip`
    compression. Most, if not all, web servers provide web compression. You will have
    to look at how to enable web compression in the web server that you are using.
  prefs: []
  type: TYPE_NORMAL
- en: You can also reduce the size of your HTML, CSS, and JavaScript files in production
    by using minification. During development, when you have reached the stage where
    you are ready to deploy your application, you can employ tools such as webpack
    that will condense your files by removing unnecessary whitespace, comments, and
    unused code. Tools such as webpack can drastically reduce the size of your files.
  prefs: []
  type: TYPE_NORMAL
- en: This size reduction results in less data being transmitted over a network, meaning
    that the files a user has requested get downloaded on their device much faster.
    The quicker that requested files are downloaded to a user’s device, the quicker
    the requested page will be rendered for them to view.
  prefs: []
  type: TYPE_NORMAL
- en: Data transmission
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transmitting data over a network takes time. That time can vary based on several
    different factors, such as the amount of network traffic and the route taken.
    Not all networks use fiber optic, and there are still locations over the internet
    that are still on slow copper wire connections.
  prefs: []
  type: TYPE_NORMAL
- en: One way to reduce network traffic and load time for networked resources is to
    **cache** them on the user’s computer that requested the resource. When a network
    resource is requested, the application will check if it exists in the cache. If
    it does, then the item will be retrieved from the cache on the user’s computer.
    But if the item is not in the cache, it will be downloaded over the network and
    stored in the user’s cache. When an item is being retrieved from the cache, the
    expiration date and time will be checked for the resource. If the expiry date
    and time have been reached, then the resource will be downloaded from over the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when working with large volumes of data, it is best to filter the data
    on the server and only return the subset of the data that you require. If the
    amount of data that you require is quite large, then employ data paging, whereby
    the data is divided into pages. Then, you only need to download a page as it is
    requested. This reduces the time it takes to receive the data once the request
    has been made.
  prefs: []
  type: TYPE_NORMAL
- en: Using pipelines for content streaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`System.IO.Pipelines` is a high-performance I/O .NET library that was first
    shipped with .NET Core 2.1 and was born from performance work carried out by the
    Kestrel team. The purpose behind pipelines is to reduce the complexity of correctly
    parsing stream and socket data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to use pipelines with sockets. We will write
    to small console applications. The first console application will listen for incoming
    requests on port `7000` and output the contents to the console window. The second
    console application will listen for the newline key. When it is detected, it will
    send the contents of the command line to the server on port `7000`. By completing
    this project, you will see how easy it is to write a network communication application
    with a minimal number of lines of code using pipes and sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by writing our server console app.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running a TCP server console application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use sockets and pipelines to write a console application
    that listens for incoming data on port `7000`. When data is received, it is processed
    and output to the console window. To write a TCP server console application, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6.0 Console Application called `CH09_TcpServer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `System.IO.Pipelines` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class called `SocketExtensions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is our `SocketExtensions` class, which we will build up with extension
    methods to simplify our socket code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReceiveAsync` extension method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method extends a socket to delimit a section of a one-dimensional array.
    It receives data from a connected socket and returns a `Task` that represents
    the asynchronous receive operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetString` extension method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method extends a socket to delimit a section of a one-dimensional array.
    Then, it decodes a sequence of bytes into a string and returns the decoded string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetArray` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets contiguous memory and returns a delimited section of a one-dimensional
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the final extension method – that is, `GetArray`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method tries to get a segment from the underlying memory buffer. The return
    value indicates the success of the operation. A delimited segment of a one-dimensional
    array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `Program.cs` file’s source code with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our top-level code creates a socket on port `7000`. Then, it listens for incoming
    data on port `7000` and processes the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ProcessLinesAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this method, we pass in a socket. The socket is assigned to a new `NetworkStream`
    object. Then, the new `NetworkStream` object is passed into a new `PipeReader`
    object. While there is data to be read, we read and process each line in the stream
    in turn. Once the stream has been completely read from start to finish, we mark
    the reader as complete so that no more data will be read from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `TryReadLine` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method attempts to read a line of a `ReadOnlySequence` of bytes. If is
    unable to, it will return false. But if it can, it will set the line it can read
    as a `ReadOnlySequence` of bytes and return true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add our final method for our TCP Server called `ProcessLine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All we are doing here is printing the contents of the stream to the console
    window line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program. You should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The TCP Server in a running state ready to receive connections
    on port 7000'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – The TCP Server in a running state ready to receive connections
    on port 7000
  prefs: []
  type: TYPE_NORMAL
- en: You now have your TCP Server project up and running. The next step in developing
    your understanding of pipelines is to write our TCP Client project. We will do
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running a TCP client console application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will continue looking at pipelines by writing the TCP client
    console application that will be sending console input to the TCP Server. The
    data received by the TCP Server from our TCP client will be displayed in the TCP
    Server’s window:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6.0 Console Application called `CH09_TcpClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, you will need to include the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need these namespaces for our TCP Client to read the console input and
    send it to the TCP Server for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following top-level statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For our TCP Client, we simply open a new TCP socket on port `7000` and connect
    using the `IPAddress.Loopback` address. Then, we pass the socket into a new `NetworkStream`.
    Finally, we listen for input from the console window’s standard input and copy
    that input to the network stream that transmits the data to our TCP Server for
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program. You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The TCP Client listening on port 7000'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87742.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – The TCP Client listening on port 7000
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `Hello, World!` and press *Enter*. Your TCP Client console application
    should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The TCP Client console window displaying user input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87751.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – The TCP Client console window displaying user input
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the TCP Server console window. You will see that the message **Hello,
    World!** has appeared since you typed the same message in the TCP Client window
    and pressed *Enter*, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The TCP Server console window displaying the response from
    the TCP Client'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87759.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – The TCP Server console window displaying the response from the
    TCP Client
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have finished writing and running the TCP client and server console
    applications, and you have seen just how simple it is to write a console application
    with sockets and pipelines. The code is very minimal and you can chain multiple
    pipelines together. For example, on the client end, a chained pipeline could be
    the serialization of an object followed by its encryption. Then, at the server
    end, the data could be decrypted and deserialized, and the resulting object could
    then be passed to LINQ, which would save the data contained in the object to a
    database. We can use sockets and pipelines with most C# project types, and you
    are encouraged to experiment with your own little projects to further your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Caching resources in memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Caching** items in memory requires RAM to be allocated so that they can be
    stored and retrieved efficiently. Storing frequently accessed resources in memory
    greatly improves the performance of applications.'
  prefs: []
  type: TYPE_NORMAL
- en: A typical application that benefits from caching is a website. A traditional
    website will consist of HTML pages that define the structure of the visual web
    page that’s displayed to end users, CSS, which styles the page and makes it look
    nice, and JavaScript, which makes websites dynamic and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Many pages of a website can use the same resources, such as data, images, sounds,
    files, and objects. Caching – temporarily storing some item so that it can be
    retrieved efficiently – can be done with a database, filesystem, or memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to store items in memory. Microsoft recommends
    the use of their `Microsoft.Extensions.Caching.Memory` NuGet package for caching
    items in memory. Therefore, we will follow their guidance and use this library
    in our example project.
  prefs: []
  type: TYPE_NORMAL
- en: We will be creating a very simple ASP.NET Core website that displays the current
    time and the cached time. When the cached time has expired, we will reset the
    cache. Each time the home view is called, we will output some text to the immediate
    window that displays the current time, the cached time, and the time difference
    in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'After each specified period has elapsed, you will see that the cache is reset,
    along with the time that’s output to the screen after the page refresh. To write
    our ASP.NET Core MVC web application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new empty ASP.NET Core MVC Web Application, ensuring that your target
    framework is `net6.0` and called `CH09_AspNetCoreCaching`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Microsoft.Extensions.Caching.Memory` NuGet package, and then add the
    `using` statement for this package to the `HomeController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `IMemoryCache` member variable and update the `HomeController` constructor,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `_memoryCache` variable will hold our cache in memory. The object that’s
    being used as our memory cache is injected into the `HomeController` constructor
    as a parameter and assigned to our variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `SetCache` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts a key and a value. We set our `MemoryCacheEntryOptions`
    with a sliding expiration of 20 seconds and then set the cached entry’s value,
    which will expire in 20 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is update the `HomeController` constructor’s `Index`
    method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code declares a `DateTime` variable called `whenCached`. It checks
    if the value exists. If it does, its value will be set to the time when the variable
    was cached. If the variable does not exist, then it will be added to the cache.
    If it does exist, then the difference in time between now and when the variable
    was cached is calculated, and the results will be output to the debug window if
    the cache has not expired. If the cache has expired, then the cached variable
    will be updated with the current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our Home view’s HTML code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines our model for the Razor page. The title of our page
    is set to `Index`. Our main page title is `Index`. Finally, we have a row that
    defines when the variable was cached and the current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our `Program.cs file` to inform our website to use memory
    caching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, our services have been configured to use the memory cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have configured our MVC application to use memory caching with
    sliding expiration. This means that we are now ready to run our project. Run the
    project and refresh a few times within 20 seconds, and then watch what happens.
    You will see that the cached and current times start the same. Then, when you
    refresh the page, you will see that the cached time remains the same, but the
    current time is ahead of the cached time. Then, when 20 seconds is over, the cached
    time will be updated in sync with the current time, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – ASP.NET Core MVC memory caching example in action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_9.14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – ASP.NET Core MVC memory caching example in action
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot and by running the code, we now
    have a way of storing items in a computer’s memory cache, and we can determine
    when its cache value expires and has to be updated. This is a really simple way
    to improve a networked application’s network performance. It also reduces the
    amount of data that is transmitted over a network. This, in turn, helps reduce
    bandwidth problems and reduces transaction and network traffic costs for cloud-hosted
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this chapter. Now, let’s summarize what we have learned from
    working through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you studied the OSI reference model to understand the different
    layers of a network and the various protocols available for each layer. You also
    learned that the various protocols can be grouped into two main groups: TCP and
    UDP.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned about web browser development tools, which allow you to monitor
    your website’s activities, such as memory usage and network traffic. You also
    saw the errors it raises via the console window. This can help identify problems
    and resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: From there, you learned how to add gRPC for desktop clients and servers, and
    gRPC-Web for web-based clients and servers. You learned that gRPC helps reduce
    the size of data compared to the JSON data format, thus reducing page load time.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you learned how to optimize internet resources. This includes using
    the correct file format and reducing the size of images, caching items to reduce
    network traffic and load times, reducing the number of background services that
    are running, and limiting the number of resources that your page loads. You also
    considered filtering data on the server and dividing it into pages that are returned
    as requested.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to write and run TCP client and server console applications
    before looking at memory caching, in which you can use ASP.NET Core MVC as your
    host project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be working with data by benchmarking different
    methods for inserting, updating, and deleting data efficiently. This will help
    us choose the best method for data operations based on our benchmark results.
    But before we do that, take some time to go through the *Further reading* section
    to further your knowledge on improving network performance. Also, try your hand
    at the questions to see how much knowledge you have retained.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the seven layers of the OSI reference model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some network protocols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between TCP/IP and UDP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you see what errors are produced by your web page, what network traffic
    it produces, and how much memory it uses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are gRPC and gRPC-Web?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How you can optimize internet resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OSI seven layers model explained with examples: [https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is,and%20software%20applications%20which%20work%20in%20dissimilar%20environments](https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is,and%20software%20applications%20which%20work%20in%20dissimilar%20en)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TCP/IP model: [https://ipcisco.com/lesson/tcp-ip-model/](https://ipcisco.com/lesson/tcp-ip-model/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overview of common TCP and UDP default ports: [https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default,FTP%20is%20to%20transfer%20files%20over...%20More](https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default,FTP%20is%20to%20transfer%20files%20over...%20More)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'List of TCP and UDP port numbers: [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internet protocol suite: [https://en.wikipedia.org/wiki/Internet_protocol_suite](https://en.wikipedia.org/wiki/Internet_protocol_suite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET network tracing: [https://www.shanebart.com/dotnet-network-tracing/](https://www.shanebart.com/dotnet-network-tracing/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dotnet-trace instructions: [https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md](https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to view and kill processes using the Terminal in Mac OS X: [https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/](https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to find a process name using a PID number in Linux: [https://www.tecmint.com/find-process-name-pid-number-linux/](https://www.tecmint.com/find-process-name-pid-number-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'High-performance services with gRPC – what’s new in .NET 5: [https://www.youtube.com/watch?v=EJ8M2Em5Zzc](https://www.youtube.com/watch?v=EJ8M2Em5Zzc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gRPC-Web with .NET: [https://www.youtube.com/watch?v=UV-VnlcpDhU](https://www.youtube.com/watch?v=UV-VnlcpDhU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Conf 2021 new Blazor WebAssembly capabilities in .NET 6: https://www.youtube.com/watch?v=kesUNeBZ1Os&list=PLdo4fOcmZ0oVFtp9MDEBNb
    A2sSqYvXSXO&index=20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Conf 2021 high-performance services with gRPC – what’s new in .NET 6:
    [https://www.youtube.com/watch?v=CXH_jEa8dUw&list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&index=31](https://www.youtube.com/watch?v=CXH_jEa8dUw&list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&index=31)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everything about Blazor: [https://codewithmukesh.com/blog/category/dotnet/blazor/](https://codewithmukesh.com/blog/category/dotnet/blazor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
