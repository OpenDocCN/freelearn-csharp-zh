<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>Native Libraries in .NET Core</title>
    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Native Libraries in .NET Core</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to learn about ncurses native libraries and how to extend console capabilities in .NET Core on Linux. We will also learn how to Interop with existing native code. This chapter will introduce the ncurses native library and Interop with existing native and Mono libraries. We will build a sample native library in C++ and we will also learn how to create an application that implements the new library and ncurses. The purpose of this chapter is to get an understanding of Interop with existing libraries, and the ability to extend console capabilities through implementing ncurses.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Introduction to ncurses</li>
<li>Interop with existing native and Mono libraries</li>
<li>Building a sample native library (C++)</li>
<li>A sample application to implement the new library and ncurses</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to ncurses</h1>
                </header>
            
            <article>
                
<p><span><strong>New curses</strong> (</span><strong>ncurses</strong>) is an openly distributable library of functions that deals with an application's <span><strong>user interface</strong> (</span><strong>UI</strong>) in text mode. It creates a wrapper over terminal abilities. ncurses is a free software, it is not an open source. It provides functions to make imaginary screen windows for logical calculations, print windows, and so on. Libraries for panels, menus, and forms use the ncurses library and extend the basic functionality of ncurses as required. We can make applications that contain numerous windows, menus, panels, and forms; windows can be overseen autonomously, can give scrollability, and can even be covered up.</p>
<p>Menus give the client a simple order determination choice, forms permit the formation of easy−to−use information sections and show windows, and panels stretch out the abilities of ncurses to manage covering and stacked windows. These are a portion of the essential things we can do with ncurses. As we progress, we will see how to build a native library using C++.</p>
<p>ncurses comes with the Visual Studio Code installation and we can download&#160;<kbd>ncurses-6.0.tar.gz</kbd>, from <a href="http://ftp.gnu.org/pub/gnu/ncurses/">http://ftp.gnu.org/pub/gnu/ncurses/</a>. After downloading, unzip and install ncurses 6.0 (the latest version at the time of writing this book):</p>
<div class="CDPAlignCenter CDPAlign"><img height="360" width="604" src="assets/f3c379ea-c508-4e74-8fca-3099a47b75fc.png"/></div>
<p>Open the Terminal from the folder,&#160;<kbd>ncurses-6.0</kbd>, and r<span>un the following commands to install ncurses</span>:</p>
<ul>
<li><kbd>./configure</kbd>:&#160;Configure the build according to your environment</li>
<li><kbd>make</kbd>:&#160;Make it</li>
<li><kbd>su root</kbd>:&#160;Become root</li>
<li><kbd>make install</kbd>:&#160;Install it</li>
</ul>
<p>Let's start with a simple application,&#160;<kbd>"Welcome to .NET Core 2.0"</kbd>, to understand how to start, use, alter, and close ncurses:</p>
<pre>#include &lt;ncurses.h&gt;<br/> <br/>Void WelcomeMessage()<br/>{<br/>  initscr(); /* Start ncurses mode */<br/>  printw("Welcome to .NET Core 2.0"); /* Print welcome message */<br/>  Move(3, 2); /* moves the cursor to 3rd row and 2nd column */<br/>  Addch('a' | A_Bold | A_UNDERLINE); /* Move() and addch() functions     <br/>  can be replaced by mvaddch(row,col,ch); */<br/>  refresh(); /* Print it on to the real screen */<br/>  getch(); /* Wait for user input */<br/>  endwin(); /* End curses mode */<br/>}<br/>int main()<br/>{<br/>  WelcomeMessage();<br/>  return 0;<br/>}</pre>
<p>Write a function called&#160;<kbd>WelcomeMessage()</kbd> which returns void, and call it from <kbd>main,</kbd> as shown in the example. Let's try to understand each function that we called inside the <kbd>WelcomeMessage</kbd> function:</p>
<ul>
<li><kbd>Initscr()</kbd>:&#160;This function initiates&#160;the Terminal in curses mode. It is typically the main curses method to call while introducing a program. A couple of uncommon methods, once in a while, should be called before it; these are <kbd>slk_init()</kbd>, <kbd>channel()</kbd>, <kbd>ripoffline()</kbd>, and&#160;<kbd>use_env()</kbd>. For different Terminal applications, <kbd>newterm()</kbd> might be called before <kbd>initscr()</kbd>. The <kbd>initscr()</kbd> code decides the Terminal sort and instates all curses data structures. <kbd>initscr()</kbd> likewise makes the main call,&#160;<kbd>refresh(),</kbd> to clear the screen. On the off chance that errors arise, <kbd>initscr()</kbd> composes an error message to standard error and exits; otherwise, a pointer comes back to stdscr. A program that yields to more than one Terminal should utilize the <kbd>newterm()</kbd> routine for every Terminal, rather than <kbd>initscr()</kbd>. The method <kbd>newterm()</kbd> ought to be called once for every Terminal.&#160;</li>
<li>&#160;<kbd>printw("Welcome to .NET Core 2.0")</kbd>:&#160;This prints <kbd>" Welcome to .NET Core 2.0"</kbd> on the screen. <kbd>printw()</kbd> is a class of functions:
<ul>
<li><strong><kbd>printw()</kbd></strong>: This function works similar to <kbd>printf()</kbd> with the exception that it prints the information on a window called stdscr and with the added capability of printing at any position on the screen at the current (<em>y, x</em>) coordinates. If the cursor is at coordinates (0,0), the string is printed at the left corner of the window.</li>
<li><kbd>mvprintw()</kbd>:&#160;This function can be used to move the cursor to a position and then print. If you want to move the cursor first and then print using the&#160;<kbd>printw()</kbd> function, use <kbd>move()</kbd> first and then use <kbd>printw()</kbd>. I think instead of using <kbd>move()</kbd> and <kbd>printw()</kbd>, using <kbd>mvprintw()</kbd> is better, because you get the flexibility to manipulate.</li>
<li><strong><kbd>wprintw()</kbd></strong> and <strong><kbd>mvwprintw()</kbd></strong>:<strong>&#160;</strong>These two functions are similar to the preceding two functions, except that they print in the corresponding window given as an argument.</li>
<li><kbd>vwprintw()</kbd>:&#160;This function is similar to <kbd>vprintf()</kbd>. This can be used when a variable number of arguments are to be printed.</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">The earlier program demonstrates how easy it is to use <kbd>printw</kbd>. You just feed the message to be shown on the screen, then it does what you want. When we call&#160;<kbd>printw</kbd>, the information is really composed for an imaginary window, which isn't refreshed on the screen yet. The activity of <kbd>printw</kbd> is to refresh a couple of banners and information structures and compose the information to a support as compare to <kbd>stdscr()</kbd>. With a specific end goal of demonstrating it on the screen, we have to call <kbd>refresh()</kbd>, and advise the curses framework to dump the substance on the screen. The logic behind this is to enable the software engineer to do different updates on the imaginary screen or windows, and do a revive once all his/her screen refresh is finished.</p>
<div class="packt_infobox">All these functions take the&#160;<em>y</em> coordinate first and after that,&#160;<em>x</em> in their arguments. A typical slip up by beginners is to pass <em>x</em>,<em>y</em> in a specific order. In the event that you are doing an excess amount of manipulations of (<em>y</em>,&#160;<em>x</em>) coordinates, consider isolating the screen into windows and control every one independently.</div>
<ul>
<li><kbd>Move(row,col)</kbd>: The function&#160;<kbd>move()</kbd>&#160;moves the cursor to the desired position by passing row and column values.</li>
<li><strong><kbd>Addch(ch | A_attribute)</kbd>:</strong><span>&#160;This function is utilized to print a character at the current cursor position on the stdscr window. We can pass attributes to print characters based on the attribute, for instance,&#160;<kbd>addch(ch |A_Bold |A_underline)</kbd>&#160;will print characters in bold and underlined. The following specified attributes characterized in <kbd>&lt;ncurses.h&gt;</kbd>&#160;can be passed to functions</span> <kbd>attron()</kbd><span>,</span> <kbd>attroff()</kbd><span>, and the</span> <kbd>attrset()</kbd> <span>,</span> <kbd>attron()</kbd> <span>functions turn on the attribute, and correspondingly</span> <kbd>attoff()</kbd> <span>turns off the attribute. To set the quality for a window, we should utilize</span> <kbd>attrset(),</kbd> <span>for instance, in the event that we compose</span> <kbd>attrset(A_NORMAL)</kbd><span>, it sets a typical show with no feature for a window, and it turns off all attributes.</span><span><br/></span> We can use multiple attributes at the same time using <kbd>OR</kbd> <kbd>(|)</kbd> <span>with the characters passed to</span> <kbd>addch()</kbd><span>. They are as shown in the following table:</span>
<table>
<tbody>
<tr>
<td>
<p><strong>Sr. No.</strong></p>
</td>
<td>
<p><strong>Attribute name</strong></p>
</td>
<td>
<p><strong>Attribute use</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p><kbd>A_NORMAL</kbd></p>
</td>
<td>
<p>Normal display (no highlight)</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p><kbd>A_UNDERLINE</kbd></p>
</td>
<td>
<p>Underlining</p>
<p>&#160;</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p><kbd>A_BOLD</kbd></p>
</td>
<td>
<p>Extra bright or bold</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p><kbd>A_PROTECT</kbd></p>
</td>
<td>
<p>Protected mode</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p><kbd>A_INVIS</kbd></p>
</td>
<td>
<p>Invisible or blank mode</p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p><kbd>A_ALTCHARSET</kbd></p>
</td>
<td>
<p>Alternate character set</p>
</td>
</tr>
<tr>
<td>
<p>7</p>
</td>
<td>
<p><kbd>A_CHARTEXT</kbd></p>
</td>
<td>
<p>Bit-mask to extract a character</p>
</td>
</tr>
<tr>
<td>
<p>8</p>
</td>
<td>
<p><kbd>A_DIM</kbd></p>
</td>
<td>
<p>Half bright</p>
</td>
</tr>
<tr>
<td>
<p>9</p>
</td>
<td>
<p><kbd>A_BLINK</kbd></p>
</td>
<td>
<p>Blinking</p>
</td>
</tr>
<tr>
<td>
<p>10</p>
</td>
<td>
<p><kbd>A_REVERSE</kbd></p>
</td>
<td>
<p>Reverse video</p>
</td>
</tr>
<tr>
<td>
<p>11</p>
</td>
<td>
<p><kbd>A_STANDOUT</kbd></p>
</td>
<td>
<p>Best highlighting mode of the Terminal</p>
</td>
</tr>
<tr>
<td>
<p>12</p>
</td>
<td>
<p><kbd>COLOR_PAIR(n)</kbd></p>
</td>
<td>
<p>Color-pair number <em>n</em></p>
</td>
</tr>
</tbody>
</table>
<p>If we want to print a character in a specific location or cursor position, we can use the following functions, instead of using the&#160;<kbd>move()</kbd> and&#160;<kbd>addch()</kbd>&#160;functions:</p>
<ul>
<li><kbd>mvaddch()</kbd>: This function is used to print characters at the desired location by passing the cursor location, for example, <kbd><kbd>mvaddch(row,col,ch)</kbd></kbd></li>
<li><kbd>waddch()</kbd>: This function is useful for printing characters at the present cursor location in a specified window</li>
<li><kbd>mvwaddch()</kbd>: This function is used to print characters at a definite cursor location in a specific window by passing row, column, character, and window</li>
</ul>
</li>
<li><kbd>refresh()</kbd>:&#160;This function checks the window and updates only the bit which has been changed. This improves execution and offers more significant flexibility. A beginners' common error is to not call <kbd>refresh()</kbd> after they did some refreshing through the&#160;<kbd>printw()</kbd> class of functions.</li>
<li><strong><kbd>getch()</kbd>:</strong>&#160;This function sits tight for the client to press a key, unless you stipulated a timeout, and when the client presses a key, the matching integer number gets returned. At that point, we can check that the value came back with the constants characterized in <kbd>curses.h</kbd>, to compare against the keys you need. On the off chance that it is a normal character, the integer number value will be equal to the character, otherwise it restores a number which can be coordinated with the constants characterized in <kbd>curses.h</kbd>. For instance, if the client presses <em>F1</em>, the number returned is <kbd>265</kbd>. This can be checked utilizing the full scale <kbd>KEY_F()</kbd>, characterized in <kbd>curses.h</kbd>. This makes <span>reading</span>&#160;keys convenient and simple to oversee.</li>
<li><kbd>endwin()</kbd>:<span>&#160;This function ends the curses mode, else our Terminal may behave&#160;unusually after the program stops.</span> <kbd>endwin()</kbd> <span>frees up the memory taken by the curses subsystem and its data structures, and puts the Terminal in normal mode. This function must be called when we are finished with the curses mode.<br/></span>A program should reliably call <kbd>endwin()</kbd> <span>before quickly leaving or closing curses mode. This function restores</span> <kbd>tty</kbd> <span>modes, moves the cursor to the lower left-hand corner of the screen, and resets the Terminal into the best non-visual mode. Calling</span> <kbd>revive()</kbd> <span>or</span> <kbd>doupdate()</kbd> <span>after a short escape, makes&#160;the program go to visual mode. The</span> <kbd>isendwin()</kbd> <span>routine returns</span> <kbd>TRUE</kbd> <span>if</span> <kbd>endwin()</kbd> <span>has been called with no subsequent calls to</span> <kbd>wrefresh()</kbd><span>.</span></li>
</ul>
<p>To run this program in Ubuntu, ncurses should be installed on the system, otherwise during compilation, we will get an error stating&#160;<kbd>ncurses.h:no such file or directory</kbd>&#160;and compilation will terminate. Use the following command to install ncurses:</p>
<pre><strong>sudo apt-get install libncurses5-dev libncursesw5-dev</strong></pre>
<p>The preceding command installs the latest version of the ncurses library onto the system. Once installation is done, open Visual Studio Code, go to <span class="packt_screen">File</span>, and<span class="packt_screen">&#160;</span>click on <span class="packt_screen">New File</span>—it opens up a new untitled page. Write code as in the earlier example and save it at your desired location. Rename the file and give it an extension of&#160;<kbd>.c</kbd> or whatever suits your requirements. In this example, we created a file called&#160;<kbd>IntoToNcurses.c</kbd>. Run the following command to execute this program.</p>
<p>To compile a program, we use the following command syntax:</p>
<pre><strong>gcc  &lt;Program_name_with_Extension&gt; -o &lt;Out_FileName&gt; -lncurses</strong></pre>
<p>Here is an example:</p>
<pre><strong>gcc IntroToNcurses.c -o ExampleOfNcurses -lncurses<br/></strong></pre>
<p>The output for the preceding command can be seen in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b037ef46-6dba-4c53-bd93-403e5e7f6ec8.png"/></div>
<p>In the preceding example, we are passing our C program with the extension <kbd>.c</kbd>. After the&#160;<kbd>-o</kbd> command, we pass the output, or rather the compiled filename. Here, we can give it any name we want, as we did with&#160;<kbd>ExampleOfNcurses</kbd> in this example. To include the ncurses library, we have to link it during compilation using <kbd>-lncurses,</kbd> otherwise the compilation will fail with the error&#160;<kbd>undefined reference to functions</kbd>, as those functions are ncurses functions.</p>
<p>Once compilation is successful, it creates an output file, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="275" width="477" src="assets/257ab9c4-5ba4-4ebc-bb17-0e90e7e41d14.png"/></div>
<p>We can run our program after the compilation is successful and the output file is created in the same folder. On the Terminal,&#160;pass the output filename as&#160;<kbd><span>./hello</span></kbd> to execute the program, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e2b053c-8ba4-45c0-8dd6-54a28ec32d60.png"/></div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interop with existing native and Mono libraries</h1>
                </header>
            
            <article>
                
<p>Code reusability is one of the key principles in programming. For example, in an application we may use a certain functionality multiple times, so we keep it in a useful place and refer it from that place, whenever we need it in our application. Now, suppose our application implemented some common functionality which we can use in other applications, in this case, instead of writing the same logic again, we can create a library. It is easily distributable and reusable.</p>
<p>Asp.NET Core supports cross-platform programming, so any Linux user who has built many reusable libraries, API-like console support, and filesystem access, and wants to use them while writing code in ASP.NET Core, can access them. In this section, we will see how to access these native libraries (<kbd>.dll</kbd>) and Mono libraries (<kbd>.so</kbd>) in the program.</p>
<p><span><strong>Common Language Infrastructure</strong> (</span><strong>CLI</strong>) helps to interoperate with existing code. We need to handle three basic problems to get things to work. First, where and how to specify the library, second, determining which function we want to invoke, and third, passing parameters. <strong>Common Language Runtime</strong> (<strong>CLR</strong>)&#160;provides Platform Invocation services—we call it P/Invoke. It enables managed code to call C, C++ functions in native libraries (DLLs). Let's discuss what Platform Invoke is and how to use it.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Platform Invoke (P/Invoke)&#160;</h1>
                </header>
            
            <article>
                
<p>P/Invoke allows us to access structures and functions of unmanaged libraries from our managed code ASP.NET Core 2.0. To use P/Invoke API, we use the <kbd>System.Runtime.InteropServices</kbd> namespace. This namespace allows us to access attributes the way we want, to use them with native components. The&#160;<kbd>DllImport</kbd> attribute is used for the declaration.</p>
<div class="packt_infobox">If you want to dig more into the details, online resources are available at:&#160;<a href="http://www.pinvoke.net/">http://www.pinvoke.net</a><span>&#160;. It has all the functions which are widely used.</span>
<div>For example: <kbd>AllowSetForegroundWindow (user32)</kbd>—this enables the mentioned process to set the foreground window by utilizing the&#160;<kbd>SetForegroundWindow</kbd> method; the only condition is that the calling process should be able to set the foreground window. In C# code, we will write it as:&#160;</div>
<div>
<div><kbd><span>[DllImport("user32.dll")]</span></kbd><br/>
<kbd><span>static extern bool AllowSetForegroundWindow(int dwProcessId);<br/></span></kbd></div>
</div>
</div>
<p><span>The following diagram demonstrates where Interop stands between native and managed code:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="92" width="430" src="assets/f12b02b9-a90e-4bb3-b0ec-de0e6266c45e.png"/></div>
<p>For example, if we want to use the <kbd><span>AnyPopup()</span></kbd>&#160;method of <kbd>user32.dll</kbd>, we use it as follows:</p>
<pre><span>using System.Runtime.InteropServices;</span><br/>public class Demo<br/>{<br/>    // Import user32.dll (contains the method we need) and define<br/>    // the method corresponding to the native method<br/>    [DllImport("user32.dll")]<br/>    <span>static extern bool AnyPopup();</span><br/><br/>    public static void Main(string[] args)<br/>    {<br/>        // Invoke the method as a regular managed method.<br/>        AnyPopup();<br/>    }<br/>}</pre>
<p class="mce-root"><span>In this program, we used the&#160;<kbd>DllImport</kbd> attribute which calls the&#160;<strong>dynamic-link library</strong>&#160;(<strong>DLL</strong>), and we can use all these methods inside this DLL which is decorated with the&#160;<kbd>_declspec(dllexport)</kbd>&#160;keyword or <kbd>extern "c"</kbd>. We will discuss more about the import and export of methods from the library in the following section.</span></p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DLLImport attribute</h1>
                </header>
            
            <article>
                
<p>The attribute,&#160;<kbd>[DllImport()]</kbd>, falls under the&#160;<kbd>DllImportAttribute</kbd> class. It provides the information required to call a function exported from an unmanaged DLL. The minimum prerequisite is that we should pass the name of the DLL which contains the entry point. We can apply this attribute straightforwardly to C# and C++ function definitions. Let's check what the&#160;<kbd>DllImport</kbd> attribute has inside it. In the code window, click on <kbd>DllImport</kbd> and press the&#160;<em>F12</em> key (referred to as the go-to definition). This key is bound to the de-compile command in Visual Studio and will de-compile the selected type, if it can. Upon de-compilation, Visual Studio will display the de-compiled code in a new window. In the de-compiled code of <kbd>DllImport</kbd>, we can see each and every parameter. The code is very well commented and self-explanatory, as can be seen here:</p>
<pre>namespace System.Runtime.InteropServices<br/>{<br/>    //<br/>    // Summary:<br/>    // Indicates that the attributed method is exposed by an unmanaged <br/>       dynamic-link<br/>    // library (DLL) as a static entry point.<br/>    [AttributeUsage(AttributeTargets.Method, Inherited = false)]<br/>    public sealed class DllImportAttribute : Attribute<br/>    {<br/>        //<br/>        // Summary:<br/>        // Enables or disables best-fit mapping behavior when <br/>           converting Unicode characters<br/>        // to ANSI characters.<br/>        public bool BestFitMapping;<br/>        //<br/>        // Summary:<br/>        // Indicates the calling convention of an entry point.<br/>        public CallingConvention CallingConvention;<br/>        //<br/>        // Summary:<br/>        // Indicates how to marshal string parameters to the method and <br/>           controls name mangling.<br/>        public CharSet CharSet;<br/>        //<br/>        // Summary:<br/>        // Indicates the name or ordinal of the DLL entry point to be <br/>           called.<br/>        public string EntryPoint;<br/>        //<br/>        // Summary:<br/>        // Controls whether the <br/>           System.Runtime.InteropServices.DllImportAttribute.CharSet<br/>        // field causes the common language runtime to search an <br/>           unmanaged DLL for entry-point<br/>        // names other than the one specified.<br/>        public bool ExactSpelling;<br/>        //<br/>        // Summary:<br/>        // Indicates whether unmanaged methods that have HRESULT or <br/>           retval return values<br/>        // are directly translated or whether HRESULT or retval return <br/>           values are automatically<br/>        // converted to exceptions.<br/>        public bool PreserveSig;<br/>        //<br/>        // Summary:<br/>        // Indicates whether the callee calls the SetLastError Win32 <br/>           API function before<br/>        // returning from the attributed method.<br/>        public bool SetLastError;<br/>        //<br/>        // Summary:<br/>        // Enables or disables the throwing of an exception on an <br/>           unmappable Unicode character<br/>        // that is converted to an ANSI "?" character.<br/>        public bool ThrowOnUnmappableChar;<br/><br/>        //<br/>        // Summary:<br/>        // Initializes a new instance of the  <br/>           System.Runtime.InteropServices.DllImportAttribute<br/>        // class with the name of the DLL containing the method to <br/>           import.<br/>        //<br/>        // Parameters:<br/>        // dllName:<br/>        // The name of the DLL that contains the unmanaged method. This <br/>           can include an assembly<br/>        // display name, if the DLL is included in an assembly.<br/>        public DllImportAttribute(string dllName);<br/><br/>        //<br/>        // Summary:<br/>        // Gets the name of the DLL file that contains the entry point.<br/>        //<br/>        // Returns:<br/>        // The name of the DLL file that contains the entry point.<br/>        public string Value { get; }<br/>    }<br/>}</pre>
<p>We can characterize the following attributes with the DLL name:</p>
<ul>
<li><kbd>ThrowOnUnmappableChar</kbd>:&#160;<span>This field is</span><span>&#160;</span><kbd>False</kbd><span>&#160;</span><span>by default, which means the&#160;<kbd>ThrowOnUnmappableChar</kbd>&#160;field is disabled.</span>&#160;<span>Best-fit mapping empowers the Interop marshaler to give a nearby coordinating character when no correct match exists, every</span>&#160;time the Interop marshaler changes over an unmappable character.&#160;For example, the marshaler changes over the Unicode character into<span>&#160;</span><kbd>c</kbd><span>&#160;</span>for unmanaged techniques that acknowledge ANSI characters. A few characters do not have a best-fit portrayal; these are called unmappable characters. These unmappable characters are typically changed over to the default<span>&#160;</span><kbd>?</kbd><span>&#160;</span>ANSI character.</li>
<li><kbd>SetLastError</kbd>: By default,&#160;<kbd><span>SetLastError</span></kbd>&#160;is set to false, but in Visual Basic it is set to true by default.<span>&#160;</span><kbd>GetLastError</kbd><span>&#160;is called by&#160;runtime marshaler&#160;</span>and it caches the return value so it is not overwritten by other API calls. You can recover the error code by calling<span>&#160;</span><kbd>GetLastWin32Error</kbd>.</li>
<li><kbd>ExactSpelling</kbd>:&#160;The<span>&#160;</span><kbd>ExactSpelling</kbd><span>&#160;</span>field, as the name suggests, impacts the behavior of the<span>&#160;</span><kbd>CharSet</kbd><span>&#160;</span>field to figure out the exact entry point name to invoke. If the<span>&#160;</span><kbd>ExactSpelling</kbd><span>&#160;</span>field is set to<span>&#160;</span><kbd>False</kbd>, Platform Invoke looks for the unmangled alias first;&#160;<span>if the unmangled alias is not found,</span> then it will look for the mangled name.</li>
<li><kbd>BestFitMapping</kbd>:&#160;By default, the&#160;<kbd>BestFitMapping</kbd> field is true. On the off chance that this field is true, it overrides any level settings for&#160;<kbd>System.Runtime.InteropServices.BestFitMappingAttribute</kbd>. Best-fit mapping empowers the Interop marshaler to give a nearby matching character when no correct match exists. For instance, the marshaler changes over the Unicode copyright character to <kbd>c</kbd> for unmanaged functions that acknowledge ANSI characters. A few characters do not have a best-fit representation, and these characters are called unmappable. Unmappable characters are generally changed over to the default <kbd>?</kbd> ANSI character.</li>
<li><kbd>CallingConvention</kbd>:&#160;<span>Specifies the calling convention required to call methods implemented in unmanaged code. It is defined as an enumeration.</span>&#160;<span>The values of this enumeration are used to specify the calling conventions. This determines how a function is called, for example, the argument passing order behaviour&#160;is set to right to left, or stack maintenance responsibility such as the Calling function pops the arguments from the stack, and so on.&#160;</span>There are fundamentally five calling convention fields: <kbd>Cdecl</kbd>,&#160;<kbd>StdCall</kbd>,<span>&#160;</span><kbd>FastCall</kbd><span>,</span> <kbd>ThisCall</kbd>, and <kbd>Winapi</kbd>. The default is <kbd>StdCall</kbd> for unmanaged functions with P/Invoke. More about this can be read at:&#160;<a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx</a>.</li>
<li><kbd>StdCall</kbd>:&#160;The callee cleans the stack. To call unmanaged functions with&#160;<span>Platform Invoke, t</span>his is the default convention.&#160;</li>
<li><kbd>Cdecl</kbd>:&#160;This empowers calling functions with variable <kbd>args</kbd>, which means it is good to use for functions that use a variable number of parameters, for example, on the Windows platform, the <kbd>System.Runtime.InteropServices.CallingConvention.Cdecl</kbd> convention will act as: Argument-passing order | r<span>ight to left</span></li>
<li><kbd>Winapi</kbd>:&#160;This part isn't really a calling convention, rather it utilizes the default platform calling convention. For instance, in Windows, the default is<span>&#160;</span><kbd>StdCall</kbd>,<span>&#160;</span>and on Windows CE .NET, it is<span>&#160;</span><kbd>Cdecl</kbd>.</li>
<li><kbd>ThisCall</kbd>:<strong>&#160;</strong>The primary parameter is the pointer and is put away in register ECX. Other parameters are pushed on the stack. This calling convention is utilized to call functions on classes exported from an unmanaged DLL.</li>
<li><kbd>CharSet</kbd>:&#160;It determines the marshaling conduct of string parameters and is useful for indicating which entry point name to invoke (the correct name given or a name finishing with <kbd>net</kbd> or <kbd>As</kbd>). The default list part for C# is <kbd>CharSet.Ansi</kbd> and the default count part for C++ is <kbd>CharSet</kbd>.</li>
<li><kbd>Entrypoint</kbd>:&#160;You can determine the entry point name by providing a string showing the name of the DLL containing the entry point, or you can recognize the entry point by its ordinal. Ordinals are prefixed with the <kbd>#</kbd> sign. We can utilize the <kbd>DllImportAttribute.EntryPoint</kbd> field to indicate a DLL function by name or ordinal. On the off chance that the name of the function in your function definition is the same as the entry point in the DLL, you don't need to expressly recognize the function with the <kbd>EntryPoint</kbd> field. Utilize syntax to demonstrate a name or ordinal:</li>
</ul>
<pre style="padding-left: 60px">[DllImport("dllname", EntryPoint="MethodName")]<br/><span>[DllImport("dllname", EntryPoint="#XYZ")]</span></pre>
<p style="padding-left: 60px">Notice that you should prefix an ordinal with the pound sign (<kbd>#</kbd><span>).</span> To know the entry point of DLL, we can use <kbd>DUMPBIN.exe</kbd> <span>also. Just open the Developer Command Prompt and go to the DLL location and type the command,</span> <kbd>DUMPBIN /EXPORTS ExampleDLL.dll</kbd>. Running this command returns information about the entry point and functions of DLL, shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad8257f3-195f-4b89-9120-cab4079bb6c6.png"/></div>
<p style="padding-left: 60px">It gives all the information about DLL such as:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>It has one ordinal base</li>
<li>It has three functions</li>
<li>The names of functions and their ordinal value</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">There are many commands which we can use to get information about DLL. To find out all the commands, enter the following command, <kbd>Dumpbin.exe</kbd>. It gives us a list of commands that we can use.</p>
<div class="packt_infobox">Certain Unicode characters are changed over to risky characters, for example, the oblique punctuation line <kbd>\</kbd> character, which can unintentionally change a way. By setting the <kbd>ThrowOnUnmappableChar</kbd> field to genuine, you can flag the nearness of an unmappable character to the guest by tossing a special case.<br/>
<br/>
You can't change the default values given by the <kbd>BestFitMapping</kbd> and <kbd>ThrowOnUnmappableChar</kbd> fields when passing a managed array whose components are ANSI characters or LPSTRs to an unmanaged safe exhibit. Best-fit mapping is constantly empowered and no special case is tossed. Know that this blend can trade-off your security information.</div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interop with existing native libraries with example</h1>
                </header>
            
            <article>
                
<p>Let's create DLL and create a header file (<kbd>.h</kbd>) inside it using C++, and we will see how we can consume it in our .NET Core application. In the following example, we created a DLL project for example, calling it&#160;<kbd>ExampleDLL</kbd>. Create a source <kbd>.cpp</kbd> file and a header file. Open the header file and write the following code, which returns the sum of two values. To consume public data and functions in class, we have to add the keyword <kbd>_declspec(dllexport)</kbd> before the public member which we want to consume from outside. While creating a DLL, we usually add the header file which contains the function or class prototype and we can export this using the&#160;<kbd>__declspec(dllexport)</kbd>&#160;keyword, while doing a declaration in the header file.</p>
<p>The named header file is&#160;<kbd>Calculate</kbd>, and the method name is <kbd>Sum</kbd> which takes two variables, integer&#160;<kbd>a</kbd> and integer <kbd>b</kbd>. Build this solution and open the project location. We can find DLL inside the debug folder:</p>
<pre>#ifndef Calculate<br/>#define Calculate<br/><br/>extern "C"<br/>{<br/>  __declspec(dllexport)int Sum(int a, int b)<br/>  {<br/>    return a + b;<br/>  }<br/>}<br/><br/>#endif</pre>
<p>Add the preceding code in the&#160;<kbd>Calculate.h</kbd> file, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="323" width="529" src="assets/7dce40fb-ed0c-4507-9eab-4db64ceb5352.jpg"/></div>
<p>This DLL is created inside the debug folder of the&#160;<kbd>ExampleDLL</kbd> project:</p>
<div class="CDPAlignCenter CDPAlign"><img height="166" width="380" src="assets/389d5c6e-5080-4021-9a4e-cc334ac57841.jpg"/></div>
<p>Now we have our C++ DLL ready to be consumed from C# code. For example, I am creating a C# console application and we just need three lines of code to consume C++ DLL:</p>
<ol>
<li>Add namespace using <kbd>System.Runtime.InteropServices;</kbd></li>
<li>Add attribute using&#160;<kbd>[DllImport(@"&lt;DLL Location&gt;")]</kbd></li>
<li>Add <kbd>static extern</kbd> functions with a compatible signature in your C# code,&#160;<kbd>public static extern int Sum(int a, int b);</kbd>&#160;&#160;&#160;&#160;&#160;&#160;</li>
</ol>
<p>The C# script for the same is as follows:</p>
<pre>using System.Runtime.InteropServices;<br/><br/>class Program<br/><br/>    {<br/>        //Insert file path of dll you want to import<br/>        [DllImport(@"C:\Users\neshriv\Documents\Visual Studio <br/>        2017\Projects\ExampleDLL\Debug\ExampleDLL.dll")]<br/>        public static extern int Sum(int a, int b);<br/>        static void Main(string[] args)<br/>        {<br/><br/>            int sumValue = Sum(3, 4);<br/><br/>            Console.WriteLine("Sum of 3 and 4 is {0}",sumValue);<br/><br/>            Console.ReadKey();<br/><br/>        }<br/><br/>    }</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="64" width="489" src="assets/916def90-ccea-4a10-a8f0-c75c82d9b46f.jpg"/></div>
<p>In the preceding section, we saw how to consume native libraries in a DLL. In this section, let's take the example of a Mono library. We will create a <kbd>.so</kbd> file in Ubuntu and will consume it from .NET Core. We will see the backward compatibility of .NET Core.</p>
<p>Mono is an open source development platform in light of the .NET Framework; it enables engineers to fabricate cross-platform applications with enhanced designer efficiency. Mono's .NET execution depends on the <strong>Ecma</strong> (<strong>Ecma International—European association for standardizing information and communication systems</strong>) norms for&#160;C#&#160;and the&#160;Common Language Infrastructure. Mono incorporates both engineer devices and the foundation expected to run .NET customer and server applications. Mono works cross platform, and runs on&#160;Linux,&#160;Microsoft Windows, and many others. All Mono dialects take advantage from many highlights of the runtime, similar to programmed memory administration, reflection, generics, and threading. Its highlights enable us to focus on composing your application, as opposed to composing framework foundation code.&#160;</p>
<p>In this example, we are creating a simple library which displays an integer value.</p>
<p>The code is as follows:</p>
<pre># include&lt;stdio.h&gt;<br/><br/>int hello()<br/>{<br/>  return 15;<br/>}</pre>
<p>Run the following command in the Terminal to create the&#160;<kbd>.so</kbd> file:</p>
<pre><strong>gcc -shared -o libHelloSO.so -fPIC HelloSOLib.c</strong></pre>
<p>In the preceding command,&#160;<kbd>-shared -o</kbd> creates an (<kbd>.o</kbd>) object file and from the object file creates a <kbd>.so</kbd> file. <kbd>-fPIC</kbd> is used to declare a flag for the position independent code.<kbd>-fPIC</kbd> generates position-independent code which can be loaded from any memory location at runtime, so we can access static or global variables and methods at runtime.</p>
<p>The preceding command can be seen in the following screenshot:<span>&#160;</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="310" width="560" src="assets/21d4bd6a-44e1-4271-9abe-e8fa39fb7967.png"/></div>
<p>Now we will see how to consume this <kbd>.so</kbd> file in C# code. We created a C# file and added the namespace,&#160;<kbd>system.Runtime.InteropServices</kbd>, and gave the path of the&#160;<kbd>.so</kbd> file inside the&#160;<kbd>DLLImport</kbd> attribute.</p>
<p>The code is as follows:</p>
<pre>Using System;<br/>Using System.Runtime.InteropServices;<br/><br/>Namespace Hello<br/>{<br/>  Class Program<br/>  {<br/>    [DllImport("/home/neha/Documents/InteroWithMonoLib/libHelloSO.so")]<br/>    Private static extern int hello()<br/>    Static void Main(string[] args)<br/>    {<br/>      int a = hello();<br/>      Console.WriteLine(a);<br/>    }<br/>  }<br/>}</pre>
<p>Now, when we are done with the code and <kbd>DLLImport</kbd>, let's discuss Mono, which we will use to create our executable and run this application. Mono is an open source tool which is created by the Microsoft subsidiary, Xamarin. It is a tool which makes the Linux developer's life easy if they want to run Microsoft .NET applications on Linux or on any other cross platform. The latest version at the time of writing this book is Mono 5.4.0, which was released in October 2017. This version supports the Core API of .NET Framework and also C# 7.0. Mono provides several command line utilities, a few of the main useful commands are:</p>
<ul>
<li><strong>Mono</strong>:&#160;It is a <span><strong>just-in-time</strong> (</span><strong>JIT</strong>) compiler and it supports both 32-bit and 64-bit types of systems. It also supports multiple platforms such as Microsoft Windows, Sun Solaris, Android, Apple iOS, macOS, Linux, Sony PlayStation, and so on. Mono runtime offers Code Execution, Garbage Collection, Code Generation, Exception Handling, OS interface, Thread management, Console access, and Security System, Program isolation using AppDomain. It allows a project to be extended in C# by reusing all existing C, C++ code libraries. As we said earlier, it is a JIT compiler. Since we have <kbd>ngen.exe</kbd> in Microsoft.NET to generate a pre-compiled code, which reduces the start up time, we use the following command with Mono to compile assemblies:</li>
</ul>
<pre style="padding-left: 90px"><strong>mono -O=all --aot &lt;exe name&gt;</strong></pre>
<p style="padding-left: 60px">In the preceding command,&#160;<kbd>-O=all</kbd>&#160;instructs to enable all optimizations, then the Mono command tells Mono to compile the code to native code,&#160;<kbd>--aot</kbd> for a precompiled image&#160;</p>
<ul>
<li><strong>MCS:</strong>&#160;It's a C# compiler. Though many versions of compiler are available which are specific to the version, for example, <kbd>gmcs</kbd> compiler targets 2.0 mscorelib, <kbd>smcs</kbd> targets 2.1 mscorelib and moonlight applications (Silverlight implementation for mainly Linux), while <kbd>dmcs</kbd> targets 4.0 mscorlib. Now, the new compiler version MCS is present which takes the latest version by default. We can also specify which version we want to use. MCS runs with Mono runtime on a Linux machine, and with both .NET and Mono runtime on a Windows machine.</li>
<li><strong><span>Global Assembly Cache tool (</span>Gacutil)</strong>:<strong>&#160;</strong>This tool is used for maintaining versions of assemblies in a system's global assembly cache.&#160;</li>
<li><strong>XSP</strong>:<strong>&#160;</strong>The&#160;web service and web application server of Mono.</li>
<li><strong>mono-config</strong>: The format configuration of Mono runtime.</li>
</ul>
<p>Install Mono using the following command.&#160;<span>When we use <kbd>mcs</kbd>, it</span>&#160;will install the latest version:</p>
<pre><strong>sudo apt install mono-mcs</strong></pre>
<p>Compile this C# program in Visual Studio Code using the following command; it creates an&#160;<kbd>.exe</kbd> file at the same location from where we opened the Terminal:</p>
<pre><strong>mcs -out:helloNative.exe InteropWithNativeSO.cs</strong></pre>
<p>Now, it's time to run and check if it is displaying the value <kbd>15</kbd>, which we have passed in our <kbd>.so</kbd> file, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="354" width="550" src="assets/8483ac96-68eb-4044-bbf8-f0dbb761914d.png"/></div>
<p>To run <kbd>helloNative.exe</kbd>, use the following command:</p>
<pre><strong>mono helloNative.exe</strong></pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">When not to use P/Invoke</h1>
                </header>
            
            <article>
                
<p>Utilizing P/Invoke isn't fitting for all C-style methods in DLLs. Let's take an example where we create a string in a C++ program and display it in a C# application:</p>
<pre>#include "stdafx.h"<br/><br/>const char * HelloMsg()<br/>{<br/>  char * msg = "Hello .NET Core.";<br/>  return msg;<br/>}<br/>int main()<br/>{<br/>  printf(HelloMsg());<br/>}</pre>
<p>Now, using P/Invoke, pass the library in the&#160;<kbd>DllImport</kbd> attribute:</p>
<pre>[DllImport("HelloMsgLib.so")]<br/>public static extern char *  HelloMsg();</pre>
<p>The trouble here is that we can't erase the memory for the unmanaged string returned by <kbd>msg</kbd>. Different methods called through P/Invoke restore a pointer and do not need to be deallocated by the client. For this situation, utilizing the marsheling is a more suitable approach.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a sample native library (C++)</h1>
                </header>
            
            <article>
                
<p>In the previous section, we learned about cross-platform implementation, and how to Interop with existing native and Mono libraries. To demonstrate interoperability, we created small sample applications. Let's start with building our first native library in C++. Follow these steps:</p>
<ol>
<li>Open Visual Studio and select <span class="packt_screen">Windows Desktop</span> under <span class="packt_screen">Visual C++</span> and select the project type <span class="packt_screen">Dynamic-Link Library (DLL)</span>. In this example, we name the project <kbd>ExampleDLL</kbd> and provide the location where we want to create the project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7233f757-5e61-4390-93cf-684fba40b11f.png"/></div>
<ol start="2">
<li>Right-click on the header files folder and create a new header file. In this example, we named it <kbd>Calculate.h</kbd>. The&#160;<kbd>Calculate</kbd> header file contains mathematical operations such as the summation of two integer numbers, multiplication, and division:</li>
</ol>
<pre style="padding-left: 60px">#ifndef Calculate<br/>#define Calculate<br/> <br/>extern "C"<br/>{<br/>  __declspec(dllexport)int Sum(int a, int b)<br/>  {<br/>    return a + b;<br/>  }<br/>  __declspec(dllexport) int Multiply(int number1, int number2)<br/>  {<br/>    int result = number1 * number2;<br/>    return result;<br/>  }<br/>  __declspec(dllexport) double divide(int number1, int number2)<br/>  {<br/>    double result = 0.0;<br/>    if (number2 != 0)<br/>    result = number1 / number2;<br/>    return result;<br/>  }<br/>}<br/>#endif</pre>
<p style="padding-left: 60px">In the preceding example, we defined a header called&#160;<kbd>Calculate</kbd>.</p>
<ol start="3">
<li><kbd>extern "C"</kbd> is used to instruct that the compiler will use the C function naming convention, not C++. Most code uses this directive because C function names are clearer to understand than C++. <kbd>__declspec(dllexport)</kbd> is utilized for export. In Microsoft's new versions of compiler, we can export data, functions, classes, or class member functions from a DLL utilizing this keyword, <kbd>__declspec(dllexport),</kbd> the export directive to the object file, so we don't have to utilize a <kbd>.def</kbd> record. This accommodation is most obvious when endeavoring to export decorated C++ function names. Since there is no standard specification for name decoration, the name of an exported function may change between compiler versions. To export functions, the <kbd>__declspec(dllexport)</kbd> keyword must appear to the left side of the calling-convention keyword, if a keyword is indicated, for instance: <kbd><kbd>__declspec(dllexport)int Sum(int a, int b).</kbd></kbd></li>
</ol>
<p style="padding-left: 60px">To export all public data members and functions in a class, the keyword must appear to the left side of the class name, as shown here:<br/>
<kbd>Class __declspec(dllexport)int Calculations : public CPPObj { Class definition};</kbd>.<br/>
When building your DLL, we normally make a header file that contains the function models, as well as classes we are trading, and include <kbd>__declspec(dllexport)</kbd> to the announcements in the header file. To make our code more intelligible, we can define a macro for&#160;<kbd>__declspec(dllexport)</kbd><span>&#160;and use the macro with each symbol we are sending out:<br/></span><kbd># define DLLExplort __declspec(dllexport)</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f169b8a-4b47-4e95-a204-d5c040fea205.png"/></div>
<ol start="4">
<li>In the preceding example, we created a sample native library, and now we will see how we can access it. In the preceding code, we used <kbd>__declspec(dllexport)</kbd>; to acccess this DLL, we will use <kbd>DllImport</kbd>. Click on <span class="packt_screen">A</span><span class="packt_screen">dd | New Project</span>; under C#, select <span class="packt_screen">.NET Core Console Application</span>. In this example, we called it <kbd>InteropWithCS</kbd>. Open the solution and add the following code:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using System.Runtime.InteropServices;<br/>namespace InteropWithCS<br/>{<br/>    class Program<br/>    {<br/>        [DllImport(@"C:\Users\neshriv\Documents\Visual Studio <br/>        2017\Projects\ExampleDLL\Debug\ExampleDLL.dll")]<br/><br/>        static extern int Multiply(int number1, int number2);<br/><br/>        [DllImport(@"C:\Users\neshriv\Documents\Visual Studio <br/>        2017\Projects\ExampleDLL\Debug\ExampleDLL.dll")]<br/><br/>        static extern double divide(int number1, int number2);<br/><br/>        [DllImport(@"C:\Users\neshriv\Documents\Visual Studio <br/>        2017\Projects\ExampleDLL\Debug\ExampleDLL.dll")]<br/><br/>        static extern int Sum(int a, int b);<br/>        static void Main(string[] args)<br/>        {<br/><br/>            Console.WriteLine("Enter number1");<br/>            int number1 = Convert.ToInt32(Console.ReadLine());<br/>            Console.WriteLine("Enter number2");<br/>            int number2 = Convert.ToInt32(Console.ReadLine());<br/>            Console.WriteLine("Select Operation : 1 for Sum , 2 for <br/>            multiply, 3 for divide");<br/>            int option = Convert.ToInt32(Console.ReadLine());<br/>            int result ;<br/>            switch (option)<br/>            {<br/>                case 1:<br/>                    result = Sum(number1, number2);<br/>                    Console.WriteLine("You have selected Sum <br/>                    operation! <br/>                    Sum is : " + result);<br/>                    Console.ReadLine();<br/>                    break;<br/>                case 2:<br/>                    result = Multiply(number1, number2);<br/>                    Console.WriteLine("You have selected Sum <br/>                    operation! <br/>                    multiplication is : " + result);<br/>                    Console.ReadLine();<br/>                    break;<br/>                case 3:<br/>                    double result1 = divide(number1, number2);<br/>                    Console.WriteLine("You have selected Sum <br/>                    operation! <br/>                    division is : " + result1);<br/>                    Console.ReadLine();<br/>                    break;<br/>            }<br/><br/>        }<br/><br/>    }<br/><br/>}</pre>
<ol start="5">
<li>In this example, we are using <kbd>ExampleDLL</kbd> and doing our calculations, taking input for <kbd>number1</kbd> and <kbd>number2</kbd> values. The user can select an operation—sum, multiply, or divide by pressing the corresponding number. On option number input, we check the user option, use switch case, and display the result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="214" width="600" src="assets/06576ed6-91ce-4006-9ac1-05013bf779ae.png"/></div>
<p>This simple application gives us an understanding of how to create our own native library in C or C++, and how to set functions which can be exported and accessed from other languages, such as C#. The intention of making it simple and using small functions, such as sum, and multiplication, for example, is to make you aware of the functionality, so that the user won't get distracted with the heavy logic of functions.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A sample application to implement new library and ncurses</h1>
                </header>
            
            <article>
                
<p>Now that we know the fundamentals, let's start building a sample application which implements ncurses. We will create a C# application which imports a C library or we can say <kbd>.so</kbd> file. This library has implemented ncurses functions. P/Invoke allows us to use those ncurses functions in our C# application.</p>
<p>First, we will create a C program which implements ncurses functions using an ncurses header. Let's create an application which takes an input character; this character will be printed in a window, based on the number of rows and columns the user enters from the application where we will import this library. The function <kbd>drawCharOnWindow()</kbd> prints the character, based on the number of rows and columns present in the window; it takes character, row, and column as&#160;<span>input</span> parameters. We get the size of the window using the ncurses function,&#160;<kbd>getmaxyx(),</kbd> and if the user enters <kbd>q</kbd>, it quits the printing of the character. Open Visual Studio Code and write the following code:</p>
<pre># include &lt;stdio.h&gt;<br/># include &lt;ncurses.h&gt;<br/><br/>int row, column, // current row and column (Top left is (0,0))<br/>numberOfRows, // number of rows in current window<br/>numberOfColumns; // number of columns in current window<br/><br/>void drawCharOnWindow(char drawChar, int row, int column)<br/><br/>{<br/>  move(row, column); // ncurses call to move cursor to given row, given <br/>  column<br/><br/>  delch(); //ncurses calls to replace character <br/>  insch(drawChar); //under cursor by drawChar<br/><br/>  refresh(); // ncurses call to update screen<br/>  row++; // go to next row<br/>  // check for need to shift right or wrap around<br/>  if (row == numberOfRows)<br/>  {<br/>    row = 0;<br/>    column++;<br/>    if (column == numberOfColumns) column = 0;<br/>  }<br/>}<br/>void hello(int i, int j, char c)<br/>{<br/>  initscr(); // ncurses call to initialize window<br/>  refresh(); // curses call to implement all changes since last refresh<br/>  while (1)<br/>  {<br/>    if (c == 'q') break; // quit?<br/>    {<br/>      drawCharOnWindow(c, i, j);<br/>    }<br/>  }<br/>}</pre>
<p>Create a library using the following command. It will create a <kbd>.so</kbd> file at the location from where the Terminal is open, and we run this command:</p>
<pre><strong>gcc -shared -o libHelloSO.so -fPIC HelloSOLib.c -lncurses</strong></pre>
<p>Now, we will use this library from the C# program using Mono. The following example application takes input from the user for the character we will print and its location, row, and column value. To use the library which implemented ncurses and to use it in C# , we need to use the namespace,&#160;<kbd>System.Runtime.InteropServices</kbd> and import DLL, using the&#160;<kbd>DllImport</kbd> attribute:</p>
<pre>using System;<br/>using System.Runtime.InteropServices;<br/><br/>namespace Hello<br/>{<br/>    class Program<br/>    {<br/>        [DllImport("/home/neha/Documents/<br/>        InteropWithMonoLib/libHelloSO.so")]<br/>        private static extern void hello(int i, int j, int c);<br/><br/>        static void Main(string[] args)<br/>        {<br/>            Console.WriteLine("Enter Character you want to print:\n");<br/>            char c = Convert.ToChar(Console.ReadLine());<br/>            Console.WriteLine("Enter row numbers till where to want to <br/>            see pattern of character:\n");<br/>            int i = Convert.ToInt32(Console.ReadLine());<br/>            Console.WriteLine("Enter column numbers till where to want <br/>            to see pattern of character:\n");<br/>            int j = Convert.ToInt32(Console.ReadLine());<br/>            for (int a = 0; a &lt; i; a++)<br/>            {<br/>                for (int b = 0; b &lt; j; b++)<br/>                {<br/>                    hello(i, j, c);<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>To create the&#160;<kbd>.exe</kbd> file, use the following Mono command:</p>
<pre><strong>mcs -out:helloNative.exe InteropWithNativeSO.cs</strong></pre>
<p>To run the program in Mono, use the following command:</p>
<pre><strong>mono helloNative.exe</strong></pre>
<p>We learned how to create an executable using Mono and run it; now, we will see how to create a .NET Core 2.0 console application. Open Visual Studio Code and set the location on the Terminal where we want to create the application, and run the following command for the console application:</p>
<pre><strong>dotnet new console</strong></pre>
<p class="syntaxhighlighter nogutter bash">After the creation of the application, use the preceding code. Run this code using the following command:</p>
<pre class="syntaxhighlighter nogutter bash"><strong>dotnet run</strong></pre>
<p class="syntaxhighlighter nogutter bash">It will take the input parameter, the character to print, row, and column location, and it will print that character in the window at the specified location, as shown here:&#160;</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="279" width="514" src="assets/54a52beb-b049-4595-886e-52542d4f95fa.png"/></div>
<p>After passing this detail, it prints the character at the specified row and column on the screen, as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="266" width="497" src="assets/b7ef9286-dc44-4944-9dec-ddf1b0c9bb73.png"/></div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the ncurses library and how to use this library in C or C++ programs. Also, we learned about how to reuse libraries created in Ubuntu or on a Linux machine which implemented ncurses<span>&#160;in a .NET Core 2.0 application, using P/Invoke. We have seen how Mono works efficiently with a Linux machine and makes programming easy in .NET Core 2.0, using C# for Linux user. The next chapter will be very interesting, and it will be where we will build our first game, Tic-Tac-Toe, using .NET Core and we will learn about its compilation, building, and testing.&#160;</span></p>


            </article>

            
        </section>
    </div>
</body>
</html>