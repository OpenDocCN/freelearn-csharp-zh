<html><head></head><body>
<div><h1 class="chapterNumber">10</h1>
<h1 class="chapterTitle" id="_idParaDest-182">JavaScript Interop</h1>
<p class="normal">In this chapter, we will take a look at JavaScript. In specific scenarios, we still need to use JavaScript, or we will want to use an existing library that relies on JavaScript. Blazor uses JavaScript to update <a id="_idIndexMarker417"/>the <strong class="keyWord">Document Object Model</strong> (<strong class="keyWord">DOM</strong>), download files, and access local storage on the client.</p>
<p class="normal">So, there are, and always will be, cases when we need to communicate with JavaScript or have JavaScript communicate with us. Don’t worry, the Blazor community is an amazing one, so chances are someone has already built the interop we need.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Why do we need JavaScript?</li>
<li class="bulletList">.NET to JavaScript</li>
<li class="bulletList">JavaScript to .NET</li>
<li class="bulletList">Implementing an existing JavaScript library</li>
<li class="bulletList">JavaScript interop in WebAssembly</li>
</ul>
<h1 class="heading-1" id="_idParaDest-183">Technical requirements</h1>
<p class="normal">Ensure you have followed the previous chapters or use the <code class="inlineCode">Chapter09</code> folder as a starting point.</p>
<p class="normal">You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10</a>.</p>
<p class="normal">If you are jumping into this chapter using the code from GitHub, make sure you have added the <code class="inlineCode">Auth0</code> account information in the settings files. You can find the instructions in <em class="chapterRef">Chapter 8</em>, <em class="italic">Authentication and Authorization</em>.</p>
<h1 class="heading-1" id="_idParaDest-184">Why do we need JavaScript?</h1>
<p class="normal">Many say Blazor is the <a id="_idIndexMarker418"/>JavaScript killer, but the truth is that Blazor needs JavaScript to work. Some events only get triggered in JavaScript, and if we want to use those events, we need to make an interop.</p>
<p class="normal">I jokingly say that I have never written so much JavaScript as when I started developing with Blazor. it’s not that bad.</p>
<p class="normal">I have written a couple of libraries that require JavaScript to work. They are called <code class="inlineCode">Blazm.Components</code> and <code class="inlineCode">Blazm.Bluetooth</code>.</p>
<p class="normal">The first one is a grid component that uses JavaScript interop to trigger C# code (JavaScript to .NET) when the window is resized, to remove columns if they can’t fit inside the window.</p>
<p class="normal">When that is triggered, the C# code calls JavaScript to get the size of the columns based on the client width, which only the web browser knows, and based on that answer, it removes columns if needed.</p>
<p class="normal">The second one, <code class="inlineCode">Blazm.Bluetooth</code>, makes it possible to interact with Bluetooth devices using Web Bluetooth, which is a web standard accessible through JavaScript.</p>
<p class="normal">It uses two-way communication; Bluetooth events can trigger C# code, and C# code can iterate over devices and send data to them. They are both open source, so if you are interested in looking at a real-world project, you can check them out on my GitHub: <a href="https://github.com/EngstromJimmy">https://github.com/EngstromJimmy</a>.</p>
<p class="normal">As mentioned earlier, in most cases, I would argue that we won’t need to write JavaScript ourselves. The Blazor community is very big, so chances are that someone has already written what we need. But we don’t need to be afraid of using JavaScript either. Next, we will look at different ways to add JavaScript calls to our Blazor project.</p>
<h1 class="heading-1" id="_idParaDest-185">.NET to JavaScript</h1>
<p class="normal">Calling JavaScript from .NET is pretty simple. There are<a id="_idIndexMarker419"/> two ways of doing this:</p>
<ul>
<li class="bulletList">Global JavaScript</li>
<li class="bulletList">JavaScript isolation</li>
</ul>
<p class="normal">We will go through both ways to see what the difference is.</p>
<h2 class="heading-2" id="_idParaDest-186">Global JavaScript (the old way)</h2>
<p class="normal">To access the JavaScript <a id="_idIndexMarker420"/>method, we need to make it accessible. One way is to <a id="_idIndexMarker421"/>define it globally through the JavaScript window object. This is a bad practice since it is accessible by all scripts and could replace the functionality in other scripts (if we accidentally use the same names).</p>
<p class="normal">What we can do, for example, is use scopes, create an object in global space, and put our variables and methods on that object so that we lower the risk a bit, at least.</p>
<p class="normal">Using a scope could look something like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;script&gt;
window.myscope = {};
window.myscope.methodName = () =&gt; { alert("this has been called"); }
&lt;/script&gt;
</code></pre>
<p class="normal">We create an object with the name <code class="inlineCode">myscope</code>. Then, we declare a method on that object called <code class="inlineCode">methodName</code>. In this example, there is no code in the method; this only demonstrates how it could be done.</p>
<p class="normal">Then, to call the method from C#, we would call it using <code class="inlineCode">JSRuntime</code> like this:</p>
<pre class="programlisting code"><code class="hljs-code">@using Microsoft.JSInterop
@inject IJSRuntime jsRuntime
await jsRuntime.InvokeVoidAsync("myscope.methodName");
</code></pre>
<p class="normal">There are two different methods we can use to call JavaScript:</p>
<ul>
<li class="bulletList"><code class="inlineCode">InvokeVoidAsync</code>, which calls JavaScript but doesn’t expect a return value</li>
<li class="bulletList"><code class="inlineCode">InvokeAsync&lt;T&gt;</code>, which calls JavaScript and expects a return value of type <code class="inlineCode">T</code></li>
</ul>
<p class="normal">We can also send in parameters to our JavaScript method if we want. We also need to refer to JavaScript, and JavaScript must be stored in the <code class="inlineCode">wwwroot</code> folder.</p>
<p class="normal">The other way is JavaScript isolation, which uses the methods described here, but with modules.</p>
<h2 class="heading-2" id="_idParaDest-187">JavaScript Isolation</h2>
<p class="normal">In .NET 5, we got a new way to <a id="_idIndexMarker422"/>add JavaScript using JavaScript<a id="_idIndexMarker423"/> Isolation, which is a much nicer way to call JavaScript. It doesn’t use global methods, and it doesn’t require us to refer to the JavaScript file.</p>
<p class="normal">This is awesome for component vendors and end users because JavaScript will be loaded when needed. It will only be loaded once (Blazor handles that for us), and we don’t need to add a reference to the JavaScript file, which makes it easier to start and use a library.</p>
<p class="normal">So, let’s implement that instead.</p>
<p class="normal">Isolated JavaScript can be stored in the <code class="inlineCode">wwwroot</code> folder, but since an update in .NET 6, we can add them in the same way we add isolated CSS. Add them to your component’s folder and name it, adding <code class="inlineCode">.js</code> to the end (<code class="inlineCode">mycomponent.razor.js</code>).</p>
<p class="normal">Let’s do just that!</p>
<p class="normal">In our project, we can delete categories and components. Let’s implement a simple JavaScript call to reveal a prompt to make sure that the user wants to delete the category or tag. But we have talked about doing things in a reusable way, so let’s do that:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, select the <code class="inlineCode">ReusableComponents/BlogButton.razor</code> file, create a new JavaScript file, and name the file <code class="inlineCode">BlogButton.razor.js</code>.</li>
<li class="numberedList">Open the new file (it is located under <code class="inlineCode">BlogButton.razor</code> in the solution explorer) and add the following code:
        <pre class="programlisting code"><code class="hljs-code">export function showConfirm(message) {
    return confirm(message);
}
</code></pre>
<p class="normal">JavaScript Isolation uses the standard <strong class="keyWord">EcmaScript</strong> (<strong class="keyWord">ES</strong>) modules<a id="_idIndexMarker424"/> and can be loaded on demand. The methods it exposes are only accessible through that object and not globally, as with the <em class="italic">old</em> way.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Open <code class="inlineCode">BlogButton.razor</code> and inject <code class="inlineCode">IJSRuntime</code> at the top of the file:
        <pre class="programlisting code"><code class="hljs-code">@using Microsoft.JSInterop
@inject IJSRuntime jsRuntime
</code></pre>
</li>
<li class="numberedList">In the <code class="inlineCode">code</code> section, let’s add a method that will call JavaScript:
        <pre class="programlisting code"><code class="hljs-code">    IJSObjectReference jsmodule;
    [Parameter]
    public string? ConfirmMessage { get; set; } = null;
    private async Task&lt;bool&gt; ShouldExecute()
    {
        if (ConfirmMessage != null)
        {
            jsmodule = await jsRuntime.InvokeAsync&lt;IJSObjectReference&gt;("import", "/_content/SharedComponents/ReusableComponents/BlogButton.razor.js");
            return await jsmodule.InvokeAsync&lt;bool&gt;("showConfirm", ConfirmMessage);
        }
        else
        {
            return true;
        }
    }
</code></pre>
<p class="normal"><code class="inlineCode">IJSObjectReference</code> is a reference to the specific script that we will import further down. It has access to the exported methods in our JavaScript, and nothing else.</p>
<p class="normal">We run <a id="_idIndexMarker425"/>the <code class="inlineCode">Import</code> command and send the filename<a id="_idIndexMarker426"/> as a parameter. This will run the <code class="inlineCode">let mymodule = import("/_content/SharedComponents/ReusableComponents/BlogButton.razor.js")</code> JavaScript command and return the module. We also add a <code class="inlineCode">ConfirmMessage</code> parameter so we know that if we have a <code class="inlineCode">ConfirmMessage</code> we should show a confirm message.</p>
<p class="normal">Then, in our <code class="inlineCode">OnButtonClick</code> method, we first check whether we <code class="inlineCode">shoudExecute</code> the method or not. Change it to the following:</p>
<pre class="programlisting code"><code class="hljs-code">if (OnClick.HasDelegate &amp;&amp; await ShouldExecute())
 {
     await OnClick.InvokeAsync(args);
 }
</code></pre>
<p class="normal">Now, we can use our button to confirm whether we want to delete the <code class="inlineCode">Category</code> or <code class="inlineCode">Tag</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Open <code class="inlineCode">ItemList.razor</code>, and let’s add our <code class="inlineCode">BlogButton</code> to the component. Inside the <code class="inlineCode">Virtualize</code> component, change the content to the following:
    <pre class="programlisting code"><code class="hljs-code"> &lt;tr&gt;
&lt;td&gt;
&lt;BlogButton OnClick="@(()=&gt; {SelectEvent.InvokeAsync(item); })"&gt; Select&lt;/BlogButton&gt;
&lt;/td&gt;
&lt;td&gt;@ItemTemplate(item)&lt;/td&gt;
&lt;td&gt;
&lt;BlogButton ConfirmMessage="Are you sure you want to delete this item?" Type="BlogButton.ButtonType.Delete" OnClick="@(()=&gt; {DeleteEvent.InvokeAsync(item);})"&gt; Delete&lt;/BlogButton&gt;
&lt;/td&gt;
&lt;/tr&gt;
</code></pre></li>
</ol>
<p class="normal">Instead of just <a id="_idIndexMarker427"/>calling our <code class="inlineCode">Delete</code> event callback, we first call our new<a id="_idIndexMarker428"/> method. Let JavaScript confirm that you really want to delete it, and if so, then run the <code class="inlineCode">Delete</code> event callback.</p>
<p class="normal">This is a simple implementation of JavaScript.</p>
<h1 class="heading-1" id="_idParaDest-188">JavaScript to .NET</h1>
<p class="normal">What <a id="_idIndexMarker429"/>about the other way around? I would argue that calling .NET code from JavaScript isn’t a very common scenario, and if we find ourselves in that scenario, we might want to think about what we are doing.</p>
<p class="normal">As Blazor developers, we should avoid using JavaScript as much as possible.</p>
<p class="normal">I am not bashing JavaScript in any way, but I see this often happen where developers kind of shoehorn what they’ve used before into their Blazor projects.</p>
<p class="normal">They are solving things with JavaScript that are easy to do with an <code class="inlineCode">if</code> statement in Blazor. So, that’s why I think it’s essential to think about when to use JavaScript and when not to use JavaScript.</p>
<p class="normal">There are, of course, times when JavaScript is the only option, and as I mentioned earlier, <code class="inlineCode">Blazm</code> uses communication both ways.</p>
<p class="normal">There are three ways of doing a callback from JavaScript to .NET code:</p>
<ul>
<li class="bulletList">A static .NET method call</li>
<li class="bulletList">An instance method call</li>
<li class="bulletList">A component instance method call</li>
</ul>
<p class="normal">Let’s take a closer look at them.</p>
<h2 class="heading-2" id="_idParaDest-189">Static .NET method call</h2>
<p class="normal">To call a .NET function<a id="_idIndexMarker430"/> from JavaScript, we can make the function static, and we also need to add the <code class="inlineCode">JSInvokable</code> attribute to the method.</p>
<p class="normal">We can add a function such as this in the <code class="inlineCode">code</code> section of a Razor component, or inside a class:</p>
<pre class="programlisting code"><code class="hljs-code">[JSInvokable]
public static Task&lt;int[]&gt; ReturnArrayAsync()
{
   return Task.FromResult(new int[] { 1, 2, 3 });
}
</code></pre>
<p class="normal">In the JavaScript file, we can call that function using the following code:</p>
<pre class="programlisting code"><code class="hljs-code">DotNet.invokeMethodAsync('BlazorWebAssemblySample', 'ReturnArrayAsync')
      .then(data =&gt; {
        data.push(4);
          console.log(data);
      });
</code></pre>
<p class="normal">The <code class="inlineCode">DotNet</code> object comes from the <code class="inlineCode">Blazor.js</code> or <code class="inlineCode">blazor.server.js</code> file.</p>
<p class="normal"><code class="inlineCode">BlazorWebAssemblySample</code> is the name of the assembly, and <code class="inlineCode">ReturnArrayAsync</code> is the name of the static .NET function.</p>
<p class="normal">It is also possible to specify the name of the function in the <code class="inlineCode">JSInvokeable</code> attribute if we don’t want it to be the same as the method name like this:</p>
<pre class="programlisting code"><code class="hljs-code">[JSInvokable("DifferentMethodName")]
</code></pre>
<p class="normal">In this sample, JavaScript calls back to .NET code, which returns an <code class="inlineCode">int</code> array.</p>
<p class="normal">It is returned as a promise in the JavaScript file that we are waiting for, and then (using the <code class="inlineCode">then</code> operator) we continue with the execution, adding a <code class="inlineCode">4</code> to the array and then outputting the values in the console.</p>
<h2 class="heading-2" id="_idParaDest-190">Instance method call</h2>
<p class="normal">This method is a bit tricky; we<a id="_idIndexMarker431"/> need to pass an instance of the .NET object to call it (this is the method that <code class="inlineCode">Blazm.Bluetooth</code> is using).</p>
<p class="normal">First, we need a class that will handle the method call:</p>
<pre class="programlisting code"><code class="hljs-code">using Microsoft.JSInterop;
public class HelloHelper
{
    public HelloHelper(string name)
    {
        Name = name;
    }
    public string Name { get; set; }
    [JSInvokable]
    public string SayHello() =&gt; $"Hello, {Name}!";
}
</code></pre>
<p class="normal">This class takes a string (a name) in the constructor and a method called <code class="inlineCode">SayHello</code> that returns a string containing <code class="inlineCode">"Hello,"</code> and the name we supplied when we created the instance.</p>
<p class="normal">So, we need to create an instance of that class, supply a name, and create <code class="inlineCode">DotNetObjectReference&lt;T&gt;</code>, which will give JavaScript access to the instance.</p>
<p class="normal">But first, we need JavaScript that can call the .NET function:</p>
<pre class="programlisting code"><code class="hljs-code">export function sayHello (dotnetHelper) {
    return dotnetHelper.invokeMethodAsync('SayHello').then(r =&gt; alert(r));
}
</code></pre>
<p class="normal">In this case, we are using the export syntax, and we export a function called <code class="inlineCode">sayHello</code>, which takes an instance of <code class="inlineCode">DotNetObjectReference</code> called <code class="inlineCode">dotnetHelper</code>.</p>
<p class="normal">In that instance, we invoke the <code class="inlineCode">SayHello</code> method, which is the <code class="inlineCode">SayHello</code> method on the .NET object. In this case, it will reference an instance of the <code class="inlineCode">HelloHelper</code> class.</p>
<p class="normal">We also need to call the JavaScript method, and we can do that from a class or, in this case, from a component:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/interop" @using Microsoft.JSInterop
@inject IJSRuntime jsRuntime
@implements IDisposable
&lt;button type="button" class="btn btn-primary" @onclick="async ()=&gt; { await TriggerNetInstanceMethod(); }"&gt;    Trigger .NET instance method HelloHelper.SayHello &lt;/button&gt;
@code {
    private DotNetObjectReference&lt;HelloHelper&gt; objRef;
    
    IJSObjectReference jsmodule;
    public async ValueTask&lt;string&gt;
 TriggerNetInstanceMethod()
    {
        objRef = DotNetObjectReference.Create(new HelloHelper("Bruce Wayne"));
        jsmodule = await jsRuntime. InvokeAsync&lt;IJSObjectReference&gt;("import", "/_content/MyBlog.Shared/Interop.razor.js");
        return await jsmodule.InvokeAsync&lt;string&gt;("sayHello", objRef);
    }
    public void Dispose()
    {
        objRef?.Dispose();
    }
}
</code></pre>
<p class="normal">Let’s go<a id="_idIndexMarker432"/> through the class. We inject <code class="inlineCode">IJSRuntime</code> because we need one to call the JavaScript function. To avoid any memory leaks, we also have to make sure to implement <code class="inlineCode">IDisposable</code> interface, and toward the bottom of the file, we make sure to dispose of the <code class="inlineCode">DotNetObjectReference</code> instance.</p>
<p class="normal">We create a private variable of the <code class="inlineCode">DotNetObjectReference&lt;HelloHelper&gt;</code> type, which is going to contain our reference to our <code class="inlineCode">HelloHelper</code> instance. We create <code class="inlineCode">IJSObjectReference</code> so that we can load our JavaScript function.</p>
<p class="normal">Then, we create an instance of <code class="inlineCode">DotNetObjectReference.Create(new HelloHelper("Bruce Wayne"))</code> of our reference to a new instance of the <code class="inlineCode">HelloHelper</code> class, which we supply with the name <code class="inlineCode">"Bruce Wayne"</code>.</p>
<p class="normal">Now, we have <code class="inlineCode">objRef</code>, which we will send to the JavaScript method, but first, we load the JavaScript module, and then we call <code class="inlineCode">JavaScriptMethod</code> and pass in the reference to our <code class="inlineCode">HelloHelper</code> instance. Now, the JavaScript <code class="inlineCode">sayHello</code> method will run <code class="inlineCode">hellohelperref.invokeMethodAsync('SayHello')</code>, which will make a call to <code class="inlineCode">SayHelloHelper</code> and get back a string with <code class="inlineCode">"Hello, Bruce Wayne"</code>.</p>
<p class="normal">There are <a id="_idIndexMarker433"/>two more ways that we can use to call .NET functions from JavaScript. We can call a method on a component instance where we can trigger an action, but it is not a recommended approach for Blazor Server. We can also call a method on a component instance by using a <code class="inlineCode">helper</code> class.</p>
<p class="normal">Since calling .NET from JavaScript is rare, we won’t go into the two examples. Instead, we’ll dive into things to think about when implementing an existing JavaScript library.</p>
<h1 class="heading-1" id="_idParaDest-191">Implementing an existing JavaScript library</h1>
<p class="normal">The best<a id="_idIndexMarker434"/> approach, in my opinion, is to avoid porting JavaScript libraries. Blazor needs to keep the DOM and the render tree in sync, and having JavaScript manipulate the DOM can jeopardize that.</p>
<p class="normal">Most component vendors, such as Telerik, Synfusion, Radzen, and, of course, <code class="inlineCode">Blazm</code>, have native components. They don’t just wrap JavaScript but are explicitly written for Blazor in C#. Even though the components use JavaScript in some capacity, the goal is to keep that to a minimum.</p>
<p class="normal">So, if you are a library maintainer, my recommendation would be to write a native Blazor version of the library, keep JavaScript to a minimum, and, most importantly, not force Blazor developers to write JavaScript to use your components.</p>
<p class="normal">Some components will be unable to use JavaScript implementations since they need to manipulate the DOM.</p>
<p class="normal">Blazor is pretty smart when syncing the DOM and render tree, but try to avoid manipulating the DOM. If you need to use JavaScript for something, make sure to put an HTML tag outside the manipulation area, and Blazor will then keep track of that tag and not think about what is inside the tag.</p>
<p class="normal">Since we started using Blazor at my workplace very early, many vendors had not yet come out with Blazor components. We needed a graph component fast. On our previous website (before Blazor), we used a component<a id="_idIndexMarker435"/> called <strong class="keyWord">Highcharts</strong>.</p>
<p class="normal"><code class="inlineCode">Highcharts</code> is free to use for non-commercial projects. When building our wrapper, we had a couple of things we wanted to ensure. We wanted the component to work in a similar way to the existing one, and we wanted it to be as simple to use as possible.</p>
<p class="normal">Let’s walk through what we did.</p>
<p class="normal">First, we added a reference to the <code class="inlineCode">Highcharts</code> JavaScript:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;script src="img/highcharts.js"&gt;&lt;/script&gt;
</code></pre>
<p class="normal">Then, we added a JavaScript file as follows:</p>
<pre class="programlisting code"><code class="hljs-code">export function loadHighchart(id, json) {
var obj = looseJsonParse(json);
    Highcharts.chart(id, obj);
};
export function looseJsonParse(obj) {
    return Function('"use strict";return (' + obj + ')')();
}
</code></pre>
<p class="normal">The <code class="inlineCode">loadHighchart</code> method takes <code class="inlineCode">id</code> of the <code class="inlineCode">div</code> tag, which should be converted into a chart, and the JSON for configuration.</p>
<p class="normal">There is also a method that converts the JSON into a JSON object so that it can be passed into the <code class="inlineCode">chart</code> method.</p>
<p class="normal">The <code class="inlineCode">Highchart</code> Razor<a id="_idIndexMarker436"/> component looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@using Microsoft.JSInterop
@inject Microsoft.JSInterop.IJSRuntime jsruntime
&lt;div&gt;
    &lt;div id="@id"&gt;&lt;/div&gt;
&lt;/div&gt;
@code
{
    [Parameter] public string Json { get; set; }
    private string id { get; set; } = "Highchart" + Guid.NewGuid().ToString();
    protected override void OnParametersSet()
    {
        StateHasChanged();
        base.OnParametersSet();
    }
    IJSObjectReference jsmodule;
    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!string.IsNullOrEmpty(Json))
        {
            jsmodule = await jsruntime.InvokeAsync&lt;IJSObjectReference&gt;("import", "/_content/Components/SharedComponents/HighChart.razor.js");
            await jsmodule.InvokeAsync&lt;string&gt;("loadHighchart", new object[] { id, Json });
        }
        await base.OnAfterRenderAsync(firstRender);
    }
}
</code></pre>
<p class="normal">The important thing to notice here is that we have two nested <code class="inlineCode">div</code> tags: one on the outside that we want Blazor to track and one on the inside that Highcharts will add things to.</p>
<p class="normal">We pass a JSON parameter in the JSON for the configuration and then call our JavaScript function. We run our JavaScript interop in the <code class="inlineCode">OnAfterRenderAsync</code> method because, otherwise, it would throw an exception, as you may recall from <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>.</p>
<p class="normal">Now, the only<a id="_idIndexMarker437"/> thing left to do is to use the component, and that looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@rendermode InteractiveServer @page "/HighChartTest"
&lt;HighChart Json="@chartjson"&gt;
&lt;/HighChart&gt;
@code {
    string chartjson = @" {
    chart: { type: 'pie'},
    series: [{
        data: [{
            name: 'Does not look like Pacman',
            color:'black',
            y: 20,
        }, {
            name: 'Looks like Pacman',
            color:'yellow',
            y: 80
        }]
    }]
}";
}
</code></pre>
<p class="normal">This test code<a id="_idIndexMarker438"/> will show a pie chart that looks like <em class="italic">Figure 10.1</em>:</p>
<figure class="mediaobject"><img alt="A yellow and black pie chart  Description automatically generated" src="img/B21849_10_01.png"/></figure>
<p class="packt_figref">Figure 10.1: Chart example</p>
<p class="normal">We have now gone through how we got a JavaScript library to work with Blazor, so this is an option if there is something we need.</p>
<p class="normal">As mentioned, component vendors are investing in Blazor, so chances are that they have what we need, so we might not need to invest time in creating our own component library.</p>
<h1 class="heading-1" id="_idParaDest-192">JavaScript interop in WebAssembly</h1>
<p class="normal">All the things <a id="_idIndexMarker439"/>mentioned so far in this chapter will work great for Blazor Server and Blazor WebAssembly.</p>
<p class="normal">But with Blazor WebAssembly, we have direct access to the <code class="inlineCode">JSRuntime</code> (since all the code is running inside the browser). Direct access will give us a really big performance boost. For most applications, we are doing one or two JavaScript calls. Performance is not really going to be a problem. Some applications are more JavaScript-heavy though and would benefit from using the <code class="inlineCode">JSRuntime</code> directly.</p>
<p class="normal">We have had direct access to the <code class="inlineCode">JSRuntime</code> using the <code class="inlineCode">IJSInProcessRuntime</code> and <code class="inlineCode">IJSUnmarshalledRuntime</code>. But with .NET 7, both are now obsolete, and we have gotten a nicer syntax.</p>
<p class="normal">In the GitHub repository, I have added a couple of files to the <code class="inlineCode">SharedComponents</code> project if you want to try the code.</p>
<p class="normal">We will start by looking at calling JavaScript from .NET. Please note that since our project is prerendering on the server, these code samples will not work (since they don’t work when running on the server). These samples must run in a WebAssembly-only project or disable the prerendering. They are included in the source code on GitHub for reference. </p>
<p class="normal">To be able to <a id="_idIndexMarker440"/>use these features, we need to enable them in the project file by enabling <code class="inlineCode">AllowUnsafeBlocks</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<h2 class="heading-2" id="_idParaDest-193">.NET to JavaScript</h2>
<p class="normal">To show the<a id="_idIndexMarker441"/> difference, the following sample is the same <code class="inlineCode">ShowAlert</code> function as earlier in the chapter.</p>
<p class="normal">The Razor file looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/nettojswasm"
@using System.Runtime.InteropServices.JavaScript
&lt;h3&gt;This is a demo how to call JavaScript from .NET&lt;/h3&gt;
&lt;button @onclick="ShowAlert"&gt;Show Alert&lt;/button&gt;
@code {
    protected async void ShowAlert()
    {
        ShowAlert("Hello from .NET");
    }
    protected override async Task OnInitializedAsync()
    {
        await JSHost.ImportAsync("nettojs", "../JSInteropSamples/NetToJS.razor.js");
    }
}
</code></pre>
<p class="normal">We are using <code class="inlineCode">JSHost</code> to import the JavaScript and give it the name <code class="inlineCode">"nettojs"</code>. A source generator generates the implementation for calling the JavaScript, and to be sure that it can pick up what it should do, we need to add some code in a code-behind. We will go into more depth on<a id="_idIndexMarker442"/> source generators in <em class="chapterRef">Chapter 17</em>, <em class="italic">Examining Source Generators</em>. The code-behind looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">using System.Runtime.InteropServices.JavaScript;
namespace BlazorWebAssembly.Client.JSInteropSamples;
public partial class NetToJS
{
    [JSImport("showAlert", "nettojs")]
    internal static partial string ShowAlert(string message);
}
</code></pre>
<p class="normal">The JavaScript file looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">export function showAlert(message) {
    return alert(message);
}
</code></pre>
<p class="normal">We add a <code class="inlineCode">JSImport</code> attribute to a method, which will automatically be mapped to the JavaScript call.</p>
<p class="normal">This is a <a id="_idIndexMarker443"/>much nicer implementation, I think, and a lot faster.</p>
<p class="normal">Next, we will look at calling .NET from JavaScript.</p>
<h2 class="heading-2" id="_idParaDest-194">JavaScript to .NET</h2>
<p class="normal">When calling a .NET method<a id="_idIndexMarker444"/> from JavaScript, a new attribute makes that possible called <code class="inlineCode">JSExport</code>.</p>
<p class="normal">The Razor file implementation looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/jstostaticnetwasm"
@using System.Runtime.InteropServices.JavaScript
&lt;h3&gt;This is a demo how to call .NET from JavaScript&lt;/h3&gt;
&lt;button @onclick="ShowMessage"&gt;Show alert with message&lt;/button&gt;
@code {
    protected override async Task OnInitializedAsync()
    {
        await JSHost.ImportAsync("jstonet", "../JSInteropSamples/JSToStaticNET.razor.js");
    }
}
</code></pre>
<p class="normal">Calling <code class="inlineCode">JSHost.ImportAsync</code> is not necessary for the <code class="inlineCode">JSExport</code> part of the demo, but we need it to call JavaScript so that we can make the .NET call from JavaScript.</p>
<p class="normal">Similarly, here <a id="_idIndexMarker445"/>we need to have the methods in a code-behind class that looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">using System.Runtime.InteropServices.JavaScript;
using System.Runtime.Versioning;
namespace BlazorWebAssembly.Client.JSInteropSamples;
[SupportedOSPlatform("browser")]
public partial class JSToStaticNET
{
    [JSExport]
    internal static string GetAMessageFromNET()
    {
        return "This is a message from .NET";
    }
    [JSImport("showMessage", "jstonet")]
    internal static partial void ShowMessage();
}
</code></pre>
<p class="normal">Here, we are using the <code class="inlineCode">SupportedOSPlatform</code> attribute to ensure that this code can only run on a browser.</p>
<p class="normal">The JavaScript portion of this demo looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">export async function setMessage() {
    const { getAssemblyExports } = await globalThis.getDotnetRuntime(0);
    var exports = await getAssemblyExports("BlazorWebAssembly.Client.dll");
    alert(exports.BlazorWebAssembly.Client.JSInteropSamples.JSToStaticNET.GetAMessageFromNET());
}
export async function showMessage() {
    await setMessage();
}
</code></pre>
<p class="normal">We call the <code class="inlineCode">showMessage</code> JavaScript function from .NET, and it will then call the <code class="inlineCode">setMessage</code> function.</p>
<p class="normal">The <code class="inlineCode">setMessage</code> function uses the <code class="inlineCode">globalThis</code> object to access the .NET runtime and get access to the <code class="inlineCode">getAssemblyExports</code> method.</p>
<p class="normal">It will <a id="_idIndexMarker446"/>retrieve all the exports for our assembly and then run the method. The .NET method will return the <code class="inlineCode">"This is a message from .NET"</code> string and show the string in an alert box.</p>
<p class="normal">Even though I prefer not to make any JavaScript calls in my Blazor applications, I love having the power to bridge between .NET code and JavaScript code with ease.</p>
<h1 class="heading-1" id="_idParaDest-195">Summary</h1>
<p class="normal">This chapter taught us about calling JavaScript from .NET and calling .NET from JavaScript. In most cases, we won’t need to do JavaScript calls, and chances are that the Blazor community or component vendors have solved the problem for us.</p>
<p class="normal">We also looked at how we can port an existing library if needed.</p>
<p class="normal">In the next chapter, we will continue to look at state management.</p>
<h1 class="heading-1" id="_idParaDest-196">Join our community on Discord </h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/WebDevBlazor3e">https://packt.link/WebDevBlazor3e</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code2668029180838459906.png"/></p>
</div>
</body></html>