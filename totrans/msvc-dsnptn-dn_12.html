<html><head></head><body>
<div id="_idContainer063">
<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.2.1">Securing Microservices with Bearer Tokens</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Security is one of the most important and tedious aspects of any application. </span><span class="koboSpan" id="kobo.3.2">We need to ensure that our application is built using secure code and always pursue the most effective ways to reduce intrusions and loopholes in our systems. </span><span class="koboSpan" id="kobo.3.3">Despite this, however, security also comes at the cost of usability, and we should always seek to find a balance between the two.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Basic application security begins with a login system. </span><span class="koboSpan" id="kobo.4.2">We should be able to allow a user to register themselves in a system and store some identifying information accordingly. </span><span class="koboSpan" id="kobo.4.3">When the user returns and wishes to access certain parts of the application, we will query the database and verify the identity of the user through their identifying information and decide to grant or restrict access accordingly.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In modern applications, we find it increasingly difficult to maintain a data store as an authority on all our users, while accounting for all the possible channels through which they may access our application. </span><span class="koboSpan" id="kobo.5.2">We have been exploring using microservices architecture, which takes our security considerations to a new level, where we now have multiple parts of an application that we need to secure for different users who are accessing from several devices.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, we will explore the major considerations to be made in securing our microservices application and the best configurations and technologies to use.</span></p>
<p><span class="koboSpan" id="kobo.7.1">After reading this chapter, we will have done the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Understand bearer token security</span></li>
<li><span class="koboSpan" id="kobo.9.1">Learn how to implement bearer token security in an ASP.NET Core API</span></li>
<li><span class="koboSpan" id="kobo.10.1">Learn how to use an identity provider to secure our microservices</span></li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.11.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.12.1">The code references used in this chapter can be found in the project repository that is hosted on GitHub here: </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12"><span class="koboSpan" id="kobo.13.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12</span></a><span class="koboSpan" id="kobo.14.1">.</span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.15.1">Bearer tokens for securing communications</span></h1>
<p><span class="koboSpan" id="kobo.16.1">Bearer tokens are a fairly recent solution to a number of security, authentication, and authorization challenges that we have faced when developing modern applications. </span><span class="koboSpan" id="kobo.16.2">We have gone from working with standard</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.17.1"> desktop and web applications to catering to various internet-capable devices that have similar security needs. </span><span class="koboSpan" id="kobo.17.2">Before we start exploring what these modern security needs are, let us review some of the challenges that we have faced with web applications over the years.</span></p>
<p><span class="koboSpan" id="kobo.18.1">When securing web </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.19.1">applications, we face several challenges:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">We need a way to collect user information.</span></li>
<li><span class="koboSpan" id="kobo.21.1">We need a way to store user information.</span></li>
<li><span class="koboSpan" id="kobo.22.1">We need a way to validate </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.23.1">user information. </span><span class="koboSpan" id="kobo.23.2">This is called </span><em class="italic"><span class="koboSpan" id="kobo.24.1">authentication</span></em><span class="koboSpan" id="kobo.25.1">.</span></li>
<li><span class="koboSpan" id="kobo.26.1">We need a way to track the user’s authenticated state in between requests.</span></li>
<li><span class="koboSpan" id="kobo.27.1">We need a way to track what </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.28.1">the user is allowed to do in our system. </span><span class="koboSpan" id="kobo.28.2">This is called </span><em class="italic"><span class="koboSpan" id="kobo.29.1">authorization</span></em><span class="koboSpan" id="kobo.30.1">.</span></li>
<li><span class="koboSpan" id="kobo.31.1">We need to cater to various channels or device types through which a user might access the web application.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">In a typical web application, most of these factors can be implemented through form authentication, where we ask for uniquely identifying information and check our database for a match.</span></p>
<p><span class="koboSpan" id="kobo.33.1">When a match is found, we instantiate a temporary storage mechanism that will identify the user as authenticated in our system. </span><span class="koboSpan" id="kobo.33.2">This temporary storage construct can come in the form of the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Sessions</span></strong><span class="koboSpan" id="kobo.35.1">: A way to store information in a variable that can be used across a website. </span><span class="koboSpan" id="kobo.35.2">Unlike typical variables that lose their value with each request, a session retains </span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.36.1">its value for a certain period until it either expires or is destroyed. </span><span class="koboSpan" id="kobo.36.2">Session variables are typically stored on the server, and one or many session variables are </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.37.1">created each time a user authenticates successfully. </span><span class="koboSpan" id="kobo.37.2">Session variables can store information such as a username, role, and so on. </span><span class="koboSpan" id="kobo.37.3">With too many users logging in simultaneously, using session variables can lead to memory issues on a less powerful server.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">Cookies</span></strong><span class="koboSpan" id="kobo.39.1">: An alternative to sessions, where a small file is created and stored on the user’s device. </span><span class="koboSpan" id="kobo.39.2">It serves a similar purpose for storing information between requests, as well as tracking a user’s authenticated state. </span><span class="koboSpan" id="kobo.39.3">Each time a request is sent from the user’s device, this </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.40.1">cook</span><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.41.1">ie is sent, and the server web application uses this information to be informed of whether actions can be taken and if so, which ones. </span><span class="koboSpan" id="kobo.41.2">Cookies are sometimes preferred to sessions given that they reduce the load on the server and place more responsibility on the user’s device.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.42.1">Both options work </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.43.1">fantastically when we are sure that we will be dealing with a web application that maintains a </span><em class="italic"><span class="koboSpan" id="kobo.44.1">state</span></em><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">A state means that we retain user information in between requests and remember who is logged in and their basic information for the period that they are using the website – but what h</span><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.46.1">appens when you need to authenticate against APIs? </span><span class="koboSpan" id="kobo.46.2">An API, by nature, does not maintain a state. </span><span class="koboSpan" id="kobo.46.3">It does not attempt to retain the knowledge of the users accessing it since APIs are designed for sporadic access from any channel at any point. </span><span class="koboSpan" id="kobo.46.4">For this reason, we implement bearer tokens.</span></p>
<p><span class="koboSpan" id="kobo.47.1">A bearer token is an encoded string that contains information about a user who is attempting to communicate with our API. </span><span class="koboSpan" id="kobo.47.2">It helps us facilitate stateless communication and facilitate general user authentication and authorization scenarios.</span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.48.1">Understanding bearer tokens</span></h2>
<p><span class="koboSpan" id="kobo.49.1">A </span><em class="italic"><span class="koboSpan" id="kobo.50.1">bearer token</span></em><span class="koboSpan" id="kobo.51.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">JSON Web Token</span></strong><span class="koboSpan" id="kobo.53.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.54.1">JWT</span></strong><span class="koboSpan" id="kobo.55.1">) is a construct </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.56.1">that is widely </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.57.1">used in </span><em class="italic"><span class="koboSpan" id="kobo.58.1">authentication</span></em><span class="koboSpan" id="kobo.59.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.60.1">authorization</span></em><span class="koboSpan" id="kobo.61.1"> scenarios for </span><em class="italic"><span class="koboSpan" id="kobo.62.1">stateless</span></em><span class="koboSpan" id="kobo.63.1"> APIs. </span><span class="koboSpan" id="kobo.63.2">Bearer tokens are based on an open industry standard of authentication that has made it easy for us to share authenticated user information between a server and a client. </span><span class="koboSpan" id="kobo.63.3">When an API is accessed, a temporary state is created for the duration of the request-response cycle. </span><span class="koboSpan" id="kobo.63.4">This means that when the request is received, we can determine the originating source of the request and can decode additional header information as needed. </span><span class="koboSpan" id="kobo.63.5">Once a response is returned, we no longer have a record of the request, where it came from, or who made it.</span></p>
<p><span class="koboSpan" id="kobo.64.1">Bearer tokens are issued </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.65.1">after a successful authentication request. </span><span class="koboSpan" id="kobo.65.2">We receive a request to our authentication API endpoint and use the information to check our databases, as previously described. </span><span class="koboSpan" id="kobo.65.3">Once a user is verified, we compile several data points, such as the </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.66.1">following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.67.1">Subject</span></strong><span class="koboSpan" id="kobo.68.1">: Usually a unique identifier for the user, such as the user ID from the originating database.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Issuer</span></strong><span class="koboSpan" id="kobo.70.1">: Usually a name that is associated with the service that has generated the token for issuance.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.71.1">Audience</span></strong><span class="koboSpan" id="kobo.72.1">: Usually a name that is associated with the client application that will be consuming the token.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Username</span></strong><span class="koboSpan" id="kobo.74.1">: The user’s unique system name, usually used for login.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Email address</span></strong><span class="koboSpan" id="kobo.76.1">: The user’s email address.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.77.1">Role</span></strong><span class="koboSpan" id="kobo.78.1">: The user’s system role that determines what they are authorized to do.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Claims</span></strong><span class="koboSpan" id="kobo.80.1">: Various bits of information about the user that can be used to aid in authorization or information display in the client application. </span><span class="koboSpan" id="kobo.80.2">This can include the user’s name, gender, and even the path to their profile picture.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Expiry Date</span></strong><span class="koboSpan" id="kobo.82.1">: Tokens should always have a moderate expiry date relative to their generation. </span><span class="koboSpan" id="kobo.82.2">When this expires, the user will need to reauthenticate, so we don’t want it to only be valid for a short period, but it should also not last forever.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.83.1">Ultimately, a login flow between a client application and an API is as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.84.1">A user will use a client application to log in</span></li>
<li><span class="koboSpan" id="kobo.85.1">The client application forwards the information collected from the login form to the login API endpoint for verification</span></li>
<li><span class="koboSpan" id="kobo.86.1">The API returns an encoded string, or token, that contains the most relevant bits of information about the user</span></li>
<li><span class="koboSpan" id="kobo.87.1">The client application stores this encoded string and uses it for subsequent API communications</span></li>
</ol>
<p><span class="koboSpan" id="kobo.88.1">Based on this kind of flow, the client application will use information from the token to display information about the user on the UI, such as the username or other information that may have been included such as the first name and last name. </span><span class="koboSpan" id="kobo.88.2">While there are recommended bits of</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.89.1"> information that you should include in a token, there is no set standard on what should be included. </span><span class="koboSpan" id="kobo.89.2">We do, however, avoid including sensitive information, such as a password.</span></p>
<p><span class="koboSpan" id="kobo.90.1">Bearer tokens are encoded but not encrypted. </span><span class="koboSpan" id="kobo.90.2">This means that they are self-contained blocks of information that contain all the information that we have mentioned earlier but are not human-readable at first sight. </span><span class="koboSpan" id="kobo.90.3">The encoding compresses the strings, usually as a </span><em class="italic"><span class="koboSpan" id="kobo.91.1">base64</span></em><span class="koboSpan" id="kobo.92.1"> representation, and this is the format used for transportation between the client and the server, as well as for storage. </span><span class="koboSpan" id="kobo.92.2">Token strings are not meant to be secure since it is easy to decode the string and see the information therein, and once again, that is why we do not include sensitive and incriminating data in the token. </span><span class="koboSpan" id="kobo.92.3">This token string comprises three sections. </span><span class="koboSpan" id="kobo.92.4">Each section is separated by a full stop (</span><em class="italic"><span class="koboSpan" id="kobo.93.1">.</span></em><span class="koboSpan" id="kobo.94.1">) and the general format is </span><em class="italic"><span class="koboSpan" id="kobo.95.1">aaaa.bbbb.cccc</span></em><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">Each section represents the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Header</span></strong><span class="koboSpan" id="kobo.98.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.99.1">a</span></em><span class="koboSpan" id="kobo.100.1"> section of the token, which contains information about the type of token and the signing algorithm that was used for the encoding, such as HMAC SHA-256 and RSA.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Payload</span></strong><span class="koboSpan" id="kobo.102.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.103.1">b</span></em><span class="koboSpan" id="kobo.104.1"> section of the token string, which contains user information in the form of claims. </span><span class="koboSpan" id="kobo.104.2">We will discuss claims in a bit more detail later in this chapter.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">Signature</span></strong><span class="koboSpan" id="kobo.106.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.107.1">c</span></em><span class="koboSpan" id="kobo.108.1"> section of the token, which contains a string representation of the encoded header, the encoded payload, and the secret key that was used for the encoding. </span><span class="koboSpan" id="kobo.108.2">This signature is used to verify that the token has not been tampered with since its generation.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.109.1">Most development frameworks include tools and libraries that can decrypt bearer tokens during the runtime of the application. </span><span class="koboSpan" id="kobo.109.2">Since bearer tokens are based on an open standard, support for decoding tokens is widely available. </span><span class="koboSpan" id="kobo.109.3">This allows us to write generic and consistent code to handle tokens being issued by an API. </span><span class="koboSpan" id="kobo.109.4">Each API implementation can include different tokens relative to the exact needs of the application, but there are certain standards that we can</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.110.1"> always count on.</span></p>
<p><span class="koboSpan" id="kobo.111.1">During development, however, we might want to test a token to see the contents that we can expect to be present in a more human-readable form. </span><span class="koboSpan" id="kobo.111.2">For this reason, we turn to third-party tools that decode and show us the contents of a token and allow us to reference different bits of information as needed.</span></p>
<p><span class="koboSpan" id="kobo.112.1">Tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">jwt.io</span></strong><span class="koboSpan" id="kobo.114.1"> provide us</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.115.1"> with the ability to simply paste in a token and view the information in a more human-readable format. </span><span class="koboSpan" id="kobo.115.2">As stated, there are three sections in each token string and we can view each of the sections in plaintext using this website or a similar tool. </span><span class="koboSpan" id="kobo.115.3">The payload section of the token, when decoded, will yield the information displayed in </span><em class="italic"><span class="koboSpan" id="kobo.116.1">Figure 12.1</span></em><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">It shows a sample bearer token and its contents on </span><a href="http://www.jwt.io"><span class="koboSpan" id="kobo.118.1">www.jwt.io</span></a><span class="koboSpan" id="kobo.119.1">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.120.1"><img alt="Figure 12.1 – We see the encoded string and the plaintext translation of its contents to the right" src="image/Figure_12.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.121.1">Figure 12.1 – We see the encoded string and the plaintext translation of its contents to the right</span></p>
<p><span class="koboSpan" id="kobo.122.1">All the information that is placed into a bearer token represents a key-value pair. </span><span class="koboSpan" id="kobo.122.2">Each key-value pair represents a unit of information about the user or the token itself, and the keys are really short names for the previously mentioned claims that are usually present in a token:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.123.1">iss</span></strong><span class="koboSpan" id="kobo.124.1">: Represents the </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">issuer</span></strong><span class="koboSpan" id="kobo.126.1"> value.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.127.1">sub</span></strong><span class="koboSpan" id="kobo.128.1">: Represents the </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">subject</span></strong><span class="koboSpan" id="kobo.130.1"> value.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">aud</span></strong><span class="koboSpan" id="kobo.132.1">: Represents the </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">audience</span></strong><span class="koboSpan" id="kobo.134.1"> value.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">nonce</span></strong><span class="koboSpan" id="kobo.136.1">: Represents a unique value that should always change with each token to prevent replay attacks. </span><span class="koboSpan" id="kobo.136.2">This value is always new, and this ensures that no two tokens that are issued to the </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.137.1">same user are the same. </span><span class="koboSpan" id="kobo.137.2">This can sometimes be called a </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">jti</span></strong><span class="koboSpan" id="kobo.139.1"> claim.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.140.1">exp</span></strong><span class="koboSpan" id="kobo.141.1">: Represents the expiration date of the token. </span><span class="koboSpan" id="kobo.141.2">The value is in the form of a UNIX epoch, which is a numerical representation of a moment in time.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.142.1">iat</span></strong><span class="koboSpan" id="kobo.143.1">: Represents the date and time of issuance.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.144.1">Now that we have</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.145.1"> explored why we need bearer tokens and how they are used, let us review how we can implement token security in our ASP.NET Core API application.</span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.146.1">Implementing bearer token security</span></h1>
<p><span class="koboSpan" id="kobo.147.1">ASP.NET Core offers native authentication and authorization support through its </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">Identity Core</span></strong><span class="koboSpan" id="kobo.149.1"> library. </span><span class="koboSpan" id="kobo.149.2">This library has direct integration with Entity Framework and allows us to create standard user management tables in the target database. </span><span class="koboSpan" id="kobo.149.3">We can also further specify the</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.150.1"> authentication methods that we prefer and define policies that define authorization rules throughout that application.</span></p>
<p><span class="koboSpan" id="kobo.151.1">This robust library has built-in support for the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.152.1">User registration</span></strong><span class="koboSpan" id="kobo.153.1">: The user manager library has functions that make user creation and management easy. </span><span class="koboSpan" id="kobo.153.2">It has functions that cover most of the common user management operations.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.154.1">Login, session, and cookie management</span></strong><span class="koboSpan" id="kobo.155.1">: The sign-in manager library has functions that can manage user authentication and session management scenarios.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.156.1">Two-factor authentication</span></strong><span class="koboSpan" id="kobo.157.1">: Identity Core allows us to implement multi-factor authentication natively with email or SMS. </span><span class="koboSpan" id="kobo.157.2">This can be easily extended.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Third-party identity providers</span></strong><span class="koboSpan" id="kobo.159.1">: Social logins are important for any modern web application and </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Identity Core</span></strong><span class="koboSpan" id="kobo.161.1"> makes it easy to integrate this feature into your application.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.162.1">Securing an API using bearer tokens ensures that each API call is required to have a valid token in the header section of the request. </span><span class="koboSpan" id="kobo.162.2">An HTTP header allows for additional information to be provided with an HTTP request or response.</span></p>
<p><span class="koboSpan" id="kobo.163.1">In our case of securing an </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.164.1">API, we enforce that each request must have an authorization header that contains the bearer token. </span><span class="koboSpan" id="kobo.164.2">Our API will assess the incoming request headers, retrieve the token, and validate it against the predefined configurations. </span><span class="koboSpan" id="kobo.164.3">If the token doesn’t meet the standards or is expired, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">HTTP 401 Unauthorized</span></strong><span class="koboSpan" id="kobo.166.1"> response will be returned. </span><span class="koboSpan" id="kobo.166.2">If the token meets the requirements, then the request will be fulfilled. </span><span class="koboSpan" id="kobo.166.3">This built-in mechanism makes it easy and maintainable to support wide-scale and robust authentication and authorization rules in our application.</span></p>
<p><span class="koboSpan" id="kobo.167.1">Now that we have an idea of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Identity Core</span></strong><span class="koboSpan" id="kobo.169.1"> library and how it is natively supported in ASP.NET Core applications, we can explore the necessary package and configurations needed to secure an API using bearer tokens.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.170.1">Securing API with bearer tokens</span></h2>
<p><span class="koboSpan" id="kobo.171.1">We can begin by</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.172.1"> installing the following packages using the NuGet package manager:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
Install-Package Microsoft.AspNetCore.Authentication
  .JwtBearer</span></pre>
<p><span class="koboSpan" id="kobo.174.1">The first package supports direct integration between Entity Framework and </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Identity Core</span></strong><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">The second package contains extended methods that allow us to implement token generation and validation rules in our API configuration.</span></p>
<p><span class="koboSpan" id="kobo.177.1">Next, we need to define constant values that will inform the token generation and validation activities in the API. </span><span class="koboSpan" id="kobo.177.2">We can place these constants in </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.179.1"> and they will look as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
  "Jwt": {
    "Issuer": "HealthCare.Appointments.API",
    "Audience": " HealthCare.Appointments.Client",
    "DurationInHours": 8
    "Key": "ASecretEncodedStringHere-Minimum16Charatcters"
  }</span></pre>
<p><span class="koboSpan" id="kobo.181.1">We have already discussed what the issuer and audience values help to enforce. </span><span class="koboSpan" id="kobo.181.2">We can also state a value for the proposed lifetime of the token that is generated. </span><span class="koboSpan" id="kobo.181.3">This value should always be relative to the API’s capabilities and operations, as well as your risk tolerance. </span><span class="koboSpan" id="kobo.181.4">The longer a token remains valid, the longer we provide a potential attacker with a window into our system. </span><span class="koboSpan" id="kobo.181.5">At the same time, if the period is too short, then the client will need to</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.182.1"> reauthenticate too often. </span><span class="koboSpan" id="kobo.182.2">We should always seek to strike a balance.</span></p>
<p><span class="koboSpan" id="kobo.183.1">Our key value here is demonstrative in its value, but we use this signing key as an encryption key when generating the token. </span><span class="koboSpan" id="kobo.183.2">The key should always be kept secret, so we may use application secrets or a more secure key store to store this value.</span></p>
<p><span class="koboSpan" id="kobo.184.1">Now that we have the application constants, we can proceed to specify the global authentication settings in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Program.cs</span></strong><span class="koboSpan" id="kobo.186.1"> file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
builder.Services.AddAuthentication(options =&gt;
{
    options.DefaultAuthenticateScheme =
        JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme =
        JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(o =&gt;
{
    o.TokenValidationParameters = new
        TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration
            ["Jwt:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey
        (Encoding.UTF8.GetBytes(builder.Configuration["Jwt:
            Key"]))
    };
});</span></pre>
<p><span class="koboSpan" id="kobo.188.1">Here, we are adding</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.189.1"> configurations to the application that will declare to the API application that it should enforce a particular type of authentication scheme. </span><span class="koboSpan" id="kobo.189.2">Given that Identity Core has support for several authentication schemes, we need to specify the ones that we intend to enforce and by extension, the type of challenge scheme that we require. </span><span class="koboSpan" id="kobo.189.3">The challenge scheme refers to the authentication requirements that the application will need. </span><span class="koboSpan" id="kobo.189.4">Here, we specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">JwtBearerDefaults.AuthenticationScheme</span></strong><span class="koboSpan" id="kobo.191.1"> for both the challenge and authentication schemes. </span><span class="koboSpan" id="kobo.191.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">JwtBearerDefaults</span></strong><span class="koboSpan" id="kobo.193.1"> class contains generally available and used JWT constants. </span><span class="koboSpan" id="kobo.193.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">AuthenticationScheme</span></strong><span class="koboSpan" id="kobo.195.1"> will render the value bearer, which is a keyword.</span></p>
<p><span class="koboSpan" id="kobo.196.1">After we are done defining the authentication scheme, we go on to set configurations that will enforce certain rules that will govern how a bearer token is validated. </span><span class="koboSpan" id="kobo.196.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">true</span></strong><span class="koboSpan" id="kobo.198.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">ValidateIssuer</span></strong><span class="koboSpan" id="kobo.200.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">ValidateAdience</span></strong><span class="koboSpan" id="kobo.202.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">ValidateLifetime</span></strong><span class="koboSpan" id="kobo.204.1">, we are enforcing that the matching values in an incoming token must match the values that we set in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.206.1"> configuration constants. </span><span class="koboSpan" id="kobo.206.2">You can be flexible with the validation rules based on how strictly you want to check the bearer token contents against your system. </span><span class="koboSpan" id="kobo.206.3">The fewer validations in place, the higher the chances of someone using fake tokens to gain access to the system.</span></p>
<p><span class="koboSpan" id="kobo.207.1">We will also need to ensure that our API knows that we intend to support authorization, so we need to add this line as well:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
builder.Services.AddAuthorization();</span></pre>
<p><span class="koboSpan" id="kobo.209.1">Then, we also need to include our middleware with the following two lines, in this order:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
app.UseAuthentication();
app.UseAuthorization();</span></pre>
<p><span class="koboSpan" id="kobo.211.1">Now that we have taken care of the preliminary configurations, we need to include our default identity user tables in our database. </span><span class="koboSpan" id="kobo.211.2">We first change the inheritance of our database context from </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">DbContext</span></strong><span class="koboSpan" id="kobo.213.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">IdentityDbContext</span></strong><span class="koboSpan" id="kobo.215.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
public class AppointmentsDbContext : IdentityDbContext</span></pre>
<p><span class="koboSpan" id="kobo.217.1">We will also add </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.218.1">code to generate a sample user in the database context. </span><span class="koboSpan" id="kobo.218.2">When we perform the next migration, then this user will be added to the table and we can use it to test authentication:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
protected override void OnModelCreating(ModelBuilder
    builder)
        {
            base.OnModelCreating(builder);
            var hasher = new PasswordHasher&lt;ApiUser&gt;();
            builder.Entity&lt;ApiUser&gt;().HasData(new ApiUser
            {
                Id = "408aa945-3d84-4421-8342-
                    7269ec64d949",
                Email = "admin@localhost.com",
                NormalizedEmail = "ADMIN@LOCALHOST.COM",
                NormalizedUserName = "ADMIN@LOCALHOST.COM",
                UserName = "admin@localhost.com",
                PasswordHash = hasher.HashPassword(null,
                    "P@ssword1"),
                EmailConfirmed = true
            });
        }</span></pre>
<p><span class="koboSpan" id="kobo.220.1">After these changes, the next migration that we perform will generate user tables that will be created when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">update-database</span></strong><span class="koboSpan" id="kobo.222.1"> command is executed. </span><span class="koboSpan" id="kobo.222.2">These new tables will, by default, be prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">AspNet</span></strong><span class="koboSpan" id="kobo.224.1">.</span></p>
<p><span class="koboSpan" id="kobo.225.1">We also need to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Identity Core</span></strong><span class="koboSpan" id="kobo.227.1"> services in our application and connect it to the database context as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
builder.Services.AddIdentityCore&lt;IdentityUser&gt;()
    .AddRoles&lt;IdentityRole&gt;()
    .AddEntityFrameworkStores&lt;AppointmentsDbContext&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.229.1">Here, we register </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.230.1">our identity-related services in our applications, specify that we are using the default user type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">IdentityUser</span></strong><span class="koboSpan" id="kobo.232.1">, the default role type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">IdentityRole</span></strong><span class="koboSpan" id="kobo.234.1">, and the data store associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">AppointmentsDbContext</span></strong><span class="koboSpan" id="kobo.236.1">.</span></p>
<p><span class="koboSpan" id="kobo.237.1">Now that we have specified what is required for the integration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Identity Core</span></strong><span class="koboSpan" id="kobo.239.1"> and JWT authentication, we can look to implement a login endpoint that will verify the user’s credentials and generate a token with the minimum identifying information accordingly. </span><span class="koboSpan" id="kobo.239.2">We will investigate this in the next section.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.240.1">Generating and issuing bearer tokens</span></h2>
<p><span class="koboSpan" id="kobo.241.1">ASP.NET Core has support for </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.242.1">generating, issuing, and validating bearer tokens. </span><span class="koboSpan" id="kobo.242.2">To do this, we need to implement logic in our authentication flow that will generate a token</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.243.1"> with the authenticated user’s information, and then return it to the requesting client in the body of the response. </span><span class="koboSpan" id="kobo.243.2">Let us</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.244.1"> first define a </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">data transfer object</span></strong><span class="koboSpan" id="kobo.246.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.247.1">DTO</span></strong><span class="koboSpan" id="kobo.248.1">), that will store the user’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Id</span></strong><span class="koboSpan" id="kobo.250.1"> value and the token and wrap them both in their own </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">AuthResponseDto</span></strong><span class="koboSpan" id="kobo.252.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
public class AuthResponseDto
{
   public string UserId { get; set; }
   public string Token { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.254.1">We will also have a DTO that will accept login information. </span><span class="koboSpan" id="kobo.254.2">We can call this </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">LoginDto</span></strong><span class="koboSpan" id="kobo.256.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
public class LoginDto
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; }
        [Required]
        [StringLength(15, ErrorMessage = "Your Password is
            limited to {2} to {1} characters",
                MinimumLength = 6)]
        public string Password { get; set; }
    }</span></pre>
<p><span class="koboSpan" id="kobo.258.1">Our DTO will enforce </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.259.1">validation rules on the data being submitted. </span><span class="koboSpan" id="kobo.259.2">Here, our users </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.260.1">can authenticate using their email address and a password, and invalid attempts that violate the validation rules will be rejected with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">400BadRequest</span></strong><span class="koboSpan" id="kobo.262.1"> HTTP code.</span></p>
<p><span class="koboSpan" id="kobo.263.1">Our authentication controller will implement a login action that will accept this DTO as a parameter:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
[Route("api/[controller]")]
[ApiController]
public class AccountController : ControllerBase
{
    private readonly IAuthManager _authManager;
    public AccountController(IAuthManager authManager)
    {
        _authManager = authManager;
    }
    // Other Actions here
    [HttpPost]
    [Route("login")]
    public async Task&lt;IActionResult&gt; Login([FromBody]
        LoginDTO loginDto)
    {
        var authResponse = _authManager.Login(loginDto);
        if (authResponse == null)
        {
            return Unauthorized();
        }
        return Ok(authResponse);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.265.1">We inject an </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">IAuthmanager</span></strong><span class="koboSpan" id="kobo.267.1"> service</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.268.1"> into the controller, where we have abstracted </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.269.1">the bulk of the user validation and token generation logic. </span><span class="koboSpan" id="kobo.269.2">This service contract is as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
public interface IAuthManager
{
   // Other methods
   Task&lt;AuthResponseDto&gt; Login(LoginDto loginDto);
}</span></pre>
<p><span class="koboSpan" id="kobo.271.1">In the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">AuthManager</span></strong><span class="koboSpan" id="kobo.273.1">, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">UserManager</span></strong><span class="koboSpan" id="kobo.275.1"> service, which is provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Identity Core</span></strong><span class="koboSpan" id="kobo.277.1">, to verify the username and password combination that is submitted. </span><span class="koboSpan" id="kobo.277.2">Upon verification, we will generate and return an </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">AuthResponseDto</span></strong><span class="koboSpan" id="kobo.279.1"> object containing </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.280.1">the token and user’s ID. </span><span class="koboSpan" id="kobo.280.2">Our implementations will look</span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.281.1"> like the following code block:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
public class AuthManager : IAuthManager
{
    private readonly UserManager&lt;IdentityUser&gt;
        _userManager;
    private readonly IConfiguration _configuration;
    private IdentityUser _user;
    public AuthManager(UserManager&lt;IdentityUser&gt;
        userManager, IConfiguration configuration)
    {
        this._userManager = userManager;
        this._configuration = configuration;
    }
    // Other Methods
    public async Task&lt;AuthResponseDto&gt; Login(LoginDto
        loginDto)
    {
        var user = await _userManager.FindByEmailAsync
            (loginDto.Email);
        var isValidUser = await _userManager
            .CheckPasswordAsync(_user, loginDto.Password);
        if(user == null || isValidUser == false)
        {
            return null;
        }
        var token = await GenerateToken();
        return new AuthResponseDto
        {
            Token = token,
            UserId = _user.Id
        };
    }</span></pre>
<p><span class="koboSpan" id="kobo.283.1">We inject both </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">UserManager</span></strong><span class="koboSpan" id="kobo.285.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">IConfiguration</span></strong><span class="koboSpan" id="kobo.287.1"> into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">AuthManager</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">In our login method, we attempt to retrieve the user based on the email address that was provided in </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">LoginDto</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">If we</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.292.1"> then attempt to validate that the correct password was </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.293.1">provided. </span><span class="koboSpan" id="kobo.293.2">If there is no user, or the password was incorrect, we return a null value, which the login action will use to indicate that no user was found and will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.295.1"> HTTP response.</span></p>
<p><span class="koboSpan" id="kobo.296.1">If we can validate the user, then we generate a token and then return our </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">AuthResponseDto</span></strong><span class="koboSpan" id="kobo.298.1"> object with the token and the user’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Id</span></strong><span class="koboSpan" id="kobo.300.1"> value. </span><span class="koboSpan" id="kobo.300.2">The method to generate the token is also in </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">AuthManager</span></strong><span class="koboSpan" id="kobo.302.1"> and it looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
private async Task&lt;string&gt; GenerateToken()
{
        var securitykey = new SymmetricSecurityKey
            (Encoding.UTF8.GetBytes(_configuration["
               Jwt:Key"]));
        var credentials = new SigningCredentials
            (securitykey, SecurityAlgorithms.HmacSha256);
        var roles = await _userManager.GetRolesAsync
            (_user);
        var roleClaims = roles.Select(x =&gt; new
            Claim(ClaimTypes.Role, x)).ToList();
        var userClaims = await _userManager.GetClaimsAsync
           (_user);
        var claims = new List&lt;Claim&gt;
        {
            new Claim(JwtRegisteredClaimNames.Sub,
                _user.Email),
            new Claim(JwtRegisteredClaimNames.Jti,
                Guid.NewGuid().ToString()),
            new Claim(JwtRegisteredClaimNames.Email,
                _user.Email),
            new Claim("uid", _user.Id),
        }
        .Union(userClaims).Union(roleClaims);
        var token = new JwtSecurityToken(
            issuer: _configuration[" Jwt:Issuer"],
            audience: _configuration[" Jwt:Audience"],
            claims: claims,
            expires: DateTime.Now.AddMinutes
                (Convert.ToInt32(_configuration["
                    Jwt:DurationInMinutes"])),
            signingCredentials: credentials
            );
        return new JwtSecurityTokenHandler()
            .WriteToken(token);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.304.1">In this method, we start by retrieving our security key from </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.306.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">IConfiguration</span></strong><span class="koboSpan" id="kobo.308.1"> service. </span><span class="koboSpan" id="kobo.308.2">We then encode and encrypt this key. </span><span class="koboSpan" id="kobo.308.3">We also compile the standard </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.309.1">claims that should generally be included in a token, and we can include other claim</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.310.1"> values, whether from the user’s claims in the database or custom claims that we deem necessary.</span></p>
<p><span class="koboSpan" id="kobo.311.1">We finally compile all the claims and other key values such as these:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">SigningCredentials</span></strong><span class="koboSpan" id="kobo.313.1"> with the value of the encrypted key</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.314.1">Issuer</span></em><span class="koboSpan" id="kobo.315.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.316.1">Audience</span></em><span class="koboSpan" id="kobo.317.1"> as defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">appsettings.json</span></strong></li>
<li><span class="koboSpan" id="kobo.319.1">The jti claim, which is a unique identifier, or </span><em class="italic"><span class="koboSpan" id="kobo.320.1">nonce</span></em><span class="koboSpan" id="kobo.321.1"> for the token.</span></li>
<li><span class="koboSpan" id="kobo.322.1">The expiration date and time of the token, relative to the time limit from the configuration</span></li>
</ul>
<p><span class="koboSpan" id="kobo.323.1">The result is a string full of encoded characters that is returned to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Login</span></strong><span class="koboSpan" id="kobo.325.1"> method, and this is then returned to the controller with </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">AuthResponseDto</span></strong><span class="koboSpan" id="kobo.327.1">.</span></p>
<p><span class="koboSpan" id="kobo.328.1">In order for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">AuthManager</span></strong><span class="koboSpan" id="kobo.330.1"> to be useable in our controller, we need to register the interface and implementation in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Program.cs</span></strong><span class="koboSpan" id="kobo.332.1"> file using this line:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
builder.Services.AddScoped&lt;IAuthManager, AuthManager&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.334.1">With these configurations in place, we can protect our controllers and actions with a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">[Authorize]</span></strong><span class="koboSpan" id="kobo.336.1"> attribute. </span><span class="koboSpan" id="kobo.336.2">This attribute will be placed directly above the implementation of our class or the action </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.337.1">method. </span><span class="koboSpan" id="kobo.337.2">Our API will automatically assess each incoming request for </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.338.1">an authorization header value and automatically reject requests that have no token or violate the rules that were stipulated in </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">TokenValidationParameters</span></strong><span class="koboSpan" id="kobo.340.1">.</span></p>
<p><span class="koboSpan" id="kobo.341.1">Now, when we use</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.342.1"> a tool such as </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Swagger UI</span></strong><span class="koboSpan" id="kobo.344.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">Postman</span></strong><span class="koboSpan" id="kobo.346.1">, to test our login endpoint using the test </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.347.1">user that we seeded, we will receive a token response that looks like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.348.1">
{
  "userId": "408aa945-3d84-4421-8342-7269ec64d949",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJz
  dWIiOiJhZG1pbkBsb2NhbGhvc3QuY29tIiwianRpIjoiZWU5ZjI4OD
  ItMWFkZC00ZTZkLThlZjktY2Q1ZjFlOWM3ZjMzIiwiZW1haWwiOiJhZ
  G1pbkBsb2NhbGhvc3QuY29tIiwidWlkIjoiNDA4YWE5NDUtM2Q4NC00
  NDIxLTgzNDItNzI2OWVjNjRkOTQ5IiwiZXhwIjoxNjY5ODI4MzMwLCJ
  pc3MiOiJIb3RlbExpc3RpbmdBUEkiLCJhdWQiOiJIb3RlbExpc3Rpbm
  dBUElDbGllbnQifQ.yuYUIFKPTyKKUpsVQhbS4NinGLSF5_XXPEBtAEf
  jO5E"
}</span></pre>
<p><span class="koboSpan" id="kobo.349.1">Implementing token authentication in an API is easy enough, but we are not only accounting for one API in our application. </span><span class="koboSpan" id="kobo.349.2">We have several APIs that need to be secured and preferably, one token should be accepted across all the services. </span><span class="koboSpan" id="kobo.349.3">If we continue down this path, we may end up making these configurations per service and then needing extra code to have all the other services acknowledge a token that might be issued by any other service.</span></p>
<p><span class="koboSpan" id="kobo.350.1">We need a more global solution and more suitably, a central authority of security and token generation and management for all the services in our microservices application. </span><span class="koboSpan" id="kobo.350.2">This is where we begin to explore separating the token management responsibilities from each API and placing them in one that</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.351.1"> implements </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.353.1">, which is </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">OpenID Connect</span></strong><span class="koboSpan" id="kobo.355.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">OAuth 2.0</span></strong><span class="koboSpan" id="kobo.357.1"> framework for ASP.NET Core. </span><span class="koboSpan" id="kobo.357.2">We will investigate implementing </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.359.1"> in the next section.</span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.360.1">Using IdentityServer4 to secure microservices</span></h1>
<p><span class="koboSpan" id="kobo.361.1">A key feature in any modern </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.362.1">application or suite of applications is the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">single-sign-on</span></strong><span class="koboSpan" id="kobo.364.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.365.1">SSO</span></strong><span class="koboSpan" id="kobo.366.1">). </span><span class="koboSpan" id="kobo.366.2">This feature allows us to provide our credentials once and retain an authenticated user state</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.367.1"> across several applications within the suite. </span><span class="koboSpan" id="kobo.367.2">This is a feature that can be observed in Google or Microsoft Online products, to name a few.</span></p>
<p><span class="koboSpan" id="kobo.368.1">This concept will come in</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.369.1"> handy when securing a microservices application. </span><span class="koboSpan" id="kobo.369.2">As we can see, it is not feasible to implement token-issuing logic in many APIs across an application and then attempt to coordinate access to all the APIs when it was granted to one. </span><span class="koboSpan" id="kobo.369.3">We also run the risk of requiring a user to reauthenticate each time they attempt to access a feature that requires another API to complete, and this will not make for a good user experience.</span></p>
<p><span class="koboSpan" id="kobo.370.1">With these considerations in mind, we need to use a central authority that can allow us to implement more global token issuing and validation rules given all the security considerations of our services. </span><span class="koboSpan" id="kobo.370.2">In ASP.NET Core, the best candidate for such services is </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.372.1">.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.373.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.374.1"> is an open source framework built on top of ASP.NET Core that extends the capabilities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Identity Core</span></strong><span class="koboSpan" id="kobo.376.1"> and allows developers to support </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">OpenID Connect</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">OAuth2.0</span></strong><span class="koboSpan" id="kobo.380.1"> standards in their</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.381.1"> web application security implementation. </span><span class="koboSpan" id="kobo.381.2">It is compliant with industry standards and contains out-of-the-box support for token-based authentication, SSO, and API access control in your applications. </span><span class="koboSpan" id="kobo.381.3">While it is a commercial product, a community edition is available for use by small organizations or personal projects.</span></p>
<p><span class="koboSpan" id="kobo.382.1">The recommended implementation style of </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.384.1"> would have us do the following:</span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.385.1">Create a new microservice for authentication</span></li>
<li><span class="koboSpan" id="kobo.386.1">Create a new database just for our authentication-related tables (optional)</span></li>
<li><span class="koboSpan" id="kobo.387.1">Configure scopes to be included in the token information</span></li>
<li><span class="koboSpan" id="kobo.388.1">Configure our services </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.389.1">to know which scopes are allowed to access them</span></li>
</ol>
<p><em class="italic"><span class="koboSpan" id="kobo.390.1">Figure 12.2</span></em><span class="koboSpan" id="kobo.391.1"> shows the</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.392.1"> IdentityServer authentication flow:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.393.1"><img alt="Figure 12.2 – This depicts how IdentityServer sits between a client and service and handles the flow of authentication and token exchange﻿" src="image/Figure_12.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.394.1">Figure 12.2 – This depicts how IdentityServer sits between a client and service and handles the flow of authentication and token exchange</span></p>
<p><span class="koboSpan" id="kobo.395.1">Now, let us explore creating a new service and configuring it to be our central authority for authentication and authorization in</span><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.396.1"> our microservices application.</span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.397.1">Configuring IdentityServer</span></h2>
<p><span class="koboSpan" id="kobo.398.1">Duende offers us</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.399.1"> some quick-start ASP.NET Core project templates that are easy to create in our solution. </span><span class="koboSpan" id="kobo.399.2">These quick-start templates bootstrap the minimum requirements needed to bootstrap IdentityServer functionality in an ASP.NET Core project. </span><span class="koboSpan" id="kobo.399.3">The general steps involved in setting up an IdentityServer service are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.400.1">Add Duende IdentityServer support to a standard ASP.ENT Core project</span></li>
<li><span class="koboSpan" id="kobo.401.1">Add data storage support, preferably using Entity Framework configurations</span></li>
<li><span class="koboSpan" id="kobo.402.1">Add support for ASP.NET </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Identity Core</span></strong></li>
<li><span class="koboSpan" id="kobo.404.1">Configure token issuing for client applications</span></li>
<li><span class="koboSpan" id="kobo.405.1">Secure client applications with IdentityServer</span></li>
</ul>
<p><span class="koboSpan" id="kobo.406.1">To get started, we need to use the .NET CLI and run the following command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.407.1">
dotnet new --install Duende.IdentityServer.Templates</span></pre>
<p><span class="koboSpan" id="kobo.408.1">That command will now </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.409.1">give us access to new project templates prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Duende.IdentityServer</span></strong><span class="koboSpan" id="kobo.411.1">. </span><em class="italic"><span class="koboSpan" id="kobo.412.1">Figure 12.3</span></em><span class="koboSpan" id="kobo.413.1"> depicts what we can expect to see in Visual Studio once these templates are installed.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.414.1">Figure 12.3</span></em><span class="koboSpan" id="kobo.415.1"> shows the Duende IdentityServer project templates:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.416.1"><img alt="Figure 12.3 – We get a variety of project templates that help us to speed up the IdentityServer implementation process" src="image/Figure_12.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.417.1">Figure 12.3 – We get a variety of project templates that help us to speed up the IdentityServer implementation process</span></p>
<p><span class="koboSpan" id="kobo.418.1">Using our healthcare microservices application, let us start by adding a new </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">Duende IdentityServer with Entity Framework Stores</span></strong><span class="koboSpan" id="kobo.420.1"> project to handle our authentication. </span><span class="koboSpan" id="kobo.420.2">We will call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">HealthCare.Auth</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">Now, we have a preconfigured IdentityServer project with several moving parts. </span><span class="koboSpan" id="kobo.422.3">We need to understand what the major components are and have an appreciation of how we can manipulate them for our needs. </span><span class="koboSpan" id="kobo.422.4">Let us conduct a high-level review </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.423.1">of the file and folder structure that we get out of the box:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">Wwwroot</span></strong><span class="koboSpan" id="kobo.425.1">: A standard folder that is shipped with ASP.NET Core web application templates. </span><span class="koboSpan" id="kobo.425.2">It stores static assets such as JavaScript and CSS files that are used in the website.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Migrations</span></strong><span class="koboSpan" id="kobo.427.1">: Stores preset migrations that will be used to populate the data store with supporting tables. </span><span class="koboSpan" id="kobo.427.2">This is handy, as it removes the need for us to create the databases.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Pages</span></strong><span class="koboSpan" id="kobo.429.1">: Stores default Razor pages that are used to support the UI requirements of user authentication operations. </span><span class="koboSpan" id="kobo.429.2">Out of the box, we get login, register, grant, and user data management pages.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.431.1">: The standard file that contains logging and database connection configurations. </span><span class="koboSpan" id="kobo.431.2">We can change this connection string to reflect our requirements better.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">buildschema.bat</span></strong><span class="koboSpan" id="kobo.433.1">: Contains Entity Framework commands using .NET command-line commands (</span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">dotnet ef</span></strong><span class="koboSpan" id="kobo.435.1">) that will run migration scripts that have been included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Migrations</span></strong><span class="koboSpan" id="kobo.437.1"> folder. </span><span class="koboSpan" id="kobo.437.2">We will use these commands to create our databases.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Config.cs</span></strong><span class="koboSpan" id="kobo.439.1">: This static class serves as a configuration authority. </span><span class="koboSpan" id="kobo.439.2">It is used to outline </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">IdentityResources</span></strong><span class="koboSpan" id="kobo.441.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Scopes</span></strong><span class="koboSpan" id="kobo.443.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Clients</span></strong><span class="koboSpan" id="kobo.445.1">:</span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">IdentityResources</span></strong><span class="koboSpan" id="kobo.447.1">: Map to scopes that grant access to identity-related information. </span><span class="koboSpan" id="kobo.447.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">OpenId</span></strong><span class="koboSpan" id="kobo.449.1"> method supports the expected </span><em class="italic"><span class="koboSpan" id="kobo.450.1">subject</span></em><span class="koboSpan" id="kobo.451.1"> (or </span><em class="italic"><span class="koboSpan" id="kobo.452.1">sub</span></em><span class="koboSpan" id="kobo.453.1">-claim) value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Profile</span></strong><span class="koboSpan" id="kobo.455.1"> method supports additional claim information such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">given_name</span></strong><span class="koboSpan" id="kobo.457.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">family_name</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">We can also extend the default offerings and include additional details such as the user’s </span><em class="italic"><span class="koboSpan" id="kobo.460.1">roles</span></em><span class="koboSpan" id="kobo.461.1">.</span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Scopes</span></strong><span class="koboSpan" id="kobo.463.1">: Can be used to</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.464.1"> outline permissions that can be included in the token when it is issued.</span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Clients</span></strong><span class="koboSpan" id="kobo.466.1">: Third-party clients that we expect to use IdentityServer as a token-issuing authority.</span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">HostingExtension.cs</span></strong><span class="koboSpan" id="kobo.468.1">: Contains service and middleware registration extension methods. </span><span class="koboSpan" id="kobo.468.2">These methods are then called in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Program.cs</span></strong><span class="koboSpan" id="kobo.470.1"> file during startup.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">Program.cs</span></strong><span class="koboSpan" id="kobo.472.1">: Primary program execution file in an ASP.NET Core application.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">SeedData.cs</span></strong><span class="koboSpan" id="kobo.474.1">: Contains default methods that will ensure that data migrations and seeding operations are carried out at application startup.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.475.1">IdentityServer uses two database contexts, a configuration store context and an operational store context. </span><span class="koboSpan" id="kobo.475.2">As a result, two database contexts are created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">HostingExtension.cs</span></strong><span class="koboSpan" id="kobo.477.1"> file. </span><span class="koboSpan" id="kobo.477.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">IdentityServer</span></strong><span class="koboSpan" id="kobo.479.1"> libraries are registered using the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
var isBuilder = builder.Services
                .AddIdentityServer(options =&gt;
                {
                    options.Events.RaiseErrorEvents = true;
                    options.Events.RaiseInformationEvents =
                        true;
                    options.Events.RaiseFailureEvents =
                        true;
                    options.Events.RaiseSuccessEvents =
                        true;
                     options.EmitStaticAudienceClaim =
                        true;
                })
                .AddTestUsers(TestUsers.Users)
                .AddConfigurationStore(options =&gt;
                {
                    options.ConfigureDbContext = b =&gt;
                        b.UseSqlite(connectionString,
                        dbOpts =&gt; dbOpts.MigrationsAssembly
                        (typeof(Program).Assembly
                         .FullName));
                })       .AddOperationalStore(options =&gt;
                {
                    options.ConfigureDbContext = b =&gt;
                        b.UseSqlite(connectionString,
                        dbOpts =&gt; dbOpts.MigrationsAssembly
                        (typeof(Program).Assembly.FullName
                        ));
                     options.EnableTokenCleanup = true;
                    options.RemoveConsumedTokens = true;
                });</span></pre>
<p><span class="koboSpan" id="kobo.481.1">We are adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">TestUsers</span></strong><span class="koboSpan" id="kobo.483.1"> to the</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.484.1"> configuration and then adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ConfigurationStoreDbContext</span></strong><span class="koboSpan" id="kobo.486.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">OperationalStoreDbContext</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">Other settings also govern how alerts and tokens are handled. </span><span class="koboSpan" id="kobo.488.3">The defaults are generally solid, but you may modify them based on your specific needs.</span></p>
<p><span class="koboSpan" id="kobo.489.1">The default connection string and Entity Framework Core libraries give us support for an SQLite database. </span><span class="koboSpan" id="kobo.489.2">This can be changed to whatever the desired data store may be, but we will continue with SQLite for the purpose of this exercise. </span><span class="koboSpan" id="kobo.489.3">Let us proceed to generate the database and the tables, and we need the following commands:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
Update-Database -context PersistedGrantDbContext
Update-Database -context ConfigurationDbContext</span></pre>
<p><span class="koboSpan" id="kobo.491.1">With these two commands, we </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.492.1">will see our database scaffolded with all the supporting tables. </span><span class="koboSpan" id="kobo.492.2">At this point, they are all empty and we may want to populate them with some default values based on our application. </span><span class="koboSpan" id="kobo.492.3">Let us start by configuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">IdentityResources</span></strong><span class="koboSpan" id="kobo.494.1"> that we intend to support in our tokens. </span><span class="koboSpan" id="kobo.494.2">We can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">IdentityResources</span></strong><span class="koboSpan" id="kobo.496.1"> method as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
public static IEnumerable&lt;IdentityResource&gt;
    IdentityResources =&gt;
            new IdentityResource[]
            {
            new IdentityResources.OpenId(),
            new IdentityResources.Profile(),
            new IdentityResource("roles", "User role(s)",
                new List&lt;string&gt; { "role" })
            };</span></pre>
<p><span class="koboSpan" id="kobo.498.1">We have added the list of roles to the resources list. </span><span class="koboSpan" id="kobo.498.2">Based on the claims that are being accounted for, we need to ensure that our users will contain all their expected data, as well as the list of claims that they are expected to have. </span><span class="koboSpan" id="kobo.498.3">Bear in mind that claims are the information that a client application will have via the token since it is the only way a client can track which user is online and what they can do.</span></p>
<p><span class="koboSpan" id="kobo.499.1">Now, we can refine the list of scopes that are supported by modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">ApiScopes</span></strong><span class="koboSpan" id="kobo.501.1"> method as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
public static Ienumerable&lt;ApiScope&gt; ApiScopes =&gt;
            new ApiScope[]
            {
                new ApiScope("healthcareApiUser",
                    "HealthCare API User"),
                new ApiScope("healthcareApiClient",
                    "HealthCare API Client "),
            };</span></pre>
<p><span class="koboSpan" id="kobo.503.1">Here, we are supporting two types of authentication scopes. </span><span class="koboSpan" id="kobo.503.2">These scopes will be used to support authentication for two different scenarios: client and user. </span><span class="koboSpan" id="kobo.503.3">Client authentication represents an unsupervised attempt to gain access to a resource, usually by another program or API. </span><span class="koboSpan" id="kobo.503.4">Client authentication means that a user will authenticate using credentials.</span></p>
<p><span class="koboSpan" id="kobo.504.1">This brings us to the next configuration, which is for the clients. </span><span class="koboSpan" id="kobo.504.2">The term client is used a bit loosely since any entity that attempts to gain authorization from IdentityServer is seen as a client. </span><span class="koboSpan" id="kobo.504.3">The word </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.505.1">client can also refer to a program that is attempting to gain authorization, such as a daemon or background service. </span><span class="koboSpan" id="kobo.505.2">Another scenario is when a user attempts to carry out an operation that requires them to authenticate against IdentityServer. </span><span class="koboSpan" id="kobo.505.3">We add support for our clients as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
public static IEnumerable&lt;Client&gt; Clients =&gt;
            new Client[]
            {
            // m2m client credentials flow client
            new Client
            {
                ClientId = "m2m.client",
                ClientName = "Client Credentials Client",
                AllowedGrantTypes = GrantTypes
                    .ClientCredentials,
                ClientSecrets = { new Secret("511536EF-
                   F270-4058-80CA-1C89C192F69A ".Sha256())
                       },
                AllowedScopes = { "healthcareApiClient" }
            },
            // interactive client using code flow + pkce
            new Client
            {
                ClientId = "interactive",
                ClientSecrets = { new Secret("49C1A7E1-
                  0C79-4A89-A3D6-A37998FB86B0".Sha256()) },
                AllowedGrantTypes = GrantTypes.Code,
                RedirectUris = {
                    "https://localhost:5001/signin-oidc" },
                FrontChannelLogoutUri =
                    "https://localhost:5001/signout-oidc",
                PostLogoutRedirectUris = {
                   "https://localhost:5001/signout-
                      callback-oidc" },
                AllowOfflineAccess = true,
                AllowedScopes = { "openid", "profile",
                    "healthcareApiUser", "roles" }
            },
            };</span></pre>
<p><span class="koboSpan" id="kobo.507.1">Now, we have defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">ClientId</span></strong><span class="koboSpan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">ClientSecret</span></strong><span class="koboSpan" id="kobo.511.1"> values for our clients. </span><span class="koboSpan" id="kobo.511.2">By defining several clients, we can support the applications that we expect to support at a more granular level, and we can define specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">AllowedScopes</span></strong><span class="koboSpan" id="kobo.513.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">AllowedGrantTypes</span></strong><span class="koboSpan" id="kobo.515.1"> values. </span><span class="koboSpan" id="kobo.515.2">In this example, we have defined a client for an API, which can represent a microservice in our application that might need to authenticate with the authentication service. </span><span class="koboSpan" id="kobo.515.3">This type of authentication generally occurs without user interaction. </span><span class="koboSpan" id="kobo.515.4">We also define</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.516.1"> a web client, which could be a user-facing application. </span><span class="koboSpan" id="kobo.516.2">This presents the unique challenge where we configure sign-in and sign-out URLs to redirect our users during the authentication or logout flow. </span><span class="koboSpan" id="kobo.516.3">We also go on to state which scopes will be accessible via the generated token. </span><span class="koboSpan" id="kobo.516.4">We have added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">roles</span></strong><span class="koboSpan" id="kobo.518.1"> value to the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">AllowedScopes</span></strong><span class="koboSpan" id="kobo.520.1"> since we want that information to be included when a user authenticates.</span></p>
<p><span class="koboSpan" id="kobo.521.1">Now that we have our configuration values outlined, let us add a command-line argument for seeding to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">launchSettings.json</span></strong><span class="koboSpan" id="kobo.523.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">Properties</span></strong><span class="koboSpan" id="kobo.525.1"> folder. </span><span class="koboSpan" id="kobo.525.2">The file’s contents will now look as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
"profiles": {
    "SelfHost": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:5001",
      "commandLineArgs": "/seed"
    }</span></pre>
<p><span class="koboSpan" id="kobo.527.1">If we run this application after making this adjustment, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">if (args.Contains("/seed"))</span></strong><span class="koboSpan" id="kobo.529.1"> statement will evaluate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">true</span></strong><span class="koboSpan" id="kobo.531.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Program.cs</span></strong><span class="koboSpan" id="kobo.533.1"> and this will trigger the database seeding activity as outlined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">SeedData.cs</span></strong><span class="koboSpan" id="kobo.535.1"> file. </span><span class="koboSpan" id="kobo.535.2">After the first run, you may remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">"commandLineArgs": "/seed"</span></strong><span class="koboSpan" id="kobo.537.1"> section from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">launchSettings.json</span></strong><span class="koboSpan" id="kobo.539.1"> file. </span><span class="koboSpan" id="kobo.539.2">Running it again will launch a browser application with a page similar to what is depicted in </span><em class="italic"><span class="koboSpan" id="kobo.540.1">Figure 12.4</span></em><span class="koboSpan" id="kobo.541.1">. </span><span class="koboSpan" id="kobo.541.2">This is the home landing page and shows that our IdentityServer is up and running.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.542.1">Figure 12.4</span></em><span class="koboSpan" id="kobo.543.1"> shows the</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.544.1"> Duende IdentityServer landing page:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.545.1"><img alt="Figure 12.4 – This landing page shows us that our IdentityServer application is in a running state" src="image/Figure_12.4_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.546.1">Figure 12.4 – This landing page shows us that our IdentityServer application is in a running state</span></p>
<p><span class="koboSpan" id="kobo.547.1">You can find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">TestUsers.cs</span></strong><span class="koboSpan" id="kobo.549.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Pages</span></strong><span class="koboSpan" id="kobo.551.1"> folder. </span><span class="koboSpan" id="kobo.551.2">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">alice</span></strong><span class="koboSpan" id="kobo.553.1"> as both the username and password for a quick test. </span><span class="koboSpan" id="kobo.553.2">You may proceed to use the credentials that have been provided in your instance of that file. </span><span class="koboSpan" id="kobo.553.3">We can then proceed to test a login operation using one of the test users that was added to the context by default, and we will be required to authenticate when attempting to access most of these links.</span></p>
<p><span class="koboSpan" id="kobo.554.1">The most important link to discuss is the one that leads to the discovery document. </span><span class="koboSpan" id="kobo.554.2">Most OAuth2.0 and OpenID Connect service providers have a concept of a discovery document, which outlines the built-in routes in the API, supported claims and token types, and other key bits of information that make it easier for us to know and access these intricate bits of information from IdentityServer. </span><span class="koboSpan" id="kobo.554.3">Some of the key information available is as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
{
    "issuer": "https://localhost:5001",
    "jwks_uri": "
        https://localhost:5001/.well-known/openid-
        configuration/jwks",
    "authorization_endpoint": "
        https://localhost:5001/
        connect/authorize",
    "token_endpoint": "
        https://localhost:5001/connect/
        token",
    "userinfo_endpoint": "
        https://localhost:5001/connect/
        userinfo",
    "end_session_endpoint": "
        https://localhost:5001/connect
        /endsession",
    "check_session_iframe": "
        https://localhost:5001/connect
        /checksession",
    "revocation_endpoint": "
        https://localhost:5001/connect
       /revocation",
    "introspection_endpoint": "
        https://localhost:5001/
        connect/introspect",
    "device_authorization_endpoint": "
        https://localhost:5001/connect/deviceauthorization",
    "backchannel_authentication_endpoint":
        "https://localhost:5001/connect/ciba",
   ...
</span><span class="koboSpan" id="kobo.555.2">    "scopes_supported": [
        "openid",
        "profile",
        "roles",
        "healthcareApiUser",
        "healthcareApiClient",
        "offline_access"
    ],
...
</span><span class="koboSpan" id="kobo.555.3">}</span></pre>
<p><span class="koboSpan" id="kobo.556.1">We have a clear outline of the various endpoints that are now available to us for the different commonly access operations.</span></p>
<p><span class="koboSpan" id="kobo.557.1">Next, we can test our </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">HealthCare.Auth</span></strong><span class="koboSpan" id="kobo.559.1"> application and validate that we can retrieve a valid</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.560.1"> token. </span><span class="koboSpan" id="kobo.560.2">Let us attempt to retrieve a token using our machine client credentials. </span><span class="koboSpan" id="kobo.560.3">We will use an API testing tool called </span><em class="italic"><span class="koboSpan" id="kobo.561.1">Postman</span></em><span class="koboSpan" id="kobo.562.1"> to send the request. </span><em class="italic"><span class="koboSpan" id="kobo.563.1">Figure 12.5</span></em><span class="koboSpan" id="kobo.564.1"> shows the user interface in Postman and the information that needs to be added accordingly.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.565.1"><img alt="Figure 12.5 – Here, we add the client ID, client secret, and token URL values in Postman in order to retrieve a bearer token" src="image/Figure_12.5_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.566.1">Figure 12.5 – Here, we add the client ID, client secret, and token URL values in Postman in order to retrieve a bearer token</span></p>
<p><span class="koboSpan" id="kobo.567.1">Once we have added the required values, we proceed to click on the </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">Get New Access Token</span></strong><span class="koboSpan" id="kobo.569.1"> button. </span><span class="koboSpan" id="kobo.569.2">This will send a request to our IdentityServer, which will validate the request and return a </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.570.1">token if the information is found in the database.</span></p>
<p><span class="koboSpan" id="kobo.571.1">Our token response automatically includes some additional information such as the type of token, the expiry timestamp, and the scope that is included. </span><span class="koboSpan" id="kobo.571.2">Our token is generated with several data points by default. </span><span class="koboSpan" id="kobo.571.3">Since IdentityServer follows the </span><em class="italic"><span class="koboSpan" id="kobo.572.1">OAuth</span></em><span class="koboSpan" id="kobo.573.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.574.1">OpenID Connect</span></em><span class="koboSpan" id="kobo.575.1"> standards, we can be sure that we do not need to include basic claims such as </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">sub</span></strong><span class="koboSpan" id="kobo.577.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">exp</span></strong><span class="koboSpan" id="kobo.579.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.580.1">jti</span></strong><span class="koboSpan" id="kobo.581.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">iss</span></strong><span class="koboSpan" id="kobo.583.1">, to name a few.</span></p>
<p><span class="koboSpan" id="kobo.584.1">The values that get included are the scope and client ID. </span><span class="koboSpan" id="kobo.584.2">These are determined by the configurations that we have per client and the information that is presented by the authenticating user. </span><span class="koboSpan" id="kobo.584.3">In this example, we are accommodating APIs that only authenticated users should be able to access.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.585.1">Figure 12.6</span></em><span class="koboSpan" id="kobo.586.1"> shows the payload of the token:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.587.1"><img alt="Figure 12.6 – Our token automatically contains some claims that we would have entered manually if it was generated without IdentityServer" src="image/Figure_12.6_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.588.1">Figure 12.6 – Our token automatically contains some claims that we would have entered manually if it was generated without IdentityServer</span></p>
<p><span class="koboSpan" id="kobo.589.1">Let us save our bearer </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.590.1">token value that was returned, as we will use it in our next section. </span><span class="koboSpan" id="kobo.590.2">Now let us review the changes that are necessary to protect an API using IdentityServer.</span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.591.1">Securing an API using IdentityServer</span></h2>
<p><span class="koboSpan" id="kobo.592.1">We now have the peculiar </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.593.1">challenge of implementing the best possible security solution across our microservices application. </span><span class="koboSpan" id="kobo.593.2">We have several services that need to be secured and based on the architecture pattern you have implemented, you might also have a gateway that is routing traffic:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.594.1">Securing each service</span></strong><span class="koboSpan" id="kobo.595.1">: Securing each service seems simple enough, but we must bear in mind that each service has different requirements and might need to be seen as a different client for each request. </span><span class="koboSpan" id="kobo.595.2">This can lead to a maintenance nightmare when trying to maintain all the scopes and clients, relative to each service. </span><span class="koboSpan" id="kobo.595.3">We then need to navigate how services will communicate as well since a token will be needed for service-to-service calls. </span><span class="koboSpan" id="kobo.595.4">One service’s claims and scopes might not be sufficient for</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.596.1"> this communication. </span><span class="koboSpan" id="kobo.596.2">This might lead to a user having to authenticate several times when accessing different features that rely on different services.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.597.1">Secured API gateway</span></strong><span class="koboSpan" id="kobo.598.1">: Securing our API gateway makes the most sense. </span><span class="koboSpan" id="kobo.598.2">If we implement a gateway that all apps will communicate with, we allow the gateway to orchestrate the authentication flow for the client and then manage the token to be shared between service calls. </span><span class="koboSpan" id="kobo.598.3">This support can be implemented in a custom-written API gateway and is supported by most if not all third-party gateway service providers. </span><span class="koboSpan" id="kobo.598.4">This is especially useful when combined with the </span><em class="italic"><span class="koboSpan" id="kobo.599.1">Backend For Frontend</span></em><span class="koboSpan" id="kobo.600.1"> pattern.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.601.1">We have already seen how we can add JWT bearer protection to our API using functionality from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Identity Core</span></strong><span class="koboSpan" id="kobo.603.1"> library. </span><span class="koboSpan" id="kobo.603.2">We can leverage some of these configurations and override the native functionality with support for IdentityServer. </span><span class="koboSpan" id="kobo.603.3">Let us explore how we can secure our </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Patients</span></strong><span class="koboSpan" id="kobo.605.1"> API using IdentityServer. </span><span class="koboSpan" id="kobo.605.2">We start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Microsoft.AspNetCore.Authentication.JwtBearer</span></strong><span class="koboSpan" id="kobo.607.1"> library using the NuGet package manager:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
Install-Package Microsoft.AspNetCore.Authentication
  .JwtBearer</span></pre>
<p><span class="koboSpan" id="kobo.609.1">We then modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Program.cs</span></strong><span class="koboSpan" id="kobo.611.1"> file and add the following configuration:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
builder.Services.AddAuthentication(JwtBearerDefaults
     .AuthenticationScheme)
            .AddJwtBearer(options =&gt;
            {
                // base-address of your identityserver
                options.Authority =
                    "https://localhost:5001/";
                // audience is optional, make sure you read
                   the following paragraphs
                // to understand your options
                options.TokenValidationParameters
                    .ValidateAudience = false;
                // it's recommended to check the type
                header to avoid "JWT confusion" attacks
                options.TokenValidationParameters
                    .ValidTypes = new[] { "at+jwt" };
            });</span></pre>
<p><span class="koboSpan" id="kobo.613.1">We will also need to register the authentication middleware in our application with the following line. </span><span class="koboSpan" id="kobo.613.2">We should </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.614.1">ensure that we place this registration above the authorization middleware:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
app.UseAuthentication();
app.UseAuthorization();</span></pre>
<p><span class="koboSpan" id="kobo.616.1">This configuration will dictate to our service that we are now to refer them to the URL in the </span><em class="italic"><span class="koboSpan" id="kobo.617.1">Authority</span></em><span class="koboSpan" id="kobo.618.1"> option, for authentication instructions. </span><span class="koboSpan" id="kobo.618.2">We can now protect our API by implementing a global authorization policy. </span><span class="koboSpan" id="kobo.618.3">This will ensure that no endpoint can be accessed without a valid bearer token that has been issued by our IdentityServer:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.619.1">
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("RequireAuth", policy =&gt;
    {
        policy.RequireAuthenticatedUser();
    });
});</span></pre>
<p><span class="koboSpan" id="kobo.620.1">We modify the controller’s middleware as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
app.MapControllers().RequireAuthorization("RequireAuth");</span></pre>
<p><span class="koboSpan" id="kobo.622.1">Now, any attempt to interact with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Patients</span></strong><span class="koboSpan" id="kobo.624.1"> API endpoint will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">401Unauthorized</span></strong><span class="koboSpan" id="kobo.626.1"> HTTP response. </span><span class="koboSpan" id="kobo.626.2">The API is now expecting us to provide the bearer token in the authorization header value. </span><span class="koboSpan" id="kobo.626.3">In </span><em class="italic"><span class="koboSpan" id="kobo.627.1">Figure 12.7</span></em><span class="koboSpan" id="kobo.628.1">, we see how we can make authorized API calls to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Patients</span></strong><span class="koboSpan" id="kobo.630.1"> API endpoints using the bearer token that was retrieved in the previous </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.631.1">section from our machine client credentials authentication.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.632.1">Figure 12.7</span></em><span class="koboSpan" id="kobo.633.1"> shows the authorized API request:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.634.1"><img alt="Figure 12.7 – Our bearer token is included in the request to our protected service and we can comfortably access endpoints" src="image/Figure_12.7_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.635.1">Figure 12.7 – Our bearer token is included in the request to our protected service and we can comfortably access endpoints</span></p>
<p><span class="koboSpan" id="kobo.636.1">Now, we need to configure our API to force authentication and rely on the </span><em class="italic"><span class="koboSpan" id="kobo.637.1">HealthCare.Auth</span></em><span class="koboSpan" id="kobo.638.1"> service accordingly. </span><span class="koboSpan" id="kobo.638.2">If we reuse our appointments API, we can make a few modifications to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Program.cs</span></strong><span class="koboSpan" id="kobo.640.1"> file and introduce reliance on our authentication service.</span></p>
<p><span class="koboSpan" id="kobo.641.1">We begin by modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">builder.Services.AddAuthenctication()</span></strong><span class="koboSpan" id="kobo.643.1"> registration as</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.644.1"> follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
builder.Services.AddAuthentication(JwtBearerDefaults
    .AuthenticationScheme)
   .AddJwtBearer("Bearer", opt =&gt;
   {
       opt.RequireHttpsMetadata = false;</span></pre>
<p><span class="koboSpan" id="kobo.646.1">Now that we have secured our API directly, we can explore how we can manage this new security requirement in our API gateway. </span><span class="koboSpan" id="kobo.646.2">Recall that we have implemented aggregation methods and we will expect client applications to access the endpoints through the gateway.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.647.1">Securing the Ocelot API gateway with IdentityServer</span></h2>
<p><span class="koboSpan" id="kobo.648.1">Now, when we access an </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.649.1">API endpoint that is protected via IdentityServer, we need to retrofit our gateway service to support authentication </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.650.1">and forwarding of the credentials to the target API. </span><span class="koboSpan" id="kobo.650.2">We start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">Microsoft.AspNetCore.Authentication.JwtBearer</span></strong><span class="koboSpan" id="kobo.652.1"> library using the NuGet package manager:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
Install-Package Microsoft.AspNetCore.Authentication
  .JwtBearer</span></pre>
<p><span class="koboSpan" id="kobo.654.1">We then modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">ocelot.json</span></strong><span class="koboSpan" id="kobo.656.1"> file with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">AuthenticationOptions</span></strong><span class="koboSpan" id="kobo.658.1"> section. </span><span class="koboSpan" id="kobo.658.2">Now, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">GET</span></strong><span class="koboSpan" id="kobo.660.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Patients</span></strong><span class="koboSpan" id="kobo.662.1"> API is as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
{
  "DownstreamPathTemplate": "/api/Patients",
  ...
</span><span class="koboSpan" id="kobo.663.2">  "AuthenticationOptions": {
        "AuthenticationProviderKey":
            "IdentityServerApiKey",
        "AllowedScopes": []
      },
…
},</span></pre>
<p><span class="koboSpan" id="kobo.664.1">Now, we modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Program.cs</span></strong><span class="koboSpan" id="kobo.666.1"> file and register our authentication service to use JWT bearer </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.667.1">authentication, similar to what we did on </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.668.1">the service itself:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
builder.Services
    .AddAuthentication()
    .AddJwtBearer(authenticationProviderKey, x =&gt;
    {
        x.Authority = "https://localhost:5001";
        x.TokenValidationParameters = new
            TokenValidationParameters
        {
            ValidateAudience = false
        };
    });</span></pre>
<p><span class="koboSpan" id="kobo.670.1">Now, we have secured our gateway using IdentityServer. </span><span class="koboSpan" id="kobo.670.2">This, once again, might be a better security solution for our suite of microservices that will be accessed through the gateway, and it can help us to centralize access to our services.</span></p>
<p><span class="koboSpan" id="kobo.671.1">Now that we have explored API security at length, let us summarize the concepts that we have explored.</span></p>
<p><span class="koboSpan" id="kobo.672.1">With this simple change, we no longer need to concern our appointments API with the inclusion of authentication tables in its database, or complex JWT bearer compilation logic. </span><span class="koboSpan" id="kobo.672.2">We simply point the service to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Authority</span></strong><span class="koboSpan" id="kobo.674.1">, which is the authentication service, and include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Audience</span></strong><span class="koboSpan" id="kobo.676.1"> value so that it can identify itself to the authentication service.</span></p>
<p><span class="koboSpan" id="kobo.677.1">With this configuration, a user will need to provide a token such as the one we retrieved to make any calls to our </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.678.1">API. </span><span class="koboSpan" id="kobo.678.2">Any other token or lack thereof will be met with a </span><em class="italic"><span class="koboSpan" id="kobo.679.1">401 Unauthorized</span></em><span class="koboSpan" id="kobo.680.1"> HTTP response.</span></p>
<p><span class="koboSpan" id="kobo.681.1">Configuring IdentityServer is not the most difficult task, but it can become complex when attempting to account for several scenarios, configurations, and clients. </span><span class="koboSpan" id="kobo.681.2">Several considerations can be made </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.682.1">along the way, and we will discuss them next.</span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.683.1">Additional API security considerations</span></h2>
<p><span class="koboSpan" id="kobo.684.1">We have configured an</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.685.1"> authentication service to secure our microservices application. </span><span class="koboSpan" id="kobo.685.2">Several scenarios can govern how each service is protected by this central authority and they all have their pros and cons.</span></p>
<p><span class="koboSpan" id="kobo.686.1">What we also need to consider is that we want the entire responsibility of hosting and maintaining our own </span><em class="italic"><span class="koboSpan" id="kobo.687.1">OAuth</span></em><span class="koboSpan" id="kobo.688.1"> service. </span><span class="koboSpan" id="kobo.688.2">There are third-party services such as </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">Auth0</span></strong><span class="koboSpan" id="kobo.690.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">Azure Active Directory</span></strong><span class="koboSpan" id="kobo.692.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">Okta</span></strong><span class="koboSpan" id="kobo.694.1">, to name a few. </span><span class="koboSpan" id="kobo.694.2">They all </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.695.1">provide a hosted service that will abstract our</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.696.1"> need to stage and maintain our services, and we can simply subscribe to their services and secure our application with a few configurations.</span></p>
<p><span class="koboSpan" id="kobo.697.1">This option takes advantage of </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">Software-as-a-Service</span></strong><span class="koboSpan" id="kobo.699.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.700.1">SaaS</span></strong><span class="koboSpan" id="kobo.701.1">) offerings that greatly reduce our infrastructure needs and increase the reliability, stability, and future-proofing of our application’s security.</span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.702.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.703.1">In this chapter, we have reviewed the current industry standard for API security. </span><span class="koboSpan" id="kobo.703.2">Using bearer tokens, we can support authorized API access attempts without maintaining state or sessions.</span></p>
<p><span class="koboSpan" id="kobo.704.1">In a service-oriented architecture, a client app can come in several forms, whether a web application, a mobile application, or even a smart television. </span><span class="koboSpan" id="kobo.704.2">We cannot account for the type of device in use and our API does not keep track of the applications connecting to it. </span><span class="koboSpan" id="kobo.704.3">For this reason, when a user logs in and is verified against our user information data stores, we select the most important bit of information and compile them into a token.</span></p>
<p><span class="koboSpan" id="kobo.705.1">This token is called a bearer token and is an encoded string that should contain enough information about a user that our API can determine the user with whom the token is associated and their privileges in our system.</span></p>
<p><span class="koboSpan" id="kobo.706.1">Ultimately, attempting to secure each API using this method can lead to a lot of disconnection and complexity, so we introduce a centralized authentication management platform such as IdentityServer. </span><span class="koboSpan" id="kobo.706.2">This central authority will secure all the APIs using common configurations, and issue tokens based on those global configurations. </span><span class="koboSpan" id="kobo.706.3">Now, we can use these tokens once and access several services without needing to re-authenticate.</span></p>
<p><span class="koboSpan" id="kobo.707.1">Security should never be neglected in any application and when it is well implemented, we can strike a balance between security and usability in our application.</span></p>
<p><span class="koboSpan" id="kobo.708.1">Now that we have explored security for our microservices application, we will review how we can leverage </span><em class="italic"><span class="koboSpan" id="kobo.709.1">containers</span></em><span class="koboSpan" id="kobo.710.1"> to deploy our microservices application in the next chapter.</span></p>
</div>
</body></html>