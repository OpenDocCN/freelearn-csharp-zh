<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor187" class="pcalibre1 pcalibre calibre6"/>10</h1>
<h1 id="_idParaDest-179" class="calibre5"><a id="_idTextAnchor188" class="pcalibre1 pcalibre calibre6"/>Creating a 3D First Person Shooter (FPS)</h1>
<p class="calibre3">In <a href="B18347_09.xhtml#_idTextAnchor169" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, we created a global event system, a quest system, and components that were all loosely coupled and worked together to provide versatile quests for the player to complete. With the systems in place, we made quick work of being able to implement collecting items to notify, update, and satisfy a specific quest requirement. The components created are extensible and reusable for creating any number of quests.</p>
<p class="calibre3">We then imported and fixed the rendering for the <strong class="bold">Universal Render Pipeline</strong> (<strong class="bold">URP</strong>), and<a id="_idIndexMarker984" class="pcalibre1 pcalibre calibre6"/> refactored the code of a third-party sliding puzzle asset as an example of how to leverage the Unity Asset Store for our games. We finished by setting up the puzzle in the scene with new artwork and triggering an event when the puzzle was solved that ended the level with a fade-to-black sequence.</p>
<p class="calibre3">This chapter will pick up right where the previous 2D adventure game left off by introducing a 3D FPS game for the habitat interior we just entered.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:<a id="_idTextAnchor189" class="pcalibre1 pcalibre calibre6"/></p>
<ul class="calibre17">
<li class="calibre15">Designing for 3D while continuing the GDD</li>
<li class="calibre15">Greyboxing a 3D environment with ProBuilder and Prefabs</li>
<li class="calibre15">Creating an FPS player character with the Unity Starter Asset</li>
<li class="calibre15">Refactoring environment interactions to 3D API methods</li>
<li class="calibre15">Code reuse in practice – Adding premade components to the player</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to design and build a greybox 3D environment from a set of modular parts we’ll make right within the Unity Editor, quickly add an FPS character controller, and reuse and refactor 2D code for a 3D project.</p>
<h1 id="_idParaDest-180" class="calibre5">Technical requirements<a id="_idTextAnchor190" class="pcalibre1 pcalibre calibre6"/></h1>
<p class="calibre3">You can download the complete project on GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-181" class="calibre5"><a id="_idTextAnchor191" class="pcalibre1 pcalibre calibre6"/>Designing for 3D while continuing the GDD</h1>
<p class="calibre3">Level design <a id="_idIndexMarker985" class="pcalibre1 pcalibre calibre6"/>for a 2D game is more straightforward<a id="_idIndexMarker986" class="pcalibre1 pcalibre calibre6"/> because players navigate in only two dimensions. In contrast, 3D games involve that extra dimension – depth – in gameplay, contributing to more complex level design. In 2D, the screen space is represented by the <strong class="bold">X</strong> and <strong class="bold">Y</strong> coordinates. In 3D, the floor plane is represented by <strong class="bold">X</strong> and <strong class="bold">Z</strong> (depth), with <strong class="bold">Y</strong> still being used for the vertical axis – Unity’s 3D coordinate system is defined<a id="_idIndexMarker987" class="pcalibre1 pcalibre calibre6"/> as a <strong class="bold">Y-up environment</strong>.</p>
<div><div><img alt="Figure 10.1 – 2D versus 3D coordinates" src="img/B18347_10_1.jpg" class="calibre111"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.1 – 2D versus 3D coordinates</p>
<p class="calibre3">As we already know from our previous 2D work, the Z axis still exists but is represented straight on with the camera – either in the front or in the back – and only applies in some cases when layering objects in the scene.</p>
<p class="calibre3">Moving on, we’ll attempt to simplify the 3D design process using a modular approach, but it all starts with the game design again. Let’s review some gameplay changes to the GDD for a new 3D FPS project introduced in this chapter.</p>
<p class="calibre3">Now is our chance to update our blueprint of gameplay mechanics to reflect our evolved vision of the <em class="italic">Outer World</em> 3D FPS game. We can then ensure that all aspects of the production of the habitat’s interior-level design will align with this new experience.</p>
<p class="calibre3">In <em class="italic">Table 10.1</em>, you can see<a id="_idIndexMarker988" class="pcalibre1 pcalibre calibre6"/> that <a id="_idIndexMarker989" class="pcalibre1 pcalibre calibre6"/>I have updated the relevant gameplay sections:</p>
<table class="no-table-style" id="table001-6">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Describe the gameplay, the core loop, and </strong><strong class="bold">the progression</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Make your way to the central control system, peeking around corners and down long corridors to restore operations while dealing with a damaged power suit that must be recharged along the way. Beware of lingering infected maintenance robots!</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is the core game mechanic for the </strong><strong class="bold">collection game?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">With a first-person perspective, the player will navigate the environment, recharge their power suit (health), and shoot the infected maintenance robots.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What systems need to be implemented to support the </strong><strong class="bold">game mechanics?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The player movement, a weapon with ammo reloading and shooting capabilities, and a health system with pickup (recharging) and damage capabilities.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 10.1 – Updated relevant gameplay sections</p>
<p class="calibre3">Next, we’ll need to update the player character and enemy backstories to be relevant, as described in <em class="italic">Table 10.2</em>:</p>
<table class="no-table-style" id="table002-3">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is the main character’s </strong><strong class="bold">challenge structure?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The habitat station’s environmental controls are offline, and the player character’s power suit has lost the ability to sustain the player due to damage.</p>
<p class="calibre3">The player must seek <em class="italic">recharges</em> in the station to survive the journey to the central system while battling infected maintenance robots.</p>
<p class="calibre3">The player will confront the evil plant entity boss.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Enemy B:</strong></p>
<p class="calibre3"><strong class="bold">Describe the second enemy in the game and how they drive the story. Who is </strong><strong class="bold">this enemy?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Type: Maintenance Robot Wheeled</p>
<p class="calibre3">Backstory: Robot deployed on pre-colonization missions for habitat maintenance and support.</p>
<p class="calibre3">Goals: Maintenance, personnel support</p>
<p class="calibre3">Skills: Quick charging</p>
<p class="calibre3">Weaknesses: Limited mobility</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Boss: </strong><strong class="bold">Viridian Overmind</strong></p>
<p class="calibre3"><strong class="bold">Describe the level boss and how they drive </strong><strong class="bold">the story</strong></p>
<p class="calibre3"><strong class="bold">Who is </strong><strong class="bold">this boss?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">A sentient plant entity infecting the central control system of the habitat station compels the player to confront the evil alien.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 10.2 – Updated character and enemy bios</p>
<p class="calibre3">This is a new<a id="_idIndexMarker990" class="pcalibre1 pcalibre calibre6"/> game<a id="_idIndexMarker991" class="pcalibre1 pcalibre calibre6"/> level, so it will also need to be defined:</p>
<table class="no-table-style" id="table003-1">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Describe the environment the game takes place in. What does it look like, who inhabits it, and what are the points </strong><strong class="bold">of interest?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The game occurs within a habitation station on a remote planet’s surface. The habitat is deceptively large with its many small connecting corridors. There are maintenance robots that roam the station carrying out their autonomous duties. Recharge pickups are conveniently placed throughout the station at the corridor intersections.</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Describe the </strong><strong class="bold">game level(s)</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The game level is a modular constructed habitat station interior with many corridors and rooms serving different purposes and a central control system room.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 10.3 – Environment and level definitions</p>
<p class="calibre3">And lastly, we’ll need to update the input control scheme so that it’s relevant for functioning in a 3D space:</p>
<table class="no-table-style" id="table004-1">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Define the input/control </strong><strong class="bold">methods actions</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Keyboard: <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, <em class="italic">D</em> keys to move, mouse to aim, the left mouse button to shoot the primary weapon, and the <em class="italic">E</em> key to interact.</p>
<p class="calibre3">Game controller: Left-stick/D-pad to move, right-stick to aim, right-trigger or <em class="italic">Y</em> to shoot, and button <em class="italic">A</em> to interact.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 10.4 – Updated input/control methods actions</p>
<p class="calibre3">With these GDD revisions to the <em class="italic">Outer World</em> game’s conceptual design and gameplay mechanics for 3D, we <a id="_idIndexMarker992" class="pcalibre1 pcalibre calibre6"/>have<a id="_idIndexMarker993" class="pcalibre1 pcalibre calibre6"/> a foundation for transitioning into the level design phase – ensuring that the level will align with our overall concept and provide the intended player experience.</p>
<h1 id="_idParaDest-182" class="calibre5"><a id="_idTextAnchor192" class="pcalibre1 pcalibre calibre6"/>Greyboxing a 3D environment with ProBuilder and Prefabs</h1>
<p class="calibre3">Creating a 3D<a id="_idIndexMarker994" class="pcalibre1 pcalibre calibre6"/> environment<a id="_idIndexMarker995" class="pcalibre1 pcalibre calibre6"/> is similar to creating a 2D environment <a id="_idIndexMarker996" class="pcalibre1 pcalibre calibre6"/>in some ways since you still need to place things meaningfully for the gameplay. Of course, we must consider the additional dimension and use 3D models instead of 2D image assets.</p>
<p class="calibre3">In Unity Hub, please create a new <code>Unity 2022</code> project and use the <strong class="bold">3D (URP) Core</strong> template as our starting point. We’ll continue to use the URP renderer from the previous 2D projects. This is still an excellent choice for 3D since it will be performant on the broadest range of devices, including mobile platforms. With that, even though it sounds like we may be robbing ourselves of some capability, we’re not, since URP is also very capable of producing beautiful 3D visuals.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">URP overview: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml</a></p>
<p class="calibre3">We will speed up the design process by using a technique<a id="_idIndexMarker997" class="pcalibre1 pcalibre calibre6"/> called <strong class="bold">greyboxing</strong> (which may also be referred<a id="_idIndexMarker998" class="pcalibre1 pcalibre calibre6"/> to as <strong class="bold">blockout</strong>) – this will allow us to rough in the level design using simple geometry without getting distracted by details. We’ll also be able to playtest the level early on and identify any potential issues with the player navigating the environment<a id="_idIndexMarker999" class="pcalibre1 pcalibre calibre6"/> and<a id="_idIndexMarker1000" class="pcalibre1 pcalibre calibre6"/> working out general<a id="_idIndexMarker1001" class="pcalibre1 pcalibre calibre6"/> playability issues.</p>
<p class="calibre3">Let’s start by looking at what we’ll be making.</p>
<h2 id="_idParaDest-183" class="calibre8"><a id="_idTextAnchor193" class="pcalibre1 pcalibre calibre6"/>Habitat interior level</h2>
<p class="calibre3">Like in earlier <a id="_idIndexMarker1002" class="pcalibre1 pcalibre calibre6"/>chapters, I’ll provide an example-level design (subjecting you again to one of my sketches, although a bit more refined this time) that you can follow along with. The level map includes an entry point – where we entered the habitat station at the end of the previous 2D adventure game – and leads to a central control system where we’ll confront the evil plant entity!</p>
<div><div><img alt="Figure 10.2 – Habitat interior level map sketch" src="img/B18347_10_2.jpg" class="calibre112"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Habitat interior level map sketch</p>
<p class="calibre3">We’ll be using a modular approach to designing the level, so following this setup, we’ll be able to adapt quickly to different layouts. As you can see, I’ve added a legend that identifies modules intended to be used – these will be our reusable components serving as the broad strokes to construct and build the level out with. Locations for <em class="italic">recharge</em> pickups (green), the starting position for the player (<strong class="bold">P</strong>), and the location of the boss character are also defined.</p>
<p class="calibre3">Great! Now we have an actionable plan. Next, we can start creating the required 3D modules for our greyboxing kit. If you’re thinking, but I have no 3D modeler/artist skills! Don’t worry, as<a id="_idIndexMarker1003" class="pcalibre1 pcalibre calibre6"/> this will be a basic introduction – I also believe a game developer should have this as the minimum amount of 3D knowledge.</p>
<h2 id="_idParaDest-184" class="calibre8"><a id="_idTextAnchor194" class="pcalibre1 pcalibre calibre6"/>Installing ProBuilder</h2>
<p class="calibre3">Unity provides more <a id="_idIndexMarker1004" class="pcalibre1 pcalibre calibre6"/>built-in tooling that we can use for our greyboxing process in the form of a simple 3D modeling feature called ProBuilder. Like most of Unity’s features, we’ll install ProBuilder from <strong class="bold">Package Manager</strong>. In Unity 2022, tooling is collected into feature sets, so open <strong class="bold">Window</strong> | <strong class="bold">Package Manager</strong>, select the <strong class="bold">3D World Building</strong> feature (including ProBuilder and related tooling), and install it.</p>
<p class="calibre3">After installing the features, we have one additional step to complete the ProBuilder setup. We’re using the URP renderer, which requires the supporting Shaders and Materials to be installed:</p>
<ol class="calibre14">
<li class="calibre15">While still in <strong class="bold">Package Manager</strong>, find and select <strong class="bold">ProBuilder</strong> in the list on the left.</li>
<li class="calibre15">On the right side, select <strong class="bold">Samples</strong> and click the <strong class="bold">Import</strong> button for the <strong class="bold">Universal Render Pipeline </strong><strong class="bold">Support</strong> item.</li>
<li class="calibre15">Once the import is complete, go to <strong class="bold">Edit</strong> | <strong class="bold">Preferences…</strong> | <strong class="bold">ProBuilder</strong> and ensure that under <strong class="bold">Mesh Settings</strong>, <strong class="bold">Material</strong> is set to <strong class="bold">ProBuilder </strong><strong class="bold">Default URP</strong>.</li>
</ol>
<p class="calibre3">Installing ProBuilder adds a new top menu item named <strong class="bold">Tools</strong> that allows opening the <strong class="bold">ProBuilder</strong> window and accessing additional functions, exporting, and debugging logging preferences. For our greyboxing, we’re going to focus on the object creation process within the <strong class="bold">ProBuilder</strong> window, but that’s not to say ProBuilder is limited to just creating simple greyboxing objects; it has grown into a full-fledged 3D modeling and texturing product that, depending on the style of your game, could be used for final asset creation too.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">ProBuilder: <a href="https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml</a></p>
<p class="calibre3">Let’s open the <strong class="bold">ProBuilder</strong> window<a id="_idIndexMarker1005" class="pcalibre1 pcalibre calibre6"/> now by going to <strong class="bold">Tools</strong> | <strong class="bold">ProBuilder</strong> | <strong class="bold">ProBuilder</strong>, and we’ll get set up to make the modular building blocks from our sketch’s legend.</p>
<h2 id="_idParaDest-185" class="calibre8"><a id="_idTextAnchor195" class="pcalibre1 pcalibre calibre6"/>Modular parts, Prefabs, and Variants</h2>
<p class="calibre3">Unlike an exterior<a id="_idIndexMarker1006" class="pcalibre1 pcalibre calibre6"/> environment’s level design, where<a id="_idIndexMarker1007" class="pcalibre1 pcalibre calibre6"/> shapes are organic in nature regarding <a id="_idIndexMarker1008" class="pcalibre1 pcalibre calibre6"/>their placement and position in the world, we’re making an interior environment for a controlled space. So, we’ll be building with modules that will need to <em class="italic">snap</em> to one another as they are laid out (you know, with the precision an airtight habitat requires). This is generally the approach you’d use for any manufactured structural spaces not found in nature.</p>
<p class="calibre3">Unity handles modular<a id="_idIndexMarker1009" class="pcalibre1 pcalibre calibre6"/> design <a id="_idIndexMarker1010" class="pcalibre1 pcalibre calibre6"/>well <a id="_idIndexMarker1011" class="pcalibre1 pcalibre calibre6"/>by providing some supporting construction options.</p>
<h3 class="calibre10">Grid snapping</h3>
<p class="calibre3">Unity provides a <strong class="bold">grid snapping</strong> system that works wonderfully with ProBuilder to simplify our lives for such a task <a id="_idIndexMarker1012" class="pcalibre1 pcalibre calibre6"/>as snapping modules together. Grid snapping allows for precisely positioning a GameObject on X, Y, or Z axis planes, and applies to move, rotate, or scale operations.</p>
<p class="calibre3">Transforming a GameObject – that is, realizing the move, rotate, and scale operations – can also be performed in increments without aligning to predefined gridline snap spacing. Incremental snapping can be performed by holding down the <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> key while using the object transform gizmo in the scene view (<strong class="bold">Snap Increment</strong> settings are found on the button to the right of the <strong class="bold">Grid Snapping</strong> settings, as seen in <em class="italic">Figure 10</em><em class="italic">.3</em>).</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Grid snapping: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml</a>.</p>
<p class="calibre3">Our level sketch is free of any dimensions (I just used a grid for roughly sizing things consistently), so we aren’t limited in letting the creativity flow; now that we’re making the <em class="italic">precise</em> modular parts, we need to introduce some unit of measurement to allow for the snapping together of parts. Building modules that need to connect to create our enclosed interior-level design will be pretty tricky if we don’t control the size of the details.</p>
<p class="calibre3">To get set up for grid snapping, we first need to activate the <strong class="bold">Move</strong> tool and ensure that the handle orientation in the <strong class="bold">Tool Settings</strong> overlay is set to <strong class="bold">Global</strong> (this is a requirement for the snapping to be enabled in the scene view), as seen in the following screenshot:</p>
<div><div><img alt="Figure 10.3 – Grid Snapping toolbar" src="img/B18347_10_3.jpg" class="calibre113"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Grid Snapping toolbar</p>
<p class="calibre3">Note that the <strong class="bold">Transform</strong> tool snaps the selected GameObject(s) to the grid along the active gizmo axis – using the <strong class="bold">Grid Visual</strong> button to the left of the <strong class="bold">Grid Snapping</strong> settings, which, as seen in <em class="italic">Figure 10</em><em class="italic">.3</em>, is currently set to the <strong class="bold">Grid </strong><strong class="bold">Plane</strong> Y-axis.</p>
<p class="calibre3">Let’s ensure that the grid snap settings are set up for us to start creating the modular parts for the habitat interior. Referring to <em class="italic">Figure 10</em><em class="italic">.3</em>, set up the snapping grid with the following steps:</p>
<ol class="calibre14">
<li class="calibre15">Select the <strong class="bold">Move</strong> tool from the <strong class="bold">Toolbar</strong> overlay in the scene view.</li>
<li class="calibre15">Set the handle orientation on the <strong class="bold">Tool Settings</strong> overlay to <strong class="bold">Global</strong>.</li>
<li class="calibre15">Verify <strong class="bold">Grid Visual</strong> | <strong class="bold">Grid Plane</strong> = <strong class="bold">Y</strong>.</li>
<li class="calibre15">Verify <strong class="bold">Grid snapping</strong> = <strong class="bold">enabled</strong>.</li>
<li class="calibre15">Set <strong class="bold">Grid snapping</strong> | <strong class="bold">Grid size</strong> = <strong class="bold">2</strong> (default value is <strong class="bold">1</strong>).</li>
<li class="calibre15">Set <strong class="bold">Increment snapping</strong> = <strong class="bold">0.25</strong>.</li>
</ol>
<p class="calibre3">I have experience <a id="_idIndexMarker1013" class="pcalibre1 pcalibre calibre6"/>with mechanical drawing and CAD, so I like knowing what dimensions I’m working with – even though, yes, we’ll be snapping to the grid units we just defined. ProBuilder’s default material also includes a grid texture, but it may still be challenging to establish the required sizes without some visible values. So, let’s use the visual dimensions of the objects we’ll be building. From the <strong class="bold">File</strong> menu, set the <strong class="bold">Dimensions</strong> overlay to <strong class="bold">Show</strong> by going to <strong class="bold">Tools</strong> | <strong class="bold">ProBuilder</strong> | <strong class="bold">Dimensions</strong>.</p>
<p class="calibre3">Grid snapping will be of tremendous help – ensuring consistent sizing of the modular parts – but we can<a id="_idIndexMarker1014" class="pcalibre1 pcalibre calibre6"/> take another step with a simple construction aid.</p>
<h3 class="calibre10">Construction plane</h3>
<p class="calibre3">We will put down<a id="_idIndexMarker1015" class="pcalibre1 pcalibre calibre6"/> a reference plane to assist in creating modules. I’ve decided the standard module size will be 6 units in length (this is rather arbitrary for how large the base modules are that you’ll want to work with; I felt it would be better to work with smaller modules for this design), so we’ll base all the dimensions – modules as well as map dimensions – on this standard (and the divisible dimensions of it by the snap unit size of 2; so, hopefully, that all works out).</p>
<p class="calibre3">Let’s proceed:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Scenes</code> folder, duplicate <code>SampleScene</code> and name it <code>Habitat </code><code>Interior 1</code>.</li>
<li class="calibre15">Now, with the <strong class="bold">ProBuilder</strong> window open, select <strong class="bold">New Shape</strong> and then click the <strong class="bold">Plane</strong> selection icon in the <strong class="bold">Create </strong><strong class="bold">Shape</strong> overlay.</li>
<li class="calibre15">Grid snapping and dimensions showing are enabled, so click and drag out a plane that is 6 x 6 units in size.</li>
</ol>
<div><div><img alt="Figure 10.4 – ProBuilder reference plane" src="img/B18347_10_4.jpg" class="calibre114"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.4 – ProBuilder reference plane</p>
<ol class="calibre14">
<li value="4" class="calibre15">Click <strong class="bold">New Shape</strong> again to stop creating shapes.</li>
<li class="calibre15">Now, let’s reset the plane position to <code>(0, 0, 0)</code> in world space. With the plane selected, right-click the <code>(0, 0, 0)</code><code>Module </code><code>Reference Plane</code>.</li>
</ol>
<p class="callout-heading">Tip | Maximize Unity window</p>
<p class="callout">To maximize the currently active window in Unity, as seen with the scene view window in <em class="italic">Figure 10</em><em class="italic">.3</em>, you can use the keyboard shortcut <em class="italic">Shift</em> + <em class="italic">spacebar.</em></p>
<p class="calibre3">And now, to make our first modular part!</p>
<h3 class="calibre10">Making modular parts</h3>
<p class="calibre3">Our modular parts will<a id="_idIndexMarker1017" class="pcalibre1 pcalibre calibre6"/> seamlessly snap together in numerous configurations to make the variations we need to create the larger complex space of the habitat station’s level design. So, let’s start making modular parts for our environment with a wall segment:</p>
<ol class="calibre14">
<li class="calibre15">To make a wall segment, click <strong class="bold">New Shape</strong>, but click the <strong class="bold">Cube</strong> selection icon this time.</li>
<li class="calibre15">Starting at <code>(0, 0, 0)</code> drag out a shape that is the length of the reference plane (6 units) and -2 units in the <strong class="bold">Z</strong> direction (away from the reference plane; the blue gizmo axis).</li>
<li class="calibre15">Then, move up (in the <code>4</code> units in height.</li>
</ol>
<p class="calibre3">As a result of snapping to the grid, it looks like the box is a bit too thick to represent a wall, so let’s edit the shape and make it a bit thinner:</p>
<ol class="calibre14">
<li class="calibre15">As seen in <em class="italic">Figure 10</em><em class="italic">.5</em>, rotate the camera to see the other side of the wall. We can rotate within the scene view by holding down the <em class="italic">Alt</em>/<em class="italic">Option</em> key and then clicking and dragging the mouse pointer.</li>
<li class="calibre15">Then click the <strong class="bold">Face Selection</strong> option in the <strong class="bold">ProBuilder Selection</strong> overlay (<em class="italic">A</em>).</li>
<li class="calibre15">Clicking on the facing side of the wall will now select just the face polygons. While holding down the <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> key, drag the Z-axis handle (blue) of the move transform gizmo until the wall is 1 unit thick (<em class="italic">B</em>).</li>
</ol>
<div><div><img alt="Figure 10.5 – ProBuilder incremental surface snap editing" src="img/B18347_10_5.jpg" class="calibre115"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.5 – ProBuilder incremental surface snap editing</p>
<ol class="calibre14">
<li value="4" class="calibre15">When done editing the face, return to the <strong class="bold">Object Selection</strong> mode (<em class="italic">A</em>).</li>
</ol>
<p class="calibre3">Greyboxing doesn’t necessarily mean 100% void of all details; I generally like to add at least some small elements to my greyboxing kit parts to convey some design aesthetics, so we’ll add a few <a id="_idIndexMarker1018" class="pcalibre1 pcalibre calibre6"/>minor details to the wall segment before building up some additional parts.</p>
<p class="calibre3">Let’s add some geometry detail to the wall segment:</p>
<ol class="calibre14">
<li class="calibre15">Make a new cube of 2 x 2 units with a height of 4 units. Then, using <code>1.5</code> x <code>0.25</code> x <code>4</code>. Position it at the end of the wall segment to provide an end cap.</li>
<li class="calibre15">Duplicate the <strong class="bold">End Cap</strong> cube and place it at the other end of the wall segment (like bookends). Note that both ends should be within the reference plane and will therefore intersect the wall segment (this is fine – we want to constrain the parts within our reference size so everything snaps together like Lego bricks).</li>
<li class="calibre15">Make a new cube of <code>6</code> x <code>2</code> units with a height of <code>2</code> units, then edit its size and position it to make a sort of connecting bar thing along the length of the wall segment.</li>
</ol>
<p class="calibre3">The results of our 3D modeling can be seen in the following screenshot:</p>
<div><div><img alt="Figure 10.6 – Wall section details added" src="img/B18347_10_6.jpg" class="calibre116"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Wall section details added</p>
<p class="callout-heading">Tip | Lighting</p>
<p class="callout">Note that the shadows on the lighting in the scene have been turned off to focus on the modeling task. You can do this by selecting the <strong class="bold">Directional Light</strong> object in the scene hierarchy, then, in the Inspector, find the <strong class="bold">Shadows</strong> section and set <strong class="bold">Shadow Type</strong> to <strong class="bold">No Shadows</strong>.</p>
<p class="calibre3">I would say this wall <a id="_idIndexMarker1019" class="pcalibre1 pcalibre calibre6"/>section is now complete for our first modular kit part. So, we’ll, of course, want to make it a Prefab so we can reuse it where needed, and should we need to modify it, all references in the scene will be updated.</p>
<p class="calibre3">Follow these steps to create the wall Prefab:</p>
<ol class="calibre14">
<li class="calibre15">Add a new empty GameObject and reset <code>(0, 0, 0)</code> . This will be our parent object and ensure that our modular parts maintain consistency for their snapping point – the individual objects that all make up the module will be transformed by this anchor pivot.</li>
<li class="calibre15">Select and drag all the parts of the wall assembly to be a child of the new empty GameObject.</li>
<li class="calibre15">Now, rename the parent object to <code>Wall 1</code> and drag it to a new <code>Assets/Prefabs</code> folder to make the Prefab.</li>
</ol>
<p class="calibre3">You now have all the tools and knowledge to make the rest of the modular parts needed for our greyboxing kit. That was easy, yay!</p>
<p class="calibre3">What are all the Prefabs we need for our greyboxing kit to produce a complete block out of the level? We <a id="_idIndexMarker1020" class="pcalibre1 pcalibre calibre6"/>can get our answer from the map legend (see <em class="italic">Figure 10</em><em class="italic">.2</em>). There are only a few to make – minus one for the wall we just made:</p>
<table class="no-table-style" id="table005-1">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">(A)</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Wall 1</p>
</td>
<td class="no-table-style2">
<p class="calibre3">6 units length</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">(B)</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Wall 2</p>
</td>
<td class="no-table-style2">
<p class="calibre3">12 units length</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">(C)</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Doorway</p>
</td>
<td class="no-table-style2">
<p class="calibre3">18 units length (equal wall, open space, wall)</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">(D)</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Connector 1</p>
</td>
<td class="no-table-style2">
<p class="calibre3">6 x 6 units with floor plane</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">(E)</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Connector 2</p>
</td>
<td class="no-table-style2">
<p class="calibre3">6 x 12 units with floor plane</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 10.5 – Greyboxing kit parts</p>
<p class="calibre3"><em class="italic">Connector 1</em> (<em class="italic">D</em>) will be the same type of connector between rooms so that it can be created as a completed module and not have to be assembled from individual wall parts whenever we need one. It’s the same for the <em class="italic">Connector 2</em> (<em class="italic">E</em>) Prefab, just longer. Here, we can see all the modular parts:</p>
<div><div><img alt="Figure 10.7 – Greyboxing kit Prefabs" src="img/B18347_10_7.jpg" class="calibre117"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Greyboxing kit Prefabs</p>
<p class="calibre3">Go ahead and create the additional wall, door, and connector modular parts now; I’ll wait. Just be sure to always start from the origin of our construction plane to ensure the anchor pivot is at <code>(0, 0, 0)</code> – by creating a new empty GameObject there and parent the cubes to it – so that our kit parts will always snap into place properly. These anchor pivot instructions are <a id="_idIndexMarker1021" class="pcalibre1 pcalibre calibre6"/>based on what’s seen in <em class="italic">Figure 10</em><em class="italic">.4</em> and not as seen in <em class="italic">Figure 10</em><em class="italic">.7</em>, where the wall parts were moved for better visibility after being created.</p>
<p class="calibre3">With our greyboxing kit complete, we can now start mapping out the level.</p>
<h2 id="_idParaDest-186" class="calibre8"><a id="_idTextAnchor196" class="pcalibre1 pcalibre calibre6"/>Greyboxing the level design</h2>
<p class="calibre3">We have our map<a id="_idIndexMarker1022" class="pcalibre1 pcalibre calibre6"/> sketch as a reference, but it would still be too abstract if we start haphazardly dragging in kit Prefabs to try and block it out. To streamline the process a bit more, we can use ProBuilder planes to lay out the map sketch according to our snapping grid. This will ensure that adding the kit modules will be straightforward and quick.</p>
<p class="calibre3">Another drawing aid (we take all the help we can get) is to set the <strong class="bold">Grid Visual</strong> setting for <strong class="bold">Opacity</strong> to the max value (as seen in <em class="italic">Figure 10</em><em class="italic">.7</em>) so the grid is fully visible.</p>
<p class="calibre3">Following our sketch and considering the size of our modular kit parts in <em class="italic">Table 10.5</em>, use the ProBuilder planes to map out the level: walls, doorways, and connectors. ProBuilder will create the planes at <strong class="bold">Y</strong>, <strong class="bold">0</strong> by default, which is right where we want them (floor level). It would then help to have the view locked to a top-down view while we draw out the level. So, using the scene gizmo (top-right corner of the scene view, (<em class="italic">A</em>) in <em class="italic">Figure 10</em><em class="italic">.8</em>), click the <strong class="bold">Y</strong> (green) handle, click the center cube to set the view to orthographic (no perspective), then click the little lock icon.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Scene view navigation: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml</a></p>
<p class="calibre3">Here is the start<a id="_idIndexMarker1023" class="pcalibre1 pcalibre calibre6"/> of our level map:</p>
<div><div><img alt="Figure 10.8 – Map layout planes" src="img/B18347_10_8.jpg" class="calibre118"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Map layout planes</p>
<p class="calibre3">As you’ll notice (and as seen in <em class="italic">Figure 10</em><em class="italic">.8</em>), the white ProBuilder planes are glowing a bit. This is because the post-processing volume was in the scene from when we duplicated <strong class="bold">SampleScene</strong>. If it’s a distraction, simply disable the <strong class="bold">Global Volume</strong> object in the hierarchy or, toggle off the effects via the <strong class="bold">View Options</strong> toolbar (<em class="italic">B</em>) while mapping out the level.</p>
<p class="calibre3">Here is the completed level map with the entryway at location (<em class="italic">A</em>), and making our way to the central control system room at location (<em class="italic">B</em>):</p>
<div><div><img alt="Figure 10.9 – Completed map layout" src="img/B18347_10_9.jpg" class="calibre118"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Completed map layout</p>
<p class="calibre3">I’m using the <em class="italic">of greatest importance</em> definition for the word central here, not the <em class="italic">in the middle of something</em> definition, just<a id="_idIndexMarker1024" class="pcalibre1 pcalibre calibre6"/> to clear up any possible confusion with the layout of the rooms.</p>
<p class="calibre3">All the hard stuff is done. All we have to do now is to drag our modular kit parts to the edges of the mapped floor planes – with the anchor pivots we ensured are at the origin of the module. We’ve guaranteed everything should snap in place and to each other. Once you have a modular Prefab in the scene, you can use <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">D</em> to duplicate it quickly, then move and rotate it into place.</p>
<p class="calibre3">Note that you will have to rotate modules to enclose the perimeter of the rooms and corridors. This is where the anchor pivot also plays a crucial role – the part will rotate at the pivot, ensuring proper snapping will be maintained. You can turn the parts by typing a value in the Inspector or using the <strong class="bold">Rotate Transform</strong> tool in the <strong class="bold">Toolbar</strong> overlay (hold the <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> key to rotate incrementally and ensure precisely 90 or 180 degrees of rotation).</p>
<p class="calibre3">If we make any mistakes in the size or spacing of the map’s rooms and corridors, we’ll quickly find out, but rapidly making changes for corrections is trivial with this modular approach. Easy-peasy.</p>
<p class="calibre3">Here are the results of my effort in bringing the interior habitat level together with our modular greyboxing kit:</p>
<div><div><img alt="Figure 10.10 – Finished habitat interior greyboxing" src="img/B18347_10_10.jpg" class="calibre119"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Finished habitat interior greyboxing</p>
<p class="calibre3">In this section, we <a id="_idIndexMarker1025" class="pcalibre1 pcalibre calibre6"/>learned how to block out a 3D environment made of simple ProBuilder model Prefabs used to create a simple greyboxing parts kit. We then discovered how to map out a level design and use Unity’s grid snapping system to make fitting everything together quick and easy.</p>
<p class="calibre3">For the next part, we need to playtest what we’ve built. Rather than coding a player controller from scratch, this time, we’ll be leveraging Unity’s Starter Assets to construct the player rapidly.</p>
<h1 id="_idParaDest-187" class="calibre5"><a id="_idTextAnchor197" class="pcalibre1 pcalibre calibre6"/>Creating an FPS player character with the Unity Starter Asset</h1>
<p class="calibre3">Let’s quickly look <a id="_idIndexMarker1026" class="pcalibre1 pcalibre calibre6"/>at some of the general<a id="_idIndexMarker1027" class="pcalibre1 pcalibre calibre6"/> benefits of using prebuilt assets – like<a id="_idIndexMarker1028" class="pcalibre1 pcalibre calibre6"/> Unity’s <strong class="bold">Starter Asset character controller</strong> – compared to coding ones ourselves:</p>
<ul class="calibre17">
<li class="calibre15">They save time and effort – complex systems take time to build and troubleshoot any issues that arise along the way</li>
<li class="calibre15">They are tested and optimized for performance and generally use best practices – as they’re provided by Unity (they know a thing or two about creating components for use in their engine) and widely used by game developers of all levels, these assets will be performant and much less likely to have bugs</li>
<li class="calibre15">They are built on Unity’s <code>CharacterController</code> component – these assets are built modularly, ensuring compatibility with other systems (such as camera and combat systems) and assets; they are a great starting foundation for an FPS game</li>
<li class="calibre15">They offer a learning opportunity – prebuilt assets can be a great learning tool because you can examine how they work</li>
<li class="calibre15">They have plenty of customization options – Unity provides many customization options out of the box for most player controller uses (especially for an FPS in this case, which is fantastic for us!)</li>
</ul>
<p class="calibre3">These advantages are pretty significant to minimize problems getting your game up and running quickly; we will take full advantage of them right now. Let’s install the Unity Starter Assets.</p>
<h2 id="_idParaDest-188" class="calibre8"><a id="_idTextAnchor198" class="pcalibre1 pcalibre calibre6"/>Installing the Unity Starter Assets</h2>
<p class="calibre3">We’ll use the <code>Starter Assets - FirstPerson CharacterController</code> | <code>URP</code> asset<a id="_idIndexMarker1029" class="pcalibre1 pcalibre calibre6"/> provided (for free) by Unity from<a id="_idIndexMarker1030" class="pcalibre1 pcalibre calibre6"/> the Asset Store for our 3D FPS game.</p>
<p class="callout-heading">Starter Assets - FirstPerson CharacterController | URP (Unity Technologies)</p>
<p class="callout">You can find this asset in the Unity Asset Store here: <a href="https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525</a>.</p>
<p class="calibre3">Installing will be straightforward and similar to how we’ve already installed assets from the Package Manager. However, since the Starter Assets have some required dependencies, there will be a bit of a hiccup in the process. Don’t worry; it’s only a minor inconvenience, as you’ll soon see by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">Save your<a id="_idIndexMarker1031" class="pcalibre1 pcalibre calibre6"/> scene now (<em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">S</em>) if you<a id="_idIndexMarker1032" class="pcalibre1 pcalibre calibre6"/> haven’t already – you’ll see why in a few steps.</li>
<li class="calibre15">Follow the preceding URL to open the asset in the Unity Asset Store.</li>
<li class="calibre15">Sign in if not already signed in.</li>
<li class="calibre15">Click the <strong class="bold">Add to My Assets</strong> button (accept <strong class="bold">Asset Store Terms of Service </strong><strong class="bold">and EULA</strong>).</li>
<li class="calibre15">With the project already open in the Unity Editor, click the <strong class="bold">Open in Unity </strong>button that appears at the top of the browser window (you can also always click the <strong class="bold">Open in Unity</strong> button on the Asset Store page at any time later) and you’ll see the following dialog:</li>
</ol>
<div><div><img alt="Figure 10.11 – Open in Unity dialog" src="img/B18347_10_11.jpg" class="calibre120"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Open in Unity dialog</p>
<ol class="calibre14">
<li value="6" class="calibre15">Clicking the <strong class="bold">Open Unity Editor</strong> button will set the focus to the Unity Editor and open the Package Manager with the <strong class="bold">Starter Assets - FirstPerson CharacterController</strong> |<strong class="bold"> URP</strong> package already selected (how convenient).</li>
<li class="calibre15">Click the <strong class="bold">Download</strong> button (top right of the window).</li>
<li class="calibre15">When the download has finished, click the <strong class="bold">Install</strong> button.</li>
<li class="calibre15">The Starter Assets packages require the new <code>PackageChecker</code> script), and we’ll be prompted concerning this, as seen in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.12 – Starter Assets dependencies warning" src="img/B18347_10_12.jpg" class="calibre121"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Starter Assets dependencies warning</p>
<ol class="calibre14">
<li value="10" class="calibre15">Of course, we want to click <strong class="bold">Install/Upgrade</strong> so we can actually use the Starter Asset in our project! If you accidentally skip this step, you can still install the new <strong class="bold">Input System</strong> package and <strong class="bold">Cinemachine</strong> package through the Package Manager. When the <strong class="bold">Input System</strong> dependency is installed, however, we’ll be presented with this dialog for enabling the native platform backends:</li>
</ol>
<div><div><img alt="Figure 10.13 – Update native platform backends" src="img/B18347_10_13.jpg" class="calibre122"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Update native platform backends</p>
<ol class="calibre14">
<li value="11" class="calibre15">Click <strong class="bold">Yes</strong>, and the Unity Editor will restart (aren’t you glad I told you to save your scene in <em class="italic">step 1</em>?).</li>
<li class="calibre15">When the Unity Editor reopens, return to the Package Manager and click the <strong class="bold">Install</strong> button again (just a bit annoying but it seems unavoidable with the current dependency<a id="_idIndexMarker1035" class="pcalibre1 pcalibre calibre6"/> requirements). This<a id="_idIndexMarker1036" class="pcalibre1 pcalibre calibre6"/> time, the installation will finish without a hitch.</li>
</ol>
<p class="calibre3">That takes care of the installation, so let’s look at what the Starter Assets provide.</p>
<h2 id="_idParaDest-189" class="calibre8"><a id="_idTextAnchor199" class="pcalibre1 pcalibre calibre6"/>Starter Assets Playground scene</h2>
<p class="calibre3">We can quickly test the <a id="_idIndexMarker1037" class="pcalibre1 pcalibre calibre6"/>first-person <a id="_idIndexMarker1038" class="pcalibre1 pcalibre calibre6"/>character controller by opening the provided playground scene. Go to <code>Assets/StarterAssets/FirstPersonController/Scenes</code> to find the <strong class="bold">Playground</strong> scene. In the <strong class="bold">Playground</strong> scene, we have the necessary objects for the first-person character controller, as well as a simple environment we can test the character controller in.</p>
<p class="calibre3">However, you can quickly manipulate the playground environment to provide some additional test geometry with the available parts by snapping them together using their mesh vertexes rather than trying to figure out a snapping grid setup. To snap objects together using their vertexes, select the mesh you want to transform with the <strong class="bold">Move</strong> tool active, then press and hold the <em class="italic">V</em> key to activate vertex snapping. Move to the vertex you want to use – generally a corner point of the mesh – then click and drag to any other vertex on another object. Simple and quite helpful!</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Positioning GameObjects and vertex snapping: <a href="https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml</a></p>
<p class="callout">Of particular note, you can also use vertex snapping to place an object precisely on the surface of another object. To accomplish this, while already holding down the <em class="italic">V</em> key, hold down the <em class="italic">Shift</em> + <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> keys while moving over the surface you want to snap to.</p>
<p class="callout">Don’t forget that you can use the <em class="italic">F</em> key in the scene view window at any time to refocus on the currently selected object – this sets orbiting, panning, and zooming around that object.</p>
<p class="calibre3">Okay, let’s look at<a id="_idIndexMarker1039" class="pcalibre1 pcalibre calibre6"/> getting around with the<a id="_idIndexMarker1040" class="pcalibre1 pcalibre calibre6"/> first-person character controller we’ll use for our game.</p>
<h2 id="_idParaDest-190" class="calibre8"><a id="_idTextAnchor200" class="pcalibre1 pcalibre calibre6"/>Getting around</h2>
<p class="calibre3">First things first, enter <a id="_idIndexMarker1041" class="pcalibre1 pcalibre calibre6"/>Play Mode. Now, you can look around using the mouse, move the player with the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, <em class="italic">D</em> keys, hold <em class="italic">Shift</em> to sprint, and press the <em class="italic">spacebar</em> to jump. The <em class="italic">move</em>, <em class="italic">look</em>, <em class="italic">jump</em>, and <em class="italic">sprint</em> actions for both keyboard/mouse and gamepad input are established with the <code>StarterAssets</code> Input Action Asset (Input Actions) located in the <code>Assets/StarterAssets/InputSystem</code> folder.</p>
<p class="calibre3">As seen in the scene <strong class="bold">Hierarchy</strong> window in the following screenshot, we have the objects that make up the Starter Assets first-person character controller:</p>
<div><div><img alt="Figure 10.14 – Standard Assets Playground scene Hierarchy" src="img/B18347_10_14.jpg" class="calibre123"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Standard Assets Playground scene Hierarchy</p>
<p class="calibre3">The <code>PlayerCapsule</code> object is the primary object (Prefab) holding the modular components that provide the behavior for the first-person character controller. Starting with <code>PlayerCapsule</code>, the process flow for the components – from input to transform manipulation – looks like this:</p>
<p class="calibre3"><code>PlayerCapsule</code> à [<code>StarterAssets</code> (Input Action Asset / Input Actions)] <code>Player</code> à <code>PlayerInput</code> [SendMessages] à <code>StarterAssetsInputs</code> à <code>FirstPersonController</code> à <code>CharacterController</code></p>
<p class="calibre3">I encourage you to look into each of the components to gain some familiarity with how things are connected to provide this functionality. We don’t actually need to dig into these components to get things working, so I won’t be covering it. We will, however, extend upon the<a id="_idIndexMarker1042" class="pcalibre1 pcalibre calibre6"/> base functionality the Starter Assets provide when required.</p>
<p class="calibre3">However, with this brief overview, we should understand what’s needed to bring the first-person character controller into our greybox habitat level.</p>
<h2 id="_idParaDest-191" class="calibre8"><a id="_idTextAnchor201" class="pcalibre1 pcalibre calibre6"/>Adding the first-person controller to our level</h2>
<p class="calibre3">Now that you’ve finished<a id="_idIndexMarker1043" class="pcalibre1 pcalibre calibre6"/> having some fun in the Starter Assets <code>Playground</code> scene, let’s go back to our habitat interior scene to add the player so we can progress further with our game. As we saw in the <code>Playground</code> scene hierarchy, a few Prefabs worked together to provide the first-person character controller functionality. So, we’ll use these Prefabs too.</p>
<p class="calibre3">Bringing this in is made simple with a provided nested Prefab. Here are the steps we’ll follow to bring the controller setup into the scene:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/StarterAssets/FirstPersonController/Prefabs</code> folder, find the <code>NestedParent_Unpack</code> Prefab. As the name no doubt indicates, this is a nested Prefab containing everything we need to set up the player.</li>
<li class="calibre15">Drag and drop <code>NestedParent_Unpack</code> into the scene hierarchy.</li>
<li class="calibre15">As the name indicates, we’ll want to unpack this nested Prefab, so we have just the child Prefabs. Right-click <code>NestedParent_Unpack</code>, and then select <strong class="bold">Prefab</strong> | <strong class="bold">Unpack</strong>.</li>
<li class="calibre15">With the prefab now unpacked, drag the child objects out into the root of the <strong class="bold">Hierarchy</strong> window.</li>
<li class="calibre15">You can now delete <code>NestedParent_Unpack</code>, and we are ready to go!</li>
</ol>
<p class="calibre3">As you can see<a id="_idIndexMarker1044" class="pcalibre1 pcalibre calibre6"/> in the <code>UI_Canvas_StarterAssetsInputs_Joysticks</code> Prefab object in the hierarchy.</p>
<div><div><img alt="Figure 10.15 – Starter Assets mobile controls" src="img/B18347_10_15.jpg" class="calibre124"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Starter Assets mobile controls</p>
<p class="calibre3">I think it’s great that Unity has decided to include mobile support with the Starter Assets; again, this<a id="_idIndexMarker1045" class="pcalibre1 pcalibre calibre6"/> saves us a lot of time if we want to get a mobile game up and running quickly – as well as all the previous benefits noted.</p>
<p class="calibre3">We’re now ready to give the level a playtest!</p>
<h2 id="_idParaDest-192" class="calibre8"><a id="_idTextAnchor202" class="pcalibre1 pcalibre calibre6"/>Playtesting the level</h2>
<p class="calibre3">To get things started, we’ll <a id="_idIndexMarker1046" class="pcalibre1 pcalibre calibre6"/>have to move the <code>PlayerCapsule</code> object into a position at the start of our level map, assuming we just entered the habitat station after solving the entryway puzzle. You can see an example of placement in <em class="italic">Figure 10</em><em class="italic">.15</em>.</p>
<p class="calibre3">The ProBuilder models <a id="_idIndexMarker1047" class="pcalibre1 pcalibre calibre6"/>include <strong class="bold">Colliders</strong> for the planes we used to map out the level floor and the cubes we used to make the modular wall Prefabs, so the level is already set! Enter Play Mode and have a look around.</p>
<p class="callout-heading">Additional reading | Starter Assets documentation</p>
<p class="callout">Additional details for the Starter Assets package can be found in the documentation included with the package. The documentation is in PDF form and can be found in the <strong class="source-inline1">Assets/StarterAssets</strong> folder.</p>
<p class="calibre3">In this section, we learned how to rapidly add a first-person character controller to our game’s level by<a id="_idIndexMarker1048" class="pcalibre1 pcalibre calibre6"/> leveraging the Unity Starter Assets.</p>
<p class="calibre3">In the next section, we’ll revisit some reusable components from the 2D game projects to use in our 3D FPS game project.</p>
<h1 id="_idParaDest-193" class="calibre5"><a id="_idTextAnchor203" class="pcalibre1 pcalibre calibre6"/>Refactoring environment interactions to 3D API methods</h1>
<p class="calibre3">From the <a id="_idIndexMarker1049" class="pcalibre1 pcalibre calibre6"/>previous 2D game projects, we have <a id="_idIndexMarker1050" class="pcalibre1 pcalibre calibre6"/>a small library of components built up already, but they are 2D, and we are now in 3D, so it requires a bit of refactoring for us to use them. Let’s first revisit the <code>TriggeredEvent</code> component we created in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>.</p>
<h2 id="_idParaDest-194" class="calibre8"><a id="_idTextAnchor204" class="pcalibre1 pcalibre calibre6"/>Revisiting the TriggeredEvent component</h2>
<p class="calibre3">The Physics 2D API method<a id="_idIndexMarker1051" class="pcalibre1 pcalibre calibre6"/> we used for the <code>TriggeredEvent</code> component <a id="_idIndexMarker1052" class="pcalibre1 pcalibre calibre6"/>is <code>OnTriggerEnter2D()</code>. Its 3D counterpart simply drops the <em class="italic">2D</em> part, and so it’s just <code>OnTriggerEnter()</code> (Unity is 3D under the hood, and it would make sense that only the 2D-specific methods are indicated as such).</p>
<p class="calibre3">Now, considering the above, let’s look at how we’ll update the <code>TriggeredEvent</code> code. Provided that you copied in the <code>Assets/Scripts/TriggeredEvent.cs</code> file from the previous 2D project, only a few changes are required. Otherwise, you can first revisit the earlier code in the book or even download the 2D version of the script from the GitHub project repo: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts</a>.</p>
<p class="calibre3">Here are the changes we’ll make:</p>
<ol class="calibre14">
<li class="calibre15">The Unity Physics message event from this appears as follows, but we will change it:<pre class="source-code">
private void OnTriggerEnter2D(Collider2D collision)</pre><p class="calibre3">And here it is after the change:</p><pre class="source-code">private void OnTriggerEnter(Collider collision)</pre></li> <li class="calibre15">Update the <code>[RequiredComponent]</code> attribute from the original, which looks like this:<pre class="source-code">
[RequireComponent(typeof(Collider2D))]
[RequireComponent(typeof(Collider))]</pre><p class="calibre3">I believe this one is self-explanatory – we don’t require the collider to be a <code>Collider2D</code> type.</pre></li> </ol>
<p class="calibre3">If you save the script <a id="_idIndexMarker1053" class="pcalibre1 pcalibre calibre6"/>now, you’ll<a id="_idIndexMarker1054" class="pcalibre1 pcalibre calibre6"/> likely notice we have an error displayed in the Console window with the <code>Tags</code> type not being found: <code>Tags.Player</code>).</p>
<p class="calibre3">We can resolve this error by copying the <code>Assets/Scripts/Tags.cs</code> file again from the 2D project, creating the <code>Tags.cs</code> file manually and typing out the constant variable declaration, or using the IDE’s refactoring tools to generate <code>Tags.cs</code>. Either way, we’ll end up with the following:</p>
<pre class="source-code">
internal class Tags
{
    // Ensure all tags are spelled correctly!
    public const string Player = "Player";
}</pre> <p class="calibre3">Concerning our <code>Player</code> tag, the <code>PlayerCapsule</code> object from the Unity Starter Assets first-person character controller is already tagged as <code>Player</code>. How convenient!</p>
<p class="calibre3">With the <code>TriggeredEvent</code> script all sorted, let’s implement it now by adding a triggered <a id="_idIndexMarker1055" class="pcalibre1 pcalibre calibre6"/>interaction<a id="_idIndexMarker1056" class="pcalibre1 pcalibre calibre6"/> to the interior habitat level.</p>
<h2 id="_idParaDest-195" class="calibre8"><a id="_idTextAnchor205" class="pcalibre1 pcalibre calibre6"/>Implementing a TriggeredEvent in our level design</h2>
<p class="calibre3">We’ve already seen<a id="_idIndexMarker1057" class="pcalibre1 pcalibre calibre6"/> how <a id="_idIndexMarker1058" class="pcalibre1 pcalibre calibre6"/>we can leverage editor tooling and reusable components to build out environments and add behavior or functionality to our games. This current implementation will be no exception. So, let’s see how we can use both ProBuilder and the <code>TriggeredEvent</code> component to add a door to the level design that automatically opens when the player gets near it:</p>
<ol class="calibre14">
<li class="calibre15">We’ll start by creating a trigger volume using a ProBuilder cube. Using <em class="italic">Figure 10</em><em class="italic">.16</em> as a reference, draw out a cube just in front of the first doorway of the room the player starts from – and don’t forget your <em class="italic">grid snapping</em>!</li>
<li class="calibre15">Once the cube is created, select it, then in the ProBuilder <code>OnTriggerEnter()</code> message event will be fired.</p></li>
</ol>
<p class="calibre3">With that, we have quickly made a trigger volume visible at design time but hidden at runtime – another excellent feature ProBuilder provides.</p>
<p class="calibre3">Let’s go ahead and add the refactored <code>TriggeredEvent</code> component to our trigger volume ProBuilder cube object now. We can now use the <code>TriggeredEvent</code> component to wire up and trigger an animation.</p>
<h2 id="_idParaDest-196" class="calibre8"><a id="_idTextAnchor206" class="pcalibre1 pcalibre calibre6"/>Animating the door opening</h2>
<p class="calibre3">Now that we <a id="_idIndexMarker1059" class="pcalibre1 pcalibre calibre6"/>have a <code>UnityEvent</code> that can be triggered when the player enters the trigger volume at our doorway, let’s add a closed door that will animate open.</p>
<p class="calibre3">First, we’ll create the door following these steps:</p>
<ol class="calibre14">
<li class="calibre15">Create a new ProBuilder cube.</li>
<li class="calibre15">Use face editing and incremental snapping to make the cube thin (you know, like a door).</li>
<li class="calibre15">Place the cube in the doorway to obstruct entry (as if it were closed).</li>
<li class="calibre15"> Rename the object <code>Door</code>.</li>
<li class="calibre15">By assigning a color, let’s quickly differentiate the door mesh from our greyboxing kit parts. We can do that using the <strong class="bold">Vertex Colors</strong> command in the ProBuilder window. With the <strong class="bold">Door</strong> object selected, clicking <strong class="bold">Vertex Colors</strong> will open a new window with a default color palette shown. Clicking one of the colors’ related <strong class="bold">Apply</strong> button will set a new color on the object. Easy-peasy. (Oh… and as seen in <em class="italic">Figure 10</em><em class="italic">.16</em>, I chose blue.)</li>
</ol>
<p class="calibre3">We can now add an animation to the door that we can trigger to play from the <code>TriggeredEvent</code> component.</p>
<p class="calibre3">With the <code>.anim</code>) that we’ll name <code>Door-idle</code> and save to a new <code>Assets/Animation</code> folder. In the associated <strong class="bold">Animator</strong>, this sets the idle animation as the default state. Since we don’t want the door to do anything at all in its idle state, we’re done with it. Now, we want to create the animation for opening the door.</p>
<p class="calibre3">Now, follow these steps to create the door-opening animation:</p>
<ol class="calibre14">
<li class="calibre15">In the <strong class="bold">Animation</strong> window, with the <strong class="bold">Door</strong> object selected, click on the <strong class="bold">Animation Clip</strong> dropdown – currently set to <strong class="bold">Door-idle</strong> – then select <strong class="bold">Create </strong><strong class="bold">New Clip…</strong>.</li>
<li class="calibre15">When prompted, save the new animation clip and name it <code>Door-open</code>.</li>
<li class="calibre15">Click the red <code>0.5</code> seconds.</li>
<li class="calibre15">Using the <strong class="bold">Move</strong> tool, move the <strong class="bold">Door</strong> into an open position (or change the <strong class="bold">Transform</strong> position value in the Inspector for the open direction axis) wide enough for the player to pass through. This will create two keyframes in the timeline: one at the start and one at the current time.</li>
<li class="calibre15">Click the <strong class="bold">Record</strong> button again now to stop animating.</li>
<li class="calibre15">Now, open the <strong class="bold">Animator</strong> window by going to <strong class="bold">Window</strong> | <strong class="bold">Animation</strong> | <strong class="bold">Animator</strong>. You’ll see both the <strong class="bold">Door-idle</strong> and <strong class="bold">Door-open</strong> nodes (the animations) already there and a <strong class="bold">Default State Transition</strong> line from <strong class="bold">Entry</strong> to <strong class="bold">Door-idle</strong> – precisely what we want. We don’t want the door to do anything when we start playing the game.</li>
<li class="calibre15">Double-click the <strong class="bold">Door-open</strong> animation, then, in the Inspector, uncheck <strong class="bold">Loop Time</strong>. We want the door to open and stop playing the animation, not continuously loop back and do it repeatedly.</li>
</ol>
<p class="calibre3">The last thing to do is<a id="_idIndexMarker1060" class="pcalibre1 pcalibre calibre6"/> wire up <code>UnityEvent</code> on the <code>TriggeredEvent</code> component:</p>
<ol class="calibre14">
<li class="calibre15">Select the <code>TriggeredEvent</code> component, click the little plus (<strong class="bold">+</strong>) icon to add a new event listener.</li>
<li class="calibre15">Drag the <strong class="bold">Door</strong> to the <strong class="bold">Object</strong> field.</li>
<li class="calibre15">In the function selection dropdown, select <code>Door-open</code> in the provided field – and double-check your spelling! The spelling here must match the name of the animation node in the <strong class="bold">Animator</strong>.</li>
</ol>
<p class="calibre3">The preceding <code>TriggeredEvent</code> listener assignment, the <strong class="bold">Door-open</strong> animation timeline, the blue <strong class="bold">Door</strong> object, and the ProBuilder <strong class="bold">Cube</strong> trigger volume object can all be seen in the following screenshot:</p>
<div><div><img alt="Figure 10.16 – Triggered door open animation" src="img/B18347_10_16.jpg" class="calibre125"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Triggered door open animation</p>
<p class="calibre3">Let’s make our triggered/animated door a Prefab as the final step:</p>
<ol class="calibre14">
<li class="calibre15">Parent the <strong class="bold">Cube</strong> and <strong class="bold">Door</strong> objects in the hierarchy to a new empty GameObject by selecting both objects.</li>
<li class="calibre15">Then right-click and choose <strong class="bold">Create </strong><strong class="bold">Empty Parent</strong>.</li>
<li class="calibre15">Name the new GameObject <code>Door_Triggered</code>.</li>
<li class="calibre15">Then drag it from the hierarchy to the <code>Assets/Prefabs</code> folder.</li>
</ol>
<p class="calibre3">Note that you may<a id="_idIndexMarker1061" class="pcalibre1 pcalibre calibre6"/> need to fix the <strong class="bold">Door-open</strong> animation since the <strong class="bold">Door</strong> object is now a child GameObject whose local position is offset in relation to the parent. If so, select <strong class="bold">Door</strong>, open the <strong class="bold">Animation</strong> window, and select the <strong class="bold">Door-open</strong> animation from the dropdown. You can now manually reset the values for each keyframe in the timeline. Use the <strong class="bold">Preview</strong> buttons to play the animation and test to adjust accordingly until resolved (you’ve got this).</p>
<p class="calibre3">You can now duplicate the <code>Door_Triggered</code> Prefab in the scene (<em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">D</em>), drag it in from the <strong class="bold">Project</strong> window, and place it throughout the level where it makes sense for the desired gameplay. For example, having a patrolling enemy behind a closed door is always fun.</p>
<p class="calibre3">In this section, we learned how to easily refactor a 2D API method to reuse some existing code and<a id="_idIndexMarker1062" class="pcalibre1 pcalibre calibre6"/> proceeded to use it and grasped some new learnings for rapidly creating 3D objects with ProBuilder to implement new functionality for the level. Next, we’ll look at more code reuse.</p>
<h1 id="_idParaDest-197" class="calibre5"><a id="_idTextAnchor207" class="pcalibre1 pcalibre calibre6"/>Code reuse in practice – Adding premade components to the player</h1>
<p class="calibre3">In addition to refactoring some<a id="_idIndexMarker1063" class="pcalibre1 pcalibre calibre6"/> existing code to work<a id="_idIndexMarker1064" class="pcalibre1 pcalibre calibre6"/> in our new project, we can also bring in our existing system code – this could then be considered premade components, ready for use. So, referring back to the GDD now, we will use <code>HealthSystem</code> from the 2D adventure game project to decrease and recharge the player’s power suit (i.e., health).</p>
<p class="calibre3">If you don’t already have the 2D adventure game scripts locally, you can download the project source from the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a></p>
<p class="calibre3">Now, from the 2D adventure game project, copy the following files into the 3D FPS game project (in the same locations):</p>
<ul class="calibre17">
<li class="calibre15">From <code>Assets/Scripts/Systems</code><ul class="calibre22"><li class="calibre15"><code>HealthSystem.cs</code></li></ul></li>
<li class="calibre15">From <code>Assets/Scripts/Interfaces</code><ul class="calibre22"><li class="calibre15"><code>IHeal.cs</code></li><li class="calibre15"><code>IDamage.cs</code></li><li class="calibre15"><code>IHaveHealth.cs</code></li></ul></li>
</ul>
<p class="calibre3">Now that the health system has been added to the project, the first thing to do is refactor any of the 2D API methods and types to the non-2D counterparts just like we did in the previous section, <em class="italic">Refactoring environment interactions to 3D API methods</em>. This includes changing all references of <code>OnTriggerEnter2D</code> to <code>OnTriggerEnter</code> and <code>Collider2D</code> to <code>Collider</code>.</p>
<p class="calibre3">Now, let’s go ahead and add <code>HealthSystem</code> as a component on the <strong class="bold">PlayerCapsule</strong> Prefab (again, in the Unity Starter Assets first-person character controller, this is the <strong class="bold">Player</strong> object).</p>
<p class="calibre3">To satisfy the GDD requirement of decreasing the player’s power suit level (health), let’s write some code that extends upon the existing <code>HealthSystem</code> code that will slowly decrease health at an <a id="_idIndexMarker1065" class="pcalibre1 pcalibre calibre6"/>assigned rate. We’ll ensure we <a id="_idIndexMarker1066" class="pcalibre1 pcalibre calibre6"/>expose fields in the Inspector for the amount to reduce health by and the rate of decrease.</p>
<h2 id="_idParaDest-198" class="calibre8"><a id="_idTextAnchor208" class="pcalibre1 pcalibre calibre6"/>Constant damage script</h2>
<p class="calibre3">Create a<a id="_idIndexMarker1067" class="pcalibre1 pcalibre calibre6"/> new C# script named <code>ConstantDamage</code> in the <code>Assets/Scripts</code> folder and open it for editing. We’ll replace the script template code with the following code, which should look familiar since we will implement the <code>IDamage</code> interface. The difference is that we won’t be triggering the damage from an object collision (like before with the <code>ProjectileDamage</code> class). Instead, we’ll be applying damage directly to the <code>HealthSystem</code> over time.</p>
<p class="calibre3">Let’s start with the required implementations for <code>IDamage</code>:</p>
<pre class="source-code">
using UnityEngine;
using System.Collections;
public class ConstantDamage : MonoBehaviour, IDamage
{
    public LayerMask DamageMask =&gt; _damageMask;
    [SerializeField] private LayerMask _damageMask;
    public int DamageAmount =&gt; _damageAmount;
    [SerializeField] private int _damageAmount = 1;
    public void DoDamage
        (Collider2D collision, bool isAffected) {}
}</pre> <p class="calibre3">A quick breakdown of the code looks like this:</p>
<ul class="calibre17">
<li class="calibre15"><code>ConstantDamage : MonoBehaviour, IDamage</code>: This class is inheriting the <code>IDamage</code> interface, which means we’ll have to implement the properties and methods defined (the contract): <code>DamageMask</code>, <code>DamageAmount</code>, and <code>DoDamage()</code>.</li>
<li class="calibre15"><code>_damageMask</code>: This encapsulated private variable is serialized and assignable in the Inspector, with the <code>public DamageMask</code> getter (to satisfy the interface contract) referenced by <code>HealthSystem</code>.<p class="calibre3">The <code>_damageMask</code> is a <code>LayerMask</code> that determines what object <strong class="bold">Layer</strong> can be damaged by this.</p></li>
<li class="calibre15"><code>_damageAmount</code>: This encapsulated private variable is serialized and assignable in the<a id="_idIndexMarker1068" class="pcalibre1 pcalibre calibre6"/> Inspector, with the <code>public DamageAmount</code> getter (to satisfy the interface contract) referenced by <code>HealthSystem.TakeDamage()</code>.<p class="calibre3">This determines the amount of damage that will be applied to the object over time (via <strong class="bold">coroutine</strong>).</p></li>
</ul>
<p class="calibre3">Now, we’ll add the code for applying damage over a set time interval:</p>
<pre class="source-code">
    [SerializeField] private float _damageInterval = 5f;
    private void Start()
        =&gt; StartCoroutine(ApplyDamageOverTime());
    private IEnumerator ApplyDamageOverTime()
    {
        var healthSystem = GetComponent&lt;HealthSystem&gt;();
        while (true)
        {
            healthSystem.HandleDamageCollision(null, this);
            yield return new
                WaitForSeconds(_damageInterval);
        }
    }</pre> <p class="calibre3">And here’s a quick breakdown of the preceding code:</p>
<ul class="calibre17">
<li class="calibre15"><code>_damageInterval</code>: This is the private member variable that is serialized and assignable in the Inspector.<p class="calibre3">It determines the time interval of the damage amount that will be applied to the object (the damage rate).</p></li>
<li class="calibre15"><code>StartCoroutine(ApplyDamageOverTime())</code>: This is how we start the coroutine in the <code>Start()</code> Unity message event, which will begin applying damage to <a id="_idIndexMarker1069" class="pcalibre1 pcalibre calibre6"/>the player right away.</li>
<li class="calibre15"><code>ApplyDamageOverTime()</code>: This is our <code>IEnumerator</code> coroutine method that uses <code>while (true)</code> to loop indefinitely, calling <code>HandleDamageCollision()</code> then delaying 5 seconds via <code>WaitForSeconds()</code> before looping again.<ul class="calibre22"><li class="calibre15"><code>HandleDamageCollision(null…</code>: Here, we’re passing in a value of <code>null</code> for the <code>Collider</code> parameter since, well, we don’t have a collision occurring. We’ll just have to ensure we do a <code>DoDamage()</code>.</li></ul></li>
<li class="calibre15"><code>DoDamage()</code>: This declaration is required for the interface implementation (to satisfy the contract), but we won’t use it now.</li>
</ul>
<p class="calibre3">Whew, that makes it seem like we have to do so much for only a dozen or so lines of code! And that’s the point. We introduce good architecture, patterns, and practices into our projects to accomplish more with less.</p>
<p class="calibre3">Add <code>ConstantDamage</code> as a component on the <code>PlayerCapsule</code> object (this will be a sibling component of <code>HealthSystem</code>) – so that the player’s health constantly decreases. Before we can test it out, assign the following values to the fields in the Inspector:</p>
<ul class="calibre17">
<li class="calibre15"><code>Player</code> (you may have to add <code>Player</code> to the project’s layers list first, using the <code>PlayerCapsule</code> object in the hierarchy to the <code>Player</code> layer)</li>
<li class="calibre15"><code>1</code></li>
<li class="calibre15"><code>5</code> (seconds)</li>
</ul>
<p class="calibre3">Now you can save (<em class="italic">Ctrl</em>/<em class="italic">Cmd </em>+ <em class="italic">S</em>) and enter <code>PlayerCapsule</code> <code>FirstPersonController</code> values under the <code>Player</code> header until the movement feels right in the level.</p>
<p class="calibre3">It will be difficult to see if anything is happening right now because we don’t have any visual indicators in <a id="_idIndexMarker1070" class="pcalibre1 pcalibre calibre6"/>the scene, and the variable holding the current health value isn’t visible in the Inspector. No worries, Unity has a solution for this.</p>
<h2 id="_idParaDest-199" class="calibre8"><a id="_idTextAnchor209" class="pcalibre1 pcalibre calibre6"/>Inspector Debug</h2>
<p class="calibre3">The Unity Inspector has <a id="_idIndexMarker1071" class="pcalibre1 pcalibre calibre6"/>a Debug mode that will peek into our components’ code and expose private member variable fields as read-only values. While still in Play Mode, go ahead and switch the Inspector into Debug mode by clicking the vertical ellipsis (<strong class="bold">⋮</strong>) <strong class="bold">More Items</strong> menu (also known as the kabab menu) button (<em class="italic">A</em>), then click <strong class="bold">Debug</strong> to switch from <strong class="bold">Normal</strong> mode, as seen in the following screenshot.</p>
<div><div><img alt="Figure 10.17 - Applying damage to the player" src="img/B18347_10_17.jpg" class="calibre126"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.17 - Applying damage to the player</p>
<p class="calibre3">And now, we can see the private <code>_healthCurrent</code> variable field as <code>HealthSystem</code> component, which, according to our <code>ConstantDamage</code> assignments, will decrease <code>_healthCurrent</code> by a value of <code>1</code> every <code>5</code> seconds. Be sure to switch the Inspector back to Normal Mode when you’ve finished inspecting the value (you won’t generally<a id="_idIndexMarker1072" class="pcalibre1 pcalibre calibre6"/> need to see all the additional debug information).</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Learn more about working in the Inspector: <a href="https://docs.unity3d.com/Manual/InspectorOptions.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/InspectorOptions.xhtml</a>.</p>
<p class="calibre3">Also seen in <em class="italic">Figure 10</em><em class="italic">.17</em>, the <strong class="bold">Console</strong> warning message is (<em class="italic">C</em>): <strong class="bold">HealthSystem on PlayerCapsule’ requires a sibling component that inherits </strong><strong class="bold">from IHaveHealth!</strong></p>
<p class="calibre3">This console output results from a null check we had implemented in the original <code>HealthSystem</code> code when the <code>HealthChanged()</code> method is called. It just ensures that an object – that implements the <code>IHaveHealth</code> interface – exists before calling <code>HealthChanged()</code> or <code>Died()</code> methods on it, as follows:</p>
<pre class="source-code">
    private void HealthChanged()
    {
        if (_objectWithHealth == null)
        {
            Debug.LogWarning(…
            return;
        …</pre> <p class="calibre3">That takes care of the<a id="_idIndexMarker1073" class="pcalibre1 pcalibre calibre6"/> constantly decreasing health of the player. Now, how do we recharge this Kryk’zylx power suit?</p>
<h2 id="_idParaDest-200" class="calibre8"><a id="_idTextAnchor210" class="pcalibre1 pcalibre calibre6"/>Recharging aka healing</h2>
<p class="calibre3">We’re going to create a<a id="_idIndexMarker1074" class="pcalibre1 pcalibre calibre6"/> pickup that will recharge (heal) the player, and this might be the quickest we’re going to add new functionality to our game yet! This is because we will again use previously written code and a similar approach to things we’ve already made.</p>
<p class="calibre3">From the previous 2D adventure game project, copy in the <code>PickupHeal.cs</code> and <code>Destroyer.cs</code> scripts. We’re going to place pickups for recharging/healing the player throughout the level – which is something we’ve made before, so maybe try making this on your own first? The only difference is that now we will create a ProBuilder object as a 3D pickup compared to the 2D sprite pickup we previously made.</p>
<p class="calibre3">Don’t worry; we’re still going to follow the below steps that you can check your work against. So, here we go. To make a 3D object as a healing pickup, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Make a ProBuilder object to use as a pickup (a cube, sphere, cone, etc.). With grid snapping enabled, you’ll want to use incremental snapping (hold <em class="italic">Ctrl</em>/<em class="italic">Cmd</em>) to make it a suitable size compared to the player.</li>
<li class="calibre15">On the new object you’ve made for the pickup, set <strong class="bold">MeshCollider</strong> as <strong class="bold">Convex</strong> and <strong class="bold">IsTrigger</strong> as <strong class="bold">Enabled</strong> (don’t use the <strong class="bold">SetTrigger</strong> option from ProBuilder because we want the mesh to be visible as is).</li>
<li class="calibre15">Use ProBuilder’s <strong class="bold">Vertex Colors</strong> to set a new color on the pickup object.</li>
<li class="calibre15">Add both <code>PickupHeal</code> and <code>Destroyer</code> as components on the ProBuilder object.<ol class="calibre42"><li class="upper-roman">Assign <code>Player</code> as the <code>Destroyer.DestroyMe</code> as a listener for <code>OnHealEvent</code> (ensure it’s set to <strong class="bold">Runtime Only</strong> and not <strong class="bold">Off</strong>).</li></ol></li>
<li class="calibre15">Rename the object to <code>Heal Pickup</code> (or <code>Recharge Pickup</code>) and drag it from the hierarchy to the <code>Assets/Prefabs</code> folder to make it a reusable Prefab.</li>
</ol>
<p class="calibre3">How’d you do on your own? With our healing pickup Prefab completed, we can now scatter them throughout the level in a strategic way to create good, challenging gameplay for the player. Enter Play Mode now and verify in the Inspector <strong class="bold">Debug mode</strong> that the current health value is restored when a pickup is collected. As always, you’ll continue to playtest – or better, enlist others to playtest as you observe – and balance values to provide the best player experience!</p>
<p class="calibre3">In this section, we saw how to reuse existing components to quickly add health system functionality to the player and extend functionality with a new component that applies constant damage. We<a id="_idIndexMarker1075" class="pcalibre1 pcalibre calibre6"/> also learned how to view and debug private member component values in the Inspector, then finished with more code reuse to rapidly create a 3D pickup object that recharges the player’s health.</p>
<h1 id="_idParaDest-201" class="calibre5"><a id="_idTextAnchor211" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter first covered a quick addition to our GDD to add specifics for our new 3D FPS game, including considerations for 3D-level design. We used the updated GDD to block out the interior habitat level environment from a greyboxing kit of modular parts that snap together and draw out a level map, all using Unity ProBuilder.</p>
<p class="calibre3">We continued by learning how to rapidly add an FPS player character to our game by leveraging the Unity Starter Assets first-person character controller. We also rapidly added behavior to our player with code reuse for the health system and healing pickups. Code reuse and refactoring 2D components to the 3D API method counterparts also allowed us to quickly make an animated door that opens when the player triggers.</p>
<p class="calibre3">In the next chapter, we’ll continue with the environment-level design by replacing the modular greybox kit Prefabs with art assets and decorating with more Unity-provided tooling: Polybrush and Decals. We will then finalize the environment design process by baking the 3D environment lighting to ensure high-performance rendering while comparing it with real-time lighting to evaluate the pros and cons of each.</p>
</div>
</div></body></html>