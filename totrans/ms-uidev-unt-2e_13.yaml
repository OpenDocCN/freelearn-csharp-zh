- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI Text and TextMeshPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve spent some time with UI Text objects already as they are the one of most
    basic graphical UI elements. We discussed them briefly in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085)
    because it was pretty hard to start laying out UI without having anything to display
    visually. Text objects are also always children of new Buttons, which we discussed
    in the previous chapter. However, we haven’t explored the properties of Text objects
    or how to work with them in code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore **UI Text** objects more thoroughly. We will
    also discuss **Text-TextMeshPro** objects and how they allow for even more control
    of the text in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using UI Text objects and setting their properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TextMeshPro -Text objects and setting their properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with fonts and font assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using markup format with UI Text objects and style sheets with TextMeshPro objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making Text that animates as if it’s being typed out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a system that allows for easy Text translation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom font to be used with UI Text objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Text that wraps along a curve and renders with a gradient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the examples shown in this section can be found within the Unity project
    provided in this book’s code bundle. They can be found within the **Chapter10**
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Each example image has a caption stating the example number within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the scene, each example is on its own Canvas, and some of the Canvases have
    been deactivated. To view an example on a deactivated Canvas, simply select the
    checkbox next to the Canvas’ name in the **Inspector**. Each Canvas has also been
    given its own Event System. This will cause errors if you have more than one Canvas
    activated at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2010](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2010)'
  prefs: []
  type: TYPE_NORMAL
- en: UI Text GameObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create a new UI Text object using **+** | **UI** | **Text**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The UI Text GameObject Inspector](img/B18327_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The UI Text GameObject Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: The UI Text GameObject contains the **Rect Transform** and **Canvas Renderer**
    components, as well as the **Text** component.
  prefs: []
  type: TYPE_NORMAL
- en: The UI Text component gives the object it is attached to a non-interactive text
    display. This component does not allow you to create all types of text you may
    be interested in, but it does allow most basic text displays.
  prefs: []
  type: TYPE_NORMAL
- en: The Text and Character properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Text** property changes the text that will be displayed. Whatever is typed
    within this box will be displayed within the Text object.
  prefs: []
  type: TYPE_NORMAL
- en: Below the **Text** property is a group of **Character** properties. These properties
    allow you to change the properties of the individual characters within the **Text**
    property’s field.
  prefs: []
  type: TYPE_NORMAL
- en: The **Font** property determines which font is used for the entire block of
    text. By default, the **Font** is set to **Arial**. To use any other font, you
    must import the font into your **Asset** folder. Refer to the *Working with fonts*
    section to learn how to bring in additional fonts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Font Style** provides a dropdown list of available font styles that come
    with the provided font. The possible styles are **Normal**, **Bold**, **Italic**,
    and **Bold** **And Italic**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The UI Text component’s Font Style options](img/B18327_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The UI Text component’s Font Style options'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that not all fonts will support all the listed font styles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Font Size** determines the size of the text, whereas **Line Spacing** represents
    the vertical spacing between each line of text.'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Rich Text** property is selected, you can include markup tags within
    the **Text** property field and they will appear with **Rich Text** styling rather
    than as typed. If this property is not selected, the text will display exactly
    as typed. Refer to the *Markup format* section for more information concerning
    writing with **Rich Text**.
  prefs: []
  type: TYPE_NORMAL
- en: The Paragraph properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next set of properties – the **Paragraph** properties (*Figure 10**.1*)
    – allow you to determine how the text will display within (or outside of) the
    Rect Transform’s bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Alignment** property determines where the text will align based on the
    Rect Transform bounds. You can choose both horizontal and vertical alignment options.
    The buttons represent the position relative to the Rect Transform bounds, so the
    left horizontal alignment will have the text pushed up to the edge of the Rect
    Transform’s left bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The UI Text component’s Alignment options](img/B18327_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The UI Text component’s Alignment options'
  prefs: []
  type: TYPE_NORMAL
- en: The **Align by Geometry** property aligns the text as if the glyphs or characters
    are cropped down to their opaque area rather than the area they cover. This cropping
    is based on their character map. This can give a tighter alignment but might also
    cause things to overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Horizontal Overflow** property determines what happens to text if it
    is too wide for the Rect Transform area. There are two options: **Wrap** and **Overflow**.
    **Wrap** will cause the text to continue on the next line, whereas **Overflow**
    will cause the text to expand past the rectangular area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Horizontal Overflow Example in the Chapter10 scene](img/B18327_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Horizontal Overflow Example in the Chapter10 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Vertical Overflow** property determines what happens to text if it is
    too long for the Rect Transform area. There are two options: **Truncate** and
    **Overflow**. **Truncate** will cut off all text outside of the rectangular area,
    whereas **Overflow** will cause the text to expand past the rectangular area.
    In the following figure, both Text boxes have the same text, but **Truncate**
    removes the last two lines of text due to them being outside of the rectangular
    area, while **Overflow** allows it to go outside the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Vertical Overflow Example in the Chapter10 scene](img/B18327_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Vertical Overflow Example in the Chapter10 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Best Fit** property attempts to resize the text so that all of it fits
    within the rectangular area. When you select the **Best Fit** property, two new
    properties will become available: **Min Size** and **Max Size**. These properties
    allow you to specify the range the font size can maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that depending on the text you have written, the **Horizontal Overflow**
    property may cause this to work slightly differently than you’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Best Fit Example in the Chapter10 scene](img/B18327_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Best Fit Example in the Chapter10 scene'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the two Text boxes in *Figure 10**.6* have **Best Fit** selected,
    but the first has **Horizontal Overflow** set to **Wrap**, while the second has
    it set to **Overflow**.
  prefs: []
  type: TYPE_NORMAL
- en: The Color and Material properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Color** and **Material** properties allow you to adjust the appearance
    of the Text’s font. The **Color** property will set the base rendering color of
    the Text and is the quickest way to change the font’s color. By default, this
    property is set to a very dark (not fully black) gray. The **Material** property
    allows you to assign a material to your font. This gives you more control over
    the look of the font and also allows you to apply specific shaders. By default,
    this property is set to **None**.
  prefs: []
  type: TYPE_NORMAL
- en: The Raycast and Maskable properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Raycast Target** property determines whether the object’s Rect Transform
    area will block raycasts or not. If this property is selected, clicks will not
    register on UI objects behind it. If it is not selected, items behind the object
    can be clicked. If you’d like for the Text to block raycasts, but not over its
    entire area, you can adjust the area with the various **Raycast** **Padding**
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The last property, **Maskable**, determines if the Text can be masked. We will
    discuss this in [*Chapter 12*](B18327_12.xhtml#_idTextAnchor328).
  prefs: []
  type: TYPE_NORMAL
- en: Text-TextMeshPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a bit of a limitation to what you can do with UI Text. If you find
    yourself wanting to accomplish some formatting with your text that you are unable
    to do with UI Text, you may be able to accomplish it with a TextMeshPro GameObject.
    For example, if you want to use underlined text, I recommend using a TextMeshPro
    GameObject. TextMeshPro assets allow for significantly more text control. Additionally,
    its rendering allows text to appear crisp at more resolutions and point sizes
    than what’s possible with the standard UI Text.
  prefs: []
  type: TYPE_NORMAL
- en: 'TextMeshPro used to be a paid asset in the Unity Asset Store, but it was adopted
    by Unity around March 2017 and is now available for free. However, to use TextMeshPro
    assets, you have to download the necessary resources. To download the TextMeshPro
    resources, attempt to add a TextMeshPro - Text to your scene by going to **+**
    | **UI** | **Text - TextMeshPro**; you will see the following popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: The TMP Importer](img/B18327_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: The TMP Importer'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Import TMP Essentials** to get all the necessary assets. I also recommend
    selecting **Import TMP Examples &** **Extras**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Selecting any of the TextMeshPro GameObjects from the UI menu (Text - TextMeshPro,
    Button - TextMeshPro, Dropdown - TextMeshPro, or Input Field - TextMeshPro) will
    bring up the popup from the preceding screenshot and allow you to download the
    necessary assets.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve downloaded it, you will not have to do so again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the robustness of TextMeshPro, I sadly can’t cover everything you can
    do with it within this chapter. Instead, I will provide a broad overview of its
    functionality. Luckily, the TextMeshPro asset comes with many examples and good
    documentation, which can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new **TextMeshPro - Text** GameObject, you will see a GameObject
    with the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: The TextMeshPro - Text component](img/B18327_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: The TextMeshPro - Text component'
  prefs: []
  type: TYPE_NORMAL
- en: You can also create Text-TextMeshPro GameObjects outside of Unity’s UI system
    via **GameObject** | **3D Object** | **Text-TextMeshPro**. This will render the
    text independent of the UI and without a Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The GameObject itself will be named **Text (TMP)** and, for simplicity’s sake,
    is how I will reference it.
  prefs: []
  type: TYPE_NORMAL
- en: As with all other UI objects, a **Rect Transform** and a **Canvas Renderer**
    component are attached to the GameObject as well. The graphic display of the **Text
    (TMP)** GameObject is controlled by the **TextMeshPro - Text (****UI)** component.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate the properties of the **TextMeshPro – Text (****UI)** component.
  prefs: []
  type: TYPE_NORMAL
- en: Text Input properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can enter the text you wish to display within the **Text** **Input** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: The TextMeshPro - Text component’s Text Input settings](img/B18327_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: The TextMeshPro - Text component’s Text Input settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Enable RTL Editor** property allows you to create text that will display
    from right to left which is necessary for some languages. When you select it,
    the text will appear in a second area in its right-to-left order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: The TextMeshPro - Text component’s RTL Text Input setting](img/B18327_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: The TextMeshPro - Text component’s RTL Text Input setting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Text Style** setting lets you specify a style for the text. You’ll see
    multiple pre-defined options from the dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: The TextMeshPro - Text component’s Text Style settings](img/B18327_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: The TextMeshPro - Text component’s Text Style settings'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at how to use this more thoroughly in the *Style sheets* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Main Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Main Settings** section allows you to adjust all the properties of the
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: The TextMeshPro - Text component’s Main Settings section](img/B18327_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: The TextMeshPro - Text component’s Main Settings section'
  prefs: []
  type: TYPE_NORMAL
- en: The `LiberationSans SDF (TMP_Font Asset)`. I want to point out that fonts and
    font assets are two different things. Fonts are used in UI Text GameObjects, whereas
    font assets are used in TextMeshPro GameObjects. I’ll discuss these differences,
    as well as how to import new fonts and create new font assets, in the *Working
    with* *fonts* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Font Asset** property needs a material to render. Any material that contains
    the name of the font asset will appear in the **Material Preset** list. You can
    create your own material, but when you create a new font asset, it comes with
    a default material. Whichever material is selected here will also appear at the
    bottom of the component, below the **Extra Settings**. From this area, you can
    also select the material’s shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: The TextMeshPro - Text’s material properties](img/B18327_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: The TextMeshPro - Text’s material properties'
  prefs: []
  type: TYPE_NORMAL
- en: The **Font Style** property allows you to create basic formatting for your text.
    You can select from **Bold**, **Italic**, **Underline**, **Strikethrough**, **Lowercased**,
    **Uppercased**, or **Small Caps**. You can choose any combination of the first
    four settings; however, you can only choose between **Lowercase**, **Uppercase**,
    or **Small Caps**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Font Size** property works as you would expect, but you also have the
    option to select **Auto Size**. The **Auto Size** property will attempt to fit
    the text within the bounding box of the Rect Transform as best as it can based
    on the properties you specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: The TextMeshPro - Text component’s Font Size properties](img/B18327_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: The TextMeshPro - Text component’s Font Size properties'
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the minimum (**Min**) and maximum (**Max**) font size along
    with the **WD%** and **Line** properties. The **WD%** property allows you to squeeze
    text horizontally to make the characters taller, whereas the **Line** property
    allows you to specify line height.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the color of the text using either the **Vertex Color** property
    or the **Color** **Gradient** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: The TextMeshPro - Text component’s color properties](img/B18327_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: The TextMeshPro - Text component’s color properties'
  prefs: []
  type: TYPE_NORMAL
- en: An example of using the `<color>` markup tags.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the spacing between **Characters**, **Words**, **Lines**, and **Paragraphs**
    in the **Spacing** **Options** area.
  prefs: []
  type: TYPE_NORMAL
- en: You also have significantly more **Alignment** options available to you in TextMeshPro-Text
    than you do with the standard UI Text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with UI Text, you can enable or disable **Wrapping**. You have significantly
    more **Overflow** options, however, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: The TextMeshPro - Text component’s Overflow options](img/B18327_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: The TextMeshPro - Text component’s Overflow options'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflow** and **Truncate** work similarly to those on the UI Text objects.
    Of the other options, the only one I want to mention at this time is the **Ellipsis**
    option. It will truncate the text to the text box area but add an ellipsis (…):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Text Mesh Pro Overflow Example in the Chapter10 scene](img/B18327_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: Text Mesh Pro Overflow Example in the Chapter10 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Horizontal Mapping** and **Vertical Mapping** properties allow you to
    affect the way a texture is displayed across the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18: The TextMeshPro - Text component’s Horizontal Mapping options](img/B18327_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.18: The TextMeshPro - Text component’s Horizontal Mapping options'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work you do to customize your font will be done in the **Text Input**
    section and the **Main Settings** section, but let’s look at some more nuanced
    settings that you will adjust with your fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Extra Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Extra Settings** menu has to be expanded to be visible. It allows you
    to adjust some less-common settings of the font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19: The TextMeshPro - Text Extra Settings section](img/B18327_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: The TextMeshPro - Text Extra Settings section'
  prefs: []
  type: TYPE_NORMAL
- en: The most notable properties in this menu are the ability to add **Margins**
    and the ability to enable **Raycast Target**.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you can specify whether or not you want to **Enable Kerning** or allow
    **Extra Padding**. Selecting **Kerning** will use the kerning data provided by
    the font file. Selecting **Extra Padding** will add a little padding around the
    glyphs of the sprite on its sprite atlas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn about any of the properties I glossed over or skipped here: [https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/TMPObjectUIText.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/TMPObjectUIText.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: TextMeshPro Project Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to being able to adjust the individual settings of each TextMeshPro
    object you have within your scene via their components, you can also adjust TextMeshPro
    project-wide settings via the **Project Settings** (**Edit** > **Project Settings**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20: The TextMeshPro – Project Settings](img/B18327_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: The TextMeshPro – Project Settings'
  prefs: []
  type: TYPE_NORMAL
- en: These let you set the various defaults for newly created TextMeshPro objects.
    You can learn more about each property at [https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/Settings.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/Settings.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Working with fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s extremely likely that you won’t want to use the default **Arial (UI Text)**
    or **Liberation Sans (TMP Text)** fonts and will want to bring a custom font into
    your project. Let’s explore how you can both find these text resources and use
    them in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You do not have to install a font onto your computer (to use within programs
    outside of Unity) to use the font within Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Importing new fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The font file formats accepted by Unity are `.tff` (TrueType) and `.otf` (OpenType).
    You can get these files in multiple places. My favorite places to find fonts are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Google* *Fonts*: [https://fonts.google.com/](https://fonts.google.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DaFont*: [http://www.dafont.com/](http://www.dafont.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Font* *Squirrel*: [https://www.fontsquirrel.com/](https://www.fontsquirrel.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the fonts on *Google Fonts* are open source and are free for personal or
    commercial use (at least at the time of writing this book), but the fonts on *Font
    Squirrel* and *DaFont* have varying licensing options. Ensure that any font you
    get has a licensing agreement that meets your needs before you use it.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve downloaded the font of your choice, simply drag the font into your
    project’s `Assets` folder. I highly recommend that you create a folder called
    `Fonts` within your `Assets` folder in which you place all of your font files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can adjust the font’s import properties in the **Inspector** if you
    so choose. The following screenshot shows the import settings of the **BungeeShade-Regular**
    font, which has been downloaded from Google Fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21: The Inspector of the Bungee Shade-Regular font](img/B18327_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: The Inspector of the Bungee Shade-Regular font'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can adjust quite a few of the settings concerning how the font will
    be handled by the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Font Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Font Size** setting determines how large the font will appear on its Unity-created
    texture atlas. Increasing or decreasing the **Font Size** setting will change
    the size of the various glyphs on the texture atlas. If your font appears fuzzy
    in your game, adjusting the **Font Size** setting may improve its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Rendering Mode** settings tell Unity how the glyphs will be smoothed.
    The possible options are **Smooth**, **Hinted Smooth**, **Raster**, and **OS Default**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Smooth** rendering mode is the fastest rendering mode. It uses anti-aliased
    rendering, which means it will smooth out jagged, pixelated edges. The **Hinted
    Smooth** rendering mode will also smooth out edges, but it will use the “hints”
    contained within the font’s data files to determine how to fill in those jagged
    edges. This is a slower rendering mode than **Smooth** but will likely look crisper
    and be easier to read than **Smooth**. The **Hinted Raster** rendering mode does
    not provide anti-aliasing and instead provides aliased or jagged edges. This is
    the crispest and the quickest of the rendering modes. **OS Default** will default
    to whatever the operating system’s preferences are set to on Windows or Mac OS.
    This will select from **Smooth** or **Hinted Smooth**.
  prefs: []
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Character** property determines which character set of the font will
    be imported into the font texture atlas. There are six options: **Dynamic**, **Unicode**,
    **ASCII default set**, **ASCII upper case**, **ASCII lower case**, and **Custom
    set**:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the **Character** property to **Dynamic** (which is the default) will
    only include the characters that are needed. This reduces the texture size needed
    for the font and, in turn, the download size of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode** is used for languages that have characters that are not supported
    in an ASCII character set. So, for example, if you want to display text in Japanese,
    you will want to use **Unicode**.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to include **Unicode** characters in your scripts, you need to
    save them with UTF-16 encoding. This will allow you to type **Unicode** characters
    directly in your code as strings so that they can display in your Text objects
    on screen.
  prefs: []
  type: TYPE_NORMAL
- en: The *Noto fonts* provided by *Google Fonts* provide support for many languages
    and can be very helpful if you want to create a game that is translated into multiple
    languages. The *Noto fonts* can be found at [https://www.google.com/get/noto/](https://www.google.com/get/noto/).
  prefs: []
  type: TYPE_NORMAL
- en: '**American Standard Code for Information Interchange** (**ASCII**) is a set
    of characters from the English-language character set. The three variations of
    **ASCII** character sets allow you to choose between the full set, only uppercase,
    or only lowercase characters. You can find a list of the **ASCII** characters
    at [http://ascii.cl/](http://ascii.cl/).'
  prefs: []
  type: TYPE_NORMAL
- en: A **Custom set** character will allow you to import your own texture atlas for
    your own custom font. I find this most commonly used when developers want beautified
    text with an extremely limited character set, such as numbers only.
  prefs: []
  type: TYPE_NORMAL
- en: Ascent Calculation Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **ascent** of a font is the distance between the font’s baseline and the
    highest glyph point. There is no standard for how this supposed *highest glyph
    point* is determined, so different modes are available in Unity to choose from,
    each determining a different *highest glyph point*. The **Ascent Calculation Mode**
    property determines how the ascent will be calculated. There are three options
    for how this calculation will be chosen: **Legacy version 2 mode (glyph bounding
    boxes)**, **Face ascender metric**, and **Face bounding box metric**. The method
    chosen may affect the vertical alignment of the font.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Legacy version 2 mode (glyph bounding boxes)** measures the ascent using
    the highest point reached by any one of the font’s glyphs listed within its character
    set as the height. This only uses those listed in the character set, and not all
    glyphs may be included within that set. **Face ascender metric** uses the face
    ascender value that is defined to measure the ascent, whereas **Face bounding
    box metric** uses the face bounding box to measure the ascent.'
  prefs: []
  type: TYPE_NORMAL
- en: Typography is a lot more complicated than many people realize, and it’s too
    complicated to fully cover in this book – not to mention I am no typography expert.
    If you’d like to learn more about glyph metrics, a good introduction can be found
    at [https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.xhtml](https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic font settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you import your font with a dynamic character set, two new settings are
    made available: **Include Font Data** and **Font Names**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Include Font Data** builds the font file with the game. If this is not selected,
    the game will assume that the player has the font installed on their machine.
    If you are using a font you have downloaded from the web, it is a pretty safe
    bet that the end user will not have the font installed and you should leave **Include
    Font** **Data** selected.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Font Names** is the list of names of fonts that Unity will fall back on if
    it cannot find the font. It will need to fall back on this font name if the font
    doesn’t include the requested glyph or the **Incl. Font Data** property was deselected
    and the user does not have the font installed on their machine. If Unity cannot
    find the font, it will search the game’s project folder or the user’s machine
    for a font matching one of the names listed in **Font Names**. Once the fonts
    have been typed into **Font Names**, the appropriate fonts will be listed in the
    **References to other fonts in** **project** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22: The Inspector of the Roboto-Regular font](img/B18327_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: The Inspector of the Roboto-Regular font'
  prefs: []
  type: TYPE_NORMAL
- en: If Unity cannot find one of the fonts listed, it will use a font provided in
    a predefined list of fallback fonts hard-coded within Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Some platforms don’t have built-in fonts in their system or can’t access built-in
    fonts. These platforms include WebGL and some console systems. When building to
    these platforms, Unity will always include fonts, regardless of the setting chosen
    for **Include** **Font Data**.
  prefs: []
  type: TYPE_NORMAL
- en: Importing font styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you bring in a font that has multiple styles (that is, bold, italic, or
    bold and italic), you must bring in all the font styles for them to appear properly.
    Bringing the fonts into your project may not be sufficient for the font to recognize
    which fonts should be used when the **Bold**, **Italic**, and **Bold and Italic**
    font styles are selected, however. For example, the following screenshot shows
    the **Roboto-Regular** Google Font with the **Bold and Italic** **Font Style**
    on the top line of text and the **Roboto-BoldItalic** Google Font with the **Normal**
    **Font Style** on the bottom line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23: Styles of the Roboto font](img/B18327_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.23: Styles of the Roboto font'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the **Font Style** property were working correctly, the two lines should
    match. However, as you can see, they do not. To make the fonts appear correctly,
    select the regular font, retype the **Font Name** property to make all the appropriate
    ones appear in the font list (as shown in *Figure 10**.22*), and hit **Apply**.
    After doing so, the two fonts should appear the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24: Styles of the Roboto font applied correctly](img/B18327_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.24: Styles of the Roboto font applied correctly'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed how to import fonts, let’s look at how to create custom
    fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Custom fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a custom font by selecting **Create** | **Custom Font** from
    the project window. To use a custom font, you will need a font material and font
    texture. How to do this is covered in the *Examples* section of this chapter.
    Once you create your custom font, you will be given the following properties to
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.25: A custom font’s Inspector](img/B18327_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.25: A custom font’s Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: The **Line Spacing** property specifies the distance between each line of text.
  prefs: []
  type: TYPE_NORMAL
- en: The `0`, which is ASCII index `48`. Therefore, you would set the `48`, indicating
    the first character in this font’s character set is the character 0\. You can
    determine the ASCII index number for individual characters at [http://ascii.cl/](http://ascii.cl/).
  prefs: []
  type: TYPE_NORMAL
- en: The **Tracking** property represents the spacing between characters for a full
    line of text. It allows the spacing between all characters to be uniform.
  prefs: []
  type: TYPE_NORMAL
- en: The **Kerning** property has been replaced with the **Tracking** property. **Tracking**
    and **Kerning** are both properties related to spacing between characters, but
    they are different. For more information, check out [http://www.practicalecommerce.com/Typography-101-The-Basics](http://www.practicalecommerce.com/Typography-101-The-Basics).
  prefs: []
  type: TYPE_NORMAL
- en: '**Character Spacing** is the amount of space between characters, whereas **Character
    Padding** is the amount of padding surrounding individual characters before the
    spacing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Character Rects** property determines how many total characters are in
    your font. Changing the number from 0 to any positive number will provide a list
    of **Elements** that can be expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.26: The Character Rects of a custom font](img/B18327_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.26: The Character Rects of a custom font'
  prefs: []
  type: TYPE_NORMAL
- en: Each element represents a character on your character set. The **Index** is
    the ASCII index of the specified character.
  prefs: []
  type: TYPE_NORMAL
- en: The `.2` and the `.5`. This should be consistent throughout all of your characters.
    The **X** and **Y** values are determined by multiplying the **W** and **H** values
    by the column or row that the character is located in.
  prefs: []
  type: TYPE_NORMAL
- en: The `50` and `-50`, respectively. To be perfectly honest, I am not exactly sure
    why the height property is always negative and I can’t seem to find the answer.
    I suspect that it has something to do with the fact that this uses texture coordinates.
    The **X** and **Y** values of **Vert** represent a shift in position, where these
    numbers can be negative or positive.
  prefs: []
  type: TYPE_NORMAL
- en: The **Advance** setting represents the pixel distance between the specific character
    and the next character.
  prefs: []
  type: TYPE_NORMAL
- en: The **Flipped** setting indicates if the glyph is flipped of how it should be
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the *Examples* section for an example of calculating the **UV**,
    **Vert**, and **Advance** values of a custom font.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, not all the properties for custom fonts are fully defined
    within Unity’s documentation and a few of these properties are a bit ambiguous.
    For example, **Convert Case** used to be a dropdown menu, and it is unclear to
    me how it is now used since it only accepts a number input. Perhaps, in the future,
    these properties will be better defined and the manual will be updated to reflect
    the new changes made, at [https://docs.unity3d.com/Manual/class-Font.xhtml](https://docs.unity3d.com/Manual/class-Font.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Font assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that TextMeshPro objects need to use font assets, not fonts. So, if you’ve
    downloaded some fonts for your project, you won’t see them as possible font options
    with a TextMeshPro object. If you’ve imported the TextMeshPro examples, you may
    have few options other than Liberation Sans available to you. To use a different
    font in a TextMeshPro GameObject, you cannot simply drag a new font into the **Font
    Asset** slot; you must create a Font Asset via the **Font** **Asset Creator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the **Font Asset Creator**, select **Window** | **TextMeshPro - Font
    Asset Creator**. This will allow you to convert a font file into a font asset
    that can be used by TextMeshPro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.27: The Font Asset Creator window](img/B18327_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.27: The Font Asset Creator window'
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few settings that can be controlled via the **Font Asset Creator**.
    You can find a breakdown of these settings at https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/FontAssetsCreator.xhtml?q=font%20asset%20creator.
    I will cover the process of creating a font asset in the *Examples* section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the markup format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML-like markup language can be included within the text field of the `<tag>the
    text you wish to format</tag>` format, where you replace `tag` with the appropriate
    tag. These tags can be nested, just as they can in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: To use markup format on a **Text** object, you must first select the **Rich
    Text** property within the **Text** component. By default, it works within a **TextMeshPro**
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This formatting allows you to change the font style, font color, and font size.
    The following chart lists the tags necessary to perform the specified formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Tag** |'
  prefs: []
  type: TYPE_TB
- en: '| `Bold` | `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `Italic` | `i` |'
  prefs: []
  type: TYPE_TB
- en: '| `Color` | `color` |'
  prefs: []
  type: TYPE_TB
- en: '| `Size` | `size` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.1: Formats and their tags'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how to change the style of a font with markup.
  prefs: []
  type: TYPE_NORMAL
- en: Font style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can change the font style of text using the bold and italic tags.
  prefs: []
  type: TYPE_NORMAL
- en: To add a bold font style to text, add the `<b></b>` tags around the text you
    wish to bold. To add an italic font style to text, add the `<i></i>` tags around
    the text you wish to italicize.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_10.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 10.2: Examples of formatting tags'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how to change the color of a font with markup.
  prefs: []
  type: TYPE_NORMAL
- en: Font color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can change the color of your font with either the hex value representation
    of a number or using the color name. To change the color of the text, add `<color=value></color>`
    around the text you wish to color, where you place either the hex value (following
    a #) or the color name where the word value appears.'
  prefs: []
  type: TYPE_NORMAL
- en: Only a limited set of colors have names that can replace the hex values. The
    color names that are recognized are black, blue, brown, cyan, darkblue, green,
    grey, lightblue, lime, magenta, maroon, navy, olive, orange, purple, red, silver,
    teal, white, and yellow. You can also use aqua in place of cyan and fuchsia in
    place of magenta.
  prefs: []
  type: TYPE_NORMAL
- en: When using the color tag, any text not surrounded by the color tag will be colored
    based on the **Color** property selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows how to use the color tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_10.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 10.3: Color formatting tag examples'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how to change the size of a font with markup.
  prefs: []
  type: TYPE_NORMAL
- en: Font size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To change the font size, add the `<size=#></size>` tags around the text you
    wish to resize. Any text not within the tag will be sized based on the `size`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_10.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 10.4: Examples of multiple font size tags'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve looked at the ways we can format fonts with markup. Now, let’s
    look at how to format a font using a style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Using style sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the markup tags described in the preceding section, TextMeshPro
    objects can also use style sheet tags. As you may recall from *Figure 10**.9*,
    the **TextMeshPro - Text (UI)** component has a property labeled **Text Style**
    with ten options in its dropdown. From there, you can select any one of the styles
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.28: The various default styles from the default style sheet](img/B18327_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.28: The various default styles from the default style sheet'
  prefs: []
  type: TYPE_NORMAL
- en: All of these styles are pre-defined by the **Default Style Sheet** option that’s
    assigned for the **TextMeshPro Settings** within the **Project Settings** (as
    we discussed in the *TextMeshPro Project* *Settings* section).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.29: The Default Style Sheet setting from the Project Settings](img/B18327_10_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.29: The Default Style Sheet setting from the Project Settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the `Default Style Sheet (TMP_Style Sheet)` object within the `Default
    Style Sheet` within the `Assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30: The Default Style Sheet asset within Resources](img/B18327_10_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.30: The Default Style Sheet asset within Resources'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then view the `Default Style Sheet` asset’s **Inspector** and see how
    each of the default style sheet tags are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.31: The Default Style Sheet properties](img/B18327_10_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.31: The Default Style Sheet properties'
  prefs: []
  type: TYPE_NORMAL
- en: You are free to change the names and properties of any of these tags by editing
    this asset. You can add and remove tags.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a whole new style sheet and make it the default style sheet.
    To create a new style sheet, right-click within the `Assets` folder and select
    **Create** | **TextMeshPro** | **Style Sheet**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply these styles via the dropdown, as I demonstrated at the beginning
    of this section, or you can assign them to portions of the text via markup format
    using the `<style>` tag. For example, if you wanted to display the text shown
    in *Figure 10**.32*, you could do so by typing `Here''s <style="Title">how</style>
    to use styles <style="Link">in-line</style>!` into the **Text** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32: Styles used in-line in a markup fashion](img/B18327_10_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.32: Styles used in-line in a markup fashion'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the how to format fonts and with markup, let’s move
    on to explore how you can use the various Text component properties, with translations.
  prefs: []
  type: TYPE_NORMAL
- en: Translating text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odds are, if you are creating a game with text in it, you might want to translate
    that text. To make sure your games are easily translatable, there are a few key
    things that you can do to make the transition to different languages easier.
  prefs: []
  type: TYPE_NORMAL
- en: You want to make sure that the text you plan to translate will still fit within
    the necessary area if it gets longer or shorter when translated. You can accomplish
    this by using the **Align By Geometry** and **Best Fit** properties of the **Text**
    component. This will make the text fit within the required space. You could also
    use the Content Size Fitter (which we discussed in [*Chapter 7*](B18327_07.xhtml#_idTextAnchor106))
    to make sure any Panels around the text will shrink or expand to fit perfectly
    around the text. You can use the first option if you don’t mind the font size
    varying across languages. You can use the second if you want the font size to
    remain consistent across languages. Keep in mind that some languages can render
    a single phrase in a very small amount of space, while others will render it in
    a very large amount of space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use fonts that can support the languages you will be translating to. If possible,
    a single font that works across all languages will be preferred as it will maintain
    a consistent style across all translations. You spent so much time picking the
    perfect font! You don’t want all that to be thrown out the window when you translate
    your game and the font won’t render all the glyphs of the language! It’s not a
    glamorous or particularly stylish font, but one that will translate into *many*
    languages is the Noto Sans font family. If you know you’ll be translating into
    a lot of languages, you might want to consider it: [https://fonts.google.com/noto/fonts](https://fonts.google.com/noto/fonts).'
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to translate into a language that renders right-to-left, such as
    Arabic, you will need to use a TextMeshPro object, rather than a Text object,
    as it will let you render text from RTL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, TextMeshPro, while able to render text from right-to-left,
    does not fully support right-to-left languages. If you’d like to display Arabic,
    Farsi, and/or Hebrew in your game’s UI, I recommend the following package: [https://github.com/pnarimani/RTLTMPro](https://github.com/pnarimani/RTLTMPro).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also appreciate the following tutorial on rendering right-to-left text:
    [https://allcorrectgames.com/insights/unity-from-right-to-left/](https://allcorrectgames.com/insights/unity-from-right-to-left/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is also an extremely helpful resource as it breaks down how to
    architect a localization solution for your project and also discusses right-to-left
    text translation: [https://phrase.com/blog/posts/localizing-unity-games-official-localization-package/](https://phrase.com/blog/posts/localizing-unity-games-official-localization-package/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Examples* section, I provide a small example that focuses on the UI
    layout and font aspects of translation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll expand on the scene we’ve been building further and also
    add a new scene that occurs between our start screen and our main game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animated text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a new scene that acts like a *cut scene* between our
    start screen and our gameplay scene. It will include our cat introducing itself.
    The text will animate as if it is being typed, and the user will have the option
    to speed it up by pressing a button. Once the text is fully displayed, pressing
    that same button will either show the next block of text or go to the gameplay
    scene. The text windows will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.33: The end result of our animated text box](img/B18327_10_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.33: The end result of our animated text box'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a prefab to save us some development time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Background Canvas prefab and a new scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can start making animated text, we need to build out our scene. In
    both the scenes we have created so far, we used `Background Canvas` to display
    the background image, and we will use it again in a new scene.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will use this `Background Canvas` multiple times, we should create
    a `Background Canvas` prefab. As we learned in a previous chapter, a **prefab**
    is a reusable GameObject. Using a prefab in a scene creates an instance of the
    prefab within the scene. If you make a change to the saved prefab, the change
    will be reflected in all unbroken prefab instances across all scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a reusable `Background Canvas` prefab GameObject, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter9-Examples` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Background Canvas` GameObject from the Hierarchy into the `Prefabs`
    folder within the `Background Canvas` should now be blue in the **Hierarchy**
    (symbolizing that it is a prefab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s create a new scene in which we will use this `Background Canvas` prefab.
    Create a new scene called `Chapter10-Examples-IntroScene` and save it in the `Scenes`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Background Canvas.prefab` into the new scene from the **Project**
    view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `Main Camera` to the `Background Canvas` and make sure that **Sorting
    Layer** is set to **Background**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can start setting up the windows that will hold our animated text.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the text box windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the text box windows that will display our text, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new UI Canvas and name it `Text Canvas`. Set its **Canvas** and **Canvas
    Scalar** properties, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.34: The Text Canvas Inspector](img/B18327_10_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.34: The Text Canvas Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new UI Image and name it `TextHolder1`. Set its anchor and pivot to
    `uiElements_10` to the **Source Image**, and then select **Set Native Size** to
    cause the image’s size to be set to 223 x 158.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This Panel will hold an image of our cat, some text, and a continue button.
    Utilizing anchors, pivots, and stretching, lay out the UI objects as children
    of `TextHolder1` so that they appear as illustrated:![Figure 10.35: TextHolder1
    and its children](img/B18327_10_35.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.35: TextHolder1 and its children'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that in the preceding screenshot, the `Text` child’s Rect Transform does
    not stretch all the way across the image of `TextHolder1`. That way, the text
    won’t cross over the white area of the window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ll want to be able to turn this window on and off, so add a `TextHolder1`.
    Leave the settings at their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s change the font. Go to https://www.dafont.com/milky-coffee.font and
    download the font named *Milky Coffee*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Milky Coffee` font to your `Assets/Fonts` folder and then drag it into
    the `Text` object’s **Text** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the font `18`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate `TextHolder1` and name the duplicate `TextHolder2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the text on the `Text` child of `TextHolder1` with `"Hello there!"`
    and the text on the `Text` child of `TextHolder2` with `"I'm a cat and, for some
    reason, I'm` `collecting food!"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s hide and disable `TextHolder2` by disabling `0` on the **Canvas** **Group**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we’re ready to start animating our text!
  prefs: []
  type: TYPE_NORMAL
- en: Animating the text box text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have our layout set up, we can animate our text. To do this, we
    will need to create a new script. This script will control the animation of the
    text, as well as load the next scene after all the text has been displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create animated text that looks like it’s typing out, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things we want to group to create the animated text box: the
    Panel that holds the text, the text object that will display the message, and
    the string that we want to display. So, to group them all, we will need to create
    a class. Create a new class called `DialogueBox`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the script so that it does not inherit from `MonoBehaviour` and looks
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I’ve used `[System.Serializable]` so that we will be able to see these values
    in the Inspector. Remember we need to use the `UnityEngine.UI` namespace whenever
    we use a `Text` type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new C# script called `DialogueSystem.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be writing code that implements scene loading and uses various `System`
    methods and collections. Therefore, we need to include the following namespaces
    at the top of our new script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s begin our variable declaration. First, we will create a list of
    `DialogueBox` objects called `dialogueBoxes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `private` variable that will hold the name of the scene that loads
    after the text is done animating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I marked it with the `SerializeField` attribute so that it can be assigned via
    the Inspector while still being private.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we proceed, let’s assign these variables in the Unity Editor. Attach
    the `DialogueSystem.cs` script to the `Text Canvas` GameObject. You should see
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.36: The Dialogue System component](img/B18327_10_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.36: The Dialogue System component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the plus sign at the bottom of the `DialogueBox` class serializable,
    we should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.37: The Dialogue System component with two Elements](img/B18327_10_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.37: The Dialogue System component with two Elements'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s drag the appropriate elements into the appropriate fields. Drag `TextHolder1`
    into `TextHolder2` into **Element 1**’s **Text Holder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Text` child object of `TextHolder1` into `Text` child object of `TextHolder2`
    into **Element 1**’s **Text** **Display Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, update the `Hello there!` and `I'm a cat and, for some reason, I'm collecting
    food!` respectively. We will be generating the text within the text boxes via
    code. In the previous subsection, we added the text to the text boxes that we
    placed in the scene. However, due to the code we will write, that step will be
    rendered unnecessary. It was helpful adding the text to those text boxes, though,
    because we were able to see exactly how it will display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the Editor, for now, is assign the scene that
    the game will navigate to once the dialogue has completed. We’ll create a scene
    called `Chapter10-Examples` later, but, for now, let’s just assign the `Chapter9-Examples`
    scene to the `Chapter9-Examples`. Your completed component should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.38: The Dialogue System component with all its properties filled
    out](img/B18327_10_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.38: The Dialogue System component with all its properties filled
    out'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can go back to our `DialogueSystem.cs` script. We aren’t quite done
    with our variable declaration. We need two variables that will track the string
    in our dialogue we wish to display, as well as which character within that specific
    string we are displaying. Add the following variable declaration to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that these two variables are not public or serialized and thus cannot be
    adjusted in the Inspector. Their values will be adjusted by the script. The `whichText`
    variable will allow us to switch between displaying the first string in the dialogue
    list and the second. The code we will write will easily be extendable to more
    strings. The `positionInString` variable will keep track of which character is
    being typed out by the animation. We want to keep track of this so that we can
    tell whether the text is being sped up by the user or if they have already read
    the whole text and just want to proceed to the next part.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will use a coroutine to animate our text one letter at a time. Coroutines
    work very well for timed and scheduled events. The last variable we need to declare
    will allow us to reference our coroutine so that we can easily stop it. Declare
    the following variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The coroutine that will control the text animation is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code finds the current string in the current dialogue box using the `whichText`
    variable and loops through all of its characters. With each step of the loop,
    the text property of the UI Text object is updated to display the first `i` characters
    of the string, where `i` represents the current step of the loop. It then increases
    the `positionInString` variable and waits a tenth of a second to display the next
    character by proceeding to the next step in the loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before the preceding code will do anything, we need to start our coroutine.
    In the process of starting it, I also want to assign the `textPusher` variable.
    Add the following to the `Start()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you play your game now, you should see the *Hello there!* text type out within
    your scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Currently, the coroutine only loops through the string in the first `DialogueBox`.
    We need to make it proceed to `DialogueBox` in the list by increasing the `whichText`
    variable. We also need to add functionality to allow players to show all the text
    so that they don’t have to wait for it to fully animate if they’re impatient.
    Let’s create a function that will be called by the press of our buttons. We’ll
    also create a function that compartmentalizes the enabling and disabling of a
    Canvas Group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a button is pressed, the code first determines whether the whole string
    has been displayed using the `positionInString` variable. If the `positionInString`
    variable is smaller than the total characters in the current string, it displays
    the complete string; otherwise, it proceeds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the `positionInString` variable is less than the total characters in the
    current string, the coroutine is stopped early with `StopCoroutine(textPusher)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `text` property of the `textDisplayBox` is updated to display the full string,
    and the `positionInString` is set to the length of the string; that way, if the
    button is clicked again, this function will know that it can proceed to the next
    step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the `positionInString` variable is not less than the total characters in
    the current string, the current Canvas Group is deactivated, and then the `whichText`
    variable is increased. Once this variable is increased, the code checks whether
    any more text boxes need animating. If there are not, the next scene loads. If
    more text boxes need animating, the `positionInString` variable is reset to `0`,
    so the very first character in the string will be displayed first. The new Canvas
    Group is now activated, and the `textPusher` variable is reassigned so that the
    coroutine loop will play again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that our code is done, we just need to hook up our buttons to perform the
    function described in the previous step. For both buttons on both `TextHolder`
    objects, set the `ProceedText()` function in the `DialogueSystem` script attached
    to the `Text Canvas`. Now, when you play the game, clicking on the button when
    the text isn’t finished typing will cause it to fully display, and clicking on
    the button when the text has fully displayed will display the next dialogue or
    the next scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To improve on this, you can also create a prefab of the `TextHolder` object
    and write code that instantiates into the scene based on `Dialogue List`. I recommend
    implementing this change if you will be making a more complicated dialogue system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code example provided in this book’s code bundle includes code comments
    not shown here as it was too cluttered to display in this text.
  prefs: []
  type: TYPE_NORMAL
- en: Translating the dialogue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s expand upon our animated text example so that it includes translations.
    This is a basic example to demonstrate how to access certain properties of Text
    components and isn’t necessarily architected in a way that would be sustainable
    for a large project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that I used Google Translate to obtain these translations, so they
    may not be fully accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18327_10_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.39: Google Translate'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add translation to the animated text example we completed previously, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DialogueBox.cs` script and add the following namespace to the top
    of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a subclass to this script that will group all the translations with
    the appropriate settings. We’ll use this subclass to hold information about not
    only the translated text but the appropriate font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `languageKey` string will be used as a key to finding the appropriate translation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add a list that will hold all of the translations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your `DialogueSystem` component should now be updated to look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18327_10_40.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.40: The Dialogue System component with translations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a few translations to the `translations` list. We’ll use the ISO
    639-1 two-digit codes as keys for each language. Add the following four key codes
    to the translation list to indicate Spanish, Japanese, Simplified Chinese, and
    Korean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.41: The translation keys filled out on the Dialogue Boxes](img/B18327_10_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.41: The translation keys filled out on the Dialogue Boxes'
  prefs: []
  type: TYPE_NORMAL
- en: To save yourself time with entering these keys, copy this list by right-clicking
    on the word `I'm a cat and, for some reason, I'm collecting food!` element, paste
    this list to its **Translations** by right-clicking and selecting **Paste**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s enter the translations. Enter the following data into the **Translated**
    **String** properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Key** | **Hello there!** | **I’m a cat and, for some reason, I’m** **collecting
    food!** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| es | ¡Hola! | ¡Soy un gato y, por alguna razón, estoy recolectando comida!
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ja | こんにちは！ | 私は猫で、なぜか食べ物を集めています！ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| zh | 你好呀！ | 我是一只猫，出于某种原因，我正在收集食物！ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ko | 안녕! | 나는 고양이고, 왠지 모를 음식을 모으고 있다! |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Table 10.5: The translation strings to enter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’ll notice that the Unity Engine is capable of rendering these languages
    in the Inspector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now need to assign some fonts to each language. The current font, `Milky
    Coffee`*,* does not support these four languages. If we try to replace the text
    with one of these translations, the engine will render any non-supported glyph
    in a font that does support it but render all supported glyphs (such as punctuation)
    in the `Milky Coffee` font. This will result in an inconsistent style that honestly
    doesn’t look great. For example, as shown in the following figure, the comma and
    exclamation point are not in the same font as the rest of the text:![Figure 10.42:
    The dialogue box with the Korean text rendering in two fonts](img/B18327_10_42.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.42: The dialogue box with the Korean text rendering in two fonts'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Therefore, we’ll want to change the font whenever the translation occurs to
    one that we specifically choose. I will use the `ZCOOL KuaiLe` font for the Simplified
    Chinese translation and `RocknRoll One` for all the others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the fonts from the following locations and add them to your `Assets/Fonts`
    folder:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://fonts.google.com/specimen/ZCOOL+KuaiLe](https://fonts.google.com/specimen/ZCOOL+KuaiLe)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://fonts.google.com/specimen/RocknRoll+One](https://fonts.google.com/specimen/RocknRoll+One)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assign the correct fonts to each of the translations. Your two elements in
    your **Dialogue Boxes** list should look as follows:![Figure 10.43: The two dialogue
    boxes with all properties completed](img/B18327_10_43.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.43: The two dialogue boxes with all properties completed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I’ve included the option to change the font style, but I’m going to leave them
    all at **Normal** for this example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s write the code that will translate our text. Add the following variable
    declaration to the top of the `DialogueSystem.cs` script so that it will be the
    first variable declaration. This will be used to determine which language our
    game should display at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to the bottom of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will find which of the translations have the key designated by the
    `currentLanguage` variable. It will then change the `dialogue` variable, the `font`,
    and the `fontStyle` to the appropriate values. If the `currentLanguage` variable
    is not found in any of the `languageKey`s, `index` will equal `-1` and no changes
    will be implemented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make sure the translation happens, we need to call the method from the `Awake()`
    method. Add the following above your `Start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to the Editor and enter `es` into the **Current Language** slot. You’ll
    see that the dialogue now translates and changes font when you press play. However,
    there is a problem displaying the text. You’ll notice that the text gets cut off
    in the second Panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.44: The Spanish translation getting cut off](img/B18327_10_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.44: The Spanish translation getting cut off'
  prefs: []
  type: TYPE_NORMAL
- en: Recall, from the *Translating text* section, that you should not only make sure
    that your font will render the text but that your text boxes will have enough
    room for the translated text, which may be much longer (especially when rendered
    in a different font)! The easiest way to fix this is to use the `Text` objects
    in the Hierarchy and then select the **Best Fit** setting from their **Text**
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the `18`. This will stop the text from getting too large.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A downside to using **Best Fit** in this example is the font size changes as
    the text animates. It’s not ideal. But, to maintain the text box size, we didn’t
    have much choice – for now! After we learn about Scroll Rects and Masks in [*Chapter
    12*](B18327_12.xhtml#_idTextAnchor328), we can maintain the font size while scrolling
    through the text.
  prefs: []
  type: TYPE_NORMAL
- en: Custom font
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a step away from building out our scenes for a moment to explore
    making a custom font. We won’t be using this custom font in the scenes we’ve been
    working on, but the process of creating a custom font is still important to cover.
    We’ll create a custom font that displays the numbers 0 through 9 using the following
    sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.45: The custom font we will create](img/B18327_10_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.45: The custom font we will create'
  prefs: []
  type: TYPE_NORMAL
- en: The sprites used to create the font are modified from the free art asset found
    at [https://opengameart.org/content/shooting-gallery](https://opengameart.org/content/shooting-gallery).
  prefs: []
  type: TYPE_NORMAL
- en: To create an evenly spaced sprite sheet for this font, I used the TexturePacker
    program, along with Photoshop. The process can be done entirely with a photo editing
    software such as Photoshop, but TexturePacker simplifies the process. TexturePacker
    can be found at [https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker).
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating a custom font is time-consuming and kind of a pain.
    To create a custom font, you have to put in coordinate locations for each character
    you plan on rendering with the font, so I don’t recommend it for anything other
    than numbers or a very limited character set.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a custom font with a more robust character set, check out the Unity
    asset store for various options on streamlining the bitmap font process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the custom font displayed in the preceding figure, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Custom Fonts` within your `Assets/Fonts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `customFontSpriteSheet.png` file within the code bundle and drag the
    file into the folder you created in *Step 1*. The sprite sheet appears as follows:![Figure
    10.46: The custom sprite sheet](img/B18327_10_46.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.46: The custom sprite sheet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When manually creating a custom font, your characters must be spaced evenly.
    This will make your life significantly easier while entering the settings of the
    individual characters. You can leave the sprite sheet’s import settings at the
    defaults of **Sprite (2D and UI) Texture Type** and **Single** **Sprite Mode**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A custom font requires a material to render. Create a new material by right-clicking
    in your `Custom Fonts` folder and selecting `CustomFontMaterial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `CustomFontMaterial` to bring up its `customFontSpriteSheet.png` into
    the square next to **Albedo** in **Main Maps**. Once you do so, the material’s
    preview image should update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.47: The custom font material](img/B18327_10_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.47: The custom font material'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to change the material’s shader. There are a few different options
    you can use for the shader: you can use **UI** | **Default** or any of the unlit
    or unlit UI options. My preference is to use **GUI** | **Text Shader** as I tend
    to have the best luck with it rendering correctly, and I prefer the way it displays
    in the **Project** view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.48: The custom font material updated](img/B18327_10_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.48: The custom font material updated'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create our custom font. Within the `Custom Fonts` folder, right-click
    and select `CustomFont`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `CustomFont` and assign `CustomFontMaterial` to the **Default** **Material**
    slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The properties under `1` for now. We will change it to `10` once we have the
    properties that will repeat for all characters entered. When you set the `1`,
    you should see the properties of **Element** **0** appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.49: The Character Rects of the custom font](img/B18327_10_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.49: The Character Rects of the custom font'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first properties that repeat for all characters are **UV** **W** and **UV**
    **H**. These values represent the percentage of the sprite’s total width and total
    height that the individual character takes up. Since our characters are all evenly
    spaced in our sprite sheet, these values will be the same for all characters.
    If your characters are evenly sized, you can calculate these values as follows:![Figure
    10.50: Calculating the UV W and UV H values](img/B18327_10_50.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.50: Calculating the UV W and UV H values'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are a total of five columns of characters. Therefore, each sprite takes
    up one-fifth of the width of the sprite. One-fifth is equal to 20% or 0.2 as a
    decimal. We need to put `0.2` in the `1/5` in the `0.2` decimal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are a total of two rows of characters. Therefore, each sprite takes up
    one-half of the height of the sprite; one-half is equal to 50% or 0.5 as a decimal.
    Typing `1/2` in the `0.5` in the slot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next values that repeat for each character are the `50` in the `-57` in
    the **H** slot. Remember that the **H** value will always be negative!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last property that remains consistent throughout all the characters is the
    `51`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After completing *Steps 9* through *11*, your **Element 0** character should
    have the following properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.51: Element 0 with its values filled in](img/B18327_10_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.51: Element 0 with its values filled in'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have placed all the repeated properties, we can increase the `10`.
    You’ll see that once we do this, the properties of **Element 0** are repeated
    in **Element 1** through **Element 9**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.52: Element 0 duplicated through Element 10](img/B18327_10_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.52: Element 0 duplicated through Element 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to specify the ASCII index of each element. This will tie the
    typed text to the correct sprite. Without this, the font wouldn’t know that typing
    the number 0 should show the first sprite in the sheet. The following table indicates
    that the numbers 0 to 9 are the ASCII numbers 48 to 57: [http://www.ascii.cl/](http://www.ascii.cl/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, we should enter the `48` through `57` in `0`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`5`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`6`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`7`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`8`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`9`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`48`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`49`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`50`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`51`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`52`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`53`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`54`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`55`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`56`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`57`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Table 10.6: The index values of each element'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to specify the **UV** **X** and **Y** values. This is the
    part of creating custom fonts that takes up the most time. These values represent
    the UV coordinate position of the characters in the sprite sheet. These numbers
    are calculated based on the row and column numbers that the character lies in.
    The row and column numbers start at 0 and start in the bottom-left corner:![Figure
    10.53: The rows and columns of the sprite sheet](img/B18327_10_53.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.53: The rows and columns of the sprite sheet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To calculate the **UV** **X** and **UV** **Y** values, use the following formulas:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.54: Calculating UV X and UV Y](img/B18327_10_54.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.54: Calculating UV X and UV Y'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that since our characters are evenly spaced, our **UV** **W** and **UV**
    **H** values are the same for each character.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, if we look at `0`. Its `0.5`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following chart represents the **UV** **X** and **UV** **Y** values that
    should be entered for each character:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| **Element** | **UV X** | **UV Y** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `0` | `0` | `0.5` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `1` | `0.2` | `0.5` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `2` | `0.4` | `0.5` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `3` | `0.6` | `0.5` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `4` | `0.8` | `0.5` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `5` | `0` | `0` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `6` | `0.2` | `0` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `7` | `0.4` | `0` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `8` | `0.6` | `0` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `9` | `0.8` | `0` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Table 10.7: The UV X and UV Y properties of the font'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following figure provides a more visual representation of the coordinate
    pattern:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.55: The coordinates of the sprite sheet](img/B18327_10_55.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.55: The coordinates of the sprite sheet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can test our font to see whether it works. Within any of your scenes,
    create a new `Custom Font Text`. I have created a new scene called `Chapter10-Examples-CustomFont`
    on which I have my test fonts. Change the `0123456789` and drag the `CustomFont`
    into the **Font** slot. You should see something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.56: The custom font as it should be displayed after Step 15](img/B18327_10_56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.56: The custom font as it should be displayed after Step 15'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it display correctly, expand the size of the text box to accommodate
    all the characters and change the text color to white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.57: The custom font after adjusting some properties](img/B18327_10_57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.57: The custom font after adjusting some properties'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve completed importing our custom font, let’s look at adjusting
    it further.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the character spacing and changing the font size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, all the numbers are evenly spaced and the font size cannot
    be changed. You will likely want your numbers to be closer together or of a different
    font size. Let’s alter our custom font so that the sprites are closer together.
    The following figure shows our font after the adjustments versus the original
    we created in the last part of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.58: The custom font with and without spacing adjustment](img/B18327_10_58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.58: The custom font with and without spacing adjustment'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the spacing of the characters, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the `CustomFont` with *Ctrl* + *D* and rename the duplicate `CustomFontTight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Inspector of `CustomFontTight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you’d like the numbers to be closer together, you simply have to change
    the **Advance** property for the specific elements. The **Advance** property represents
    the pixels from the start of the sprite to the start of the next sprite. So, if
    we wanted the number 2 to appear closer to the number 1, we could change the **Advance**
    property of **Element 1** to something smaller, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.59: The 1 glyph spacing problem](img/B18327_10_59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.59: The 1 glyph spacing problem'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can change the settings on your custom font while previewing the results
    in the scene. To get the text to refresh in the scene after making a change to
    your custom font, you have to save the scene first.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the `0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`5`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`6`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`7`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`8`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`9`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`38`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`30`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`38`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`35`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Table 10.8: Advance properties of the custom font'
  prefs: []
  type: TYPE_NORMAL
- en: 'The font should now appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.60: All the glyphs of the font displayed](img/B18327_10_60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.60: All the glyphs of the font displayed'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still a bit too much spacing between the 0 and the 1; however, if
    you try to reduce the **Advance** property on the 0 to bring the 1 closer, other
    numbers will overlap the 0 if they follow the 0\. The following example shows
    what will happen if the **Advance** property of **Element 0** were reduced to
    35; the 1 looks good following 0, but the 9 overlaps it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.61: Different Advance settings on the 0 glyph](img/B18327_10_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.61: Different Advance settings on the 0 glyph'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping that in mind, we need to bring 1 closer in our scenario. To move the
    1 closer, we need to change the `-3` to shift it left just a smidge. This will
    give the character a more favorable spacing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you’d like to adjust the font size, you cannot change the size of a
    custom font by changing the `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, we probably won’t be using this font to build our master
    example scene, but the process of creating a custom font is still a useful exercise.
    Now, let’s move on to creating some other common UI assets – health bars and progress
    bars.
  prefs: []
  type: TYPE_NORMAL
- en: TextMeshPro - Warped Text with Gradient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The banner of our `Pause Panel` looks a bit bare currently. Now that we’ve
    covered using TextMeshPro - Text, we can create a nice curved text with a gradient
    that lines up well with our banner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.62: The banner text with a gradient and warp](img/B18327_10_62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.62: The banner text with a gradient and warp'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the curved text shown in the preceding screenshot, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the `Chapter 9``-Examples` scene and name the new scene `Chapter 10``-Examples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Pause Banner` UI Image and give it a child Text (TMP) object by
    right-clicking on it in the Hierarchy and selecting `Paused TMP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not done so already, select **Import TMP Essentials** and **Import
    TMP Examples & Extras** when the popup prompts you to do so. If you previously
    only imported TMP Essentials, but not the examples, go to **File | Project Settings**
    | **TextMeshPro** and select **Import TMP Examples &** **Extras.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Paused`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Font Style** to **Bold**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center-align the text horizontally and vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `43`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the font to `Roboto-Bold`. (Note this **Font Asset** will only be available
    if you imported the TMP Examples.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the Rect Transform so that the text is centered more within the banner.
    Your text should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.63: The banner text’s placement](img/B18327_10_63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.63: The banner text’s placement'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s give the text a gradient fill. Select the checkbox next to **Color
    Gradient** in the **TextMeshPro - Text (****UI)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve the desired look, we will leave the top-left and top-right colors
    white. Select the white rectangle at the bottom left to bring up the Color picker.
    Select the eye dropper at the top of the Color picker and then move your mouse
    over the tan area of the `Pause Panel` image. When you close the Color picker
    window, the tan color will be in the bottom-left slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.64: Using the eye dropper tool to get the text color](img/B18327_10_64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.64: Using the eye dropper tool to get the text color'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the color in the bottom-left slot and select **Copy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the white square in the bottom-right slot and select **Paste**.
    Now, the two top colors should be white and the two bottom colors should be tan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.65: The Color Gradient properties completed](img/B18327_10_65.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.65: The Color Gradient properties completed'
  prefs: []
  type: TYPE_NORMAL
- en: In the `0.25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do is curve the text. TextMeshPro has made this pretty easy
    for us by providing an example script that curves text at runtime. To view the
    changes, you have to play the game, and they are not represented in the Scene
    view. Select the **Add Component** button and choose **Scripts** | **TMPro.Examples**
    | **Warp** **Text Example**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.66: The Warp Text Example component](img/B18327_10_66.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.66: The Warp Text Example component'
  prefs: []
  type: TYPE_NORMAL
- en: Select the wavy green line in the **Vertex Curve** slot to bring up the curve
    editor. Select the option on the far left – that is, the flat line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.67: Selecting a flat curve for the Vertex Curve](img/B18327_10_67.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.67: Selecting a flat curve for the Vertex Curve'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the green line at the `0.5` mark and select **Add Key**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select that new key and drag it upward to a little below `1.3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.68: The final version of the Vertex Curve](img/B18327_10_68.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.68: The final version of the Vertex Curve'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game from this scene and press the *P* key to view the `Pause Panel`.
    The text should now appear as it did at the beginning of this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To view the entire flow, Start Screen, Intro Scene, and this scene with the
    updated `Pause Panel`, we’ll need to update some old scenes. Open `Chapter10-Examples-IntroScene`
    and change the `Text Canvas`’ `Chapter9-Examples` to `Chapter10-Examples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the scene called `Chapter9-Examples-StartScreen` and name it `Chapter10-Examples-StartScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new scene and select the `Play Button` child of the `Button Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Chapter10-Examples-IntroScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Build Settings** and update the **Scenes in Build** to the following:![Figure
    10.69: The Build Settings with all the appropriate scenes](img/B18327_10_69.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.69: The Build Settings with all the appropriate scenes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can remove unnecessary scenes by right-clicking on them and removing them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the `Chapter10-Examples-StartScreen` scene open, press the play button
    in the Editor and watch the game’s flow complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’d like to point out that, while I am duplicating and renaming each scene with
    each new chapter, you do not have to do so. I am doing it to maintain an easy-to-view
    progression log of what is happening to our scenes for this book, but admittedly,
    your project is probably getting a bit cluttered if you’ve been doing it, too.
    So, if you are wondering “Why can’t I just keep adding to my scenes instead of
    starting a new one each time?” you can!
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it for creating a wrapped text using TextMeshPro!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! I bet you thought, *how much can you really say about text?* when this
    chapter started and didn’t expect to be faced with the longest chapter so far!
    And I almost made it longer by adding more examples! Alas, as much as I would
    like to provide even more examples, I have a page limit I have to adhere to –
    even though I have already blown past it. If you are hankering for even more examples
    concerning UI Text and Text-TextMeshPro, I strongly recommend you review the various
    examples linked within this chapter, as well as the example scenes that you downloaded
    with the TextMesh – Pro examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll do a deep dive into UI Images and Effects.
  prefs: []
  type: TYPE_NORMAL
