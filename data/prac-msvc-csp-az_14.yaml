- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: gRPC for Binary Communication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC用于二进制通信
- en: Service-to-service communication does not need to be via REST passing JSON data.
    Performance and cost are important factors to consider when it comes to using
    **gRPC**, a binary and platform-independent communication technology. Reducing
    the data that’s transferred can increase performance and reduce costs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务到服务的通信不需要通过REST传递JSON数据。当使用**gRPC**，一种二进制和平台无关的通信技术时，性能和成本是重要的考虑因素。减少传输的数据可以增加性能并降低成本。
- en: In this chapter, we’ll change some services in the Codebreaker solution so that
    they offer gRPC instead or in addition to REST services. You’ll learn how gRPC
    differs from REST, as well as how to create services and clients using this binary
    communication technology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更改Codebreaker解决方案中的某些服务，以便它们提供gRPC服务或REST服务。您将了解gRPC与REST的不同之处，以及如何使用这种二进制通信技术创建服务和客户端。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Configure a service project to use gRPC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务项目以使用gRPC
- en: Create a platform-independent communication contract with Protobuf
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protobuf创建平台无关的通信合约
- en: Create gRPC services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建gRPC服务
- en: Create clients that call gRPC services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建调用gRPC服务的客户端
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription
    and Docker Desktop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，就像前几章一样，您需要一个Azure订阅和Docker Desktop。
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/)。
- en: The `ch14` folder contains the projects we’ll be looking at in this chapter,
    as well as their results. To add the functionality from this chapter, you can
    start with the source code from the previous chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch14`文件夹包含本章中我们将要查看的项目及其结果。要添加本章的功能，您可以从上一章的源代码开始。'
- en: 'The projects we’ll be considering are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的项目如下：
- en: '`Codebreaker.AppHost`: The .NET Aspire host project. The app model has been
    updated to use HTTPS with the `game-apis` service and `live-service` so that it
    supports gRPC.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost`: 这是.NET Aspire宿主项目。应用模型已更新，使用HTTPS与`game-apis`服务和`live-service`一起使用，以支持gRPC。'
- en: '`Codebreaker.Live`: The project we created in the previous chapter has been
    changed to offer a gRPC service instead of a REST service.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Live`: 我们在上一章中创建的项目已被修改，提供gRPC服务而不是REST服务。'
- en: '`Codebreaker.GameAPIs`: This project has been updated so that it includes a
    gRPC client to invoke `live-service`. In addition to the REST service used by
    many different clients, a gRPC service has been added as an alternative. This
    is invoked by the bot service.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs`: 此项目已更新，包括一个用于调用`live-service`的gRPC客户端。除了许多不同客户端使用的REST服务外，还添加了一个作为替代方案的gRPC服务。这是由机器人服务调用的。'
- en: '`Codebreaker.Bot`: The bot service has been updated to use a gRPC client instead
    of REST to invoke the `game-apis` service.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Bot`: 机器人服务已更新，使用gRPC客户端而不是REST来调用`game-apis`服务。'
- en: '`LiveTestClient`: You will need to use the live test client from the previous
    chapter to verify the SignalR service.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveTestClient`: 您需要使用上一章中的实时测试客户端来验证SignalR服务。'
- en: Before digging into gRPC, let’s compare it with **Representational State** **Transfer**
    (**REST**).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究gRPC之前，让我们将其与**表示状态转移**（**REST**）进行比较。
- en: Comparing REST with gRPC
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较REST与gRPC
- en: The most important difference between REST and gRPC is that REST is a *guideline*
    that builds upon HTTP, whereas gRPC is a *protocol*. Both are used for communication
    between clients and services. Let’s take a closer look.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: REST与gRPC之间最重要的区别在于，REST是一个基于HTTP的**指南**，而gRPC是一个**协议**。两者都用于客户端和服务之间的通信。让我们更深入地了解一下。
- en: Communication style
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信风格
- en: REST is a guideline that defines services to be stateless, makes use of HTTP
    verbs (GET, POST, PUT, DELETE) to manipulate resources, typically uses a human-readable
    format such as JSON or XML, and is commonly used with web APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种定义服务为无状态的指南，使用HTTP动词（GET、POST、PUT、DELETE）来操作资源，通常使用如JSON或XML等人可读的格式，并且通常与Web
    API一起使用。
- en: gRPC uses a *strongly defined contract* to specify the operations that are available
    with the services. While other specifications can be used as well, most services
    make use of **Protocol Buffers** (**Protobuf**) to specify the contract. With
    this, gRPC has a compact payload size and efficient serialization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用一个**严格定义的合约**来指定服务中可用的操作。虽然也可以使用其他规范，但大多数服务都使用 **Protocol Buffers**（**Protobuf**）来指定合约。这样，gRPC
    具有紧凑的有效负载大小和高效的序列化。
- en: Performance
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: When it comes to textual representation, REST has a higher overhead and a higher
    latency. With gRPC, because of its efficient serialization, latency is lower,
    and the binary serialization reduces the payload’s size. With gRPC, multiplexing
    allows for concurrent requests across a single connection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文本表示时，REST 有更高的开销和更高的延迟。gRPC 由于其高效的序列化，延迟较低，二进制序列化减少了有效负载的大小。gRPC 的多路复用允许在单个连接上进行并发请求。
- en: Flexibility
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活性
- en: REST adds flexibility by using URIs for resources and is not strictly based
    on HTTP and HTTPS. Other protocols can be used as well that fulfill REST principles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: REST 通过使用 URI 作为资源来增加灵活性，并且不严格基于 HTTP 和 HTTPS。还可以使用其他满足 REST 原则的协议。
- en: With gRPC, contracts strictly specify the communication. gRPC is based on HTTP/2,
    which offers some advantages compared to HTTP/1, such as multiplexing concurrent
    calls over a single connection. gRPC-Web is an alternative that allows a subset
    of gRPC to be used with HTTP/1.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 严格指定了通信合约。gRPC 基于 HTTP/2，与 HTTP/1 相比，提供了一些优势，例如在单个连接上多路复用并发调用。gRPC-Web
    是一个替代方案，允许使用 HTTP/1 使用 gRPC 的子集。
- en: Language support
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言支持
- en: REST just needs HTTP and works with any language that supports HTTP. With gRPC,
    based on the protobuf contract, code is created – and this requires supported
    languages to be used. Check out the list of supported languages at [https://grpc.io/docs/languages/](https://grpc.io/docs/languages/).
    It includes C#, C++, Dart, Java, Go, Python, PHP, and others.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: REST 只需要 HTTP，并且与支持 HTTP 的任何语言一起工作。gRPC 基于 protobuf 合约创建代码，这需要使用受支持的语言。查看受支持语言的列表，请访问
    [https://grpc.io/docs/languages/](https://grpc.io/docs/languages/)。它包括 C#、C++、Dart、Java、Go、Python、PHP
    以及其他语言。
- en: Security
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: REST relies on transport security (HTTPS). Authentication and authorization
    are done at the application level. With gRPC, transport security (TLS/SSL) is
    supported, and authentication via OAuth and JWT is built-in. gRPC supports per-message
    encryption.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST 依赖于传输安全（HTTPS）。身份验证和授权在应用层完成。gRPC 支持传输安全（TLS/SSL），并且内置了 OAuth 和 JWT 的身份验证。gRPC
    支持按消息加密。
- en: Use cases
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: REST allows for easy interoperability. Only HTTP calls need to be made. It’s
    used with web APIs and simple services, as well as for interoperability with existing
    services.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: REST 允许轻松互操作性。只需要进行 HTTP 调用。它与 Web API 和简单服务以及与现有服务的互操作性一起使用。
- en: With cloud services, we pay for compute and memory resources. With a lot of
    communication going on, the number of instances needed can be reduced by using
    memory and CPU-efficient technologies. Communication between services can be done
    using gRPC.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云服务时，我们为计算和内存资源付费。由于有很多通信进行，可以通过使用内存和 CPU 效率高的技术来减少所需的实例数量。服务之间的通信可以使用 gRPC
    完成。
- en: Let’s start by updating the solution so that it makes use of gRPC (with the
    logging collectors, gRPC is already in use).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更新解决方案，使其能够使用 gRPC（日志收集器已经使用 gRPC）。
- en: Updating a service project so that it uses gRPC
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新服务项目以使用 gRPC
- en: 'When using .NET templates to create new projects, a gRPC service can be created
    by running the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 .NET 模板创建新项目时，可以通过运行以下命令创建 gRPC 服务：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When using such a project, you can check the project file to see the NuGet packages
    and other configurations that are needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此类项目时，你可以检查项目文件以查看所需的 NuGet 包和其他配置。
- en: 'Because we already have existing projects, we’ll update these to offer a gRPC
    service. But first, let’s have a look at the communication between the Codebreaker
    services shown in *Figure 14**.1*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有现有项目，我们将更新这些项目以提供 gRPC 服务。但首先，让我们看看 *图 14.1* 中所示的 Codebreaker 服务之间的通信：
- en: '![Figure 14.1 – Codebreaker communication technologies](img/B21217_14_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – Codebreaker 通信技术](img/B21217_14_01.jpg)'
- en: Figure 14.1 – Codebreaker communication technologies
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – Codebreaker 通信技术
- en: 'Let’s start with the right-hand side. In [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317),
    we implemented the Codebreaker live service using a SignalR hub, which notifies
    SignalR clients. For the SignalR client, we created a console client application.
    Also in [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317), we used minimal ASP.NET
    Core APIs which allowed us to call the `game-apis` service to send completed games.
    This is a form of service-to-service communication that can be replaced by gRPC.
    The `game-apis` service itself is called by clients and the bot service. With
    this service, a REST API must be invoked by any client technology. The communication
    between the bot and the `game-apis` service can be done using gRPC as well. Thus,
    when it comes to the `game-apis` service, we’ll offer an alternative communication
    technology so that communication between the `game-apis` service and `live-service`
    will be replaced. Thus, in this chapter, we’ll do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从右侧开始。在 [*第 13 章*](B21217_13.xhtml#_idTextAnchor317) 中，我们使用 SignalR 集线器实现了
    Codebreaker live 服务，该集线器通知 SignalR 客户端。对于 SignalR 客户端，我们创建了一个控制台客户端应用程序。同样，在 [*第
    13 章*](B21217_13.xhtml#_idTextAnchor317) 中，我们使用了最小的 ASP.NET Core API，这使得我们可以调用
    `game-apis` 服务来发送完成的游戏。这是一种服务到服务的通信方式，可以被 gRPC 替换。`game-apis` 服务本身被客户端和机器人服务调用。使用此服务，任何客户端技术都必须调用
    REST API。机器人和 `game-apis` 服务之间的通信也可以使用 gRPC 完成。因此，当涉及到 `game-apis` 服务时，我们将提供一种替代的通信技术，以便替换
    `game-apis` 服务和 `live-service` 之间的通信。因此，在本章中，我们将执行以下操作：
- en: Replace the minimal API implementation of `live-service` with gRPC
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 gRPC 替换 `live-service` 的最小 API 实现
- en: Add an alternative option for the `game-apis` service so that we offer gRPC
    as well
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `game-apis` 服务添加一个替代选项，以便我们提供 gRPC
- en: Implement a gRPC client with the `game-apis` service to invoke `live-service`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `game-apis` 服务实现一个 gRPC 客户端以调用 `live-service`
- en: Implement a gRPC client with clients of the `game-apis` service
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `game-apis` 服务的客户端实现一个 gRPC 客户端
- en: Let’s start by creating a gRPC service contract for `live-service` that’s invoked
    by the `game-apis` service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为 `live-service` 创建一个由 `game-apis` 服务调用的 gRPC 服务合约开始。
- en: Creating service contracts
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务合约
- en: First, we need to add the `Grpc.AspNetCore` NuGet package to the `Codebreaker.Live`
    project. Then, we must add a Protobuf file as a contract to the service. The contract
    file is language and platform-independent, so a .NET service can communicate with
    a Dart application using the same Protobuf file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `Grpc.AspNetCore` NuGet 包添加到 `Codebreaker.Live` 项目中。然后，我们必须将一个 Protobuf
    文件作为合约添加到服务中。合约文件是语言和平台无关的，因此一个 .NET 服务可以使用相同的 Protobuf 文件与 Dart 应用程序通信。
- en: 'Using Visual Studio, add a `Protos` folder, and use the Visual Studio template
    to create a `Codebreaker.Live`, you can run the following command to create the
    `LiveGame.proto` file inside the `Protos` folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio，添加一个 `Protos` 文件夹，并使用 Visual Studio 模板创建一个 `Codebreaker.Live`，你可以在
    `Protos` 文件夹内运行以下命令来创建 `LiveGame.proto` 文件：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s create contracts for both `live-service` and `game-apis`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 `live-service` 和 `game-apis` 创建合约
- en: Creating a gRPC service contract for live-service
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 `live-service` 创建一个 gRPC 服务合约
- en: 'The simpler contract is the one for `live-service`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的合约是 `live-service` 的合约：
- en: Codebreaker.Live/Protos/LiveGame.proto
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Protos/LiveGame.proto
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `syntax` keyword specifies the Protobus version that should be used. Version
    3 added features such as `maps` and `oneof` fields. The `option` keyword allows
    us to add language-specific features. `option csharp_namespace` sets the C# namespace
    that should be used by the generated classes, postfixed with the name set by the
    `package` keyword. The `service` keyword describes the list of operations offered
    by the gRPC service. Every operation within the service uses the `rpc` keyword
    (remote procedure call). In our code, the operation is called `ReportGameCompleted`,
    uses `ReportGameCompletedRequest` as a parameter, and returns `google.protobuf.Empty`.
    `google.protobuf.Empty` is one of the well-known Protobuf types that’s available.
    When used, this type must be imported using the `import` keyword. The `google.protobuf.Duration`
    and `google.protobuf.Timestamp` types are imported as well. `ReportGameCompletedRequest`
    is a message that’s specified using the `message` keyword. Every field within
    a message needs a unique identifier. The serializer and deserializers use this
    number to get a match. Thus, if you specify a contract once, don’t change the
    number in future versions, as this breaks existing clients or services. The types
    used need to be platform-independent as the same Protobuf file can be used by
    all platforms that support gRPC. `string`, `bool`, and `int32` are types that
    are defined by the Protobuf specification. With .NET, these types map to `string`,
    `bool`, and `int`, respectively. `Id` is a GUID, but there’s no representation
    for GUIDs with Protobuf. `string` can be used for the identifier. With the .NET
    `GameSummary` class, the `StartTime` property is of the `DateTime` type and the
    `Duration` property is of the `TimeSpan` type. To map these types with Protobuf,
    you can use `Timestamp` and `Duration`. These types are defined in the `Google.Protobuf.WellKnownTypes`
    .NET namespace. `Timestamp` and `Duration` offer conversion methods to convert
    to and from `DateTime` and `TimeSpan`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax` 关键字指定了应该使用的 Protobuf 版本。版本 3 添加了 `maps` 和 `oneof` 字段等特性。`option` 关键字允许我们添加特定语言的功能。`option
    csharp_namespace` 设置了由生成的类使用的 C# 命名空间，后缀为 `package` 关键字设置的名称。`service` 关键字描述了
    gRPC 服务提供的操作列表。服务中的每个操作都使用 `rpc` 关键字（远程过程调用）。在我们的代码中，操作被命名为 `ReportGameCompleted`，使用
    `ReportGameCompletedRequest` 作为参数，并返回 `google.protobuf.Empty`。`google.protobuf.Empty`
    是可用的已知 Protobuf 类型之一。当使用此类型时，必须使用 `import` 关键字导入。`google.protobuf.Duration` 和
    `google.protobuf.Timestamp` 类型也被导入。`ReportGameCompletedRequest` 是使用 `message`
    关键字指定的消息。消息中的每个字段都需要一个唯一的标识符。序列化和反序列化器使用这个数字来匹配。因此，如果你已经指定了一个合约，那么在未来的版本中不要更改这个数字，因为这会破坏现有的客户端或服务。使用的类型需要是平台无关的，因为相同的
    Protobuf 文件可以被所有支持 gRPC 的平台使用。`string`、`bool` 和 `int32` 是由 Protobuf 规范定义的类型。在
    .NET 中，这些类型分别映射到 `string`、`bool` 和 `int`。`Id` 是一个 GUID，但在 Protobuf 中没有 GUID 的表示。可以使用
    `string` 作为标识符。在 .NET 的 `GameSummary` 类中，`StartTime` 属性是 `DateTime` 类型，而 `Duration`
    属性是 `TimeSpan` 类型。要将这些类型与 Protobuf 映射，可以使用 `Timestamp` 和 `Duration`。这些类型在 `Google.Protobuf.WellKnownTypes`
    .NET 命名空间中定义。`Timestamp` 和 `Duration` 提供了将它们转换为 `DateTime` 和 `TimeSpan` 的转换方法。'
- en: 'To create .NET classes from the Protobuf file, a `Protobuf` entry needs to
    be added to the project file, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Protobuf 文件创建 .NET 类，需要在项目文件中添加一个 `Protobuf` 条目，如下所示：
- en: Codebreaker.Live/Codebreaker.Live.csproj
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Codebreaker.Live.csproj
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This `Protobuf` entry references the Protobuf file with the `Include` attribute
    and specifies the code to be generated for the server by setting `GrpcServices`
    to `Server`. With the server, classes for all the defined messages and base classes
    for every service specified are generated. Later in this chapter, we’ll use the
    `Protobuf` element to generate classes for the client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Protobuf` 条目通过 `Include` 属性引用了 Protobuf 文件，并通过将 `GrpcServices` 设置为 `Server`
    来指定为服务器生成的代码。有了服务器，就会生成所有定义的消息的类以及每个服务指定的基类的类。在本章的后面部分，我们将使用 `Protobuf` 元素来生成客户端的类。
- en: 'In the previous chapter, we created the `GameSummary` class to report game
    completions. To convert this class into the gRPC-generated `ReportGameCompletedRequest`
    class, we must define a conversion method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了 `GameSummary` 类来报告游戏完成情况。要将这个类转换为 gRPC 生成的 `ReportGameCompletedRequest`
    类，我们必须定义一个转换方法：
- en: Codebreaker.Live/Extensions/ReportGameCompletedRequestExtensions.cs
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Extensions/ReportGameCompletedRequestExtensions.cs
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this implementation, we create a new `GameSummary` instance and use conversion
    methods – for example, we parse a string to a `Guid` value and invoke the `ToDateTime`
    and `ToTimeSpan` methods to convert the `Timestamp` and `Duration` values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们创建一个新的`GameSummary`实例并使用转换方法——例如，我们将字符串解析为`Guid`值，并调用`ToDateTime`和`ToTimeSpan`方法来转换`Timestamp`和`Duration`值。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To see the generated code with Visual Studio, click on the `ReportGameCompletedRequest`
    class, use the context menu, and select **Go To Implementation**. This directly
    opens the generated code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio中查看生成的代码，请单击`ReportGameCompletedRequest`类，使用上下文菜单并选择**转到实现**。这会直接打开生成的代码。
- en: With `ReportGameService`, we just have a very simple contract. To allow `game-apis`
    to be called and moves to be made by the bot service, we need a more complex contract.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ReportGameService`，我们只有一个非常简单的合同。为了允许`game-apis`被调用并且移动可以通过机器人服务进行，我们需要一个更复杂的合同。
- en: Creating a gRPC service contract for the game-apis service
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为game-apis服务创建gRPC服务合同
- en: The gRPC contracts of the `game-apis` service are lengthier than for `live-service`.
    Here, we’ll focus on some specific parts of the contract. Check out this book’s
    GitHub repository for the complete definition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-apis`服务的gRPC合同比`live-service`的合同更长。在这里，我们将关注合同的一些特定部分。查看本书的GitHub存储库以获取完整的定义。'
- en: 'The service contract specifies operations to play the game:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务合同指定了玩游戏的操作：
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Protos/GameService.proto
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The alternative option to the REST interface, `GrpcGameService`, defines operations
    to create a game (`CreateGame`), set a move (`SetMove`), and get information about
    a game (`GetGame`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为REST接口的替代选项，`GrpcGameService`定义了创建游戏（`CreateGame`）、设置移动（`SetMove`）和获取游戏信息（`GetGame`）的操作。
- en: 'Most messages that are used to send a request to the service just contain scalar
    values. The `SetMoveRequest` message is different. This message contains a list
    of guess pegs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用于向服务发送请求的消息仅包含标量值。`SetMoveRequest`消息是不同的。此消息包含了一个猜测销钉的列表：
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Protos/GameService.proto
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lists are specified using the `repeated` keyword.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表使用`repeated`关键字指定。
- en: 'Not only pre-defined types can be repeated – it’s also possible to repeat an
    inner message type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅预定义的类型可以重复，还可以重复内部消息类型：
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Protos/GameService.proto
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `GetGameResponse` message type contains a repeated list of `Move` messages.
    The `Move` message type contains a list of strings for the guess pegs and the
    key pegs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetGameResponse`消息类型包含了一个`Move`消息的重复列表。`Move`消息类型包含了一个字符串列表，用于猜测的销钉和键销钉。'
- en: 'Protobuf also defines a list of keys and values via the `map` type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf还通过`map`类型定义了一个键和值的列表：
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Protos/GameService.proto
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With a map, the key and value types are specified. With the `fieldValues` field,
    the key is a string. The corresponding REST API specifies a string array for the
    value. Using `repeated` with the value type is not possible with Protobuf. Instead,
    `FieldMessage` is defined to contain a `repeated string`, and this is used with
    the `map` value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地图时，指定了键和值类型。`fieldValues`字段中，键是一个字符串。相应的REST API指定了一个字符串数组作为值。在Protobuf中，使用`repeated`关键字与值类型是不可能的。相反，定义了`FieldMessage`来包含一个`repeated
    string`，并且这个用于`map`值。
- en: The message contracts create .NET classes that are specific to gRPC. When it
    comes to the local service classes, it’s better if they’re independent of communication
    technologies. So, we need to create conversion methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 消息合同创建了特定于gRPC的.NET类。当涉及到本地服务类时，最好它们与通信技术无关。因此，我们需要创建转换方法。
- en: Creating conversion methods
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建转换方法
- en: 'The gRPC service of `live-service` receives `ReportGameCompletedRequest`. This
    is forwarded to the SignalR service we created in the previous chapter as a `GameSummary`
    method. So, we need to convert `ReportGameCompletedRequest` into a `GameSummary`
    method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`live-service`的gRPC服务接收`ReportGameCompletedRequest`。这被转发到我们在上一章中创建的SignalR服务作为`GameSummary`方法。因此，我们需要将`ReportGameCompletedRequest`转换为`GameSummary`方法：'
- en: Codebreaker.Live/Extensions/GrpcExtensions.cs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Extensions/GrpcExtensions.cs
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is done in the form of an extension method where we extend the `ReportGameCompletedRequest`
    type. With the implementation of the `ToGameSummary` method, simple scalar types
    can be passed on, creating a `GameSummary` object. Google’s `Timestamp` and `Duration`
    types offer the `ToDateTime` and `ToTimeSpan` methods to convert `DateTime` and
    `TimeSpan`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以扩展方法的形式完成的，我们扩展了`ReportGameCompletedRequest`类型。通过实现`ToGameSummary`方法，可以传递简单的标量类型，创建一个`GameSummary`对象。Google的`Timestamp`和`Duration`类型提供了`ToDateTime`和`ToTimeSpan`方法来转换`DateTime`和`TimeSpan`。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Libraries such as `AutoMapper`, `Mapster`, and others can be used to automatically
    implement such conversions. While this works out of the box with simple properties
    without the need to add custom code, some customization is needed when converting
    different types. What you need to be aware of is that mapper libraries that use
    .NET reflection instead of source generators increase memory and CPU usage and
    cannot be used with native AOT. Depending on the types you need to map, you might
    prefer a custom extension method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用如`AutoMapper`、`Mapster`等库来自动实现此类转换。虽然这对于简单的属性来说开箱即用，无需添加自定义代码，但在转换不同类型时可能需要一些定制。需要注意的是，使用.NET反射而不是源生成器的映射库会增加内存和CPU使用，并且不能与原生AOT一起使用。根据您需要映射的类型，您可能更喜欢自定义扩展方法。
- en: Check out this book’s GitHub repository for additional conversion methods that
    can be used with the `game-apis` service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅本书的GitHub仓库以获取可用于`game-apis`服务的其他转换方法。
- en: With the conversion methods in place, let’s create the gRPC service implementations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换方法就绪后，让我们创建gRPC服务的实现。
- en: Creating gRPC services
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建gRPC服务
- en: 'To implement a gRPC service for the `Codebreaker.Live` project, create the
    `GRPCLiveGameService` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`Codebreaker.Live`项目实现一个gRPC服务，创建`GRPCLiveGameService`类：
- en: Codebreaker.Live/Endpoints/GRPCLiveGameService.cs
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Endpoints/GRPCLiveGameService.cs
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the `GRPCLiveGameService` class, using constructor injection, the hub context
    we created in the previous chapter is injected to send a `GameSummary` method
    to all connected clients participating with the group that is named with `game-type`.
    The `GRPCLiveGameService` class needs to derive from the base class – that is,
    `ReportGame.ReportGameBase`. `ReportGameBase` is implemented as an inner class
    of `ReportGame` based on the Protobuf contract.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GRPCLiveGameService`类，通过构造函数注入，将我们在上一章中创建的hub上下文注入到发送`GameSummary`方法到所有连接的客户端中，这些客户端参与名为`game-type`的组。`GRPCLiveGameService`类需要从基类派生——即`ReportGame.ReportGameBase`。`ReportGameBase`是基于Protobuf合约实现的`ReportGame`的内部类。
- en: 'Next, use the `GRPCLiveGameService` class to map it as a gRPC endpoint:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`GRPCLiveGameService`类将其映射为gRPC端点：
- en: Codebreaker.Live/ApplicationServices.cs
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/ApplicationServices.cs
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can remove the mapping of the minimal API endpoint and just configure the
    gRPC endpoint with the `WebApplication` class known as `MapGrpcService`, passing
    the service class as a generic parameter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以移除最小API端点的映射，只需使用名为`MapGrpcService`的`WebApplication`类配置gRPC端点，并将服务类作为泛型参数传递。
- en: 'gRPC requires HTTP/2\. So, we need to configure the `Kestrel` server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC需要HTTP/2。因此，我们需要配置`Kestrel`服务器：
- en: Codebreaker.Live/appsettings.json
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/appsettings.json
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring `Protocols` to `Http1And2` starts the `Kestrel` server and ensures
    it supports both HTTP/1 and HTTP/2\. The gRPC service needs HTTP/2\. When it comes
    to `live-service`, SignalR is offered from the same server. To allow the SignalR
    service to connect via HTTP/1 or HTTP/2, the server must be configured to offer
    both versions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Protocols`配置为`Http1And2`将启动`Kestrel`服务器并确保它支持HTTP/1和HTTP/2。gRPC服务需要HTTP/2。对于`live-service`，同一服务器提供了SignalR。为了允许SignalR服务通过HTTP/1或HTTP/2连接，服务器必须配置为提供这两种版本。
- en: 'The `game-apis` service’s implementation has similarities. In the project file,
    we need to add the `Grpc.AspNetCore` package, add a `Protobuf` element to the
    project file, and specify that we wish to create classes for the server:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-apis`服务的实现有相似之处。在项目文件中，我们需要添加`Grpc.AspNetCore`包，向项目文件添加一个`Protobuf`元素，并指定我们希望为服务器创建类：'
- en: 'Implementing this aspect of the gRPC service is simple: we can inject the `IGameService`
    interface. This uses the same classes we already used to implement the minimal
    API service:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实现gRPC服务的这一方面很简单：我们可以注入`IGameService`接口。这使用了我们之前用来实现最小API服务的相同类：
- en: Codebreaker.GameAPIs/GrpcGameEndpoints.cs
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/GrpcGameEndpoints.cs
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In gRPC, we can derive from the generated base class, `GrpcGame.GrpcGameBase`,
    override the base class methods that have been specified with the service contracts,
    and use the conversion methods to convert the input and output types into their
    corresponding gRPC representations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 gRPC 中，我们可以从生成的基类 `GrpcGame.GrpcGameBase` 继承，并覆盖由服务合同指定的基类方法，并使用转换方法将输入和输出类型转换为相应的
    gRPC 表示形式。
- en: Similar to `live-service`, the `game-apis` service needs gRPC to be added to
    the DI container and mapped to the endpoint, and `Kestrel` needs to be configured
    so that it supports both HTTP/1 and HTTP/2.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `live-service` 类似，`game-apis` 服务需要将 gRPC 添加到 DI 容器并映射到端点，并且需要配置 `Kestrel`
    以支持 HTTP/1 和 HTTP/2。
- en: With the services implemented, let’s consider the gRPC clients.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了服务后，让我们考虑 gRPC 客户端。
- en: Creating gRPC clients
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 gRPC 客户端
- en: 'If you’re using Visual Studio 2022, you can take advantage of its built-in
    support to add a gRPC client. From Solution Explorer, select the project, open
    the context menu, and select **Add** | **Connected Service**. This opens the dialogue
    shown in *Figure 14**.2*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio 2022，可以利用其内置支持添加 gRPC 客户端。从解决方案资源管理器中选择项目，打开上下文菜单，然后选择
    **添加** | **连接服务**。这会打开 *图 14.2* 所示的对话框：
- en: '![Figure 14.2 – Add service reference](img/B21217_14_02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 添加服务引用](img/B21217_14_02.jpg)'
- en: Figure 14.2 – Add service reference
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 添加服务引用
- en: 'Select **gRPC** and click **Next**. This opens the dialogue shown in *Figure
    14**.3*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **gRPC** 并点击 **下一步**。这会打开 *图 14.3* 所示的对话框：
- en: '![Figure 14.3 – Add new gRPC service reference](img/B21217_14_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 添加新的 gRPC 服务引用](img/B21217_14_03.jpg)'
- en: Figure 14.3 – Add new gRPC service reference
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 添加新的 gRPC 服务引用
- en: Select the Protobuf file, then select **Client** from the **Select the type
    of class to be generated** dropdown to create the classes for messages and the
    code for the client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Protobuf 文件，然后从 **选择要生成的类的类型** 下拉菜单中选择 **Client** 以创建消息类和客户端代码。
- en: 'If you’re not using Visual Studio, you can use a .NET command-line tool called
    `dotnet`. To install this tool, run the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 Visual Studio，可以使用名为 `dotnet` 的 .NET 命令行工具。要安装此工具，请运行以下命令：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this tool globally installed, you can use the `dotnet-grpc` command to
    create the proxy classes for the `game-apis` client:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局安装了此工具后，可以使用 `dotnet-grpc` 命令为 `game-apis` 客户端创建代理类：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can run the following for the bot service client:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于机器人服务客户端，你可以运行以下命令：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What happened with these commands or with the Visual Studio integration?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令或 Visual Studio 集成发生了什么？
- en: The `Grpc.AspNetCore` NuGet package was added to the project
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目中添加了 `Grpc.AspNetCore` NuGet 包
- en: A `Protobuf` element was added to the project file
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件中添加了一个 `Protobuf` 元素
- en: 'Using the command-line tool, code for both the client and the server is created
    when the `Protobuf` entry is created. To only create code for the client, the
    `GrpcServices="Client"` attribute needs to be added:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行工具，当创建 `Protobuf` 条目时，会创建客户端和服务器端的代码。如果要仅创建客户端代码，需要添加 `GrpcServices="Client"`
    属性：
- en: Codebreaker.GameAPis/Codebreaker.GameAPIs.csproj
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPis/Codebreaker.GameAPIs.csproj
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Regarding the `game-apis` service, the project file now includes two `Protobuf`
    entries. One is used to create the service part (which we did in the previous
    section), while the new entry is for the client code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `game-apis` 服务，项目文件现在包括两个 `Protobuf` 条目。一个用于创建服务部分（我们在上一节中已执行），而新的条目用于客户端代码。
- en: 'The bot invokes the `game-apis` service. So, the proto file of the `game-apis`
    service needs to be referenced in the bot project file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人调用 `game-apis` 服务。因此，需要在机器人项目文件中引用 `game-apis` 服务的 proto 文件：
- en: Codebreaker.Bot/Codebreaker.Bot.csproj
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Bot/Codebreaker.Bot.csproj
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, for the client, `GrpcServices` is set to `Client`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于客户端，`GrpcServices` 设置为 `Client`。
- en: 'Upon using the proto files, client proxy classes are created, offering methods
    to invoke the service with the names of the operations. These proxy classes can
    be injected. In the following code snippet, the generated `ReportGameClient` class
    is being injected into the `GrpcLiveReportClient` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 proto 文件时，会创建客户端代理类，提供使用操作名称调用服务的方法。这些代理类可以被注入。在下面的代码片段中，正在将生成的 `ReportGameClient`
    类注入到 `GrpcLiveReportClient` 类中：
- en: Codebreaker.GameApis/GrpcLiveReportClient.cs
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameApis/GrpcLiveReportClient.cs
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ReportGameClient` implements the `ILiveReportClient` interface – the same
    interface we defined and implemented in the previous chapter to invoke the SignalR
    service on completion of a game. When implementing the same interface, we just
    need to change the configuration of the DI container so that it invokes the service
    via gRPC instead of using the REST interface. With the implementation of the `ReportGameEndedAsync`
    method, we can invoke the generated method from the proxy and need to convert
    the parameter with the help of an extension method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReportGameClient` 实现了 `ILiveReportClient` 接口——这是我们之前章节中定义和实现的相同接口，用于在游戏完成后调用
    SignalR 服务。在实现相同接口时，我们只需更改 DI 容器的配置，以便通过 gRPC 而不是使用 REST 接口调用服务。通过实现 `ReportGameEndedAsync`
    方法，我们可以从代理调用生成的方法，并需要使用扩展方法帮助转换参数：'
- en: Codebreaker.GameApis/ApplicationServices.cs
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameApis/ApplicationServices.cs
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, for the bot service, `GrpcGamesClient` implements the `IGamesClient`
    interface and injects `GrpcGame.GrpcGameClient`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于机器人服务，`GrpcGamesClient` 实现了 `IGamesClient` 接口并注入了 `GrpcGame.GrpcGameClient`：
- en: Codebreaker.Bot/GrpcGamesClient.cs
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Bot/GrpcGamesClient.cs
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `IGamesClient` interface was the same one that’s implemented by `GameClient`,
    which calls the REST API. This interface is injected into `CodebreakerGameRunner`,
    so no changes are required when switching to gRPC.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGamesClient` 接口与 `GameClient` 实现的相同，它调用 REST API。此接口被注入到 `CodebreakerGameRunner`
    中，因此在切换到 gRPC 时不需要进行任何更改。'
- en: The `SetMoveAsync` method makes a request to the gRPC service by invoking the
    `SetMoveAsync` method of `GrpcGame.GrpcGameClient`. Similar to before, it aims
    to convert the parameters into the ones needed by gRPC.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMoveAsync` 方法通过调用 `GrpcGame.GrpcGameClient` 的 `SetMoveAsync` 方法向 gRPC 服务发出请求。与之前类似，它的目的是将参数转换为
    gRPC 所需的参数。'
- en: For help with implementing the other methods of the interface, check out this
    book’s GitHub repository. Note that it’s similar to what we did previously.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解接口其他方法的实现，请参阅本书的 GitHub 仓库。请注意，它与之前所做的工作类似。
- en: 'To glue `IGamesClient` to the new implementation, and to configure the gRPC
    client, we need to update the DI container’s configuration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `IGamesClient` 连接到新的实现，并配置 gRPC 客户端，我们需要更新 DI 容器配置：
- en: Codebreaker.Bot/ApplicationServices.cs
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Bot/ApplicationServices.cs
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `AddGrpcClient` method configures the generated class with the address of
    the `game-apis` service.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddGrpcClient` 方法配置生成的类以使用 `game-apis` 服务的地址。'
- en: Now, run the application and start one or multiple instances of the live test
    client to see if completed games show up. Start the bot service and send requests
    to the bot service to play several games. At the same time, use another client
    to play a game. How many games does the bot run until you complete one? Of course,
    this depends on the think time you configure with the bot. Do the results show
    up in the console of the live test client? Check the logs and the environment
    variables of the different services in the .NET Aspire dashboard.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并启动一个或多个实时测试客户端实例，以查看是否显示已完成的游戏。启动机器人服务并向机器人服务发送请求以玩几场游戏。同时，使用另一个客户端玩游戏。机器人运行多少场游戏你才完成一场？当然，这取决于你为机器人配置的思考时间。结果是否显示在实时测试客户端的控制台中？检查日志和
    .NET Aspire 仪表板中不同服务的环境变量。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the differences between REST APIs and gRPC, as
    well as the advantages when using gRPC with service-to-service communication.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 REST API 和 gRPC 之间的区别，以及在使用 gRPC 进行服务间通信时的优势。
- en: You created a service contract using Protobuf syntax to define services and
    messages. Contrary to REST, gRPC is strict when it comes to messages and service
    operations. You created servers and clients using the classes that were generated
    with the proto files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 Protobuf 语法创建了一个服务合同，以定义服务和消息。与 REST 相比，gRPC 在消息和服务操作方面非常严格。你使用由 proto 文件生成的类创建了服务器和客户端。
- en: 'To reduce cost in the cloud, it can be cost-effective to use protocols with
    lower overhead for service-to-service communication. However, other options are
    available as well. Upon completion of the game, it’s not required to inform the
    listener immediately. There’s also a price aspect to this: with the current implementation,
    the live service is running when accessed from the game APIs service. If nobody
    is listening, this is not required. By using asynchronous communication, the `live-service`
    can register to receive information when it’s started – this is when a listener
    is active. Asynchronous communication will be covered in the next chapter.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在云中降低成本，使用较低开销的协议进行服务间通信可能是经济有效的。然而，还有其他选项可供选择。游戏完成后，无需立即通知听众。这也涉及到一个价格方面：根据当前实现，当从游戏API服务访问时，实时服务正在运行。如果没有人在监听，这就不需要了。通过使用异步通信，`live-service`可以在启动时注册接收信息——这是当有听众活跃时。异步通信将在下一章中介绍。
- en: Further reading
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，请参考以下链接：
- en: '*Protobuf Language* *Guide*: [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf 语言指南：[https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/)
- en: '*gRPC on .NET-supported* *platforms*: [https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms](https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 .NET 支持的平台上的 gRPC：[https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms](https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms)
- en: '*grpc-dotnet GitHub* *repository*: [https://github.com/grpc/grpc-dotnet](https://github.com/grpc/grpc-dotnet)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*grpc-dotnet GitHub* 存储库：[https://github.com/grpc/grpc-dotnet](https://github.com/grpc/grpc-dotnet)'
- en: '*Call gRPC services with the .NET* *client*: [https://learn.microsoft.com/en-us/aspnet/core/grpc/client](https://learn.microsoft.com/en-us/aspnet/core/grpc/client)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET 客户端调用 gRPC 服务：[https://learn.microsoft.com/en-us/aspnet/core/grpc/client](https://learn.microsoft.com/en-us/aspnet/core/grpc/client)
