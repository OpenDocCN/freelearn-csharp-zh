- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to [*Chapter 5*](B21069_05.xhtml#_idTextAnchor221)! You are doing great!
    In this chapter, we will discuss a new approach provided by functional programming
    to handle errors. We will do so through the help of the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional error handling in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Result type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Railway-Oriented Programming (ROP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing your own error-handling mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical tips for functional error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional versus functional error handling comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and anti-patterns in functional error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steve is really upset today because he spent the last three days fixing errors
    and didn’t have time to write even a single line of new code. Moreover, benchmark
    tests showed that the code with try-catch blocks works much slower than the one
    without them and that there are a lot of these blocks in his code. So he decided
    to ask Julia whether there was a way to handle errors better with a functional
    approach. She sent Steve a big article about error handling using functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this chapter delves into the functional techniques, which will
    help you not just handle errors but do so in a manner that’s clean, efficient,
    and maintainable. And before we dig in, let’s look at these three self-assessment
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Custom error types and result usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s a function in Steve’s tower defense game that upgrades a tower and returns
    a boolean. Refactor it to return a `Result` type instead, with a custom error
    when the upgrade fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Utilizing ROP for validation and processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Steve has a workflow that involves parsing, validating, and processing an enemy
    spawn. Refactor it using **Railway-Oriented Programming** (**ROP**) to improve
    the error-handling flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Implementing a Retry mechanism using functional techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that implements a retry mechanism for a flaky tower firing
    operation and returns a `Result` type. The function should retry the operation
    a specified number of times before returning an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If these tasks are easy for you, you are free to skip this chapter for now and
    return later when you have read all the others or have any questions about error
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional error handling in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every C# developer, whether a novice or an expert, has come across the try-catch
    block. It’s been the main protection against unexpected behaviors and system failures.
    Let’s revisit this conventional mechanism before understanding what the functional
    paradigm offers.
  prefs: []
  type: TYPE_NORMAL
- en: try-catch blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The try-catch block attempts an operation, and if it fails, the control is
    transferred to the catch block, ensuring the application doesn’t crash. For instance,
    let’s say we’re working with a simple file-reading operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we log different messages depending on the type of the raised exception.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# offers two primary categories of exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NullReferenceException`, `IndexOutOfRangeException`, or the ones we just encountered:
    `FileNot` **FoundException** and `IOException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application exceptions**: These are custom exceptions created for specific
    application needs. Let’s say you’re developing an e-commerce platform, and you
    need an exception for an out-of-stock item. Here’s how you might design it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Later, check the item’s stock:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Custom exceptions empower developers to communicate specific error scenarios,
    ensuring that error handling is informative.
  prefs: []
  type: TYPE_NORMAL
- en: Steve slumped in his chair, frustration etched on his face. He’d spent the last
    three days battling bugs in his tower defense game, and the codebase was becoming
    a maze of try-catch blocks. Just then, his phone buzzed. It was a message from
    Julia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *How’s the game* *coming along?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Not great. I’m drowning in error handling. Got any functional programming
    wisdom* *for me?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *As a matter of fact, I do. Let me tell you about a more elegant way
    to* *handle errors...*'
  prefs: []
  type: TYPE_NORMAL
- en: The Result type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of dealing with exceptions after they occur, what if we designed our
    code to anticipate and elegantly communicate errors? Please welcome the `Result`
    type, a cornerstone of functional error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, the `Result` type encapsulates either a successful value or an
    error. It might sound similar to exceptions, but there’s a key difference: errors
    become first-class citizens, directly influencing your application’s flow.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `Option` type that can only distinguish existing values from
    non-existing, the `Result` type describes the error that happened and, more importantly,
    can be used to chain methods application. We will discuss that technique later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, traditionally, a method might return a value or throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, with the `Result` type, the method communicates both its intention
    and possible failure more explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code is more explicit. No hidden exceptions. No unexpected behaviors. Just
    clear, honest communication.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Result type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive a bit deeper and see what a general implementation of the `Result`
    type looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the Result type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usage of the `Result` type leads to a more systematic approach to error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: No more scattered try-catch blocks. Now errors become just another path your
    code can take, leading to more predictable and maintainable systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Result` type fundamentally shifts how we view errors: not as sudden interruptions,
    but as anticipated outcomes. As we go further, you’ll see how this functional
    tool integrates with other advanced techniques, creating a new approach to error
    management.'
  prefs: []
  type: TYPE_NORMAL
- en: Railway-Oriented Programming (ROP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve was intrigued by the Result type, but he still had questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *This is great for individual operations, but what about when I have
    a series of steps that all need* *to succeed?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *I’m glad you asked. Let me introduce you to* *Railway-Oriented Programming.*'
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of functional programming is the drive for predictability and clarity.
    Although traditional error-handling techniques are powerful, they often scatter
    the error-handling logic across the codebase. ROP, inspired by this railway track-switching
    analogy, offers a cohesive, structured approach to error handling, keeping your
    code both expressive and streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: 'ROP provides a systematic way to manage errors in a sequence of operations.
    Think of it as managing two parallel tracks: the success track (happy path) and
    the error track. Operations run sequentially on the happy path. However, as soon
    as an error is encountered, the flow is diverted to the error track, bypassing
    subsequent operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The essence of Bind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Central to ROP is the Bind function. It takes an operation and a subsequent
    operation to execute if the first one succeeds. However, if an error occurs, it
    bypasses the second operation, and the error is immediately propagated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Chaining operations with Bind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine a series of steps where we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate parsed data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform validated data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store transformed data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ROP lets us express these steps as a cohesive chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Composable error handling with ROP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A strength of ROP is that it fosters composable error handling. Each component
    of your application can define its own error scenarios, and when these components
    are chained together, the combined operation can handle a broader spectrum of
    errors without losing granularity.
  prefs: []
  type: TYPE_NORMAL
- en: Consider having separate components for user input, business logic, and database
    operations. Each component can have its own error definitions. When operations
    from these components are chained together, the system can seamlessly handle errors
    from any component, creating a unified error-handling strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CompositeError` might encapsulate errors from input validation, business
    logic violations, and database failures.
  prefs: []
  type: TYPE_NORMAL
- en: Handling diverse error types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One challenge with a straightforward ROP implementation is that it assumes
    a unified error type throughout the chain. However, real-world scenarios often
    involve diverse error types. To manage this, you can introduce a mechanism to
    convert or map error types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This enhanced `Bind` function maps one error type to another, enabling more
    complex and varied error-handling scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROP isolates error handling, ensuring that your main business logic remains
    uncluttered. When reading through the core operations, one can focus purely on
    the main logic without being distracted by error-handling intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: For developers, this isolation simplifies cognitive load. They can trust the
    system to handle errors and focus on crafting the primary logic. When debugging,
    the structured nature of ROP makes it crystal clear where things might have gone
    off the rails, thus, simplifying the troubleshooting process.
  prefs: []
  type: TYPE_NORMAL
- en: Extending ROP for asynchronous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In modern applications, a lot of methods are asynchronous. ROP can be adapted
    to asynchronous operations using techniques such as `BindAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With `BindAsync`, you can now chain asynchronous operations just as easily,
    making ROP versatile in both synchronous and asynchronous contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Having delved deep into ROP, we witness a paradigm shift in how we perceive
    and handle errors. Instead of treating errors as exceptional events, ROP integrates
    them into the very logic of our application, resulting in more robust, readable,
    and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Designing your own error-handling mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Steve began refactoring his code, he realized that the pre-built solutions
    didn’t quite fit all his game’s unique scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Julia, I think I need to create some custom error types for my game.
    Is* *that okay?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *More than okay. In fact, let’s talk about how you can design your own
    error-handling mechanisms tailored to your* *game’s needs.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating your own functional error handling, a `Result` type is a prime
    starting point. Let it be generic enough to cater to different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Use factory methods for creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Factory methods provide clarity and ease of use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Extend with Bind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Bind` method to add more fluency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Customize error types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than just using strings, create specific error types to convey detailed
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Leverage extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extension methods can offer enhanced readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Integration with existing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By wrapping legacy methods, we can seamlessly integrate with non-functional
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Always iterate and refine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom error mechanisms are living entities. As your application grows, keep
    iterating and refining based on feedback and new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Designing your own error-handling mechanisms not only empowers you with tailor-fit
    solutions but also deepens your understanding of the functional paradigm. Dive
    in, get hands-on, and watch as your applications become models of robustness and
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Practical tips for functional error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A week into refactoring, Steve was making progress, but he felt overwhelmed
    by all the new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *I’m not sure I’m doing* *this right…*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Don’t worry, it’s normal to feel that way when learning a new paradigm.
    Let me share some practical tips that’ll help you navigate this* *new territory.*'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid null with options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try to never return null. It sounds simple, yet it’s a pitfall waiting to trip
    up the unwary. Why? Because nulls are very easy to get, however, it is much harder
    to handle them properly and if you don’t do it well, it can lead to cascading
    failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Turn this around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Logging errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logging is vital, but try to avoid side effects that ruin the functional approach.
    A good idea here is to delegate the act of logging, keeping functions pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Two strategies To replace exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I know that in some cases your first instinct might be to use a try-catch. Resist.
    Use these strategies to stick to the functional paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Safe execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a method that will execute any code in an exception-free way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Fallback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For some operations, you can provide a fallback result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Anticipate errors – make it predictable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of waiting for errors, anticipate them. Validate your data before using
    it in processing. You can do it manually or with the help of guard clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Embrace composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use function composition for cleaner error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Educate your team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lastly, ensure everyone’s on board. A consistent approach to error handling
    ensures clarity and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional versus functional error handling comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every developer experiences it sooner or later: running into an error while
    coding. But as the coding world has changed, so has the way we deal with these
    problems. Let’s look at the clear differences between the old and new ways of
    handling errors in C# and understand why this new approach is becoming more popular.'
  prefs: []
  type: TYPE_NORMAL
- en: The traditional way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In traditional OOP, exceptions are the go-to mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Throwing exceptions**: We rely on system or custom exceptions when things
    go wrong:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Catching exceptions**: Use try-catch blocks to handle and possibly recover
    from errors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The benefits of the traditional way are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Most developers are accustomed to using exceptions, making it a well-understood
    approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-grained error handling is possible with different exception types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can disrupt the natural flow of code execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling introduces a performance overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be hard to reason about and can lead to “exception hell”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functional way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional programming prefers a more graceful form of error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use constructs such as** **Result types**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Consuming the preceding function becomes straightforward:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**ROP**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The benefits of the functional way are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Clearer intent and flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids the exception performance overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier chaining of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a couple of drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers may be required to learn new concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less granularity compared to traditional exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparative analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the differences between traditional exception handling
    and functional programming when it comes to performance, readability, and maintainability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Traditional exception handling can be slower due to the overhead
    of creating exception objects and unwinding the stack. FP offers a more predictable
    performance profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability**: try-catch blocks can clutter code, making it less readable.
    Often these blocks contain also code that cannot throw exceptions. FP encapsulates
    errors within data, making code flow apparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Traditional methods spread error handling, making maintenance
    complex. FP encourages isolated, pure functions, which simplifies debugging and
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the shift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with FP error handling might seem odd, especially if you’ve lived
    all your life in the traditional paradigm. But once you make the switch, the benefits
    are profound. Remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Start small. Refactor a section of your codebase and observe the difference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embrace pure functions. They’ll simplify your error-handling story.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Educate your team. A shared understanding is pivotal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, while traditional error handling has served us well for years,
    the functional paradigm offers a fresher, more systematic approach. By representing
    errors as first-class citizens within our data types, we write more maintainable
    code. The choice between the two often boils down to the problem domain, team
    familiarity, and project requirements. But if you want clarity and expressiveness,
    the functional route is the way.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and anti-patterns in functional error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming has redefined our approach to error handling. By bringing
    errors into the realm of data, we ensure safer, more predictable code. But as
    with any paradigm, there are right ways and pitfalls. Let’s look at the patterns
    that can help you and also the anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several patterns that can help you handle errors in a more functional
    way. These patterns are designed to enhance the quality, readability, and maintainability
    of your code. Here are some of the key patterns to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rich custom** **error types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of generic strings or codes, use detailed types to describe errors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Leveraging composition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chain multiple functions seamlessly to maintain clear logic flow:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Pattern matching** **with errors**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This ensures every error scenario is addressed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Isolating** **side effects**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep your core logic pure and handle side effects, such as logging or I/O,
    separately:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are also some anti-patterns that can make your error handling more complex
    and error-prone:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Result` types can confuse other software developers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Unclear errors**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returning vague errors eliminates the value of FP’s expressive error handling:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Ignoring errors**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just getting the value without addressing potential failures breaks the idea
    of FP error handling. An example is when you have a Result type as a method output,
    but don’t check it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Overcomplicating with** **custom types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While detailed error types are beneficial, creating one for every minor deviation
    can overcomplicate things. Please don’t do errors like these:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Steve was eager to apply his newfound knowledge of functional error handling
    to his tower defense game. Julia, impressed by his enthusiasm, presented him with
    three challenges to test his understanding and improve his code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the function that upgrades a tower and returns a boolean. Refactor it
    to return a `Result` type instead, with a custom error when the payment fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve has a workflow that involves parsing, validating, and processing an enemy
    spawn. Refactor it using Railway-Oriented Programming to improve the error-handling
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a function that implements a retry mechanism for a flaky operation and
    returns a `Result` type. The function should retry the operation a specified number
    of times before returning an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Try to do these exercises yourself, and when finished, you can check your work
    with the following solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refactor the method to use a `Result` type with a custom error that encapsulates
    failure details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve refactored his enemy spawning system using ROP, creating a clean pipeline
    for processing enemy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the flaky tower firing mechanism, Steve implemented a retry function that
    attempts the operation multiple times before giving up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: These exercises take you from understanding to applying functional principles
    in practical coding scenarios. They encourage you to think and code functionally,
    recognizing error handling not as an afterthought but as an integral part of the
    coding process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we progressed from traditional methods of error handling to
    functional approaches. We identified the strengths, challenges, patterns, and
    anti-patterns of the FP way.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming offers not just a way to code, but a mindset shift. By
    treating errors as data, we benefit from type safety, expressiveness, and predictability.
  prefs: []
  type: TYPE_NORMAL
- en: However, our goal is not to get rid of all exceptions and nulls but to create
    more readable and resilient software. Luckily, with the development of C#, functional
    error handling is becoming easier and more integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Like all paradigms, functional programming is not a silver bullet. While errors
    as data can be powerful, you have to remember the real world where your code runs.
    Networking failures, database outages, and hardware malfunctions are realities.
    Striking a balance between functional purity and real-world pragmatism is key.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of times in this chapter, we used delegates, and in order to get a
    better understanding of them and their role in functional programming, in the
    next chapter we will delve into the concepts of higher-order functions and delegates.
  prefs: []
  type: TYPE_NORMAL
