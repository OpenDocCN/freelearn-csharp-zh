- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Industrial Principles to Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains what can be done to make IT a real industry, and this
    begins with applying the main principles of industrialization, namely cutting
    complexity into small pieces and then standardizing the modules, and in particular
    their interfaces. We will make a comparison with the development of cities, where
    the normalization of water pipes, electricity, and other interfaces has allowed
    for continuous evolution.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain the very concept of industry, as this is a
    very often used name, but not necessarily every time with a precise understanding
    of its meaning. We will also learn about how industrialization works by cutting
    complex problems into small ones and then making the small ones simple and repeatable,
    principally by means of standardization. We’ll also understand what benefits can
    be drawn from such an approach, in particular in information systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an industry?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management of complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of standards and norms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The urbanism metaphor of information systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an industry?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we compared craftsmanship to industrialization, hopefully
    showing that, while the former has nothing to be ashamed of, the latter is its
    natural evolution in time. All industries start with artisans and, with the work
    becoming more and more controlled and repeatable, potentially end up as real industries
    where the artisans have gradually converted to engineer competencies and jobs.
    Most people understand this without any need for explanation because it can be
    seen in many day-to-day experiences. When one, for example, first attempts at
    realizing a new task (say, cutting hair), the first trials are not comparable
    to the ensuing ones. After a period of time, the process starts to become more
    regular (the hair is cut fine, and the initial customer who accepted to be your
    *guinea pig* does not complain anymore). Given enough training, one gets expertise
    in the field and develops a routine (the hair is cut at a defined length and with
    the expected shape, in a way that can be precisely reproduced in a future haircut).
  prefs: []
  type: TYPE_NORMAL
- en: How about trying to formalize what is behind industrialization, though? In other
    terms, how do we characterize what constitutes industrialization? As we saw, there
    is the concept of being reproducible, which means there is a measured norm that
    should be met. Also, this norm is shared between all knowledgeable people in the
    field, which means it becomes a standard. In our example with haircuts, there
    are names for haircuts, and everybody in the field knows what “trimmed” or “shortened”
    means, which makes it safe for customers not to leave the hairdresser with a hairstyle
    they did not expect. Also, from one hairdresser to another, one can expect to
    obtain a globally similar result once stated using the right vocabulary. We obtain
    a homogeneous quality in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In industrialization, just like in hairdressing, there is also the concept
    of addressing small parts of the whole. Except if you would like to look like
    a well-known person, you will not describe your haircut as a whole but describe
    small parts that form a complete hairstyle. For example (although not a good one,
    from an aesthetic point of view): long at the back, short on the top, tapered
    on the side. Addressing the parts instead of the whole and cutting a complex problem
    into small, simple ones that can be solved simply is the basis for industrialization,
    engineering, and even problem-solving as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: A good hairdresser may be a fine artisan, but once you can get a similar haircut
    from many professionals in the field, it has simply become an **industry**. In
    the following sections, we will apply this definition to IT and show how industrialization
    happens there. In order to do so, we will first dive a bit deeper into what really
    stands behind the concept, in terms of actions to realize.
  prefs: []
  type: TYPE_NORMAL
- en: The two roots of industrialization – modularization and standardization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a simple example as an introduction to what we are going to call industrialization
    when applying it to Information Technology, we are going to dive a bit deeper
    into two associated movements in the concept, namely cutting big problems into
    small ones, which can be called **modularization** (as we expect small modules
    of a whole system) and solving these small problems with a normalized approach
    to reach homogeneous quality, which can be called **standardization**.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity to reduce complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before explaining the concept of complexity, let’s see with another example
    how it relates to modularity. This time, we will use a mechanical comparison by
    analyzing the different modules of a car. A modern car is a feat of engineering,
    gathering so many parts in a sophisticated manner that is it virtually impossible
    for a person alone to build such a system. When one decomposes a car into modules,
    there are definitely clear-cut, well-separated modules that each have a purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: The engine will provide power to displace the car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body will protect the driver and passengers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wheels and driving train will transform power into motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chassis will hold the other modules together in a rigid way, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The engine alone still is quite a beast, but we can decompose it further, into
    sub-modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The injection system will bring gas into the chamber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pistons will transform the explosion into linear motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The crankshaft will convert linear motion into rotary motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lubrication system will ensure the system does not degrade due to wearing,
    heating, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, the complexity has lowered, and, if we go one step further into decomposing
    modules, the lubrication system can be described as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A pump ensures oil circulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The oil performs cooling and allows for frictionless movements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The oil filter removes small debris that could otherwise increase friction and
    wear, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This time, we have reached such a small level of complexity that almost anyone
    could act on these modules: adding oil can be done by anyone owning a car, provided
    they know where to pour it; replacing an oil filter is as simple as unscrewing
    the old one and screwing a new one into the same place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularity, really, is the art of cutting complex things into small parts that
    are easier to manage. If modularization is done well, complexity decreases at
    each step. Imagine we had separated the engine as left and right portions of it:
    we surely would not have made it easier to observe and maintain. Indeed, modularity
    is not simply the cutting of the system; it is the art of cutting it in an intelligent
    way so that complexity decreases. But how can we do that? This is where the experience
    of artisans and the help of a long history of making comes into place, providing
    enough expertise to know where the system should be and what will make it simpler.
    The first engines surely did not have an oil filter, but after some time being
    obliged to remove all the oil from the engine after a few hundred kilometers,
    filter it, and pour it back into the engine, it became obvious inserting a filter
    into the engine oil flow was the clever thing to do. If we try to summarize this
    in just one sentence, modules should be carved out after functions. The oil filter
    is there because, in the process of lubrication, there has to be a filtering function.
    It does make sense to assign this function to one and only one module.'
  prefs: []
  type: TYPE_NORMAL
- en: Standardization to ensure modularity is helpful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The relationship between the different modules, the way they fit together,
    and how they interact are other criteria that must be taken into account. Cutting
    down is not enough: if one wants the whole system to function, defining smaller
    modules is the first step, but once created, they must be put back together to
    reach the global goal. This is where the way the modules have been cut is important,
    and we have explained previously that it should follow functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But how about putting them back together? If modules are aligned with functions,
    how can we make sure they fit together well? In fact, the problem is quite simple
    to explain and sometimes extremely hard to solve, needing large engineering teams
    to do so: we have to ensure that the common function they share is exactly the
    same. If two functions have to be reassembled, that means they have a small connecting
    sub-function in common, which is generally called the interface. This interface
    has to be defined in a similar pattern on both sides.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the example of our oil filter again: it has been separated from
    the rest of the lubrication system and engine for its definition, but it also
    has to be put back in the engine system to operate and participate in the higher
    level of function, namely providing power to the car. To do so, it has been explained
    the oil filter has to be screwed back to the position in the engine, and this
    is where an interface will be needed. This interface is simply a screw thread:
    the oil filter will present a threaded oil and the engine a threaded growth at
    the place where the filter has to be placed, with of course a hole in it, allowing
    oil to flow in and from the filter. The interface itself is defined with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: It should provide a stable attachment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be tight enough to be oil-proof
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should allow enough fluid circulation, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are one step forward, but there remains another step to do in order to reach
    industrialization: the interface must be standardized, which means all the preceding
    functions should be specified in such a way that replacement is easy and each
    provider can participate in the higher-level module simply by knowing the interface.
    In our example, the oil filter, in order to participate in the engine system,
    has to adhere to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the precise thread diameter (for European oil filters, it is a 20-millimeter
    diameter, with a thread step of 1.5 millimeters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oil-proofness is ensured by a circular joint that is 62 millimeters wide in
    the same standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capacity to retain debris based on fluid circulation, and thus the duration
    of the filter use, is determined by the volume of the filter, which comes in two
    standard sizes, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a very low-grade schema of how an oil filter is attached to a car engine:
    a threaded hole in the oil filter adapts to a threaded piece of metal with a hole
    in it that is on the external part of the engine, for easy access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Schematic positioning of an oil filter on a car engine](img/B21293_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Schematic positioning of an oil filter on a car engine
  prefs: []
  type: TYPE_NORMAL
- en: There we have it! If we now go back to the explanation, we have modules that
    are so standardized that one can buy them anywhere and they will have the same
    interfaces, although their inner functions may be different; modules put together
    will each have their function but provide a higher-level, more sophisticated function
    to the global system they form together. A few steps more and the whole system
    operated by the many modules and submodules will have a complexity that could
    not have been addressed without this industrial approach.
  prefs: []
  type: TYPE_NORMAL
- en: To take another example that is more associated with our day-to-day experience,
    small batteries, and chargers are currently the target of a push to standardization
    by governments. This is particularly visible in the European Community, where
    USB-C has been pushed down the throat even to massive opponents such as Apple.
    Large companies have been using many different non-compatible connectors and chargers
    for decades, leading to a huge waste of electronic systems and complexity in the
    everyday lives of the users, forcing them to juggle many different pieces of equipment.
    This law is already having some results in making charging a phone less complex
    for the public.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about complexity, we will have to define more precisely what is behind
    this term, and this is what we are going to do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Management of complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *complexity* refers to the quality of something that is composed of
    many different parts. It is often confused with *complication*, which brings the
    meaning of something hard to understand. Most information systems are complex,
    and how this complexity is handled can make them complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of complexity was introduced previously when talking about how to
    reduce it by cutting large, difficult-to-operate systems into small ones that
    are easier to deal with. In this section, we will come back to this concept of
    complexity and start by stating that there are two kinds of complexity, namely
    the **intrinsic**, functional one and the avoidable, **accidental** one. The first
    one comes from the function itself, and if a module is to provide this function,
    it cannot do less than this. The second one is everything that is added when implementing
    the function to make it operate, and that cannot be considered as purely necessary
    for the function itself. Of course, the whole deal will be to reduce as much as
    possible the second one, since the two add up and the first one cannot be reduced
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example of an oil filter for a car engine, the folding of the absorbing
    paper inside the filter is intrinsic complexity, because the different stacks
    of paper and how they form a complex path for the oil are the way the filter functions,
    retaining the heavy metal particles in the foldings of paper, while the oil reaches
    the output of the filter with cleaner, purer characteristics. The metal casing
    of the filter, really, cannot be considered as a participant in the filtering
    operation. Sure – it is helpful to hold the paper sheets together and facilitate
    manipulation, but it does not participate in filtering: this is accidental complexity
    in the oil filter.'
  prefs: []
  type: TYPE_NORMAL
- en: Information systems are filled with accidental complexity, and considering that
    the smallest text notes application nowadays uses thousands of lines of code and
    megabytes of memory, this only starts to show the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Computer science as a way to deal with complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may sound weird that complexity has reached such a level considering that
    computers have been designed with added productivity in mind. After all, early
    computers were built to strongly accelerate calculations that otherwise would
    take days, weeks, or even months, and required careful double-checking in order
    to avoid errors as much as possible. The cost of investment in creating a computer
    was huge due to increasing complexity at first (designing modern computers and
    electronic chips is one of the most complex endeavors of our civilization), but
    the using of the computer to quickly produce accurate results for many problems
    would largely pay for the investment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of work currently done by computers today is of a high level of technical
    complexity: displaying high-resolution real-time pictures from 3D modeling in
    games, performing long calculations such as discrete Fourier transforms or Monte
    Carlo simulations, and so on. Lots of these operations could not be realized with
    the same level of accuracy and low error level by humans or even large groups
    of them. Thus, we can consider IT has helped reduce complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: Information systems and complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But at the same time, and this is particularly true for people like me who have
    been in the software field for more than 30 years, it just looks like computers
    actually did not bring the incredible functional advances that the huge increase
    in computing power would lead us to believe. GPUs are millions of times quicker,
    but games are only a few times better. Personal computers are hundreds of times
    more powerful, but vocal typing is still far from perfect, and word processing
    has basically not changed, with new features being – most of the time – useless
    at best, and bloatware at worst.
  prefs: []
  type: TYPE_NORMAL
- en: It just happens that, along with the capacity of computers, we have asked them
    to do more and more. And while some of these additional operations are bringing
    new value (optimization of mechanical models, capacity to simulate complex physical
    models, and so on), a lot are non-value-adding features (larger screens, infinity
    of nuances of colors) that really make for additional comfort but, in **line-of-business**
    (**LOB**) software applications, do not bring anything to the functional value.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, it looks very much like accidental complexity has grown almost
    at the same rhythm as computational power, and thus, the remaining power has brought
    very little performance in handling intrinsic, business-oriented complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of “as a service”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Luckily, there is also good news on the evolution of information systems, and
    the “as a service” approach is one such example. The “as a service” approach means
    that something of value is provided to the user without the material part. **Infrastructure
    as a service** (**IaaS**), for example, brings you memory and CPU without the
    hardware part of the computer; that is dealt with by someone else, generally the
    cloud provider. **Software as a service** (**SaaS**) provides you with working
    software that you can call with a simple web browser without having to worry about
    prerequisites, installation, purchase of licenses, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider this approach with respect to the concepts of complexity exposed
    previously, we can say that the goal is to reduce accidental complexity to almost
    zero by providing not even the function alone but only the results of the function,
    which is the service requested. If almost nothing of the surrounding artifacts
    remains; only the outcome of the software-assisted procedure is obtained. For
    example, in IaaS, infrastructure as a whole is not what is needed per se by the
    buyer: one does not crave physical computers consuming space, needing local temperature
    control, racks, and so on, but has to go through this accidental complexity to
    obtain CPU power, RAM usage, storage space, or network bandwidth and connectivity.'
  prefs: []
  type: TYPE_NORMAL
- en: The “as a service” concept has considerably diminished the perceived complexity
    of information systems. Of course, there is no free lunch, and the overall complexity
    is still there (it has even increased). But the separation, not modules by modules
    this time, but functions by functions, has established a clear cut between the
    high technical complexity that is handled by the provider of the service and the
    low complexity that remains for the user. The financial transfer from the latter
    to the former is explained by the fact that the user gets a great advantage of
    focusing only on value-adding, business-oriented complexity. How the provider
    of the service gains a financial interest in handling higher technical complexity
    (which would be accidental for a mere user, but is standard business complexity
    for the provider) comes from the fact that they are an expert in it, handle large
    volumes for many users, and apply scale-related cost savings. In the end, everyone
    benefits from a clear cut of complexity, which can also be described as a separation
    of responsibility and task specialization, which is consubstantial with industrialization,
    as explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: Link to a minimum viable product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lots of people working with Agile methods know a famous picture illustrating
    the concept of a **minimum viable product** (**MVP**), from Henrik Kniberg, who
    created it in the mid-2010s ([https://blog.crisp.se/wp-content/uploads/2016/01/mvp.png](https://blog.crisp.se/wp-content/uploads/2016/01/mvp.png)):
    it shows a first line of product evolution from a wheel to two wheels linked,
    then to two wheels and a body, and finally a car. During this evolution, a smiley
    frowns all the time and is only satisfied at the last step. In the second line
    of the image, the steps are replaced by a skateboard (sad smiley), then a bike
    (neutral smiley), followed by a motorbike (reasonably happy), and finally a convertible
    car (extremely happy smiley).'
  prefs: []
  type: TYPE_NORMAL
- en: It has been studied a lot and is a great description of the concept of the evolution
    of a software application from MVP (the skateboard) to a full-fledged project
    (the car on the right). Lots of imitations do not carry as much meaning because
    they miss a few details. For example, some of them end up with the same car on
    the two lines, which is completely wrong as Kniberg purposefully showed different
    cars at the end of the two processes. The whole story is perfectly explained at
    [https://blog.crisp.se/2016/01/25/henrikkniberg/making-sense-of-mvp](https://blog.crisp.se/2016/01/25/henrikkniberg/making-sense-of-mvp),
    and I am certainly not going to paraphrase it, but rather try to make a link with
    what was written previously about the “as a service” approach.
  prefs: []
  type: TYPE_NORMAL
- en: What is the service that is talked about in that famous picture? Does it have
    a car? No – owning a car or driving it is merely a side-effect on the service
    itself, which is “going from one point to another.” Using an MVP will help us
    collect feedback as quickly as possible on the actual needs of the users. Now,
    if we go to the extreme of the “as a service” approach and consider displacement
    of the person (and possible luggage) as the one and only request, science-fiction-like
    teleportation would be absolutely perfect! And we are a bit more reasonable with
    possibility and price; as Kniberg says, maybe the most basic approach should be
    to provide the user with a bus ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would also be a valuable MVP, but that would be forgetting the fact that
    an MVP does not mean the designer does not have the final destination in mind:
    we provide the skateboard to collect feedback (for example, “stability is important”)
    while still having in mind that we want a car in the end, maybe because the initially
    expressed need is that of autonomous travel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is of uttermost importance – and we will come back to why the cars are
    not the same in the end – is that, while taking into account feedback, stability
    was important in this example and the design quickly evolved to a bike, which
    is more stable and easier to stay on. But this is not the only feedback that was
    received. For example, the fact that the vehicle was not covered was not really
    an issue, and the design evolved into a bike and then a motorbike, which has no
    wind or rain protection. In the end, the proposed car has no roof: not only because
    it is simply not requested, but because the interest in driving with hair in the
    wind may have arisen from the feedback loop. If one had created the car directly,
    maybe the customer would not have thought of an open roof. But asking for continuous
    feedback has shown an additional desirable feature (not a need, though, but just
    a “bonus”) that would have not been detected otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: This is what companies talk about when they express their desire to “delight
    their customers.” Most of us engineers do not immediately get it because we tend
    to see problems with one optimized solution that derives from initial specifications,
    but the best solutions bring value to customers that they would not even have
    thought about initially. And guess what? Since all companies are generally good
    at creating the expected features, these unexpected and delightful features will
    be the ones your customers will use to differentiate your service from your competitors!
  prefs: []
  type: TYPE_NORMAL
- en: Now that the concept of complexity should be clear, we will propose a first
    approach to how to reduce it.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of standards and norms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first section of this chapter, *What is an industry?*, started talking about
    standardization and how it is essential for modularization to make sense. Let’s
    imagine the contrary and a system that has been arbitrarily cut into several smaller
    ones, without reflection on the way to define these parts, how they interact,
    and how they each can be replaced by improved versions. The result would be that
    modules could not be designed without knowing the whole and could not be replaced
    by existing modules since the way they are glued to the rest would not already
    exist. At best, this would only make the whole problem a bit easier to address;
    at worst, the added difficulty of putting everything back together would largely
    overcome the reduction of complexity with respect to addressing the whole system
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why the cutting interfaces of the modules and their standardization
    are so important, and why we will dedicate the next section to stressing this
    with additional examples.
  prefs: []
  type: TYPE_NORMAL
- en: Docker, containers, and OCI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Docker** technology is a great way to talk about norms and standards because
    its very name starts with a metaphor for an industrial concept that prospered
    through standardization, namely freight and shipping containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until the 1950s, freight transportation was not standardized at all, and filling
    a ship with freight was quite a craftsmanship: packages came in all sizes and
    weights, some of them being soft, some of them being hard. The way to bind them
    together so that they did not move during transportation was customized at every
    different shipping. It was extremely hard to correctly fill a vehicle since there
    was little chance all packages would fit nicely to occupy all space while keeping
    fragile and lightweight packages at the top and heavy, solid ones at the bottom.
    If you then add the problems of load balance, humidity, or temperature effects
    that could transmit from one package to another, and the occasional last-minute
    package that was too heavy to put on top of the other ones and forced the dockers
    to unload part of the shipment and rearrange everything, you start to get an understanding
    of what a complicated job freight shipping was at that time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meet Malcolm McLean, who devised in 1956 a shipping system based on wood boxes
    that could be easily transferred from trucks to trains and boats. After only 10
    years, in 1967, this great idea was used so much that the **International Organization
    for Standardization** (**ISO**) defined three standard sizes of “containers.”
    Despite road/train/sea transportation activities being a huge, worldwide business,
    after only a few decades, virtually every operator on earth uses standard-sized
    metal containers that allow optimization of the whole logistics chain and have
    the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of loading**: Any expediter can get their hands on a container and load
    it at their own rhythm, then contact a transporter and have them carry the container,
    without any risk of refuse because they cannot take care of a particular shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improvement in the handling of goods**: Since the metal boxes have standardized
    sizes and corners with handling holes, there is no use anymore in changing manipulation
    tools that are needed to press the package (and potentially break its content).
    Now, the prehensile tools simply lock the four corners of the container and lift
    them. The speed of handling is also improved as there is no need to handle different
    packages one by one: the machines lift a container – that carries many different
    packages inside – as a single unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized storage**: Industrial containers are plain, parallelepiped-shaped
    boxes. Their stacking wastes almost no place but the width of the walls. Today,
    large ships are sized around containers for size optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interchangeable material**: Containers have become such commodities that
    there is almost no question of property. A container can be easily repaired or
    replaced by another. A container basically never travels empty. Some of them have
    traveled several times around the world without their initial buyer seeing them
    again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Docker name and logo clearly state the philosophy behind the technology:
    the term *docker* refers to the job of loading freight on ships, and Docker’s
    logo shows a whale carrying containers on its back. The link is quite obvious
    to the transportation business, and the company wants to become the equivalent
    of industrial containers for application shipping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with industrial shipping containers, Docker containers provide standard-based
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Whatever is inside the container (Java process, .NET web, Python script, NodeJS
    API, and so on), the external interface is exactly the same, and one can simply
    type `docker run` and have the container up and running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once put inside a Docker image, an application can be shipped to any place on
    the planet through registries and it will be executed in the same manner, whichever
    country it is used in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independence from the underlying architecture**: Docker containers do not
    know or care whether they are operated on a Windows machine, a Linux server, or
    even a Kubernetes cluster. Since they have a standard size, they can fit anywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all these nice features, Docker quickly became the de facto standard for
    application deployment. Docker itself could even have become the definitive standard,
    but there were a few shortcomings, and a higher-level, more widespread standard
    appeared a few years later: **Open Container Initiative** (**OCI**) created a
    low-denominator, but undeniable standard that every container technology (Docker,
    but also other technologies, though less known) adheres to.'
  prefs: []
  type: TYPE_NORMAL
- en: Containers have undoubtedly industrialized and strongly improved the way applications
    are deployed. The rise of microservices is strongly related to container technologies
    since the deployment of numerous small applications would have been extremely
    complicated with the old approach of manually setting up dependencies and resources
    for each application. Some even say microservices architecture appeared only because
    Docker allowed them to exist.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is an example of how a technology that normalizes a given software-related
    function (in this case, application deployment) can have a huge impact and replace,
    through a single standardized approach, loads of proprietary, manual approaches.
    But this is not the only time this happened in the industry...
  prefs: []
  type: TYPE_NORMAL
- en: Another example with IAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Identity and access management** (**IAM**) is another field of IT where normalization
    has brought a great deal of help and positively changed a difficult situation
    in the last decades. Remember when each and every software application had its
    own user management and passwords? Let alone different, not compatible, ways of
    handling groups and authorization management, and so on. Such a mess... Everyone
    in the field was glad when the first approaches of **single sign-on** (**SSO**)
    appeared, and the **Central Authentication Service** (**CAS**) implemented it
    in readily available software. Identity and authentication providers made the
    field more complex to grasp for beginners, but avoided hundreds of thousands of
    badly-designed IAM systems, replacing them with online, always-accessible identities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Assertion Markup Language** (**SAML**) quickly became a standard,
    and tools such as Shibboleth help diffuse the capacity of handling in a correct,
    open source, manner. More recently, **OpenID Connect** (**OIDC**), OAuth 2.0,
    **JSON Web Token** (**JWT**), and other standardized approaches basically killed
    any discussion on the best way to identify, authenticate, and authorize accounts,
    accounting for new features that needed to be taken into account and now covering
    virtually any needs in the field. Keycloak is a production-ready, standard-based,
    open source application that can act as the glue between standards, which means
    we now have all the tools to really deal with IAM in a standard way. The benefits
    are such that companies not using these approaches yet will be obliged in the
    next years to take steps to do so, as security issues are going to make it mandatory
    to stop trying to deal with IAM on proprietary, fragile implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There again, the function of IAM has become a commodity owing to standards
    and an industrial approach of separating modules, each of them with its own responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Identification deals with who the accounts and individual owners of accounts
    are, with all associated metadata. **Lightweight Directory Access Protocol** (**LDAP**)
    and **LDAP Data Interchange Format** (**LDIF**) come to mind as standards for
    this responsibility, but **System for Cross-domain Identity Management** (**SCIM**)
    also can be used, as well as extensions such as SCIM Enterprise Profile to incorporate
    organizational charts, for example. JWTs can be used to carry this data in a normalized
    way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication is about proving the identity of accounts. OIDC, of course, comes
    to mind, but **Fast IDentity Online** (**FIDO**) and **Universal 2nd Factor**
    (**U2F**) are standards related to authentication as well, introducing physical
    devices to improve authentication management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization is – once identity is established with proof of authentication
    – the way to deal with what the person is allowed to do in the software (or, otherwise,
    remembering that information systems are mostly, but not only, about software).
    **eXtensible Access Control Markup Language** (**XACML**) is an XML-based norm
    for this, but there exist also more recent approaches such as **Open Policy**
    **Agent** (**OPA**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In conclusion, IAM is another example of how information systems have positively
    evolved once the recipe of industrialization has been applied: dividing this complex
    subject into clear-cut, separate responsibilities, and then applying norms and
    standards to each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this chapter will make an analogy with other systems that may
    be highly complex and use lots of standards, namely the cities in which lots of
    us live. And I am not talking about smart cities, where software serves urban
    management, but just cities in their organization emerging over time.
  prefs: []
  type: TYPE_NORMAL
- en: The urbanism metaphor of information systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why did I spend so much time and use so much text talking about technologies
    that became standards and had a great impact on the ease of use and capacity of
    the evolution of information systems inside of which they are used? Well, because
    what has been done for application deployment and IAM can be done for any function
    in a software system. There may not be an undeniable, internationally approved
    standard behind every functionality you need to operate in your system, but deploying
    a locally approved standard will provide the exact same benefits inside the perimeter
    of your own information system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach of industrializing an information system by cutting it into zones
    and standardizing the interfaces between them is the best approach to keep it
    in a functional state of health over time. Depending on the context, you may hear
    about “business/IT alignment,” “enterprise architecture,” or “urbanization of
    information systems.” The third expression refers to a metaphor where the information
    system is compared to a modern city:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The organization follows hierarchical zoning**: Large zones are dedicated
    to housing, commerce, or industry. Inside these zones, one will find neighborhoods
    that define a smaller portion of the zone. Finally, blocks articulate buildings
    together inside a neighborhood. One will find the same hierarchy inside a well-groomed
    information system with large business domain zones (for example, administration),
    inside of which specialized direction will appear (let’s say human resources),
    and finally blocks of functions (in our example, hiring management).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fluids are standardized for a city to operate correctly**: If firefighters
    had to adapt to different pipe diameters in different parts of the city, there
    would, of course, be a problem. The same goes for electricity, water, waste pipes,
    and so on. That may sound crazy today since all this has been perfectly normalized
    for decades, but at the beginning of the 20th century, a city such as Paris had
    several different electricity companies, some of them operating 110 volts, some
    220 volts, some in **alternating current** (**AC**), some in **constant current**
    (**CC**), some at 50 Hz, some at 60 Hz, and most of them with different plug formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large city always evolves, and work in progress in the east of the city is
    meant to have as little impact on the life of inhabitants of the west side. The
    same goes for information systems where change is the only constant, and the impact
    on one piece should be as much as possible without impact on other applications.
    Town architects provide a global vision and direction of evolution but the day-to-day
    changes of the city are organic and can happen because of normalization. Well-established
    information systems can do the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sadly, it seems that enterprise architecture is not very widespread. This partly
    comes from the fact that this is a complex activity; but it also comes from a
    lack of knowledge and information spread, against which this book proposes to
    humbly provide a remedy. I will try in the next chapters to show that industrial
    and standardization approaches in information systems can bring a lot of value
    and radically reduce stiffness and difficulty to evolve for most information systems
    and that the knowledge and practices to reach this are far from being as complicated,
    as most IT architects think.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained at length the concepts of industrialization and standardization
    and then explained how they can be applied to the field of software and computer
    science. Lots of information systems nowadays have difficulty evolving, as stated
    in the previous chapter, and industrialization, though a recent field in computer
    science, is a way to strongly improve their efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to get a bit more practical, starting from
    the – admittedly theoretical – material in this chapter, and explain methods to
    put the industrial approach in place in information systems. The most known approach
    that will be presented is called “business/IT alignment.” In a few words, it states
    that the structure of IT must reflect the structure of the business processes
    the information system is there to help.
  prefs: []
  type: TYPE_NORMAL
