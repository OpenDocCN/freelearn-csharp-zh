- en: '*Chapter 8*: Writing Custom Middleware'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow, we are already onto the eighth chapter of this book! In this chapter, we
    will learn about **middleware** and how you can use it to customize your app a
    little more. We will quickly go over the basics of middleware and then we'll explore
    some special things you can do with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the potential of middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware on ASP.NET Core 3.0 and later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter relate to the middleware layer of the ASP.NET
    Core architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The ASP.NET Core architecture](img/Figure_8.1_B17996.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The ASP.NET Core architecture
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core MVC application. To do this, open your console, shell, or Bash terminal,
    and change to your working directory. Then, use the following command to create
    a new MVC application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code by typing the following command in the already-open console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The simple `web` project template changed in .NET 6.0\. In version 6.0, Microsoft
    introduced **minimal APIs** and changed the project template to use the minimal
    API approach. This is a simpler way to bootstrap and to get started with a web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of you probably already know what middleware is, but some of you
    might not. Even if you have already been using ASP.NET Core for a while, you don't
    really need to know about middleware instances in detail, as they are mostly hidden
    behind nicely named extension methods such as `UseMvc()`, `UseAuthentication()`,
    `UseDeveloperExceptionPage()`, and so on. Every time you call a `Use` method in
    the `Startup.cs` file, in the `Configure` method, you'll implicitly use at least
    one – or maybe more – middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: A middleware component is a piece of code that handles the request pipeline.
    Imagine the request pipeline as a huge tube where you can call something and then
    an echo comes back. The middleware is responsible for the creation of this echo
    – it manipulates the sound to enrich the information, handling the source sound,
    or handling the echo.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware components are executed in the order in which they are configured.
    The first middleware component configured is the first that gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: In an ASP.NET Core web application, if the client requests an image or any other
    static file, `StaticFileMiddleware` searches for that resource and returns that
    resource if it finds it. If not, this middleware component does nothing except
    call the next one. If there is no final piece of middleware that handles the request
    pipeline, the request returns nothing. The `MvcMiddleware` component also checks
    the requested resource, tries to map it to a configured route, executes the controller,
    creates a view, and returns an HTML or web API result. If `MvcMiddleware` does
    not find a matching controller, it will return a result anyway – in this case,
    it is a `404` status result. So, in any case, it returns an echo. This is why
    `MvcMiddleware` is the last piece of middleware configured.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A middleware workflow diagram](img/Figure_8.2_B17996.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – A middleware workflow diagram
  prefs: []
  type: TYPE_NORMAL
- en: '`500` status:'
  prefs: []
  type: TYPE_NORMAL
- en: You are able to see how the pipeline is executed if you create an empty ASP.NET
    Core application, as described in the *Technical requirements* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Program.cs` with your favorite editor. This should be pretty small compared
    to a regular ASP.NET Core application. In ASP.NET Core 6.0, Microsoft introduced
    the minimal API approach, which simplifies the application configuration and hides
    a lot of default configuration from the developers. Microsoft is also implementing
    default `using` statements in ASP.NET Core. Because of this, you don''t see any
    `using` statements initially. This is how `Program.cs` looks in ASP.NET Core 6.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, special lambda middleware is bound to the default route and only writes
    `"Hello World!"` to the response stream. The response stream is the echo we learned
    about previously. This special middleware stops the pipeline and returns something
    like an echo. So, it is the last middleware to run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace the line with the call of `app.MapGet()` with the following lines of
    code, right before the `app.Run()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two calls of `app.Use()` also create two lambda middlewares, but this
    time, in addition to dealing with specific requests, the middleware components
    are calling their successors: each middleware component knows which middleware
    component should follow it, and so calls it. The call of `app.Run()` replaces
    the call of `app.MapGet()`, but it does basically the same thing, except that
    `app.Run()` directly writes to the response stream. The lambda middlewares created
    with `app.Use()` write to the response stream before and after the next middleware
    is called. Before the next middleware is called, the actual request is handled,
    and after the next middleware is called, the response (echo) is handled. This
    should demonstrate how the pipeline works.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you now run the application (using `dotnet run`) and open the displayed
    URL in the browser, you should see a plain text result like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Does this make sense to you? If yes, let's move on and see how to use this concept
    to add some additional functionality to the request pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core is based on middleware. All the logic that gets executed during
    a request is based on middleware. So, we can use this to add custom functionality
    to the web. In the following process, we want to find out the execution time of
    every request that goes through the request pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by creating and starting a stopwatch before the next middleware
    is called, and stop measuring the execution time after the next middleware is
    called, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might need to add a `using` statement for `System.Diagnostics`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After that, we return the elapsed milliseconds to the response stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you write some more middleware components, the configuration in `Program.cs`
    gets pretty messy. This is why most middleware components are written as separate
    classes. This could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way, we get the next middleware component to execute via the constructor
    and the current context in the `Invoke()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The middleware is initialized at the start of the application and the constructor
    runs only once during the application lifetime. On the other hand, the `Invoke()`
    method is called once per request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use this middleware, there is a generic `UseMiddleware()` method available
    that you can use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, the more elegant way is to create an `extension` method that encapsulates
    this call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can simply call it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way, you can provide additional functionality to an ASP.NET Core application
    through the request pipeline. You have the entire `HttpContext` available in your
    middleware. With this, you can manipulate the request or even the response using
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `AuthenticationMiddleware` tries to collect user information from
    the request. If it doesn't find any, it will ask for the information by sending
    a specific response back to the client. If it finds some information, it will
    add it to the request context and make it available to the entire application
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the potential of middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other things you can do with middleware. For example, did you
    know that you can split the request pipeline into two or more pipelines? We'll
    look at how to do that and several other things in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Branching the pipeline with /map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next code snippet shows how to create branches of the request pipeline
    based on specific paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `/map1` path is a specific branch that continues the request pipeline inside
    – this is the same with the `/map2` path. Both maps have their own middleware
    configurations inside. All other unspecified paths will follow the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Branching the pipeline with MapWhen()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is also a `MapWhen()` method to branch the pipeline based on a condition,
    instead of a branch based on a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll look at using middleware to create conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conditions with middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create conditions based on configuration values or, as shown here, based
    on properties of the request context. In the previous example, a query string
    property was used. You can use HTTP headers, form properties, or any other property
    of the request context.
  prefs: []
  type: TYPE_NORMAL
- en: You are also able to nest the maps to create child and grandchild branches if
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `Map()` or `MapWhen()` to provide a special API or resource based
    on a specific path or a specific condition, respectively. The ASP.NET Core `HealthCheck`
    API works like this: first, it uses `MapWhen()` to specify the port to use, and
    then, it uses `Map()` to set the path for the `HealthCheck` API (or, it uses `Map()`
    if no port is specified). In the end, `HealthCheckMiddleware` is used. The following
    code is just an example to show what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see how you should use terminating middleware components in newer
    versions of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Using middleware in ASP.NET Core 3.0 and later
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 3.0 and later, there are two new kinds of middleware element,
    and they are called `UseRouting` and `UseEndpoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first one is a middleware component that uses routing and the other one
    uses endpoints. So, what exactly are we looking at?
  prefs: []
  type: TYPE_NORMAL
- en: This is the new **endpoint routing**. Previously, routing was part of MVC, and
    it only worked with MVC, web APIs, and frameworks that are based on the MVC framework.
    In ASP.NET Core 3.0 and later, however, routing is no longer in the MVC framework.
    Now, MVC and the other frameworks are mapped to a specific route or endpoint.
    There are different kinds of endpoint definitions available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, a `GET` request is mapped to the page root URL.
    In the next code snippet, MVC is mapped to a route pattern, and **Razor Pages**
    are mapped to the Razor Pages-specific file structure-based routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There is no `UseMvc()` method anymore, even if it still exists and works on
    the `IApplicationBuilder` object level, to prevent the existing code from breaking.
    Now, there are new methods to activate ASP.NET Core features more granularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most commonly used new `Map` methods for ASP.NET Core 5.0 or
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '`endpoints.MapAreaControllerRoute(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoints.MapControllerRoute(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoints.MapBlazorHub(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoints.MapHub(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoints.MapRazorPages(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoints.MapHealthChecks(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more methods to define fallback endpoints, to map routes and
    HTTP methods to delegates, and for middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create middleware that works on all requests, such as `StopWatchMiddleware`,
    this will work as before on `IApplicationBuilder`. If you would like to write
    middleware to work on a specific path or route, you will need to create a `Map`
    method for it to map it to that route.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: It is no longer recommended to handle the route inside the middleware. Instead,
    you should use the new endpoint routing. With this approach, the middleware is
    a lot more generic, and it will work on multiple routes with a single configuration.
  prefs: []
  type: TYPE_NORMAL
- en: I recently wrote middleware to provide a **GraphQL** endpoint in an ASP.NET
    Core application. However, I had to rewrite it to follow the new ASP.NET Core
    routing. The old way would still have worked, but it would have handled the paths
    and routes separately from the new ASP.NET Core routing. Let's look at how to
    deal with those situations.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting terminating middleware to meet the current standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have existing middleware that provides a different endpoint, you should
    change it to use the new endpoint routing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s create small, dummy middleware that writes an application
    status to a specific route. In this example, there is no custom route handling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we need to do is write an `extension` method on the `IEndpointRouteBuilder`
    object. This method has a route pattern as an optional argument and returns an
    `IEndpointConventionBuilder` object to enable **cross-origin resource sharing**
    (**CORS**), authentication, or other conditions to the route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we should add an extension method to make it easier to use the middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once that is complete, we can use the `MapAppStatus` method to map it to a
    specific route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now call the route in the browser by entering the following address:
    `http://localhost:5000/status`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will learn more about endpoint routing and how to customize it in [*Chapter
    9*](B17996_09_ePub.xhtml#_idTextAnchor143), *Working with Endpoint Routing*. For
    now, let's recap what we've learned about middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the ASP.NET Core features are based on middleware and in this chapter,
    you learned how middleware works and how to create your own middleware components
    to extend the ASP.NET framework. You also learned how to use the new routing to
    add routes to your own custom terminating middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at the new endpoint routing in ASP.NET
    Core, which allows you to create your own hosted endpoints in an easy and flexible
    way.
  prefs: []
  type: TYPE_NORMAL
