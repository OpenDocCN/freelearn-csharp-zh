- en: Surface Shaders and Texture Mapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表面着色器和纹理映射
- en: In this chapter, we will explore the topic of Surface Shaders in greater detail
    than in the previous chapter. We will start from building a very simple matte
    material and end with holographic projections and the advanced blending of terrains.
    We will also see how you can use textures to animate, blend, and drive any other
    property that they like.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将比上一章更深入地探讨表面着色器。我们将从一个非常简单的哑光材质开始，以全息投影和高级地形混合结束。我们还将看到如何使用纹理来动画化、混合和驱动它们喜欢的任何其他属性。
- en: 'In this chapter, you will learn about the following methods:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下方法：
- en: Diffuse shading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漫反射着色
- en: Accessing and modifying packed arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和修改打包数组
- en: Adding a texture to a shader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向着色器添加纹理
- en: Scrolling textures by modifying UV values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改UV值滚动纹理
- en: Creating a shader with normal mapping
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用法线贴图创建着色器
- en: Creating a transparent material
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建透明材质
- en: Creating a Holographic Shader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建全息着色器
- en: Packing and blending textures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和混合纹理
- en: Creating a circle around your terrain
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的地形周围创建一个圆
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Surface Shaders were introduced in [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*, as the main type of shader that's used in Unity.
    This chapter will show you in detail what these actually are and how they work.
    Generally speaking, there are two essential steps in every Surface Shader. First,
    you have to specify certain physical properties of the material that you want
    to describe, such as its diffuse color, smoothness, and transparency. These properties
    are initialized in a function called the **surface function** and are stored in
    a structure called the `SurfaceOutput`. Secondly, the `SurfaceOutput` is passed
    to a lighting model. This is a special function that will also take information
    about the nearby lights in the scene. Both of these parameters are then used to
    calculate the final color for each pixel of your model. The lighting function
    is where the real calculations of a shader take place as it's the piece of code
    that determines how light should behave when it touches a material.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表面着色器在[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)“创建你的第一个着色器”中引入，作为Unity中使用的着色器的主要类型。本章将详细介绍这些着色器的实际内容和它们的工作原理。一般来说，每个表面着色器有两个基本步骤。首先，你必须指定你想要描述的材料的某些物理属性，例如其漫反射颜色、平滑度和透明度。这些属性在名为**surface
    function**的函数中初始化，并存储在名为`SurfaceOutput`的结构中。其次，`SurfaceOutput`被传递给一个光照模型。这是一个特殊的函数，它还会接收场景中附近灯光的信息。这两个参数随后被用来计算模型每个像素的最终颜色。光照函数是着色器真正计算的地方，因为它是确定光线接触材料时应如何行为的代码片段。
- en: 'The following diagram loosely summarizes how a Surface Shader works. Custom
    lighting models will be explored in [Chapter 4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08),
    *Understanding Lighting Models*, while [Chapter 6](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Vertex Functions*, will focus on vertex modifiers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表大致总结了表面着色器的工作原理。自定义光照模型将在[第4章](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08)“理解光照模型”中探讨，而[第6章](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08)“顶点函数”将专注于顶点修改器：
- en: '![](img/00040.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: Diffuse shading
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫反射着色
- en: Before starting our journey into texture mapping, it is important to understand
    how diffuse materials work. Certain objects might have a uniform color and smooth
    surface, but are not smooth enough to shine in reflected light. These matte materials
    are best represented with a Diffuse Shader. While, in the real world pure diffuse
    materials do not exist, Diffuse Shaders are relatively cheap to implement and
    are largely applied in games with low-poly aesthetics, so they're worth learning
    about.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始纹理映射之旅之前，了解漫反射材料的工作原理非常重要。某些物体可能具有均匀的颜色和光滑的表面，但不够光滑以在反射光中发光。这些哑光材料最好用漫反射着色器来表示。虽然，在现实世界中纯漫反射材料不存在，但漫反射着色器的实现相对便宜，并且在具有低多边形美学的游戏中大量应用，因此它们值得学习。
- en: There are several ways in which you can create your own Diffuse Shader. A quick
    way is to start with Unity's Standard Surface Shader and edit it to remove any
    additional texture information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式创建自己的漫反射着色器。一种快速的方法是从Unity的标准表面着色器开始，并编辑它以删除任何额外的纹理信息。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting this recipe, you should have created a Standard Surface Shader
    with the name `SimpleDiffuse`. For instructions on creating a Standard Surface
    Shader, look at the *Creating a basic Standard Surface Shader* recipe located
    in  [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader, *if you haven't done so already.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此配方之前，您应该已经创建了一个名为`SimpleDiffuse`的标准表面着色器。有关创建标准表面着色器的说明，请参阅[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)中的*创建您的第一个着色器*配方，如果您还没有这样做的话。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open up the `SimpleDiffuse` shader you''ve created and make the following changes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您创建的`SimpleDiffuse`着色器，并做出以下更改：
- en: 'In the `Properties` section, remove all of the variables except for  `_Color`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`属性`部分，删除除`_Color`之外的所有变量：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the `SubShader{}` section, remove the `_MainTex`, `_Glossiness`, and `_Metallic`
    variables. You should not remove the reference to `uv_MainTex` as Cg does not
    allow the `Input` struct to be empty. The value will simply be ignored.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`SubShader{}`部分中删除`_MainTex`、`_Glossiness`和`_Metallic`变量。您不应该删除对`uv_MainTex`的引用，因为Cg不允许`Input`结构为空。该值将被简单地忽略。
- en: Also, remove the `UNITY_INSTANCING_BUFFER_START/END` macros and the comments
    used with them.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，删除`UNITY_INSTANCING_BUFFER_START/END`宏及其相关的注释。
- en: 'Remove the content of the `surf()` function and replace it with the following:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`surf()`函数的内容，并替换为以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Your shader should look as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的着色器应该看起来如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The two lines below `CGPROGRAM` is actually one line and is cut off due to the
    size of the book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`CGPROGRAM`的两行实际上是同一行，由于书籍的大小而被截断。
- en: As this shader has been refitted with a Standard Shader, it will use physically-based
    rendering to simulate how light behaves on your models.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个着色器已经适配了Standard Shader，它将使用基于物理的渲染来模拟光线在模型上的行为。
- en: If you are trying to achieve a non-photorealistic look, you can change the first
    `#pragma` directive so that it uses `Lambert` rather than `Standard`. If you do
    so, you should also replace the  `SurfaceOutputStandard` parameter of the `surf`
    function with `SurfaceOutput`. For more information on this and the other lighting
    models that Unity supports, Jordan Stevens put together a very nice article about
    it, which you can see here: [http://www.jordanstevenstechart.com/lighting-models](http://www.jordanstevenstechart.com/lighting-models)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图实现非真实感的外观，您可以更改第一个`#pragma`指令，使其使用`Lambert`而不是`Standard`。如果您这样做，还应该将`surf`函数的`SurfaceOutputStandard`参数替换为`SurfaceOutput`。有关此信息和Unity支持的其他光照模型的信息，Jordan
    Stevens编写了一篇非常好的文章，您可以通过以下链接查看：[http://www.jordanstevenstechart.com/lighting-models](http://www.jordanstevenstechart.com/lighting-models)
- en: Save the shader and dive back into Unity. Using the same instructions as in
    the *Creating a basic Standard Surface Shader* recipe located in  [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader,* create a new material called `SimpleDiffuseMat` and apply
    our newly created shader to it. Change the color to something different, such
    as red, by clicking on the window next to the Color property in the Inspector window
    while selected.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存着色器，然后返回Unity。使用与[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)中*创建基本标准表面着色器*配方相同的指令，创建一个名为`SimpleDiffuseMat`的新材质，并将我们新创建的着色器应用到它上。通过在检查器窗口中选择并单击颜色属性旁边的窗口，将颜色更改为不同的颜色，例如红色。
- en: 'Then, go into the `Models` folder of this book''s example code and bring the
    bunny object into our scene by dragging and dropping it from the Project window
    into the Hierarchy window. From there, assign the `SimpleDiffuseMat` material
    to the object:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，进入本书示例代码的`Models`文件夹，通过从项目窗口拖放到层次窗口中，将兔子对象拖放到我们的场景中。从那里，将`SimpleDiffuseMat`材质分配给对象：
- en: '![](img/00041.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.jpeg)'
- en: You can double-click on an object in the Hierarchy tab in order to center the
    camera on the object that's been selected.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在层次窗口中双击一个对象，以便将相机居中到所选对象。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The way shaders allow you to communicate the rendering properties of your material
    to their lighting model is via their `SurfaceOutput`. It is basically a wrapper
    around all the parameters that the current lighting model needs. It should not
    surprise you that different lighting models have different `SurfaceOutput` structs.
    The following table shows the three main output structs used in Unity and how
    they can be used:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器允许你通过它们的 `SurfaceOutput` 将你的材料渲染属性传达给光照模型的方式。它基本上是围绕当前光照模型所需的所有参数的一个包装。不同光照模型有不同的
    `SurfaceOutput` 结构体，这不会让你感到惊讶。以下表格显示了在 Unity 中使用的三个主要输出结构体以及它们的使用方法：
- en: '| **Type of shaders** | **Standard** | **Physically-Based Lighting Models**
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **着色器类型** | **标准** | **基于物理的光照模型** |'
- en: '| Diffuse | Any Surface Shader`SurfaceOutput` | Standard`SurfaceOutputStandard`
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 扩散 | 任何表面着色器`SurfaceOutput` | 标准`SurfaceOutputStandard` |'
- en: '| Specular | Any Surface Shader`SurfaceOutput` | Standard (Specular setup)`SurfaceOutputStandardSpecular`
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 镜面 | 任何表面着色器`SurfaceOutput` | 标准（镜面设置）`SurfaceOutputStandardSpecular` |'
- en: 'The `SurfaceOutput` struct has the following properties:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceOutput` 结构体具有以下属性：'
- en: '`fixed3 Albedo;`: This is the diffuse color of the material'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Albedo;`: 这是材料的扩散颜色'
- en: '`fixed3 Normal;`: This is the tangent space, normal, if written'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Normal;`: 这是切线空间中的法线，如果写入的话'
- en: '`fixed3 Emission;`: This is the color of the light emitted by the material
    (this property is declared as `half3` in the Standard Shaders)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Emission;`: 这是材料发出的光的颜色（在标准着色器中此属性被声明为 `half3`）'
- en: '`fixed Alpha;`: This is the transparency of the material'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed Alpha;`: 这是材料的透明度'
- en: '`half Specular;`: This is the specular power from `0` to `1`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half Specular;`: 这是镜面功率，范围从 `0` 到 `1`'
- en: '`fixed Gloss;`: This is the specular intensity'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed Gloss;`: 这是镜面强度的固定值'
- en: 'The `SurfaceOutputStandard` struct has the following properties:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceOutputStandard` 结构体具有以下属性：'
- en: '`fixed3 Albedo;`: This is the base color of the material (whether it''s diffuse
    or specular)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Albedo;`: 这是材料的基色（无论是扩散还是镜面）'
- en: '`fixed3 Normal;`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Normal;`'
- en: '`half3 Emission;`: This property is declared as `half3`, while it was defined
    as `fixed3` in `SurfaceOutput`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half3 Emission;`: 这个属性被声明为 `half3`，而在 `SurfaceOutput` 中定义为 `fixed3`'
- en: '`fixed Alpha;`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed Alpha;`'
- en: '`half Occlusion;`: This is the occlusion (default `1`)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half Occlusion;`: 这是遮挡（默认 `1`）'
- en: '`half Smoothness;`: This is the smoothness (`0` = rough, `1` = smooth)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half Smoothness;`: 这是平滑度（`0` = 粗糙，`1` = 平滑）'
- en: '`half Metallic;`: `0` = non-metal, `1`= metal'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half Metallic;`: `0` = 非金属，`1` = 金属'
- en: 'The `SurfaceOutputStandardSpecular` struct has the following properties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceOutputStandardSpecular` 结构体具有以下属性：'
- en: '`fixed3 Albedo;`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Albedo;`'
- en: '`fixed3 Normal;`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Normal;`'
- en: '`half3 Emission;`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half3 Emission;`'
- en: '`fixed Alpha;`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed Alpha;`'
- en: '`half Occlusion;`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half Occlusion;`'
- en: '`half Smoothness;`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half Smoothness;`'
- en: '`fixed3 Specular;`: This is the specular color. This is very different from
    the `Specular` property in `SurfaceOutput` as it allows you to specify a color
    rather than a single value.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed3 Specular;`: 这是镜面颜色。这与 `SurfaceOutput` 中的 `Specular` 属性非常不同，因为它允许你指定一个颜色而不是单个值。'
- en: Using a Surface Shader correctly is a matter of initializing the `SurfaceOutput`
    with the correct values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正确初始化 `SurfaceOutput` 为正确的值是正确使用表面着色器的问题。
- en: For more information on creating Surface Shaders, check out the following link: [https://docs.unity3d.com/Manual/SL-SurfaceShaders.html](https://docs.unity3d.com/Manual/SL-SurfaceShaders.html)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建表面着色器的更多信息，请查看以下链接： [https://docs.unity3d.com/Manual/SL-SurfaceShaders.html](https://docs.unity3d.com/Manual/SL-SurfaceShaders.html)
- en: Accessing and modifying packed arrays
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和修改打包数组
- en: Loosely speaking, the code inside a shader has to be executed for at least every
    pixel in your screen. This is the reason why GPUs are highly optimized for parallel
    computing; they can execute multiple processes at the same time. This philosophy
    is also evident in the standard type of variables and operators available in Cg.
    Understanding them is essential, not just so that you can use the shaders correctly,
    but also to write highly optimized ones.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，着色器内部的代码必须至少执行屏幕上每个像素一次。这就是为什么 GPU 高度优化了并行计算；它们可以同时执行多个进程。这种理念在 Cg 中可用的标准类型变量和运算符中也很明显。理解它们是至关重要的，不仅是为了正确使用着色器，也是为了编写高度优化的着色器。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are two types of variables in Cg: single values and packed arrays. The
    latter can be identified because their type ends with a number such as `float3`
    or `int4`. As their names suggest, these types of variables are similar to structs,
    which means that they each contain several single values. Cg calls them packed
    arrays, though they are not exactly *arrays* in the traditional sense.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Cg中有两种类型的变量：单个值和压缩数组。后者可以通过它们的类型以数字结尾来识别，例如`float3`或`int4`。正如它们的名称所暗示的，这些类型的变量类似于结构体，这意味着它们各自包含几个单个值。Cg称它们为压缩数组，尽管它们在传统意义上并不完全是**数组**。
- en: 'The elements of a packed array can be accessed as a normal struct. They are
    typically called `x`, `y`, `z`, and `w`. However, Cg also provides you with another
    alias for them, that is, `r`, `g`, `b`, and `a`. Despite there being no difference
    between using `x` or `r`, it can make a huge difference for the readers. Shader
    coding, in fact, often involves calculation with positions and colors. You might
    have seen this in the Standard Shaders:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩数组的元素可以像正常结构体一样访问。它们通常被称为`x`、`y`、`z`和`w`。然而，Cg还为你提供了它们的另一个别名，即`r`、`g`、`b`和`a`。尽管使用`x`或`r`之间没有区别，但它对读者来说可能有很大的影响。实际上，着色器编码通常涉及位置和颜色的计算。你可能在标准着色器中见过这种情况：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `o` was a struct and `_Color` was a packed array. This is also why Cg
    prohibits the mixed usage of these two syntaxes: you cannot use `_Color.xgz`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`o`是一个结构体，`_Color`是一个压缩数组。这也是为什么Cg禁止混合使用这两种语法：你不能使用`_Color.xgz`。
- en: 'There is also another important feature of packed arrays that has no equivalent
    in C#: **swizzling**. Cg allows addressing and reordering elements within packed
    arrays in just a single line. Once again, this appears in the Standard Shader:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩数组还有一个重要的特性，在C#中没有等效功能：**swizzling**。Cg允许在单行内对压缩数组中的元素进行寻址和重新排序。再次强调，这也在标准着色器中体现出来：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Albedo` is `fixed3`, which means that it contains three values of the `fixed`
    type. However, `_Color` is defined as a  `fixed4` type.  A direct assignment would
    result in a compiler error as `_Color` is bigger than `Albedo`. The C# way of
    doing this would be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Albedo`是`fixed3`，这意味着它包含三个`fixed`类型的值。然而，`_Color`被定义为`fixed4`类型。直接赋值会导致编译器错误，因为`_Color`比`Albedo`大。在C#中这样做的方式如下：'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, it can be compressed in Cg:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Cg中它可以被压缩：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cg also allows reordering elements, for instance, using `_Color.bgr` to swap
    the red and blue channels.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Cg还允许重新排序元素，例如，使用`_Color.bgr`来交换红色和蓝色通道。
- en: 'Lastly, when a single value is assigned to a packed array, it is copied to
    all of its fields:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当单个值赋给压缩数组时，它被复制到所有字段中：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is referred to as **smearing**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**模糊化**。
- en: 'Swizzling can also be used on the left-hand side of an expression, allowing
    only certain components of a packed array to be overwritten:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Swizzling也可以用于表达式的左侧，允许只覆盖压缩数组的某些组件：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, it is called **masking**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它被称为**遮罩**。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Where swizzling really shows its full potential is when it''s applied to packed
    matrices. Cg allows types such as `float4x4`, which represents a matrix of floats
    with four rows and four columns. You can access a single element of the matrix
    using the `_mRC` notation, where *R* is the row and *C* is the column:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当swizzling应用于压缩矩阵时，它真正显示出其全部潜力。Cg允许使用`float4x4`这样的类型，它代表一个有四行四列的浮点矩阵。你可以使用`_mRC`表示法访问矩阵的单个元素，其中*R*是行，*C*是列：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `_mRC` notation can also be chained:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`_mRC`表示法也可以链式使用：'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An entire row can be selected using squared brackets:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用方括号选择整行：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In addition to being easier to write, swizzling, smearing, and masking properties
    have performance benefits as well
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了更容易编写之外，swizzling、smearing和masking属性还有性能优势。
- en: However, inappropriate use of swizzling can also make your code harder to understand
    at first glance, and may make it harder for the compiler to automatically optimize
    your code
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，不当使用swizzling可能会使你的代码在第一眼看起来更难以理解，也可能使编译器更难自动优化你的代码。
- en: Packed arrays are one of the nicest features of Cg. You can discover more about
    them here: [http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩数组是Cg最吸引人的特性之一。你可以在这里了解更多信息：[http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html)
- en: Adding a texture to a shader
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向着色器添加纹理
- en: Textures can bring our shaders to life very quickly in terms of achieving very
    realistic effects. In order to effectively use textures, we need to understand
    how a 2D image is mapped to a 3D model. This process is called texture mapping,
    and it requires some work to be done on the shader and 3D model that we want to
    use. Models, in fact, are made out of triangles, which are often referred to as
    polygons; each vertex on the model can store data that shaders can access and
    use to determine what to draw.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以迅速使我们的着色器变得生动，以实现非常逼真的效果。为了有效地使用纹理，我们需要了解二维图像是如何映射到三维模型的。这个过程称为纹理映射，并且需要对我们要使用的着色器和
    3D 模型进行一些工作。实际上，模型是由三角形组成的，通常被称为多边形；模型上的每个顶点都可以存储着色器可以访问和使用的数据，以确定要绘制的内容。
- en: 'One of the most important pieces of information that are stored in vertices
    is the **UV data**. It consists of two coordinates, *U* and *V*, ranging from
    0 to 1\. They represent the *XY* position of the pixel in the 2D image that will
    be mapped to the vertices. UV data is present only for vertices; when the inner
    points of a triangle have to be texture-mapped, the GPU interpolates the closest
    UV values to find the right pixel in the texture to be used. The following diagram
    shows you how a **2D Texture** is mapped to a triangle from a 3D model:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在顶点中最重要的信息之一是 **UV 数据**。它由两个坐标组成，*U* 和 *V*，范围从 0 到 1。它们代表将要映射到顶点的 2D 图像中像素的
    *XY* 位置。UV 数据仅存在于顶点中；当三角形的内部点需要纹理映射时，GPU 会插值最接近的 UV 值，以找到纹理中要使用的正确像素。以下图表显示了如何将
    **2D 纹理**从 3D 模型映射到三角形：
- en: '![](img/00042.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: The UV data is stored in the 3D model and requires modeling software to be edited.
    Some models lack the UV component, hence they cannot support texture mapping.
    The Stanford bunny, for example, was not originally provided with one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: UV 数据存储在 3D 模型中，需要使用建模软件进行编辑。一些模型缺少 UV 组件，因此它们无法支持纹理映射。例如，斯坦福兔子最初并没有提供 UV 组件。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need a 3D model with UV data and its texture. They both
    need to be imported to Unity before starting. You can do this simply by dragging
    them to the editor. As the Standard Shader supports texture mapping by default,
    we'll use this and then explain how it works in detail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要一个带有 UV 数据和纹理的 3D 模型。在开始之前，它们都需要导入到 Unity 中。你可以通过简单地拖动它们到编辑器中来实现。由于标准着色器默认支持纹理映射，我们将使用它，并详细解释其工作原理。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Adding a texture to your model using the Standard Shader is incredibly simple,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准着色器为你的模型添加纹理非常简单，如下所示：
- en: In the Sample Code for this chapter that's provided with this book, you can
    find the `basicCharacter` model which, by default, has UV information embedded
    into it, making it so that when we attach a material, it will draw the texture
    using that information.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书提供的本章示例代码中，你可以找到 `basicCharacter` 模型，默认情况下，它已经嵌入 UV 信息，这使得当我们附加材质时，它会使用这些信息来绘制纹理。
- en: Create a new Standard Surface Shader called `TexturedShader` by going to the
    Project tab and then selecting Create | Shaders | Standard Surface Shader. Once
    created, you can type in a new name for the shader and then press *Enter*.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到项目标签并选择创建 | 着色器 | 标准表面着色器，创建一个名为 `TexturedShader` 的新标准表面着色器。一旦创建，你可以输入着色器的新名称，然后按
    *Enter* 键。
- en: 'For organization''s sake, open the shader and change the first line to the
    following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了组织起见，打开着色器并将第一行更改为以下内容：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will allow us to find the shader inside of the organization we have been
    using so far for this book.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使我们能够找到我们迄今为止为本书使用的组织内部的着色器。
- en: Create a new material called `TexturedMaterial` by going to the Project tab
    and then selecting Create | Material. Once created, you can type in a new name
    for the material and then press *Enter* to confirm the change.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到项目标签并选择创建 | 材质，创建一个名为 `TexturedMaterial` 的新材质。一旦创建，你可以输入材质的新名称，然后按 *Enter*
    键确认更改。
- en: 'Assign the shader to the material by going to the Inspector tab and then clicking
    on the Shader dropdown before selecting `CookbookShaders/Chapter 03/TexturedShader`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到检查器标签并点击着色器下拉菜单，然后选择 `CookbookShaders/Chapter 03/TexturedShader` 来将着色器分配给材质：
- en: '![](img/00043.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: You may also do this by first selecting the material and then dragging the shader
    file over it in the Project tab.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过首先选择材质，然后在项目标签中将其拖动到着色器文件上来实现这一点。
- en: 'After selecting the material, drag your texture to the empty rectangle called
    Albedo (RGB). If you are missing some, there are textures located in this chapter''s
    example code that can be used. If you have followed all of these steps correctly,
    your material Inspector tab should look like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择材质后，将你的纹理拖放到名为Albedo (RGB)的空白矩形中。如果你缺少某些纹理，本章的示例代码中提供了可以使用的纹理。如果你正确地遵循了所有这些步骤，你的材质检查器标签页应该看起来像这样：
- en: '![](img/00044.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: The Standard Shader knows how to map a 2D image to a 3D model using its UV models
    and textures used in this example were created by Kenney Vleugels and Casper Jorissen.
    You can find these and many other public domain game assets at [Kenney.nl](http://Kenney.nl).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 标准着色器知道如何使用其UV模型和纹理将2D图像映射到3D模型，本例中使用的纹理是由Kenney Vleugels和Casper Jorissen创建的。你可以在[Kenney.nl](http://Kenney.nl)找到这些以及其他许多公共领域游戏资产。
- en: 'To see the UV data in action, in the example code''s `Models` folder, drag
    and drop the model into the Hierarchy tab. Once there, double-click on the newly
    created object to zoom in so that you can see the object:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看UV数据在实际中的应用，在示例代码的`模型`文件夹中，将模型拖放到“层次结构”标签页。一旦到达那里，双击新创建的对象以便放大，以便你可以看到该对象：
- en: '![](img/00045.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00045.jpeg)'
- en: 'Once there, you may go to the Project tab and open up the `Chapter 3 `| `Materials`
    folder and drag and drop our `Textured Material` onto the character. Note that
    the model consists of different objects, each of which provides direction to draw
    in a particular place. This means that you will need to drop the material on each
    part of the model (`ArmLeft1`, `ArmRight1`, `Body1`, and so on); trying to apply
    this to the top level of the hierarchy only (`basicCharacter`) will not work:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦到达那里，你可以转到“项目”标签页，打开`第3章 `| `材料`文件夹，并将我们的`纹理材质`拖放到角色上。请注意，该模型由不同的对象组成，每个对象都提供了在特定位置绘制方向。这意味着你需要将材质应用到模型的每个部分（`ArmLeft1`、`ArmRight1`、`Body1`等）；仅尝试将其应用于层次结构的顶层（`basicCharacter`）将不会起作用：
- en: '![](img/00046.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00046.jpeg)'
- en: 'It is also possible to change what the object looks like by changing the texture
    that''s being used. For instance, if we use the other texture provided (`skin_womanAlternative`),
    we have a very different looking character:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更改正在使用的纹理，也可以更改对象的外观。例如，如果我们使用提供的其他纹理（`skin_womanAlternative`），我们将得到一个看起来非常不同的角色：
- en: '![](img/00047.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00047.jpeg)'
- en: This is often used in games to provide different kinds of characters with minimal
    cost.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在游戏中用于以最小的成本提供不同类型的角色。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the Standard Shader is used from the Inspector of a material, the process
    behind texture mapping is completely transparent to developers. If we want to
    understand how it works, it''s necessary to take a closer look at `TexturedShader`.
    From the `Properties` section, we can see that the `Albedo (RGB)` texture is actually
    referred to in the code as `_MainTex`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当从材质的检查器使用标准着色器时，纹理映射背后的过程对开发者来说是完全透明的。如果我们想了解它是如何工作的，就需要更仔细地查看`TexturedShader`。从`属性`部分，我们可以看到`Albedo
    (RGB)`纹理实际上在代码中被称为`_MainTex`：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `CGPROGRAM` section, this texture is defined as `sampler2D`, the standard
    type for 2D textures:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CGPROGRAM`部分，此纹理被定义为`sampler2D`，这是2D纹理的标准类型：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following line shows a `struct` called `Input`. This is the input parameter
    for the surface function and contains a packed array called `uv_MainTex`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行显示了一个名为`struct`的结构。这是表面函数的输入参数，包含一个名为`uv_MainTex`的打包数组：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Every time the `surf()` function is called, the `Input` structure will contain
    the UV of `_MainTex` for the specific point of the 3D model that needs to be rendered.
    The Standard Shader recognizes that the name `uv_MainTex` refers to `_MainTex`
    and initializes it automatically. If you are interested in understanding how the
    UV is actually mapped from a 3D space to a 2D texture, you can check out [Chapter
    5](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08), *Understanding Lighting
    Models*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`surf()`函数时，`Input`结构将包含需要渲染的3D模型特定点的`_MainTex`的UV。标准着色器识别出名称`uv_MainTex`指的是`_MainTex`，并自动初始化它。如果你对了解UV实际上是如何从3D空间映射到2D纹理感兴趣，可以查看[第5章](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08)，*理解光照模型*。
- en: 'Finally, the UV data is used to sample the texture in the first line of the
    surface function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，UV数据用于在表面函数的第一行采样纹理：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is done using the `tex2D()` function of Cg; it takes a texture and UV and
    returns the color of the pixel at that position.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用 Cg 的 `tex2D()` 函数来完成的；它接受一个纹理和 UV，并返回该位置的像素颜色。
- en: The *U* and *V* coordinates go from *0* to *1*, where (0,0) and (1,1) correspond
    to two opposite corners. Different implementations associate UV with different
    corners; if your texture happens to appear reversed, try inverting the V component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* 和 *V* 坐标从 *0* 到 *1*，其中 (0,0) 和 (1,1) 对应于两个相对的角。不同的实现将 UV 与不同的角关联；如果你的纹理恰好出现反转，尝试反转
    V 分量。'
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'When you import a texture to Unity, you are setting up some of the properties
    that `sampler2D` will use. The most important is the Filter mode, which determines
    how colors are interpolated when the texture is sampled. It is very unlikely that
    the UV data will point exactly to the center of a pixel; in all other cases, you
    might want to interpolate between the closest pixels to get a more uniform color.
    The following is a screenshot of the Inspector tab of an example texture:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将纹理导入 Unity 时，您正在设置 `sampler2D` 将使用的一些属性。最重要的是过滤模式，它决定了在采样纹理时颜色如何插值。UV 数据不太可能正好指向像素的中心；在其他所有情况下，您可能想要在最近的像素之间进行插值，以获得更均匀的颜色。以下是一个示例纹理的检查器选项卡的截图：
- en: '![](img/00048.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: For most applications, Bilinear provides an inexpensive, yet effective, way
    to smooth the texture. If you are creating a 2D game, however, Bilinear might
    produce blurred tiles. In this case, you can use Point to remove any interpolation
    from the texture sampling.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用来说，双线性提供了既经济又有效的方法来平滑纹理。然而，如果您正在创建 2D 游戏，双线性可能会产生模糊的瓦片。在这种情况下，您可以使用点采样来从纹理采样中移除任何插值。
- en: When a texture is seen from a steep angle, texture sampling is likely to produce
    visually unpleasant artifacts. You can reduce them by setting the Aniso Level
    to a higher value. This is particularly useful for floor and ceiling textures,
    where glitches can break the illusion of continuity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当从陡峭的角度观察纹理时，纹理采样很可能会产生视觉上不愉快的伪影。您可以通过将 Aniso Level 设置为更高的值来减少它们。这对于地板和天花板纹理特别有用，因为故障可能会破坏连续性的幻觉。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you would like to know more about the inner workings of how textures are
    mapped to a 3D surface, you can read the information available at [http://developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于纹理如何映射到 3D 表面的内部工作原理的信息，您可以阅读在 [http://developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html)
    可用的信息。
- en: For a complete list of the options available when importing a 2D texture, you
    can refer to the following website: [http://docs.unity3d.com/Manual/class-TextureImporter.html](http://docs.unity3d.com/Manual/class-TextureImporter.html)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取导入 2D 纹理时可用选项的完整列表，您可以参考以下网站：[http://docs.unity3d.com/Manual/class-TextureImporter.html](http://docs.unity3d.com/Manual/class-TextureImporter.html)
- en: Scrolling textures by modifying UV values
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过修改 UV 值来滚动纹理
- en: One of the most common texture techniques used in today's game industry is the
    process of allowing you to scroll the textures over the surface of an object.
    This allows you to create effects such as waterfalls, rivers, and lava flows.
    It's also a technique that is the basis of creating animated sprite effects, but
    we will cover this in a subsequent recipe of this chapter. First, let's see how
    we will create a simple scrolling effect in a Surface Shader.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今游戏行业中，最常用的纹理技术之一是允许您在对象的表面上滚动纹理的过程。这使您能够创建瀑布、河流和熔岩流动等效果。这同样也是创建动画精灵效果的基础技术，但我们将在这章的后续菜谱中介绍。首先，让我们看看我们如何在
    Surface Shader 中创建一个简单的滚动效果。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin this recipe, you will need to create a new shader file (`ScrollingUVs`)
    and material (`ScrollingUVMat`). This will set us up with a nice clean shader
    that we can use to study the scrolling effect by itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个菜谱，您需要创建一个新的着色器文件（`ScrollingUVs`）和材质（`ScrollingUVMat`）。这将为我们提供一个干净整洁的着色器，我们可以用它单独研究滚动效果。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin with, we will launch our new shader file that we just created and
    enter the code mentioned in the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将启动我们刚刚创建的新着色器文件，并按照以下步骤输入代码：
- en: 'The shader will need two new properties that will allow us to control the speed
    of the texture scrolling. So, let''s add a speed property for the *X* direction
    and a speed property for the *Y* direction, as shown in the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器需要两个新属性，这将允许我们控制纹理滚动的速度。所以，让我们添加一个用于*X*方向的滚动速度属性和一个用于*Y*方向的滚动速度属性，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When working in ShaderLab, `Properties` has a syntax that looks like the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在ShaderLab中工作时，`Properties`的语法看起来如下：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each property contained in the `Properties` block first has a name that is used
    in code to refer to the object, here specified as `_propertyName`. The underscore
    isn't required but is a common standard in place. Inside the parenthesis, you'll
    see two parameters. The first is a string that defines what text will be displayed
    in the Inspector for what this property is. The second parameter is the type of
    data we wish to store.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在`Properties`块中的每个属性首先有一个用于在代码中引用对象的名称，这里指定为`_propertyName`。下划线不是必需的，但这是一个常见的标准。在括号内，您将看到两个参数。第一个是一个字符串，它定义了在检查器中显示的文本，用于表示此属性。第二个参数是我们希望存储的数据类型。
- en: In our case, for the *X* and *Y* Scroll Speed, we are creating a number with
    a possible Range from 0 to 10\. Lastly, we can initialize the property with a
    default value which is done on the end. As we've seen before, these properties
    will show up in the Inspector if you select a material that is using this shader.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，对于*X*和*Y*滚动速度，我们创建了一个可能的范围从0到10的数字。最后，我们可以使用默认值初始化属性，这通常在末尾完成。正如我们之前看到的，如果您选择使用此着色器的材质，这些属性将显示在检查器中。
- en: For more information on Properties and how to create them, check out [https://docs.unity3d.com/Manual/SL-Properties.html](https://docs.unity3d.com/Manual/SL-Properties.html).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有关属性及其创建的更多信息，请参阅[https://docs.unity3d.com/Manual/SL-Properties.html](https://docs.unity3d.com/Manual/SL-Properties.html)。
- en: For this example, we don't need the `Smoothness` or `Metallic` properties, so
    we can remove them as well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们不需要`Smoothness`或`Metallic`属性，因此我们也可以移除它们。
- en: 'Modify the Cg properties in the `CGPROGRAM` section above the definition of
    `_MainTex` and create new variables so that we can access the values from our
    properties:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_MainTex`定义上面的`CGPROGRAM`部分中修改Cg属性，并创建新变量，以便我们可以从我们的属性中访问值：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We also need to remove the `_Glossiness` and `_Metallic` definitions as we are
    not using them anymore.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再使用它们，我们需要移除`_Glossiness`和`_Metallic`的定义。
- en: 'Modify the surface function to change the UVs given to the `tex2D()` function.
    Then, use the built-in `_Time` variable to animate the UVs over time when the
    Play button is pressed in the editor:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改表面函数以改变提供给`tex2D()`函数的UVs。然后，在编辑器中按下播放按钮时，使用内置的`_Time`变量随时间动画UVs：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the script is finished, save it and then go back to the Unity editor.
    Go to the `Materials` folder and assign `ScrollingUVsMat` to use our `ScrollingUVs`
    shader. Once that is done, under the Albedo (RGB) property, drag and drop the
    water texture from the example code provided with this book to assign the property:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本完成，保存它，然后回到Unity编辑器。转到`Materials`文件夹，将`ScrollingUVsMat`分配给使用`ScrollingUVs`着色器的材质。完成后，在Albedo
    (RGB)属性下，从本书提供的示例代码中拖放水纹理以分配属性：
- en: '![](img/00049.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: After this is created, we need to create an object that can use the shader.
    From a new scene, go ahead and select GameObject | 3D Object | Plane and drag
    and drop the `ScrollingUVMat` material onto it.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完成后，我们需要创建一个可以使用着色器的对象。从一个新场景开始，选择GameObject | 3D Object | Plane，并将`ScrollingUVMat`材质拖放到它上。
- en: 'Once applied, go ahead and play the game to see the shader in action:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用，继续玩游戏以查看着色器的作用：
- en: '![](img/00050.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: While it's not visible in this still image, you will notice that in the Unity
    editor, the object will now move in both the *X* and *Y* axes! Feel free to drag
    the X Scroll Speed and Y Scroll Speed properties in the Inspector tab to see how
    the changes affect how the object moves. Also, feel free to move the camera to
    make it easier to see if you would like.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个静态图像中不可见，但您会注意到在Unity编辑器中，对象现在将在*X*和*Y*轴上移动！您可以自由地将X滚动速度和Y滚动速度属性拖放到检查器选项卡中，以查看这些更改如何影响对象的移动。如果您想更容易地看到，也可以自由地移动相机。
- en: If you modify a variable on a Material during gameplay, the value will stay
    changed, unlike how Unity typically works.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在游戏过程中修改了材质上的变量，其值将保持更改，这与Unity通常的工作方式不同。
- en: 'Pretty cool! With this knowledge, we can take this concept much further to
    create interesting visual effects. The following screenshot demonstrates the result
    of utilizing the scrolling UV system with multiple materials in order to create
    a simple river motion for your environments:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷！有了这些知识，我们可以将这个概念进一步发展，以创建有趣的视觉效果。以下截图展示了使用多个材料利用滚动UV系统创建简单河流运动环境的结果：
- en: '![](img/00051.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The scrolling system starts with the declaration of a couple of properties,
    which will allow the user of this shader to increase or decrease the speed of
    the scrolling effect itself. At their core, they are float values being passed
    from the material's Inspector tab to the surface function of the shader. For more
    information on shader properties, see [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动系统从声明几个属性开始，这些属性将允许用户增加或减少滚动效果的滚动速度。在本质上，它们是作为从材料的Inspector标签传递到着色器表面函数的浮点值。有关着色器属性的更多信息，请参阅第2章，*创建您的第一个着色器*。
- en: Once we have these float values from the material's Inspector tab, we can use
    them to offset our UV values in the shader.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从材料的Inspector标签中获取了这些浮点值，我们就可以使用它们在着色器中偏移我们的UV值。
- en: 'To begin this process, we first store the UVs in a separate variable called
    `scrolledUV`. This variable has to be `float2`/`fixed2` because the UV values
    are being passed to us from the `Input` structure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个过程，我们首先将UVs存储在一个名为`scrolledUV`的单独变量中。这个变量必须是`float2`/`fixed2`，因为UV值是从`Input`结构传递给我们的：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once we have access to the mesh's UVs, we can offset them using our scroll speed
    variables and built-in `_Time` variable. This built-in variable returns a variable
    of the `float4` type, meaning that each component of this variable contains different
    values of time as it pertains to game time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够访问网格的UVs，我们可以使用我们的滚动速度变量和内置的`_Time`变量来偏移它们。这个内置变量返回一个`float4`类型的变量，这意味着这个变量的每个分量都包含与游戏时间相关的不同时间值。
- en: 'A complete description of these individual time values is described at the
    following link: [http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html](http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些个别时间值的完整描述可以在以下链接中找到：[http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html](http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html)
- en: 'This `_Time` variable will give us an incremented float value based on Unity''s
    game time clock. So, we can use this value to move our UVs in a UV direction and
    scale that time with our scroll speed variables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`_Time`变量将根据Unity的游戏时间时钟给我们一个递增的浮点值。因此，我们可以使用这个值在UV方向上移动我们的UVs，并使用我们的滚动速度变量来缩放这个时间：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the correct offset being calculated by time, we can add the new offset
    value back to the original UV position. This is why we are using the `+=` operator
    in the next line. We want to take the original UV position, add the new offset
    value, and then pass this to the `tex2D()` function as the texture''s new UVs.
    This creates the effect of the texture moving on the surface. What we are really
    doing is manipulating the UVs, so we are faking the effect of the texture moving:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算正确的时间偏移，我们可以将新的偏移值添加回原始UV位置。这就是为什么我们在下一行使用`+=`运算符的原因。我们想要获取原始UV位置，添加新的偏移值，然后将这个值传递给`tex2D()`函数作为纹理的新UVs。这会在表面上创建纹理移动的效果。我们真正做的是操作UVs，因此我们是在模拟纹理移动的效果：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating a shader with normal mapping
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有法线贴图的着色器
- en: 'Every triangle of a 3D model has a *facing direction*, which is the direction
    that it is pointing toward. It is often represented with an arrow placed in the
    center of the triangle and is orthogonal to the surface. The facing direction
    plays an important role in the way light reflects on a surface. If two adjacent
    triangles face different directions, they will reflect lights at different angles,
    hence they''ll be shaded differently. For curved objects, this is a problem: it
    is obvious that the geometry is made out of flat triangles.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 3D模型的每个三角形都有一个*面向方向*，这是它指向的方向。通常用一个箭头表示，放置在三角形的中心，并且与表面垂直。面向方向在光线反射到表面上的方式中起着重要作用。如果相邻的两个三角形面向不同的方向，它们将以不同的角度反射光线，因此它们将以不同的方式着色。对于弯曲物体，这是一个问题：显然，几何形状是由平面三角形组成的。
- en: To avoid this problem, the way the light reflects on a triangle doesn't take
    into account its facing direction, but its *normal direction* instead. As stated
    in the *Adding a texture to a shader* recipe, vertices can store data; the normal
    direction is the most used information after the UV data. This is a vector of
    unit length (which means it has a length of 1) that indicates the direction faced
    by the vertex.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，三角形上光线的反射方式不考虑其朝向方向，而是考虑其**法线方向**。正如在“向着色器添加纹理”的配方中所述，顶点可以存储数据；法线方向是除UV数据之外最常用的信息。这是一个单位长度的向量（这意味着它的长度为1），它指示顶点所面对的方向。
- en: Regardless of the facing direction, every point within a triangle has its own
    normal direction that is a linear interpolation of the ones stored in its vertices.
    This gives us the ability to fake the effect of high-resolution geometry on a
    low-resolution model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 无论朝向方向如何，三角形内的每个点都有自己的法线方向，它是其顶点中存储的法线的线性插值。这使我们能够在低分辨率模型上模拟高分辨率几何形状的效果。
- en: 'The following screenshot shows the same geometric shape rendered with different
    per-vertex normals. In the image, on the left, normals are orthogonal to the face
    represented by its vertices; this indicates that there is a clear separation between
    each face. On the right, normals are interpolated along the surface, indicating
    that even if the surface is rough, a light should reflect as if it''s smooth.
    It''s easy to see that even if the three objects in the following screenshot share
    the same geometry, they reflect light differently. Despite being made out of flat
    triangles, the object on the right reflects light as if its surface was actually
    curved:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了使用不同顶点法线渲染的相同几何形状。在图像的左侧，法线与由其顶点表示的面垂直；这表明每个面之间有明显的分离。在右侧，法线沿着表面进行插值，表明即使表面是粗糙的，光线也应该像在光滑表面上一样反射。很容易看出，即使以下截图中的三个物体具有相同的几何形状，它们反射光线的方式也不同。尽管它们由平面三角形组成，但右侧的物体反射光线就像其表面实际上是弯曲的一样：
- en: '![](img/00052.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: 'Smooth objects with rough edges are a clear indication that per-vertex normals
    have been interpolated. This can be seen if we draw the direction of the normal
    stored in every vertex, as shown in the following screenshot. You should note
    that every triangle has only three normals, but as multiple triangles can share
    the same vertex, more than one line can come out of it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 带有粗糙边缘的平滑物体是顶点法线插值的一个明显迹象。如果我们绘制每个顶点中存储的法线方向，就像以下截图所示，这一点可以观察到。请注意，每个三角形只有三个法线，但由于多个三角形可以共享同一个顶点，因此可能有多条线从这个顶点发出：
- en: '![](img/00053.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: Calculating the normals from the 3D model is a technique that has rapidly declined
    in favor of a more advanced one-normal mapping. Similar to what happens with texture
    mapping, the normal directions can be provided using an additional texture, usually
    called a normal map or bump map.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从3D模型计算法线是一种迅速被更高级的单法线贴图技术所取代的技术。与纹理贴图类似，法线方向可以通过一个额外的纹理提供，通常称为正常贴图或凹凸贴图。
- en: Normal maps are usually images where the red, green, and blue channels of the
    image are used to indicate the *X*, *Y*, and *Z* components of the normal direction.
    There are many ways to create normal maps these days. Some applications, such
    as CrazyBump ([http://www.crazybump.com/](http://www.crazybump.com/)) and NDO
    Painter ([http://quixel.se/ndo/](http://quixel.se/ndo/)), will take in 2D data
    and convert it to normal data for you. Other applications such as Zbrush 4R7 ([http://www.pixologic.com/](http://www.pixologic.com/))
    and AUTODESK ([http://usa.autodesk.com](http://usa.autodesk.com/)) will take 3D-sculpted
    data and create normal maps for you. The actual process of creating normal maps
    is out of the scope of this book, but the links in the previous text should help
    you get started.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正常贴图通常是使用图像的红色、绿色和蓝色通道来表示法线方向的**X**、**Y**和**Z**分量。如今创建正常贴图的方法有很多。一些应用程序，例如CrazyBump([http://www.crazybump.com/](http://www.crazybump.com/))和NDO
    Painter([http://quixel.se/ndo/](http://quixel.se/ndo/))，会接收2D数据并将其转换为正常数据。其他应用程序，如Zbrush
    4R7([http://www.pixologic.com/](http://www.pixologic.com/))和AUTODESK([http://usa.autodesk.com](http://usa.autodesk.com/))，则会接收3D雕刻数据并为您创建正常贴图。创建正常贴图的实际过程超出了本书的范围，但前文中的链接应该能帮助您开始。
- en: Unity makes the process of adding normals to your shaders quite an easy process
    in the Surface Shader realm using the `UnpackNormals()` function. Let's see how
    this is done.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用`UnpackNormals()`函数使在表面着色器领域添加法线到你的着色器变得非常简单。让我们看看这是如何完成的。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To begin this recipe, first create a new scene by selecting File | New Scene.
    Then, create a sphere game object by going to GameObject | 3D Objects | Sphere.
    Double-click on the object in the Hierarchy tab to bring the object into focus
    in the Scene tab. You will also need to create a new standard Surface Shader file
    (`NormalShader`) and material (`NormalShaderMat`). Once created, set the material
    to a sphere in the Scene view. This will give us a clean workspace in which we
    can look at just the normal mapping technique:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个配方，首先通过选择File | New Scene创建一个新的场景。然后，通过GameObject | 3D Objects | Sphere创建一个球体游戏对象。在Hierarchy标签中双击对象，使其在Scene标签中聚焦。你还需要创建一个新的标准表面着色器文件（`NormalShader`）和材质（`NormalShaderMat`）。创建后，将材质设置为场景中的球体。这将给我们一个干净的工作空间，我们可以查看仅法线贴图技术：
- en: '![](img/00054.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.jpeg)'
- en: You will need a normal map for this recipe, but there is also one in the Unity
    project included with this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这个配方提供一个法线贴图，但本书附带的Unity项目中也有一个。
- en: 'An example normal map included with this book''s content is shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本书内容中包含的一个示例法线贴图如下所示：
- en: '![](img/00055.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00055.jpeg)'
- en: You can see it for yourself in the `Assets `|  `Chapter 03 `| `Textures` folder
    under `normalMapExample`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Assets | Chapter 03 | Textures`文件夹下的`normalMapExample`中自己查看。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps to create a normal map shader:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建法线贴图着色器的以下步骤：
- en: 'Let''s get the `Properties` block set up in order to have a color `Tint` and
    texture:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`Properties`块，以便有一个颜色`Tint`和纹理：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, I have 1 in the green and alpha channels and `0` for red and blue,
    so the default color will be green. For the `_NormalTex` property, we are using
    a 2D type, which means we can use a 2D image to dictate what each pixel will use.
    By initializing the texture as `bump`, we are telling Unity that `_NormalTex` will
    contain a normal map (sometimes referred to as bump maps as well, hence the bump
    name). If the texture is not set, it will be replaced by a grey texture. The color
    used (`0.5`, `0.5`, `0.5`, `1`) indicates no bump at all.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我在绿色和alpha通道中设置为`1`，红色和蓝色通道设置为`0`，因此默认颜色将是绿色。对于`_NormalTex`属性，我们使用2D类型，这意味着我们可以使用2D图像来指定每个像素将使用的内容。通过将纹理初始化为`bump`，我们告诉Unity
    `_NormalTex`将包含一个法线贴图（有时也称为凹凸贴图，因此命名为bump），如果未设置纹理，它将被灰色纹理替换。使用的颜色（`0.5`，`0.5`，`0.5`，`1`）表示没有任何凹凸。
- en: 'In the `SubShader{}` block, scroll below the `CGPROGRAM` statement and remove
    the original `_MainText`,  `_Glossiness`, `_Metallic`, and `_Color` definitions.
    Afterward, add in our `_NormalTex` and `_MainTint`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SubShader{}`块中，在`CGPROGRAM`语句下方滚动并删除原始的`_MainText`，`_Glossiness`，`_Metallic`和`_Color`定义。之后，添加我们的`_NormalTex`和`_MainTint`：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to make sure that we update the `Input` struct with the proper variable
    name so that we can use the model''s UVs for the normal map texture:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保更新`Input`结构体中的正确变量名，以便我们可以使用模型的UVs来为法线贴图纹理：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we extract the normal information from the normal map texture using
    the built-in `UnpackNormal()` function. Then, you only have to apply these new
    normals to the output of the Surface Shader:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用内置的`UnpackNormal()`函数从法线贴图纹理中提取法线信息。然后，你只需将这些新的法线应用到表面着色器的输出中：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save your script and return to the Unity editor. You should notice that the
    sphere has now become green by default if added. More importantly though, notice
    the Normal Map property that has been added. Drag and drop the normal map texture
    into the slot.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到Unity编辑器。你应该注意到，如果添加了球体，它现在默认是绿色的。更重要的是，请注意新添加的法线贴图属性。将法线贴图纹理拖放到槽中。
- en: 'You may notice some changes, but it may be hard to visually see what is going
    on. In the Normal Map property, change the Tiling to (`10`, `10`). This way, you
    can see the normal map duplicated 10 times over the course of the sphere in the
    *X* and *Y* axes instead of only once:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会注意到一些变化，但可能难以直观地看到正在发生什么。在法线贴图属性中，将平铺设置为（`10`，`10`）。这样，你可以在球体的X和Y轴上看到法线贴图重复10次，而不是只重复一次：
- en: '![](img/00056.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: 'The following screenshot demonstrates the result of our normal map shader:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图展示了我们的法线贴图着色器的结果：
- en: '![](img/00057.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: Shaders can have both a texture map and a normal map. It is not uncommon to
    use the same UV data to address both. However, it is possible to provide a secondary
    set of UVs in the vertex data (UV2), which are specifically used for the normal
    map.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器可以同时具有纹理贴图和法线贴图。使用相同的UV数据来处理两者并不罕见。然而，在顶点数据中（UV2）提供一组次级UV也是可能的，这些UV专门用于法线贴图。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The actual math to perform the normal mapping effect is definitely beyond the
    scope of this chapter, but Unity has done it all for us already. It has created
    the functions for us so that we don't have to keep doing it over and over again.
    This is another reason why Surface Shaders are a really efficient way to write
    shaders.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行正常映射效果的数学计算确实超出了本章的范围，但Unity已经为我们完成了所有这些。它为我们创建了函数，这样我们就不必一遍又一遍地重复做同样的事情。这也是为什么表面着色器是编写着色器的一种非常高效的方法的另一个原因。
- en: If you look in the `UnityCG.cginc` file found in the `Editor` | `Data`| `CGIncludes`
    folder in your Unity installation directory, you will find the definitions for
    the `UnpackNormal()` function. When you declare this function in your Surface
    Shader, Unity takes the normal map provided and processes it for you, giving you
    the correct type of data so that you can use it in your per-pixel lighting function.
    It's a huge time-saver! When sampling a texture, you get RGB values from `0` to
    `1`; however, the directions of a normal vector range from `-1` to `1`. `UnpackNormal()`
    brings these components into the right range.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看在Unity安装目录中的`Editor` | `Data` | `CGIncludes`文件夹中找到的`UnityCG.cginc`文件，你将找到`UnpackNormal()`函数的定义。当你在这个表面着色器中声明这个函数时，Unity会为你处理提供的法线贴图，并给出正确的数据类型，以便你可以在你的每像素光照函数中使用它。这是一个节省大量时间的方法！在采样纹理时，你会从`0`到`1`得到RGB值；然而，法线向量的方向范围从`-1`到`1`。`UnpackNormal()`将这些分量带入正确的范围。
- en: Once you have processed the normal map with the `UnpackNormal()` function, you
    send it back to your `SurfaceOutput` struct so that it can be used in the lighting
    function. This is done by using `o.Normal = normalMap.rgb;`. We will see how the
    normal is actually used to calculate the final color of each pixel in [Chapter
    4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08), *Understanding Lighting
    Models*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`UnpackNormal()`函数处理了法线贴图，你就将其发送回你的`SurfaceOutput`结构体，以便在光照函数中使用。这是通过使用`o.Normal
    = normalMap.rgb;`来完成的。我们将在[第4章](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08)，“理解光照模型”中看到法线是如何实际上用于计算每个像素的最终颜色的。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'You can also add some controls to your normal map shader that lets a user adjust
    the intensity of the normal map. This is easily done by modifying the `x` and
    `y` components of the normal map variable and then adding it all back together.
    Add another property to the `Properties` block and name it `_NormalMapIntensity`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为你的法线贴图着色器添加一些控件，让用户调整法线贴图的强度。这可以通过修改法线贴图变量的`x`和`y`分量，然后将它们全部加回来轻松完成。在`Properties`块中添加另一个属性，并将其命名为`_NormalMapIntensity`：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, we are giving the property the ability to be between `0` and
    `3` with a default value of `1`. Once created, you''ll need to add the variable
    inside the SubShader:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们赋予属性在`0`到`3`之间的能力，默认值为`1`。一旦创建，你需要在SubShader内部添加变量：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After the property is added, we can make use of it. Multiply the `x` and `y`
    components of the unpacked normal map and reapply this value to the normal map
    variable with the bolded changes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加属性后，我们可以利用它。将展开的法线贴图的`x`和`y`分量相乘，然后将此值以粗体显示的更改重新应用于法线贴图变量：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Normal vectors are supposed to have lengths equal to one. Multiplying them for `_NormalMapIntensity` changes
    their length, making normalization necessary. The normalize function will take
    the vector and adjust it so that it is pointing in the correct direction but with
    a length of one, which is what we are looking for.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 法线向量应该具有长度等于一的长度。将它们乘以`_NormalMapIntensity`会改变它们的长度，因此需要进行归一化。归一化函数将调整向量，使其指向正确的方向，但长度为1，这正是我们所寻找的。
- en: 'Now, you can let a user adjust the intensity of the normal map in the material''s
    Inspector tab, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在材质的检查器标签中让用户调整法线贴图的强度，如下所示：
- en: '![](img/00058.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: 'The following screenshot shows the result of modifying the normal map with
    our scalar values:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用我们的标量值修改法线贴图的结果：
- en: '![](img/00059.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: Creating a transparent material
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建透明材质
- en: All the shaders we have seen so far have something in common; they are used
    for solid materials. If you want to improve the look of your game, transparent
    materials are often a good way to start. They can be used for anything from a
    fire effect to a glass window. Working with them, unfortunately, is slightly more
    complicated. Before rendering solid models, Unity orders them according to the
    distance from the camera (*Z ordering*) and skips all the triangles that are facing
    away from the camera (**culling**). When rendering transparent geometries, there
    are instances in which these two aspects can cause problems. This recipe will
    show you how to solve some of these issues when it comes to creating a transparent
    Surface Shader. This topic will be heavily revisited in [Chapter 7](part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08),
    *Fragment Shaders and Grab Passes*, where realistic glass and water shaders will
    be provided.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的着色器都有一个共同点；它们用于固体材质。如果你想改善游戏的外观，透明材质通常是一个很好的起点。它们可以用于从火焰效果到玻璃窗户的任何东西。不幸的是，与它们一起工作稍微复杂一些。在渲染固体模型之前，Unity
    会根据从相机到模型的距离对它们进行排序（*Z 排序*），并跳过所有面向相机的三角形（**裁剪**）。当渲染透明几何体时，这两个方面有时会导致问题。这个配方将向你展示如何在创建透明表面着色器时解决这些问题。这个主题将在第
    7 章（[part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08](part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08)）中大量回顾，*片段着色器和抓取通道*，其中将提供逼真的玻璃和水着色器。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe requires a new shader, which we''ll be calling `Transparent`, and
    a new material (`TransparentMat`) so that it can be attached to an object. As
    this is going to be a transparent glass window, a quad or plane is perfect (GameObject
    | 3D Objects | Quad). We will also need several other non-transparent objects
    to test the effect:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要一个新着色器，我们将称之为 `Transparent`，以及一个新的材质（`TransparentMat`），以便它可以附加到对象上。由于这将是一个透明玻璃窗户，一个四边形或平面是完美的（GameObject
    | 3D Objects | Quad）。我们还需要几个其他不透明对象来测试效果：
- en: '![](img/00060.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: 'In this example, we will use a PNG image file for the glass texture since it
    has support for an alpha channel that will be used to determine the transparency
    of the glass. The process of creating such an image depends on the software that
    you are using. However, these are the main steps that you will need to follow:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 PNG 图像文件作为玻璃纹理，因为它支持用于确定玻璃透明度的 alpha 通道。创建此类图像的过程取决于你使用的软件。然而，这些是你需要遵循的主要步骤：
- en: Find the image of the glass you want for your windows.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你想要用于窗户的玻璃图像。
- en: Open it with a photo editing software, such as *GIMP* or *Photoshop*.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用像 *GIMP* 或 *Photoshop* 这样的照片编辑软件打开它。
- en: Select the parts of the image that you want to be semi-transparent.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要半透明的图像部分。
- en: Create a white (full opacity) layer mask on your image.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的图像上创建一个白色（全不透明）的图层蒙版。
- en: Use the selection previously made to fill the layer mask with a darker color.
    White is treated as fully visible, black will be treated as invisible, and grey
    will be somewhere in the middle.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前选择的选项，用较深的颜色填充图层蒙版。白色被视为完全可见，黑色被视为不可见，灰色则介于两者之间。
- en: Save the image and import it into Unity.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存图像并将其导入 Unity。
- en: 'The toy image used in this recipe is a picture of stained glass from the *Meaux
    Cathedral *in *France* ([https://en.wikipedia.org/wiki/Stained_glass](https://en.wikipedia.org/wiki/Stained_glass)).
    If you have followed all of these steps, your image should look like this (**RGB**
    channels on the left, and **A** channel on the right):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中使用的玩具图像是法国 *梅奥大教堂* 的彩色玻璃的图片 ([https://en.wikipedia.org/wiki/Stained_glass](https://en.wikipedia.org/wiki/Stained_glass))。如果你已经遵循了所有这些步骤，你的图像应该看起来像这样（**RGB**
    通道在左侧，**A** 通道在右侧）：
- en: '![](img/00061.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: You can also make use of the image file in provided the example code for this
    book in `Chapter 3 `| `Textures` folder (`Meaux_Vitrail.psd`).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用提供的示例代码中的图像文件（`Chapter 3` | `Textures` 文件夹中的 `Meaux_Vitrail.psd`）。
- en: 'Attaching this image to the material will cause the image to show up, but we
    cannot see it behind the glass:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将此图像附加到材质上会使图像显示出来，但我们无法看到玻璃后面的内容：
- en: '![](img/00062.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: As we would like to see behind this, we can make adjustments to the shader to
    do exactly that.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想看到背后的内容，我们可以调整着色器来实现这一点。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As mentioned previously, there are a few aspects that we need to take care
    of while using a Transparent Shader:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在使用透明着色器时，有几个方面需要注意：
- en: Remove the `_Glossiness` and `_Metallic` variables from the `Properties` and
    `SubShader` sections of the code as they aren't needed for this example.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码的`Properties`和`SubShader`部分移除`_Glossiness`和`_Metallic`变量，因为在这个示例中它们不是必需的。
- en: 'In the `SubShader{}` section of the shader, modify the `Tags` section to the
    following so that we can signal that the shader is transparent:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器的`SubShader{}`部分中，修改`Tags`部分如下，以便我们可以发出信号，表明着色器是透明的：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tags are used by the `SubShader` to know how and when items should be rendered.
    Similar to the dictionary type, tags are key-value pairs where the left-hand side
    is the tag name and the right-hand side is the value you wish for it to be set
    to.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 标签由`SubShader`使用，以了解项目和何时渲染。类似于字典类型，标签是键值对，其中左侧是标签名称，右侧是您希望设置的值。
- en: For more information on tags in ShaderLab, check out: [https://docs.unity3d.com/Manual/SL-SubShaderTags.html](https://docs.unity3d.com/Manual/SL-SubShaderTags.html)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ShaderLab中标签的更多信息，请参阅：[https://docs.unity3d.com/Manual/SL-SubShaderTags.html](https://docs.unity3d.com/Manual/SL-SubShaderTags.html)
- en: 'As this shader is designed for 2D materials, make sure that the back geometry
    of your model is not drawn by adding the following below the `LOD 200` line:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个着色器是为2D材质设计的，请确保通过在`LOD 200`行下方添加以下内容来防止模型的背面几何体被绘制：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Tell the shader that this material is transparent and needs to be blended with
    what was drawn on the screen before:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉着色器，这个材质是透明的，并且需要与屏幕上绘制的内容混合：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use this Surface Shader to determine the final color and transparency of the
    glass:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此表面着色器确定玻璃的最终颜色和透明度：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Afterward, save your script and dive back to the Unity editor:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，保存您的脚本并返回到Unity编辑器：
- en: '![](img/00063.jpeg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: Notice that you can now see the cube behind the glass. Perfect!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您现在可以看到玻璃后面的立方体。太完美了！
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This shader introduces several new concepts. First of all, `Tags` are used to
    add information about how the object is going to be rendered. The really interesting
    one here is `Queue`. Unity, by default, will sort your objects for you based on
    the distance from the camera. So, as an object gets nearer to the camera, it is
    going to be drawn over all the objects that are further away from the camera.
    For most cases, this works out just fine for games, but you will find yourself
    in certain situations where you will want to have more control over the sorting
    of your objects in your scene. Unity has provided us with some default render
    queues, each with a unique value that directs Unity when to draw the object to
    the screen. These built-in render queues are called `Background`, `Geometry`,
    `AlphaTest`, `Transparent`, and `Overlay`. These queues weren't just created arbitrarily;
    they actually serve a purpose to make our lives easier when writing shaders and
    interacting with the real-time renderer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器引入了几个新概念。首先，`Tags`用于添加有关对象如何渲染的信息。这里真正有趣的是`Queue`。默认情况下，Unity会根据对象与摄像机的距离为您排序对象。因此，当对象靠近摄像机时，它将覆盖所有远离摄像机的对象。对于大多数情况，这对游戏来说效果很好，但您会发现自己在某些情况下想要对场景中对象的排序有更多的控制。Unity为我们提供了一些默认的渲染队列，每个队列都有一个独特的值，指示Unity何时将对象绘制到屏幕上。这些内置的渲染队列被称为`Background`、`Geometry`、`AlphaTest`、`Transparent`和`Overlay`。这些队列并非随意创建；它们实际上有助于我们在编写着色器和与实时渲染器交互时简化生活。
- en: 'Refer to the following table for descriptions on the usage of each of these
    individual render queues:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下表格，了解每个单独渲染队列的用法描述：
- en: '| **Render queue** | **Render queue description** | **Render queue value**
    |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **渲染队列** | **渲染队列描述** | **渲染队列值** |'
- en: '| --- | --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Background` | This render queue is rendered first. It is used for skyboxes
    and so on. | `1000` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `Background` | 这个渲染队列首先渲染。它用于天空盒等。 | `1000` |'
- en: '| `Geometry` | This is the default render queue. This is used for most objects.
    Opaque geometry uses this queue. | `2000` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `Geometry` | 这是默认的渲染队列。它用于大多数对象。不透明几何体使用此队列。 | `2000` |'
- en: '| `AlphaTest` | Alpha-tested geometry uses this queue. It''s different from
    the `Geometry` queue as it''s more efficient to render alpha-tested objects after
    all the solid objects are drawn. | `2450` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `AlphaTest` | 使用此队列进行Alpha测试的几何体。它与`Geometry`队列不同，因为它在绘制所有实体对象之后渲染Alpha测试对象更有效率。
    | `2450` |'
- en: '| `Transparent` | This render queue is rendered after `Geometry` and `AlphaTest`
    queues in back-to-front order. Anything alpha-blended (that is, shaders that don''t
    write to the depth buffer) should go here, for example, glass and particle effects.
    | `3000` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `Transparent` | 此渲染队列在`Geometry`和`AlphaTest`队列之后按从后向前的顺序渲染。任何alpha混合（即不写入深度缓冲区的着色器）的内容应放在这里，例如，玻璃和粒子效果。
    | `3000` |'
- en: '| `Overlay` | This render queue is meant for overlay effects. Anything rendered
    last should go here, for example, lens flares. | `4000` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `Overlay` | 此渲染队列用于叠加效果。最后渲染的内容应放在这里，例如，镜头光晕。 | `4000` |'
- en: So, once you know which render queue your object belongs to, you can assign
    its built-in render queue tag. Our shader used the `Transparent` queue, so we
    wrote `Tags{"Queue"="Transparent"}`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦您知道您的对象属于哪个渲染队列，您就可以分配其内置的渲染队列标签。我们的着色器使用了`Transparent`队列，因此我们编写了`Tags{"Queue"="Transparent"}`。
- en: The fact that the `Transparent` queue is rendered after `Geometry` does *not*
    mean that our glass will appear on top of all the other solid objects. Unity will
    draw the glass last, but it will not render pixels that belong to pieces of geometry
    hidden behind something else. This control is done using a technique called **ZBuffering**.
    More information on how models are rendered can be found at the following link: [http://docs.unity3d.com/Manual/SL-CullAndDepth.html](http://docs.unity3d.com/Manual/SL-CullAndDepth.html).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transparent`队列在`Geometry`之后渲染的事实并不意味着我们的玻璃会出现在所有其他实体物体之上。Unity将最后绘制玻璃，但它不会渲染属于被其他东西遮挡的几何形状的像素。这种控制是通过一种称为**ZBuffering**的技术完成的。有关模型渲染的更多信息，请参阅以下链接：[http://docs.unity3d.com/Manual/SL-CullAndDepth.html](http://docs.unity3d.com/Manual/SL-CullAndDepth.html)。'
- en: The `IgnoreProjector` tag makes this object unaffected by Unity's projectors.
    Lastly, `RenderType` plays a role in **shader replacement**, a topic that will
    be covered briefly in [Chapter 10](part0246.html#7AJAC0-e8c76c858d514bc3b1668fda96f8fa08),
    *Gameplay and Screen Effects*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`IgnoreProjector`标签使此对象不受Unity投影器的影响。最后，`RenderType`在**着色器替换**中发挥作用，这个主题将在第10章[游戏玩法和屏幕效果](part0246.html#7AJAC0-e8c76c858d514bc3b1668fda96f8fa08)中简要介绍。'
- en: The last concept introduced is `alpha:fade`. This indicates that all the pixels
    from this material have to be blended with what was on the screen before according
    to their alpha values. Without this directive, the pixels will be drawn in the
    correct order, but they won't have any transparency.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后介绍的概念是`alpha:fade`。这表示所有来自这种材质的像素都必须根据它们的alpha值与屏幕上之前的内容混合。如果没有这个指令，像素将以正确的顺序绘制，但它们将没有任何透明度。
- en: Creating a Holographic Shader
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全息着色器
- en: 'More and more space-themed games are being released every year. An important
    part of a good sci-fi game is the way futuristic technology is presented and integrated
    into gameplay. There''s nothing that screams futuristic more than holograms. Despite
    being present in many flavors, holograms are often represented as semi-transparent,
    thin projections of an object. This recipe shows you how to create a shader that
    simulates such effects. Take this as a starting point: you can add noise, animated
    scan lines, and vibrations to create a truly outstanding holographic effect. The
    following screenshot shows an example of a Holographic effect:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每年都有越来越多的以太空为主题的游戏发布。一款好的科幻游戏的一个重要部分是未来科技的表现和融入游戏玩法的方式。没有比全息投影更能体现未来感的了。尽管全息投影以多种形式存在，但它们通常被表示为半透明、薄薄的对象投影。这个配方向您展示了如何创建模拟这种效果的着色器。以此为起点：您可以添加噪声、动画扫描线、振动，以创建真正出色的全息效果。以下截图显示了全息效果的示例：
- en: '![](img/00064.jpeg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a shader called `Holographic`. Attach it to a material (`HolographicMat`)
    and assign it to a 3D model in your scene:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Holographic`的着色器。将其附加到材质（`HolographicMat`）并将它分配到场景中的3D模型：
- en: '![](img/00065.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following changes will change our existing shader into a holographic one:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改将把我们的现有着色器转换为全息着色器：
- en: 'Remove the following properties as they will not be used:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下属性，因为它们将不会使用：
- en: '`_Glossiness`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_Glossiness`'
- en: '`_Metallic`'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_Metallic`'
- en: 'Add the following property to the shader:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到着色器中：
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add its respective variable to the `CGPROGRAM` section:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其相应的变量添加到`CGPROGRAM`部分：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As this material is transparent, add the following tags:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这种材质是透明的，请添加以下标签：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: According to the type of object that you will use, you might want its backside
    to appear. If this is the case, add `Cull Off` so that the back of the model won't
    be removed (*culled*).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你将使用的对象类型，你可能希望其背面看起来。如果是这样，添加`Cull Off`，这样模型的背面就不会被移除（*裁剪*）。
- en: 'This shader is not trying to simulate a realistic material, so there is no
    need to use the PBR lighting model. **Lambertian reflectance**, which is very
    cheap, is used instead. Additionally, we should disable any lighting with `nolighting`
    and signal to Cg that this is a Transparent Shader using `alpha:fade`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个着色器并不试图模拟真实材料，因此不需要使用PBR光照模型。相反，使用非常便宜的**朗伯反射**。此外，我们应该禁用任何带有`nolighting`的照明，并通知Cg这是一个使用`alpha:fade`的透明着色器：
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Change the `Input` structure so that Unity will fill it with the current view
    direction and the world normal direction:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Input`结构，以便Unity将其填充为当前视图方向和世界法线方向：
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the following surface function. Remember that since this shader is using
    Lambertian reflectance as its lighting function, the name of the `SurfaceOutput`
    structure should be changed accordingly to `SurfaceOutput` instead of `SurfaceOutputStandard`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下表面函数。请记住，由于这个着色器使用朗伯反射作为其光照函数，因此`SurfaceOutput`结构的名称应相应地更改为`SurfaceOutput`而不是`SurfaceOutputStandard`：
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Save your script and dive into Unity. From there, change the Color property
    in the HolographicMat and see your hologram come to life:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并进入Unity。从那里，更改HolographicMat中的颜色属性，看看你的全息图是如何变得生动起来的：
- en: '![](img/00066.jpeg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00066.jpeg)'
- en: You can now use the Rim effect slider to choose the strength of the holographic
    effect.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用边缘效果滑块来选择全息效果的强度。
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As mentioned previously, this shader works by showing only the silhouette of
    an object. If we look at the object from another angle, its outline will change.
    Geometrically speaking, the edges of a model are all those triangles whose *normal
    direction* is orthogonal (90 degrees) to the current *view direction*. The `Input`
    structure declares these parameters, `worldNormal` and `viewDir`, respectively.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个着色器通过仅显示对象的轮廓来工作。如果我们从另一个角度观察对象，其轮廓将改变。从几何学角度讲，模型的边缘是所有那些其*法线方向*与当前*视图方向*正交（90度）的三角形。`Input`结构分别声明了这些参数，`worldNormal`和`viewDir`。
- en: The problem of understanding when two vectors are orthogonal can be solved using `_DotProduct`.
    This is an operator that takes two vectors and returns zero if they are orthogonal.
    We use `_DotProduct` to determine how close to zero the `_DotProduct` has to be
    for the triangle to fade completely.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`_DotProduct`可以解决理解两个向量是否正交的问题。这是一个操作符，它接受两个向量，如果它们是正交的，则返回零。我们使用`_DotProduct`来确定`_DotProduct`需要接近零到什么程度，以便三角形完全消失。
- en: 'The second aspect that is used in this shader is the gentle fading between
    the edge of the model (fully visible) and the angle determined by `_DotProduct`
    (invisible). This linear interpolation is effected as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个着色器中使用的第二个方面是模型边缘（完全可见）与由`_DotProduct`确定的角（不可见）之间的柔和渐变。这种线性插值如下所示：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, the original `alpha` from the texture is multiplied with the newly
    calculated coefficient to achieve the final look.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将原始纹理中的`alpha`与新计算的系数相乘，以实现最终的外观。
- en: There's more...
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This technique is very simple and relatively inexpensive, and yet it can be
    used for a large variety of effects, such as the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术非常简单且相对便宜，但可以用于各种效果，如下所示：
- en: The slightly colored atmosphere of a planet in sci-fi games
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科幻游戏中行星的略带色彩的气氛
- en: The edge of an object that has been selected or is currently under the mouse
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已被选中或当前鼠标悬停下的对象边缘
- en: A ghost or specter
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个幽灵或鬼魂
- en: Smoke coming out of an engine
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发动机排出的烟雾
- en: The shockwave of an explosion
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆炸的冲击波
- en: The bubble shield of a spaceship under attack
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在受到攻击的宇宙飞船的气泡护盾
- en: See also
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `_DotProduct` plays an important role in the way reflections are calculated.
    [Chapter 4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08), *Understanding
    Lighting Models*, will explain in detail how it works and why it is widely used
    in so many shaders.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`_DotProduct`在计算反射的方式中起着重要作用。[第4章](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08)，*理解光照模型*，将详细解释它是如何工作的以及为什么它在许多着色器中被广泛使用。'
- en: Packing and blending textures
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理打包和混合
- en: Textures are useful for storing not only loads of data, not just pixel colors
    as we generally tend to think of them, but also for multiple sets of pixels in
    both the *x* and *y* directions and RGBA channels. We can actually pack multiple
    images into a single RGBA texture and use each of the R, G, B, and A components
    as individual textures themselves by extracting each of these components from
    the shader code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理不仅用于存储大量数据，不仅仅是像素颜色，正如我们通常所认为的那样，而且还用于在*x*和*y*方向以及RGBA通道中的多组像素。我们实际上可以将多个图像打包到一个RGBA纹理中，并通过从着色器代码中提取每个组件，将每个R、G、B和A组件用作单独的纹理。
- en: 'The result of packing individual grayscale images into a single RGBA texture
    can be seen in the following screenshot:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个灰度图像打包到单个RGBA纹理中的结果可以在以下屏幕截图中看到：
- en: '![](img/00067.jpeg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00067.jpeg)'
- en: Why is this helpful? Well, in terms of the amount of actual memory that your
    application takes up, textures are a large portion of your application's size.
    We can, of course, reduce the size of the image, but then we would lose details
    in how it can be represented. So, to begin reducing the size of your application,
    we can look at all of the images that we are using in our shader and see if we
    can merge these textures into a single texture. Using a single texture with multiple
    images in them requires fewer draw calls and less overhead than separate files.
    We can also use this concept to combine irregularly shaped textures (that being,
    those that are not squares) into a single one to take up less space than giving
    them their own full texture.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这有帮助呢？好吧，从你的应用程序实际占用的内存量来看，纹理占据了应用程序大小的大部分。我们当然可以减小图像的大小，但这样我们就会失去它在表示方式上的细节。因此，为了开始减小应用程序的大小，我们可以查看我们在着色器中使用的所有图像，看看我们是否可以将这些纹理合并成一个纹理。使用包含多个图像的单个纹理比使用单独的文件需要更少的绘制调用和更少的开销。我们还可以使用这个概念将不规则形状的纹理（即不是正方形的纹理）合并成一个，这样占用的空间比给它们各自的全纹理要少。
- en: Any texture that is grayscale can be packed into one of the RGBA channels of
    another texture. This might sound a bit odd at first, but this recipe is going
    to demonstrate one of the uses of packing a texture and using these packed textures
    in a shader.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 任何灰度纹理都可以打包到另一个纹理的RGBA通道中。一开始这听起来可能有点奇怪，但这个配方将要演示打包纹理和使用这些打包纹理在着色器中的用途之一。
- en: One example of using these packed textures is when you want to blend a set of
    textures together onto a single surface. You see this most often in terrain type
    shaders, where you need to blend into another texture nicely using some sort of
    control texture or the packed texture, in this case. This recipe covers this technique
    and shows you how to construct the beginnings of a nice four-texture blended terrain
    shader.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些打包纹理的一个例子是当你想要将一组纹理混合到单个表面上的情况。你通常在地面类型着色器中看到这种情况，你需要使用某种控制纹理或打包纹理（在这种情况下）很好地融合到另一个纹理中。这个配方涵盖了这项技术，并展示了如何构建一个优秀的四纹理混合地面着色器的开始。
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a new shader file in your `Shaders` folder (`TextureBlending`)
    and then create a new material for this shader (`TextureBlendingMat`). The naming
    convention is entirely up to you for your shader and material files, so try your
    best to keep them organized, and easy to reference later on.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Shaders`文件夹中创建一个新的着色器文件（`TextureBlending`），然后为这个着色器创建一个新的材质（`TextureBlendingMat`）。着色器和材质文件的命名规范完全取决于你，所以尽量保持它们有组织，便于以后参考。
- en: 'Once you have your shader and material ready, create a new scene in which we
    can test our shader. Inside to the scene, place the `Terrain_001` object from
    the `Chapter 3 `| `Models` folder and assign the `TextureBlendingMat` material
    to it:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的着色器和材质准备好了，创建一个新的场景，我们可以在这个场景中测试我们的着色器。在场景内部，放置来自“第 3 章”|“模型”文件夹的`Terrain_001`对象，并将其`TextureBlendingMat`材质分配给它：
- en: '![](img/00068.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00068.jpeg)'
- en: You will also need to gather up four textures that you would want to blend together.
    These can be anything, but for a nice terrain shader, you will want grass, dirt,
    rocky dirt, and rock textures. You can find these assets in `Chapter 1 `| `Standard
    Assets `| `Environment `| `TerrainAssets `| `SurfaceTextures` folder in the example
    code for this book.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要收集你想要混合的四个纹理。这些可以是任何东西，但为了一个漂亮的地面着色器，你将想要草地、泥土、多石泥土和岩石纹理。你可以在本书的示例代码中找到这些资源，在“第
    1 章”|“标准资源”|“环境”|“地形资源”|“表面纹理”文件夹中。
- en: Finally, we will also need a blending texture that is packed with grayscale
    images. This will give us the four blending textures that we can use to direct
    how the color textures will be placed on the object surface.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要一个包含灰度图像的混合纹理。这将给我们四个混合纹理，我们可以使用它们来指导颜色纹理如何放置在物体表面上。
- en: 'We can use very intricate blending textures to create a very realistic distribution
    of terrain textures over a terrain mesh, as shown in the following screenshot:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用非常复杂的混合纹理来在地形网格上创建非常逼真的地形纹理分布，如下面的屏幕截图所示：
- en: '![](img/00069.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s learn how to use packed textures by entering the code shown in the following
    steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤中的代码来学习如何使用打包纹理：
- en: 'We need to add a few properties to our `Properties` block. We will need five
    `sampler2D` objects, or textures, and two `Color` properties:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`Properties`块中添加一些属性。我们需要五个`sampler2D`对象，或纹理，以及两个`Color`属性：
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As always, remove the properties we are not using from the base shader from
    our code.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，从我们的代码中移除我们不使用的基着色器属性。
- en: 'We then need to create the `SubShader{}` section variables that will be our
    link to the data in the `Properties` block:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建`SubShader{}`部分变量，这将是我们与`Properties`块中的数据链接：
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Due to the number of items inside of our shader, we will need to update the
    target level version of our shader model to `3.5`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的着色器中包含的项目数量，我们需要将我们的着色器模型的目标版本更新到`3.5`：
- en: For more information on Shader Compilation Target Levels, check out: [https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html](https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有关着色器编译目标级别的更多信息，请参阅：[https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html](https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html)。
- en: 'So, now we have our texture properties and we are passing them to our `SubShader{}`
    function. In order to allow the user to change the tiling rates on a per-texture
    basis, we will need to modify our `Input` struct. This will allow us to use the
    tiling and offset parameters on each texture:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们有了纹理属性，并将它们传递给我们的`SubShader{}`函数。为了允许用户按纹理基础更改平铺率，我们需要修改我们的`Input`结构。这将允许我们在每个纹理上使用平铺和偏移参数：
- en: '[PRE44]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `surf()` function, get the texture information and store it in its own
    variables so that we can work with the data in a clean, easy-to-understand way:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`surf()`函数中，获取纹理信息并将其存储在其自己的变量中，这样我们就可以以干净、易于理解的方式处理数据：
- en: '[PRE45]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remember that due to us using Lambert, we will be using `SurfaceOutput` instead
    of `SurfaceOutputStandard` for the `surf` function.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于我们使用了Lambert，我们将使用`SurfaceOutput`而不是`SurfaceOutputStandard`作为`surf`函数。
- en: 'Let''s blend each of our textures together using the `lerp()` function. It
    takes three arguments, `lerp(value : a, value : b,` and `blend: c)`. The `lerp()`
    function takes in two textures and blends them with the float value given in the
    last argument:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们使用`lerp()`函数将我们每个纹理混合在一起。它接受三个参数，`lerp(value : a, value : b, blend: c)`。`lerp()`函数接收两个纹理，并使用最后一个参数提供的浮点值将它们混合：'
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we multiply our blended texture by the color tint values and use the
    red channel to determine where the two different terrain tint colors go:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将混合纹理乘以颜色着色值，并使用红色通道来确定两种不同的地形着色颜色放置的位置：
- en: '[PRE47]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Save your script and go back into Unity. Once there, you can assign the `TerrainBlend`
    texture to the Blend Texture property. Once you''ve done that, place different
    textures in the different channels in order to see our script in action:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本，然后回到Unity。一旦进入，你就可以将`TerrainBlend`纹理分配给混合纹理属性。完成此操作后，将不同的纹理放置在不同的通道中，以便看到我们的脚本在起作用：
- en: '![](img/00070.jpeg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: 'This effect can be taken even further by using different textures and terrain
    tinting to create some great looking terrains with minimal effort. The result
    of blending together four terrain textures and creating a terrain tinting technique
    can be seen in the following screenshot:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用不同的纹理和地形着色，我们可以进一步实现这一效果，以最小的努力创建出一些看起来很棒的地形。将四个地形纹理混合在一起并创建地形着色技术的结果可以在以下屏幕截图中看到：
- en: '![](img/00071.jpeg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: How it works...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This might seem like quite a few lines of code, but the concept behind blending
    is actually quite simple. For the technique to work, we have to employ the built-in
    `lerp()` function from the `CgFX` standard library. This function allows us to
    pick a value between argument one and argument two using argument three as the
    blend amount:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是很多行代码，但混合的概念实际上非常简单。为了使该技术生效，我们必须使用来自 `CgFX` 标准库的内置 `lerp()` 函数。这个函数允许我们使用第三个参数作为混合量，在第一个和第二个参数之间选择一个值：
- en: '| Function | Description |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| `lerp(a, b, f )` | This involves linear interpolation:*(1 - f )* a + b *
    f*Here, `a` and `b` are matching vector or scalar types. The `f` parameter can
    be either a scalar or vector of the same type as `a` and `b`. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `lerp(a, b, f)` | 这涉及线性插值：*(1 - f)* a + b * f*在这里，`a` 和 `b` 是匹配的向量或标量类型。`f`
    参数可以是与 `a` 和 `b` 相同类型的标量或向量。|'
- en: So, for example, if we wanted to find the mid-value between `1` and `2`, we
    could feed the value `0.5` as the third argument to the `lerp()` function and
    it would return the value `1.5`. This works perfectly for our blending needs as
    the values of an individual channel in an RGBA texture are single float values,
    usually in the range of `0` to `1`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想找到 `1` 和 `2` 之间的中间值，我们可以将值 `0.5` 作为 `lerp()` 函数的第三个参数输入，它将返回值 `1.5`。这对于我们的混合需求来说非常完美，因为
    RGBA 纹理中单个通道的值是单个浮点值，通常在 `0` 到 `1` 的范围内。
- en: In the shader, we simply take one of the channels from our Blend Texture and
    use it to drive the color that is picked in a `lerp()` function for each pixel.
    For instance, we take our grass texture and dirt texture, use the red channel
    from our blending texture, and feed this to a `lerp()` function. This will give
    us the correct blended color result for each pixel on the surface.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中，我们简单地从我们的混合纹理中取一个通道，并使用它来驱动每个像素中选择的颜色，在 `lerp()` 函数中。例如，我们取我们的草地纹理和泥土纹理，使用混合纹理的红通道，并将其输入到
    `lerp()` 函数中。这将为我们提供每个像素表面的正确混合颜色结果。
- en: 'A more visual representation of what is happening when using the `lerp()` function
    is shown in the following diagram:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lerp()` 函数时发生的情况的更直观表示如下所示：
- en: '![](img/00072.jpeg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: The shader code simply uses the four channels of the Blend Texture and all the
    color textures to create a final Blended Texture. This final texture then becomes
    the color that we can multiply with our diffuse lighting.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器代码简单地使用混合纹理的四个通道和所有颜色纹理来创建最终的混合纹理。然后，这个最终纹理将成为我们可以与漫反射光照相乘的颜色。
- en: Creating a circle around your terrain
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的地形周围创建一个圆
- en: Many RTS games display distances (range attack, moving distance, sight, and
    so on) by drawing a circle around the selected unit. If the terrain is flat, this
    can be done simply by stretching a quad with the texture of a circle. If that's
    not the case, the quad will most likely be clipped behind a hill or another piece
    of geometry. This recipe will show you how to create a shader that allows you
    to draw circles around an object of arbitrary complexity. If you want to be able
    to move or animate your circle, we will need both a shader and C# script.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 许多即时战略游戏通过在选定的单位周围画圆来显示距离（攻击范围、移动距离、视野等）。如果地形是平坦的，这可以通过拉伸一个带有圆形纹理的四边形来完成。如果不是这样，四边形很可能会被山丘或其他几何图形裁剪掉。这个配方将向你展示如何创建一个着色器，允许你在任意复杂性的对象周围画圆。如果你想能够移动或动画化你的圆，我们需要一个着色器和
    C# 脚本。
- en: 'The following screenshot shows an example of drawing a circle in a hilly region
    using a shader:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用着色器在丘陵地区绘制圆的示例：
- en: '![](img/00073.jpeg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: Getting ready
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Despite working with every piece of geometry, this technique is oriented to
    terrains. Hence, the first step is setting up a terrain in Unity, but instead
    of using a model, we will create one within the Unity editor:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与每一块几何图形都有关联，但这种技术主要针对地形。因此，第一步是在 Unity 中设置一个地形，但我们将不在模型中使用，而是在 Unity 编辑器内创建一个：
- en: Let's start by creating a new shader called `RadiusShader` and the respective
    material, `RadiusMat`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的着色器 `RadiusShader` 和相应的材质 `RadiusMat` 开始。
- en: Have the character for your object ready; we will draw a circle around it.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好你的对象角色；我们将围绕它画一个圆。
- en: From the menu, navigate to GameObject | 3D Object | Terrain to create a new
    terrain.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中，导航到 GameObject | 3D Object | Terrain 创建一个新的地形。
- en: Create the geometry for your terrain. You can either import an existing one
    or draw your own using the tools available (Raise/Lower Terrain, Paint Height, Smooth
    Height).
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的地形创建几何形状。你可以导入现有的一个，或者使用可用的工具（提升/降低地形，绘制高度，平滑高度）来绘制自己的地形。
- en: 'The terrains are special objects in Unity, and the way texture mapping works
    on them is different from traditional 3D models. You cannot provide `_MainTex`
    from a shader as it needs to be provided directly from the terrain itself. To
    do this, select Paint Texture and then click on Add Texture...:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，地形是特殊对象，纹理映射的方式与传统3D模型不同。你不能从着色器提供`_MainTex`，因为它需要直接从地形本身提供。为此，选择绘制纹理，然后点击添加纹理...：
- en: '![](img/00074.jpeg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: The creation  of a terrain isn't covered in this book, but if you would like
    to learn more about it, check out the following link: [https://docs.unity3d.com/Manual/terrain-UsingTerrains.html](https://docs.unity3d.com/Manual/terrain-UsingTerrains.html)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有涵盖地形的创建，但如果你想了解更多，请查看以下链接：[https://docs.unity3d.com/Manual/terrain-UsingTerrains.html](https://docs.unity3d.com/Manual/terrain-UsingTerrains.html)
- en: 'Now that the texture is set, you have to change the material of the terrain
    so that a custom shader can be provided. From Terrain Settings, change the Material
    property to `Custom`, and then drag the Radius material to the `Custom Material`
    box:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在纹理已经设置好了，你必须更改地形的材质，以便提供一个自定义着色器。从地形设置中，将材质属性更改为`Custom`，然后将半径材质拖到`Custom
    Material`框中：
- en: '![](img/00075.jpeg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: You are now ready to create your shader.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以创建你的着色器了。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by editing the `RadiusShader` file:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先编辑`RadiusShader`文件：
- en: 'In the new shader, remove the `_Glossiness` and `_Metallic` properties and
    add these four properties:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的着色器中，删除`_Glossiness`和`_Metallic`属性，并添加以下四个属性：
- en: '[PRE48]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add their respective variables to the `CGPROGRAM` section, remembering to remove
    the declaration of `_Glossiness` and `_Metallic`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们各自的变量添加到`CGPROGRAM`部分，记得删除`_Glossiness`和`_Metallic`的声明：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Input` to our surface function requires not only the UV of the texture but
    also the position (in world coordinates) of every point of the terrain. We can
    retrieve this parameter by changing the `struct Input ` as follows:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input`到我们的表面函数不仅需要纹理的UV，还需要地形的每个点的位置（在世界坐标中）。我们可以通过更改`struct Input`来检索此参数：'
- en: '[PRE50]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, we use this surface function:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用这个表面函数：
- en: '[PRE51]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'These steps are all it takes to draw a circle on your terrain. You can use
    the material''s Inspector tab to change the position, radius, and color of the
    circle:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤就是绘制地形上的圆圈所需的所有步骤。你可以使用材质的检查器选项卡来更改圆圈的位置、半径和颜色：
- en: '![](img/00076.jpeg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: Moving the circle
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动圆圈
- en: 'This is great, but you''ll likely also want to change where the circle is at
    run-time, which we can do via code. If you want the circle to follow your character,
    other steps are necessary:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但你可能还希望更改运行时圆圈的位置，我们可以通过代码来实现。如果你想让圆圈跟随你的角色，则需要其他步骤：
- en: Create a new C# script called `SetRadiusProperties`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，命名为`SetRadiusProperties`。
- en: 'Since you may wish to see this change both in the game and outside, we can
    add a tag to the top of the class saying to execute this code while in the editor,
    in addition to when the game is being played, by adding the following tag:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你可能希望在游戏和编辑器中都能看到这个变化，我们可以在类顶部添加一个标签，表示在游戏运行时执行此代码，通过添加以下标签：
- en: '[PRE52]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add these properties to the script:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到脚本中：
- en: '[PRE53]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `Update()` method, add these lines of code:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update()`方法中，添加以下代码行：
- en: '[PRE54]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Attach the script to the object you wish to have the circle drawn around.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本附加到你希望绘制圆圈的对象上。
- en: 'Finally, drag the `RadiusMat` material to the Radius Material slot of the script:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`RadiusMat`材质拖到脚本的半径材质槽中：
- en: '![](img/00077.jpeg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: You can now move your character around and this will create a nice circle around
    it. Changing the properties of the `Radius` script will change the radius as well.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以移动你的角色，这将围绕它创建一个漂亮的圆圈。更改`Radius`脚本的属性将更改半径。
- en: How it works...
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The relevant parameters to draw a circle are its center, radius, and color.
    They are all available in the shader with the names `_Center`, `_Radius`, and
    `_RadiusColor`. By adding the `worldPos` variable to the `Input` structure, we
    are asking Unity to provide us with the position of the pixel that we are drawing
    expressed in world coordinates. This is the actual position of an object in the
    editor.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆的相关参数包括其中心、半径和颜色。这些参数在着色器中均可用，分别以 `_Center`、`_Radius` 和 `_RadiusColor` 命名。通过将
    `worldPos` 变量添加到 `Input` 结构中，我们请求 Unity 提供我们正在绘制的像素的位置，该位置以世界坐标表示。这是在编辑器中对象的实际位置。
- en: The `surf()` function is where the circle is actually drawn. It calculates the
    distance from the point being drawn and the center of the radius, and then it
    checks whether it is between `_Radius` and `_Radius + _RadiusWidth`; if this is
    the case, it uses the chosen color. In the other case, it just samples the texture
    map like all the other shaders we have seen so far.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`surf()` 函数是实际绘制圆的地方。它计算正在绘制的点与半径中心的距离，然后检查它是否位于 `_Radius` 和 `_Radius + _RadiusWidth`
    之间；如果是这种情况，它使用所选颜色。在其他情况下，它就像我们迄今为止看到的所有其他着色器一样，对纹理图进行采样。'
