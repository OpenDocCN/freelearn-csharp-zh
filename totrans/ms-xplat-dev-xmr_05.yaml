- en: Chapter 5. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 网络通信
- en: 'In this chapter, we will take a detailed look at the networking capabilities
    of Xamarin applications and various service integration scenarios. The chapter
    also includes real-world examples on how to use local storage for data caching
    on connected app scenarios. It is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨Xamarin应用程序的网络功能以及各种服务集成场景。本章还包括了在连接应用程序场景中如何使用本地存储进行数据缓存的实际示例。它分为以下部分：
- en: Connected apps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已连接的应用
- en: Web services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务
- en: Push notifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送通知
- en: SignalR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR
- en: Patterns and best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Platform-specific concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定概念
- en: Cloud integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云集成
- en: Connected apps
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已连接的应用
- en: Mobile applications by definition should be as lightweight and resource-efficient
    as possible. You cannot expect to package media and other content into the application
    and then distribute the app or create an extravagant size of storage for user
    data, especially with applications whose main purpose is to provide user access
    to related content or store and manipulate the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，移动应用程序应该尽可能轻量级和资源高效。你不能期望将媒体和其他内容打包到应用程序中，然后分发应用程序或为用户数据创建过大的存储空间，尤其是对于那些主要目的是提供用户访问相关内容或存储和操作数据的程序。
- en: For instance, while dealing with cross-platform projects, one of the easiest
    ways to create unified business logic and storage is to create a web service layer
    and delegate the responsibility and logic to this layer. In this scenario, the
    application(s) would be simply responsible for serving the content provided by
    the service layer or communicating the user input to the service layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在处理跨平台项目时，创建统一业务逻辑和存储的最简单方法之一是创建一个网络服务层，并将责任和逻辑委托给这一层。在这种情况下，应用程序（s）将仅负责提供由服务层提供的内容，或将用户输入传达给服务层。
- en: This approach not only increases the efficiency of the application(s) but also
    creates an abstraction between the logic implementation and the presentation.
    This allows the developers to be free from the platform constraints on technology
    choices for storage and execution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅提高了应用程序的效率，还在逻辑实现和表示之间创建了一个抽象层。这允许开发者从存储和执行的技术选择上摆脱平台限制。
- en: It is also important to mention that applications' dependency on external resources
    is not a matter of choice but has rather become a necessity, since applications
    are more and more dependent on third-party web service APIs and social media networks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，应用程序对外部资源的依赖不是一个选择问题，而已经变成了一个必要性，因为应用程序越来越依赖于第三方网络服务API和社交媒体网络。
- en: Web services
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务
- en: A web service is generally defined as an interoperable machine-to-machine communication
    over the wire (network). In the context of cross-platform application, the most
    important term in this definition would be "interoperable". Web services written
    in different frameworks or languages and running on different type of runtimes
    and hardware conform to the same standards, most of which can be consumed by applications
    running on a variety of platforms, including Xamarin target platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务通常定义为通过网络（网络）进行的可互操作机器到机器通信。在跨平台应用程序的上下文中，这个定义中最重要的术语将是“可互操作”。使用不同框架或语言编写的网络服务，在运行于不同类型的运行时和硬件上，符合相同的标准，其中大部分可以被运行在各种平台上的应用程序消费，包括Xamarin目标平台。
- en: Xamarin target platforms, namely iOS and Android, and Windows Runtime, can access
    stateless web services using the TCP/IP (short for Transmission Control Protocol
    / Internet Protocol) stack over a secure or non-secure HTTP (short for Hypertext
    Transfer Protocol) transport layer. Even though various data representations can
    be consumed via web services, JSON and XML are the most common text-based notations
    used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin目标平台，即iOS和Android，以及Windows Runtime，可以使用TCP/IP（传输控制协议/互联网协议的简称）堆栈通过安全或非安全的HTTP（超文本传输协议的简称）传输层访问无状态网络服务。尽管可以通过网络服务消费各种数据表示，但JSON和XML是最常见的基于文本的表示法。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'While defining or accessing a web service, there are three basic elements that
    need to be taken into consideration. We can call these the A-B-C of a web service:
    Address, Binding, and Contract. The address is the remote access location to the
    service, binding defines the transport and security protocols, and contract defines
    the data types and the methods used by the service.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: While the methods and data types defined in the web service contract are very
    case-specific, transport and serialization protocols that can be used by Xamarin
    applications can be generalized.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In web service scenarios, if the consumer is a Xamarin target platform, you
    should always be persistent about using asynchronous implementation for the client
    implementation. Asynchronous implementation for the web service clients decreases
    the chance of blocking the main thread, as discussed previously, and protects
    the application from network shortage related errors and crashes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Transport
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Xamarin applications on both iOS and Android platforms, the main communication
    protocol is HTTP. HTTP transport can be secured on the client and/or message level
    using a certificate or credentials.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The message-level security is optional in other versions of iOS and Xamarin.Android
    applications. In iOS 9, the **App Transport Security** (**ATS**) feature enforces
    secure connections to network resources. Even though it is possible to add certain
    domains to the exclusion list, or to turn off the ATS altogether for the target
    applications, it is strongly advised that you use secure transport over HTTP (or
    HTTPS) for Xamarin.iOS applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Even though communication protocols for TCP, UDP, or web sockets over HTTP are
    fully or partially supported on Xamarin platforms, with the current service infrastructure
    implementation, these communication channels cannot be used with web services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messaging specifications of a service define which format should be used while
    communicating data over the HTTP transport layer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin applications dealing with web services, messages should be constructed
    either according to the SOAP (Simple Object Access Protocol) or using POX (short
    for Plain Old XML) or JSON, depending on the service requirements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Messaging](img/B04693_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Simple SOAP Communication Example
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The messaging structure is mainly important for the serialization and deserialization
    of request and response pairs between the client and server implementations. Hence,
    it is possible to employ other types of data communication models, which would
    require additional custom implementation for the client and the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: SOAP/XML services
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SOAP web services use XML data objects enveloped in SOAP-defined schemas. **Windows
    Communication Foundation** (**WCF**) services and ASP.Net Legacy Services (ASMX)
    are both SOAP services and conform to the SOAP protocol.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: SOAP web service contracts are defined in **Web Service Description Language**
    (**WSDL**) and the WSDL document, together with other XML data schemas (for example,
    XSD files), are generally accessible through the web service URL. Using this document,
    web services can be defined in a consistent manner, irrespective of the underlying
    language, and can be interfaced with and consumed by various clients.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Service WSDL for a SOAP 1.1 Service
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin applications, one of the possible ways to create a so-called proxy
    (service consumer) is to use the Silverlight SDK to generate the access code.
    The main reason for using the Silverlight SDK is the fact that the Windows Communication
    Foundation client infrastructure is not fully included in the Xamarin core and
    only a subset of client features, very similar to the Silverlight framework, can
    be used to access web services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the client, you can simply use the command-line tool to
    execute the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SLSvcUtil can be found in various SDKs including Windows Phone 7, Windows Phone
    8, Windows Phone 8.1 (Silverlight), as well as the actual Silverlight SDK directories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v7.0\Tools\SlSvcUtil.exe`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.0\Tools\SlSvcUtil.exe`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.1\Tools\SlSvcUtil.exe`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Silverlight\v5.0\Tools\SlSvcUtil.exe`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding command would generate a WCF client that can communicate with
    any web service that supports the SOAP 1.1 profile. If we were to consume a WCF
    service, the supported binding configurations would be `BasicHttpBinding` and
    `WebHttpBinding` (essentially a REST binding). `WSHttpBinding` and similar configurations
    use other SOAP profiles to envelope the data requests and responses.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: Generating Silverlight Proxy
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The generated client would have both the Event-Based and Asynchronous Programming
    Model (APM) asynchronous methods for accessing the client.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another approach would be to create a web reference in Visual Studio or Xamarin
    Studio. A web reference can only be used to communicate with services that implement
    the WS-I Basic Profile 1.1 (in other words, SOAP 1.1). Web reference generated
    clients use the ASMX communication stack (.NET 2.0 Services Technology) as opposed
    to the WCF client infrastructure used by service references.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Add Web Reference Dialog (Visual Studio)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: If we were to compare the generated clients from the web reference and the Silverlight
    SDK, we could easily identify the underlying technologies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Looking at the class diagram for both of the generated proxies, we can get
    some more insight into the method execution strategies:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Generated Proxy Comparison
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The ideal way to integrate the generated proxy in a cross-platform project would
    be to add the service reference in a portable class library to be used by platform-specific
    projects. In order to be able to add a service reference in a PCL project in Visual
    Studio, you must remove Windows Phone 8.1 as one of the targets and/or add a reference
    to the `System.ServiceModel` namespace (Visual Studio will automatically remove
    Windows Phone 8.1 from the targets list). The Windows Phone 8.1 platform does
    not include the Windows Communication Foundation client assemblies. After this
    step, the **Add Service Reference** option will appear under the project context
    menu.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: For scenarios involving Windows Phone 8.1, the more appropriate solution would
    be to use a RESTful service and a client.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: RESTful services
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful services are one of the most common distributed system implementations
    involving mobile applications. Compared to SOAP services, they don't have the
    overhead of SOAP protocols or the enveloping of the request/response pairs. In
    essence, network traffic caused by a SOAP method call is the same as the request/response
    pair of a REST call. The simplicity of the **Representational State Transfer**
    (**REST**) model increases the performance and maintainability. Stateless and
    cacheable approaches of RESTful services makes them an optimal solution for Xamarin
    target platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: REST services can essentially be described as static HTTP endpoints. The HTTP
    verbs (GET, PUT, POST, and DELETE) used to access these endpoints define the type
    of method to be invoked on the service layer (PUT for update, POST for create,
    and DELETE for delete actions). The messaging structure can vary from JSON to
    XML, even to ATOM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: On Xamarin target platforms, there are various out-of-the-box options and additional
    components available for REST-based web services. Any of these options can be
    used to execute web requests and request/response pairs can be serialized/deserialized
    according to the requirements and chosen messaging media-type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Since we are making ordinary web requests to the REST endpoints, the simplest
    implementation would involve the `HttpClient`, which is included in the `System.Net.Http`
    namespace.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to implement a base class that will handle the CRUD
    (create, read, update, and delete) methods on the RESTful version of the web service
    used in the previous section (`TravelTrace.ReferenceDataService`), we could implement
    a per-call wrapper around the inner HTTP client layer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that we are using the base address as the server address and,
    if any, using the security token to initialize our client. In this implementation,
    the create method will simply create the HTTP client and use the authentication
    token as a default header. Another important requirement is to set the "Accept"
    header to announce which type of content the client is expecting from the server
    (JSON in this example).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the HTTP pipeline is ready to execute the requests, we can start implementing
    the base methods for the REST service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the `GetRegions` method looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result of this request can be visualized in the debug screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![RESTful services](img/B04693_05_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: JSON data returned from Web API
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is only the string representation of the service data, and we
    would need to extend our implementation to include a JSON serializer. There are
    multiple options available for serialization, including the standard libraries
    available through the *Microsoft BCL* package: `System.Xml` and `System.Json`
    namespaces. *NewtonSoft Json.NET* is still one of the most popular JSON libraries
    and available through NuGet.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using this implementation, we can create generic methods in the base class implementation
    and push the serialization responsibility to this layer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can extend this generic implementation for other web methods and create the
    basis for our RESTful client. The authentication scenario will be discussed further
    in the following section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: There are many more REST consumer implementations available for the Xamarin
    developer and these modules can be included in cross-platform projects via components
    and NuGet packages (RestSharp, Hammock, and so on).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: OData and OAuth
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OData and OAuth are two widely accepted standards/protocols for RESTful communication
    scenarios. Xamarin mobile applications that deal with external resources, and
    especially third-party web service APIs, are generally implementing these protocols.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: OData
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike SOAP, which is a communication protocol, REST is simply an architectural
    approach to web service implementations. RESTful services do not need to conform
    to certain specifications and may vary greatly. In order to identify the requirements
    for RESTful services and create a uniform structure for data being exchanged between
    the client applications and the server, OData was initiated by Microsoft in 2007\.
    OData is now an internationally accepted protocol that is maintained by OASIS
    and supported/used by various applications, platforms, and companies (for example,
    Microsoft Azure Mobile Services, Microsoft Office 365 Web Access, Salesforce,
    SAP Netweaver Gateway Solution, IBM WebSphere, and so on).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: In OData protocol, each object set is defined by an endpoint in line with REST
    principles. For GET requests, these entity set endpoints can either accept object
    identifiers, which results in the details of that specific entity instance, or
    entities in the list can be queried with OData filter and other query options.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the WSDL in SOAP/XML services, accessible endpoints (entity sets
    and functions) and types used in the service contracts are generally served through
    the metadata endpoint with a CSDL (OData Common Schema Definition Language) file
    in OData.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: To access the whole list of elements, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: To access a single element in the entity set endpoint, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions(guid'90222c18-66fa-441a-b069-0115faa1e0f1')`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: To query the list of elements with a filter, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions?$filter=Continent
    eq 'Europe'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Advanced OData queries involving additional property expansions, lambda operators,
    and functions are also possible with the OData protocol; however, these topics
    are beyond the scope of this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple NuGet packages and components available both as open source
    and/or free to download that help with the client generation for OData services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth is an open standard used generally by service providers for authorization.
    A general use case for OAuth would be to use third-party identity providers such
    as Live ID (Microsoft), Google, Facebook, or Twitter for authentication and authorization
    in a mobile or web application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: A classic OAuth 2.0 implementation scenario is generally a two-step process.
    The first step involves the user granting access to the client application through
    the provider web interface. The second step is using the authorization code received
    from the provider's web interface to get an access token to access the provider's
    resources.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth](img/B04693_05_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Facebook as Auth Provider
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The first step of the authorization process on a web application is generally
    an `iframe` displaying the provider's authorization page. In a Xamarin application,
    this step is executed using a web view control or a more specialized implementation
    (`WebAuthenticationBroker` is an out-of-box control on Windows Phone 8.1). Implementing
    the two-step authentication process can become quite cumbersome considering the
    fact that the provider's page makes a callback request to the client application
    page with the authorization token and the client app is responsible for parsing
    and extracting this token either from the callback URL or the body of the content.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth](img/B04693_05_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Xamarin.Auth Components
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide access to OAuth APIs and simplify the implementation, developers
    can make use of the available Xamarin OAuth component: Xamarin.Auth (available
    on Xamarin.iOS and Xamarin.Android platforms). There is also an accompanying component
    for social media provider APIs: Xamarin.Social.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using the Xamarin.Auth implementation, authenticating with the Facebook API
    can become as simple as a few lines of code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: SignalR
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET SignalR is a web server-side technology that allows developers to pass
    real-time updates to their applications. SignalR works in a similar way to WCF
    duplex channels where the server side is accessible through the main service contract
    and the server-to-client communication occurs through the callback contract. While
    WCF duplex channels provide support for the same scenarios as SignalR, duplex
    channel implementation is currently not supported in any of the Xamarin target
    platforms. On the other hand, there is a component available for use on all Xamarin
    target platforms for SignalR.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B04693_05_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: SignalR Component
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: SignalR takes advantage of `WebSockets`, which enables bidirectional communication
    over the HTTP transport. In essence, `WebSockets` works almost in the same way
    as TCP Sockets; however, the connection is established over the HTTP transport
    layer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Using SignalR, applications requiring real-time data can be implemented without
    resorting to polling or listener channel implementations, which is neither scalable
    nor efficient on mobile platforms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: SignalR is generally implemented with a Hub application on the server-side,
    which creates different event sinks to be subscribed by different applications.
    Each client that subscribes to a certain channel gets event notifications and
    data over these channels in a normal broadcast scenario in a string format or
    already deserialized as a complex type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: SignalR server implementations can, generally speaking, replace RESTful service
    actions. These duplex hubs can provide functions to be called by the consumers
    as well as update calls from the server to listening clients.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: While different message formats can be used to exchange data, most implementations
    employ the JSON format to serialize and deserialize data, and Json.NET is the
    default serialization library used by the SignalR component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On top of the server invoked events, SignalR channels also offer lifetime events:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Received**: Raised when any data is received on the connection. Provides
    the received data.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConnectionSlow**: Raised when the client detects a slow or frequently dropping
    connection.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reconnecting**: Raised when the underlying transport begins reconnecting.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reconnected**: Raised when the underlying transport has reconnected.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StateChanged**: Raised when the connection state changes. Provides the old
    state and the new state.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed**: Raised when the connection has disconnected.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR supports SSL transport security as well as having the ability to integrate
    with the existing authentication and authorization providers already being used
    by the web server and mobile applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and best practices
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mobile applications, developers often use certain reusable design patterns
    while using web services and other communication channels in development projects.
    These patterns aim to increase the efficiency and increase the code sharing not
    only between platforms but also among various execution domains of cross-platform
    mobile applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Async conversions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated proxies for WCF and/or SOAP/XML services generally include either
    an event-based async implementation or an asynchronous invoke pattern with begin
    and end methods. Both of these implementations can be converted to a task-based
    async pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In order to convert the event-based async service method to a task-based one,
    we can use `TaskCompletionSource<T>` and return the task that is produced (refer
    to [Chapter 3](ch03.html "Chapter 3. Asynchronous Programming"), *Asynchronous
    Programming*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For the async invoke pattern, we can use the designated methods from the `TaskFactory`.
    The `FromAsync` method of the `TaskFactory` uses the begin and end methods together
    with the async state object (which can, for example, be used for cancellation
    token or progress callback) and creates an awaitable task.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data model abstraction
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the quality identifiers that were put forward previously, in service-related
    scenarios, it is important to create a data model abstraction layer which can
    be used by different branches of a cross-platform application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the travelers'' guide application example from previous sections, we
    can analyze the sharing strategy. In this example, as a development team or a
    single developer, we are responsible for:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the service layer responsible for accessing the database and connecting
    to external APIs, if necessary
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the shared common logic which will be used by Xamarin applications
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Xamarin.iOS and Xamarin.Android applications
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Windows Phone 8.1 application
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the web interface which will employ a Silverlight component (optional)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, we will be implementing only a single data type and a single
    GET method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: For the contracts and the data objects, we can create a portable library that
    will be targeting Xamarin platforms together with .NET 4.5\. The reason we are
    including the .NET profile is because we will be using the data model in the service
    layer implementation as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The implementation starts by creating the Data Transfer Model objects. These
    objects are generally the reflection of the database tables used on the service
    layer. However, one-to-one mapping between DTOs and DBOs (Entity Framework items)
    is not absolutely necessary since the DTO abstraction layer's sole purpose is
    to create an abstraction layer over the actual data repository that we will be
    dealing with.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we are including Json.NET attributes to define class properties.
    They are used to format the JSON object attributes during serialization/deserialization
    to camel-case (for example, camelCase), which is the JavaScript convention, rather
    than the .NET convention of pascal-case (for example, PascalCase) for property
    names. These property definitions can be used with RESTful clients and web service
    implementations. This will not interfere with other service or client layer use
    cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: After we create the model, we can define the interface(s) that will be used
    by the web service and associated clients. We will define two interfaces for synchronous
    implementation on the service layer and asynchronous consumption on the client
    side.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The service implementation strategy would normally be to use a RESTful layer.
    For demonstration purposes, let's implement the WCF service in a separate project,
    reusing the data model defined and the interface previously created.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Data model abstraction](img/B04693_05_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Solution Structure
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, each service method will be calling a data repository
    (Entity Framework/MSSQL) and the repository will be returning the DTO objects
    by converting the database layer entities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The next section of the project that we need to implement would be the service
    data consumer layer. We will create a new portable library for this layer and
    use a generated WCF client. After creating the project and adding the reference
    to the `System.ServiceModel` namespace and the common portable library that contains
    the DTO model, an important detail to remember is to make sure that the generated
    proxy reuses the referenced libraries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Data model abstraction](img/B04693_05_11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Service Reference Properties
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using the Silverlight SDK to generate the client, it is a little
    more complicated to include the existing libraries so that the types are reused.
    In order to do this, you can use the "reference" switch (or simply, `/r`: ) and
    point the utility to the assemblies that contain the implemented types.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After creating the proxy, we have a structure in which the data model and the
    contracts are shared by different layers of the application including the service,
    data access layer, service proxy, and finally, the applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Data model abstraction](img/B04693_05_12.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Shared service structure
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The implementation, however, should be further extended with conversions to
    task-based async implementation on the service proxy. Another useful improvement
    would be to implement local DB caching and offline storage. For this caching layer,
    the same DTO implementation can be reused.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If we were to include a Windows Phone 8.1 client in this cross-platform project,
    the only solution to the lack of WCF infrastructure would be to exchange the WCF
    service with a RESTful implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Service cache
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with network scenarios, it is important to keep in mind that mobile
    devices do not always have a good network connectivity or network at all. In order
    to make the Xamarin connected app usable even in offline scenarios, a caching
    layer can be implemented to store and return data items that do not often change.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in travel guide applications, users will want to access guides,
    and possibly maps, even when they are with a roaming connection or, even worse,
    without any connection at all. To facilitate offline storage, we can implement
    a SQLite database that uses the existing data transfer objects as storage items
    and updates the data on certain intervals when there is Internet connectivity.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The first step of the implementation would be to revise our DTO layer classes
    and add SQLite attributes if needed. This will create a dependency on the service
    layer for SQLite assemblies; the other option is either to use linked code files
    between the service layer and the client libraries or to recreate the DTO objects
    specifically for the SQLite data store.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this scenario, in order to create a data context that will use the online
    storage if available and use the local data storage if Internet connectivity is
    limited, we can implement the same data interface that we created for the service
    proxy in the previous examples for the SQLite data source and create one parent
    handler for the data sync context.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Service cache](img/B04693_05_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Data Abstraction on App Tiers
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In the sync context, for GET methods, the service calls will be used only for
    updating the local storage and actual results will be returned from the local
    storage. For PATCH, POST, and PUT calls, depending on the online connectivity,
    we will be either saving the data locally or pushing the deltas and new object
    instances to the service and updating the local data with the updates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For performance improvement in this implementation, when we are loading data
    for certain visualizations, we can first call the local data provider and continue
    with UI updates and then call the web service method and the same continuation
    delegate.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Platform-specific concepts
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other concepts and network communication methods on Xamarin platforms
    that are provided by the native runtime and supported by Xamarin.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for an Android or Windows Phone application to access Internet, the
    application manifest should declare that the application will need to use the
    network to access resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The permission on Android system is declared using the `uses-permission` tag
    in the manifest node of the XML file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While this declaration will suffice in most use case scenarios, in order to
    access the current network status or the Wi-Fi status, you must also declare the
    network state permissions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For a Windows phone, the app capability to declare would be `ID_CAP_NETWORKING`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Application manifests for both platforms can be edited through the application
    project properties in the designated configuration section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Permissions](img/B04693_05_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Android Manifest
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: iOS, other than the App Transport Security (ATS) that was mentioned previously,
    does not enforce any manifest setup or permissions for applications to use network
    connection.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: NSUrlConnection/NSUrlSession (iOS Only)
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the different client libraries available for use with Xamarin target
    platforms, some native implementations can also be used to call and receive external
    web data. One of these available options for Xamarin.iOS platform is `NSUrlConnection`.
    With the help of `NSUrlConnection`, developers can make web requests and use the
    response.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple web request to retrieve the data from the previously demonstrated
    static data endpoint on iOS would look similar to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The implementation for the connection delegate would involve the deserialization
    of the data and assigning the result to the `TaskCompletionSource` so the method
    execution can be finalized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even though this implementation is possible on the iOS platform, considering
    the cost of passing the mono to iOS bridge (likewise on Android and JNC Bridge),
    this type of implementation should be avoided, and either only native or mono
    runtime code should be used to communicate over the network.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, we can implement the usage scenario for the new `NSUrlSession`
    class in iOS. However, `NSUrlSession` can also be used in background download
    scenarios. Therefore, we will discuss it in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Background downloads
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the application requires larger network resources than the client UI can
    wait for, in Xamarin mobile applications we can resort to background downloads.
    Both iOS and Android platforms offer implementations for background downloads
    and these strategies can be executed on Xamarin runtime.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: For Xamarin.Android application developers, the easiest way to execute a background
    download is to use the Download Manager API service/application provided since
    API level 9\. The download manager can be initialized with a request and the application
    can subscribe to event notification(s) regarding the download status.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a request to pass onto the `DownloadManager`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the request is ready to be executed, we can get the `DownloadManager`
    instance and queue the download request:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The download reference can be used to get the current status information about
    the queued download or cancel the ongoing background download.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: To get the current status of the download or cancel it, we can use the respective
    methods on the `DownloadManager` instance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This implementation can be extended with the notification(s) that are received
    from the `DownloadManager` application using a `BroadcastReceiver` class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can now register the broadcast receiver with the `DownloadManager` instance
    and update the UI with a possible delegated implementation for updating it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On top of the broadcasts mechanism, the Download Manager App UI can also be
    invoked within the Xamarin applications to give a uniform UI about on-going or
    completed transfers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform (at least post iOS 7), background transfers (both download
    and upload operations) are made possible with `NSUrlSession`. `NSUrlSession` provides
    an easy to implement interface that lets developers create an efficient and reliable
    transfer processes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The implementation strategy for `NSUrlSession` initially involves the implementation
    of an `NSUrlSessionDelegate`, which will be the responsible "handler" for the
    transfer process. Basic methods related to the health and status of the transfer
    are exposed through this delegate and can be implemented to provide required information
    for the transfer or give real-time updates to the application user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`DidFinishEventsForBackgroundSession` is called when the background session
    is complete'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidReceiveChallenge` is invoked when the server requests credentials'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidBecomeInvalid` is invoked when there is a problem with the session'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSUrlSessionDelegate` provides the base implementation for more specialized
    transfer delegates: `NSUrlSessionDownloadDelegate` for download operations and
    `NSUrlSessionTaskDelegate` for upload operations. These delegate classes expose
    additional status methods related to the transfer tasks (for example, download
    delegate provides methods to retrieve notifications about the download progress).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to use the same example as on Xamarin.Android with
    the `BroadcastReceiver` implementation, the `NSUrlSessionDownloadDelegate` implementation
    would require three basic methods for completion, error, and progress.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the delegate implementation is complete, we can create the session and
    start the download operation using the `NSUrlSession`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On top of the handler implementation, the iOS app can be woken to execute certain
    code, such as a local mobile notification to inform the user about the completed
    sessions. For the task complete event, one needs to use the iOS application delegate
    (refer to [Chapter 2](ch02.html "Chapter 2. Memory Management"), *Memory Management*)
    for `DidFinishEventsForBackgroundSession`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Mobile notifications (also called pushed notifications for remote scenarios)
    are user notifications that are executed on the OS level to inform the user about
    application-related updates. They can be triggered both locally or by using a
    remote server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Push notifications are subtle UI messages that can help an application to provide
    the user information about an asynchronous task being executed by the service
    layer or about an external event that is related to the application instance itself
    (for example, messages from social networks, approval for a travel reservation,
    and so on).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create and receive push notifications on both Xamarin platforms
    and Windows Phone. These notifications are triggered by a secondary server/application
    (for example, service layer), brokered by the corresponding messaging infrastructure
    provider for the platform and displayed by the application on the target client.
    For the Android platform, the messaging provider is **Google Cloud Messaging**
    (**GCM**) and it is the **Apple Notification Push Service** (**APNS**) for iOS.
    Both of these service providers require your application to be registered to receive
    push notifications and the server application to have the credentials to be able
    to authenticate with the notification services. Similarly, **Windows Notification
    Services** (**WNS**) adopts a federated authentication mechanism.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Both GCM and APNS use a subscription model in which the client app on a specific
    device subscribes/registers for the push notifications and an addressing token
    is created. The addressing token is used, later on, by the server to send push
    notifications to the message broker service (for example, GCM) and the queued
    messages are delivered to the specific client.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Push notifications](img/B04693_05_15.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Push Notifications
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: On top of the classic messaging model, GCM also supports topic-based and group-based
    messages where the receivers are not limited to a single device/application pair.
    It is also possible with GCM to create a duplex channel where the client is able
    to send messages back to the server layer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications on these platforms can be used to trigger various tasks,
    the most common of which is to navigate to a certain view and continue the business
    process flow initialized by the notification.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Although it is relatively elementary on the client side to subscribe to push
    notifications, cross-platform scenarios require complex implementation to introduce
    a single server environment to provide messages to both GCM and APNS. However,
    there are platform-agnostic implementations available for both of these platforms.
    The Microsoft Azure platform and the notification hub is one of these solutions,
    where communication with GCM and APNS are both supported through usage of the
    same business logic implementation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Cloud integration
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though there are multiple cloud service providers as development platforms
    for creating the backend for mobile applications, Microsoft Azure stands out among
    the competitors with its inherent natural bond to the .NET platform and subsequently
    Xamarin, considering its evolution. Most of the features supported by Azure have
    a specific implementation for Xamarin target platforms.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Azure Mobile Services
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Mobile Services is a scalable cloud development platform that helps developers
    add functionality to their mobile applications with ease. The patterns and features
    described in this chapter related to network services such as OData services,
    offline data storage, push notifications, and OAuth authentication providers are
    already included in the mobile services SDK and can be configured through the
    Azure management console.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate aforementioned features, we can incorporate them into
    our demo application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The initial step would be to create a mobile service on the Azure management
    console. For this purpose, we will select a compute service and create the mobile
    service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_16.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Create Compute Service
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will set up the mobile service endpoint and create the SQL database
    to store the online data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_17.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Mobile Service Setup
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Once the setup is complete, the "personalized" service layer project can be
    downloaded in order to integrate the mobile services into the application project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_18.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Connect Mobile Services to an existing Xamarin app
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In the service layer project, you will notice that there is only a single controller
    created for your convenience. We will be extending the project with additional
    controllers and adding a reference to our own DTO data model. In order to reuse
    the types created in the previous sections, instead of referencing the common
    data model project directly, we add the data type files as a reference to the
    new service project that we downloaded from the Azure portal. The reason for the
    referenced files is that the data objects in the service project have to derive
    from `EntityData` class. Another change we need to make is to convert the class
    definitions to partial and remove the SQLite references, for example, you can
    comment out the SQLite property descriptors or use conditional compilation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are using `AZURE` as the build constant for the Azure web
    service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, create a data object definition using a `partial` declaration for
    the `Region` class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After this step, you can simply use the existing project item template for the
    controller to add the specialized data endpoint (Microsoft Azure Mobile Services
    Table Controller).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_19.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: Microsoft Azure Mobile Services Table Controller
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: This will create a controller for the data object and insert the type into the
    data context.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is published and the mobile services are running, SQL database
    tables are going to be migrated automatically. This migration also applies to
    data table column changes or future additions to the DTO model.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add the NuGet package or the component to our client application
    and add the necessary initialization code, as described in the start page of mobile
    services section on the Azure management console.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main activity, we create the following mobile service instance:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在主活动中，我们创建了以下移动服务实例：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following to an event handler or the `OnCreate` function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到事件处理程序或 `OnCreate` 函数中：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After the code is successfully executed, the data on the Azure database can
    be observed using SQL Management Studio or the Visual Studio SQL Server tools.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码成功执行后，可以使用 SQL Management Studio 或 Visual Studio SQL Server 工具观察 Azure 数据库中的数据。
- en: '![Azure Mobile Services](img/B04693_05_20.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 移动服务](img/B04693_05_20.jpg)'
- en: Azure Data Sample
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 数据示例
- en: Now that we have a working service layer and a client that can communicate with
    it, we can have a look at the local synchronization.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以与之通信的工作服务层和客户端，我们可以看看本地同步。
- en: Azure offline data
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 离线数据
- en: For local data caching and offline scenarios, Azure Mobile Services SDK already
    implements a synchronization framework where the local data is stored in SQLite
    database and the synchronization is handled by pull and push commands (push requests
    upload local changes to the cloud store whereas pull requests download the latest
    changes from the server) using a default conflict handler. Each pull request automatically
    issues a push request where the local data is pushed to the cloud storage. Conflicts
    are resolved according to the created and updated fields, which are members of
    each object type defined using the `EntityData` base class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地数据缓存和离线场景，Azure Mobile Services SDK 已经实现了一个同步框架，其中本地数据存储在 SQLite 数据库中，同步由拉取和推送命令（推送请求将本地更改上传到云存储，而拉取请求从服务器下载最新更改）处理，使用默认的冲突处理器。每个拉取请求都会自动发出一个推送请求，其中本地数据被推送到云存储。冲突根据创建和更新的字段解决，这些字段是使用
    `EntityData` 基类定义的每个对象类型的成员。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before starting the implementation, we need to download and install the Azure
    Mobile Services SQLiteStore NuGet package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，我们需要下载并安装 Azure Mobile Services SQLiteStore NuGet 包。
- en: In order to initialize the default local data store, we will use the `MobileServicesSQLiteStore`
    implementation. Custom local store implementation can be incorporated using the
    `IMobileServiceLocalStore` interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化默认的本地数据存储，我们将使用 `MobileServicesSQLiteStore` 实现。可以通过 `IMobileServiceLocalStore`
    接口集成自定义本地存储实现。
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After the local store is initialized and the synchronization context is created,
    we can implement the synchronization method that can be called every time the
    application starts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地存储初始化和同步上下文创建之后，我们可以实现每次应用程序启动时都可以调用的同步方法。
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both the `PushAsync` and `PullAsync` methods additionally accept filter expressions
    so one can limit the synchronization to certain entities.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushAsync` 和 `PullAsync` 方法还接受过滤表达式，因此可以限制同步到某些实体。'
- en: In this implementation, once the synchronization context is in place, if the
    service connection is not available, the `IMobileServiceSyncTable<T>` interface
    implementations handle the offline data and the data is kept in the local store
    until the next push operation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，一旦同步上下文就绪，如果服务连接不可用，`IMobileServiceSyncTable<T>` 接口实现将处理离线数据，并且数据将保存在本地存储中，直到下一次推送操作。
- en: Azure authentication
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 身份验证
- en: The Azure platform provides various authentication mechanisms for Xamarin mobile
    applications. Each authentication mechanism can be integrated into existing mobile
    applications with a service backend through NuGet packages and/or components.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 平台为 Xamarin 移动应用程序提供各种身份验证机制。每种身份验证机制都可以通过 NuGet 包和/或组件集成到现有的具有服务后端的移动应用程序中。
- en: Being a multi-tenant, cloud-based directory and identity management service,
    Azure Active Directory (Azure AD) provides application developers an easy way
    to create single sign-on experience on a large number of cloud SaaS applications.
    It is also possible to incorporate an existing Windows Server Active Directory
    into applications and leverage the existing on-premise identity stores. These
    features make the Azure AD an ideal candidate for LOB applications.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多租户、基于云的目录和身份管理服务，Azure Active Directory (Azure AD) 为应用程序开发者提供了一种简单的方法，在大量云
    SaaS 应用程序上创建单点登录体验。还可以将现有的 Windows Server Active Directory 集成到应用程序中，并利用现有的本地身份存储。这些功能使
    Azure AD 成为 LOB 应用程序的理想候选者。
- en: Another authentication strategy for Azure Mobile Services is to configure an
    existing authentication provider such as Facebook, Google, Twitter, or Microsoft
    and secure the service requests using the Azure Mobile SDK. In order to register
    an authentication provider, the first step would be to create a consumer app on
    the target platform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to use Live ID for our authentication scenarios, we
    would need to use the Live Connect App management site ([https://account.live.com/developers/applications/index](https://account.live.com/developers/applications/index)).
    Similarly, for Twitter, we would need to create a Twitter consumer application
    on the Twitter application management console ([https://apps.twitter.com/](https://apps.twitter.com/)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure authentication](img/B04693_05_21.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: Live Connect app management site
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Once the application setup is in place, the Azure management console can be
    used to update the mobile services configuration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure authentication](img/B04693_05_22.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Mobile Services Identity Configuration
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: After the identity provider for the mobile services has been set up, the web
    service project can be easily protected simply by adding the Authorize attribute.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On the client apps, the authentication is handled by simply using the `LoginAsync`
    method on the Azure Mobile Services SDK client with the correct authentication
    provider.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The result is the same authentication screen received using the Xamarin.Auth
    component.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure authentication](img/B04693_05_23-1.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Brokered Authentication
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cloud integration scenarios extend far beyond the ones described here.
    The features that are included in this cloud-based development platform can help
    developers enhance their Xamarin apps with ease and scalability.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an overview of various network channels that can be used
    in Xamarin applications to create connected applications.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Web services are definitely on the essentials list for modern mobile applications
    because of the interoperability of the protocols in place for web services (both
    SOAP/XML and REST/JSON). Unfortunately, XML services are a little harder to integrate
    with Windows Phone 8.1 runtime (even though they are still supported by Windows
    Phone Silverlight runtime) because the Windows Communication Foundation client
    infrastructure is not included in Windows Phone runtime. However, the same RESTful
    service proxies can be used by applications on each Xamarin target platform and
    Windows Phone.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Cloud integration options such as mobile services and Azure Active Directory
    were discussed with demonstration samples. Each of these technologies provides
    additional connectivity and integration opportunities for Xamarin mobile apps.
    SignalR is another web technology that grants additional communication capabilities
    to mobile applications by means of bidirectional communication between the client
    apps and the server.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Several common service and web implementation patterns were demonstrated using
    the TravelTrace application scope that we will be using for various scenarios
    in the remainder of this book. Each pattern described targets different quality
    identifiers initially mentioned.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TravelTrace应用程序范围演示了几个常见的服务和Web实现模式，这些模式将在本书剩余部分的各种场景中使用。每个模式最初都针对不同的质量标识符。
- en: Finally, we discussed some of the platform-specific network options.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些特定平台的网络选项。
