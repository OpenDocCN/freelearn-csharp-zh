- en: Chapter 2. Why We Need Design Patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will try to understand the necessity of choosing a pattern-based
    approach to software development. We start with some principles of software development,
    that one might find useful while undertaking large projects. The working example
    in this chapter starts with a requirements specification and progresses toward
    a preliminary implementation. We will then try to iteratively improve the solution
    using patterns and idioms, and come up with a good design that supports a well-defined
    programming Interface. During this process, we will learn about some software
    development principles that one can adhere to, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles for OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three key uses of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arlow/Nuestadt archetype patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity, value, and data transfer objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command pattern and factory method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design by contract idiom and the template method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade pattern for API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the .NET Reflection API for plugin architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML processing using LINQ for parsing configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep cloning of CLR objects using extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing stateless classes for better scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some principles of software development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing quality production code consistently is not easy without some foundational
    principles under your belt. The purpose of this section is to whet the developer''s
    appetite, and towards the end, some references are given for detailed study. Detailed
    coverage of these principles warrants a separate book on its own scale. The authors
    have tried to assimilate the following key principles of software development,
    which help one write quality code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KISS**: Keep it simple, stupid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DRY**: Don''t repeat yourself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAGNI**:You aren''t gonna need it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low coupling**: Minimize coupling between classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOLID principles**: Principles for better OOP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: William of Ockham framed the maxim **Keep it simple, stupid** (**KISS**). It
    is also called the law of parsimony. In programming terms, it can be translated
    as "writing code in a straightforward manner, focusing on a particular solution
    that solves the problem at hand".
  prefs: []
  type: TYPE_NORMAL
- en: This maxim is important because, most often, developers fall into the trap of
    writing code in a generic manner for unwarranted extensibility. Even though it
    initially looks attractive, things slowly go out of bounds. The accidental complexity
    introduced in the code base for catering to improbable scenarios, often reduces
    readability and maintainability. The KISS principle can be applied to every human
    endeavor. Learn more about the KISS principle by consulting the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t repeat yourself** (**DRY**), a maxim that is often forgotten by programmers
    while implementing their domain logic. Most often, in a collaborative development
    scenario, code gets duplicated inadvertently due to a lack of communication and
    proper design specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: This bloats the code base, induces subtle bugs, and makes things really difficult
    to change. By following the DRY maxim at all stages of development, we can avoid
    additional effort and make the code consistent. The opposite of DRY is **write
    everything twice** (**WET**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**You aren''t gonna need it** (**YAGNI**), a principle that complements the
    KISS axiom. It serves as a warning for people who try to write code in the most
    general manner, anticipating changes right from the word go.'
  prefs: []
  type: TYPE_NORMAL
- en: Too often, in practice, most of the code which are written in a generic manner,
    might result in code smells.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While writing code, one should try to make sure that there are no hard-coded
    references to concrete classes. It is advisable to program to an interface as
    opposed to an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This is a key principle which many patterns use to provide behavior acquisition
    at runtime. A dependency injection framework could be used to reduce coupling
    between classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID principles are a set of guidelines for writing better object-oriented
    software. It is a mnemonic acronym that embodies the following five principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sr. no** | **Principles** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | **Single Responsibility Principle** (**SRP**) | A class should have only
    one responsibility. If it is doing more than one unrelated thing, we need to split
    the class. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **Open Close Principle** (**OCP**) | A class should be open for extension,
    closed for modification. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **Liskov Substitution Principle** (**LSP**) | Named after Barbara Liskov,
    a Turing Award laureate, who postulated that a sub-class (derived class) could
    substitute any super class (base class) references without affecting the functionality.
    Even though it looks like stating the obvious, most implementations have quirks
    that violate this principle. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **Interface Segregation Principle** (**ISP**) | It is more desirable
    to have multiple interfaces for a class (such classes can also be called components)
    than having one Uber interface that forces implementation of all methods (both
    relevant and non-relevant to the solution context). |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **Dependency Inversion** (**DI**) | This is a principle which is very
    useful for framework design. In the case of frameworks, the client code will be
    invoked by server code, as opposed to the usual process of the client invoking
    the server. The main principle here is that abstraction should not depend upon
    details; rather, details should depend upon abstraction. This is also called the
    **Hollywood** principle (Do not call us, we will call you back). |'
  prefs: []
  type: TYPE_TB
- en: The authors consider the preceding five principles primarily as a verification
    mechanism. This will be demonstrated by verifying the ensuing case study implementations
    for violation of these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Karl Seguin has written an e-book titled *Foundations of Programming - Building
    Better Software*, which covers most of what has been outlined here. Read his book
    to gain an in-depth understanding of most of these topics. The SOLID principles
    are well covered in the Wikipedia page on the subject, which can be retrieved
    from [https://en.wikipedia.org/wiki/SOLID_(object-oriented_design](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design).
    Robert Martin's *Agile Principles, Patterns, and Practices in C#* is a definitive
    book on learning about SOLID, as Robert Martin himself is the creator of these
    principles, even though Michael Feathers coined the acronym.
  prefs: []
  type: TYPE_NORMAL
- en: Why are patterns required?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the authors, the three key advantages of pattern-oriented software
    development that stand out are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A language/platform-agnostic way to communicate about software artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tool for refactoring initiatives (targets for refactoring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better API design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the advent of the pattern movement, the software development community
    got a canonical language to communicate about software design, architecture, and
    implementation. Software development is a craft that has got trade-offs attached
    to each strategy, and there are multiple ways to develop software. The various
    pattern catalogs brought some conceptual unification for this **cacophony** in
    software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most developers around the world today who are worth their salt can understand
    and speak this language. We believe you will be able to do the same by the end
    of the chapter. Imagine yourself stating the following about your recent implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our tax computation example, we have used the command pattern to handle
    the computation logic. The commands (handlers) are configured using an XML file,
    and a factory method takes care of the instantiation of classes on the fly using
    Lazy loading. We cache the commands, and avoid instantiation of more objects by
    imposing singleton constraints on the invocation. We support the prototype pattern
    where command objects can be cloned. The command objects have a base implementation,
    where concrete command objects use the template method pattern to override methods
    that are necessary. The command objects are implemented using the design by contracts
    idiom. The whole mechanism is encapsulated using a Facade class, which acts as
    an API layer for the application logic. The application logic uses entity objects
    (reference) to store the taxable entities, attributes such as tax parameters are
    stored as value objects. We use **data transfer object** (**DTO**) to transfer
    the data from the application layer to the computational layer. The Arlow/Nuestadt-based
    archetype pattern is the unit of structuring the tax computation logic.
  prefs: []
  type: TYPE_NORMAL
- en: For some developers, the preceding language/platform-independent description
    of the software being developed is enough to understand the approach taken. This
    will boost developer productivity (during all phases of SDLC, including development,
    maintenance, and support) as the developers will be able to get a good mental
    model of the code base. Without Pattern catalogs, such succinct descriptions of
    the design or implementation would have been impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In an Agile software development scenario, we develop software in an iterative
    fashion. Once we reach a certain maturity in a module, developers refactor their
    code. While refactoring a module, patterns do help in organizing the logic. The
    case study given next will help you to understand the rationale behind *patterns
    as refactoring targets*.
  prefs: []
  type: TYPE_NORMAL
- en: APIs based on well-defined patterns are easy to use and impose less cognitive
    load on programmers. The success of the ASP.NET MVC framework, NHibernate, and
    APIs for writing HTTP modules and handlers in the ASP.NET pipeline are a few testimonies
    to the process. You will see how these three key advantages are put into practice
    in the ensuing chapters and case studies.
  prefs: []
  type: TYPE_NORMAL
- en: A quick foray into the .NET Reflection API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we write non-trivial software that should go to production, it is mandatory
    to have the ability to load and execute modules on the fly. This is useful when
    you are planning to provide user defined extensions as a mechanism to add new
    features to the existing software. The .NET Reflection API is a nifty mechanism
    supported by the Microsoft Corporation to help developers to write code that can
    be loaded dynamically, after the base software has been written. The platform
    technologies, such as ASP.net, WCF,EF, and WPF, use reflection extensively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write a simple program that will instantiate the object using the `new`
    keyword, and after the object instantiation, a property (`X`) will be set to the
    value `0xBEEF`. The .NET Reflection API will be used to retrieve the property
    value and invoke a method (`Spit`) using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will be using .NET Reflection API extensively in our programs. A competent
    programmer should know the .NET Reflection API and its features to write any advanced
    piece of code. Do consult the Microsoft documentation to understand the features
    available and the nuances of the API. If you want to be a library or framework
    designer, you should know Reflection API in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Personal income tax computation - A case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than explaining the advantages of patterns, the following example will
    help us to see things in action. Computation of annual income tax is a well-known
    problem domain across the globe. We have chosen an application domain that is
    well known for focusing on software development issues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application should receive inputs regarding the demographic profile (UID,
    Name, Age, Sex, Location) of a citizen and the income details (Basic, DA, HRA,
    CESS, Deductions) to compute their tax liability. The system should have discriminants
    based on the demographic profile, and have a separate logic for senior citizens,
    juveniles, disabled people, female senior citizens, and others. By discriminant
    we mean that demographic parameters such as age, sex, and location should determine
    the category to which a person belongs and therefore apply category-specific computation
    for that individual. As a first iteration, we will implement logic for the senior
    citizen and ordinary citizen categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'After preliminary discussions, our developer created a prototype screen, as
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Personal income tax computation - A case study](img/B05691_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Archetypes and business archetype patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The legendary Swiss psychologist, Carl Gustav Jung, created the concept of archetypes
    to explain fundamental entities that arise from a common repository of human experiences.
    The concept of archetypes percolated to the software industry from psychology.
    The Arlow/Nuestadt patterns describe business archetype patterns such as Party,
    Customer Call, Product, Money, Unit, Inventory, and so on. An example is the Apache
    Maven archetype, which helps us to generate projects of different natures, such
    as J2EE apps, Eclipse plugins, OSGI projects, and so on. The Microsoft patterns
    and practices describe archetypes for targeting builds such as web applications,
    rich client applications, mobile applications, and services applications. Various
    domain-specific archetypes can exist in respective contexts as organizing and
    structuring mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will define some archetypes that are common in the taxation
    domain. Some of the key archetypes in this domain are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sr.no** | **Archetype** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | SeniorCitizenFemale | Tax payers who are female, and above the age of
    60 years. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | SeniorCitizen | Tax payers who are male, and above the age of 60 years.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | OrdinaryCitizen | Tax payers who are male/female, and above 18 years
    of age. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | DisabledCitizen | Tax payers who have any disability. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | MilitaryPersonnel | Tax payers who are military personnel. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Juveniles | Tax payers whose age is less than 18 years. |'
  prefs: []
  type: TYPE_TB
- en: We will use demographic parameters as discriminants to find the archetype that
    corresponds to the entity. The whole idea of inducing archetypes is to organize
    the tax computation logic around them. Once we are able to resolve the archetypes,
    it is easy to locate and delegate the computations corresponding to the archetypes.
  prefs: []
  type: TYPE_NORMAL
- en: Entity, value, and data transfer objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create a class that represents a citizen. Since a citizen needs
    to be uniquely identified, we are going to create an entity object, which is also
    called a reference object (from the DDD catalog). The **universal identifier**
    (**UID**) of an entity object is the handle to which an application refers. Entity
    objects are not identified by their attributes, as there can be two people with
    the same name. The ID uniquely identifies an entity object. The definition of
    an entity object is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class definition, `Id` uniquely identifies the entity object.
    TaxParams is a value object (from the DDD catalog) associated with the entity
    object. Value objects do not have a conceptual identity. They describe some attributes
    of things (entities). The definition of TaxParams is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While writing applications ever since Smalltalk, **Model-view-controller**
    (**MVC**) is the most dominant paradigm for structuring applications. The application
    is split into a model layer (which mostly deals with data), a view layer (which
    acts as a display layer), and a controller (to mediate between the two). In the
    web development scenario, they are physically partitioned across machines. To
    transfer data between layers, the J2EE pattern catalog identified the DTO. The
    DTO object is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the layering exists within the same process, we can transfer these objects
    as-is. If layers are partitioned across processes or systems, we can use XML or
    JSON serialization to transfer objects between the layers.
  prefs: []
  type: TYPE_NORMAL
- en: A computation engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to separate UI processing, input validation, and computation to create
    a solution that can be extended to handle additional requirements. The computation
    engine will execute different logic depending upon the command received. The GoF
    command pattern is leveraged for executing the logic based on the command received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command pattern consists of four constituents. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Command object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command Dispatcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The command object''s interface has an `Execute` method. The parameters to
    the command objects are passed through a bag. The client invokes the command object
    by passing the parameters through a bag to be consumed by the Command Dispatcher.
    The parameters are passed to the command object through the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ComputationCommand` interface, which all the command objects implement,
    has only one `Execute` method, which is shown next. The `Execute` method takes
    a bag as a parameter. The `COMPUTATION_CONTEXT` data structure acts as the bag
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have already implemented a command interface and bag to transfer the
    parameters, it is time that we implemented a command object. For the sake of simplicity,
    we will implement two commands where we hardcode the tax liability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands will be invoked by a `CommandDispatcher` object, which takes an
    `archetype` string and a `COMPUTATION_CONTEXT` object. The `CommandDispatcher`
    acts as an API layer for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The application to engine communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data from the application UI, be it web or desktop, has to flow to the
    computation engine. The following `ViewHandler` routine shows how data, retrieved
    from the application UI, is passed to the engine, via the Command Dispatcher,
    by a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, imagine that a change in requirements has been received from
    the stakeholders. Now we need to support tax computation for new categories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Initially, we had different computations for senior citizens and ordinary citizens.
    Now we need to add new archetypes. At the same time, to make the software extensible
    (loosely coupled) and maintainable, it would be ideal if we provided the capability
    to support the new archetypes in a configurable manner, as opposed to recompiling
    the application for every new archetype owing to concrete references.
  prefs: []
  type: TYPE_NORMAL
- en: The Command Dispatcher object does not scale well to handle additional archetypes.
    We need to change the assembly whenever a new archetype is included, as the tax
    computation logic varies for each archetype. We need to create a pluggable architecture
    to add or remove archetypes at will.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin system to make system extensible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing system logic without impacting the application warrants a mechanism--that
    of loading a class on the fly. Luckily, the .NET Reflection API provides a mechanism
    for one to load a class during runtime, and invoke methods within it. A developer
    worth his salt should learn the Reflection API to write systems that change dynamically.
    In fact, most of the technologies such as ASP.NET, Entity Framework, .NET Remoting,
    and WCF work because of the availability of Reflection API in the .NET stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Henceforth, we will be using an XML configuration file to specify our tax computation
    logic. A sample XML file is given next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the XML file can be read very easily using LINQ to XML. We
    will be generating a `Dictionary` object with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Factory method pattern and plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method (from the GoF catalog) is a pattern that solves the creation
    of objects through a static method exposed solely for this purpose. The object
    we create will be based on a particular class or derived class. In our case, we
    need to create objects that have implemented the `ComputationCommand` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The consumer of the `Factory` class can also indicate whether it requires a
    singleton or a prototype. The default behavior of the factory method is singleton,
    and it is supposed to return the same instance whenever a call to the `Factory`
    (`Get`) method is received. If the prototype option is given, a clone of the object
    will be created and returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer of the `ObjectFactory` class will indicate whether it wants a
    reference to the object to be available in the plugin cache or a clone of the
    object. We can clone an object using binary serialization. By writing an extension
    method leveraging generics, we can write an all-purpose clone routine. The following
    code snippet will help us to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the implementation of `Get` becomes a straightforward affair; the full
    listing of the `Get` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have got a factory method implementation, let us see how one can
    consume the code. The Command Dispatcher will get a handle to the instance of
    a command based on the archetype provided to it. Once the handle to the object
    is received, the `Execute` method can be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authors of the book feel that command objects should be designed in a stateless
    manner. In the imperative programming world, this means that there shouldn't be
    any shared variables between the methods of a class. We should not add class-level
    variables in order to avoid locks in a multithreaded environment. In effect, parameters
    become the sole determinant of the results. If you cannot avoid having class-level
    variables, they should be immutable (read only). If we mutate the state of an
    object, the prototype created out of that will have an impact because of object
    references. The Java servlet specification expects the servlets to be stateless,
    and Spring controllers are also stateless. The Microsoft ASP.NET MVC controllers
    need not be stateless (not sure why Microsoft chose things that way).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us revisit our `ViewHandler` routine. The interface does not change
    here. The real magic happens beneath the Command Dispatcher object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The view handler routine does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the value from the UI elements to create entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the archetype based on demographic parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a DTO and places it in a bag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatches the method through `CommandDispatcher`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the UI based on the status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new command that will compute taxes for senior citizens who
    are female:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make some changes to the configuration file. The resulting XML configuration
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finalizing the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started with a solution that solved the problem at hand. After creating a
    basic pipeline, we created an elaborate pipeline, which made the solution extensible.
    Now we can add new commands without recompiling the application. This is very
    important in the case of applications that are governed by amendable laws. To
    make our code robust, we will add the design by contract strategy to our command
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Design by contract and template method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design by contract idiom, created by Bertrand Meyer (creator of the Eiffel
    language), extends the ordinary definition of abstract data types with preconditions,
    post conditions, and invariants. To execute any contract in real life, we need
    to satisfy some preconditions, followed by execution, and a post execution (verification)
    phase as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-Execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-Execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of the Post-Execute phase, the invariants are checked to see whether
    they are violated. The consumer will call `PreExecute` to determine whether there
    is a context for the execution of the contract. The invocation will proceed only
    if `PreExecute` returns true. To incorporate design by contract, we extend the
    interface with two additional methods. The resultant `interface` is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a `BaseComputationCommand` class, which will stub the methods
    in the `ComputationCommand` interface. This will help the concrete, derived command
    classes to override only those methods which have the respective changes. After
    redefining the interface, we will create a default implementation of the command
    pattern with methods marked as `virtual`. This helps us to override the implementation
    in the derived class. This is an instance of the template method pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our commands here will use the template method pattern to override only those
    methods that are relevant. Otherwise, there is already a fallback in the `BaseComputationCommand`.
    The template method pattern defines the program skeleton of an algorithm(s) in
    a method, and they are called template method(s). These template methods are overridden
    by sub-classes, which implement the concrete logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We need not override every method, and yet, the whole scheme would still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to rewrite the command pattern to reflect the implementation of
    the design by contract idiom in the command classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In some implementations, the clients will check the return value to see whether
    invariants have been violated. In some cases, a compensating transaction will
    be executed to restore the state to the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Facade pattern to expose the computation API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our computation engine contains a lot of classes that coordinate to implement
    the application logic. Any client who wants to interact with this implementation
    would prefer a simplified interface to this subsystem. A facade is an object that
    provides a simple interface to a large body of code in large classes or modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GoF facade pattern is a mechanism that we can use to expose a coarse-grained
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `ViewHandler` has become much simpler, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered quite a lot of ground in understanding why
    pattern-oriented software development is a good way to develop modern software.
    We started the chapter by citing some key principles. We progressed further to
    demonstrate the applicability of these key principles by iteratively skinning
    an application that is extensible and resilient to changes. Through this journey,
    we covered concepts such as the command pattern, factory method pattern, facade
    pattern, design by contract, template method pattern, XML configuration files,
    LINQ to XML, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our discussion of patterns by implementing
    a logging library, which can serialize contents into file, database, or remote
    network.
  prefs: []
  type: TYPE_NORMAL
