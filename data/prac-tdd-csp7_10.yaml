- en: Exploring Integrations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索集成
- en: In this chapter, we'll explore integration-testing the Speaker Meet application.
    The React front-end application will be tested and configured to hit the real
    back-end API, and the .NET application will be tested to ensure that it functions
    properly from controller to database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨集成测试Speaker Meet应用程序。我们将测试并配置React前端应用程序以击中真实的后端API，并测试.NET应用程序以确保它从控制器到数据库都能正常工作。
- en: 'In this chapter, we cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Implementing a real API service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个真实的API服务
- en: Removing mocked API calls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除模拟API调用
- en: End-to-end integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端集成
- en: Integration tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Implementing a real API service
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个真实的API服务
- en: The time has come to actually receive data from the server. Our current data
    model is still not 100% correct, but the groundwork is there. When we receive
    the correct data structure from the server, we will need to update our views accordingly.
    We will leave that part as an exercise for you.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正从服务器接收数据的时候了。我们当前的数据模型仍然不是100%正确，但基础工作已经完成。当我们从服务器接收到正确的数据结构时，我们需要相应地更新我们的视图。我们将把这个部分留给你作为练习。
- en: In this section, we will look at pulling our mocked API out of the factory that
    we created and replacing it with a real API. In our existing tests, we will use
    Sinon to override the default functionality of our Ajax component with the functionality
    from our mock API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看从我们创建的工厂中拉出模拟API，并用真实API替换它。在我们的现有测试中，我们将使用Sinon来覆盖我们的Ajax组件的默认功能，使用我们的模拟API的功能。
- en: Lastly, we will need to create an application configuration object to manage
    the base path for the API to determine the correct path in both dev and prod.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个应用程序配置对象来管理API的基本路径，以确定开发和生产中的正确路径。
- en: Replacing the mock API with the real API service
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用真实API服务替换模拟API
- en: 'To keep things as simple as possible, we will be using the fetch API to get
    data from the server. We will begin by breaking all the tests that are currently
    using the mock API. That is because we are going to create a stub class that implements
    the same interface as the mock API, but it will not be doing anything:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能保持简单，我们将使用fetch API从服务器获取数据。我们将首先中断所有目前使用模拟API的测试。这是因为我们将创建一个实现与模拟API相同接口的存根类，但它不会做任何事情：
- en: '`src/services/fetchSpeakerService.js`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/services/fetchSpeakerService.js`'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, replace the mock service that is created by the factory with the creation
    of the fetch based service:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用基于fetch的服务创建来替换工厂创建的模拟服务：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Thankfully, only four tests are failing because of that change. Looking at the
    failed tests, three of them are failing because we did not return a promise. One
    test, however, is failing because we are no longer returning the mock API. We
    are going to ignore the failing tests caused by missing promises by excluding
    them temporarily. Then, we will focus on test checking for a specific instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，只有四个测试因为这次更改而失败。查看失败的测试，其中三个失败是因为我们没有返回一个承诺。然而，有一个测试失败是因为我们不再返回模拟API。我们将忽略由缺少承诺引起的失败测试，暂时排除它们。然后，我们将专注于检查特定实例的测试。
- en: 'The test that is failing is in the service factory tests. We don''t actually
    want the service factory to return a `MockSpeakerService`. We want it to return
    a `FetchSpeakerService`. Even more accurately, we want any implementation of a
    `SpeakerService`. Let''s create a base class that will behave like an interface
    or abstract class from C#:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的测试是在服务工厂测试中。我们实际上不希望服务工厂返回一个`MockSpeakerService`。我们希望它返回一个`FetchSpeakerService`。更准确地说，我们希望返回任何`SpeakerService`的实现。让我们创建一个基类，它将表现得像C#中的接口或抽象类：
- en: '`/src/services/speakerService.js`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/services/speakerService.js`'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we have an abstract base class, we need to inherit from that base class
    in both our existing service classes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个抽象基类，我们需要在我们的现有服务类中继承这个基类：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And then we need to modify the factory tests to expect an instance of the base
    class instead of the derived class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要修改工厂测试，以期望基类的一个实例而不是派生类的一个实例：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using Sinon to mock Ajax responses
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sinon模拟Ajax响应
- en: Now, it is time to tackle the three tests that we have ignored. They are expecting
    actual responses from our service. Right now, our service is completely empty.
    Keep in mind, those tests were written to be unit tests and we need to protect
    them from the changes in the response that the real endpoint will experience over
    time. For that reason, we are going to, finally, introduce Sinon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候解决我们忽略的三个测试了。它们期望从我们的服务中获得实际响应。目前，我们的服务是完全空的。记住，那些测试是为了编写单元测试而编写的，我们需要保护它们免受真实端点随时间变化响应的影响。为此，我们最终将引入Sinon。
- en: We will use Sinon to return the results from our mock API instead of the real
    API. This will allow us to continue to use the work we have already put into the
    mock API.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Sinon从我们的模拟API返回结果，而不是使用真实API。这将允许我们继续使用我们已经投入模拟API的工作。
- en: After we have our existing tests covered, we are going to introduce integration
    tests by using Sinon to mock the back-end server. Using Sinon in that way will
    allow us to test-drive our fetch based speaker service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有现有的测试覆盖后，我们将通过使用Sinon模拟后端服务器来引入集成测试。以这种方式使用Sinon将允许我们测试驱动基于fetch的演讲者服务。
- en: Fixing existing tests
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复现有测试
- en: 'First things first; we must make our existing tests pass. In the `speakerActions.spec.js`
    file, find the first test that we skipped and remove the skip. This will cause
    that test to fail with:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须让现有的测试通过。在`speakerActions.spec.js`文件中，找到我们跳过的第一个测试，并移除跳过。这将导致该测试失败，原因如下：
- en: '`Cannot read property ''then'' of undefined`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`无法读取未定义的属性 ''then''`'
- en: 'Back in the `beforeEach` method, where we are creating the speaker service,
    we need to create a new Sinon stub for a service method. Looking at the test,
    we can see that the first service call we make is to get all speakers. So, let''s
    start there:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`beforeEach`方法，在那里我们创建演讲者服务，我们需要为服务方法创建一个新的Sinon模拟。查看测试，我们可以看到我们第一次服务调用是获取所有演讲者。所以，让我们从这里开始：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Looking at this code, what we have done is to create a new Sinon stub and redirect
    calls to the service `getAll` method to the `mockService getAll` method. Lastly,
    we bind the `mockService` call to the `mockService` to preserve access to private
    variables in the `mockService`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这段代码，我们所做的是创建一个新的Sinon模拟，并将对服务`getAll`方法的调用重定向到`mockService getAll`方法。最后，我们将`mockService`调用绑定到`mockService`以保留对私有变量的访问。
- en: 'Running the tests again, we get a new error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，我们得到一个新的错误：
- en: '`Attempted to wrap getAll which is already wrapped`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`尝试包装已包装的getAll`'
- en: 'What this error is telling us is that we have already created a stub for the
    method we are trying to stub. At first, this error may not make any sense. But,
    if you look we are doing this in a `beforeEach`. Sinon is a singleton and we are
    running our mocking commands inside a `beforeEach`, so it already has a `getAll`
    stub registered by the time the second test is preparing to run. What we must
    do is remove that registration before we try to register it again. Another way
    to say this is that we must remove the registration after each test run. Let’s
    add an `afterEach` method and remove the registration there:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，我们已经为我们要模拟的方法创建了一个模拟。起初，这个错误可能没有意义。但是，如果你看，我们在`beforeEach`中这样做。Sinon是一个单例，我们在`beforeEach`中运行我们的模拟命令，所以当第二个测试准备运行时，它已经注册了一个`getAll`模拟。我们必须做的是在我们再次注册之前移除该注册。另一种说法是，我们必须在每个测试运行后移除注册。让我们添加一个`afterEach`方法并在那里移除注册：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That fixes the first failing test that we had, now to fix the other two. The
    process will be largely the same, so let's get started.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这修复了我们遇到的第一个失败的测试，现在让我们修复其他两个。过程将大致相同，让我们开始。
- en: Remove the skip from the next test. The test fails. We are calling the `getSpeaker`
    action in this test and if we look at the speaker actions, we can see that it
    uses the `getById` service method. As before we will need to stub this method
    in the `beforeEach`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一个测试中移除跳过。测试失败。我们在这次测试中调用`getSpeaker`动作，如果我们查看演讲者动作，我们可以看到它使用了`getById`服务方法。和之前一样，我们将在`beforeEach`中模拟这个方法。
- en: '`getById = sinon.stub(service, "getById");`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`getById = sinon.stub(service, "getById");`'
- en: '`getById.callsFake(mockService.getById.bind(mockService));`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`getById.callsFake(mockService.getById.bind(mockService));`'
- en: 'As before, we are now getting the already wrapped message:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在正在获取已经包装的消息：
- en: '`Attempted to wrap getById which is already wrapped`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`尝试包装已包装的getById`'
- en: We can fix this one the same way we fixed the last one, by removing the stub
    in the `afterEach` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过与修复上一个错误相同的方式修复这个问题，即在`afterEach`函数中移除模拟。
- en: '`getById.restore();`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`getById.restore();`'
- en: 'We are back to all passing tests with one skipped. The last test is the exact
    same process. Here are the full `beforeEach` and `afterEach` functions when we
    are done:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在回到了所有通过测试，只有一个跳过的测试。最后一个测试是相同的过程。以下是当我们完成时完整的`beforeEach`和`afterEach`函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Don't forget to remove the skip from the last test. When all is said and done
    you should have 42 passing tests and 0 skipped tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从最后一个测试中移除跳过。当一切完成时，你应该有42个通过测试和0个跳过测试。
- en: Mocking the server
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟服务器
- en: Now that we have fixed our existing tests, we are ready to start writing tests
    for our real service, the `fetchSpeakerService`. Let's get started by looking
    at the test we used for our mock service. The tests will largely be the same as
    we are trying to achieve the same pattern of functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修复了现有的测试，我们准备好开始编写对真实服务`fetchSpeakerService`的测试。让我们从查看我们用于模拟服务的测试开始。测试将大致相同，因为我们试图实现相同的功能模式。
- en: 'First, we will want to create the test file `fetchSpeakerService.spec.js.`
    Once the file is created, we can add the standard existence test:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将想要创建测试文件`fetchSpeakerService.spec.js`。一旦文件创建完成，我们就可以添加标准的存在性测试：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because we stubbed out the fetch speaker service earlier, this test should just
    pass after we add the appropriate import.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前模拟了fetch演讲者服务，这个测试在添加适当的导入后应该直接通过。
- en: 'Following the mock speaker service tests, the next test is a construction and
    type verification test:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟演讲者服务测试之后，下一个测试是一个构造和类型验证测试：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This test, too, should pass right away, because when we stubbed the fetch service
    we created it as a class. Continuing to follow the progression of the mock service
    tests, we have an `After Initialization` section with a `Create` section inside
    it. The only test in the *Create* section is an exists test for the `Create` method.
    Writing this test, it should pass:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试也应该立即通过，因为我们模拟了fetch服务时，我们将其创建为一个类。继续跟随模拟服务测试的进展，我们有一个`After Initialization`部分，其中包含一个`Create`部分。*Create*部分中唯一的测试是对`Create`方法的`exists`测试。编写这个测试时，它应该通过：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because we are copying the flow from the mock service tests, we have already
    extracted the service to a `beforeEach` instantiation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在从模拟服务测试中复制流程，我们已经将服务提取到`beforeEach`实例化中。
- en: In the next section, our tests will start to get interesting and won't just
    pass right away. Before we move on, to verify that the tests are doing what they
    should be doing, it is a good idea to comment out parts of the fetch service and
    see the appropriate tests pass.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们的测试将开始变得有趣，而不会立即通过。在我们继续之前，为了验证测试是否正在执行它们应该执行的操作，注释掉fetch服务的一部分是一个好主意，以查看适当的测试是否通过。
- en: 'Moving on to the `Get All` section, still inside the `After Initialization`
    section, we have an existence test checking the `getAll method`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Get All`部分，仍然在`After Initialization`部分内，我们有一个检查`getAll方法`的存在性测试：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As with the other tests so far, to fail this test you will have to comment
    out the `getAll` method in the fetch service to see it fail. Immediately following
    this test are two more sections: `No Speakers Exist` and `Speaker Listing`. We
    will add them one at a time starting with `No Speakers Exist`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止的其他测试一样，要使这个测试失败，你将不得不在fetch服务中注释掉`getAll`方法以查看其失败。紧接着这个测试的是两个更多部分：`No
    Speakers Exist`和`Speaker Listing`。我们将逐个添加它们，从`No Speakers Exist`开始：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we have a failing test. The failure is complaining because it doesn''t
    look like we returned a promise. Let''s begin the proper implementation of the
    fetch service and we will use Sinon in the tests to mock the back-end. In the
    fetch service, add the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个失败的测试。失败的原因是它看起来我们没有返回一个promise。让我们开始正确实现fetch服务，并在测试中使用Sinon来模拟后端。在fetch服务中，添加以下内容：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a very basic fetch call. We are use the HTTP verb, `GET,` so there is
    no reason to call a method on fetch; by default it will use `GET`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的fetch调用。我们使用HTTP动词`GET`，所以没有必要在fetch上调用方法；默认情况下，它将使用`GET`。
- en: In our tests, we are now getting a meaningful result. `fetch is not defined`.
    This result is because fetch does not exist as part of our testing setup yet.
    We will need to import a new NPM package to handle fetch calls in testing. The
    package we want to import is `fetch-ponyfill`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们现在得到了一个有意义的结果。`fetch is not defined`。这个结果是因为fetch在我们的测试设置中还不存在。我们需要导入一个新的NPM包来处理测试中的fetch调用。我们想要导入的包是`fetch-ponyfill`。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After installing the `ponyfill` library, we must modify our test setup file
    `scripts/test.js`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`ponyfill`库之后，我们必须修改我们的测试设置文件`scripts/test.js`：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After those modifications, we must restart our tests for the changes to take
    effect. We are now getting a test failure telling us that only absolute URLs are
    supported. We are getting this message because when we instantiate our fetch service
    we aren''t passing a baseURL. For the tests it doesn''t matter what the URL is
    so let''s just use localhost:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些修改之后，我们必须重新启动我们的测试以使更改生效。我们现在得到了一个测试失败，告诉我们只支持绝对URL。我们得到这个消息是因为当我们实例化我们的fetch服务时，我们没有传递一个baseURL。对于测试来说，URL是什么并不重要，所以让我们就使用localhost：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After making this change we have moved the error forward and now we are getting
    a fetch error to the effect that localhost refused a connection. We are now ready
    to replace the back-end with Sinon.  We will start in the `beforeEach` and `afterEach`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个更改后，我们将错误向前移动，现在我们得到了一个fetch错误，表明localhost拒绝了一个连接。我们现在准备好用Sinon替换后端。我们将从`beforeEach`和`afterEach`开始：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the test, we will need some items from the `fetch-ponyfill` package so let's
    add the import statements while we are close to the top of the file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们需要`fetch-ponyfill`包中的某些项目，所以在我们接近文件顶部的时候，让我们添加导入语句。
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And now in the test, we need to configure the response from the server:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在测试中，我们需要配置来自服务器的响应：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That finishes the `No Speakers Exist` scenario. We will refactor the server
    response once we have a better idea about what data will be changing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了“无演讲者存在”的场景。一旦我们有了更好的数据变化想法，我们将重构服务器响应。
- en: We are now ready for the speaker listing scenario. As before, we start by copying
    the test from the mock service tests. Remove the arrange from the mock service
    test and copy the arrange from our previous test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好进行演讲者列表场景了。和之前一样，我们首先从模拟服务测试中复制测试。从模拟服务测试中移除arrange，并复制我们之前的测试中的arrange。
- en: 'After adding the arrange from the no speakers test, we get a message expecting
    a length of 1 instead of 0\. This is an easy fix and for the purposes of this
    test we can simply add an empty object to the body array of the response. Here
    is what the test should look like, once it is passing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了无演讲者测试的arrange之后，我们得到了一个期望长度为1而不是0的消息。这是一个简单的修复，为了这个测试的目的，我们可以在响应的主体数组中简单地添加一个空对象。以下是测试通过后应该看起来像的样子：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we are using basically the same arrange twice, it''s time to refactor
    our tests. The only thing that has really changed is the body. Let''s extract
    an `okResponse` function to use:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基本上两次使用了相同的arrange，是时候重构我们的测试了。唯一真正改变的是主体。让我们提取一个`okResponse`函数来使用：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have placed this helper function at the top of the `After Initialization`
    `describe`. Now in each test, replace the arrange with a call to the function,
    passing in the body that is specific to that test.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这个辅助函数放在了`After Initialization` `describe`的顶部。现在在每个测试中，用对这个函数的调用替换arrange，传递特定于该测试的主体。
- en: The get all speakers functionality is now covered by the tests. Let's move on
    to getting a specific speaker by ID. Copy the tests for `getById` from the mock
    service tests and apply a skip to the describes. Now, remove the skip from the
    outer-most describe. This should enable the existence test, which should pass.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有演讲者的获取功能都由测试覆盖了。让我们继续通过ID获取特定演讲者的测试。从模拟服务测试中复制`getById`的测试，并应用一个skip到describes。现在，从最外层的describe中移除skip。这应该启用存在测试，它应该通过。
- en: 'The next test is for when a speaker is not found; removing skip from that test
    results in a message indicating that we are not returning a promise. Let''s go
    into the body of the `getById` function and use fetch to get a speaker:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是当找不到演讲者时；从那个测试中移除skip会导致出现一个消息，表明我们没有返回一个promise。让我们进入`getById`函数的主体，并使用fetch获取一个演讲者：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Adding fetch to our function should have fixed the error but hasn''t. Remember
    we are mocking the response from fetch so if we don''t set a response then fetch
    won''t return anything at all. Let''s configure the mock response. In this case
    we are expecting a 404 from the server so let’s configure that response:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们的函数添加fetch应该已经修复了错误，但实际上并没有。记住，我们正在模拟fetch的响应，如果我们不设置响应，那么fetch将不会返回任何内容。让我们配置模拟响应。在这种情况下，我们期望服务器返回404错误，所以让我们配置这个响应：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That makes our test pass, but it''s not for the right reason. Let’s add a `then`
    clause to the assertion to prove the false positive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的测试就通过了，但这并不是正确的理由。让我们在断言中添加一个`then`子句来证明这是一个假阳性：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now our test will fail with expected `''Error not returned''` to equal `''SPEAKER_NOT_FOUND''`.
    Why is this? Shouldn''t a 404 cause a rejection of the promise? With fetch, the
    only thing that will cause a rejected promise is a network connection error. For
    that reason, we didn''t reject when we mocked the server response. What we need
    to do is check for that condition in the service and cause a promise rejection
    on that side. The easiest way to accomplish this is to wrap the fetch call with
    a promise of our own. Once wrapped, we can check for the appropriate condition
    and reject our promise:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试将失败，预期的`'Error not returned'`将等于`'SPEAKER_NOT_FOUND'`。为什么是这样？不应该是一个404导致promise的拒绝吗？对于fetch来说，唯一会导致promise拒绝的是网络连接错误。因此，当我们模拟服务器响应时我们没有拒绝。我们需要做的是在服务中检查那个条件，并在那一侧引起promise拒绝。最简单的方法是将fetch调用包裹在我们的自己的promise中。一旦包裹，我们就可以检查适当的条件并拒绝我们的promise：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That should do it for this test. We are now ready for our last test. Before
    we move on, let''s do a quick refactoring of the arrange in this test to shorten
    the test and have it make a bit more sense to future readers. While we are doing
    that, we will refactor the existing response function to reduce duplication and
    enforce some default values:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就完成了这个测试。我们现在准备进行最后一个测试。在我们继续之前，让我们快速重构这个测试中的arrange部分，以缩短测试并使其对未来的读者更有意义。当我们这样做的时候，我们将重构现有的响应函数以减少重复并强制执行一些默认值：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use the `notFoundResponse` function in the test just like we used the `okResponse`
    function. Moving on to our last test for the current functionality of the fetch
    service, remove the skip from the next describe and we will begin looking at the
    errors generated and make the necessary changes to make the test pass.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用`notFoundResponse`函数，就像我们使用`okResponse`函数一样。接下来，我们将进行当前获取服务功能的最后一个测试，移除下一个describe中的skip，我们将开始查看生成的错误并做出必要的更改以使测试通过。
- en: 'This last test is fairly simple after the work we have already done to make
    mock responses easier. We need the fetch call to return an `ok` response with
    the speaker as the body:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经做了让模拟响应更容易的工作之后，这个最后的测试相当简单。我们需要获取调用返回一个带有演讲者作为主体的`ok`响应：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we are getting a timeout error. That is because our service isn''t actually
    handling the case where the speaker exists. Let''s add that now:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遇到了超时错误。这是因为我们的服务实际上没有处理演讲者存在的情况。现在让我们添加这个功能：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now all our tests are passing and we have verified all the expected behavior
    of the system. There are a few more things we could do and some developers will
    choose to do them. We will discuss some of them but will not be providing examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的测试都通过了，我们已经验证了系统的所有预期行为。我们还可以做几件事情，一些开发者可能会选择去做。我们将讨论其中的一些，但不会提供示例。
- en: Application configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序配置
- en: Now that all the tests are passing there is still some application configuration
    that must be taken care of before the application can be used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有测试都通过了，但在应用程序可以使用之前，还有一些应用程序配置需要处理。
- en: In the service factory, we must set a base URL for the fetch service to use
    when the application is running. This can be done many different ways and which
    way exactly is up to you. The simplest but least flexible way is to just hard-code
    a string value as the base URL used to construct the service. However, you could
    get as fancy as having a dynamic class that sets the value based on the applications,
    running environment. Again this decision is left to you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务工厂中，我们必须为运行中的应用程序设置一个用于获取服务的基URL。这可以通过多种方式完成，具体方式由你决定。最简单但最不灵活的方式是将一个字符串值硬编码为构建服务的基URL。然而，你也可以让它变得非常复杂，比如有一个动态类，根据应用程序和运行环境来设置值。再次，这个决定留给你。
- en: End-to-end integration tests
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端集成测试
- en: The last subject we will discuss in this chapter is end-to-end integration tests.
    These tests involve actually calling the server and checking the real responses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后要讨论的主题是端到端集成测试。这些测试涉及实际调用服务器并检查真实响应。
- en: Benefits
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: So, what are the benefits from testing the actual client server connection?
    The most valuable benefit is that you know your application will work in the deployed
    environment. Sometimes an application will get deployed and not work because a
    network or database connection was incorrectly configured and that will wreak
    havoc on a deployment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，测试实际客户端服务器连接的好处是什么？最有价值的优势是，你知道你的应用程序将在部署环境中工作。有时应用程序会被部署但无法工作，因为网络或数据库连接配置不正确，这将对部署造成破坏。
- en: Additionally, this will help to verify the system is working properly. A series
    of smoke tests could be employed after a deployment to ensure the deployment was
    successful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这还将帮助验证系统是否正常工作。在部署后，可以执行一系列烟雾测试，以确保部署成功。
- en: Detriments
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损害
- en: E2E tests are usually skipped for one of two reasons. The first reason is that
    they are difficult to write. You have a lot of extra setup to get these tests
    to run, including a completely different test runner than what you normally use
    for unit testing. If not a different runner, they at least need to be a separate
    test run and not included in your normal unit tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通常由于以下两个原因之一而被跳过。第一个原因是它们很难编写。你需要进行很多额外的设置才能运行这些测试，包括一个与通常用于单元测试完全不同的测试运行器。如果不是不同的运行器，它们至少需要是单独的测试运行，而不是包含在你的正常单元测试中。
- en: The second issue is that E2E tests are fragile. Any change to the system and
    these tests break. They are not commonly run all the time like a unit test is
    and so the broken code will not be noticed until they are run in the production
    environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是端到端测试很脆弱。系统中的任何更改都会导致这些测试失败。它们不像单元测试那样经常运行，因此，直到它们在生产环境中运行时，才会注意到代码已损坏。
- en: For these reasons we generally do not write that many E2E tests, if any at all.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们通常不会编写很多端到端测试，如果不是一个都不写的话。
- en: How much end-to-end testing should you do?
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该进行多少端到端测试？
- en: If you choose to do end-to-end testing, you will want to do as little as possible.
    These are the top tier of tests and should be the least numerous type of test
    in your system. A recommendation is to only write as many tests as you have third-party
    connections to your application, that is, one test for each back-end server that
    you must communicate with. Additionally, use the simplest and most basic case
    which is not anticipated to change.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择进行端到端测试，你希望尽可能少做。这些是最高级别的测试，应该是你系统中数量最少的测试类型。建议只编写与你的应用程序第三方连接一样多的测试，也就是说，每个你必须与之通信的后端服务器一个测试。此外，使用最简单、最基本的情况，这种情况下预计不会发生变化。
- en: That completes integration testing from the front-end. There are still some
    things that can be done. We will leave them as an exercise for you. You might
    have noticed that the front-end and back-end are not fully in agreement for the
    model that is being passed back and forth. As an exercise, add or remove and refine
    the model that is being used by both systems so that they agree on the format.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了前端集成测试。还有一些事情可以做。我们将把它们留给你作为练习。你可能已经注意到，前端和后端在传递回和 forth 的模型上并不完全一致。作为练习，添加或删除并完善两个系统都使用的模型，以便它们在格式上达成一致。
- en: Another task would be to set the base URL for the fetch service and run both
    applications locally to verify interconnectability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个任务是设置获取服务的基 URL 并在本地运行两个应用程序以验证互操作性。
- en: Configuring the API project
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 API 项目
- en: With the React project now configured to hit the real API, it's time to turn
    our attention to the .NET solution. In order to verify that everything is wired
    up correctly, you'll want to write a series of integration tests to ensure that
    the whole system is working properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 React 项目已配置为调用真实 API，是时候将我们的注意力转向 .NET 解决方案了。为了验证一切是否正确连接，你需要编写一系列集成测试，以确保整个系统正常工作。
- en: Integration test project
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试项目
- en: Create a new xUnit Project called `SpeakerMeet.Api.IntegrationTest` within the
    existing solution. This will be where the .NET integration tests will be created.
    You may want to explore separating these out according to your preferences and/or
    team coding standards, but that can wait. For now, a single integration test project
    will do.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有解决方案中创建一个新的 xUnit 项目，名为 `SpeakerMeet.Api.IntegrationTest`。这将是在其中创建 .NET 集成测试的地方。你可能希望根据你的偏好和/或团队编码标准将它们分离出来，但这可以稍后再说。现在，一个单独的集成测试项目就足够了。
- en: For our purposes, we'll be testing whether the system functions from API entry
    all the way to the database, and back. However, it's best to start small test
    individual integration points, and grow from there.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将测试系统是否从 API 入口到数据库，然后再返回的功能。然而，最好从小测试单个集成点开始，然后逐步扩展。
- en: Where to begin?
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从哪里开始？
- en: You could certainly start by creating a test that will call an API endpoint.
    In order to achieve this, an HTTP Request will need to be made to a controller.
    The controller will then call into a service within the business layer, which
    in turn will make a call to the repository, and finally a command is sent to the
    database. That feels like a lot of moving parts. Perhaps there's a better place
    to start.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以从创建一个调用API端点的测试开始。为了实现这一点，需要向控制器发出一个HTTP请求。然后控制器将调用业务层中的服务，该服务随后将调用仓库，最终向数据库发送命令。这感觉有很多移动部件。也许有一个更好的起点。
- en: In order to break down the problem into smaller, more manageable pieces, perhaps
    it's best to start testing closer to the persistence layer of the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将问题分解成更小、更易于管理的部分，也许从测试应用程序的持久层开始测试是最好的。
- en: Verifying the repository calls into the DB context
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证仓库是否调用DB上下文
- en: A good place to start is verifying that the system is fully integrated; let's
    first test that the repository can access the database. Create a folder within
    the integration test project called `RepositoryTests` and create a new test file
    called `GetAll`. This will be where the integration tests for the `GetAll` method
    of the repository will be created.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的开始是验证系统是否完全集成；让我们首先测试仓库是否可以访问数据库。在集成测试项目中创建一个名为`RepositoryTests`的文件夹，并创建一个名为`GetAll`的新测试文件。这里将创建仓库`GetAll`方法的集成测试。
- en: 'You could create a test that verifies that the repository can be created, like
    so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个测试来验证仓库可以被创建，如下所示：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, that''s not going to pass. If you run the test you will receive the
    following error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不能通过。如果你运行测试，你将收到以下错误：
- en: '`System.InvalidOperationException: No database provider has been configured
    for this DbContext`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.InvalidOperationException: No database provider has been configured
    for this DbContext`。'
- en: This is easily fixed by configuring an appropriate provider.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易解决，只需配置一个合适的提供程序。
- en: InMemory database
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Running tests against a SQL Server is time-consuming, error-prone, and potentially
    costly. Establishing a connection to a database takes time, and remember, you
    want your test suite to be lightning-fast. It might also be a problem to rely
    on data if the database is used by others, whether in a development environment,
    by quality assurance engineers, and so on. You certainly wouldn't want to run
    your integration tests against a production database. Additionally, running tests
    against a database hosted in the cloud (for example, AWS, Azure, and so on) could
    potentially incur a dollar cost in terms of bandwidth and processing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对SQL Server进行测试既耗时又容易出错，可能还相当昂贵。建立数据库连接需要时间，记住，你希望你的测试套件能够快速运行。如果数据库被其他人使用，无论是开发环境中的，还是质量保证工程师等，这也可能是一个问题。你当然不希望对你的生产数据库运行集成测试。此外，对托管在云中的数据库（例如AWS、Azure等）进行测试可能会在带宽和处理方面产生成本。
- en: Luckily, it's quite trivial to configure a solution that uses Entity Framework
    to use an `InMemory` database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，配置一个使用Entity Framework的解决方案以使用`InMemory`数据库相当简单。
- en: First, install a `NuGet` package for the `InMemory` database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装一个用于`InMemory`数据库的`NuGet`包。
- en: '`Microsoft.EntityFrameworkCore.InMemory`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.InMemory`'
- en: 'Now, modify the test you created before so that the database context is created
    `InMemory`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改你之前创建的测试，以便在内存中创建数据库上下文：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The test should now pass because the context is now being created `InMemory`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在应该通过，因为上下文现在是在内存中创建的。
- en: 'Next, create a test to verify that a collection of Speaker entities is returned
    when the `GetAll` method is called:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个测试来验证当调用`GetAll`方法时，会返回一个演讲者实体集合：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, turn your attention to the `Get` method in the repository. Create a new
    test method to verify that a null Speaker entity is returned when a speaker with
    the given ID is not found:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将注意力转向仓库中的`Get`方法。创建一个新的测试方法来验证当找不到具有给定ID的演讲者时，会返回一个null的演讲者实体：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This should pass right away. Now, create a test to verify that a Speaker entity
    is returned when a speaker with the supplied ID exists:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该立即通过。现在，创建一个测试来验证当存在具有提供的ID的演讲者时，会返回一个演讲者实体：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This test will not pass quite yet. Regardless of whether or not a Speaker with
    the ID of 1 exists in your development database, the speakers table in the `InMemory`
    database is currently empty. Adding data to the `InMemory` database is quite simple.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试现在还不能通过。无论ID为1的演讲者是否存在于您的开发数据库中，`InMemory`数据库中的演讲者表目前是空的。向`InMemory`数据库添加数据非常简单。
- en: Adding speakers to the InMemory database
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向`InMemory`数据库添加演讲者
- en: 'In order to test that the repository will return specific Speaker entities
    when querying the database, you first must add Speakers to the database. In order
    to do this, add a few lines of code to your test file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试仓库在查询数据库时是否会返回特定的`Speaker`实体，您首先必须将`Speaker`添加到数据库中。为了做到这一点，在您的测试文件中添加几行代码：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Feel free to add as many speakers as you want, with as much detail as you feel
    necessary. Your test should now pass. More tests can be created, and should continue
    to be added as the system grows in functionality and complexity. The bulk of the
    logic should be tested already in the unit tests, but verifying that the system
    functions as a whole is equally important.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加尽可能多的演讲者，以及您认为必要的尽可能多的细节。现在，您的测试应该可以通过。可以创建更多测试，并且随着系统的功能复杂度增长，应该继续添加测试。大部分的逻辑应该在单元测试中已经测试过了，但验证整个系统是否正常工作同样重要。
- en: Verify that the service calls the DB through the repository
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证服务是否通过仓库调用数据库
- en: Moving on to the business layer, you should verify that each service can retrieve
    data from the `InMemory` database through the repository.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转向业务层，您应该验证每个服务是否可以通过仓库从`InMemory`数据库中检索数据。
- en: First, create a new folder in the integration test project called `ServiceTests.`
    Within that folder, create a folder named `SpeakerServiceTests`. This folder is
    where the tests specific to the `SpeakerService` will be created.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在集成测试项目中创建一个名为`ServiceTests`的新文件夹。在该文件夹中，创建一个名为`SpeakerServiceTests`的文件夹。这个文件夹是创建针对`SpeakerService`的特定测试的地方。
- en: 'Create a new test file named `GetAll`. Add a test method to verify that the
    service can be created:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`GetAll`的新测试文件。添加一个测试方法来验证服务是否可以创建：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ContextFixture
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ContextFixture
- en: There's a lot of setup code here and quite a bit of duplication from our previous
    tests. Luckily, you can use what's known as a *Test Fixture*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多设置代码，以及从前面的测试中复制的大量代码。幸运的是，您可以使用所谓的*测试固定装置*。
- en: A Test Fixture is simply some code that is run to configure the system under
    test. For our purposes, create a *ContextFixture* to set up an `InMemory` database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试固定装置只是一些用于配置待测系统的代码。在我们的情况下，创建一个*上下文固定装置*来设置`InMemory`数据库。
- en: 'Create a new class named `ContextFixture`, which is where all the `InMemory`
    database creation will happen:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ContextFixture`的新类，其中将发生所有`InMemory`数据库的创建：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, modify the test class to use the new `ContextFixture` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改测试类以使用新的`ContextFixture`类：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That''s quite a bit cleaner. Now, create a new test to ensure a collection
    of `SpeakerSummary` objects is returned when the `GetAll` method of the `SpeakerService`
    is called:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这要干净得多。现在，创建一个新的测试来确保当调用`SpeakerService`的`GetAll`方法时，会返回一个`SpeakerSummary`对象的集合：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, create a new test class for the `Get` method of the `SpeakerService`.
    The first test should validate that an exception is thrown when a speaker does
    not exist with the supplied ID:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为`SpeakerService`的`Get`方法创建一个新的测试类。第一个测试应该验证当提供的ID不存在时，会抛出异常：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can reuse the `ContextFixture` that you created earlier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重用之前创建的`ContextFixture`：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Verify the API calls into the service
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证对服务的API调用
- en: Now, turn your attention to the web API controllers. As covered in a previous
    chapter, you could simply create a new instance of the controller and call the
    method under test. However, that would not exercise the entire system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将您的注意力转向Web API控制器。如前一章所述，您可以简单地创建一个控制器的新实例并调用测试中的方法。然而，那样并不能测试整个系统。
- en: It would be far better to call the method with an HTTP request. Deploying to
    a web server would be prohibitively time-consuming.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 用HTTP请求调用方法会更好。部署到Web服务器会非常耗时。
- en: TestServer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestServer
- en: 'ASP.NET Core has the ability to configure a host for testing purposes. Install
    the `TestServer` from `NuGet`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core有配置测试目的主机的能力。从`NuGet`安装`TestServer`：
- en: '`Microsoft.AspNetCore.TestHost`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.TestHost`'
- en: There's a little setup involved. First, you’ll add an instance of the `TestServer`.
    Create a new `WebHostBuilder` and use the existing `Startup` class of the web
    API project. This will wire up the Dependency Injection container that was set
    up previously. Now, configure the services to set up a new `InMemory` database.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些设置工作。首先，你将添加一个`TestServer`的实例。创建一个新的`WebHostBuilder`并使用Web API项目的现有`Startup`类。这将连接之前设置的依赖注入容器。现在，配置服务以设置一个新的`InMemory`数据库。
- en: 'Take a look at the test here to see the setup required:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这里的测试以了解所需的设置：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ServerFixture
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServerFixture
- en: 'In order to move the setup out of the controller tests, again use a test fixture.
    This time, create a new class named `ServerFixture`. This will be where the setup
    will live for the controller tests:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将设置从控制器测试中移除，再次使用测试固定装置。这次，创建一个名为`ServerFixture`的新类。这将是在控制器测试中设置的地方：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, return to the previous test. Modify the test class to use the `ServerFixture`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到之前的测试。修改测试类以使用`ServerFixture`：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, verify that the response returns an `OK` status code by creating a new
    test:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过创建一个新的测试来验证响应返回了一个`OK`状态码：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And finally, ensure that the proper speaker is returned:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保返回了正确的演讲者：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Remember, you want to make sure your test suite is clean and well maintained.
    To clean this test up a bit, you might want to consider creating a `ReadAsJsonAsync`
    extension. Here''s what that might look like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你想要确保你的测试套件干净且维护良好。为了稍微清理这个测试，你可能想要考虑创建一个`ReadAsJsonAsync`扩展。这可能看起来是这样的：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And now, modify the test to use the new extension method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改测试以使用新的扩展方法：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That's much better. Now this extension can be used and reused over and over,
    and its first use has now been documented in the `ItShouldReturnSpeakers` test.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就更好了。现在这个扩展可以被反复使用，并且它的第一次使用已经在`ItShouldReturnSpeakers`测试中进行了文档记录。
- en: 'Now, move on to testing that the single speaker endpoint can be called. Create
    a test named `ItShouldCallGetSpeaker` and ensure that a response is returned:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续测试单个演讲者端点是否可以被调用。创建一个名为`ItShouldCallGetSpeaker`的测试，并确保返回了一个响应：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, test that the proper response code is returned if a Speaker with the given
    ID does not exist:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试如果给定的ID不存在，是否返回了正确的响应码：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now validate that an `OK` status code is returned when a speaker with the supplied
    ID exists:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证当提供的ID存在时，返回了一个`OK`状态码：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And finally, confirm that the speaker returned is the one that is expected.
    Note that the `ReadAsJsonAsync` can be used here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确认返回的演讲者正是预期的那个。注意，这里可以使用`ReadAsJsonAsync`：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Only the `Get` and `GetAll` methods for speakers have been tested in the preceding
    pages. Feel free to add tests for the `Search` methods to grow your integration
    test suite.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，只有演讲者的`Get`和`GetAll`方法被测试过。你可以自由地添加对`Search`方法的测试，以扩展你的集成测试套件。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a firm grasp of integration testing, its benefits, and detriments.
    The mock API calls have been removed and the real API service has been implemented.
    Integration tests have been created and now ensure separate parts of the application
    are working well together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对集成测试、其优势和劣势有了牢固的理解。模拟API调用已被移除，并实现了真实的API服务。已经创建了集成测试，并确保应用程序的各个部分能够良好地协同工作。
- en: Change is inevitable, especially in software development. In the next chapter,
    we'll be discussing how to handle a change in requirements. Whether these changes
    include new features, resolve defects, or change existing logic, through TDD these
    can be easily managed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 变化是不可避免的，尤其是在软件开发中。在下一章中，我们将讨论如何处理需求的变化。这些变化可能包括新功能、修复缺陷或更改现有逻辑，通过TDD这些都可以轻松管理。
