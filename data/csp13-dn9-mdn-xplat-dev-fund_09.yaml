- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Working with Files, Streams, and Serialization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件、流和序列化
- en: This chapter is about reading and writing to files and streams, text encoding,
    and serialization. Applications that do not interact with a filesystem are extraordinarily
    rare. As a .NET developer, almost every application that you build will need to
    manage the filesystem and create, open, read, and write to and from files. Most
    of those files will contain text, so it is important to understand how text is
    encoded. And finally, after working with objects in memory, you will need to store
    them somewhere permanently for later reuse. You do that using a technique called
    serialization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍文件和流的读写操作、文本编码以及序列化。不与文件系统交互的应用程序非常罕见。作为一名.NET开发者，你构建的几乎每个应用程序都需要管理文件系统，并创建、打开、读取和写入文件。大多数这些文件将包含文本，因此了解文本的编码方式非常重要。最后，在内存中处理对象之后，你还需要将它们永久存储起来以供以后重用。你可以使用一种称为序列化的技术来完成这项工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Managing a filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理文件系统
- en: Reading and writing with streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流进行读写操作
- en: Encoding and decoding text
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编码和解码
- en: Serializing object graphs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化对象图
- en: Managing a filesystem
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件系统
- en: Your applications will often need to perform input and output operations with
    files and directories in different environments. The `System` and `System.IO`
    namespaces contain classes for this purpose.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序通常需要在不同的环境中对文件和目录执行输入和输出操作。`System` 和 `System.IO` 命名空间包含用于此目的的类。
- en: Handling cross-platform environments and filesystems
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理跨平台环境和文件系统
- en: 'Let’s explore how to handle cross-platform environments and the differences
    between Windows, Linux, and macOS. Paths are different for Windows, macOS, and
    Linux, so we will start by exploring how .NET handles this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何处理跨平台环境以及 Windows、Linux 和 macOS 之间的差异。Windows、macOS 和 Linux 的路径不同，因此我们将首先探讨
    .NET 如何处理这个问题：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `WorkingWithFileSystems`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithFileSystems`
- en: 'Solution file and folder: `Chapter09`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter09`
- en: 'In the project file, add a package reference for `Spectre.Console`, and then
    add elements to import the following classes statically and globally, `System.Console`,
    `System.IO.Directory`, `System.IO.Path`, and `System.Environment`, as shown in
    the following markup:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加对 `Spectre.Console` 的包引用，然后添加元素以静态和全局方式导入以下类：`System.Console`、`System.IO.Directory`、`System.IO.Path`
    和 `System.Environment`，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build the `WorkingWithFileSystems` project to restore packages.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建用于恢复包的 `WorkingWithFileSystems` 项目。
- en: Add a new class file named `Program.Helpers.cs`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with a `SectionTitle`
    method, as shown in the following code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，添加一个部分 `Program` 类，包含一个 `SectionTitle` 方法，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `Program.cs`, add statements to use a `Spectre.Console` table to do the
    following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句以使用 `Spectre.Console` 表格执行以下操作：
- en: Output the path and directory separation characters.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出路径和目录分隔符。
- en: Output the path of the current directory.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出当前目录的路径。
- en: 'Output some special paths for system files, temporary files, and documents:'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出系统文件、临时文件和文档的一些特殊路径：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Environment` type has many other useful members that we did not use in
    this code, including the `OSVersion` and `ProcessorCount` properties.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Environment` 类型还有许多其他有用的成员，我们在这段代码中没有使用，包括 `OSVersion` 和 `ProcessorCount`
    属性。'
- en: 'Run the code and view the result, as shown using Visual Studio on Windows in
    *Figure 9.1*:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如图 9.1 所示，使用 Windows 上的 Visual Studio：
- en: '![](img/B22322_09_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_09_01.png)'
- en: 'Figure 9.1: Showing filesystem information with Visual Studio on Windows'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：使用 Windows 上的 Visual Studio 显示文件系统信息
- en: '**More Information**: You can learn more about using `Spectre Console` tables
    at the following link: [https://spectreconsole.net/widgets/table](https://spectreconsole.net/widgets/table).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于使用 `Spectre Console` 表格的信息：[https://spectreconsole.net/widgets/table](https://spectreconsole.net/widgets/table)。'
- en: 'When running the console app using `dotnet run` on a Mac, the path and directory
    separator characters are different, and the `CurrentDirectory` will be the project
    folder, not a folder inside `bin`, as shown in *Figure 9.2*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Mac上使用`dotnet run`运行控制台应用程序时，路径和目录分隔符字符不同，`CurrentDirectory`将是项目文件夹，而不是`bin`文件夹内的文件夹，如*图9.2*所示：
- en: '![](img/B22322_09_02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_09_02.png)'
- en: 'Figure 9.2: Showing filesystem information with the CLI on macOS'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：在macOS上使用CLI显示文件系统信息
- en: '**Good Practice**: Windows uses a backslash (`\`) for the directory separator
    character. macOS and Linux use a forward slash (`/`) for the directory separator
    character. Do not assume which character is used in your code when combining paths;
    use `Path.DirectorySeparatorChar`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：Windows使用反斜杠（`\`）作为目录分隔符字符。macOS和Linux使用正斜杠（`/`）作为目录分隔符字符。在组合路径时，不要假设使用哪个字符，请使用`Path.DirectorySeparatorChar`。'
- en: In future sections of this chapter, we will create directories and files in
    the `Personal` special folder, so make a note of where that is for your operating
    system. For example, if you’re using Linux, it should be `$USER/Documents`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将在`Personal`特殊文件夹中创建目录和文件，因此请记下在您的操作系统中的位置。例如，如果您使用Linux，它应该是`$USER/Documents`。
- en: Managing drives
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理驱动器
- en: To manage drives, use the `DriveInfo` type, which has a static method that returns
    information about all the drives connected to your computer. Each drive has a
    drive type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理驱动器，请使用`DriveInfo`类型，它有一个静态方法，可以返回连接到您的计算机的所有驱动器的信息。每个驱动器都有一个驱动器类型。
- en: 'Let’s explore drives:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索驱动器：
- en: 'In `Program.cs`, write statements to get all the drives and output their name,
    type, size, available free space, and format, but only if the drive is ready,
    as shown in the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中编写语句以获取所有驱动器并输出它们的名称、类型、大小、可用空间和格式，但仅当驱动器已准备好时，如下代码所示：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Good Practice**: Check that a drive is ready before reading properties such
    as `TotalSize`, or you will see an exception thrown with removable drives.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在读取`TotalSize`等属性之前，请检查驱动器是否已准备好，否则您将看到在可移动驱动器上抛出的异常。'
- en: 'On Linux, by default, your console app will only have permission to read the
    `Name` and `DriveType` properties when run as a normal user. An `UnauthorizedAccessException`
    is thrown for `DriveFormat`, `TotalSize`, and `AvailableFreeSpace`. Run the console
    app as a superuser to avoid this issue, as shown in the following command: `sudo
    dotnet run`. Using `sudo` is fine in a development environment, but in a production
    environment, it’s recommended to edit your permissions to avoid running with elevated
    permissions. On Linux, the name and drive format columns might also need to be
    wider, for example, 55 and 12 characters wide, respectively.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，默认情况下，当以普通用户身份运行时，您的控制台应用程序只能读取`Name`和`DriveType`属性。对于`DriveFormat`、`TotalSize`和`AvailableFreeSpace`将抛出`UnauthorizedAccessException`。以超级用户身份运行控制台应用程序以避免此问题，如下命令所示：`sudo
    dotnet run`。在开发环境中使用`sudo`是可以的，但在生产环境中，建议编辑您的权限以避免以提升权限运行。在Linux上，名称和驱动器格式列可能也需要更宽，例如，分别为55和12个字符宽。
- en: 'Run the code and view the result, as shown in *Figure 9.3*:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如*图9.3*所示：
- en: '![](img/B22322_09_03.png)Figure 9.3: Showing drive information on Windows and
    macOS'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B22322_09_03.png)图9.3：在Windows和macOS上显示驱动器信息'
- en: Managing directories
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理目录
- en: To manage directories, use the `Directory`, `Path`, and `Environment` static
    classes. These types include many members to work with the filesystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理目录，请使用`Directory`、`Path`和`Environment`静态类。这些类型包括许多用于与文件系统交互的成员。
- en: 'When constructing custom paths, you must be careful to write your code so that
    it makes no assumptions about the platform, for example, what to use for the directory
    separator character:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建自定义路径时，您必须小心编写代码，以确保它不针对平台做出假设，例如，使用什么作为目录分隔符字符：
- en: 'In `Program.cs`, write statements to do the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中编写语句以执行以下操作：
- en: Define a custom path under the user’s home directory by creating an array of
    strings for the directory names, and then properly combine them with the `Path`
    type’s `Combine` method.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户主目录下通过创建一个包含目录名称的字符串数组来定义一个自定义路径，然后使用`Path`类型的`Combine`方法正确地组合它们。
- en: Check for the existence of the custom directory path using the `Exists` method
    of the `Directory` class.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Directory`类的`Exists`方法检查自定义目录路径是否存在。
- en: 'Create and then delete the directory, including the files and subdirectories
    within it, using the `CreateDirectory` and `Delete` methods of the `Directory`
    class:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Directory`类的`CreateDirectory`和`Delete`方法创建然后删除目录，包括其内的文件和子目录：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In .NET 6 and earlier, only the `Directory` class had an `Exists` method. In
    .NET 7 or later, the `Path` class also has an `Exists` method. Both can be used
    to check for the existence of a path.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在.NET 6及之前版本中，只有`Directory`类有`Exists`方法。在.NET 7或更高版本中，`Path`类也有`Exists`方法。两者都可以用来检查路径是否存在。
- en: 'Run the code, view the result, and use your favorite file management tool to
    confirm that the directory has been created before pressing *Enter* to delete
    it, as shown in the following output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并使用你喜欢的文件管理工具确认在按下*Enter*键删除之前已创建目录，如下所示输出：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Managing files
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理文件
- en: 'When working with files, you can statically import the file type, just as we
    did for the directory type. However, for the next example, we will not do so because
    it has some of the same methods as the directory type, and they would conflict.
    The file type has a short enough name not to matter in this case. The steps are
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理文件时，你可以静态导入文件类型，就像我们为目录类型所做的那样。然而，对于下一个示例，我们不会这样做，因为它有一些与目录类型相同的方法，它们可能会冲突。文件类型有足够短的名字，在这种情况下不会造成影响。步骤如下：
- en: 'In `Program.cs`, write statements to do the following:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中编写以下语句：
- en: Check for the existence of a file.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件是否存在。
- en: Create a text file.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。
- en: Write a line of text to the file.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件中写入一行文本。
- en: Close the file to release system resources and file locks (this would normally
    be done inside a `try`-`finally` statement block to ensure that the file is closed,
    even if an exception occurs when writing to it).
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件以释放系统资源和解锁文件（这通常在`try`-`finally`语句块内完成，以确保即使在写入时发生异常，文件也能被关闭）。
- en: Copy the file to a backup.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件复制到备份中。
- en: Delete the original file.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始文件。
- en: 'Read the backup file’s contents and then close it:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取备份文件的 内容然后关闭它：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Managing paths
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理路径
- en: 'Sometimes, you need to work with parts of a path; for example, you might want
    to extract just the folder name, the filename, or the extension. Sometimes, you
    need to generate temporary folders and filenames. You can do this with static
    methods of the `Path` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要处理路径的一部分；例如，你可能只想提取文件夹名、文件名或扩展名。有时，你需要生成临时文件夹和文件名。你可以使用`Path`类的静态方法来完成这些操作：
- en: 'In `Program.cs`, add the following statements:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加以下语句：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`GetTempFileName` creates a zero-byte file and returns its name, ready for
    you to use. `GetRandomFileName` just returns a filename; it doesn’t create the
    file.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTempFileName`创建一个零字节的文件并返回其名称，供你使用。`GetRandomFileName`仅返回一个文件名；它不会创建文件。'
- en: Getting file information
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文件信息
- en: To get more information about a file or directory, for example, its size or
    when it was last accessed, you can create an instance of the `FileInfo` or `DirectoryInfo`
    class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关文件或目录的更多信息，例如大小或最后访问时间，你可以创建`FileInfo`或`DirectoryInfo`类的实例。
- en: '`FileInfo` and `DirectoryInfo` both inherit from `FileSystemInfo`, so they
    both have members such as `LastAccessTime` and `Delete`, as well as extra members
    specific to themselves, as shown in *Table 9.1*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileInfo`和`DirectoryInfo`都继承自`FileSystemInfo`，因此它们都有`LastAccessTime`和`Delete`等成员，以及一些特定于自身的额外成员，如*表9.1*所示：'
- en: '| **Class** | **Members** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **成员** |'
- en: '| `FileSystemInfo` | Fields: `FullPath` and `OriginalPath`Properties: `Attributes`,
    `CreationTime`, `CreationTimeUtc`, `Exists`, `Extension`, `FullName`, `LastAccessTime`,
    `LastAccessTimeUtc`, `LastWriteTime`, `LastWriteTimeUtc`, and `Name`Methods: `Delete`,
    `GetObjectData`, and `Refresh` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `FileSystemInfo` | 字段：`FullPath`和`OriginalPath`属性：`Attributes`、`CreationTime`、`CreationTimeUtc`、`Exists`、`Extension`、`FullName`、`LastAccessTime`、`LastAccessTimeUtc`、`LastWriteTime`、`LastWriteTimeUtc`和`Name`方法：`Delete`、`GetObjectData`和`Refresh`
    |'
- en: '| `DirectoryInfo` | Properties: `Parent` and `Root`Methods: `Create`, `CreateSubdirectory`,
    `EnumerateDirectories`, `EnumerateFiles`, `EnumerateFileSystemInfos`, `GetAccessControl`,
    `GetDirectories`, `GetFiles`, `GetFileSystemInfos`, `MoveTo`, and `SetAccessControl`
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo` | 属性：`Parent`和`Root`方法：`Create`、`CreateSubdirectory`、`EnumerateDirectories`、`EnumerateFiles`、`EnumerateFileSystemInfos`、`GetAccessControl`、`GetDirectories`、`GetFiles`、`GetFileSystemInfos`、`MoveTo`和`SetAccessControl`
    |'
- en: '| `FileInfo` | Properties: `Directory`, `DirectoryName`, `IsReadOnly`, and
    `Length`Methods: `AppendText`, `CopyTo`, `Create`, `CreateText`, `Decrypt`, `Encrypt`,
    `GetAccessControl`, `MoveTo`, `Open`, `OpenRead`, `OpenText`, `OpenWrite`, `Replace`,
    and `SetAccessControl` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `FileInfo` | 属性：`Directory`, `DirectoryName`, `IsReadOnly`, 和 `Length` 方法：`AppendText`,
    `CopyTo`, `Create`, `CreateText`, `Decrypt`, `Encrypt`, `GetAccessControl`, `MoveTo`,
    `Open`, `OpenRead`, `OpenText`, `OpenWrite`, `Replace`, 和 `SetAccessControl` |'
- en: 'Table 9.1: Classes to get information about files and directories'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：获取文件和目录信息的类
- en: 'Let’s write some code that uses a `FileInfo` instance to efficiently perform
    multiple actions on a file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些使用`FileInfo`实例来高效地对文件执行多个操作的代码：
- en: 'In `Program.cs`, add statements to create an instance of `FileInfo` for the
    backup file, and write information about it to the console, as shown in the following
    code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以创建备份文件的`FileInfo`实例，并将其信息写入控制台，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The number of bytes might be different on your operating system because operating
    systems can use different line endings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的操作系统上，字节数可能不同，因为操作系统可以使用不同的行结束符。
- en: Controlling how you work with files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制如何处理文件
- en: When working with files, you often need to control how they are opened. The
    `File.Open` method has overloads to specify additional options using `enum` values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理文件时，您通常需要控制它们的打开方式。`File.Open`方法有重载，可以使用`enum`值指定附加选项。
- en: 'The `enum` types are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型如下：'
- en: '`FileMode`: This controls what you want to do with a file, like `CreateNew`,
    `OpenOrCreate`, or `Truncate`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileMode`：这控制了您想要对文件执行的操作，如`CreateNew`、`OpenOrCreate`或`Truncate`。'
- en: '`FileAccess`: This controls what level of access you need, like `ReadWrite`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileAccess`：这控制您需要的访问级别，如`ReadWrite`。'
- en: '`FileShare`: This controls locks on a file to allow other processes the specified
    level of access, like `Read`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileShare`：这控制对文件的锁定，以允许其他进程以指定的级别访问，如`Read`。'
- en: 'You might want to open a file and read from it, allowing other processes to
    read it too, as shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要打开一个文件并从中读取，同时允许其他进程读取它，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is also an `enum` for attributes of a file, `FileAttributes`, that checks
    a `FileSystemInfo`-derived type’s `Attributes` property for values like `Archive`
    and `Encrypted`. For example, you could check a file or directory’s attributes,
    as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样还有一个`enum`用于文件的属性，`FileAttributes`，它会检查`FileSystemInfo`派生类型的`Attributes`属性，以获取如`Archive`和`Encrypted`之类的值。例如，您可以检查文件或目录的属性，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All the methods of the `File` class that manage a file have a parameter to
    specify the path to the file as a `string` value. Additional parameters of the
    `File` class, its methods, and what the methods return are shown in *Table 9.2*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类中管理文件的所有方法都有一个参数，用于指定文件路径作为`string`值。`File`类、其方法和它们的返回值的附加参数如下所示*表9.2*：'
- en: '| **Method** | **Special parameters** | **Returns** | **Notes** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **特殊参数** | **返回值** | **说明** |'
- en: '| `Open` | `FileMode`, `FileAccess`, `FileShare` | `FileStream` | Byte-level
    access to a file. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Open` | `FileMode`, `FileAccess`, `FileShare` | `FileStream` | 以字节级别访问文件。
    |'
- en: '| `OpenWrite` |  | `FileStream` | Overwrites from the start but does not truncate.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `OpenWrite` |  | `FileStream` | 从开始覆盖但不截断。 |'
- en: '| `Create` | `FileOptions` | `FileStream` | Overwrites and truncates. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Create` | `FileOptions` | `FileStream` | 覆盖并截断。 |'
- en: '| `OpenText` |  | `StreamReader` | For reading a text file. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `OpenText` |  | `StreamReader` | 用于读取文本文件。 |'
- en: '| `CreateText` |  | `StreamWriter` | Overwrites and truncates. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `CreateText` |  | `StreamWriter` | 覆盖并截断。 |'
- en: '| `AppendText` |  | `StreamWriter` | Creates the file if it does not exist.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `AppendText` |  | `StreamWriter` | 如果文件不存在，则创建文件。 |'
- en: '| `ReadAllLines` | `Encoding` | `string[]` | Warning! This uses a lot of memory
    for large files. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `ReadAllLines` | `Encoding` | `string[]` | 警告！对于大文件，这会使用大量内存。 |'
- en: '| `ReadAllText` | `Encoding` | `string` | Warning! This uses a lot of memory
    for large files. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `ReadAllText` | `Encoding` | `string` | 警告！对于大文件，这会使用大量内存。 |'
- en: '| `WriteAllText` | `string`, `Encoding` | `void` |  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `WriteAllText` | `string`, `Encoding` | `void` |  |'
- en: '| `AppendAllText` | `string`, `Encoding` | `void` |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `AppendAllText` | `string`, `Encoding` | `void` |  |'
- en: '| `WriteAllLines` | `string[]`, `IEnumerable<string>`, `Encoding` | `void`
    |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `WriteAllLines` | `string[]`, `IEnumerable<string>`, `Encoding` | `void`
    |  |'
- en: '| `AppendAllLines` | `string[]`, `IEnumerable<string>`, `Encoding` | `void`
    |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `AppendAllLines` | `string[]`, `IEnumerable<string>`, `Encoding` | `void`
    |  |'
- en: 'Table 9.2: File class and its methods'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2：文件类及其方法
- en: Now that you’ve learned some common ways to work with the directories and files
    in a filesystem, we next need to learn how to read and write data stored in a
    file, that is, how to work with streams.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了在文件系统中处理目录和文件的一些常见方法，接下来我们需要学习如何读取和写入存储在文件中的数据，即如何使用流。
- en: Reading and writing with streams
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流进行读写
- en: In *Chapter 10*, *Working with Data Using Entity Framework Core*, you will use
    a file named `Northwind.db`, but you will not work with the file directly. Instead,
    you will interact with the SQLite database engine, which, in turn, will read and
    write to the file. In scenarios where there is no other system that “owns” the
    file and does the reading and writing for you, you will use a file stream to work
    directly with the file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第10章*，*使用Entity Framework Core处理数据* 中，你将使用一个名为 `Northwind.db` 的文件，但你不会直接与文件交互。相反，你将与SQLite数据库引擎交互，它反过来会读取和写入文件。在没有其他系统“拥有”文件并为你进行读写操作的情况下，你将使用文件流直接与文件交互。
- en: A **stream** is a sequence of bytes that can be read from and written to. Although
    files can be processed rather like arrays, with random access provided by knowing
    the position of a byte within the file, it is more efficient to process a file
    as a stream in which the bytes can be accessed in sequential order. When a human
    does the processing, they tend to need random access so that they can jump around
    the data, make changes, and then return to the data they worked on earlier. When
    an automated system does the processing, it tends to be able to work sequentially
    and only needs to “touch” the data once.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**是一系列可以读取和写入的字节。虽然文件可以像数组一样处理，通过知道文件中字节的定位来提供随机访问，但将文件作为流处理更有效，其中字节可以按顺序访问。当人类进行处理时，他们往往需要随机访问，以便可以在数据中跳跃，进行更改，然后返回到之前工作的数据。当自动化系统进行处理时，它往往可以按顺序工作，并且只需要“接触”数据一次。'
- en: Streams can also be used to process terminal input and output and networking
    resources, such as sockets and ports, that do not provide random access and cannot
    seek (that is, move) to a position. You can write code to process some arbitrary
    bytes without knowing or caring where they come from. Your code simply reads or
    writes to a stream, and another piece of code handles where the bytes are stored.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 流也可以用来处理终端输入输出和网络资源，例如套接字和端口，这些资源不提供随机访问且不能进行定位（即移动）到某个位置。你可以编写代码来处理一些任意的字节，而不必知道或关心它们来自何处。你的代码只需简单地读取或写入流，而另一段代码则处理字节存储的位置。
- en: Understanding abstract and concrete streams
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解抽象和具体流
- en: There is an `abstract` class named `Stream` that represents any type of stream.
    Remember that an `abstract` class cannot be instantiated using `new`; it can only
    be inherited. This is because it is only partially implemented.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `Stream` 的抽象类，代表任何类型的流。请记住，抽象类不能使用 `new` 实例化；它只能被继承。这是因为它只部分实现了。
- en: There are many concrete classes that inherit from this base class, including
    `FileStream`, `MemoryStream`, `BufferedStream`, `GZipStream`, and `SslStream`.
    They all work the same way. All streams implement `IDisposable`, so they have
    a `Dispose` method to release unmanaged resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多具体类继承自这个基类，包括 `FileStream`、`MemoryStream`、`BufferedStream`、`GZipStream` 和
    `SslStream`。它们的工作方式相同。所有流都实现了 `IDisposable`，因此它们都有一个 `Dispose` 方法来释放非托管资源。
- en: 'Some of the common members of the `Stream` class are described in *Table 9.3*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类的一些常见成员在 *表9.3* 中进行了描述：'
- en: '| **Member** | **Description** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **成员** | **描述** |'
- en: '| `CanRead` and `CanWrite` | These properties determine if you can read from
    and write to the stream. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `CanRead` 和 `CanWrite` | 这些属性确定你是否可以从流中读取和写入。|'
- en: '| `Length` and `Position` | These properties determine the total number of
    bytes and the current position within the stream. These properties may throw a
    `NotSupportedException` for some types of streams, for example, if `CanSeek` returns
    `false`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Length` 和 `Position` | 这些属性确定流中的总字节数和当前位置。对于某些类型的流，这些属性可能会抛出 `NotSupportedException`，例如，如果
    `CanSeek` 返回 `false`。|'
- en: '| `Close` and `Dispose` | This method closes the stream and releases its resources.
    You can call either method, since the implementation of `Dispose` calls `Close`!
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `Close` 和 `Dispose` | 此方法关闭流并释放其资源。你可以调用任一方法，因为 `Dispose` 的实现调用了 `Close`！|'
- en: '| `Flush` | If the stream has a buffer, then this method writes the bytes in
    the buffer to the stream, and the buffer is cleared. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `Flush` | 如果流有一个缓冲区，则此方法将缓冲区中的字节写入流，并清除缓冲区。|'
- en: '| `CanSeek` | This property determines if the `Seek` method can be used. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `CanSeek` | 此属性确定是否可以使用`Seek`方法。 |'
- en: '| `Seek` | This method moves the current position to the one specified in its
    parameter. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Seek` | 此方法将当前位置移动到其参数中指定的位置。 |'
- en: '| `Read` and `ReadAsync` | These methods read a specified number of bytes from
    the stream into a byte array and advance the position. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Read` 和 `ReadAsync` | 这些方法将指定数量的字节从流中读取到字节数组中并前进位置。 |'
- en: '| `ReadByte` | This method reads the next byte from the stream and advances
    the position. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `ReadByte` | 此方法从流中读取下一个字节并前进位置。 |'
- en: '| `Write` and `WriteAsync` | These methods write the contents of a byte array
    into the stream. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Write` 和 `WriteAsync` | 这些方法将字节数组的内容写入流。 |'
- en: '| `WriteByte` | This method writes a byte to the stream. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `WriteByte` | 此方法将一个字节写入流。 |'
- en: 'Table 9.3: Common members of the Stream class'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3：Stream类的常见成员
- en: Understanding storage streams
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解存储流
- en: 'Some storage streams that represent a location where bytes will be stored are
    described in *Table 9.4*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表示字节存储位置的存储流在*表9.4*中描述：
- en: '| **Namespace** | **Class** | **Description** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | **类** | **描述** |'
- en: '| `System.IO` | `FileStream` | Bytes stored in the filesystem |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `FileStream` | 存储在文件系统中的字节 |'
- en: '| `System.IO` | `MemoryStream` | Bytes stored in memory in the current process
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `MemoryStream` | 存储在当前进程中的内存中的字节 |'
- en: '| `System.Net.Sockets` | `NetworkStream` | Bytes stored at a network location
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Sockets` | `NetworkStream` | 存储在网络位置的字节 |'
- en: 'Table 9.4: Storage stream classes'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.4：存储流类
- en: '`FileStream` has been rewritten in .NET 6 to have much higher performance and
    reliability on Windows. You can read more about this at the following link: [https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/](https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`在.NET 6中已重写，以在Windows上提供更高的性能和可靠性。您可以在以下链接中了解更多信息：[https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/](https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/)。'
- en: Understanding function streams
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解函数流
- en: 'Function streams cannot exist on their own and can only be “plugged into” other
    streams to add functionality. Some are described in *Table 9.5*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数流不能独立存在，只能“插入”到其他流中以添加功能。其中一些在*表9.5*中描述：
- en: '| **Namespace** | **Class** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | **类** | **描述** |'
- en: '| `System.Security.Cryptography` | `CryptoStream` | This encrypts and decrypts
    the stream. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `System.Security.Cryptography` | `CryptoStream` | 此流进行加密和解密。 |'
- en: '| `System.IO.Compression` | `GZipStream`, `DeflateStream` | These compress
    and decompress the stream. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO.Compression` | `GZipStream`, `DeflateStream` | 这些压缩和解压缩流。 |'
- en: '| `System.Net.Security` | `AuthenticatedStream` | This sends credentials across
    the stream. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Security` | `AuthenticatedStream` | 此方法通过流发送凭据。 |'
- en: 'Table 9.5: Function stream classes'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.5：函数流类
- en: Understanding stream helpers
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解流辅助
- en: Although there will be occasions where you need to work with streams at a low
    level, most often, you can plug helper classes into the chain to make things easier.
    All the helper types for streams implement `IDisposable`, so they have a `Dispose`
    method to release unmanaged resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有时您需要以低级别处理流，但大多数情况下，您可以将辅助类插入链中，使事情变得更容易。所有流辅助类型都实现`IDisposable`，因此它们有一个`Dispose`方法来释放非托管资源。
- en: 'Some helper classes to handle common scenarios are described in *Table 9.6*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用于处理常见场景的辅助类在*表9.6*中描述：
- en: '| **Namespace** | **Class** | **Description** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | **类** | **描述** |'
- en: '| `System.IO` | `StreamReader` | This reads from the underlying stream as plain
    text. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `StreamReader` | 此以纯文本形式从底层流中读取。 |'
- en: '| `System.IO` | `StreamWriter` | This writes to the underlying stream as plain
    text. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `StreamWriter` | 此以纯文本形式将底层流写入。 |'
- en: '| `System.IO` | `BinaryReader` | This reads from streams as .NET types. For
    example, the `ReadDecimal` method reads the next 16 bytes from the underlying
    stream as a `decimal` value, and the `ReadInt32` method reads the next 4 bytes
    as an `int` value. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `BinaryReader` | 此读取流作为.NET类型。例如，`ReadDecimal`方法从底层流中读取下一个16字节作为`decimal`值，而`ReadInt32`方法读取下一个4字节作为`int`值。
    |'
- en: '| `System.IO` | `BinaryWriter` | This writes to streams as .NET types. For
    example, the `Write` method with a `decimal` parameter writes 16 bytes to the
    underlying stream, and the `Write` method with an `int` parameter writes 4 bytes.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `BinaryWriter` | 此将.NET类型写入流。例如，具有`decimal`参数的`Write`方法将16字节写入底层流，而具有`int`参数的`Write`方法写入4字节。
    |'
- en: '| `System.Xml` | `XmlReader` | This reads from the underlying stream using
    the XML format. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `System.Xml` | `XmlReader` | 这使用 XML 格式从底层流中读取。|'
- en: '| `System.Xml` | `XmlWriter` | This writes to the underlying stream using the
    XML format. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `System.Xml` | `XmlWriter` | 这使用 XML 格式将数据写入底层流。|'
- en: 'Table 9.6: Stream helper classes'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.6：流辅助类
- en: Building a stream pipeline
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建流管道
- en: 'It is very common to combine a helper, like `StreamWriter`, and multiple function
    streams, like `GZipStream` and `CryptoStream`, with a storage stream, like `FileStream`,
    into a pipeline, as shown in *Figure 9.4*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将辅助器，如 `StreamWriter`，多个功能流，如 `GZipStream` 和 `CryptoStream`，以及存储流，如 `FileStream`，组合成管道是很常见的，如图
    *9.4* 所示：
- en: '![](img/B22322_09_04.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_09_04.png)'
- en: 'Figure 9.4: Writing plain text, and then encrypting and compressing it into
    a file stream'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：将纯文本写入，然后将其加密并压缩到文件流中
- en: Your code would just call a simple helper method, like `WriteLine`, to send
    a `string` value, like `"Hello"`, through the pipeline until it arrives at its
    final destination, having been compressed and then encrypted so that it gets written
    to the file as `"``G7x"` (or whatever it would be).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码只需调用一个简单的辅助方法，如 `WriteLine`，将一个 `string` 值，如 `"Hello"`，通过管道发送，直到它到达最终目的地，经过压缩和加密后，被写入文件作为
    `"``G7x"`（或任何其他值）。
- en: '**Good Practice**: “*Good encryption will generate relatively uncompressible
    data. If you switch the order of the operations so that you first compress and
    then encrypt, not only should you end up with a smaller file, but the encryption
    will most likely take less time as it’ll be operating on less data*.” From an
    article by Stephen Toub: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/february/net-matters-stream-pipeline](https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/february/net-matters-stream-pipeline).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：“*良好的加密将生成相对不可压缩的数据。如果你改变操作的顺序，先压缩再加密，不仅最终文件会更小，而且加密很可能花费更少的时间，因为它将处理更少的数据*。”
    来自 Stephen Toub 的文章：[https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/february/net-matters-stream-pipeline](https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/february/net-matters-stream-pipeline)。'
- en: Writing to text streams
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文本流
- en: When you open a file to read or write to it, you use resources outside of .NET.
    These are called **unmanaged resources** and must be disposed of when you are
    done working with them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个文件进行读取或写入时，你使用 .NET 之外的资源。这些被称为 **未托管资源**，在完成与它们的操作后必须释放。
- en: To deterministically control when these resources are disposed of, we can call
    the `Dispose` method. When the `Stream` class was first designed, all cleanup
    code was expected to go in the `Close` method. But later, the concept of `IDisposable`
    was added to .NET, and `Stream` had to implement a `Dispose` method. Later, the
    `using` statement was added to .NET, which can automatically call `Dispose`. So
    today, you can call either `Close` or `Dispose`, which actually do the same thing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定性地控制这些资源何时被释放，我们可以调用 `Dispose` 方法。当 `Stream` 类最初设计时，所有清理代码都预期放在 `Close`
    方法中。但后来，.NET 中添加了 `IDisposable` 的概念，`Stream` 必须实现 `Dispose` 方法。后来，.NET 中添加了 `using`
    语句，它可以自动调用 `Dispose`。所以今天，你可以调用 `Close` 或 `Dispose`，实际上它们做的是同一件事。
- en: 'Let’s type some code to write text to a stream:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入一些代码来将文本写入流：
- en: 'Use your preferred code editor to add a new **Console App** / `console` project,
    named `WorkingWithStreams`, to the `Chapter09` solution:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，向 `Chapter09` 解决方案中添加一个名为 `WorkingWithStreams` 的新 **控制台应用程序**/ `console`
    项目：
- en: In the project file, add an element to import the `System.Console`, `System.Environment`,
    and `System.IO.Path` classes, statically and globally.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加一个元素以导入 `System.Console`、`System.Environment` 和 `System.IO.Path` 类，静态和全局地。
- en: Add a new class file named `Program.Helpers.cs`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with a `SectionTitle`
    and an `OutputFileInfo` method, as shown in the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，添加一个部分 `Program` 类，包含 `SectionTitle` 和 `OutputFileInfo`
    方法，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add a new class file named `Viper.cs`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Viper.cs` 的新类文件。
- en: 'In `Viper.cs`, define a static class named `Viper` with a static array of `string`
    values, named `Callsigns`, as shown in the following code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Viper.cs` 中，定义一个名为 `Viper` 的静态类，其中包含一个名为 `Callsigns` 的静态 `string` 值数组，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `Program.cs`, delete the existing statements, and then import the namespace
    to work with the `Viper` class, as shown in the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后导入命名空间以使用 `Viper` 类，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `Program.cs`, add statements to enumerate the `Viper` call signs, writing
    each one on its own line in a single text file, as shown in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加语句以枚举 `Viper` 呼号，将每个呼号单独写入一个文本文件的一行中，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Calling `Close` on the stream writer helper will call `Close` on the underlying
    stream. This in turn calls `Dispose` to release unmanaged file resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在流写入辅助工具上调用 `Close` 将会调用底层流的 `Close`。这反过来会调用 `Dispose` 以释放非托管文件资源。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE18]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the file that was created, and confirm that it contains the list of call
    signs as well as a blank line, as we are effectively calling `WriteLine` twice:
    once when we write the last call sign to the file, and again when we read the
    whole file and write it out to the console.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开创建的文件，并确认它包含呼号列表以及一个空行，因为我们实际上调用了两次 `WriteLine`：一次是在将最后一个呼号写入文件时，另一次是在读取整个文件并将其写入控制台时。
- en: Remember that if you run the project at the command prompt using `dotnet run`,
    then the path will be the project folder. It will not include `bin\Debug\net9.0`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果您使用 `dotnet run` 在命令提示符下运行项目，则路径将是项目文件夹。它不会包括 `bin\Debug\net9.0`。
- en: Writing to XML streams
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入 XML 流
- en: 'There are two ways to write an XML element, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来编写 XML 元素，如下所示：
- en: '`WriteStartElement` and `WriteEndElement`: Use this pair when an element might
    have child elements.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteStartElement` 和 `WriteEndElement`：当元素可能有子元素时使用此对。'
- en: '`WriteElementString`: Use this when an element does not have children.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteElementString`：当元素没有子元素时使用此方法。'
- en: 'Now, let’s try storing the Viper pilot call signs array of `string` values
    in an XML file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将 Viper 飞行员的呼号数组（`string` 类型的值）存储在一个 XML 文件中：
- en: 'At the top of `Program.cs`, import the `System.Xml` namespace, as shown in
    the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的顶部导入 `System.Xml` 命名空间，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the bottom of `Program.cs`, add statements that enumerate the call signs,
    writing each one as an element in a single XML file, as shown in the following
    code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部添加语句以枚举呼号，将每个呼号作为单个 XML 文件中的一个元素写入，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Optionally, right-click in the `Close` method of `xmlFileStream`, select **Go
    To Implementation**, and note the implementations of the `Dispose`, `Close`, and
    `Dispose(bool)` methods, as shown in the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在 `xmlFileStream` 的 `Close` 方法上右键单击，选择 **转到实现**，并注意 `Dispose`、`Close` 和
    `Dispose(bool)` 方法的实现，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Close` and `Dispose(bool)` methods are `virtual` in the `Stream` class
    because they are designed to be overridden in a derived class, like `FileStream`,
    to do the work of releasing unmanaged resources.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类中的 `Close` 和 `Dispose(bool)` 方法是 `virtual` 的，因为它们被设计为在派生类（如 `FileStream`）中重写，以执行释放非托管资源的工作。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE22]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Good Practice**: Before calling the `Dispose` method, check that the object
    is not `null`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在调用 `Dispose` 方法之前，请检查对象是否不是 `null`。'
- en: Simplifying disposal by using the using statement
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `using` 语句简化释放
- en: You can simplify the code that needs to check for a `null` object and then call
    its `Dispose` method by using the `using` statement. Unless you need a greater
    level of control, I would generally recommend using `using` rather than manually
    calling `Dispose`, as it’s less code to write.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `using` 语句简化需要检查 `null` 对象并调用其 `Dispose` 方法的代码。除非您需要更高程度的控制，否则我通常会推荐使用
    `using` 而不是手动调用 `Dispose`，因为它更简洁。
- en: 'Confusingly, there are two uses for the `using` keyword: importing a namespace
    and generating a `finally` statement that calls `Dispose` on an object implementing
    `IDisposable`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，`using` 关键字有两种用法：导入命名空间和生成一个调用实现 `IDisposable` 接口的对象的 `Dispose` 方法的 `finally`
    语句。
- en: 'The compiler changes a `using` statement block into a `try`-`finally` statement
    without a `catch` statement. You can use nested `try` statements, so if you do
    want to catch any exceptions, you can, as shown in the following code example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将 `using` 语句块转换为没有 `catch` 语句的 `try`-`finally` 语句。您可以使用嵌套的 `try` 语句，因此如果您确实想捕获任何异常，您可以，如下面的代码示例所示：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can even simplify the code further by not explicitly specifying the braces
    and indentation for the `using` statements, as shown in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过不显式指定 `using` 语句的大括号和缩进来进一步简化代码，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make this clearer, let’s review a simpler example. You can use a `using`
    block to ensure that the `Dispose` method is called at the end of the scope, as
    shown in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更清晰，让我们回顾一个更简单的例子。您可以使用`using`块确保在作用域结束时调用`Dispose`方法，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**More Information**: You can learn how the preceding code is lowered into
    a `try-catch` block at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#ensuring-that-dispose-is-called](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#ensuring-that-dispose-is-called).
    If you haven’t already, you should also read the following online section: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#releasing-unmanaged-resources](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#releasing-unmanaged-resources).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解前面的代码是如何转换为`try-catch`块的：[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#ensuring-that-dispose-is-called](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#ensuring-that-dispose-is-called)。如果您还没有阅读，您也应该阅读以下在线部分：[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#releasing-unmanaged-resources](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#releasing-unmanaged-resources)。'
- en: 'You can also use a simplified syntax without braces, as shown in the following
    code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用不带花括号的简化语法，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code example, there is no explicit block defined by braces,
    so an implicit block is defined that ends at the end of the containing scope.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，没有显式定义由花括号定义的块，因此定义了一个隐式块，该块在包含作用域的末尾结束。
- en: '**More Information**: You can learn more about this at the following links:
    [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using)
    and [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1314-the-using-statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1314-the-using-statement).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using)
    和 [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1314-the-using-statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1314-the-using-statement)。'
- en: Compressing streams
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩流
- en: XML is relatively verbose, so it takes up more space in bytes than plain text.
    Let’s see how we can squeeze the XML using a common compression algorithm, known
    as GZIP.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: XML相对冗长，因此它占用的字节数比纯文本多。让我们看看如何使用常见的压缩算法GZIP来压缩XML。
- en: In .NET Core 2.1, Microsoft introduced an implementation of the Brotli compression
    algorithm. In performance, Brotli is like the algorithm used in DEFLATE and GZIP,
    but the output is about 20% denser.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 2.1中，Microsoft引入了Brotli压缩算法的实现。在性能上，Brotli类似于DEFLATE和GZIP中使用的算法，但输出密度大约高20%。
- en: 'Let’s compare the two compression algorithms:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两种压缩算法：
- en: Add a new class file named `Program.Compress.cs`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Program.Compress.cs`的新类文件。
- en: 'In `Program.Compress.cs`, write statements to use instances of `GZipStream`
    or `BrotliStream` to create a compressed file that contains the same XML elements
    as before, and then decompress it while reading it and outputting to the console,
    as shown in the following code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Compress.cs`中，编写语句以使用`GZipStream`或`BrotliStream`的实例创建包含与之前相同的XML元素的压缩文件，然后在其读取并输出到控制台的同时对其进行解压缩，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code that uses the `decompressor` object does not use the simplified `using`
    syntax. Instead, it uses the fact that `using` blocks can omit their braces for
    a single “statement,” just like `if` statements. Remember that `if` statements
    can have explicit braces even if only one statement is executed within a block,
    as shown in the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`decompressor`对象的代码不使用简化的`using`语法。相反，它利用了`using`块可以省略其花括号以表示单个“语句”的事实，就像`if`语句一样。记住，即使一个块内只执行了一个语句，`if`语句也可以有显式的花括号，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, `using (XmlReader reader = XmlReader.Create(decompressor))`
    and the entire `while (reader.Read()) { ... }` block are equivalent to single
    statements, so we can remove the braces and the code works as expected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`using (XmlReader reader = XmlReader.Create(decompressor))`和整个`while
    (reader.Read()) { ... }`块相当于单个语句，因此我们可以省略花括号，代码按预期工作。
- en: 'In `Program.cs`, add calls to `Compress` with parameters to use the `gzip`
    and `brotli` algorithms, as shown in the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加调用`Compress`的语句，使用`gzip`和`brotli`算法，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code, and compare the sizes of the XML file and the compressed XML
    file using the `gzip` and `brotli` algorithms, as shown in the following output:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并使用`gzip`和`brotli`算法比较XML文件和压缩XML文件的大小，如下面的输出所示：
- en: '[PRE30]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To summarize the file sizes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 总结文件大小：
- en: 'Uncompressed: 320 bytes'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未压缩：320字节
- en: 'GZIP-compressed: 151 bytes'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GZIP压缩：151字节
- en: 'Brotli-compressed: 117 bytes'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brotli压缩：117字节
- en: 'As well as choosing a compression mode, you can also choose a compression level.
    You can learn more about this at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.compressionlevel](https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.compressionlevel).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择压缩模式外，您还可以选择压缩级别。您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.compressionlevel](https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.compressionlevel)。
- en: Reading and writing with random access handles
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用随机访问句柄进行读写
- en: For the first 20 years of .NET’s life, the only API to work directly with files
    was the one for stream classes. These work great for automated tasks that only
    need to process data sequentially. But when a human interacts with the data, they
    often want to jump around and return multiple times to the same location.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET生命的头20年里，直接与文件工作的唯一API是流类API。这些对于只需要按顺序处理数据的自动化任务非常出色。但当人类与数据交互时，他们通常会跳来跳去，多次返回到同一位置。
- en: 'With .NET 6 and later, there is a new API for working with files without needing
    a file stream and in a random access way. Let’s see a simple example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6及以后版本中，有一个新的API用于以随机访问方式处理文件，无需使用文件流。让我们看看一个简单的例子：
- en: 'Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithRandomAccess` to the `Chapter09` solution:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，将名为`WorkingWithRandomAccess`的新**控制台应用程序**/`console`项目添加到`Chapter09`解决方案中：
- en: In the project file, add an element to import the `System.Console` class statically
    and globally.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加一个元素以静态和全局方式导入`System.Console`类。
- en: 'In `Program.cs`, delete the existing statements, and then get a handle to a
    file named `coffee.txt`, as shown in the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中删除现有语句，然后获取名为`coffee.txt`的文件句柄，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Write some text encoded as a byte array, and then store it in a read-only memory
    buffer to the file, as shown in the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些编码为字节数组的文本写入，然后将其存储到文件中的只读内存缓冲区中，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To read from the file, get the length of the file, allocate a memory buffer
    for the contents using that length, and then read the file, as shown in the following
    code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从文件中读取，获取文件长度，使用该长度分配内存缓冲区以存储内容，然后读取文件，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code, and note the content of the file, as shown in the following output:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意文件内容，如下面的输出所示：
- en: '[PRE34]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Encoding and decoding text
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编码和解码
- en: Text characters can be represented in different ways. For example, the alphabet
    can be encoded using Morse code into a series of dots and dashes for transmission
    over a telegraph line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符可以用不同的方式表示。例如，字母表可以用摩尔斯电码编码成一系列点和划，以便在电报线上传输。
- en: In a similar way, text inside a computer is stored as bits (ones and zeros)
    representing a code point within a code space. Most code points represent a single
    character, but they can also have other meanings, like formatting.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，计算机内的文本以位（一和零）的形式存储，代表代码空间内的代码点。大多数代码点代表单个字符，但它们也可以有其他含义，如格式化。
- en: For example, ASCII has a code space with 128 code points. .NET uses a standard
    called **Unicode** to encode text internally. Unicode has more than 1 million
    code points.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ASCII有128个代码点。.NET使用一个称为**Unicode**的标准来内部编码文本。Unicode有超过一百万个代码点。
- en: Sometimes, you will need to move text outside .NET for use by systems that do
    not use Unicode or a variation of it, so it is important to learn how to convert
    between encodings.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要将文本移出.NET，以便由不使用Unicode或其变体的系统使用，因此学习如何在编码之间进行转换是很重要的。
- en: 'Some common text encodings used by computers are shown in *Table 9.7*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用的常见文本编码如下表所示：
- en: '| **Encoding** | **Description** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **编码** | **描述** |'
- en: '| ASCII | This encodes a limited range of characters using the lower 7 bits
    of a byte. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| ASCII | 使用字节的低7位编码字符的有限范围。|'
- en: '| UTF-8 | This represents each Unicode code point as a sequence of 1 to 4 bytes.
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8 | 这表示每个 Unicode 代码点为一个 1 到 4 字节的序列。|'
- en: '| UTF-7 | This is designed to be more efficient over 7-bit channels than UTF-8,
    but it has security and robustness issues, so UTF-8 is recommended over UTF-7.
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| UTF-7 | 这是为了在 7 位通道上比 UTF-8 更有效，但它存在安全和健壮性问题，因此建议使用 UTF-8 而不是 UTF-7。|'
- en: '| UTF-16 | This represents each Unicode code point as a sequence of one or
    two 16-bit integers. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16 | 这表示每个 Unicode 代码点为一个或两个 16 位整数的序列。|'
- en: '| UTF-32 | This represents each Unicode code point as a 32-bit integer and
    is, therefore, a fixed-length encoding, unlike the other Unicode encodings, which
    are all variable-length encodings. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32 | 这表示每个 Unicode 代码点为一个 32 位整数，因此是一个固定长度编码，与所有其他 Unicode 编码不同，它们都是可变长度编码。|'
- en: '| ANSI/ISO encodings | This provides support for a variety of code pages that
    are used to support a specific language or group of languages. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| ANSI/ISO 编码 | 这提供了对各种代码页的支持，这些代码页用于支持特定的语言或语言组。|'
- en: 'Table 9.7: Common text encodings'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.7：常见文本编码
- en: '**Good Practice**: In most cases today, UTF-8 is a good default, which is why
    it is literally the default encoding, that is, `Encoding.Default`. You should
    avoid using `Encoding.UTF7` because it is not secure. Due to this, the C# compiler
    will warn you when you try to use UTF-7\. Of course, you might need to generate
    text using that encoding for compatibility with another system, so it needs to
    remain an option in .NET.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在当今大多数情况下，UTF-8 是一个好的默认编码，这也是为什么它是字面上的默认编码，即 `Encoding.Default`。您应该避免使用
    `Encoding.UTF7`，因为它不安全。因此，当您尝试使用 UTF-7 时，C# 编译器会警告您。当然，您可能需要使用该编码生成文本以与其他系统兼容，因此它需要在
    .NET 中保留为一个选项。'
- en: Encoding strings as byte arrays
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串编码为字节数组
- en: 'Let’s explore text encodings:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索文本编码：
- en: Use your preferred code editor to add a new **Console App** / `console` project,
    named `WorkingWithEncodings`, to the `Chapter09` solution.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，将一个新的 **Console App** / `console` 项目，命名为 `WorkingWithEncodings`，添加到
    `Chapter09` 解决方案中。
- en: In the project file, add an element to statically and globally import the `System.Console`
    class.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加一个元素以静态和全局导入 `System.Console` 类。
- en: 'In `Program.cs`, delete the existing statements, import the `System.Text` namespace,
    add statements to encode a `string` using an encoding chosen by the user, loop
    through each byte, and then decode the encoded value back into a `string` and
    output it, as shown in the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，导入 `System.Text` 命名空间，添加语句以使用用户选择的编码编码一个 `string`，循环遍历每个字节，然后将编码的值解码回
    `string` 并输出，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the code, press *1* to choose ASCII, and note that when outputting the
    bytes, the pound sign (`£`) and accented e (`é`) cannot be represented in ASCII,
    so it uses a question mark instead:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按 *1* 选择 ASCII，注意当输出字节时，英镑符号 (`£`) 和带重音的 e (`é`) 无法在 ASCII 中表示，因此它使用问号代替：
- en: '[PRE36]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Rerun the code and press *3* to choose UTF-8\. Note that UTF-8 requires 2 extra
    bytes for the two characters that need 2 bytes each (12 bytes instead of 10 bytes
    in total), but it can encode and decode the `é` and `£` characters:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并按 *3* 选择 UTF-8。注意 UTF-8 需要为每个需要 2 个字节的两个字符额外使用 2 个字节（总共 12 个字节而不是 10
    个字节），但它可以编码和解码 `é` 和 `£` 字符：
- en: '[PRE37]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Rerun the code and press *4* to choose Unicode (UTF-16). Note that UTF-16 requires
    2 bytes for every character, so 20 bytes in total, and it can encode and decode
    the `é` and `£` characters. This encoding is used internally by .NET to store
    `char` and `string` values.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并按 *4* 选择 Unicode（UTF-16）。注意 UTF-16 为每个字符需要 2 个字节，因此总共需要 20 个字节，并且它可以编码和解码
    `é` 和 `£` 字符。此编码由 .NET 内部用于存储 `char` 和 `string` 值。
- en: Encoding and decoding text in files
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件中的文本编码和解码
- en: When using stream helper classes, such as `StreamReader` and `StreamWriter`,
    you can specify the encoding you want to use. As you write to the helper, the
    text will be automatically encoded, and as you read from the helper, the bytes
    will be automatically decoded.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用流辅助类，例如 `StreamReader` 和 `StreamWriter` 时，您可以指定您想要使用的编码。当您向辅助类写入时，文本将被自动编码；当您从辅助类读取时，字节将被自动解码。
- en: 'To specify an encoding, pass the encoding as a second parameter to the helper
    type’s constructor, as shown in the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定一个编码，将编码作为辅助类型构造函数的第二个参数传递，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Good Practice**: Often, you won’t have the choice of which encoding to use
    because you will generate a file for use by another system. However, if you do,
    pick one that uses the least number of bytes but can store every character you
    need.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：通常，你不会选择使用哪种编码方式，因为你将生成一个文件供其他系统使用。然而，如果你有选择，请选择使用字节最少的编码方式，但可以存储你需要的所有字符。'
- en: Serializing object graphs
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化对象图
- en: An **object graph** is a structure of multiple objects that are related to each
    other, either through a direct reference or indirectly through a chain of references.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象图**是一组多个相互关联的对象的结构，这些对象通过直接引用或间接引用链相互关联。'
- en: '**Serialization** is the process of converting a live object graph into a sequence
    of bytes using a specified format. **Deserialization** is the reverse process.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将活动对象图转换为使用指定格式的一系列字节的过程。**反序列化**是相反的过程。'
- en: You would use serialization to save the current state of a live object so that
    you can recreate it in the future, for example, saving the current state of a
    game so that you can continue at the same place tomorrow. The stream produced
    from a serialized object is usually stored in a file or database.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用序列化来保存活动对象的状态，以便将来可以重新创建它，例如，保存游戏当前状态以便明天可以继续，在相同的地方继续。从序列化对象产生的流通常存储在文件或数据库中。
- en: There are dozens of formats you can choose for serialization, but the two most
    common text-based human-readable formats are **eXtensible Markup Language** (**XML**)
    and **JavaScript Object Notation** (**JSON**). There are also more efficient binary
    formats like Protobuf, used by gRPC.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择数十种格式进行序列化，但最常用的两种基于文本的、可读性强的格式是 **可扩展标记语言** (**XML**) 和 **JavaScript 对象表示法**
    (**JSON**)。还有更高效的二进制格式，如 Protobuf，它被 gRPC 所使用。
- en: '**Good Practice**: JSON is more compact and is best for web and mobile applications.
    XML is more verbose but is better supported in more legacy systems. Use JSON to
    minimize the size of serialized object graphs. JSON is also a good choice when
    sending object graphs to web applications and mobile applications, as it is the
    native serialization format for JavaScript, and mobile apps often make calls over
    limited bandwidth, so the number of bytes is important.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：JSON 更紧凑，更适合网页和移动应用程序。XML 更冗长，但在更多遗留系统中支持得更好。使用 JSON 来最小化序列化对象图的大小。当将对象图发送到网页应用程序和移动应用程序时，JSON
    也是一个不错的选择，因为它是 JavaScript 的原生序列化格式，并且移动应用程序通常在有限的带宽下进行调用，因此字节数很重要。'
- en: .NET has multiple classes that will serialize to and from XML and JSON. We will
    start by looking at `XmlSerializer` and `JsonSerializer`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 有多个类可以将 XML 和 JSON 序列化和反序列化。我们将首先看看 `XmlSerializer` 和 `JsonSerializer`。
- en: Serializing as XML
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象序列化为 XML
- en: 'Let’s start by looking at XML, probably the world’s most used serialization
    format (for now). To show a typical example, we will define a custom class to
    store information about a person and then create an object graph, using a list
    of `Person` instances with nesting:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 XML，可能是世界上使用最广泛的序列化格式（目前）。为了展示一个典型的例子，我们将定义一个自定义类来存储有关人员的信 息，然后创建一个对象图，使用
    `Person` 实例的列表进行嵌套：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithSerialization` to the `Chapter09` solution.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，将一个名为 `WorkingWithSerialization` 的新 **Console App** / `console`
    项目添加到 `Chapter09` 解决方案中。
- en: 'In the project file, add elements to statically and globally import the following
    classes:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加元素以静态和全局导入以下类：
- en: System.Console to use ForegroundColor and WriteLine
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `System.Console` 的 `ForegroundColor` 和 `WriteLine`
- en: System.Environment to use CurrentDirectory
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `System.Environment` 的 `CurrentDirectory`
- en: System.IO.Path to use Combine, GetFileName, and GetDirectoryName
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `System.IO.Path` 的 `Combine`、`GetFileName` 和 `GetDirectoryName`
- en: Add a new class file named `Program.Helpers.cs`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with a `SectionTitle`
    and an `OutputFileInfo` method, as shown in the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，添加一个部分 `Program` 类，包含 `SectionTitle` 和 `OutputFileInfo`
    方法，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a new class file, named `Person.cs`, to define a `Person` class with a
    `Salary` property that is `protected`, meaning it is only accessible to itself
    and derived classes. To populate the salary, the class has a constructor with
    a single parameter to set the initial salary, as shown in the following code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Person.cs` 的新类文件，用于定义一个具有 `Salary` 属性的 `Person` 类，该属性是 `protected` 的，这意味着它只能由自身和派生类访问。为了填充薪水，该类有一个带有单个参数的构造函数，用于设置初始薪水，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `Program.cs`, delete the existing statements, and then import namespaces
    to work with XML serialization and the `Person` class, as shown in the following
    code:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后导入命名空间以使用 XML 序列化和 `Person` 类，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In `Program.cs`, add statements to create an object graph of `Person` instances,
    as shown in the following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加语句以创建 `Person` 实例的对象图，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the code, view the result, and note that an exception is thrown, as shown
    in the following output:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意会抛出一个异常，如下面的输出所示：
- en: '[PRE43]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `Person.cs`, add a statement to define a parameterless constructor, as shown
    in the following code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中添加一个定义无参构造函数的语句，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The constructor does not need to do anything, but it must exist so that the
    `XmlSerializer` can call it to instantiate new `Person` instances during the deserialization
    process.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不需要做任何事情，但它必须存在，以便 `XmlSerializer` 可以在反序列化过程中调用它以实例化新的 `Person` 实例。
- en: 'Run the code and view the result, and note that the object graph is serialized
    as XML elements, like `<FirstName>Bob</FirstName>`, and that the `Salary` property
    is not included because it is not a `public` property, as shown in the following
    output:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，并注意对象图被序列化为 XML 元素，如 `<FirstName>Bob</FirstName>`，并且 `Salary` 属性没有包含，因为它不是
    `public` 属性，如下面的输出所示：
- en: '[PRE45]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Generating compact XML
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成紧凑的 XML
- en: 'We could make the XML more compact using attributes instead of elements for
    some fields:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用属性而不是元素来使某些字段更紧凑的 XML：
- en: 'At the top of `Person.cs`, import the `System.Xml.Serialization` namespace
    so that you can decorate some properties with the `[XmlAttribute]` attribute,
    as shown in the following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件的顶部导入 `System.Xml.Serialization` 命名空间，以便可以使用 `[XmlAttribute]`
    属性装饰一些属性，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `Person.cs`, decorate the first name, last name, and date of birth properties
    with the `[XmlAttribute]` attribute, and set a short name for each property, as
    highlighted in the following code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，使用 `[XmlAttribute]` 属性装饰姓名、姓氏和出生日期属性，并为每个属性设置一个简短名称，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the code, and note that the size of the file has reduced from 793 to 488
    bytes, a space-saving of more than a third. This reduction was achieved by outputting
    property values as XML attributes, as shown in the following output:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意文件大小从 793 字节减少到 488 字节，节省了超过三分之一的存储空间。这种减少是通过将属性值作为 XML 属性输出实现的，如下面的输出所示：
- en: '[PRE48]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Deserializing XML files
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反序列化 XML 文件
- en: 'Now, let’s try deserializing the XML file back into live objects in memory:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将 XML 文件反序列化回内存中的活动对象：
- en: 'In `Program.cs`, add statements to open the XML file, and then deserialize
    it, as shown in the following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加语句以打开 XML 文件，然后反序列化它，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the code, and note that the people are loaded successfully from the XML
    file and then enumerated, as shown in the following output:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意人员已成功从 XML 文件中加载并枚举，如下面的输出所示：
- en: '[PRE50]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**More Information**: There are many other attributes defined in the `System.Xml.Serialization`
    namespace that can be used to control the XML generated. A good place to start
    is the official documentation for the `XmlAttributeAttribute` class found here:
    [https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlattributeattribute](https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlattributeattribute).
    Do not get this class confused with the `XmlAttribute` class in the `System.Xml`
    namespace. That is used to represent an XML attribute when reading and writing
    XML, using `XmlReader` and `XmlWriter`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：在 `System.Xml.Serialization` 命名空间中定义了许多其他属性，可以用来控制生成的 XML。一个好的起点是找到
    `XmlAttributeAttribute` 类的官方文档，该文档位于此处：[https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlattributeattribute](https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlattributeattribute)。不要将此类与
    `System.Xml` 命名空间中的 `XmlAttribute` 类混淆。后者用于在读取和写入 XML 时表示 XML 属性，使用 `XmlReader`
    和 `XmlWriter`。'
- en: If you don’t use any annotations, `XmlSerializer` performs a case-insensitive
    match using the property name when deserializing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用任何注解，`XmlSerializer` 在反序列化时会使用属性名进行不区分大小写的匹配。
- en: '**Good Practice**: When using `XmlSerializer`, remember that only the public
    fields and properties are included, and the type must have a parameterless constructor.
    You can customize the output with attributes.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当使用 `XmlSerializer` 时，请记住，只有公共字段和属性会被包含，并且类型必须有一个无参构造函数。您可以使用属性来自定义输出。'
- en: Serializing with JSON
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 序列化
- en: One of the most popular .NET libraries to work with the JSON serialization format
    is **Newtonsoft.Json**, known as **Json.NET**. It is mature and powerful.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的 .NET 库之一用于处理 JSON 序列化格式是 **Newtonsoft.Json**，也称为 **Json.NET**。它成熟且功能强大。
- en: '`Newtonsoft.Json` is so popular that it overflowed the bounds of the 32-bit
    integer used for the download count in the NuGet package manager, as shown in
    the following post in *Figure 9.5*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`Newtonsoft.Json` 非常受欢迎，以至于它溢出了 NuGet 包管理器中用于下载计数的 32 位整数的界限，如下所示 *图 9.5*：'
- en: '![](img/B22322_09_05.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_09_05.png)'
- en: 'Figure 9.5: Negative 2 billion downloads for Newtonsoft.Json in August 2022'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：2022 年 8 月 Newtonsoft.Json 的下载量达到负 20 亿
- en: 'Let’s see it in action:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果：
- en: 'In the `WorkingWithSerialization` project, add a package reference for the
    latest version of `Newtonsoft.Json`, as shown in the following markup:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithSerialization` 项目中，添加对最新版本 `Newtonsoft.Json` 的包引用，如下所示：
- en: '[PRE51]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Build the `WorkingWithSerialization` project to restore packages.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `WorkingWithSerialization` 以恢复包。
- en: 'In `Program.cs`, add statements to create a text file, and then serialize the
    people into the file as JSON, as shown in the following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加创建文本文件的语句，然后将人员序列化为 JSON 文件，如下所示：
- en: '[PRE52]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the code, and note that JSON requires fewer than half the number of bytes
    compared to XML with elements. It’s even smaller than the XML file, which uses
    attributes (366 compared to 488), as shown in the following output:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意 JSON 相比于具有元素的 XML 所需的字节数更少。它甚至比使用属性的 XML 文件更小（366 与 488 相比），如下所示：
- en: '[PRE53]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: High-performance JSON processing
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高性能 JSON 处理
- en: .NET Core 3 introduced a new namespace to work with JSON, `System.Text.Json`,
    which is optimized for performance by leveraging APIs like `Span<T>`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3 引入了一个新的命名空间来处理 JSON，`System.Text.Json`，它通过利用 `Span<T>` 等API来优化性能。
- en: Also, older libraries like `Json.NET` are implemented by reading UTF-16\. It
    would be more performant to read and write JSON documents using UTF-8 because
    most network protocols, including HTTP, use UTF-8, and you can avoid transcoding
    UTF-8 to and from Json.NET’s Unicode `string` values.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像 `Json.NET` 这样的旧库是通过读取 UTF-16 实现的。使用 UTF-8 读取和写入 JSON 文档将更高效，因为大多数网络协议，包括
    HTTP，都使用 UTF-8，你可以避免将 UTF-8 转换为和从 Json.NET 的 Unicode `string` 值转换。
- en: With the new API, Microsoft achieved between 1.3x and 5x improvement, depending
    on the scenario.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 API，Microsoft 在不同场景下实现了 1.3x 到 5x 的性能提升。
- en: 'The original author of Json.NET, James Newton-King, joined Microsoft and is
    working with them to develop their new JSON types. As he says in a comment discussing
    the new JSON APIs, “*Json.NET isn’t going away*,” as shown in *Figure 9.6*:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Json.NET 的原始作者 James Newton-King 加入微软，并与他们一起开发新的 JSON 类型。正如他在讨论新 JSON API 的注释中所说，“*Json.NET
    不会消失*”，如下所示 *图 9.6*：
- en: '![](img/B22322_09_06.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_09_06.png)'
- en: 'Figure 9.6: A comment by the original author of Json.NET'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：Json.NET 原作者的注释
- en: Deserializing JSON files
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反序列化 JSON 文件
- en: 'Let’s see how to use the modern JSON APIs to deserialize a JSON file:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用现代 JSON API 来反序列化一个 JSON 文件：
- en: 'In the `WorkingWithSerialization` project, at the top of `Program.cs`, import
    the new JSON class to perform serialization, using an alias to avoid conflicting
    names with the Json.NET one we used before, as shown in the following code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithSerialization` 项目中，在 `Program.cs` 的顶部，导入新的 JSON 类以执行序列化，使用别名以避免与之前使用的
    Json.NET 名称冲突，如下所示：
- en: '[PRE54]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `Program.cs`, add statements to open the JSON file, deserialize it, and
    output the names and counts of the children of the people, as shown in the following
    code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加打开 JSON 文件、反序列化它并输出人员的姓名和子女数量的语句，如下所示：
- en: '[PRE55]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE56]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Good Practice**: Choose Json.NET for developer productivity and a large feature
    set, or `System.Text.Json` for performance. You can review a list of the differences
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#table-of-differences-between-newtonsoftjson-and-systemtextjson](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#table-of-differences-between-newtonsoftjson-and-systemtextjson).'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：选择 Json.NET 以提高开发效率和功能集，或选择 `System.Text.Json` 以提高性能。您可以在以下链接中查看差异列表：[https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#table-of-differences-between-newtonsoftjson-and-systemtextjson](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#table-of-differences-between-newtonsoftjson-and-systemtextjson)。'
- en: JSON schema exporter
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 架构导出器
- en: .NET 9 introduced a class to make it easy to generate JSON schemas for .NET
    types. As a result, serialization is simplified and data conforms to expected
    formats.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9 引入了一个类，用于轻松为 .NET 类型生成 JSON 架构。因此，序列化简化了，数据符合预期的格式。
- en: 'Let’s see a working example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个工作示例：
- en: 'In the `WorkingWithSerialization` project, at the top of `Program.cs`, import
    the namespaces to perform JSON serialization and work with JSON schemas, as shown
    in the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithSerialization` 项目中，在 `Program.cs` 文件的顶部，导入执行 JSON 序列化和处理 JSON
    架构所需的命名空间，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In `Program.cs`, add statements to export the JSON schema for the `Person`
    class, as shown in the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加导出 `Person` 类 JSON 架构的语句，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE59]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Controlling JSON processing
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制JSON处理
- en: 'There are many options to take control of how JSON is processed, as shown in
    the following list:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可以控制 JSON 的处理方式，如下面的列表所示：
- en: Including and excluding fields
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含和排除字段
- en: Setting a casing policy
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置大小写策略
- en: Selecting a case-sensitivity policy
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择大小写敏感策略
- en: Choosing between compact and prettified whitespace
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择紧凑格式和格式化空格
- en: 'Let’s see some in action:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些实际操作：
- en: Use your preferred code editor to add a new **Console App** / `console` project,
    named `ControllingJson`, to the `Chapter09` solution.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器向 `Chapter09` 解决方案中添加一个名为 `ControllingJson` 的新 **Console App** /
    `console` 项目。
- en: In the project file, add elements to statically and globally import the `System.Console`,
    `System.Environment`, and `System.IO.Path` classes.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加元素以静态和全局导入 `System.Console`、`System.Environment` 和 `System.IO.Path`
    类。
- en: In the `ControllingJson` project, add a new class file named `Book.cs`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ControllingJson` 项目中，添加一个名为 `Book.cs` 的新类文件。
- en: 'In `Book.cs`, define a class named `Book`, as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Book.cs` 文件中，定义一个名为 `Book` 的类，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `Program.cs`, delete the existing statements, and then import the namespaces
    to work with high-performance JSON and `Book`, as shown in the following code:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后导入处理高性能 JSON 和 `Book` 的命名空间，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In `Program.cs`, add statements to create an instance of the `Book` class and
    serialize it to JSON, as shown in the following code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加创建 `Book` 类实例并将其序列化为 JSON 的语句，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE63]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The JSON file is 221 bytes.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 文件大小为 221 字节。
- en: The member names use camelCasing, for example, `publishDate`. This is best for
    subsequent processing in a browser with JavaScript.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员名称使用驼峰式大小写，例如，`publishDate`。这对于在浏览器中使用 JavaScript 进行后续处理最佳。
- en: All fields are included due to the options set, including `pages`.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于设置了选项，所有字段都被包含在内，包括 `pages`。
- en: JSON is prettified for easier human legibility.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 被格式化以方便人类阅读。
- en: '`DateTime` and `DateTimeOffset` values are stored as a single standard `string`
    format.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime` 和 `DateTimeOffset` 值存储为单个标准 `string` 格式。'
- en: In `Program.cs`, when setting the `JsonSerializerOptions`, comment out the setting
    of a casing policy, write with an indent, and include fields.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，当设置 `JsonSerializerOptions` 时，取消注释大小写策略的设置，使用缩进并包含字段。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE64]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Note the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The JSON file has about a 20% reduction.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 文件大约减少了 20%。
- en: The member names use normal casing, for example, `PublishDate`.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员名称使用常规大小写，例如，`PublishDate`。
- en: The `Pages` field is missing. The other fields are included due to the `[JsonInclude]`
    attribute on the `PublishDate` and `Created` fields.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages` 字段缺失。其他字段由于 `PublishDate` 和 `Created` 字段上的 `[JsonInclude]` 属性而被包含。'
- en: A warning about binary serialization using BinaryFormatter
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于使用 BinaryFormatter 进行二进制序列化的警告
- en: The `BinaryFormatter` class is a serialization class that can convert a live
    object, or a graph of connected objects, into a binary format that can be stored
    or transmitted and later reconstructed. This class has been part of .NET since
    its early versions and is in the `System.Runtime.Serialization.Formatters.Binary`
    namespace. But `BinaryFormatter` is problematic for several reasons, primarily
    related to security and robustness.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryFormatter` 类是一个序列化类，可以将活动对象或连接对象图转换为可以存储或传输的二进制格式，并且可以在以后重建。这个类自 .NET
    的早期版本以来一直是其一部分，位于 `System.Runtime.Serialization.Formatters.Binary` 命名空间中。但是，`BinaryFormatter`
    存在几个问题，主要与安全和健壮性相关。'
- en: For example, `BinaryFormatter` is vulnerable to deserialization attacks, where
    malicious input can execute arbitrary code during the deserialization process.
    This makes any application using `BinaryFormatter` susceptible to **remote code
    execution** (**RCE**) if an attacker can control the serialized data. `BinaryFormatter`
    does not perform any validation or checks on the data it deserializes, making
    it inherently insecure when handling untrusted data.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`BinaryFormatter` 易受反序列化攻击的影响，恶意输入可以在反序列化过程中执行任意代码。这使得任何使用 `BinaryFormatter`
    的应用程序如果攻击者可以控制序列化数据，就会容易受到**远程代码执行**（**RCE**）的影响。`BinaryFormatter` 对其反序列化的数据不执行任何验证或检查，因此在处理不受信任的数据时固有不安全。
- en: '`BinaryFormatter` does not support many modern serialization features, like
    JSON or XML serialization capabilities, which are more secure and flexible.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryFormatter` 不支持许多现代序列化功能，如 JSON 或 XML 序列化能力，这些功能更安全且更灵活。'
- en: '**Good Practice**: Microsoft recommends using serialization libraries like
    `System.Text.Json`, `System.Xml.Serialization`, or `Google.Protobuf`.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：微软建议使用 `System.Text.Json`、`System.Xml.Serialization` 或 `Google.Protobuf`
    等序列化库。'
- en: In the first version of .NET Core, the Microsoft team removed `BinaryFormatter`
    entirely due to its known risks, but without a clear path to using something safer,
    customers demanded that it be brought back, which the team did with .NET Core
    1.1\. Since then, the team has disabled it by default but allowed developers to
    explicitly re-enable it, by setting flags if they accept the risks.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 的第一个版本中，由于已知的风险，微软团队完全移除了 `BinaryFormatter`，但因为没有明确的路径使用更安全的东西，客户要求将其恢复，团队在
    .NET Core 1.1 中实现了这一点。从那时起，团队默认禁用了它，但允许开发者通过设置标志明确重新启用它，如果他们接受这些风险。
- en: With .NET 9, the flags to enable `BinaryFormatter` have been removed, and any
    use of it will throw an exception. But there is still a way to re-enable it, by
    referencing a NuGet package marked as being permanently vulnerable and setting
    some configuration.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 9 中，启用 `BinaryFormatter` 的标志已被移除，任何使用它的尝试都会抛出异常。但仍然有一种方法可以重新启用它，通过引用标记为永久性易受攻击的
    NuGet 包并设置一些配置。
- en: '**More Information**: You can learn more about why and how the `BinaryFormatter`
    class is being removed in .NET 9 at the following link: `https://devblogs.microsoft.com/dotnet/binaryformatter-removed-from-dotnet-9/`.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于为什么以及如何在 .NET 9 中移除 `BinaryFormatter` 类的信息：`https://devblogs.microsoft.com/dotnet/binaryformatter-removed-from-dotnet-9/`。'
- en: Practicing and exploring
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with more in-depth research.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作练习，并更深入地研究本章的主题来测试您的知识和理解。
- en: Exercise 9.1 – Online material
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.1 – 在线材料
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是我为这本书写的额外内容，也可以是引用微软或第三方创建的内容。
- en: Working with tar archives
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 tar 存档一起工作
- en: 'If you use Linux, then you will be interested in how to programmatically work
    with tar archives. I have written an online-only section to introduce you to them
    that can be found at the following link:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Linux，那么您可能对如何以编程方式处理 tar 存档感兴趣。我编写了一个仅在线的部分，介绍这些内容，您可以在以下链接中找到：`https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md`。
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md)'
- en: Migrating from Newtonsoft to new JSON
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Newtonsoft 迁移到新的 JSON
- en: 'If you have existing code that uses the Newtonsoft `Json.NET` library and you
    want to migrate to the new `System.Text.Json` namespace, then Microsoft has specific
    documentation for that, which you can find at the following link:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现有的代码使用了 Newtonsoft `Json.NET` 库，并且你想迁移到新的 `System.Text.Json` 命名空间，那么微软有针对这一点的特定文档，你可以在以下链接中找到：
- en: '[https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
- en: Exercise 9.2 – Practice exercises
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.2 – 练习题
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题深入探讨了本章的主题。
- en: Serializing as XML
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以 XML 格式序列化
- en: 'In the `Chapter09` solution, create a console app named `Exercise_SerializingShapes`
    that creates a list of shapes, uses serialization to save it to the filesystem
    with XML, and then deserializes it back:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter09` 解决方案中，创建一个名为 `Exercise_SerializingShapes` 的控制台应用程序，该程序创建一个形状列表，使用序列化将其保存到文件系统中以
    XML 格式，然后将其反序列化回来：
- en: '[PRE65]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Shapes should have a read-only property named `Area` so that when you deserialize,
    you can output a list of shapes, including their areas, as shown here:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 形状应该有一个名为 `Area` 的只读属性，这样在反序列化时，你可以输出一个包含其面积的形状列表，如下所示：
- en: '[PRE66]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is what your output should look like when you run your console application:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行你的控制台应用程序时，你的输出应该看起来像这样：
- en: '[PRE67]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Exercise 9.3 – Test your knowledge
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is the difference between using the `File` class and the `FileInfo` class?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `File` 类和 `FileInfo` 类有什么区别？
- en: What is the difference between the `ReadByte` method and the `Read` method of
    a stream?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流的 `ReadByte` 方法与 `Read` 方法的区别是什么？
- en: When would you use the `StringReader`, `TextReader`, and `StreamReader` classes?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在什么情况下使用 `StringReader`、`TextReader` 和 `StreamReader` 类？
- en: What does the `DeflateStream` type do?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DeflateStream` 类型的作用是什么？'
- en: How many bytes per character does UTF-8 encoding use?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UTF-8 编码每字符使用多少字节？
- en: What is an object graph?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象图是什么？
- en: What is the best serialization format to choose to minimize space requirements?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择哪种序列化格式以最小化空间需求最好？
- en: What is the best serialization format to choose for cross-platform compatibility?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于跨平台兼容性，选择哪种序列化格式最好？
- en: Why is it bad to use a `string` value like `"\Code\Chapter01"` to represent
    a path, and what should you do instead?
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用像 `"\Code\Chapter01"` 这样的 `string` 值来表示路径是糟糕的，你应该做什么？
- en: Where can you find information about NuGet packages and their dependencies?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在哪里可以找到有关 NuGet 包及其依赖项的信息？
- en: Exercise 9.4 – Explore topics
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.4 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-9---working-with-files-streams-and-serialization](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-9---working-with-files-streams-and-serialization](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何：
- en: Read from and write to text files.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本文件中读取和写入。
- en: Read from and write to XML files.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 XML 文件中读取和写入。
- en: Compress and decompress files.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩和解压缩文件。
- en: Encode and decode text.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和解码文本。
- en: Serialize an object graph into JSON and XML.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象图序列化为 JSON 和 XML。
- en: Deserialize an object graph from JSON and XML.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 JSON 和 XML 中反序列化对象图。
- en: In the next chapter, you will learn how to work with databases using Entity
    Framework Core.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 Entity Framework Core 与数据库一起工作。
