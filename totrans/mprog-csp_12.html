<html><head></head><body>
		<div><h1 id="_idParaDest-132" class="chapter-number"><a id="_idTextAnchor196"/>12</h1>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor197"/>Go Beyond Inheritance</h1>
			<p>With object-oriented languages such as C#, we can derive our types from other types and we can also implement contracts (interfaces) and make them fulfill that contract. Implementing interfaces and making an implementation fulfill these is really one of the great things about a type-safe language. With the compiler, we get everything checked to make sure we implement the contract, while at runtime, we can leverage the interface type to be a representation rather than having to know the actual implementor.</p>
			<p>Sometimes, however, the verbosity of having to implement an interface can be too much. It can also be limited to what you’re trying to achieve.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Method signature conventions</li>
				<li>By the end of the chapter, you will have an idea of how conventions can let you go beyond having to inherit from a base type or an interface and how that sometimes caters to a cleaner code base.</li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor198"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12</a>) and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found at <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor199"/>Method signature conventions</h1>
			<p>Coming up with good <a id="_idIndexMarker433"/>examples to do a home run on a topic for a book can be very hard. For this chapter, I’ve decided to go with something that is part of my day-to-day job.</p>
			<p>I work with a platform that is centered around event-driven architecture, or more specifically, with event sourcing. This topic might be unfamiliar to you, so let’s dive into what this specifically is, to give you the context.</p>
			<p>In traditional <strong class="bo d">CRUD</strong> (short for <strong class="bo d">Create, Read, Update, Delete</strong>) systems, the primary focus is on the concrete data that is<a id="_idIndexMarker434"/> commonly stored in a relational or document database. These systems revolve around the four fundamental operations – creating new records, retrieving existing records, updating records, and deleting records.</p>
			<p>The data in such systems represents the outcome of a user’s actions, and the system’s flow typically follows a one-to-one mapping from the user’s input form to the database. However, this approach to software development has a significant drawback – it only captures the effect and not the cause.</p>
			<p>With event sourcing, the effect is less important, and it’s all about capturing what caused the effect. The cause captures how we got to the conclusion, as shown in the following diagram:</p>
			<div><div><img src="img/B19418_12_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Capturing the cause</p>
			<p>The cause is <a id="_idIndexMarker435"/>what is known as an event – something that happened in the system. We capture these by giving them a clear name, and we store them in the sequence in which they occur. The events are never deleted. All events are stored in what is referred to as<a id="_idIndexMarker436"/> an <strong class="bo d">event store</strong>. There are technologies out there that specialize in this, such as the platform I’m working on, called Cratis (<a href="https://cratis.io">https://cratis.io</a>),
but <a id="_idIndexMarker437"/>you could also use any database and do this yourself.</p>
			<p>By prioritizing the capturing of events, we gain the ability to control how the effects are presented. This is achieved by extracting relevant information from various event types as they occur and then converting it into specialized objects for easy access. These objects are typically stored in conventional data stores such as relational or document databases, which allow for the efficient querying of the end result.</p>
			<p>One major advantage of this approach is that the event store becomes the source of truth in the system rather than relying solely on traditional data stores. This means that modifying how data is represented becomes significantly easier, as you can simply replay the relevant events when implementing changes. You can also decide to have multiple representations, catering to special needs within a system. This could then have a huge performance benefit, as well as clarity in code, and avoiding tension often seen in developing systems where one shares the same data and objects.</p>
			<p>The following figure shows an imaginary bank system with events being produced and how they are projected down to materialized objects, referred to as read models. It also shows the relationship with other systems or other microservices in a microservice-centric architecture by projecting to events that can be communicated outside of the bounds of the system-producing events.</p>
			<div><div><img src="img/B19418_12_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Imaginary bank system with events produced</p>
			<p>The<a id="_idIndexMarker438"/> observer is a key element of this architecture. They are the ones responsible for observing the events as they occur and creating an effect. For the most part, the effect comes in the form of a projection to a read model that is stored, but it could also perform other tasks such as sending emails or, in fact, append new events as the consequence of an analysis the observer performs.</p>
			<p>It’s these observers that we want to bring forward as an example in this chapter. Let’s narrow it down to a pipeline that looks like the following figure:</p>
			<div><div><img src="img/B19418_12_03.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Logical pipeline</p>
			<p>A command <a id="_idIndexMarker439"/>represents something the user desires, an action to be performed. The action typically would then decide what event, or possibly multiple events, it should generate. This is appended to the main event log within the event store. The event log is the event sequence that holds all the events in the order they occurred, with an incremental sequence number.</p>
			<p>Once the event is in the event log, we want to notify all the interested observers that the event has been appended and they should react.</p>
			<p>The following figure shows more concretely what we want to accomplish and will be the basis of the example in this chapter.</p>
			<div><div><img src="img/B19418_12_04.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Concrete pipeline</p>
			<p>In order to be able to do this, you’re going to need some infrastructure that will give you the convention<a id="_idTextAnchor200"/>s.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor201"/>Infrastructure</h1>
			<p>Let’s create a bare foundation of what’s<a id="_idIndexMarker440"/> needed for having observers that can respond to events being appended.</p>
			<p>Let’s create a folder called <strong class="source-in ine">Chapter12</strong> at the root of your repository. Change into this folder in your command-line interface and create a new console project:</p>
			<pre class="source-code">
dotnet new console</pre>
			<p>You’re going to make use of the Microsoft hosting model to get the .NET default service provider without spinning up a web application. To achieve this, you’ll need the package called <strong class="source-in ine">Microsoft.Extensions.Hosting</strong>. In the terminal, you’d add the reference by doing the following:</p>
			<pre class="source-code">
dotnet add package Microsoft.Extensions.Hosting</pre>
			<p>The next thing you’ll need to do is to reference the <strong class="source-in ine">Fundamentals</strong> project. In the terminal, do the following:</p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p>As I discussed in <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, one of the things I do in all my code is to formalize types rather than use primitives. This makes the APIs much clearer and also helps avoid mistakes.</p>
			<p>You’re going to be using <strong class="source-in ine">ConceptAs&lt;&gt;</strong> to formalize the types.</p>
			<p>Inside the <strong class="source-in ine">Chapter12</strong> folder, create a folder dedicated to the <strong class="source-in ine">EventSourcing</strong> infrastructure, and call this folder <strong class="source-in ine">EventSourcing</strong>.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventSourceId.cs</strong> and make it look<a id="_idIndexMarker441"/> like the following:</p>
			<pre class="source-code">
using Fundamentals;
namespace EventSourcing;
public record EventSourceId(string Value) :
  ConceptAs&lt;string&gt;(Value)
{
    public static EventSourceId New() =&gt;
      new(Guid.NewGuid().ToString());
}</pre>
			<p>The <strong class="source-in ine">EventSourceId</strong> concept represents the unique identifier of the source of events. In domain modeling, this is typically the identifier of an object, a noun, in your domain. An example of this could be the unique identifier of a bank account or the unique identifier of a person in the system. The <strong class="source-in ine">EventSourceId</strong> code sets up <strong class="source-in ine">ConceptAs&lt;&gt;</strong> for this and makes the inner value a string, enabling basically any representation of a unique identifier. It adds a convenient method for creating a new <strong class="source-in ine">EventSourceId</strong> by leveraging <strong class="source-in ine">Guid</strong>, which can then generate a unique identifier on the fly. You’ll be using <strong class="source-in ine">EventSourceId</strong> later and it should become clearer why it’s needed.</p>
			<p>When appending an event to a sequence of events, as we discussed earlier, every event gets a sequence number. This is an incremental number that increases by 1 for every event added. Let’s <a id="_idIndexMarker442"/>formalize a type that represents this number.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventSequenceNumber.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using Fundamentals;
namespace EventSourcing;
public record EventSequenceNumber(ulong Value) :
  ConceptAs&lt;ulong&gt;(Value)
{
    public static implicit operator
      EventSequenceNumber(ulong value) =&gt; new(value);
}</pre>
			<p>The code introduces a concrete type for <strong class="source-in ine">EventSequenceNumber</strong> that is <strong class="source-in ine">ConceptAs&lt;&gt;</strong> with its inner value of the <strong class="source-in ine">ulong</strong> type. With <strong class="source-in ine">ulong</strong>, you get a full 64-bit value and this should most likely be more than sufficient as an incremental sequence number. For convenience, there is also an implicit operator that can convert <strong class="source-in ine">ulong</strong> to the encapsulated <strong class="source-in ine">EventSequenceNumber</strong> type.</p>
			<p>For the observers that you’ll be adding later, you’ll be marking them with an attribute to indicate they are an observer. An alternative to this would be to use an empty interface. The point of this is just to be able to mark a type, making it possible to discover.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">ObserverAttribute.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace EventSourcing;
[AttributeUsage(AttributeTargets.Class, AllowMultiple =
  false)]
public sealed class ObserverAttribute : Attribute
{
}</pre>
			<p>The code introduces an attribute that can be added to classes.</p>
			<p>For the observer methods, you typically find the information related to the event in addition to the actual <a id="_idIndexMarker443"/>event itself. The type of information you want to know is the <strong class="source-in ine">EventSourceId</strong>, <strong class="source-in ine">EventSequenceNumber</strong>, and when the event occurred. We call this <strong class="source-in ine">EventContext</strong>.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventContext.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace EventSourcing;
public record EventContext(
    EventSourceId EventSourceId,
    EventSequenceNumber SequenceNumber,
    DateTimeOffset Occurred);</pre>
			<p>The code holds <strong class="source-in ine">EventSourceId</strong>, <strong class="source-in ine">SequenceNumber</strong>, and <strong class="source-in ine">Occurred</strong> in the form of <strong class="source-in ine">DateTimeOffset</strong>. In a full event-sourced system, we would typically hold more details, but this will suffice for this example.</p>
			<p>For the events to be discoverable and classified as events, you’re going to need a building block in the infrastructure.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">IEvent.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace EventSourcing;
public interface IEvent { }</pre>
			<p>Now comes the juicy <a id="_idIndexMarker444"/>part: the code that will discover methods on a type that matches certain criteria.</p>
			<p>The convention we’re looking for is one that allows for two base method signatures and two variants of these, supporting both synchronous and asynchronous models.</p>
			<p>The synchronous signatures are as follows:</p>
			<pre class="source-code">
void &lt;name-of-method&gt;(YourEventType @event);
void &lt;name-of-method&gt;(YourEventType @event, EventContext
  context);</pre>
			<p>And then the asynchronous signatures are as follows:</p>
			<pre class="source-code">
Task &lt;name-of-method&gt;(YourEventType @event);
Task &lt;name-of-method&gt;(YourEventType @event, EventContext
  context);</pre>
			<p>As you can see, the convention does not care about the name of the method but only the parameters and return types. This gives flexibility to the developer in creating more precise named methods and increases the readability and maintainability of the code, something regular inheritance wouldn’t allow for.</p>
			<p>Let’s create a system that enables calling the methods by convention.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">ObserverHandler.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using System.Reflection;
namespace EventSourcing;
public class ObserverHandler
{
    readonly Dictionary&lt;Type, IEnumerable&lt;MethodInfo&gt;&gt;
      _methodsByEventType;
    readonly IServiceProvider _serviceProvider;
    readonly Type _targetType;
    public IEnumerable&lt;Type&gt; EventTypes =&gt;
      _methodsByEventType.Keys;
    public ObserverHandler(IServiceProvider
      serviceProvider, Type targetType)
    {
        _serviceProvider = serviceProvider;
        _targetType = targetType;
        _methodsByEventType =
          targetType.GetMethods(BindingFlags.Instance |
          BindingFlags.NonPublic | BindingFlags.Public)
                                        .Where(_ =&gt;
                                      IsObservingMethod(_))
                                        .GroupBy(_ =&gt;
                                      _.GetParameters()[0].
                                      ParameterType)
                                        .ToDictionary(_ =&gt;
                                      _.Key, _ =&gt;
                                      _.ToArray()
                                      .AsEnumerable());
    }
}</pre>
			<p>The code sets up the basis for the <strong class="source-in ine">ObserverHandler</strong> class. The constructor takes two parameters, <strong class="source-in ine">serviceProvider</strong> and <strong class="source-in ine">targetType</strong>. The <strong class="source-in ine">serviceProvider</strong> parameter will be used to get instances of <strong class="source-in ine">targetType</strong> representing the observer when an event needs to be handled. Within the constructor, the code uses reflection to look for instance methods, both <a id="_idIndexMarker445"/>public and non-public methods.</p>
			<p>It then filters down the methods by those matching the signature with a method called <strong class="source-in ine">IsObservingMethod()</strong>, which you’ll be adding next. Then it groups it by the first parameter on the method, which is the event type, and creates a dictionary enabling fast lookup.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Notice the <strong class="source-in ine">EventTypes</strong> property that is added; this exposes what event types the handler supports, and this will come in handy later.</p>
			<p>In the LINQ query, it uses the <strong class="source-in ine">IsObservingMethod()</strong> method, which is a method that should be inside the <strong class="source-in ine">ObserverHandler</strong> class. Add the following private method at the bottom of the <strong class="source-in ine">ObserverHandler</strong> class:</p>
			<pre class="source-code">
bool IsObservingMethod(MethodInfo methodInfo)
{
    var isObservingMethod =
      methodInfo.ReturnType.IsAssignableTo(typeof(Task)) ||
                            methodInfo.ReturnType ==
                              typeof(void);
    if (!isObservingMethod) return false;
    var parameters = methodInfo.GetParameters();
    if (parameters.Length &gt;= 1)
    {
        isObservingMethod = parameters[0]
          .ParameterType.IsAssignableTo(typeof(IEvent));
        if (parameters.Length == 2)
        {
            isObservingMethod &amp;= parameters[1]
              .ParameterType == typeof(EventContext);
        }
        else if (parameters.Length &gt; 2)
        {
            isObservingMethod = false;
        }
        return isObservingMethod;
    }
    return false;
}</pre>
			<p>To identify allowed signatures, the code examines <strong class="source-in ine">MethodInfo</strong> and begins by recognizing the permitted return types, which are <strong class="source-in ine">Task</strong> or <strong class="source-in ine">void</strong>. If the return type is anything other than a valid observing method, it will be considered invalid. The code then proceeds to examine the parameters of the method. If the method has one parameter and its type <a id="_idIndexMarker446"/>implements the <strong class="source-in ine">IEvent</strong> interface, it qualifies as an observing method. Alternatively, if the method has two parameters and the first parameter type implements <strong class="source-in ine">IEvent</strong>, and the second parameter type is <strong class="source-in ine">EventContext</strong>, then it is also classified as an observing method.</p>
			<p>With the <a id="_idIndexMarker447"/>discovery part in place, all you need is a method that understands the convention and can invoke the method on the observer.</p>
			<p>In the <strong class="source-in ine">ObserverHandler</strong> class, add the following code:</p>
			<pre class="source-code">
public async Task OnNext(IEvent @event, EventContext
  context)
{
    var eventType = @event.GetType();
    if (_methodsByEventType.ContainsKey(eventType))
    {
        var actualObserver =
          _serviceProvider.GetService(_targetType);
        Task returnValue;
        foreach (var method in
          _methodsByEventType[eventType])
        {
            var parameters = method.GetParameters();
            if (parameters.Length == 2)
            {
                returnValue =
                  (Task)method.Invoke(actualObserver, new
                  object[] { @event, context })!;
            }
            else
            {
                returnValue =
                  (Task)method.Invoke(actualObserver, new
                  object[] { @event })!;
            }
            if (returnValue is not null) await returnValue;
        }
    }
}</pre>
			<p>The <strong class="source-in ine">OnNext()</strong> method<a id="_idIndexMarker448"/> is responsible for doing the call to the observer; it does so by taking an event of any type implementing the <strong class="source-in ine">IEvent</strong> interface and <strong class="source-in ine">EventContext</strong> for the event. From this, it finds the method in <strong class="source-in ine">_methodsByEventType</strong> populated in the constructor based on the type of event supported by the observer. If it is supported, it goes on to get an instance of the observer type by using the service provider. For each method, it invokes based on the correct signature for the method and if the method is asynchronous, it will await <strong class="source-in ine">Task</strong> returned.</p>
			<p>With the concrete handler that handles the invocation, you’re going to need a service that knows about all the observers and can call the correct ones when an event occurs.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">IObservers.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace EventSourcing;
public interface IObservers
{
    Task OnNext(IEvent @event, EventContext context);
}</pre>
			<p>The code<a id="_idIndexMarker449"/> represents the contract for <strong class="source-in ine">IObservers</strong>. The <strong class="source-in ine">OnNext()</strong> method will be the method called by the system that knows when events have occurred.</p>
			<p>You’re going to need an implementation of this interface.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">Observers.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using System.Reflection;
using Fundamentals;
namespace EventSourcing;
[Singleton]
public class Observers : IObservers
{
    readonly IEnumerable&lt;ObserverHandler&gt; _handlers;
    public Observers(ITypes types, IServiceProvider
      serviceProvider)
    {
        _handlers = types.All.Where(_ =&gt;
          _.HasAttribute&lt;ObserverAttribute&gt;())
                            .Select(_ =&gt;
                            {
                                var observer =
                                  _.GetCustomAttribute
                                  &lt;ObserverAttribute&gt;()!;
                                return new
                                  ObserverHandler(
                                  serviceProvider, _);
                            });
    }
}</pre>
			<p>The code leverages <strong class="source-in ine">ITypes</strong> from fundamentals for discovery. The code scans through all the types and filters out those that do not have <strong class="source-in ine">ObserverAttribute</strong>, leaving only the types that do have it. For every type that has the <strong class="source-in ine">ObserverAttribute</strong>, it then creates an instance of <strong class="source-in ine">ObserverHandler</strong> by passing in <strong class="source-in ine">serviceProvider</strong> and the target type, which is the observer itself.</p>
			<p>For invoking the handler, you need an implementation of the <strong class="source-in ine">OnNext()</strong> method. In the <strong class="source-in ine">Observers</strong> class, add the following method at the bottom:</p>
			<pre class="source-code">
public Task OnNext(IEvent @event, EventContext context)
{
    var tasks = _handlers.Where(_ =&gt;
      _.EventTypes.Contains(@event.GetType()))
                        .Select(_ =&gt; _.OnNext(@event,
                          context));
    return Task.WhenAll(tasks);
}</pre>
			<p>The code filters<a id="_idIndexMarker450"/> down to only the handlers that are capable by looking at the <strong class="source-in ine">EventTypes</strong> property of the handler, and whether it contains the type of the <strong class="source-in ine">@event</strong> argument. It then calls the <strong class="source-in ine">OnNext()</strong> method of the handler and collects all the <strong class="source-in ine">Task</strong> instances for all the calls it made, so that it can wait for them all to finish.</p>
			<p>With the observer infrastructure in place, you’ll need something that triggers this. We’re not going to implement a fully working event sourcing system, as that would be too involved. Instead, we’re going to make a few shortcuts and not save the events anywhere.</p>
			<p>In an event-sourced system, you need a place to append the events to a sequence; the main place you <a id="_idIndexMarker451"/>append to is called an event log. Let’s introduce this concept.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">IEventLog.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace EventSourcing;
public interface IEventLog
{
    Task Append(EventSourceId eventSourceId, IEvent
      @event);
}</pre>
			<p>The code represents the contract for the event log with only one method in this version, which enables you to append an event for a specific <strong class="source-in ine">EventSourceId</strong>.</p>
			<p>You’ll need an implementation of the <strong class="source-in ine">IEventLog</strong> interface.</p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventLog.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace EventSourcing;
public class EventLog : IEventLog
{
    readonly IObservers _observers;
    EventSequenceNumber _sequenceNumber = 0;
    public EventLog(IObservers observers)
    {
        _observers = observers;
    }
    public async Task Append(EventSourceId eventSourceId,
      IEvent @event)
    {
        // TODO: persist the event
        await _observers.OnNext(
            @event,
            new EventContext(eventSourceId,
              _sequenceNumber, DateTimeOffset.UtcNow));
        _sequenceNumber++;
    }
}</pre>
			<p>The code <a id="_idIndexMarker452"/>represents a very simplistic implementation that takes a direct dependency on <strong class="source-in ine">IObservers</strong> for it to call when an event has been appended. It manages internally the <strong class="source-in ine">_sequenceNumber</strong>. As you can see, there is no persistence and the whole implementation is naive at best. But it serves the purpose of this chapter.</p>
			<p>Now that you have built all this nice infrastructure for invoking methods by the convention on observers, you’re probably eager to take it <a id="_idTextAnchor202"/>out for a spin.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor203"/>Using the infrastructure</h1>
			<p>Going with the bank <a id="_idIndexMarker453"/>theme of the chapter, let’s create something that represents that domain. In a bank, you can open an account, deposit and withdraw money from it, and then possibly, and ultimately, close an account. All of these are very important events that happen in the lifespan of an account.</p>
			<p>Within the root folder of the chapter code, create a file called <strong class="source-in ine">Events.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using EventSourcing;
namespace Chapter12;
public record BankAccountOpened(string CustomerName) :
  IEvent;
public record BankAccountClosed() : IEvent;
public record DepositPerformed(decimal Amount) : IEvent;
public record WithdrawalPerformed(decimal Amount) : IEvent;</pre>
			<p>The code holds all the events we want for now as <strong class="source-in ine">record</strong> types and they all implement the <strong class="source-in ine">IEvent</strong> interface.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">In a production environment, I would recommend keeping one file per type, as that makes it easier to navigate and discover events in your system.</p>
			<p>With the events in place, you can now go ahead and create observers that will react to the events occurring.</p>
			<p>Within the root folder of the chapter code, create a file called <strong class="source-in ine">AccountLifecycle.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using EventSourcing;
namespace Chapter12;
[Observer]
public class AccountLifecycle
{
    public Task Opened(BankAccountOpened @event)
    {
        Console.WriteLine($"Account opened for
          {@event.CustomerName}");
        return Task.CompletedTask;
    }
    public Task Closed(BankAccountClosed @event,
      EventContext context)
    {
        Console.WriteLine($"Account with id
          {context.EventSourceId} closed");
        return Task.CompletedTask;
    }
}</pre>
			<p>The code adds a<a id="_idIndexMarker454"/> class called <strong class="source-in ine">AccountLifecycle</strong> and adorns it with the <strong class="source-in ine">[Observer]</strong> attribute. Its purpose is to only deal with the life cycle events of <strong class="source-in ine">BankAccountOpened</strong> and <strong class="source-in ine">BankAccountClosed</strong>. Notice that it uses the convention fully with custom names of the methods and also the different signatures.</p>
			<p>For the events that affect the balance of an account, you could then separate that particular logic into its own observer.</p>
			<p>Within the <a id="_idIndexMarker455"/>root folder of the chapter code, create a file called <strong class="source-in ine">AccountBalance.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using EventSourcing;
namespace Chapter12;
[Observer]
public class AccountBalance
{
    public Task DepositPerformed(DepositPerformed @event,
      EventContext context)
    {
        Console.<a href="mailto:%7b@event.Amount%7d">WriteLine($"Dep</a>osit of {@event.Amount}
          performed on {context.EventSourceId}");
        return Task.CompletedTask;
    }
    public Task WithdrawalPerformed(WithdrawalPerformed
      @event, EventContext context)
    {
        Console.Wri<a href="mailto:%7b@event.Amount%7d">teLine($"Withdr</a>awal of {@event.Amount}
          performed on {context.EventSourceId}");
        return Task.CompletedTask;
    }
}</pre>
			<p>The code adds a class called <strong class="source-in ine">AccountBalance</strong> and adorns it with the <strong class="source-in ine">[Observer]</strong> attribute. Its purpose is to only deal with the balance events of <strong class="source-in ine">DepositPerformed</strong> and <strong class="source-in ine">WithdrawalPerformed</strong>.</p>
			<p>Both observers are just logging what has happened to the console. In a real implementation of these, you’d probably want to store the data somewhere. The benefit here is that you could store the data in two different locations. For life cycle events, you’re only interested in the ownership and any details related to the account, while with the<a id="_idIndexMarker456"/> balance events, you’re only interested in what affects the balance and not interested in anything else. Breaking these things up makes it easier to choose the right technology for the job and also model each of these independently and create a less coupled system.</p>
			<p>Now you want to do the last hookup and throw some events at it and verify that it does the job.</p>
			<p>Open the <strong class="source-in ine">Program.cs</strong> file and make it look like the following:</p>
			<pre class="source-code">
using Chapter12;
using EventSourcing;
using Fundamentals;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
var host = Host.CreateDefaultBuilder()
    .ConfigureServices((context, services) =&gt;
    {
        var types = new Types();
        services.AddSingleton&lt;ITypes&gt;(types);
        services.AddBindingsByConvention(types);
        services.AddSelfBinding(types);
    })
    .Build();</pre>
			<p>The code sets up the necessary plumbing code to get the default .NET inversion of the control container going; it leverages <strong class="source-in ine">AddBindingsByConvention()</strong> that you created in <a href="B19418_10.xhtml#_idTextAnchor162"><em class="ita ic">Chapter 10</em></a>, <em class="ita ic">Convention over Configuration</em>, to hook up services by convention, and <strong class="source-in ine">AddSelfBinding()</strong> that you created in <a href="B19418_11.xhtml#_idTextAnchor177"><em class="ita ic">Chapter 11</em></a>, <em class="ita ic">Applying the </em><em class="ita ic">Open-Closed Principle</em>.</p>
			<p>With the basic <a id="_idIndexMarker457"/>infrastructure in place, you can now ask for an instance of <strong class="source-in ine">IEventLog</strong> and start appending events to it.</p>
			<p>Add the following code at the bottom of <strong class="source-in ine">Program.cs</strong>:</p>
			<pre class="source-code">
var eventLog = host.Services
  .GetRequiredService&lt;IEventLog&gt;();
var bankAccountId = EventSourceId.New();
eventLog.Append(bankAccountId, new BankAccountOpened("Jane
  Doe"));
eventLog.Append(bankAccountId, new DepositPerformed(100));
eventLog.Append(bankAccountId, new
  WithdrawalPerformed(32));
eventLog.Append(bankAccountId, new BankAccountClosed());</pre>
			<p>Running your program should give you a similar output:</p>
			<pre class="source-code">
Account opened for Jane Doe
Deposit of 100 performed on a3d7dbae-9e2a-4d2d-a070-
ead70e48f87a
Withdrawal of 32 performed on a3d7dbae-9e2a-4d2d-a070-
ead70e48f87a
Account with id a3d7dbae-9e2a-4d2d-a070-ead70e48f87a closed</pre>
			<p>You now have the beginning of an event-sourcing component. But more importantly, it should give you an idea of what could be done dynamically without having to be tied to the strictness of inheritance.</p>
			<p>As an illustration <a id="_idIndexMarker458"/>of the implication of doing this with inheritance instead, we would need something like an interface that defines the method for the event; it could look something like the following:</p>
			<pre class="source-code">
public interface IObserveEvent&lt;TEvent&gt; where TEvent :
  IEvent
{
    Task Handle(TEvent @event, EventContext context);
}</pre>
			<p>With this interface, we could take the <strong class="source-in ine">AccountLifecycle</strong> observer and do the following:</p>
			<pre class="source-code">
public class AccountLifecycle :
    IObserveEvent&lt;BankAccountOpened&gt;,
    IObserveEvent&lt;BankAccountClosed&gt;
{
    public Task Handle(BankAccountOpened @event,
      EventContext context)
    {
        Console.WriteLine($"Account opened for
          {@event.CustomerName}");
        return Task.CompletedTask;
    }
    public Task Handle(BankAccountClosed @event,
      EventContext context)
    {
        Console.WriteLine($"Account with id
          {context.EventSourceId} closed");
        return Task.CompletedTask;
    }
}</pre>
			<p>While using this approach can provide compile-time safety, there are several downsides to consider. Firstly, naming every method <strong class="source-in ine">Handle</strong> can lead to ambiguity and confusion, both in terms of tooling and readability. It may be difficult to determine which method to work with without carefully examining the parameters. Additionally, this approach limits you to only one method handling one event, while the convention-based approach allows for <a id="_idIndexMarker459"/>multiple individual methods with specific purposes to handle different aspects of the event.</p>
			<p>If you have an observer handling numerous events, you’d end up having to implement <strong class="source-in ine">IObserveEvent&lt;&gt;</strong> for every type it handles. This can easily make your code less readable and maintainable.</p>
			<p>There are pros and cons to both approaches, but hopefully, the takeaway is the potential this gives and, hopefully, it is useful and applicable to the c<a id="_idTextAnchor204"/>ode bases you work on.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor205"/>Summary</h1>
			<p>Conventions, like those explained in this chapter with the discovery of well-known signatures, can be very powerful and help clean up your code. Forcing the developer to implement an interface for every class supported can be tedious and make the code look a little strange.</p>
			<p>The downside of using a convention for method signatures is obviously that you are now at the mercy of runtime checks; there is no compiler that will help you. If you happen to make a little error, it won’t be noticed until you’re at runtime, which can be very annoying while in the zone and developing. In <a href="B19418_17.xhtml#_idTextAnchor299"><em class="ita ic">Chapter 17</em></a>, <em class="ita ic">Static Code Analysis</em>, we will look at how we can detect errors at compile time.</p>
			<p>In the next chapter, we’re going to look at how automation can go further with conventions to put developers in the pit of success and avoid a recipe-driven development.</p>
		</div>
	</body></html>