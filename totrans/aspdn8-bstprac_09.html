<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-197"><a id="_idTextAnchor207"/>9</h1>
<h1 id="_idParaDest-198"><a id="_idTextAnchor208"/>Creating Better Web APIs</h1>
<p>Web APIs are the essence of the internet. They give developers the openness of the web and the ability to access any data on the internet. However, there are some best practices specific to APIs. The ability to select the right HTTP verb, how to document APIs, and testing APIs are just some of the topics we’ll cover.</p>
<p>With that said, the techniques covered in this chapter are vast and dense. We’ll try to pack as much information as possible to help build quality APIs. We’ll also provide relevant links for further research.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Creating APIs quickly</li>
<li>Designing APIs</li>
<li>Testing Web APIs</li>
<li>Standardized Web API techniques</li>
</ul>
<p>In this chapter, we’ll learn how to design, create, test, and document APIs and how to perform full end-to-end tests of our APIs through a CI/CD pipeline.</p>
<p>We’ll finish this chapter by reviewing some of the more common techniques for writing APIs, such as using the correct HTTP verbs and status codes, how to avoid large dependent resources, how to implement pagination into APIs, versioning an API, using DTOs instead of entities, and the best way to call other APIs from .NET.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor209"/>Technical requirements</h1>
<p>In .NET 8, Web APIs take a front seat. Visual Studio has added new features to make Web APIs easier to build and test. For this chapter, we recommend using Visual Studio 2022, but the only requirement to view the GitHub repository is a simple text editor.</p>
<p>The code for <em class="italic">Chapter 09</em> is located in Packt Publishing’s GitHub repository, found at <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor210"/>Creating APIs quickly</h1>
<p>With .NET 8, APIs<a id="_idIndexMarker481"/> are integrated into the framework, making it easier to create, test, and document. In this section, we’ll learn a quick and easy way to create a minimal API using Visual Studio 2022 and walk through the code it generates. We’ll also learn why minimal APIs are the best approach to building REST-based services.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor211"/>Using Visual Studio</h2>
<p>One of the <a id="_idIndexMarker482"/>features of .NET 8 is the ability to create minimal <a id="_idIndexMarker483"/>REST APIs extremely fast. One way is to use the dotnet command-line tool and the other way is to use Visual Studio. To do so, follow these steps:</p>
<ol>
<li>Open Visual Studio 2022 and create an <strong class="bold">ASP.NET Core Web </strong><strong class="bold">API</strong> project.</li>
<li>After selecting the directory for the project, click <strong class="bold">Next</strong>.</li>
<li>Under the project options, make the following changes:<ul><li>Uncheck the <strong class="bold">Use Controllers</strong> option to use minimal APIs</li><li>Check <strong class="bold">Enable OpenAPI support</strong> to include support for API documentation using Swagger:</li></ul></li>
</ol>
<div><div><img alt="Figure 9.1 – Options for a web minimal API project" src="img/B19493_09_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Options for a web minimal API project</p>
<ol>
<li value="4">Click <strong class="bold">Create</strong>.</li>
</ol>
<p>That’s it – we have a simple API! It may not be much of one, but it’s still a complete API <a id="_idIndexMarker484"/>with Swagger documentation. Swagger<a id="_idIndexMarker485"/> is a tool for creating documentation for APIs and implementing the OpenAPI specification, whereas Swashbuckle is a NuGet package that uses Swagger for implementing Microsoft APIs. If we look at the project, there’s a single file called <code>Program.cs</code>.</p>
<ol>
<li value="5">Opening <code>Program.cs</code> will show the entire application. This is one of the strong points of .NET – the ability to create a scaffolded REST API relatively quickly:<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
// Learn more about configuring Swagger/OpenAPI at
   https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
var summaries = new[]
{
    "Freezing", "Bracing", "Chilly", "Cool", "Mild",
    "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
};
app.MapGet("/weatherforecast", () =&gt;
{
    var forecast = Enumerable.Range(1, 5).Select(index
    =&gt;
        new WeatherForecast
        (
            DateOnly.FromDateTime(DateTime.Now.AddDays
                (index)),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(
                summaries.Length)]
        ))
        .ToArray();
    return forecast;
})
.WithName("GetWeatherForecast")
.WithOpenApi();
app.Run();
internal record WeatherForecast(DateOnly Date,
int TemperatureC, string? Summary)
{
    public int TemperatureF =&gt; 32 +
        (int)(TemperatureC / 0.5556);
}</pre></li> </ol>
<p>In the <a id="_idIndexMarker486"/>preceding <a id="_idIndexMarker487"/>code, we created our “application” through the <code>.CreateBuilder()</code> method. We also added the <code>EndpointsAPIExplorer</code> and <code>SwaggerGen</code> services. <code>EndpointsAPIExplorer</code> enables the developer to view all endpoints in Visual Studio, which we’ll cover later. The <code>SwaggerGen</code> service, on the other hand, creates the documentation for the API when accessed through the browser. The next line creates our application instance using the <code>.</code><code>Build()</code> method.</p>
<ol>
<li value="6">Once we have our app instance and we are in development mode, we can add Swagger and the Swagger UI. <code>.UseHttpsRedirection()</code> is meant to redirect to HTTPS when the protocol of a web page is HTTP to make the API secure.</li>
<li>The next line creates our GET <code>weatherforecast</code> route using <code>.MapGet()</code>. We added the <code>.WithName()</code> and <code>.WithOpenApi()</code> methods to identify the primary method to call and let .NET know it uses the OpenAPI standard, respectively. Finally, we called <code>app.Run()</code>.</li>
<li>If we run the <a id="_idIndexMarker488"/>application, we will see the documented <a id="_idIndexMarker489"/>API on how to use our API and what’s available. Running the application produces the following output:</li>
</ol>
<div><div><img alt="Figure 9.2 – Screenshot of our documented Web API" src="img/B19493_09_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Screenshot of our documented Web API</p>
<p>If we call the <code>/weatherforecast</code> API, we see that we receive JSON back with a 200 HTTP status.</p>
<div><div><img alt="Figure 9.3 – Results of our /weatherforecast API" src="img/B19493_09_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Results of our /weatherforecast API</p>
<p>Think of this small <a id="_idIndexMarker490"/>API as middleware with API controllers <a id="_idIndexMarker491"/>combined into one compact file (<code>Program.cs</code>).</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor212"/>Why minimal APIs?</h2>
<p>I consider<a id="_idIndexMarker492"/> minimal APIs to be a feature in .NET 8, even though it’s a <a id="_idIndexMarker493"/>language concept. If the application is extremely large, adding minimal APIs should be an appealing feature in four ways:</p>
<ul>
<li><strong class="bold">Self-contained</strong>: Simple API<a id="_idIndexMarker494"/> functionality inside one file is easy to follow for other developers</li>
<li><strong class="bold">Performance</strong>: Since we aren’t using controllers, the MVC overhead isn’t necessary when using these APIs</li>
<li><strong class="bold">Cross-platform</strong>: With .NET, APIs can now be deployed on any platform</li>
<li><strong class="bold">Self-documenting</strong>: While we can add Swashbuckle to other APIs, it also builds the documentation for minimal APIs</li>
</ul>
<p>Moving forward, we’ll take these minimal APIs and start looking at Visual Studio’s testing capabilities.</p>
<p>In this section, we created and reviewed a minimal API project in Visual Studio and why minimal APIs are important to our projects.</p>
<p>In the next section, we’ll look at designing APIs to help eliminate long resource (URL) names and standardized API naming.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor213"/>Designing APIs</h1>
<p>In this section, we’ll <a id="_idIndexMarker495"/>cover the best approach for delivering intuitive and clear APIs to our users. The design of an API should be well thought-out and make sense when a user wishes to make a request.</p>
<p>To create a truly REST-based API, we must use a different mindset. We have to think of ourselves as a user and not a developer. When writing APIs, the users of the API <em class="italic">are</em> fellow developers.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor214"/>Disconnecting from existing schemas</h2>
<p>When designing <a id="_idIndexMarker496"/>APIs, we need a user’s perspective as opposed to basing an API on a class hierarchy or database schema. While developers may consider creating an API based on a class hierarchy or database schema as a shortcut, it could create more complexity as to which resource to use when retrieving data. One example is using an Order resource to find a contact. While an Order entity in Entity Framework Core could contain a <code>Company</code> property and we need the contact of the company, we wouldn’t write <code>https://www.myfakesite.com/Order/15/Company/Contact</code>. Basing a URL structure on an existing hierarchy or schema should be avoided.</p>
<p>It’s crucial to disregard existing schemas when designing a sensible API. Look at the API with new eyes to get the best design. The most popular APIs are the cleanest and most intuitive as they use the <code>collection/item/collection</code> syntax. A good example of this would be <code>/orders/15/companys</code>.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor215"/>Identifying the resources</h2>
<p>In a system, look<a id="_idIndexMarker497"/> at how the user interacts with the website and extract the nouns from specific scenarios. These will become the resources for the APIs.</p>
<p>For example, a user can perform the following actions in a shopping cart system:</p>
<ul>
<li>View a list of products</li>
<li>View a product</li>
<li>Add a product to the cart</li>
<li>Remove a product from the cart</li>
<li>Check out</li>
</ul>
<p>From these scenarios, we can extract the following resources:</p>
<ul>
<li>Products</li>
<li>Product</li>
<li>Cart</li>
</ul>
<p>We’re starting <a id="_idIndexMarker498"/>to identify and logically partition our APIs based on resources used throughout the system.</p>
<p>From here, we can apply an HTTP verb to each resource based on each scenario.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor216"/>Relating HTTP verbs to resources</h2>
<p>Once we have<a id="_idIndexMarker499"/> the primary resources, we can apply <a id="_idIndexMarker500"/>an HTTP verb to each resource based on the specific scenario we defined in the previous section.</p>
<p>When creating an API, it may be tempting to use the noun/verb syntax – for example, <a href="https://www.myurl.com/products/get">https://www.myurl.com/products/get</a> or <a href="https://www.myurl.com/getproducts">https://www.myurl.com/getproducts</a>. This approach is counterproductive since web standards already exist for this exact purpose.</p>
<p>While this does work, it violates some of the REST principles (which we’ll get into when we looked at standardized web API techniques in the following sections). For now, let’s take it step by step and create a simple shopping cart API.</p>
<p>Each HTTP verb has a default operation based on its context:</p>
<ul>
<li><code>GET</code>: Returns a resource</li>
<li><code>POST</code>: Creates a new resource</li>
<li><code>PUT</code>: Replaces an entire resource based on an identifier</li>
<li><code>PATCH</code>: Updates specific items in a resource based on an identifier</li>
<li><code>DELETE</code>: Deletes a resource</li>
</ul>
<p>For example, our scenarios in the previous section can begin to take shape based on the resources and their verbs:</p>
<ul>
<li><code>GET /api/products</code>: View a list of products</li>
<li><code>GET /api/product/{id}</code>: View a product</li>
<li><code>POST /api/cart/{cartId}</code>: Add a product to the cart with <code>POST</code> data (that is, <code>new { ProductId = {productId}, Qty = </code><code>1 }</code>)</li>
<li><code>PATCH /api/cart/{cartId}</code>: Remove a product from the cart with <code>POST</code> data (that is, <code>new { ProductId = {</code><code>productId} }</code>)</li>
<li><code>GET /api/cart/{cartId}</code>: Retrieve a cart with all the products in the cart</li>
<li><code>POST /api/cart/{cartId}/checkout</code>: Check out</li>
</ul>
<p>Once we have <a id="_idIndexMarker501"/>matched the resources to<a id="_idIndexMarker502"/> the scenarios that have been defined, we can move forward with returning status codes to the caller.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor217"/>Returning HTTP status codes</h2>
<p>With the resources <a id="_idIndexMarker503"/>defined, we need to know whether <a id="_idIndexMarker504"/>the request was successful or not. This is where we return HTTP status codes.</p>
<p>These status codes are broken into the following categories:</p>
<ul>
<li><strong class="bold">1xx</strong>: Information codes</li>
<li><strong class="bold">2xx</strong>: Success codes</li>
<li><strong class="bold">3xx</strong>: Redirection codes</li>
<li><strong class="bold">4xx</strong>: Client-side codes</li>
<li><strong class="bold">5xx</strong>: Server errors</li>
</ul>
<p>Similar to unit tests, we look at a “happy” path and a broken path. But with APIs, we need to add an unrecoverable path in case an unrecoverable error occurs.</p>
<p>Let’s look at two of the URLs and what status codes they should return.</p>
<p><code>GET /api/products</code> will return the following status codes:</p>
<ul>
<li><strong class="bold">200 Success</strong>: Products were successfully returned</li>
<li><strong class="bold">500 Internal Server Error</strong>: Optional if something caused a problem</li>
</ul>
<p>If the API was successful, it will return a list of the products with a 200 status code. If there are issues, it will return a 500 status code. The API could also return additional status codes. For example, if an API call is made for specific users, the API could return a 401, which is an Unauthorized status code.</p>
<p><code>POST /api/cart/{cartId}</code> with a post body of (<code>new { ProductId = {productId}, Qty = 1 }</code>) will return the following status codes:</p>
<ul>
<li><strong class="bold">201 Created</strong>: The item was created and added to the cart</li>
<li><strong class="bold">202 Accepted</strong>: The item was added to the cart</li>
<li><strong class="bold">404 Not Found</strong>: The cart or product wasn’t found</li>
<li><strong class="bold">500 Internal Server Error</strong>: An unrecoverable error occurred</li>
</ul>
<p>With this API, we can return either a 201 Created or a 202 Accepted status code. If we couldn’t find the<a id="_idIndexMarker505"/> cart or product to add to the cart, return<a id="_idIndexMarker506"/> a 404 status code. Otherwise, return a 500 status code.</p>
<p>While these two examples are not set in stone, they should provide a template for the team to discuss what business rules dictate the status codes that are returned to the user. Whatever status codes are returned, they should provide enough context as to the request made through the API.</p>
<p>Some APIs seen in the wild use an all-or-nothing approach; they either return a 200 or a 500. It depends on how much information we want to send back to the client. These types of APIs feel like they’re missing more functionality, such as Unauthorized (401) or Not Found (404) status codes. It’s a best practice to include as much information as we can to the caller of the API.</p>
<p class="callout-heading">HTTP status codes</p>
<p class="callout">HTTP status codes are standard in web <a id="_idIndexMarker507"/>development and are presented through the RFC <code>HttpStatusCodeEnum</code> class with every status code at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode">https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode</a>, along with <code>IActionResults</code> such as <code>Ok(object)</code>. Specific status codes can be found at <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode">https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode</a>.</p>
<p>In this section, we learned how to design APIs and broke down each step – that is, disconnecting from the technology, identifying the resources, knowing the right verbs to apply to<a id="_idIndexMarker508"/> resources, and providing the correct response<a id="_idIndexMarker509"/> codes to our API.</p>
<p>In the next section, we will look at two ways to test our APIs: one in Visual Studio with the new Endpoints Explorer and the other by creating a complete integration test.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor218"/>Testing Web APIs</h1>
<p>Once we have<a id="_idIndexMarker510"/> our APIs designed and created, we need a way to test them in our IDE and our integration tests. Luckily, Visual Studio has added the new Endpoints Explorer.</p>
<p>In this section, we’ll learn two ways to test our APIs. One way is through our development environment using Visual Studio. The second way we’ll test our API is through integration tests. If we have a CI/CD pipeline (which we should from <a href="B19493_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>), these will automatically run to confirm our APIs work as expected.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor219"/>Visual Studio Endpoints Explorer</h2>
<p>Historically, developers<a id="_idIndexMarker511"/> using Visual Studio had to <a id="_idIndexMarker512"/>run a separate tool to test their APIs, but with the latest version of .NET 8, the Visual Studio team added a new panel called <strong class="bold">Endpoints Explorer</strong>:</p>
<div><div><img alt="Figure 9.4 – Endpoints Explorer" src="img/B19493_09_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Endpoints Explorer</p>
<p>If we have<a id="_idIndexMarker513"/> a<a id="_idIndexMarker514"/> collection of APIs defined in the <code>Program.cs</code> file, our collection will appear as follows:</p>
<div><div><img alt="Figure 9.5 – Collection of APIs in Endpoints Explorer" src="img/B19493_09_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Collection of APIs in Endpoints Explorer</p>
<p>Right-clicking on an API will generate a request in a new HTTP Editor. The HTTP Editor allows<a id="_idIndexMarker515"/> custom-defined variables for the APIs<a id="_idIndexMarker516"/> listed:</p>
<div><div><img alt="Figure 9.6 – Sample API collection in the HTTP Editor" src="img/B19493_09_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Sample API collection in the HTTP Editor</p>
<p>In <em class="italic">Figure 9</em><em class="italic">.6</em>, the HTTP Editor uses the following commands to issue HTTP requests:</p>
<ul>
<li><code>@</code>: Creates a variable for the file (for example, <code>@variable</code> = <code>value</code>)</li>
<li><code>//</code>: This specifies comments</li>
<li><code>###</code>: This specifies the end of an HTTP request</li>
<li><code>&lt;HTTP Verb&gt;</code>: Creates a REST-based request, including <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, <code>PUT</code>, and <code>TRACE</code> requests</li>
<li><code>&lt;Headers&gt;</code>: Adds headers directly after defining the URL so that they’re included in the request</li>
</ul>
<p>Once we have defined the APIs, there are green arrows in the left gutter. Run the application to test the API locally. Pressing the arrow in the far left gutter <em class="italic">while the API is running</em> will <a id="_idIndexMarker517"/>produce <a id="_idIndexMarker518"/>results in the right-hand pane:</p>
<div><div><img alt="Figure 9.7 – Results of the /attractions request" src="img/B19493_09_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Results of the /attractions request</p>
<p>In this <a id="_idIndexMarker519"/>example, we tested the <code>/attractions</code> request, received<a id="_idIndexMarker520"/> the data, and displayed it on the right.</p>
<h3>Why is this important?</h3>
<p>By using this<a id="_idIndexMarker521"/> new Visual Studio feature, we gain the following advantages:</p>
<ul>
<li><strong class="bold">Centralized APIs</strong>: We have a<a id="_idIndexMarker522"/> catalog of all of our APIs in one place</li>
<li><code>.http</code> file, execute sample requests, and understand what each API does in the system</li>
<li><strong class="bold">IDE-integrated</strong>: Additional tools aren’t necessary for testing our APIs</li>
</ul>
<p>This new feature is extremely helpful to developers looking to test existing APIs locally and also complements new minimal APIs introduced into the system.</p>
<p class="callout-heading">Additional Endpoints Explorer material</p>
<p class="callout">For additional material on Endpoints Explorer, Sayed Ibrahim Hashimi has provided a great write-up about everything it can do at <a href="https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer">https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer</a>.</p>
<p>In this section, we learned about Endpoints Explorer, how we can use it to help test APIs locally, and why it’s<a id="_idIndexMarker523"/> important. In the next section, we’ll take our APIs and learn how to use integration tests to produce quick results.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor220"/>Integration testing APIs</h2>
<p>In the previous<a id="_idIndexMarker524"/> section, we learned about how to use Endpoints Explorer to test our APIs. However, we shouldn’t have to install Visual Studio on a server to test our APIs.</p>
<p>In this section, we will look at applying an integration server for our APIs to achieve a complete end-to-end test.</p>
<p>When we created unit tests back in <a href="B19493_08.xhtml#_idTextAnchor189"><em class="italic">Chapter 8</em></a>, we created an in-memory representation of a database. We can create a similar environment where we can spin up and tear down the entire environment for API tests.</p>
<p>In our CI/CD pipelines, we can build a disposable server for our integration tests to provide a full end-to-end test with APIs and services and a disposable database.</p>
<h3>Building the integration server</h3>
<p>Since .NET provides<a id="_idIndexMarker525"/> us with a simple <code>Program.cs</code> file for our applications, we can wrap the entire application and replace the services we want to mimic with a web and database server.</p>
<p>We can set up the environment using the <code>WebApplicationFactory</code> class. We include the minimal API project as a dependency in our <code>Api.Tests</code> project. Once we have our dependency in the program, we can create our <code>WebApplicationFactory</code> class:</p>
<pre class="source-code">
using System.Data.Common;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using ThemePark.Data.DataContext;
namespace ThemePark.Api.Tests;
public class TestThemeParkApiApplication :
WebApplicationFactory&lt;Program&gt;
{
    protected override IHost CreateHost(
    IHostBuilder builder)
    {
        var root = new InMemoryDatabaseRoot();
        builder.ConfigureServices(services =&gt;
        {
            services.RemoveAll(typeof(
                DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;
                ));
            services.AddScoped(sp =&gt; new
            DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;()
                .UseInMemoryDatabase("TestApi", root)
                .UseApplicationServiceProvider(sp)
                .Options);
            services.AddDbContext&lt;ThemeParkDbContext&gt;(
            (container, options) =&gt;
            {
                var connection = container
                    .GetRequiredService&lt;DbConnection&gt;();
                options.UseSqlite(connection);
            });
            services.AddTransient&lt;IThemeParkDbContext,
                ThemeParkDbContext&gt;();
        });
        return base.CreateHost(builder);
    }
}</pre> <p>In the preceding code example, we inherited from <code>WebApplicationFactory&lt;Program&gt;</code>. The generic <code>&lt;Program&gt;</code> comes from the included dependency we referenced. Then, we created a root for our in-memory database and proceeded to configure our services by removing all instances of <code>DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;</code>. Once we’ve removed these, we can create a new scoped reference to the same type with our updated settings for the database.</p>
<p>Next, we added our new <code>ThemeParkDbContext</code> with our updated connection using a SQLite database. Remember, Entity Framework Core will automatically create the structure of our entire database with the <code>.EnsureCreated()</code> method. Finally, we added a dependency injection registration for <code>IThemeParkDbContext</code> for the services in our application.</p>
<p>That’s it for our integration server. Now, we can use <code>TestThemeParkApiApplication</code> in our integration test. For example, if we want to create a test for<a id="_idIndexMarker526"/> our <code>/attractions</code> API, our integration test will look as follows:</p>
<pre class="source-code">
using Microsoft.Extensions.DependencyInjection;
using ThemePark.Data.DataContext;
namespace ThemePark.Api.Tests;
[TestClass]
public class ApiTests
{
    private TestThemeParkApiApplication _app;
    [TestInitialize]
    public void Setup()
    {
        _app = new TestThemeParkApiApplication();
        using (var scoped = _app.Services.CreateScope())
        {
            var context = scoped.ServiceProvider
                .GetService&lt;IThemeParkDbContext&gt;();
            context?.Database.EnsureCreated();
        }
    }
    [TestMethod]
    [TestCategory("Integration")]
    public async Task GetAllAttractions()
    {
        // Arrange
        var client = _app.CreateClient();
        var expected = TestData.ExpectedAttractionData;
        // Act
        var response = await
            client.GetAsync("/attractions");
        var actual = await response.Content
            .ReadAsStringAsync();
        // Assert
        Assert.AreEqual(expected, actual);
    }
}</pre> <p>In the preceding code snippet, we initialized <code>TestThemeParkApiApplication</code> on setup so that every instance is new through the <code>.EnsureCreated()</code> method. <code>_app.CreateClient</code> gives us <code>HttpClient</code> to make a call to a URL. We make a call to our <code>/attractions</code> API and compare it with a resource string we created instead of cluttering our test methods with large JSON strings. Finally, our test compares the JSON results with what’s returned from an API.</p>
<p>The ability to create entire front-to-back integration tests proving the APIs, Entity Framework queries, and database code work as expected while running through a CI/CD pipeline with successful tests should instill confidence about the code.</p>
<p>In this section, we learned how to take APIs and test them in Visual Studio’s Endpoints Explorer. We also <a id="_idIndexMarker527"/>learned how to take those APIs and make them testable in a CI/CD pipeline by wrapping our API project using <code>WebApplicationFactory</code>.</p>
<p>In the next section, we’ll cover some of the common practices used in the industry when building APIs.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor221"/>Standardized Web API techniques</h1>
<p>In this section, we’ll learn<a id="_idIndexMarker528"/> how to use HTTP verbs and status codes properly, how to avoid large dependent resources, how to create paginations for APIs, how to version an API, using DTOs instead of entities, and the best way to make API calls from .NET.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor222"/>Using the right HTTP verbs and status codes</h2>
<p>So far, we’ve<a id="_idIndexMarker529"/> looked at how to use HTTP verbs <a id="_idIndexMarker530"/>and how to <a id="_idIndexMarker531"/>return<a id="_idIndexMarker532"/> status codes. While this may seem like a trivial thing, some systems ignore these standards and use POSTs all the time, regardless of the function.</p>
<p>Swagger provides a great template for documenting APIs and with Visual Studio’s new Endpoints Explorer, Visual Studio brings this fundamental documentation down to the developer’s IDE, making the API easier to read and implement in other projects, showing developers what verbs to use and what status codes are expected.</p>
<p>In our example of a shopping cart API earlier in this chapter, users were going to add products to a cart and proceed to check out. They were going to use a cart to begin this process. The function of checking out led us to use the cart API with a method of checkout (<code>/cart/checkout</code>), which makes perfect sense. We should take the user’s actions<a id="_idIndexMarker533"/> and<a id="_idIndexMarker534"/> match <a id="_idIndexMarker535"/>them to<a id="_idIndexMarker536"/> actions in the APIs.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor223"/>Beware dependent resources</h2>
<p>But how far do I take my <a id="_idIndexMarker537"/>API based on resources? What if one resource belongs to another resource and that’s dependent on another resource, and so on?</p>
<p>Here’s an example: <code>/users/{userId}/projects/{projectId}/tasks</code>.</p>
<p>We want to get a user’s tasks for a project, but this URL seems a bit long, doesn’t it? How do we break this down into something a bit more manageable? Anything more than three levels deep is simply asking for trouble.</p>
<p>This URL requires a more granular approach – that is, breaking out each resource. Instead of the preceding URL, a better approach would be to use <code>/users/{userId}/projects</code> to retrieve a list of projects a user is working on at a time. The next URL would provide the tasks based on the selected project and look like <code>/projects/{projectId}/tasks</code>.</p>
<p>As developers, we all know everything is a compromise. In this case, we are providing a simpler API but requiring two calls instead of one.</p>
<p>These are discussions to be had with team members, but essentially, the smaller the URL, the easier it is to implement. The longer the URL, the more resource lookups are necessary to fulfill the request.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor224"/>Pagination in API results</h2>
<p>For most API calls, results<a id="_idIndexMarker538"/> are returned in<a id="_idIndexMarker539"/> a raw, <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) format, usually as a collection or a single item. What if the client side needs paginated results and they only want one page of data for now?</p>
<p>To assist client-side developers, a JSON result could contain the following:</p>
<pre class="source-code">
{
    "total": 7,
    "pageSize": 7,
    "currentPage": 1,
    "next": false,
    "previous": false,
    "results": [
        {
            "id": 1,
            "name": "Twirly Ride",
            "locationId": 2,
            "locationName": "Fantasy"
        },
        {
            "id": 2,
            "name": "Mine car Coaster",
            "locationId": 5,
.
.</pre> <p>While returning<a id="_idIndexMarker540"/> results as a collection is usually required, some fields to return in the header are as follows:</p>
<ul>
<li><code>Total</code>: Total number of records</li>
<li><code>PageSize</code>: How many records are returned in this response</li>
<li><code>TotalPages</code>: Specifies the total number of pages based on <code>PageSize</code></li>
<li><code>CurrentPage</code>: Specifies what page we are currently on</li>
<li><code>Next</code> and <code>Previous</code>: Are there enough records to move back and forward?</li>
<li><code>Sort</code>: Specifies how the results are sorted</li>
<li><code>Filter</code>: Specifies what filter was applied to the results</li>
</ul>
<p>The header is meant to help our fellow client-side developer make the most of the response. While this isn’t a comprehensive list of fields to include, it should be implemented with consistency across every single response when displaying a subset of records on<a id="_idIndexMarker541"/> the client.</p>
<p>A “status code” field or “success” field in the header should be avoided since HTTP status codes are considered the expected response.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor225"/>Versioning APIs</h2>
<p>When creating<a id="_idIndexMarker542"/> APIs, by default, they’ll more than likely be in a raw state with no versioning in place. There are four types of versioning:</p>
<ul>
<li><strong class="bold">No versioning</strong>: When we create our first API</li>
<li><code>/v1/users</code>)</li>
<li><code>/users/?version=1</code>)</li>
<li><code>custom-header</code> to place the version into the header:<pre class="source-code">
GET /users
Custom-Header: api-version=1</pre></li> </ul>
<p>The most common versioning technique that’s used is URI versioning. While everyone’s mileage may vary, this technique is appealing because it’s immediately obvious which version we’re using.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor226"/>Use DTOs, not entities!</h2>
<p>While testing<a id="_idIndexMarker543"/> our API, we <a id="_idIndexMarker544"/>weren’t returning entities (<code>Attraction</code> or <code>Location</code>). Instead, we were returning <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>), which are a subset of properties.</p>
<p>Our security chapter (<a href="B19493_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>) mentioned not to expose too much when it comes to primary keys or sensitive information. DTOs give the developer a chance to pick and choose which properties should be exposed to the client.</p>
<p>For example, our <code>Attraction</code> DTO is meant to provide a minimal amount of information; we’ll discuss this after we look at the following code example:</p>
<pre class="source-code">
public static class AttractionExtensions
{
    public static AttractionDto ToDto(
    this Attraction attraction)
    {
        return new AttractionDto
        {
            Id = attraction.Id,
            Name = attraction.Name,
            LocationId = attraction.LocationId,
            LocationName = attraction.Location == null
                ? string.Empty
                : attraction.Location.Name
        };
    }
}</pre> <p>Here, we have a simplified <code>AttractionDto</code> class containing simple properties. We also have a <code>LocationName</code> property based on our dependent <code>Location</code> class.</p>
<p>While we have this as a <code>.ToDto()</code> method, we could create other DTO extension methods to return different data in a <code>.ToDifferentDto()</code> method or whatever we want to call it.</p>
<p>Another reason to use DTOs instead of Entity Framework entities is the potentially recursive nature of navigational properties. When an entity is returned from an API, it’s turned into a JSON object. If we have a nested entity, it’ll follow it down the chain. It’s better to isolate and distill an entity’s properties down to their native types for basic consumption on<a id="_idIndexMarker545"/> the client<a id="_idIndexMarker546"/> side when they’re returned from the API.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor227"/>Avoid new instances of HttpClient</h2>
<p>While the majority<a id="_idIndexMarker547"/> of this <a id="_idIndexMarker548"/>chapter discussed creating and testing APIs, I feel we need to mention how to consume them in a .NET application as well.</p>
<p>There are various ways to consume a web API, such as using <code>WebRequest</code> or <code>WebClient</code>, but for most purposes, the use of the <code>HttpClient</code> class is recommended because of its flexibility and modernization. The <code>WebRequest</code> and <code>WebClient</code> classes were included for the transition of legacy applications. With that said, it’s easy to create a new instance of <code>HttpClient</code>, but it’s not the best approach.</p>
<p>Microsoft states that <code>HttpClient</code> should only be used once per the lifetime of an application. If we create instances of <code>HttpClient</code> in multiple locations in our application, we are hindering the performance and scalability opportunities. It causes an issue called TCP port exhaustion if the rate of requests is too high, so it’s best to avoid code such as the following:</p>
<pre class="source-code">
// Bad use of HttpClient
var client = new HttpClient();</pre> <p>Some developers may take this a step further and decide the following code snippet is better by wrapping a <code>using</code> statement to dispose of an <code>HttpClient</code> class properly:</p>
<pre class="source-code">
// Still not good
using (var client = new HttpClient())
{
    .
    .
}</pre> <p>The problem with this code is that we’re still creating another instance of <code>HttpClient</code>, still causing port exhaustion, and still disposing of it when we’ll more than likely need it later.</p>
<p>In .NET Core 2.1, Microsoft created an <code>IHttpClientFactory</code> class to deliver a single instance of <code>HttpClient</code>. We can simply ask it for an <code>HttpClient</code> instance and we’ll receive one. The best news is it can be dependency injected.</p>
<p>The code becomes easier to work with once we’ve injected the class through constructors, as <a id="_idIndexMarker549"/>shown in<a id="_idIndexMarker550"/> the following code snippet:</p>
<pre class="source-code">
public class IndexModel : PageModel
{
    private readonly ILogger&lt;IndexModel&gt; _logger;
    private readonly IHttpClientFactory _factory;
    public IndexModel(
        ILogger&lt;IndexModel&gt; logger,
        IHttpClientFactory factory)
    {
        _logger = logger;
        _factory = factory;
    }
    public async Task OnGet()
    {
        // Bad use of HttpClient
        // var client = new HttpClient();
        // Still not good
        //using (var client = new HttpClient())
        //{
        //    .
        //    .
        //}
        // Best way to use HttpClient
        var client = _factory.CreateClient();
        // use client.GetAsync("https://www.google.com") to
           grab HTML
    }
}</pre> <p>When we <a id="_idIndexMarker551"/>ask <code>HttpClientFactory</code> for a <a id="_idIndexMarker552"/>client using <code>.CreateClient()</code>, it won’t create a new instance of <code>HttpClient</code> unless it has to.</p>
<p>Think of the <code>.CreateClient()</code> method as using a singleton design pattern behind the scenes, similar to the code shown here:</p>
<pre class="source-code">
private static HttpClient _client { get; set; }
public HttpClient CreateClient()
{
    if (_client == null)
    {
        _client = new HttpClient();
    }
    return _client;
}</pre> <p>As a side note, the preceding code is <em class="italic">not</em> thread-safe; it has been provided to show the concept of a <a id="_idIndexMarker553"/>singleton design <a id="_idIndexMarker554"/>pattern.</p>
<p>We always get an instance of <code>HttpClient</code>, which is a better way to make server-side API calls.</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor228"/>Summary</h1>
<p>In this chapter, we learned about several techniques, such as how to design an API by disconnecting from technology by becoming a user of the application, identifying the resources, and using the right HTTP verbs and correct status codes. We also learned how to create, test, and document APIs, along with why minimal APIs are important. After, we learned how to use the new Endpoints Explorer in Visual Studio 2022, as well as how to build an automated end-to-end test of our APIs in a CI/CD pipeline.</p>
<p>Once we understood the process of writing APIs, we examined what standards were used in the industry to create common and useful APIs, such as using the correct HTTP verbs and status codes, avoiding large URLs, how to use pagination with APIs, versioning our API, using DTOs instead of entities, and the optimal way to use <code>HttpClient</code> when making API calls from .NET.</p>
<p>In the next chapter, we’ll look at how to improve performance across various topics we’ve covered in this book, and we’ll also provide some new performance tips.</p>
</div>
</body></html>