<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Building a Camera Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Building a Camera Application</h1></div></div></div><p>We have reached the end of an era, learning the ins and outs of cross-platform development using the <code class="literal">Xamarin</code> platform.</p><p>In our last chapter, we are going to walk-through the final <code class="literal">Xamarin.Forms</code> project. We will introduce Effects, Triggers, and how they apply to UI elements. Then, we will build a
<code class="literal">CustomRenderer</code> for each platform camera. The following topics will be covered in this
chapter.</p><p>Expected knowledge:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Xamarin.Forms</code></li><li class="listitem" style="list-style-type: disc">XAML</li><li class="listitem" style="list-style-type: disc">MVVM</li><li class="listitem" style="list-style-type: disc">C# threading</li><li class="listitem" style="list-style-type: disc">HashMap data structures</li><li class="listitem" style="list-style-type: disc">CustomRenderers</li><li class="listitem" style="list-style-type: disc"><code class="literal">INotifiedPropertyChanged</code> framework</li></ul></div><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Solution setup</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">MainPageViewModel</code></li><li class="listitem" style="list-style-type: disc">Improving the <code class="literal">INotifiedPropertyChanged</code> implementation</li><li class="listitem" style="list-style-type: disc">Creating the custom UI objects</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">FocusView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Xamarin.Forms</code> animations</li><li class="listitem" style="list-style-type: disc"><code class="literal">Xamarin.Forms</code> compound animations</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">CameraView</code></li><li class="listitem" style="list-style-type: disc">Building a control for the iOS camera</li><li class="listitem" style="list-style-type: disc">Building the iOS <code class="literal">CameraRenderer</code></li><li class="listitem" style="list-style-type: disc">Integrating the Android Camera2 framework</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">CameraViewRenderer</code> in Android</li><li class="listitem" style="list-style-type: disc">Handling native touch events through the <code class="literal">FocusView</code></li><li class="listitem" style="list-style-type: disc">Using RX to handle events</li><li class="listitem" style="list-style-type: disc">Building a <code class="literal">VisualElementRenderer</code> for iOS</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">CustomImageRenderer</code></li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">UIImageEffect</code> class</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">CustomImageRenderer</code> for Android</li><li class="listitem" style="list-style-type: disc">Triggers</li><li class="listitem" style="list-style-type: disc">Platform effects</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">CameraPage</code></li><li class="listitem" style="list-style-type: disc">Adding native orientation events</li></ul></div><div class="section" title="Solution setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec125"/>Solution setup</h1></div></div></div><p>Let's begin by creating a new <code class="literal">Xamarin.Forms</code> project and calling it <code class="literal">Camera</code>. We also want to create the <code class="literal">Camera.Portable</code> project. Now that we have built up several <code class="literal">Xamarin.Forms</code> applications, we have a lot of reusable parts that will be brought across to this application.</p><p>Starting with the <code class="literal">Camera.Portable</code> project, we want to copy in the <code class="literal">IoC</code>, <code class="literal">Extras</code>, and <code class="literal">Logging</code> folders used in <a class="link" href="ch07.html" title="Chapter 7.  Building a File Storage Application">Chapter 7</a>, <span class="emphasis"><em>Building a File Storage Application</em></span>. Make sure all the files contained in these folders are copied in accordingly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip115"/>Tip</h3><p>Don't forget to update namespaces in each code sheet.</p></div></div><p>Then we want to add the following NuGet packages for every project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Autofac</li><li class="listitem" style="list-style-type: disc">Reactive extensions</li></ul></div><p>Next, we want to create a folder called <span class="strong"><strong>Enums</strong></span>. Add in a new folder called <code class="literal">PageNames.cs</code> and implement the following:</p><pre class="programlisting">public enum PageNames &#13;
    { &#13;
        #region Properties &#13;
 &#13;
        MainPage, &#13;
 &#13;
        CameraPage, &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Like our other projects, this will be used in the navigation setup. In this folder, we also want to add another file called <code class="literal">Orientation.cs</code> and implement the following:</p><pre class="programlisting">public enum Orientation &#13;
    { &#13;
        Portrait, &#13;
 &#13;
        LandscapeLeft, &#13;
 &#13;
        LandscapeRight, &#13;
 &#13;
        None &#13;
    } &#13;
</pre><p>This <code class="literal">enum</code> will be used with orientation settings on our <code class="literal">CameraPage</code>. Each different orientation setting will be handled for adjusting camera preview surface areas.</p><p>Our next step is to create a new folder called <code class="literal">UI</code> and copy in the <code class="literal">INavigationService.cs</code>. We also want to add another file called <code class="literal">AlertArgs.cs</code> and implement the following:</p><pre class="programlisting">public class AlertArgs : EventArgs &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public string Message { get; set; } &#13;
 &#13;
        public TaskCompletionSource&lt;bool&gt; Tcs { get; set; } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>The preceding class will be used inside all alerts that are invoked inside our view-models. We use a <code class="literal">TaskCompletionSource</code> object to await the method that fires the alert, and the <code class="literal">Message</code> object for every alert message.</p></div></div>
<div class="section" title="Building the MainPageViewModel class"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec126"/>Building the MainPageViewModel class</h1></div></div></div><p>Let's add the <code class="literal">ViewModelBase</code> class, which will contain the <code class="literal">AlertArgs</code> event. Create a new folder called <code class="literal">ViewModels</code>, add in a new file called <code class="literal">ViewModelBase.cs</code>, and implement the following:</p><pre class="programlisting">public class ViewModelBase : INotifyPropertyChanged &#13;
    { &#13;
        #region Public Events &#13;
 &#13;
        public event PropertyChangedEventHandler PropertyChanged; &#13;
 &#13;
        public event EventHandler&lt;AlertArgs&gt; Alert; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Properties &#13;
 &#13;
        public INavigationService Navigation; &#13;
 &#13;
        #endregion &#13;
</pre><p>The <code class="literal">ViewModelBase</code> class will be similar to the other <code class="literal">Xamarin.Forms</code> projects. We have the <code class="literal">INotifiedPropertyChanged</code> requirements, another <code class="literal">EventHandler</code> for alerts, and the <code class="literal">INavigationService</code> for navigation control.</p><p>Next, we have the constructor:</p><pre class="programlisting">       #region Constructor &#13;
 &#13;
        public ViewModelBase(INavigationService navigation, IMethods methods) &#13;
        { &#13;
            Navigation = navigation; &#13;
 &#13;
            _methods = methods; &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre></div>
<div class="section" title="Improving the INotifiedPropertyChanged implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec127"/>Improving the INotifiedPropertyChanged implementation</h1></div></div></div><p>As you may have noticed from previous projects, our standard property implementation for handling property changes looks like the following:</p><pre class="programlisting">private string _descriptionMessage = "Take a Picture";  &#13;
 &#13;
public string DescriptionMessage &#13;
        { &#13;
            get &#13;
            { &#13;
                return _descriptionMessage; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_descriptionMessage)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _descriptionMessage = value; &#13;
                OnPropertyChanged("DescriptionMessage"); &#13;
            } &#13;
        } &#13;
</pre><p>The repeated code in every public property makes our view-model code look much bigger than it actually is. In all your code sheets, a good coding practice to think about is how you can reduce the amount of lines of code and, especially repeated code. The following function <code class="literal">SetProperty</code> is an example of how we can turn 13 lines of code into just two:</p><pre class="programlisting">        protected void SetProperty&lt;T&gt;(string propertyName,&#13;
        ref T referenceProperty, T newProperty) &#13;
        { &#13;
            if (!newProperty.Equals(referenceProperty)) &#13;
            { &#13;
                referenceProperty = newProperty; &#13;
            } &#13;
 &#13;
            OnPropertyChanged(propertyName); &#13;
        } &#13;
</pre><p>In all properties, we always check first if the value being assigned is different to the current value before firing the <code class="literal">OnPropertyChanged</code> function. Since this is a generic type function, the same logic can be used for any property on all view-models. Now the <code class="literal">DescriptionMessage</code> property will look like the following:</p><pre class="programlisting">public string DescriptionMessage &#13;
        { &#13;
            get { return _descriptionMessage; } &#13;
            set { SetProperty(nameof(DescriptionMessage),&#13;
                  ref _descriptionMessage, value); } &#13;
        } &#13;
</pre><p>Let's add the rest of the <code class="literal">ViewModelBase</code> as follows:</p><pre class="programlisting">        protected virtual void OnPropertyChanged([CallerMemberName]&#13;
        string propertyName = null) &#13;
        { &#13;
            PropertyChangedEventHandler handler = PropertyChanged; &#13;
 &#13;
            if (handler != null) &#13;
            { &#13;
                handler(this, new PropertyChangedEventArgs(propertyName)); &#13;
            } &#13;
        } &#13;
 &#13;
        protected virtual async Task LoadAsync(IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Methods &#13;
 &#13;
        public Task&lt;bool&gt; NotifyAlert(string message) &#13;
        { &#13;
            var tcs = new TaskCompletionSource&lt;bool&gt;(); &#13;
 &#13;
            Alert?.Invoke(this, new AlertArgs() &#13;
            { &#13;
                Message = message, &#13;
                Tcs = tcs &#13;
            }); &#13;
 &#13;
            return tcs.Task; &#13;
        } &#13;
 &#13;
        public void OnShow(IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
            LoadAsync(parameters).ToObservable().Subscribe( &#13;
                result =&gt; &#13;
                { &#13;
                    // we can add things to do after we load the view model &#13;
                },  &#13;
                ex =&gt; &#13;
                { &#13;
                    // we can handle any areas from the load async function &#13;
                }); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>The preceding functions are the same from previous implementations. Take note of how we fire the <code class="literal">Alert</code> event. Since we now have access to C# 6.0, we can turn a standard null check on an event like the following:</p><pre class="programlisting">If (Alert != null) &#13;
{ &#13;
Alert(this, new AlertArgs() &#13;
            { &#13;
                Message = message, &#13;
                Tcs = tcs &#13;
            }); &#13;
} &#13;
</pre><p>Into this:</p><pre class="programlisting">Alert?.Invoke(this, new AlertArgs() &#13;
            { &#13;
                Message = message, &#13;
                Tcs = tcs &#13;
            }); &#13;
</pre><p>It looks much cleaner, meaning we can remove all the <code class="literal">if</code> statements.</p><p>Now let's add a new file called <code class="literal">MainPageViewModel.cs</code> and implement the following:</p><pre class="programlisting">public class MainPageViewModel : ViewModelBase &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private readonly IMethods _methods; &#13;
 &#13;
        private string _descriptionMessage = "Take a Picture"; &#13;
 &#13;
        private string _cameraTitle = "Camera"; &#13;
 &#13;
        private string _exitTitle = "Exit"; &#13;
 &#13;
        private ICommand _cameraCommand; &#13;
 &#13;
        private ICommand _exitCommand; &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><p>Exactly like the other <code class="literal">MainPageViewModel</code> objects, the <code class="literal">MainPage</code> layout is the same, with two buttons, an image, and a label.</p><p>Now let's add the <code class="literal">public</code> properties. We are going to use the new <code class="literal">SetProperty</code> function for each <code class="literal">public</code> property:</p><pre class="programlisting">        #region Public Properties &#13;
 &#13;
        public string DescriptionMessage &#13;
        { &#13;
            get { return _descriptionMessage; } &#13;
            set { SetProperty(nameof(DescriptionMessage), &#13;
                  ref _descriptionMessage, value); } &#13;
        } &#13;
 &#13;
        public string CameraTitle &#13;
        { &#13;
            get { return _cameraTitle; } &#13;
            set { SetProperty(nameof(CameraTitle), ref _cameraTitle, value); } &#13;
        } &#13;
 &#13;
        public string ExitTitle &#13;
        { &#13;
            get { return _exitTitle; } &#13;
            set { SetProperty(nameof(ExitTitle), ref _exitTitle, value); } &#13;
        } &#13;
 &#13;
        public ICommand CameraCommand &#13;
        { &#13;
            get { return _cameraCommand; } &#13;
            set { SetProperty(nameof(CameraCommand), ref _cameraCommand, value); } &#13;
        } &#13;
 &#13;
        public ICommand ExitCommand &#13;
        { &#13;
            get { return _exitCommand; } &#13;
            set { SetProperty(nameof(ExitCommand), ref _exitCommand, value); } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now for the constructor, we are going to use the <code class="literal">Command</code> factory again to instantiate our binded <code class="literal">Command</code>:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public MainPageViewModel (INavigationService navigation, Func&lt;Action, ICommand&gt; commandFactory): base (navigation, methods) &#13;
        { &#13;
            _methods = methods; &#13;
 &#13;
            _exitCommand = commandFactory (async () =&gt; &#13;
            { &#13;
                await NotifyAlert("GoodBye!!"); &#13;
 &#13;
                _methods.Exit(); &#13;
            }); &#13;
 &#13;
            _cameraCommand = commandFactory (async () =&gt; await Navigation.Navigate(PageNames.CameraPage, null)); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now let's build the next view-model for the <code class="literal">CameraPage</code>. Add a new file called <code class="literal">CameraPageViewModel.cs</code> to the <code class="literal">ViewModels</code> folder and implement the private properties to begin with:</p><pre class="programlisting">public sealed class CameraPageViewModel : ViewModelBase &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private Orientation _pageOrientation; &#13;
 &#13;
        private byte[] _photoData; &#13;
 &#13;
        private string _loadingMessage = "Loading Camera..." &#13;
 &#13;
        private bool _canCapture; &#13;
 &#13;
        private bool _cameraLoading; &#13;
 &#13;
        private bool _isFlashOn; &#13;
 &#13;
        private bool _photoEditOn; &#13;
 &#13;
        #endregion &#13;
 &#13;
} &#13;
</pre><p>The <code class="literal">CameraPage</code> is going to include an <code class="literal">Orientation</code> property for adjusting <code class="literal">Grid</code> rows and columns using converters. The <code class="literal">_photoData</code> property will be used for recording the image taken as bytes, we will also be using these bytes to bind to an <code class="literal">ImageSource</code>. The <code class="literal">_loadingMessage</code> and <code class="literal">_cameraLoading</code> properties are used when displaying a view showing the native camera hardware is busy. The <code class="literal">_isFlashOn</code> will be used to control UI elements displaying the status of the flash. The <code class="literal">CameraPage</code> will also have a target image representing the focus target. Then finally, the <code class="literal">_canCapture</code> is used to determine whether the camera has loaded and we are ready to take photos, and the <code class="literal">_photoEditOn</code> is used to bind the visibility status of a view showing the photo just taken.</p><p>Next, we add the <code class="literal">public</code> properties; following are two to get you started:</p><pre class="programlisting">#region Public Properties &#13;
 &#13;
        public bool CanCapture &#13;
        { &#13;
            get { return _canCapture; } &#13;
            set { SetProperty(nameof(CanCapture), ref _canCapture, value); } &#13;
        } &#13;
 &#13;
        public string LoadingMessage &#13;
        { &#13;
            get { return _loadingMessage; } &#13;
            set { SetProperty(nameof(LoadingMessage), ref _loadingMessage, value); } &#13;
        } &#13;
 &#13;
#endregion &#13;
</pre><p>Add the constructor as follows:</p><pre class="programlisting">        #region Constructors and Destructors &#13;
 &#13;
        public CameraPageViewModel(INavigationService navigation, Func&lt;Action, ICommand&gt; commandFactory) : base (navigation, methods) &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now for the <code class="literal">public</code> functions, we have the <code class="literal">AddPhoto</code> function, this will take the image as bytes from the native side, and the <code class="literal">PhotoData</code> is assigned for the <code class="literal">ImageSource</code> binding:</p><pre class="programlisting">        public void AddPhoto(byte[] data) &#13;
        { &#13;
            PhotoData = data; &#13;
            PhotoEditOn = true; &#13;
        } &#13;
</pre><p>We also have a function for resetting the variables used in the current photo taken. When the <code class="literal">PhotoEditOn</code> is <code class="literal">false</code>, this means we remove the view that is displaying the current photo taken. When the <code class="literal">PhotoData</code> property is assigned an empty byte array, this means we have freed the data of the image that is currently displaying:</p><pre class="programlisting">        public void ResetEditPhoto() &#13;
        { &#13;
            PhotoData = new byte[] { }; &#13;
            PhotoEditOn = false; &#13;
        } &#13;
</pre><p>Finally, we have two more functions that are called when the page appears and disappears:</p><pre class="programlisting">        public void OnAppear() &#13;
        { &#13;
            CameraLoading = false; &#13;
        } &#13;
 &#13;
        public void OnDisappear() &#13;
        { &#13;
            CameraLoading = true; &#13;
            ResetEditPhoto(); &#13;
        } &#13;
</pre><p>The <code class="literal">OnAppear</code> function simply resets the <code class="literal">CameraLoading</code> property to <code class="literal">false</code>, and the <code class="literal">OnDisappear</code> function resets the entire view-model; when we return to this page, the state is the same as the starting point (that is, the camera is not loading, no photo is showing)</p><p>Excellent! Now that we have built our view-models, let's add the <code class="literal">PortableModule</code> for our IoC container as follows:</p><pre class="programlisting">public class PortableModule : IModule &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public void Register(ContainerBuilder builder) &#13;
        { &#13;
            builder.RegisterType&lt;MainPageViewModel&gt; ().SingleInstance(); &#13;
            builder.RegisterType&lt;CameraPageViewModel&gt; ().SingleInstance(); &#13;
        } &#13;
 &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>Let's begin building the user interface screens.</p></div>
<div class="section" title="Creating the custom UI objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec128"/>Creating the custom UI objects</h1></div></div></div><p>Jump back in the <code class="literal">Camera</code> project and let's begin adding a new folder called <code class="literal">Controls</code>. Add in a new file called <code class="literal">OrientationPage.cs</code> and implement the following:</p><pre class="programlisting">public class OrientationPage : ContentPage &#13;
    { &#13;
        #region Static Properties &#13;
 &#13;
        public static Orientation PageOrientation; &#13;
 &#13;
        public static event EventHandler&lt;Orientation&gt; OrientationHandler; &#13;
 &#13;
        public static event EventHandler&lt;Point&gt; TouchHandler; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Static Methods &#13;
 &#13;
        public static void NotifyOrientationChange(Orientation orientation) &#13;
        { &#13;
            if (OrientationHandler != null) &#13;
            { &#13;
                OrientationHandler (null, orientation); &#13;
            } &#13;
        } &#13;
 &#13;
        public static void NotifyTouch(Point touchPoint) &#13;
        { &#13;
            if (TouchHandler != null) &#13;
            { &#13;
                TouchHandler(null, touchPoint); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>In our previous chapter, we created an <code class="literal">ExtendedContentPage</code> for handling alerts. This time, the <code class="literal">ExtendedContentPage</code> will inherit the <code class="literal">OrientationPage</code>, meaning it will be handling orientation events as well. The <code class="literal">CameraPage</code> is going to use this <code class="literal">OrientationPage</code> to track orientation events to resize camera preview areas, and rotate the camera view.</p><p>Our next control is the <code class="literal">FocusView</code>. It is going to be used for custom rendering purposes so that we are able to record touch point (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates on a view plane. These touch points will then be used to focus the camera at that particular (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate.</p><p>Our next custom control is an extension to the <code class="literal">Image</code> class. Add another file into the <code class="literal">Controls</code> folder called <code class="literal">CustomImage.cs</code> and implement the following:</p><pre class="programlisting">public class CustomImage : View &#13;
    { &#13;
        public static readonly BindableProperty TintColorStringProperty = BindableProperty.Create ((CustomImage o) =&gt; o.TintColorString, string.Empty, &#13;
            propertyChanged: (bindable, oldvalue, newValue) =&gt;  &#13;
            { &#13;
                var eh = ((CustomImage)bindable).CustomPropertyChanged; &#13;
 &#13;
                if (eh != null) &#13;
                { &#13;
                    eh (bindable, TintColorStringProperty.PropertyName); &#13;
                } &#13;
            }); &#13;
 &#13;
        public string TintColorString &#13;
        { &#13;
            get &#13;
            { &#13;
                return (string)GetValue(TintColorStringProperty); &#13;
            } &#13;
            set &#13;
            { &#13;
                this.SetValue(TintColorStringProperty, value); &#13;
            } &#13;
        } &#13;
 &#13;
        public static readonly BindableProperty TintOnProperty = BindableProperty.Create ((CustomImage o) =&gt; o.TintOn, default(bool), &#13;
            propertyChanged: (bindable, oldvalue, newValue) =&gt;  &#13;
            { &#13;
                var eh = ((CustomImage)bindable).CustomPropertyChanged; &#13;
 &#13;
                if (eh != null) &#13;
                { &#13;
                    eh (bindable, TintOnProperty.PropertyName); &#13;
                } &#13;
            }); &#13;
 &#13;
        public bool TintOn  &#13;
        { &#13;
            get  &#13;
            { &#13;
                return (bool)GetValue (TintOnProperty); &#13;
            } &#13;
            set  &#13;
            {                  &#13;
                SetValue (TintOnProperty, value); &#13;
            } &#13;
        } &#13;
} &#13;
</pre><p>These custom bindings will be used for tinting. Since this view will be used for a <code class="literal">CustomRenderer</code>, we will have access to native tinting features. This is where we will add some advanced techniques to our <code class="literal"> CustomRenderer</code>.</p><p>Next, we are going to add two more custom bindings. The <code class="literal">Path</code> property will be used for the absolute path of the file, and the <code class="literal">Aspect</code> property will be used for the image aspect ratio so we can change the image aspect natively:</p><pre class="programlisting">        public static readonly BindableProperty PathProperty = BindableProperty.Create((CustomImage o) =&gt; o.Path, default(string), &#13;
            propertyChanged: (bindable, oldvalue, newValue) =&gt; &#13;
            { &#13;
                var eh = ((CustomImage)bindable).CustomPropertyChanged; &#13;
 &#13;
                if (eh != null) &#13;
                { &#13;
                    eh (bindable, PathProperty.PropertyName); &#13;
                } &#13;
            }); &#13;
 &#13;
        public string Path &#13;
        { &#13;
            get &#13;
            { &#13;
                return (string)GetValue(PathProperty); &#13;
            } &#13;
            set &#13;
            { &#13;
                SetValue(PathProperty, value); &#13;
            } &#13;
        } &#13;
 &#13;
        public static readonly BindableProperty AspectProperty = BindableProperty.Create((CustomImage o) =&gt; o.Aspect, default(Aspect), &#13;
            propertyChanged: (bindable, oldvalue, newValue) =&gt; &#13;
            { &#13;
                var eh = ((CustomImage)bindable).CustomPropertyChanged; &#13;
 &#13;
                if (eh != null) &#13;
                { &#13;
                    eh(bindable, AspectProperty.PropertyName); &#13;
                } &#13;
            }); &#13;
 &#13;
        public Aspect Aspect &#13;
        { &#13;
            get &#13;
            { &#13;
                return (Aspect)GetValue(AspectProperty); &#13;
            } &#13;
            set &#13;
            { &#13;
                SetValue(AspectProperty, value); &#13;
            } &#13;
        } &#13;
</pre><p>Have a look at the delegate function passed in as the last parameter for each <code class="literal">Create</code> function. This will be called every time the property changes; the <code class="literal">bindable</code> object that comes from the first parameter of this delegate function is the object itself. We retrieve the <code class="literal">CustomPropertyChangedEventHandler</code> and fire a new event to signal that a property on this object has changed.</p><p>Let's add the following to the <code class="literal">CustomImage</code> class:</p><pre class="programlisting">        public event EventHandler&lt;string&gt; CustomPropertyChanged; &#13;
 &#13;
        protected override void OnPropertyChanged (string propertyName) &#13;
        { &#13;
            base.OnPropertyChanged (propertyName); &#13;
 &#13;
            if (propertyName == &#13;
                CustomImage.TintColorStringProperty.PropertyName || &#13;
                propertyName == CustomImage.TintOnProperty.PropertyName ||  &#13;
                propertyName == CustomImage.AspectProperty.PropertyName) &#13;
            { &#13;
                if (CustomPropertyChanged != null)  &#13;
                { &#13;
                    this.CustomPropertyChanged (this, propertyName); &#13;
                } &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><p>That's all for the <code class="literal">CustomImage</code> class; let's move on to the next custom control.</p></div>
<div class="section" title="Building the FocusView"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec129"/>Building the FocusView</h1></div></div></div><p>The <code class="literal">FocusView</code> is going to be used as an overlay view with a target image for touching focus points. This will be a <code class="literal">CustomRenderer</code> as we have to use native libraries for retrieving specific (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates on touch points.</p><p>Start with adding a new file into the <code class="literal">Controls</code> folder called <code class="literal">FocusView.cs</code> and implement the following:</p><pre class="programlisting">public sealed class FocusView : RelativeLayout &#13;
    { &#13;
        #region Constant Properties &#13;
 &#13;
        const int IMG_TARGET_BOUND = 100; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Private Properties &#13;
 &#13;
        private bool _isAnimating; &#13;
 &#13;
        private bool _startingPointsAssigned; &#13;
 &#13;
        private readonly CustomImage _focalTarget; &#13;
 &#13;
        private Point _pStartingOrientation; &#13;
 &#13;
        private Point _pFlippedOrientation; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Events &#13;
 &#13;
        public event EventHandler&lt;Point&gt; TouchFocus; &#13;
 &#13;
        #endregion &#13;
 &#13;
} &#13;
</pre><p>The first part we see here are two <code class="literal">Point</code> objects for specific (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates for portrait and landscape orientation starting points. These two points will be set when the view first loads. Both points will be set to the center of the view in both landscape and portrait orientations. We also have the _<code class="literal">startingPointsAssigned</code> Boolean to ensure we only set the starting focus points once.</p><p>The <code class="literal">CustomImage</code> object is used for the actual image of the target. We will be using the tinting properties each time a user touches to focus. The <code class="literal">_isAnimating</code> property is used for tracking progress of current animations (we will be animating the scale of the image each time a touch is detected). The constant property is used to hard set the height and width of the target image, and we have two events for detecting all user touch events.</p><p>Next, we have a single public property for the orientation:</p><pre class="programlisting">        #region Public Properties &#13;
 &#13;
        public Orientation Orientation; &#13;
 &#13;
        #endregion &#13;
</pre></div>
<div class="section" title="Xamarin.Forms animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec130"/>Xamarin.Forms animations</h1></div></div></div><p><code class="literal">Xamarin.Forms</code> has multiple functions for animating views. We have access to the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FadeTo</code>: This is used to animate opacity (that is, fade in/out).</li><li class="listitem" style="list-style-type: disc"><code class="literal">RotateTo</code>: This is used to animate rotations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ScaleTo</code>: This is used to animate size.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TranslateTo</code>: This is used to animate (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) positions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LayoutTo</code>: This is used to animate <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, width, and height.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip116"/>Tip</h3><p>Stay away from the <code class="literal">LayoutTo</code> function. Jason Smith (the creator of <code class="literal">Xamarin.Forms</code>) recommends you stick with the <code class="literal">TranslateTo</code> instead. The issue with <code class="literal">LayoutTo</code> is the parent of the view you are calling <code class="literal">LayoutTo</code> on will not be aware of the translation/resize that happened and will simply overwrite it at the next layout cycle (like when you rotate the device). This is because <code class="literal">LayoutTo</code> is calling the same method Layouts call to position children.</p></div></div><p>We are now going to use a few of these animation functions to animate our target image when a use touches to focus. The <code class="literal">AnimateFocalTarget</code> function will be responsible for performing the animations every time a user touches the view. At first, it will change the tint color of the image to green, then translate the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate to the starting position, expand the scale, fade the image, contract the scale, and wait a second until the tint color changes back to white:</p><pre class="programlisting">#region Private Methods &#13;
 &#13;
        private async Task AnimateFocalTarget(Point touchPoint) &#13;
        { &#13;
            _focalTarget.TintColorString = "#007F00"; &#13;
 &#13;
            await _focalTarget.TranslateTo(touchPoint.X - (IMG_TARGET_BOUND / 2),  &#13;
                                     touchPoint.Y - (IMG_TARGET_BOUND / 2), 0).ConfigureAwait(false); &#13;
 &#13;
            await _focalTarget.ScaleTo(1, 0); &#13;
 &#13;
            // fade in &#13;
            await _focalTarget.FadeTo(0.7f, 25); &#13;
 &#13;
            await _focalTarget.ScaleTo(0.5, 250); &#13;
 &#13;
            _focalTarget.TintOn = true; &#13;
 &#13;
            await Task.Delay(1000); &#13;
 &#13;
            _focalTarget.TintColorString = "#FFFFFF"; &#13;
 &#13;
            _isAnimating = false; &#13;
        }  &#13;
 &#13;
        #endregion &#13;
</pre><p>All these await functions, is there a cleaner way?</p><p>In a lot of cases, you will need to combine multiple transitions at any one time. Let's replace the preceding combination of animations with a compound animation.</p></div>
<div class="section" title="Xamarin.Forms compound animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec131"/>Xamarin.Forms compound animations</h1></div></div></div><p>Compound animations give you the ability to combine multiple animations as a storyboard. Let's replace the preceding function with our new implementation using a compound animation as follows:</p><pre class="programlisting">private async Task AnimateFocalTarget(Point touchPoint) &#13;
        { &#13;
            _focalTarget.TintColorString = "#007F00"; &#13;
 &#13;
            var storyboard = new Animation(); &#13;
 &#13;
            var translationX = new Animation(callback: x&#13;
             =&gt; _focalTarget.TranslationX = x, &#13;
                                          start: touchPoint.X, &#13;
                                          end: touchPoint.X - (IMG_TARGET_BOUND / 2), &#13;
                                          easing: Easing.Linear); &#13;
 &#13;
            var translationY = new Animation(callback: y&#13;
             =&gt; _focalTarget.TranslationY = y, &#13;
                                          start: touchPoint.Y, &#13;
                                          end: touchPoint.Y - (IMG_TARGET_BOUND / 2), &#13;
                                          easing: Easing.Linear); &#13;
 &#13;
            var scaleFirst = new Animation(callback: o =&gt; _focalTarget.Scale = o, &#13;
                                          start: 0.5, &#13;
                                          end: 1, &#13;
                                          easing: Easing.Linear); &#13;
 &#13;
            var fade = new Animation(callback: o =&gt; _focalTarget.Opacity = o, &#13;
                                          start: 1, &#13;
                                          end: 0.7f, &#13;
                                          easing: Easing.Linear); &#13;
 &#13;
            var scaleSecond = new Animation(callback: o =&gt; _focalTarget.Scale = o, &#13;
                                          start: 1, &#13;
                                          end: 0.5f, &#13;
                                          easing: Easing.Linear); &#13;
 &#13;
            storyboard.Add(0, 0.01, translationX); &#13;
            storyboard.Add(0, 0.01, translationY); &#13;
            storyboard.Add(0, 0.01, scaleFirst); &#13;
            storyboard.Add(0, 0.5, fade); &#13;
            storyboard.Add(0.5, 1, scaleSecond); &#13;
 &#13;
            var tcs = new TaskCompletionSource&lt;bool&gt;(); &#13;
                 &#13;
            storyboard.Commit(_focalTarget, "_focalTarget", length: 300, finished: async (arg1, arg2) =&gt; &#13;
            { &#13;
                _focalTarget.TintOn = true; &#13;
 &#13;
                await Task.Delay(500); &#13;
 &#13;
                _focalTarget.TintColorString = "#FFFFFF"; &#13;
 &#13;
                _isAnimating = false; &#13;
 &#13;
                tcs.TrySetResult(true); &#13;
            }); &#13;
 &#13;
            await tcs.Task; &#13;
        } &#13;
</pre><p>Each <code class="literal">Animation</code> object has the property we are animating, a start point and an end point, and <code class="literal">easing</code> (linear, bounce in, bounce out). All <code class="literal">Animation</code> objects are then added to the storyboard. The first two parameters of the <code class="literal">Add</code> function are the start time and finish time of that particular animation. Finally, we call the commit, and instead of awaiting the <code class="literal">Commit</code> function, we will use a <code class="literal">TaskCompletionSource</code> object to await the commit until it is finished. The <code class="literal">finished</code> action is called after the length of 300 milliseconds.</p><p>Isn't that much nicer than our previous implementation?</p><p>We should use this approach when we have multiple animations to commit at any one time.</p><p>Now let's add the <code class="literal">Reset</code> functions to our <code class="literal">FocusView</code>. This will be called whenever an orientation has occurred, we will use the assign the focus point to the correct orientation starting point:</p><pre class="programlisting">        #region Public Methods &#13;
 &#13;
        public void Reset() &#13;
        { &#13;
            switch (Orientation) &#13;
            { &#13;
                case Orientation.Portrait: &#13;
                    NotifyFocus(_pStartingOrientation); &#13;
                    break; &#13;
                case Orientation.LandscapeLeft: &#13;
                case Orientation.LandscapeRight: &#13;
                    NotifyFocus(_pFlippedOrientation); &#13;
                    break; &#13;
            } &#13;
        } &#13;
</pre><p>The <code class="literal">NotifyFocus</code> function is responsible for controlling the entire touch animation; this is where we will set the starting state of the <code class="literal">_focalTarget</code> image, call the <code class="literal">AddFocualTargetImg</code> function, and then fire the <code class="literal">TouchFocus</code> event. This event will be used to focus the <code class="literal">CameraView</code> through the custom renderer:</p><pre class="programlisting">        public void NotifyFocus(Point touchPoint) &#13;
        { &#13;
            if (_isAnimating)  &#13;
            { &#13;
                return; &#13;
            } &#13;
 &#13;
            _focalTarget.Opacity = 0.0f; &#13;
            _focalTarget.TintOn = false; &#13;
            _isAnimating = true; &#13;
 &#13;
            Device.BeginInvokeOnMainThread(async () =&gt; await AnimateFocalTarget(touchPoint)); &#13;
 &#13;
            TouchFocus?.Invoke (this, touchPoint); &#13;
        } &#13;
</pre><p>Finally, we have the <code class="literal">SetFocusPoints</code> function to assign the starting focus points in each orientation (landscape and portrait). These starting points will always be the center of the <code class="literal">CameraView</code>. This is to ensure that the <code class="literal">_focalTarget</code> image is centered inside the <code class="literal">CameraView</code> on every change in orientation:</p><pre class="programlisting">        public void SetFocusPoints(Point pStart, Point pFlipped) &#13;
        { &#13;
            _pStartingOrientation = pStart; &#13;
            _pFlippedOrientation = pFlipped; &#13;
        } &#13;
 &#13;
 &#13;
        #endregion  &#13;
</pre><p>That's everything for our <code class="literal">FocusView</code>. Let's add our next custom UI element, the <code class="literal">CameraView</code>.</p></div>
<div class="section" title="Building the CameraView"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec132"/>Building the CameraView</h1></div></div></div><p>Our next custom element is the UI object for rendering the native camera. Let's add a new file into the <code class="literal">Controls</code> folder called <code class="literal">CameraView.cs</code> and implement the first part:</p><pre class="programlisting">public sealed class CameraView : ContentView &#13;
    { &#13;
        #region Events &#13;
 &#13;
        public event EventHandler&lt;Orientation&gt; OrientationChange; &#13;
 &#13;
        public event EventHandler&lt;Point&gt; Focus; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; AvailabilityChange; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; OpenCamera; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Busy; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Flash; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Torch; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Loading; &#13;
 &#13;
        public event EventHandler&lt;byte[]&gt; Photo; &#13;
 &#13;
        public event EventHandler&lt;float&gt; Widths; &#13;
 &#13;
        public event EventHandler Shutter; &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><p>There are many events to manage because we have to handle events coming from the <code class="literal">Xamarin.Forms</code> object in order for the native object to respond to, and vice-versa.</p><p>Next, we add the public properties:</p><pre class="programlisting">        #region Public Properties &#13;
 &#13;
        public bool CameraAvailable; &#13;
 &#13;
        public Orientation Orientation; &#13;
 &#13;
        public float CameraButtonContainerWidth = 0f; &#13;
 &#13;
        #endregion &#13;
</pre><p>The first <code class="literal">bool</code> is set when we receive events for the <code class="literal">AvailabilityChangeEventHandler</code>. The <code class="literal">Orientation</code> property is assigned every time the screen orientation changes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip117"/>Tip</h3><p>Screen orientation changes will come from the native side, these events will come from the <code class="literal">AppDelegate </code>(iOS), <code class="literal">MainActivity </code>(Android), and <code class="literal">MainPage.xaml.cs</code> (Windows).</p></div></div><p>Then we have the <code class="literal">CameraButtonContainerWidth</code>, this will only be relevant for iOS as we need to resize the preview layer for the iOS camera when the orientation changes.</p><p>Our next functions are all for notifying the preceding events:</p><pre class="programlisting">        #region Public Methods &#13;
 &#13;
        public void NotifyShutter() &#13;
        { &#13;
            Shutter?.Invoke(this, EventArgs.Empty); &#13;
        } &#13;
 &#13;
        public void NotifyOpenCamera(bool open) &#13;
        { &#13;
            OpenCamera?.Invoke(this, open); &#13;
        } &#13;
 &#13;
        public void NotifyFocus(Point touchPoint) &#13;
        { &#13;
            Focus?.Invoke(this, touchPoint); &#13;
        } &#13;
 &#13;
        public void NotifyBusy(object sender, bool busy) &#13;
        { &#13;
            Busy?.Invoke(this, busy); &#13;
        } &#13;
 &#13;
        public void NotifyOrientationChange(Orientation orientation) &#13;
        { &#13;
            Orientation = orientation; &#13;
 &#13;
            OrientationChange?.Invoke(this, orientation); &#13;
        } &#13;
 &#13;
        public void NotifyAvailability(object sender, bool isAvailable) &#13;
        { &#13;
            CameraAvailable = isAvailable; &#13;
 &#13;
            AvailabilityChange?.Invoke(this, isAvailable); &#13;
        } &#13;
 &#13;
        public void NotifyPhoto(object sender, byte[] imageData) &#13;
        { &#13;
            Photo?.Invoke(this, imageData); &#13;
        } &#13;
 &#13;
        public void NotifyFlash(bool flashOn) &#13;
        { &#13;
            Flash?.Invoke(this, flashOn); &#13;
        } &#13;
 &#13;
  public void NotifyTorch(bool torchOn) &#13;
        { &#13;
            Torch?.Invoke(this, torchOn); &#13;
        } &#13;
 &#13;
        public void NotifyLoading(object sender, bool loading) &#13;
        { &#13;
            Loading?.Invoke(this, loading); &#13;
        } &#13;
 &#13;
        public void NotifyWidths(float cameraButtonContainerWidth) &#13;
        { &#13;
            CameraButtonContainerWidth = cameraButtonContainerWidth; &#13;
 &#13;
            Widths?.Invoke (this, cameraButtonContainerWidth); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Then, we have the constructor:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public CameraView() &#13;
        { &#13;
            BackgroundColor = Color.Black; &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Excellent! Now we have the final custom control to build. Add a new <code class="literal">ContentView.xaml</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_08_001.jpg" alt="Building the CameraView"/></div><p>Call the <code class="literal">LoadingView.xaml</code> file and implement the following:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt; &#13;
&lt;ContentView  &#13;
     &#13;
    x:Class="Camera.Controls.LoadingView" &#13;
     &#13;
     &#13;
    BackgroundColor="White"&gt; &#13;
 &#13;
    &lt;Grid x:Name="MainLayout" BackgroundColor="Black"&gt; &#13;
        &lt;Grid.RowDefinitions&gt; &#13;
            &lt;RowDefinition Height="*" /&gt; &#13;
        &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
        &lt;Grid.ColumnDefinitions&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
        &lt;/Grid.ColumnDefinitions&gt; &#13;
         &#13;
        &lt;StackLayout Orientation="Vertical" HorizontalOptions="Center" VerticalOptions="Center"  &#13;
                Grid.Row="0" Grid.Column="0"&gt; &#13;
            &lt;ActivityIndicator x:Name="ProgressActivity" Color="White" IsRunning="true"  /&gt; &#13;
            &lt;Label x:Name="LoadingLabel" Text="{Binding LoadingMessage}" TextColor="White"/&gt; &#13;
        &lt;/StackLayout&gt; &#13;
    &lt;/Grid&gt; &#13;
&lt;/ContentView&gt; &#13;
</pre><p>The layout of the <code class="literal">FocusView</code> consists of a <code class="literal">Grid</code> containing another <code class="literal">StackLayout</code>, which is centered both horizontally and vertically inside the <code class="literal">Grid</code>. The <code class="literal">StackLayout</code> contains an <code class="literal">ActivityIndicator</code>, which will be running every time this view is shown, and a <code class="literal">Label</code> to display a loading message.</p><p>Then, expand the <code class="literal">LoadingView.xaml.cs</code> and implement the following:</p><pre class="programlisting">   public partial class LoadingView : ContentView &#13;
    { &#13;
        public LoadingView() &#13;
        { &#13;
            InitializeComponent(); &#13;
        } &#13;
    } &#13;
</pre><p>This view will be used on the <code class="literal">CameraPage</code>. When the camera is loading or processing an image, the entire screen will be cast black, displaying the <code class="literal">ActivityIndicator</code> and loading message, to show the user that the camera is processing.</p></div>
<div class="section" title="Building a control for the iOS camera"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec133"/>Building a control for the iOS camera</h1></div></div></div><p>Now that we have built the <code class="literal">CameraView</code> object in the <code class="literal">Xamarin.Forms</code> PCL, we are going to build the <code class="literal">CustomRenderer</code> for iOS. Jump into the <span class="strong"><strong>Camera.iOS </strong></span>project and add a new folder called <code class="literal">Renderers</code>, and then add a new file called <code class="literal">CameraiOS.cs</code> and implement the following private properties:</p><pre class="programlisting">public sealed class CameraIOS : UIView &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private readonly string _tag; &#13;
 &#13;
        private readonly ILogger _log; &#13;
 &#13;
        private readonly AVCaptureVideoPreviewLayer _previewLayer; &#13;
 &#13;
        private readonly AVCaptureSession _captureSession; &#13;
 &#13;
        private UIView _mainView; &#13;
 &#13;
        private AVCaptureDeviceInput _input; &#13;
 &#13;
        private AVCaptureStillImageOutput _output; &#13;
 &#13;
        private AVCaptureConnection _captureConnection; &#13;
 &#13;
        private AVCaptureDevice _device; &#13;
 &#13;
         &#13;
        private bool _cameraBusy; &#13;
 &#13;
        private bool _cameraAvailable; &#13;
 &#13;
        private float _cameraButtonContainerWidth; &#13;
 &#13;
        private float _imgScale = 1.25f; &#13;
 &#13;
        private double _systemVersion; &#13;
 &#13;
        private nint _width; &#13;
 &#13;
        private nint _height; &#13;
 &#13;
 #endregion &#13;
} &#13;
</pre><p>The <code class="literal">_tag </code>and <code class="literal">_log</code> properties will be used for all logging that occurs when an exception occurs. The <code class="literal">_previewLayer</code> is used to display the video input from the camera; this will be set to the entire width and height of the <code class="literal">CameraView</code>. The <code class="literal">_captureSession</code> is used in conjunction with an <code class="literal">AVCaptireVideoPreviewLayer</code> object for capturing an image from the video input. The <code class="literal">_input</code> object is used in conjunction with an <code class="literal">AVCaptureDevice</code> and <code class="literal">CaptureSession</code>; this provides the video stream input, which the <code class="literal">CaptureSession</code> will use to capture an image. We also have an <code class="literal">AVCaptureStillImageOutput</code> object called <code class="literal">_output</code>; this is used to capture high-quality still images with accompanying metadata.</p><p>An <code class="literal">AVCaptureStillImageOutput</code> object also contains <code class="literal">AVCaptureConnections</code>, which we use for controlling the video stream orientation. Then finally, we have the <code class="literal">_device</code> property, which is the object that represents a physical capture device. In our example, we are going to use the rear camera. We will see how the remaining properties are used through the other functions.</p><p>Next we have to add three events that will be notified when the camera is busy, when the camera is available, and when a photo is taken:</p><pre class="programlisting">   #region Events &#13;
 &#13;
  public event EventHandler&lt;bool&gt; Busy; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Available; &#13;
 &#13;
        public event EventHandler&lt;byte[]&gt; Photo; &#13;
 &#13;
        #endregion &#13;
</pre><p>Then we have the constructor:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public CameraIOS() &#13;
        { &#13;
            _log = IoC.Resolve&lt;ILogger&gt;(); &#13;
            _tag = $"{GetType()} "; &#13;
 &#13;
            // retrieve system version  &#13;
            var versionParts = UIDevice.CurrentDevice.SystemVersion.Split ('.'); &#13;
            var versionString = versionParts [0] + "." + versionParts [1]; &#13;
            _systemVersion = Convert.ToDouble (versionString, CultureInfo.InvariantCulture); &#13;
 &#13;
            _mainView = new UIView () { TranslatesAutoresizingMaskIntoConstraints = false }; &#13;
            AutoresizingMask = UIViewAutoresizing.FlexibleMargins; &#13;
 &#13;
            _captureSession = new AVCaptureSession(); &#13;
 &#13;
            _previewLayer = new AVCaptureVideoPreviewLayer(_captureSession) &#13;
            { &#13;
                VideoGravity = AVLayerVideoGravity.Resize &#13;
            }; &#13;
 &#13;
            _mainView.Layer.AddSublayer (_previewLayer); &#13;
 &#13;
            // retrieve camera device if available &#13;
            _cameraAvailable = RetrieveCameraDevice (); &#13;
 &#13;
            Add (_mainView); &#13;
 &#13;
            // set layout constraints for main view &#13;
            AddConstraints (NSLayoutConstraint.FromVisualFormat("V:|[mainView]|", NSLayoutFormatOptions.DirectionLeftToRight, null, new NSDictionary("mainView", _mainView))); &#13;
            AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|[mainView]|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("mainView", _mainView))); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>The constructor will start with retrieving the <code class="literal">ILogger</code> object from the <code class="literal">IoC</code> container and assigning the <code class="literal">_tag</code> to the type name using C# 6. Then we retrieve the system version information and create a new <code class="literal">UIView</code>. Setting the <code class="literal">AutoresizingMask</code> to <code class="literal">UIViewAutoresizing.FlexibleMargins</code> ensures that the <code class="literal">CameraiOS</code> view adjusts to the entire bounds of the <code class="literal">CustomRenderer</code>. Then we instantiate a new <code class="literal">AvCaptureSession</code> and an <code class="literal">AVCaptureVideoPreviewLayer</code>, we pass the <code class="literal">AVCaptureSession</code> object into the new <code class="literal">AVCaptureVideoPreviewLayer, </code>and add this layer to the <code class="literal">mainView</code> layer. We then retrieve the physical camera device using the <code class="literal">RetrieveCameraDevice</code> function.</p><p>Let's add this function in below the constructor:</p><pre class="programlisting">public bool RetrieveCameraDevice() &#13;
        { &#13;
            _device = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video); &#13;
 &#13;
            if (_device == null)  &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + "RetrieveCameraDevice() No device detected \n "); &#13;
             &#13;
                return false; &#13;
            } &#13;
 &#13;
            return true; &#13;
        } &#13;
</pre><p>On this line, add the following:</p><pre class="programlisting">_device = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video); &#13;
</pre><p>This is used to retrieve the physical rear-view camera.</p><p>Now let's get back to the constructor. After we retrieved the physical device, we simply add the <code class="literal">mainView</code> to the <code class="literal">CameraiOS</code> view and set the layout constraints of the <code class="literal">mainView </code>to fill the bounds of the <code class="literal">CameraiOS</code> view.</p><p>Next, we add the <code class="literal">private</code> functions. Our first function <code class="literal">AdjustPreviewLayer</code> is responsible for setting the bounds of the layer to fill the <code class="literal">CameraiOS</code> view when an orientation change occurs:</p><pre class="programlisting">        #region Private Methods &#13;
 &#13;
        /// &lt;param name="orientation"&gt;Orientation.&lt;/param&gt; &#13;
        private void AdjustPreviewLayer(Orientation orientation) &#13;
        { &#13;
            CGRect previewLayerFrame = _previewLayer.Frame; &#13;
 &#13;
            switch (orientation) &#13;
            { &#13;
                case Orientation.Portrait: &#13;
                    previewLayerFrame.Height = UIScreen.MainScreen.Bounds.Height - _cameraButtonContainerWidth; &#13;
                    previewLayerFrame.Width = UIScreen.MainScreen.Bounds.Width; &#13;
                    break; &#13;
 &#13;
                case Orientation.LandscapeLeft: &#13;
                case Orientation.LandscapeRight: &#13;
                    if (_systemVersion &gt;= 8) &#13;
                    { &#13;
                        previewLayerFrame.Width = UIScreen.MainScreen.Bounds.Width - _cameraButtonContainerWidth; &#13;
                        previewLayerFrame.Height = UIScreen.MainScreen.Bounds.Height; &#13;
                    } &#13;
                    else &#13;
                    { &#13;
                        previewLayerFrame.Width = UIScreen.MainScreen.Bounds.Height - _cameraButtonContainerWidth; &#13;
                        previewLayerFrame.Height = UIScreen.MainScreen.Bounds.Width; &#13;
                    } &#13;
                    break; &#13;
            } &#13;
 &#13;
            try &#13;
            { &#13;
                _previewLayer.Frame = previewLayerFrame; &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "AdjustPreviewLayer() Failed to adjust frame \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
        } &#13;
</pre><p>We also need a function for setting the starting orientation:</p><pre class="programlisting">        private void SetStartOrientation() &#13;
        { &#13;
            Orientation sOrientation = Orientation.None; &#13;
 &#13;
            switch (UIApplication.SharedApplication.StatusBarOrientation) &#13;
            { &#13;
                case UIInterfaceOrientation.Portrait: &#13;
                case UIInterfaceOrientation.PortraitUpsideDown: &#13;
                    sOrientation = Orientation.Portrait; &#13;
                    break; &#13;
                case UIInterfaceOrientation.LandscapeLeft: &#13;
                    sOrientation = Orientation.LandscapeLeft; &#13;
                    break; &#13;
                case UIInterfaceOrientation.LandscapeRight: &#13;
                    sOrientation = Orientation.LandscapeRight; &#13;
                    break; &#13;
            } &#13;
 &#13;
            HandleOrientationChange(sOrientation); &#13;
        } &#13;
</pre><p>Then we have the <code class="literal">SetBusy</code> function, which will invoke the <code class="literal">Busy</code> EventHandler and set the <code class="literal">private</code> variable to keep the busy status locally:</p><pre class="programlisting">        private void SetBusy(bool busy) &#13;
        { &#13;
            _cameraBusy = busy; &#13;
 &#13;
            // set camera busy  &#13;
            Busy?.Invoke(this, _cameraBusy); &#13;
        } &#13;
</pre><p>Next, we have the <code class="literal">CaptureImageWithMetadata</code> function. This is called every time the user clicks to take a picture (this function will be called from the public method <code class="literal">TakePhoto</code>). When we call the <code class="literal">CaptureImageWithMetadata</code> function, we must pass in an <code class="literal">AVCaptureStillImageOutput</code> object and an <code class="literal">AVCaptureConnection</code>. From the <code class="literal">AVCaptureStillImageOutput</code> object, we call the <code class="literal">CaptureStillImageTaskAsync</code> function on the <code class="literal">AVCaptureConnection</code>. The connection we pass in is linked to the <code class="literal">_previewLayer</code> connection. After this call is successful, we retrieve the raw image as a JPEG and retrieve the raw bytes to invoke the <code class="literal">Photo </code>EventHandler. We also use the <code class="literal">RotateImage</code> function for rotating the original <code class="literal">UIImage</code> image to the correct orientation:</p><pre class="programlisting">        private async Task CaptureImageWithMetadata(AVCaptureStillImageOutput captureStillImageOutput, AVCaptureConnection connection) &#13;
        { &#13;
            var sampleBuffer = await captureStillImageOutput.CaptureStillImageTaskAsync(connection); &#13;
            var imageData = AVCaptureStillImageOutput.JpegStillToNSData(sampleBuffer); &#13;
            var image = UIImage.LoadFromData(imageData); &#13;
 &#13;
            RotateImage(ref image); &#13;
 &#13;
            try &#13;
            { &#13;
                byte[] imgData = image.AsJPEG().ToArray(); &#13;
 &#13;
                if (Photo != null) &#13;
                { &#13;
                    Photo(this, imgData); &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "CaptureImageWithMetadata() Failed to take photo \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion</pre><p>Let's add the <code class="literal">RotateImage</code> function:</p><pre class="programlisting"> &#13;
private void RotateImage(ref UIImage image) &#13;
        { &#13;
            CGImage imgRef = image.CGImage; &#13;
            CGAffineTransform transform = CGAffineTransform.MakeIdentity(); &#13;
 &#13;
            var imgHeight = imgRef.Height * _imgScale; &#13;
            var imgWidth = imgRef.Width * _imgScale; &#13;
 &#13;
            CGRect bounds = new CGRect(0, 0, imgWidth, imgHeight); &#13;
            CGSize imageSize = new CGSize(imgWidth, imgHeight); &#13;
            UIImageOrientation orient = image.Orientation; &#13;
 &#13;
            switch (orient) &#13;
            { &#13;
                case UIImageOrientation.Up: &#13;
                    transform = CGAffineTransform.MakeIdentity(); &#13;
                    break; &#13;
                case UIImageOrientation.Down: &#13;
                    transform = CGAffineTransform.MakeTranslation (imageSize.Width, imageSize.Height); &#13;
                    transform = CGAffineTransform.Rotate(transform, (float)Math.PI); &#13;
                    break; &#13;
                case UIImageOrientation.Right: &#13;
                    bounds.Size = new CGSize( bounds.Size.Height, bounds.Size.Width); &#13;
                    transform = CGAffineTransform.MakeTranslation(imageSize.Height, 0); &#13;
                    transform = CGAffineTransform.Rotate(transform, (float)Math.PI / 2.0f); &#13;
                    break; &#13;
                default: &#13;
                    throw new Exception("Invalid image orientation");                         &#13;
            } &#13;
 &#13;
            UIGraphics.BeginImageContext(bounds.Size); &#13;
            CGContext context = UIGraphics.GetCurrentContext(); &#13;
 &#13;
            if (orient == UIImageOrientation.Right) &#13;
            { &#13;
                context.ScaleCTM(-1, 1); &#13;
                context.TranslateCTM(-imgHeight, 0); &#13;
            } &#13;
            else &#13;
            { &#13;
                context.ScaleCTM(1, -1); &#13;
                context.TranslateCTM(0, -imgHeight); &#13;
            } &#13;
 &#13;
            context.ConcatCTM(transform); &#13;
 &#13;
            context.DrawImage(new CGRect(0, 0, imgWidth, imgHeight), imgRef); &#13;
            image = UIGraphics.GetImageFromCurrentImageContext(); &#13;
            UIGraphics.EndImageContext(); &#13;
        } &#13;
</pre><p>In the preceding function, we use the <code class="literal">UIGraphics</code> context for rebuilding and rotating the <code class="literal">UIImage</code> image. We start with a new <code class="literal">CGImage</code>, gather the orientation from the original <code class="literal">UIImage</code>, and transform this image, then redraw using the <code class="literal">UIGraphics.GetImageFromCurrentImageContext()</code> method.</p><p>Now we add the public methods. Start with overriding the <code class="literal">Draw</code> function so that we can assign the most recent frame on the <code class="literal">_previewLayer</code>. The <code class="literal">Draw</code> function is called every time the screen rotates. We want to ensure the <code class="literal">_previewLayer</code> frame fills the bounds of the screen:</p><pre class="programlisting">        public override void Draw(CGRect rect) &#13;
        { &#13;
            _previewLayer.Frame = rect; &#13;
 &#13;
            base.Draw(rect); &#13;
        } &#13;
</pre><p>Next, we have the <code class="literal">TakePhoto</code> function. This will retrieve the current <code class="literal">AVCaptureConnection</code> from the <code class="literal">AVCaptureStillImageOutput</code>, set the connection orientation to the <code class="literal">_previewLayer </code>orientation, and pass the connection and output to the <code class="literal">CaptureImageWithMetadata</code> function:</p><pre class="programlisting">        public async Task TakePhoto() &#13;
        { &#13;
            if (!_cameraBusy)  &#13;
            { &#13;
                SetBusy(true); &#13;
 &#13;
                try  &#13;
                { &#13;
                    // set output orientation &#13;
                    _output.Connections [0].VideoOrientation = _previewLayer.Orientation; &#13;
 &#13;
                    var connection = _output.Connections[0]; &#13;
 &#13;
                    await CaptureImageWithMetadata(_output, connection); &#13;
 &#13;
                    SetBusy(false); &#13;
                } &#13;
                catch (Exception error) &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "TakePhoto() Error with camera output capture \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace); &#13;
                         &#13;
                    IoC.Resolve&lt;ILogger&gt;().WriteLineTime  ("CameraIOS: Error with camera output capture - " + e); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note118"/>Note</h3><p>Don't forget to look at the exception handling occurring for all functions. Sometimes, bizarre errors can occur (null connections, device retrieval fails) when dealing with camera hardware, so we must handle all exceptions that may occur.</p></div></div><p>Next, we have the <code class="literal">SwitchFlash</code> function, which is used to turn the flash on/off using the <code class="literal">AVCaptureDevice</code> configurations:</p><pre class="programlisting">        public void SwitchFlash(bool flashOn) &#13;
        { &#13;
            NSError err; &#13;
 &#13;
            if (_cameraAvailable &amp;&amp; _device != null)  &#13;
            { &#13;
                try  &#13;
                { &#13;
                    _device.LockForConfiguration(out err); &#13;
                    _device.TorchMode = flashOn ? AVCaptureTorchMode.On : AVCaptureTorchMode.Off; &#13;
                    _device.UnlockForConfiguration(); &#13;
                }  &#13;
                catch (Exception error)  &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "SwitchFlash() Failed to switch flash on/off \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>Then we have the <code class="literal">SetBounds</code> function. This is called from the <code class="literal">OnElementPropertyChanged</code> method of the <code class="literal">CustomRenderer</code>, on any height and with property changes:</p><pre class="programlisting">        public void SetBounds(nint width, nint height) &#13;
        { &#13;
            _height = height; &#13;
            _width = width; &#13;
        } &#13;
</pre><p>The <code class="literal">ChangeFocusPoint</code> function is used for focusing the camera to the touch point received from the user. First, we must lock the <code class="literal">AVCaptureDevice</code> configurations before making any changes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip119"/>Tip</h3><p>When we make changes to the <code class="literal">AVCaptureDevice</code> configurations, we must first call <code class="literal">LockForConfiguration</code> to notify the device that we are making changes and then, once we are finished, call <code class="literal">UnlockForConfiguration</code> for the changes to take effect.</p></div></div><p>Then we check to see if the <code class="literal">FocusPointOfInterestSupported</code> is <code class="literal">true</code> and set the <code class="literal">FocusPointOfInterest</code> to a new <code class="literal">CGRect</code> point. We also do the same with exposure by first checking the<code class="literal"> ExposurePointOfInterestSupported</code> is <code class="literal">true</code> and setting the <code class="literal">ExposurePointOfInterest</code> to a new <code class="literal">CGRect</code> point:</p><pre class="programlisting">        public void ChangeFocusPoint(Point fPoint) &#13;
        { &#13;
            NSError err; &#13;
 &#13;
            if (_cameraAvailable &amp;&amp; _device != null)  &#13;
            { &#13;
                try  &#13;
                { &#13;
                    _device.LockForConfiguration(out err); &#13;
 &#13;
                    var focus_x = fPoint.X / Bounds.Width; &#13;
                    var focus_y = fPoint.Y / Bounds.Height; &#13;
 &#13;
                    // set focus point &#13;
                    if (_device.FocusPointOfInterestSupported) &#13;
                        _device.FocusPointOfInterest =&#13;
                        new CGPoint(focus_x, focus_y); &#13;
                    if (_device.ExposurePointOfInterestSupported) &#13;
                        _device.ExposurePointOfInterest =&#13;
                        new CGPoint(focus_x, focus_y); &#13;
 &#13;
                    _device.UnlockForConfiguration(); &#13;
                }  &#13;
                catch (Exception error)  &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "SwitchFlash() Failed to adjust focus \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>Our next function is <code class="literal">InitializeCamera</code>, which we use to set up the <code class="literal">AVCaptureDevice</code>. We set the focus mode to <code class="literal">ContinuousAuto</code> and create a new <code class="literal">AVCaptureDeviceInput</code> using the instance of the <code class="literal">AVCaptureDevice</code>. We then create a new <code class="literal">AvCaptureStillImageOutput</code> object. Both the <code class="literal">AVCaptureDeviceInput</code> and <code class="literal">AvCaptureStillImageOutput</code> objects are assigned to the input/output of the <code class="literal">AVCaptureSession</code>, respectively. After this, the new <code class="literal">NSDictionary</code> is created with a key to set the video CODEC to JPEG (all still images taken will be in this format). Finally, the <code class="literal">Connection</code> object from the <code class="literal">_previewLayer</code> is retrieved, the starting orientation is set accordingly, and we call the <code class="literal">StartRunning</code> method on the <code class="literal">AVCaptureSession</code>:</p><pre class="programlisting">        public void InitializeCamera() &#13;
        { &#13;
            try  &#13;
            { &#13;
                NSError error; &#13;
                NSError err; &#13;
 &#13;
                _device.LockForConfiguration(out err); &#13;
                _device.FocusMode = AVCaptureFocusMode.ContinuousAutoFocus; &#13;
                _device.UnlockForConfiguration(); &#13;
 &#13;
                _input = new AVCaptureDeviceInput(_device, out error); &#13;
                _captureSession.AddInput(_input); &#13;
 &#13;
                _output = new AVCaptureStillImageOutput(); &#13;
 &#13;
                var dict = new NSMutableDictionary(); &#13;
                dict[AVVideo.CodecKey] = new NSNumber((int) AVVideoCodec.JPEG); &#13;
                _captureSession.AddOutput (_output); &#13;
 &#13;
                InvokeOnMainThread(delegate  &#13;
                    { &#13;
                        // capture connection used for rotating camera &#13;
                        _captureConnection = _previewLayer.Connection; &#13;
                        SetStartOrientation(); &#13;
                        // set orientation before loading camera &#13;
                        _captureSession.StartRunning (); &#13;
                    }); &#13;
            } &#13;
            catch (Exception error)  &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "InitializeCamera() Camera failed to initialise \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace);     &#13;
            } &#13;
 &#13;
            Available?.Invoke(this, _cameraAvailable); &#13;
 &#13;
            _log.WriteLineTime(_tag + "\n" + "RetrieveCameraDevice() Camera initalised \n "); &#13;
        } &#13;
</pre><p>Our next function is <code class="literal">SetWidths</code>, which will assign the local <code class="literal">_cameraButtonConatinerWidth</code> property accordingly. This <code class="literal">local</code> property is used as an extra reduction on the camera stream width to ensure that the camera stream does not fall behind the black button panel on the <code class="literal">CameraPage</code>:</p><pre class="programlisting">        public void SetWidths(float cameraButtonContainerWidth) &#13;
        { &#13;
            _cameraButtonContainerWidth = cameraButtonContainerWidth; &#13;
        } &#13;
</pre><p>Next, the last function is <code class="literal">HandleOrientationChange</code>, which will be called from the <code class="literal">CustomRenderer</code> every time an orientation occurs because we must update the <code class="literal">VideoOrientation</code> property of the <code class="literal">AVCaptureConnection</code> object.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip120"/>Tip</h3><p>Even though <code class="literal">Xamarin.Forms</code> automatically handles the orientation changes of the views for you, with this <code class="literal">CustomRenderer</code> view, the video stream from the <code class="literal">AVCaptureVideoPreviewLayer</code> does not rotate unless we change the underlying <code class="literal">CALayers</code>.</p></div></div><pre class="programlisting">public void HandleOrientationChange(Orientation orientation)&#13;
 {&#13;
 if (_captureConnection != null)&#13;
 {&#13;
 switch (orientation)&#13;
 {&#13;
 case Orientation.Portrait: _captureConnection.VideoOrientation = AVCaptureVideoOrientation.Portrait;&#13;
 break;&#13;
 case Orientation.LandscapeLeft: _captureConnection.VideoOrientation = AVCaptureVideoOrientation.LandscapeLeft;&#13;
 break;&#13;
 case Orientation.LandscapeRight: _captureConnection.VideoOrientation = AVCaptureVideoOrientation.LandscapeRight;&#13;
 break;&#13;
 }&#13;
 }&#13;
 AdjustPreviewLayer(orientation);&#13;
 }</pre><p>Finally, we have the <code class="literal">StopAndDispose</code> method. This will be called from the <code class="literal">Dipose</code> method of the <code class="literal">CustomRenderer</code>. It is responsible for freeing up all the resources involved with the camera stream, and switching off the flash if it is on:</p><pre class="programlisting">public void StopAndDispose()&#13;
 {&#13;
 if (_device != null)&#13;
 {&#13;
 // if flash is on turn off if (_device.TorchMode == AVCaptureTorchMode.On)&#13;
 {&#13;
 SwitchFlash(false);&#13;
 }&#13;
 }&#13;
 _captureSession.StopRunning();&#13;
 // dispose output elements _input.Dispose();&#13;
 _output.Dispose();&#13;
 }&#13;
 #endregion&#13;
 }</pre><p>Well done! Now we have built the native camera control, we are going to use this as the control for our CustomRenderer.</p></div>
<div class="section" title="Building the iOS CameraRenderer"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec134"/>Building the iOS CameraRenderer</h1></div></div></div><p>Now let's create the actual <code class="literal">CustomRenderer</code> that will use this custom iOS object. Add a new file into <span class="strong"><strong>Renderers</strong></span> | <span class="strong"><strong>CameraView</strong></span>, call it <code class="literal">CameraViewRenderer.cs</code>, and implement the following:</p><pre class="programlisting">public class CameraViewRenderer : ViewRenderer&lt;CameraView, CameraIOS&gt; &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private CameraIOS bodyshopCameraIOS; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Protected Methods &#13;
 &#13;
        protected override void OnElementChanged(ElementChangedEventArgs&lt;CameraView&gt; e) &#13;
        { &#13;
            base.OnElementChanged(e); &#13;
 &#13;
            if (Control == null) &#13;
            { &#13;
                bodyshopCameraIOS = new CameraIOS(); &#13;
 &#13;
                bodyshopCameraIOS.Busy += Element.NotifyBusy; &#13;
                bodyshopCameraIOS.Available += Element.NotifyAvailability; &#13;
                bodyshopCameraIOS.Photo += Element.NotifyPhoto; &#13;
 &#13;
                SetNativeControl(bodyshopCameraIOS); &#13;
            } &#13;
 &#13;
            if (e.OldElement != null) &#13;
            { &#13;
                e.NewElement.Flash -= HandleFlash; &#13;
                e.NewElement.OpenCamera -= HandleCameraInitialisation; &#13;
                e.NewElement.Focus -= HandleFocus; &#13;
                e.NewElement.Shutter -= HandleShutter; &#13;
                e.NewElement.Widths -= HandleWidths; &#13;
 &#13;
                bodyshopCameraIOS.Busy -= Element.NotifyBusy; &#13;
                bodyshopCameraIOS.Available -= Element.NotifyAvailability; &#13;
                bodyshopCameraIOS.Photo -= Element.NotifyPhoto; &#13;
            } &#13;
 &#13;
            if (e.NewElement != null) &#13;
            { &#13;
                e.NewElement.Flash += HandleFlash; &#13;
                e.NewElement.OpenCamera += HandleCameraInitialisation; &#13;
                e.NewElement.Focus += HandleFocus; &#13;
                e.NewElement.Shutter += HandleShutter; &#13;
                e.NewElement.Widths += HandleWidths; &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
 &#13;
} &#13;
</pre><p>The first part of our <code class="literal">CustomRenderer</code> shows the <code class="literal">OnElementChanged</code> override. In all custom renderers, the <code class="literal">OnElementChanged</code> function may be called multiple times, so care must be taken to avoid any memory leaks that can lead to performance impact. Following is the approach that should be taken:</p><pre class="programlisting">protected override void OnElementChanged (ElementChangedEventArgs&lt;NativeListView&gt; e) &#13;
{ &#13;
base.OnElementChanged (e); &#13;
 &#13;
if (Control == null) { &#13;
// Instantiate the native control &#13;
} &#13;
 &#13;
if (e.OldElement != null) { &#13;
// Unsubscribe from event handlers and cleanup any resources &#13;
} &#13;
 &#13;
if (e.NewElement != null) { &#13;
        // Configure the control and subscribe to event handlers &#13;
    } &#13;
} &#13;
</pre><p>Now back to the <code class="literal">OnElementChanged</code> implementation, we instantiate a new <code class="literal">CameraiOS</code> and register the EventHandlers to the <code class="literal">Xamarin.Forms</code><code class="literal">CameraView</code> functions. This will fire another event that will be handled on our <code class="literal">CameraPage</code>. We then call <code class="literal">SetNativeControl</code> to assign the <code class="literal">CameraiOS</code> object to the <code class="literal">CustomRenderer</code> control, so when <code class="literal">CameraView</code> object is displayed on a <code class="literal">ContentPage</code>, a <code class="literal">CameraiOS</code> view will appear on top. We then register events and unregister events in both the if blocks to correctly dispose and assign the <code class="literal">CameraView</code> EventHandlers.</p><p>Let's add the next override for <code class="literal">OnElementPropertyChanged</code> as follows:</p><pre class="programlisting">        protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) &#13;
        { &#13;
            base.OnElementPropertyChanged(sender, e); &#13;
 &#13;
            if (Element != null &amp;&amp; bodyshopCameraIOS != null) &#13;
            { &#13;
                if (e.PropertyName == VisualElement.HeightProperty.PropertyName || &#13;
                    e.PropertyName == VisualElement.WidthProperty.PropertyName) &#13;
                { &#13;
                    bodyshopCameraIOS.SetBounds((nint)Element.Width, (nint)Element.Height); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>This function will be called for every property change on the <code class="literal">CameraView</code>. We will call the <code class="literal">SetBounds</code> method on the <code class="literal">CameraiOS</code> object so that our <code class="literal">AVCapturePreviewVideoLayer</code> always retains the latest height and width update.</p><p>Now we must add the <code class="literal">EventHandler</code> functions as follows:</p><pre class="programlisting">        #region Private Methods &#13;
 &#13;
        private void HandleWidths (object sender, float e) &#13;
        { &#13;
            bodyshopCameraIOS.SetWidths (e); &#13;
        } &#13;
 &#13;
        private async void HandleShutter (object sender, EventArgs e) &#13;
        { &#13;
            await bodyshopCameraIOS.TakePhoto (); &#13;
        } &#13;
 &#13;
        private void HandleOrientationChange (object sender, Orientation e) &#13;
        { &#13;
            bodyshopCameraIOS.HandleOrientationChange (e); &#13;
        } &#13;
 &#13;
        private void HandleFocus (object sender, Point e) &#13;
        { &#13;
            bodyshopCameraIOS.ChangeFocusPoint (e); &#13;
        } &#13;
 &#13;
        private void HandleCameraInitialisation (object sender, bool args) &#13;
        { &#13;
            bodyshopCameraIOS.InitializeCamera(); &#13;
 &#13;
            Element.OrientationChange += HandleOrientationChange; &#13;
        } &#13;
 &#13;
        private void HandleFlash (object sender, bool args) &#13;
        { &#13;
            bodyshopCameraIOS.SwitchFlash (args); &#13;
        } &#13;
 &#13;
        private void HandleFocusChange (object sender, Point args) &#13;
        { &#13;
            bodyshopCameraIOS.ChangeFocusPoint (args); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>All these functions will respond to events fired from the <code class="literal">CameraView</code> and call their respect native functions to handle control on the native camera.</p><p>Now that we have implemented control over the iOS camera, let's do the same for Android.</p></div>
<div class="section" title="Integrating the Android Camera2 framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec135"/>Integrating the Android Camera2 framework</h1></div></div></div><p>The new <code class="literal">Camera2</code> framework was introduced in API 21 (5.0 Lollipop) and provides a wide featured framework for controlling camera devices connected to any Android device.</p><p>Start by setting up the folder structure <span class="strong"><strong>Renderers</strong></span> | <span class="strong"><strong>CameraView</strong></span> inside the <code class="literal">Camera.Droid</code> project. Inside the <code class="literal">CameraView</code> folder, add a file called <code class="literal">CameraCaptureListener.cs</code> and implement the following:</p><pre class="programlisting">public class CameraCaptureListener : CameraCaptureSession.CaptureCallback &#13;
    { &#13;
        public event EventHandler PhotoComplete; &#13;
 &#13;
        public override void OnCaptureCompleted(CameraCaptureSession session, CaptureRequest request,  &#13;
                    TotalCaptureResult result) &#13;
        { &#13;
            PhotoComplete?.Invoke(this, EventArgs.Empty); &#13;
        } &#13;
    } &#13;
</pre><p>All we need to do is fire an event every time the <code class="literal">OnCaptureCompleted</code> function is called. This function is called after all the image capture processing is completed.</p><p>Next, we have to create a callback for receiving updates about the state of a camera capture session. We will listen for both the <code class="literal">OnConfigured</code> and <code class="literal">OnConfigureFailed</code> and fire two different events so that we can handle any errors that may occur with the configuration of the capture session:</p><pre class="programlisting">public class CameraCaptureStateListener : CameraCaptureSession.StateCallback &#13;
    { &#13;
        public Action&lt;CameraCaptureSession&gt; OnConfigureFailedAction; &#13;
 &#13;
        public Action&lt;CameraCaptureSession&gt; OnConfiguredAction; &#13;
 &#13;
        public override void OnConfigureFailed(CameraCaptureSession session) &#13;
        { &#13;
            if (OnConfigureFailedAction != null) &#13;
            { &#13;
                OnConfigureFailedAction(session); &#13;
            } &#13;
        } &#13;
 &#13;
        public override void OnConfigured(CameraCaptureSession session) &#13;
        { &#13;
            if (OnConfiguredAction != null) &#13;
            { &#13;
                OnConfiguredAction(session); &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><p>Our next class is another callback for receiving updates about the state of the camera device. Here we will be firing events for camera availability so that we can pass down the availability state of the native camera to our <code class="literal">CameraView</code> view in the <code class="literal">Xamarin.Forms</code> project:</p><pre class="programlisting">public class CameraStateListener : CameraDevice.StateCallback &#13;
    { &#13;
        public CameraDroid Camera; &#13;
 &#13;
        public override void OnOpened(CameraDevice camera) &#13;
        { &#13;
            if (Camera != null) &#13;
            { &#13;
                Camera.cameraDevice = camera; &#13;
                Camera.StartPreview(); &#13;
                Camera.OpeningCamera = false; &#13;
 &#13;
                Camera?.NotifyAvailable(true); &#13;
            } &#13;
        } &#13;
 &#13;
        public override void OnDisconnected(CameraDevice camera) &#13;
        { &#13;
            if (Camera != null) &#13;
            { &#13;
                camera.Close(); &#13;
                Camera.cameraDevice = null; &#13;
                Camera.OpeningCamera = false; &#13;
 &#13;
                Camera?.NotifyAvailable(false); &#13;
            } &#13;
        } &#13;
 &#13;
        public override void OnError(CameraDevice camera, CameraError error) &#13;
        { &#13;
            camera.Close(); &#13;
 &#13;
            if (Camera != null) &#13;
            { &#13;
                Camera.cameraDevice = null; &#13;
                Camera.OpeningCamera = false; &#13;
 &#13;
                Camera?.NotifyAvailable(false); &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note121"/>Note</h3><p>All the new <code class="literal">Camera2</code> callback objects provide excellent control with error handling.</p></div></div><p>The <code class="literal">CameraDroid</code> class will be rendered on top of the <code class="literal">CustomRenderer</code>, which is equivalent to the <code class="literal">CameraiOS</code> object. We want to pass an instance of the<code class="literal"> CameraDroid</code> class to the <code class="literal">CameraStateListener</code>, when the state of the camera changes, we update the availability status on the <code class="literal">CameraDroid</code> instance.</p><p>Next, we must add another callback instance for handling image availability. This is where the raw image bytes will come from. Add a new file called <code class="literal">ImageAvailableListener.cs</code> and implement the following:</p><pre class="programlisting">public class ImageAvailableListener : Java.Lang.Object, ImageReader.IOnImageAvailableListener &#13;
    { &#13;
        public event EventHandler&lt;byte[]&gt; Photo; &#13;
 &#13;
        public void OnImageAvailable(ImageReader reader) &#13;
        { &#13;
            Image image = null; &#13;
 &#13;
            try &#13;
            { &#13;
                image = reader.AcquireLatestImage(); &#13;
                ByteBuffer buffer = image.GetPlanes()[0].Buffer; &#13;
                byte[] imageData = new byte[buffer.Capacity()]; &#13;
                buffer.Get(imageData); &#13;
 &#13;
                Photo?.Invoke(this, imageData); &#13;
            } &#13;
            catch (Exception ex) &#13;
            { &#13;
            } &#13;
            finally &#13;
            { &#13;
                if (image != null) &#13;
                { &#13;
                    image.Close(); &#13;
                } &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><p>When the <code class="literal">OnImageAvailable</code> function is called, this means we have the raw image available. We call <code class="literal">AcquireLatestImage</code> on the <code class="literal">ImageReader</code> object to acquire the last image taken, pull the raw bytes into a <code class="literal">ByteBuffer</code>, and convert the <code class="literal">ByteBuffer</code> into an array of bytes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note122"/>Note</h3><p>A <code class="literal">ByteBuffer</code> comes from the <code class="literal">Java.Lang</code> framework, which we use when we want to implement fast low-level I/O.</p></div></div><p>Now it's time to implement the <code class="literal">CameraDroid</code> class. Add in a new file called <code class="literal">CameraDroid.cs</code> and implement the following:</p><pre class="programlisting">public class CameraDroid : FrameLayout, TextureView.ISurfaceTextureListener &#13;
    { &#13;
        #region Static Properties &#13;
 &#13;
        private static readonly SparseIntArray ORIENTATIONS = new SparseIntArray(); &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Events &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Busy; &#13;
 &#13;
        public event EventHandler&lt;bool&gt; Available; &#13;
 &#13;
        public event EventHandler&lt;byte[]&gt; Photo; &#13;
 &#13;
        #endregion &#13;
 &#13;
} &#13;
</pre><p>The <code class="literal">CameraDroid</code> class inherits <code class="literal">FrameLayout</code> and <code class="literal">TextureView.ISurfaceTextureListener</code>. The static <code class="literal">ORIENTATIONS</code> property is a <code class="literal">SpareIntArray</code>, which works similar to a <code class="literal">HashMap</code>, but it can only map integers to integers. This will be used when a picture is taken. We must rotate images based upon screen orientation for the picture orientation to appear correctly.</p><p>We also have three event handlers like our <code class="literal">CameraiOS</code> these, are used to track whether the camera has taken a photo, is busy or is available.</p><p>Next, we have the following <code class="literal">private</code> properties:</p><pre class="programlisting">#region Private Properties &#13;
 &#13;
        private readonly string _tag; &#13;
 &#13;
        private readonly ILogger _log; &#13;
 &#13;
        private CameraStateListener mStateListener; &#13;
 &#13;
        private CaptureRequest.Builder _previewBuilder; &#13;
 &#13;
        private CameraCaptureSession _previewSession; &#13;
 &#13;
        private SurfaceTexture _viewSurface; &#13;
 &#13;
        private TextureView _cameraTexture; &#13;
 &#13;
        private MediaActionSound mediaSound; &#13;
 &#13;
        private Android.Util.Size _previewSize; &#13;
 &#13;
        private Context _context; &#13;
 &#13;
        private CameraManager _manager; &#13;
 &#13;
        private bool _mediaSoundLoaded; &#13;
 &#13;
        private bool _openingCamera; &#13;
 &#13;
        #endregion &#13;
</pre><p>The <code class="literal">_tag</code> and <code class="literal">_log</code> properties are used for logging like our other classes. We are also going to include an instance of all our callbacks.</p><p>Then we have the <code class="literal">public</code> properties. Every time the <code class="literal">OpeningCamera</code> property is assigned, it will fire a <code class="literal">Busy</code> event. Now we can track the busy state of the camera inside the <code class="literal">CameraPage</code> containing the <code class="literal">CameraView</code>. We also have an instance of the <code class="literal">CameraDevice</code>, which represents the actual device:</p><pre class="programlisting">        #region Public Properties &#13;
 &#13;
        public bool OpeningCamera &#13;
        { &#13;
            get &#13;
            { &#13;
                return _openingCamera; &#13;
            } &#13;
            set &#13;
            { &#13;
                if (_openingCamera != value) &#13;
                { &#13;
                    _openingCamera = value; &#13;
                    Busy?.Invoke(this, value); &#13;
                } &#13;
            } &#13;
        } &#13;
 &#13;
        public CameraDevice cameraDevice; &#13;
 &#13;
        #endregion &#13;
</pre><p>Next, we have the constructor. We must first pass in the context, since we will be using this locally through the class. Then the <code class="literal">LoadShutterSound</code> function is called, which will return a Boolean once the sound has been loaded. We then assign <code class="literal">_log</code> from the <code class="literal">IoC</code> container and set <code class="literal">_tag</code> using the C# 6 method <code class="literal">GetType</code>. Using the <code class="literal">LayoutInflator</code>, we create a new <code class="literal">CameraLayout</code> and set the local <code class="literal">_cameraTexture</code> object. The <code class="literal">SurfaceTextureListener</code> property of the <code class="literal">_cameraTexture</code> must be set to the <code class="literal">CameraDroid</code> instance itself. This is why the <code class="literal">CameraDroid</code> class implements the <code class="literal">TextureView.ISurfaceTextureListener</code> framework. We then instantiate a new <code class="literal">CameraStateListener</code> and set the <code class="literal">Camera</code> property to the <code class="literal">CameraDroid</code> instance using the <code class="literal">this</code> keyword, and, add the orientation to rotation mappings:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public CameraDroid (Context context) : base (context) &#13;
        { &#13;
            _context = context; &#13;
            _mediaSoundLoaded = LoadShutterSound (); &#13;
 &#13;
            _log = IoC.Resolve&lt;ILogger&gt;(); &#13;
            _tag = $"{GetType()} "; &#13;
 &#13;
            var inflater = LayoutInflater.FromContext (context); &#13;
 &#13;
            if (inflater != null) &#13;
            { &#13;
                var view = inflater.Inflate(Resource.Layout.CameraLayout, this); &#13;
 &#13;
                _cameraTexture = view.FindViewById&lt;TextureView&gt;(Resource.Id.CameraTexture); &#13;
                _cameraTexture.SurfaceTextureListener = this; &#13;
 &#13;
                mStateListener = new CameraStateListener() { Camera = this }; &#13;
 &#13;
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation0, 90); &#13;
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation90, 0); &#13;
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation180, 270); &#13;
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation270, 180); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now let's move on to the <code class="literal">private</code> methods. We are going to start with <code class="literal">UpdatePreview</code>. This is responsible for starting the video stream through the surface texture. If we have both a session and camera object in play, we use the <code class="literal">CameraRequest.Builder</code> instance to set the capture request mode to auto. The <code class="literal">Handler</code> object that is created is required to run the <code class="literal">CameraPreview</code> on the main UI thread:</p><pre class="programlisting">        #region Private Methods &#13;
 &#13;
        private void UpdatePreview() &#13;
        { &#13;
            if (cameraDevice != null &amp;&amp; _previewSession != null) &#13;
            { &#13;
                try &#13;
                { &#13;
                    // The camera preview can be run in a background thread. This is a Handler for the camere preview &#13;
                    _previewBuilder.Set(CaptureRequest.ControlMode, new Java.Lang.Integer((int)ControlMode.Auto)); &#13;
                    HandlerThread thread = new HandlerThread("CameraPreview"); &#13;
                    thread.Start(); &#13;
                    Handler backgroundHandler = new Handler(thread.Looper); &#13;
 &#13;
                    // Finally, we start displaying the camera preview &#13;
                    _previewSession.SetRepeatingRequest(_previewBuilder.Build(), null, backgroundHandler); &#13;
                } &#13;
                catch (CameraAccessException error) &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "UpdatePreview() Camera access exception.  \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace); &#13;
                } &#13;
                catch (IllegalStateException error) &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "UpdatePreview() Illegal exception.  \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>Our next function is responsible for loading the click sound. The <code class="literal">LoadShutterSound </code>method is used above in the constructor. When it returns <code class="literal">true</code>, this means we have successfully loaded the <code class="literal">MediaActionSoundType.ShutterClick</code>, so every time a user takes a photo, the shutter sound will play:</p><pre class="programlisting">        private bool LoadShutterSound() &#13;
        { &#13;
            try  &#13;
            { &#13;
                mediaSound = new MediaActionSound (); &#13;
                mediaSound.LoadAsync (MediaActionSoundType.ShutterClick); &#13;
 &#13;
                return true; &#13;
            } &#13;
            catch (Java.Lang.Exception error)  &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "LoadShutterSound() Error loading shutter sound  \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
 &#13;
            return false; &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now we move on to the <code class="literal">public</code> methods. Our first function <code class="literal">OpenCamera</code> will be called when the <code class="literal">CameraPage</code> appears:</p><pre class="programlisting">        #region Public Methods &#13;
 &#13;
        public void OpenCamera() &#13;
        { &#13;
            if (_context== null || OpeningCamera) &#13;
            { &#13;
                return; &#13;
            } &#13;
 &#13;
            OpeningCamera = true; &#13;
 &#13;
            _manager = (CameraManager)_context.GetSystemService(Context.CameraService); &#13;
 &#13;
            try &#13;
            { &#13;
                string cameraId = _manager.GetCameraIdList()[0]; &#13;
 &#13;
                // To get a list of available sizes of camera preview, we retrieve an instance of &#13;
                // StreamConfigurationMap from CameraCharacteristics &#13;
                CameraCharacteristics characteristics = _manager.GetCameraCharacteristics(cameraId); &#13;
                StreamConfigurationMap map = (StreamConfigurationMap)characteristics.Get(CameraCharacteristics.ScalerStreamConfigurationMap); &#13;
                _previewSize = map.GetOutputSizes(Java.Lang.Class.FromType(typeof(SurfaceTexture)))[0]; &#13;
                Android.Content.Res.Orientation orientation = Resources.Configuration.Orientation; &#13;
                if (orientation == Android.Content.Res.Orientation.Landscape) &#13;
                { &#13;
                    _cameraTexture.SetAspectRatio(_previewSize.Width, _previewSize.Height); &#13;
                } &#13;
                else &#13;
                { &#13;
                    _cameraTexture.SetAspectRatio(_previewSize.Height, _previewSize.Width); &#13;
                } &#13;
 &#13;
                // We are opening the camera with a listener. When it is ready, OnOpened of mStateListener is called. &#13;
                _manager.OpenCamera(cameraId, mStateListener, null); &#13;
            } &#13;
            catch (Java.Lang.Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "OpenCamera() Failed to open camera  \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
                 &#13;
                Available?.Invoke(this, false); &#13;
            } &#13;
        } &#13;
</pre><p>Before opening the camera, we first check if the <code class="literal">_context</code> is null and that we are not already opening the camera. We then flag <code class="literal">OpeningCamera</code> to true and retrieve the camera device from the context using the <code class="literal">GetSystemService</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note123"/>Note</h3><p>The <code class="literal">GetSystemService</code> method can be used to retrieve all hardware services.</p></div></div><p>Now that we have our <code class="literal">CameraManager</code> object, we call the <code class="literal">GetCameraIdList</code> method and retrieve the first camera ID from the list. We use this camera ID to retrieve the camera's characteristics that will be used for retrieving camera output sizes. We first use the camera output size to set the aspect ratio of the <code class="literal">_cameraTexture</code> and then we call <code class="literal">OpenCamera</code>, where we pass in the <code class="literal">cameraId</code> and<code class="literal"> CameraStateListener</code>.</p><p>Now we have to add a function for taking photos. We start by checking if the <code class="literal">_context</code> and <code class="literal">cameraDevice</code> is not null. We then invoke a <code class="literal">Busy</code> event to communicate to our <code class="literal">CameraView</code> and check if the shutter click sound has been loaded, then play if it has loaded successfully.. Then we use the camera's characteristics to retrieve JPEG output sizes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip124"/>Tip</h3><p>On every Android device, a camera will have supported output sizes for video streams and picture sizes. When we assign height, width, and ratio properties of camera display, they must be mapped to supported sizes.</p></div></div><p>We then set the first output size to the function's <code class="literal">width</code> and <code class="literal">height</code> properties. If the characteristics fail to show any JPEG output sizes, we start with the default width and height (640, 480).</p><p>Next, we use an <code class="literal">ImageReader</code> to retrieve and image from the <code class="literal">_cameraDevice</code>. We start with creating a new instance of an <code class="literal">ImageReader</code> and pass in our required width and height properties. An <code class="literal">ImageRenderer</code> also requires a surface, which is mapped to the output of a camera. When we take a picture, the <code class="literal">ImageReader</code> knows it will be reading from the output of the camera. We create a new <code class="literal">CaptureRequest.Builder</code>, which is created from the <code class="literal">CreateCaptureRequest</code> method of the <code class="literal">_cameraDevice</code>. Then we set the surface target to the surface we created earlier. Now the builder knows we are mapped to the output of the camera. We also set the capture request to auto, so most of the setup is taken care of. We then get the current orientation of the window from the <code class="literal">WindowManager</code> property (this is another service pulled from the <code class="literal">_context</code> using the <code class="literal">GetSystemService</code> method), and using the current orientation, set the rotation of the image accordingly.</p><p>Why do we have to change the orientation of the image? If we take an image on the current orientation, why is the image in a different orientation?</p><p>This is something we cannot control; the current orientation of the camera display does not map exactly how the image is interpreted when we take a picture, so we have to apply some minor rotation to bring the image into the same orientation as the camera surface.</p><p>This is a lot of work for the camera to do to prepare for capturing an image,</p><p>It takes a lot of work to prepare a capture session</p><p>how do we know when an image is actually taken?</p><p>All the work we have done so far is all for preparing the camera to take an image. We use our <code class="literal">ImageAvailableListener</code> for letting us know when the image is ready. Since we set up an event to hand us the image bytes, we can assign a delegate that will fire the <code class="literal">CameraDroid</code> so that the image bytes are passed back to the <code class="literal">CameraView</code> object.</p><p>Notice the use of the Handler?</p><p>The handler is used to handle the resulting JPEG in a background thread.</p><p>We then create an instance of our <code class="literal">CameraCaptureListener</code> to let us know capture operations have completed and assign a delegate function to restart the camera stream when the <code class="literal">PhotoComplete</code> event has been invoked. A new <code class="literal">CameraCaptureStateListener</code> object is passed into the <code class="literal">CreateCaptureSession</code> method to start the capture session and we assign a delegate to the <code class="literal">OnConfiguredAction</code> that will store the current <code class="literal">CameraCaptureSession</code>. We call the <code class="literal">Capture</code> method on the session and then call the <code class="literal">Build</code> method on the <code class="literal">captureBuilder</code> we created earlier. This occurs every time the <code class="literal">Capture</code> method is called.</p><p>The <code class="literal">captureListener</code> object and the handler are passed into the <code class="literal">Capture</code> method so that all capture processing is done on a background thread.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note125"/>Note</h3><p>This means that when a picture is taken, the processing time in between preparing a photo will not lock the UI thread.</p></div></div><pre class="programlisting">        public void TakePhoto () &#13;
        { &#13;
            if (_context != null &amp;&amp; _cameraDevice != null) &#13;
            { &#13;
                try &#13;
                { &#13;
                    Busy?.Invoke(this, true); &#13;
 &#13;
                    if (_mediaSoundLoaded) &#13;
                    { &#13;
                        _mediaSound.Play(MediaActionSoundType.ShutterClick); &#13;
                    } &#13;
 &#13;
                    // Pick the best JPEG size that can be captures with this CameraDevice &#13;
                    var characteristics = _manager.GetCameraCharacteristics(_cameraDevice.Id); &#13;
                    Android.Util.Size[] jpegSizes = null; &#13;
                    if (characteristics != null) &#13;
                    { &#13;
                        jpegSizes = ((StreamConfigurationMap)characteristics.Get(CameraCharacteristics.ScalerStreamConfigurationMap)).GetOutputSizes((int)ImageFormatType.Jpeg); &#13;
                    } &#13;
                    int width = 640; &#13;
                    int height = 480; &#13;
 &#13;
                    if (jpegSizes != null &amp;&amp; jpegSizes.Length &gt; 0) &#13;
                    { &#13;
                        width = jpegSizes[0].Width; &#13;
                        height = jpegSizes[0].Height; &#13;
                    } &#13;
 &#13;
                    // We use an ImageReader to get a JPEG from CameraDevice &#13;
                    // Here, we create a new ImageReader and prepare its Surface as an output from the camera &#13;
                    var reader = ImageReader.NewInstance(width, height, ImageFormatType.Jpeg, 1); &#13;
                    var outputSurfaces = new List&lt;Surface&gt;(2); &#13;
                    outputSurfaces.Add(reader.Surface); &#13;
                    outputSurfaces.Add(new Surface(_viewSurface)); &#13;
 &#13;
                    CaptureRequest.Builder captureBuilder = _cameraDevice.CreateCaptureRequest(CameraTemplate.StillCapture); &#13;
                    captureBuilder.AddTarget(reader.Surface); &#13;
                    captureBuilder.Set(CaptureRequest.ControlMode, new Integer((int)ControlMode.Auto)); &#13;
 &#13;
                    // Orientation &#13;
                    var windowManager = _context.GetSystemService(Context.WindowService).JavaCast&lt;IWindowManager&gt;(); &#13;
                    SurfaceOrientation rotation = windowManager.DefaultDisplay.Rotation; &#13;
 &#13;
                    captureBuilder.Set(CaptureRequest.JpegOrientation, new Integer(ORIENTATIONS.Get((int)rotation))); &#13;
 &#13;
                    // This listener is called when an image is ready in ImageReader  &#13;
                    ImageAvailableListener readerListener = new ImageAvailableListener(); &#13;
 &#13;
                    readerListener.Photo += (sender, e) =&gt; &#13;
                    { &#13;
                        Photo?.Invoke(this, e); &#13;
                    }; &#13;
 &#13;
                    // We create a Handler since we want to handle the resulting JPEG in a background thread &#13;
                    HandlerThread thread = new HandlerThread("CameraPicture"); &#13;
                    thread.Start(); &#13;
                    Handler backgroundHandler = new Handler(thread.Looper); &#13;
                    reader.SetOnImageAvailableListener(readerListener, backgroundHandler); &#13;
 &#13;
                    var captureListener = new CameraCaptureListener(); &#13;
 &#13;
                    captureListener.PhotoComplete += (sender, e) =&gt; &#13;
                    { &#13;
                        Busy?.Invoke(this, false); &#13;
                        StartPreview(); &#13;
                    }; &#13;
 &#13;
                    _cameraDevice.CreateCaptureSession(outputSurfaces, new CameraCaptureStateListener() &#13;
                    { &#13;
                        OnConfiguredAction = (CameraCaptureSession session) =&gt; &#13;
                        { &#13;
                            try &#13;
                            { &#13;
                                _previewSession = session; &#13;
                                session.Capture(captureBuilder.Build(), captureListener, backgroundHandler); &#13;
                            } &#13;
                            catch (CameraAccessException ex) &#13;
                            { &#13;
                                Log.WriteLine(LogPriority.Info, "Capture Session error: ", ex.ToString()); &#13;
                            } &#13;
                        } &#13;
                    }, backgroundHandler); &#13;
                } &#13;
                catch (CameraAccessException error) &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "TakePhoto() Failed to take photo  \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace);                     &#13;
                } &#13;
                catch (Java.Lang.Exception error) &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "TakePhoto() Failed to take photo  \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>It takes a lot of work to prepare a capture session on an Android camera using the <code class="literal">Camera2</code> framework, but the advantage is we have is the ability to control every single step separately, and handle any exceptions that occur at any point during the capture operation.</p><p>Our next function will be responsible for changing the focus point of the camera, when a touch on the <code class="literal">CameraView</code> occurs, this function will be called to change the focus point of the native camera:</p><pre class="programlisting">        public void ChangeFocusPoint(Xamarin.Forms.Point e) &#13;
        { &#13;
            string cameraId = _manager.GetCameraIdList()[0]; &#13;
 &#13;
            // To get a list of available sizes of camera preview, we retrieve an instance of &#13;
            // StreamConfigurationMap from CameraCharacteristics &#13;
            CameraCharacteristics characteristics = _manager.GetCameraCharacteristics(cameraId); &#13;
 &#13;
            var rect = characteristics.Get(CameraCharacteristics.SensorInfoActiveArraySize) as Rect; &#13;
            var size = characteristics.Get(CameraCharacteristics.SensorInfoPixelArraySize) as Size; &#13;
 &#13;
            int areaSize = 200; &#13;
            int right = rect.Right; &#13;
            int bottom = rect.Bottom; &#13;
            int viewWidth = _cameraTexture.Width; &#13;
            int viewHeight = _cameraTexture.Height; &#13;
            int ll, rr; &#13;
 &#13;
            Rect newRect; &#13;
            int centerX = (int)e.X; &#13;
            int centerY = (int)e.Y; &#13;
 &#13;
            ll = ((centerX * right) - areaSize) / viewWidth; &#13;
            rr = ((centerY * bottom) - areaSize) / viewHeight; &#13;
 &#13;
            int focusLeft = Clamp(ll, 0, right); &#13;
            int focusBottom = Clamp(rr, 0, bottom); &#13;
 &#13;
            newRect = new Rect(focusLeft, focusBottom, focusLeft + areaSize, focusBottom + areaSize); &#13;
            MeteringRectangle meteringRectangle = new MeteringRectangle(newRect, 500); &#13;
            MeteringRectangle[] meteringRectangleArr = { meteringRectangle }; &#13;
            _previewBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Cancel); &#13;
            _previewBuilder.Set(CaptureRequest.ControlAeRegions, meteringRectangleArr); &#13;
            _previewBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Start); &#13;
 &#13;
            UpdatePreview(); &#13;
        } &#13;
</pre><p>The <code class="literal">ChangeFocusPoint</code> function starts with retrieving the <code class="literal">cameraId</code> from the <code class="literal">CameraManager</code>. We then call the <code class="literal">Get</code> method of the camera characteristics to retrieve a rectangle and size of the active region of the camera sensor (that is, the region that actually receives light from the scene). We then retrieve the right and bottom bounds of this region and get the width and height of the <code class="literal">_cameraTexture</code>. When a user touches to focus, the point coordinate (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) passed into this function is used as the center of the focus region. As we have the middle point, we calculate the left and bottom points and we also use the <code class="literal">Clamp</code> function to make sure these points are within the width and height bounds of the <code class="literal">_cameraTexture</code>. We then create a new <code class="literal">Rect</code> representing the new active region for the camera sensor. Then, to perform the actual focus on the camera device, we must first disable the autofocus by calling the line:</p><pre class="programlisting">_previewBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Cancel); &#13;
</pre><p>Then assign the camera sensor's active region by calling:</p><pre class="programlisting">_previewBuilder.Set(CaptureRequest.ControlAeRegions, meteringRectangleArr); &#13;
</pre><p>And finally, reset the autofocus by calling:</p><pre class="programlisting">_previewBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Start); &#13;
</pre><p>The operation works by disabling the autofocus, setting the active region, and then recalling autofocus. When the autofocus is started again, we have a new focus point in which the camera will adjust its focus point too.</p><p>We also call the <code class="literal">UpdatePreview</code> function for resetting the camera control to auto.</p><p>Next, we have the <code class="literal">Clamp</code> function, which is responsible for forcing the value passed in to be between a range. We use the following function:</p><pre class="programlisting">        private int Clamp(int value, int min, int max) &#13;
        { &#13;
            return (value &lt; min) ? min : (value &gt; max) ? max : value; &#13;
        } &#13;
</pre><p>Now for the <code class="literal">StartPreview</code> function, this will be responsible for starting the camera stream through the <code class="literal">TextureView</code>. We won't call this unit the camera has been opened previously:</p><pre class="programlisting">        public void StartPreview() &#13;
        { &#13;
            if (cameraDevice != null &amp;&amp; _cameraTexture.IsAvailable &amp;&amp; _previewSize != null) &#13;
            { &#13;
                try &#13;
                { &#13;
                    var texture = _cameraTexture.SurfaceTexture; &#13;
 &#13;
                    texture.SetDefaultBufferSize(_previewSize.Width, _previewSize.Height); &#13;
                    Surface surface = new Surface(texture); &#13;
 &#13;
                                        _previewBuilder = cameraDevice.CreateCaptureRequest(CameraTemplate.Preview); &#13;
                    _previewBuilder.AddTarget(surface); &#13;
 &#13;
                    // Here, we create a CameraCaptureSession for camera preview. &#13;
                    cameraDevice.CreateCaptureSession(new List&lt;Surface&gt;() { surface }, &#13;
                        new CameraCaptureStateListener() &#13;
                        { &#13;
                            OnConfigureFailedAction = (CameraCaptureSession session) =&gt; &#13;
                            { &#13;
                            }, &#13;
                            OnConfiguredAction = (CameraCaptureSession session) =&gt; &#13;
                            { &#13;
                                _previewSession = session; &#13;
                                UpdatePreview(); &#13;
                            } &#13;
                        }, &#13;
                        null); &#13;
 &#13;
                } &#13;
                catch (Java.Lang.Exception error) &#13;
                { &#13;
                    _log.WriteLineTime(_tag + "\n" + &#13;
                        "TakePhoto() Failed to start preview \n " + &#13;
                        "ErrorMessage: \n" + &#13;
                        error.Message + "\n" + &#13;
                        "Stacktrace: \n " + &#13;
                        error.StackTrace);     &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>The function starts with configuring the size of the default buffer to be the size of the camera preview. Then we want to create a new <code class="literal">Surface</code> object for the output surface of the camera, which is then assigned to a new <code class="literal">CaptureRequest.Builder</code>.</p><p>Don't forget we have another function to control the flash of the camera. We simply adjust the flash mode through <code class="literal">CaptureRequest.Builder</code> object and, based upon the <code class="literal">flashOn bool</code> passed in, we assign either <code class="literal">FlashMode.Torch</code> or <code class="literal">FlashMode.Off</code>:</p><pre class="programlisting">        public void SwitchFlash(bool flashOn) &#13;
        { &#13;
            try &#13;
            { &#13;
                _previewBuilder.Set(CaptureRequest.FlashMode, new Integer(flashOn ? (int)FlashMode.Torch : (int)FlashMode.Off)); &#13;
                UpdatePreview(); &#13;
            } &#13;
            catch (System.Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "TakePhoto() Failed to switch flash on/off \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
                 &#13;
            } &#13;
        } &#13;
</pre><p>Next we have a public function to invoke the <code class="literal">Available</code> event, which we need for the <code class="literal">CmaptureStateListener</code> callback so that we keep track of the camera availability during a capture session:</p><pre class="programlisting">        public void NotifyAvailable(bool isAvailable) &#13;
        { &#13;
            Available?.Invoke(this, isAvailable); &#13;
        } &#13;
</pre><p>Next we have the <code class="literal">ConfigureTransform</code> function, which is responsible for transforming the texture view. Here we are handling surface orientations and matrix rotations:</p><pre class="programlisting">        public void ConfigureTransform(int viewWidth, int viewHeight) &#13;
        { &#13;
            if (_viewSurface != null &amp;&amp; _previewSize != null &amp;&amp; _context != null) &#13;
            { &#13;
                var windowManager = _context.GetSystemService(Context.WindowService).JavaCast&lt;IWindowManager&gt;(); &#13;
 &#13;
                var rotation = windowManager.DefaultDisplay.Rotation; &#13;
                var matrix = new Matrix(); &#13;
                var viewRect = new RectF(0, 0, viewWidth, viewHeight); &#13;
                var bufferRect = new RectF(0, 0, _previewSize.Width, _previewSize.Height); &#13;
 &#13;
                var centerX = viewRect.CenterX(); &#13;
                var centerY = viewRect.CenterY(); &#13;
 &#13;
                if (rotation == SurfaceOrientation.Rotation90 || rotation == SurfaceOrientation.Rotation270) &#13;
                { &#13;
                    bufferRect.Offset(centerX - bufferRect.CenterX() , centerY - bufferRect.CenterY()); &#13;
                    matrix.SetRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.Fill); &#13;
 &#13;
                    matrix.PostRotate(90 * ((int)rotation - 2), centerX, centerY); &#13;
                } &#13;
 &#13;
                _cameraTexture.SetTransform(matrix); &#13;
            } &#13;
        } &#13;
</pre><p>Then we have the functions that are required by every <code class="literal">TextureView</code>:</p><pre class="programlisting">        public void OnSurfaceTextureAvailable (SurfaceTexture surface, int w, int h) &#13;
        { &#13;
            _viewSurface = surface; &#13;
 &#13;
            ConfigureTransform(w, h); &#13;
            StartPreview(); &#13;
        } &#13;
</pre><p>The <code class="literal">OnSurfaceTextureAvailable</code> function will call configure the texture's transformation matrix based upon the current window's orientation and call <code class="literal">StartPreview</code> to start the video stream through the texture view:</p><pre class="programlisting">        public bool OnSurfaceTextureDestroyed (SurfaceTexture surface) &#13;
        { &#13;
            return true; &#13;
        } &#13;
 &#13;
        public void OnSurfaceTextureSizeChanged (SurfaceTexture surface, int width, int height) &#13;
        { &#13;
            ConfigureTransform(width, height); &#13;
            StartPreview(); &#13;
        } &#13;
</pre><p>We also want to configure the texture's transformation matrix when the surface size changes:</p><pre class="programlisting">        public void OnSurfaceTextureUpdated (SurfaceTexture surface) &#13;
        { &#13;
        } &#13;
</pre><p>Wow! That was one huge implementation. Configuring the camera is not an easy task; it involves a lot of step-by-step procedures that must be taken correctly for starting the camera stream and creating a capture session. Those are the two most important operations of any camera implementation.</p></div>
<div class="section" title="Building the CameraViewRenderer in Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec136"/>Building the CameraViewRenderer in Android</h1></div></div></div><p>Now we must add the CustomRenderer for the Android camera. In the <code class="literal">Renderers</code> folder, add a new file called <code class="literal">CameraViewRender.cs</code> and implement the following:</p><pre class="programlisting">public class CameraViewRenderer : ViewRenderer&lt;CameraView, CameraDroid&gt; &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private CameraDroid Camera; &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><p>Our renderer contains only one private instance of the <code class="literal">CameraDroid</code> class. Then we override the <code class="literal">OnElementChanged</code> method:</p><pre class="programlisting">        #region Protected Methods &#13;
 &#13;
        protected override void OnElementChanged(ElementChangedEventArgs&lt;CameraView&gt; e) &#13;
        { &#13;
            base.OnElementChanged(e); &#13;
 &#13;
            if (Control == null) &#13;
            { &#13;
                Camera = new CameraDroid(Context); &#13;
 &#13;
                SetNativeControl(Camera); &#13;
            } &#13;
 &#13;
            if (e.NewElement != null) &#13;
            { &#13;
 &#13;
                Camera.Available += e.NewElement.NotifyAvailability; &#13;
                Camera.Photo += e.NewElement.NotifyPhoto; &#13;
                Camera.Busy += e.NewElement.NotifyBusy; &#13;
 &#13;
                e.NewElement.Flash += HandleFlashChange; &#13;
                e.NewElement.OpenCamera += HandleCameraInitialisation; &#13;
                e.NewElement.Focus += HandleFocus; &#13;
                e.NewElement.Shutter += HandleShutter; &#13;
            } &#13;
        } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip126"/>Tip</h3><p>Inside Android <code class="literal">CustomRenderers</code>, there is a bug with disposal using the <code class="literal">OnElementChanged</code> method. In some cases, this method is not called when the view is disposed, so we are going to override the <code class="literal">Dispose</code> method.</p></div></div><p>Here we follow the correct structure in the <code class="literal">OnElementChanged</code> method and instantiate the new control when the <code class="literal">Control</code> property is null. We also register our events when the new element is not null (events are registered on both the <code class="literal">CameraDroid</code> and <code class="literal">CameraView</code> objects).</p><p>Now let's add the override to handle the disposal:</p><pre class="programlisting">protected override void Dispose(bool disposing) &#13;
        { &#13;
            Element.Flash -= HandleFlashChange; &#13;
            Element.OpenCamera -= HandleCameraInitialisation; &#13;
            Element.Focus -= HandleFocus; &#13;
            Element.Shutter -= HandleShutter; &#13;
 &#13;
            Camera.Available -= Element.NotifyAvailability; &#13;
            Camera.Photo -= Element.NotifyPhoto; &#13;
            Camera.Busy -= Element.NotifyBusy; &#13;
 &#13;
            base.Dispose(disposing); &#13;
        } &#13;
</pre><p>Here we simply unregister the events for both the <code class="literal">CameraView</code> and <code class="literal">CameraDroid</code> objects. Next, we have the <code class="literal">private</code> event delegate methods for calling the native camera methods:</p><pre class="programlisting">        #region Private Methods &#13;
 &#13;
        private void HandleCameraInitialisation (object sender, bool args) &#13;
        { &#13;
            Camera.OpenCamera(); &#13;
        } &#13;
        private void HandleFlashChange (object sender, bool args) &#13;
        { &#13;
            Camera.SwitchFlash (args); &#13;
        } &#13;
 &#13;
        private void HandleShutter (object sender, EventArgs e) &#13;
        { &#13;
            Camera.TakePhoto(); &#13;
        } &#13;
 &#13;
        private void HandleFocus (object sender, Point e) &#13;
        { &#13;
            Camera.ChangeFocusPoint(e); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>Great! We have completed our camera implementations for both iOS and Android. Now we have to create another renderer for the <code class="literal">FocusView</code>.</p></div>
<div class="section" title="Handling native touch events through the FocusView"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec137"/>Handling native touch events through the FocusView</h1></div></div></div><p>Since our camera implementation is handling focus changes from touch events, we are required to receive these touch events from the native side. <code class="literal">Xamarin.Forms</code> does not have touch events that give (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates, so we have to do some more custom rendering on the <code class="literal">FocusView</code>. Let's start with the Android implementation this time, inside the <code class="literal">Renderers</code> folder, add a new folder called <code class="literal">FocusView</code>, and add a new file called <code class="literal">FocusViewGestureDetector.cs</code>, and implement the following:</p><pre class="programlisting">public class FocusViewGestureDetector : GestureDetector.SimpleOnGestureListener &#13;
    { &#13;
        #region Events &#13;
 &#13;
        public event EventHandler&lt;MotionEvent&gt; Touch; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Methods &#13;
 &#13;
        public override void OnLongPress(MotionEvent e) &#13;
        { &#13;
            base.OnLongPress(e); &#13;
        } &#13;
 &#13;
        public override bool OnDoubleTap(MotionEvent e) &#13;
        { &#13;
            return base.OnDoubleTap(e); &#13;
        } &#13;
 &#13;
        public override bool OnDoubleTapEvent(MotionEvent e) &#13;
        { &#13;
            return base.OnDoubleTapEvent(e); &#13;
        } &#13;
 &#13;
        public override bool OnSingleTapUp(MotionEvent e) &#13;
        { &#13;
            return base.OnSingleTapUp(e); &#13;
        } &#13;
 &#13;
        public override bool OnDown(MotionEvent e) &#13;
        { &#13;
            if (Touch != null) &#13;
            { &#13;
                Touch(this, e); &#13;
            } &#13;
 &#13;
            return base.OnDown(e); &#13;
        } &#13;
 &#13;
        public override bool OnFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#13;
        { &#13;
            return base.OnFling(e1, e2, velocityX, velocityY); &#13;
        } &#13;
 &#13;
        public override bool OnScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#13;
        { &#13;
            return base.OnScroll(e1, e2, distanceX, distanceY); &#13;
        } &#13;
 &#13;
        public override void OnShowPress(MotionEvent e) &#13;
        { &#13;
            base.OnShowPress(e); &#13;
        } &#13;
 &#13;
        public override bool OnSingleTapConfirmed(MotionEvent e) &#13;
        { &#13;
            return base.OnSingleTapConfirmed(e); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>The preceding class is very similar to the gesture detector we created for the <code class="literal">CarouselView</code> in the last chapter. We only use this object to retrieve the <code class="literal">MotionEvent</code> object from the <code class="literal">OnDown</code> method.</p><p>Let's add in another file called <code class="literal">FocusViewRender.c</code> and implement the following:</p><pre class="programlisting">public class FocusViewRenderer : ViewRenderer&lt;FocusView, LinearLayout&gt; &#13;
    { &#13;
        #region Private Methods &#13;
 &#13;
        private FocusViewGestureDetector _gestureDetector; &#13;
 &#13;
        private GestureDetector _detector; &#13;
 &#13;
        private LinearLayout _layout; &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><p>The <code class="literal">FocusViewRenderer</code> will contain an instance of our <code class="literal">FocusViewGestureDetector</code> and <code class="literal">GestureDetector</code> for handling touches on the <code class="literal">FocusView</code>. We also have a <code class="literal">LinearLayout</code>, which is going to be the control assigned to the <code class="literal">FocusView</code>. This <code class="literal">LinearLayout</code> will be blank and will only be used to receive the native touch events.</p><p>Then we add the override to the <code class="literal">OnElementChanged</code> function:</p><pre class="programlisting">        #region Protected Methods &#13;
 &#13;
        protected override void OnElementChanged(ElementChangedEventArgs&lt;FocusView&gt; e) &#13;
        { &#13;
            base.OnElementChanged(e); &#13;
 &#13;
            if (Control == null) &#13;
            { &#13;
                SetGestureDetectorListener(); &#13;
                _layout = new LinearLayout(Context); &#13;
 &#13;
                SetNativeControl (_layout); &#13;
            } &#13;
 &#13;
            if (e.NewElement != null) &#13;
            { &#13;
                _layout.Touch += HandleTouch; &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>When the <code class="literal">Control</code> is null, before we call the <code class="literal">SetNativeControl</code> method, we set up the gesture detectors.</p><p>Now we must handle disposal as follows:</p><pre class="programlisting">protected override void Dispose(bool disposing) &#13;
        { &#13;
            _layout.Touch -= HandleTouch; &#13;
 &#13;
            base.Dispose(disposing); &#13;
        }  &#13;
</pre><p>Then we add the remaining:</p><pre class="programlisting">        #region Private Methods &#13;
 &#13;
        private int ConvertPixelsToDp(float pixelValue) &#13;
        { &#13;
            return (int) ((pixelValue)/Resources.DisplayMetrics.Density); &#13;
        } &#13;
 &#13;
        private void SetGestureDetectorListener() &#13;
        { &#13;
            _gestureDetector = new FocusViewGestureDetector (); &#13;
            _detector = new GestureDetector (_gestureDetector); &#13;
 &#13;
             &#13;
            Observable.FromEventPattern&lt;MotionEvent&gt; (_gestureDetector, "Touch") &#13;
                .Window (() =&gt; Observable.Interval (TimeSpan.FromSeconds (0.7))) &#13;
                .SelectMany (x =&gt; x.Take (1)) &#13;
                .Subscribe (e =&gt; Element.NotifyFocus (new Point (ConvertPixelsToDp (e.EventArgs.GetX ()), ConvertPixelsToDp (e.EventArgs.GetY ())))); &#13;
        } &#13;
 &#13;
        private void HandleTouch (object sender, TouchEventArgs e) &#13;
        { &#13;
            _detector.OnTouchEvent (e.Event); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre></div>
<div class="section" title="Using RX to handle events"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec138"/>Using RX to handle events</h1></div></div></div><p>Have a look at the <code class="literal">SetGestureDetectorListener</code> function where we are using the <code class="literal">FromEventPattern</code> method from the <code class="literal">Observable</code> framework. The function must be typed with a particular object (that is, <code class="literal">MotionEvent</code>) that contains an <code class="literal">EventHandler</code> property, in this case <code class="literal">Touch</code>. Every time a <code class="literal">Touch</code> event is fired, using the <code class="literal">Window</code> method, we wait 0.7 seconds before doing anything (this ensures that we only respond to the first event taken every period set in the<code class="literal"> Window</code> method). Once this period is reached, <code class="literal">SelectMany</code> is called and the first <code class="literal">Touch</code> event is retrieved from the observable sequence via the <code class="literal">Take</code> method. Then we call <code class="literal">Subscribe</code> to assign the <code class="literal">NotifyFocus</code> method, and pass in the <code class="literal">MotionEvent</code> object taken from the <code class="literal">SelectMany</code> method.</p><p>To summarize, the <code class="literal">FromEventPattern</code> method is very useful for controlling multiple events and responding with specific actions. We have applied this technique with touch events because we want to make sure only one touch event is processed every 0.7 seconds. If we used a simply delegate function, a user could very fast, and for every touch event, the camera would run through the <code class="literal">ChangeFocusPoint</code> operation every time before the previous has finished, eventually crashing the application.</p><p>Now turn attention to the <code class="literal">ConvertPixelsToDp</code> method. We have to translate the pixel points into DPI when translating position coordinates (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) between native Android and <code class="literal">Xamarin.Forms</code> views. This will be called for every touch event for both x and y before we pass the coordinate to the <code class="literal">CameraView</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note127"/>Note</h3><p>1 DP equals 1.5 physical pixels.</p></div></div></div>
<div class="section" title="Building a VisualElementRenderer for iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec139"/>Building a VisualElementRenderer for iOS</h1></div></div></div><p>To handle native touch events on iOS, we are going to build a <code class="literal">VisualElementRenderer</code>. These work similar to CustomRenderers, but instead of rendering and replacing the entire control, we are able to render specific attributes, so we are able to attach native attributes to a <code class="literal">Xamarin.Forms</code> view.</p><p>Let's start with adding a new folder inside the <code class="literal">Renderers</code> folder called <code class="literal">FocusView</code>. Add in a new file called <code class="literal">FocusViewRendererTouchAttribute.cs</code> and implement the following:</p><pre class="programlisting">public class FocusViewRendererTouchAttribute : VisualElementRenderer&lt;FocusView&gt; &#13;
    { &#13;
        public override void TouchesBegan (NSSet touches, UIEvent evt) &#13;
        { &#13;
            base.TouchesBegan (touches, evt); &#13;
 &#13;
            FocusView focusView = ((FocusView)this.Element); &#13;
 &#13;
            UITouch touch = touches.AnyObject as UITouch; &#13;
 &#13;
            if (touch != null)  &#13;
            { &#13;
                var posc = touch.LocationInView (touch.View); &#13;
                focusView.NotifyFocus (new Xamarin.Forms.Point(posc.X, posc.Y)); &#13;
            } &#13;
        } &#13;
    } &#13;
</pre><p>Don't forget to add the assembly line above the namespace like the following:</p><pre class="programlisting">[assembly: Xamarin.Forms.ExportRendererAttribute (typeof(Camera.Controls.FocusView),  &#13;
                                                  typeof(Camera.iOS.Renderers.FocusView.FocusViewRendererTouchAttribute))] &#13;
</pre><p>When the element is rendered, we will now have the access to the <code class="literal">TouchesBegan</code> override. Inside this function, we have access to the render object (<code class="literal">FocusView</code>), where we can call the <code class="literal">NotifyFocus</code> function and pass the current touch (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate back to the <code class="literal">FocusView</code>.</p><p>That's all for our <code class="literal">FocusView</code> renderers. Let's now move on to the <code class="literal">CustomImageRenderer</code> so that we can apply color tinting to an image.</p></div>
<div class="section" title="Building the CustomImageRenderers"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec140"/>Building the CustomImageRenderers</h1></div></div></div><p>We are going to start with the iOS implementation of the <code class="literal">CustomImage</code>. Inside the <code class="literal">Renderers</code> folder, add a new folder called <code class="literal">CustomImage</code>, add a new file called <code class="literal">CustomImageRenderer.cs</code>, and implement the following:</p><pre class="programlisting">public class CustomImageRenderer : ViewRenderer&lt;CustomImage, UIView&gt; &#13;
    { &#13;
        #region Private Propertie &#13;
 &#13;
        private readonly string _tag; &#13;
 &#13;
        private ILogger _log; &#13;
 &#13;
        private UIImageView _imageView; &#13;
 &#13;
        private int _systemVersion = Convert.ToInt16 (UIDevice.CurrentDevice.SystemVersion.Split ('.') [0]); &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Constructors &#13;
 &#13;
        public CustomImageRenderer() &#13;
        { &#13;
            _log = IoC.Resolve&lt;ILogger&gt;(); &#13;
            _tag = string.Format("{0} ", GetType()); &#13;
        } &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><p>Looking at our <code class="literal">private</code> properties, we have the logging objects again, an integer property to hold the current system version (that is, iOS version), and an <code class="literal">UIImageView</code> to use as the native control. Next we have to override the <code class="literal">OnElementChanged</code> method:</p><pre class="programlisting">        protected override void OnElementChanged (ElementChangedEventArgs&lt;CustomImage&gt; e) &#13;
        { &#13;
            base.OnElementChanged (e); &#13;
 &#13;
            if (Control == null) &#13;
            { &#13;
                _imageView = new UIImageView(); &#13;
 &#13;
                SetNativeControl(_imageView); &#13;
            } &#13;
 &#13;
            if (e.OldElement != null) &#13;
            { &#13;
                e.OldElement.CustomPropertyChanged -= HandleCustomPropertyChanged; &#13;
            } &#13;
 &#13;
            if (e.NewElement != null) &#13;
            { &#13;
                LoadImage(); &#13;
 &#13;
                e.NewElement.CustomPropertyChanged += HandleCustomPropertyChanged; &#13;
            } &#13;
        } &#13;
</pre><p>Remember we have to follow the same structure for instantiating the control, and registering and deregistering EventHandlers. In this renderer, we are going to apply event handling a little differently. Instead of registering multiple events in the <code class="literal">OnElementChanged</code> method, we only have to register and deregister the <code class="literal">CustomPropertyChanged</code> event. In our <code class="literal">CustomImage</code> view, with each custom binding, when a property is changed, we assigned a delegate that would fire this event with the property name for every property. Therefore, we add one delegate function on the renderer side called <code class="literal">HandleCustomPropertyChanged</code>, and in this function, we will check what property has changed and respond with an action:</p><pre class="programlisting">        private void HandleCustomPropertyChanged (object sender, string propertyName) &#13;
        { &#13;
            switch (propertyName) &#13;
            { &#13;
                case "TintColorString": &#13;
                case "TintOn": &#13;
                    UpdateControlColor(); &#13;
                    break; &#13;
                case "Path": &#13;
                    InvokeOnMainThread(() =&gt; LoadImage()); &#13;
                    break; &#13;
            } &#13;
        } &#13;
</pre><p>Much cleaner than handling multiple events right?</p><p>Every time the <code class="literal">Path</code> property is changed, we call a new method called <code class="literal">LoadImage</code>. Before we add this function in, we are going to add a <code class="literal">private</code> method for setting the image aspect ratio:</p><pre class="programlisting">private UIViewContentMode SetAspect() &#13;
        { &#13;
            if (Element != null) &#13;
            { &#13;
                switch (Element.Aspect)  &#13;
                { &#13;
                    case Aspect.AspectFill: &#13;
                        return UIViewContentMode.ScaleAspectFill; &#13;
                    case Aspect.AspectFit: &#13;
                        return UIViewContentMode.ScaleAspectFit; &#13;
                    case Aspect.Fill: &#13;
                        return UIViewContentMode.ScaleToFill; &#13;
                    default: &#13;
                        return UIViewContentMode.ScaleAspectFit; &#13;
                } &#13;
            } &#13;
 &#13;
            return UIViewContentMode.ScaleAspectFit; &#13;
        } &#13;
</pre><p>This will take a <code class="literal">Xamarin.Forms</code> image aspect ratio value and return the related native image aspect ratio. This value will then be used for the aspect of the <code class="literal">UIImageView</code>.</p><p>Let's now add the <code class="literal">LoadImage</code> method as follows:</p><pre class="programlisting">        private void LoadImage() &#13;
        { &#13;
            try  &#13;
            { &#13;
                if (Element != null) &#13;
                { &#13;
                    if (!string.IsNullOrEmpty(Element.Path)) &#13;
                    { &#13;
                        _imageView.Image = ReadBitmapImageFromStorage (Element.Path); &#13;
 &#13;
                        if (_imageView.Image != null) &#13;
                        { &#13;
                            if (_systemVersion &gt;= 7 &amp;&amp; Element.TintOn) &#13;
                            { &#13;
                                _imageView.Image = _imageView.Image.ImageWithRenderingMode (UIImageRenderingMode.AlwaysTemplate); &#13;
                            } &#13;
 &#13;
                            UpdateControlColor(); &#13;
 &#13;
                            _imageView.ContentMode = SetAspect(); &#13;
                        } &#13;
                    } &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "LoadAsync() Failed to load view model.  \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
        } &#13;
</pre><p>This function is responsible for using the <code class="literal">Path</code> property to load an image into the <code class="literal">UIImageView</code>. Inside this function, we also use the <code class="literal">systemVersion</code> property to handle backward compatibility with color tinting. Only if the iOS device is using an iOS version greater than or equal to iOS 7, we apply the following line:</p><pre class="programlisting">_imageView.Image = _imageView.Image.ImageWithRenderingMode (UIImageRenderingMode.AlwaysTemplate); &#13;
</pre><p>This tells the <code class="literal">UIImageView</code> that its <code class="literal">Image</code> should always draw as a template image, ignoring its color information. We have to do this before we can apply a tinted color.</p><p>Next we have to add the <code class="literal">ReadBitmapImageFromStorage</code> function:</p><pre class="programlisting">private UIImage ReadBitmapImageFromStorage(string fn) &#13;
        { &#13;
            var docsPath = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments); &#13;
            string filePath = Path.Combine(Environment.CurrentDirectory, fn); &#13;
 &#13;
            try  &#13;
            { &#13;
                using (Stream stream = File.OpenRead(filePath)) &#13;
                { &#13;
                    NSData data = NSData.FromStream (stream); &#13;
                    return UIImage.LoadFromData (data); &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "LoadAsync() Failed to load view model.  \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
 &#13;
            return UIImage.FromFile (Path.Combine (Environment.CurrentDirectory, "loading.png")); &#13;
        } &#13;
</pre><p>Using the <code class="literal">File.OpenRead</code> method, we retrieve the files stream and load it into a new <code class="literal">NSData</code> object, and then from this <code class="literal">NSData</code> we load this into a new <code class="literal">UIImage</code> and return it to the caller (that is, the <code class="literal">LoadImage</code> function).</p><p>We must also add the <code class="literal">UpdateControlColor</code> function for assigning the tint color to the <code class="literal">UIImageView</code>:</p><pre class="programlisting">private void UpdateControlColor() &#13;
        { &#13;
            if (Element.TintOn &amp;&amp; !string.IsNullOrEmpty(Element.TintColorString))  &#13;
            { &#13;
                var color = UIColor.Clear.FromHex (Element.TintColorString, 1.0f); &#13;
 &#13;
                _imageView.Image = UIImageEffects.GetColoredImage(_imageView.Image, color); &#13;
            } &#13;
        } &#13;
</pre><p>Here we are using another <code class="literal">static</code> class, which will take a color and the image and return a new image tinted to the color passed in.</p></div>
<div class="section" title="Building the UIImageEffects class"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec141"/>Building the UIImageEffects class</h1></div></div></div><p>Our final part to the image tinting on iOS is implementing the class that will return a tinted image from a template image and color. Create a new folder in the iOS project called <code class="literal">Helpers</code>, add a new file called <code class="literal">UIImageEffects.cs</code>, and implement the following:</p><pre class="programlisting">public static class UIImageEffects &#13;
    { &#13;
        public static UIImage GetColoredImage(UIImage image, UIColor color) &#13;
        { &#13;
            UIImage coloredImage = null; &#13;
 &#13;
            UIGraphics.BeginImageContext(image.Size); &#13;
 &#13;
            using (CGContext context = UIGraphics.GetCurrentContext()) &#13;
            { &#13;
                context.TranslateCTM(0, image.Size.Height); &#13;
                context.ScaleCTM(1.0f, -1.0f); &#13;
 &#13;
                var rect = new CGRect(0, 0, image.Size.Width, image.Size.Height); &#13;
 &#13;
                // draw image, (to get transparancy mask) &#13;
                context.SetBlendMode(CGBlendMode.Normal); &#13;
                context.DrawImage(rect, image.CGImage); &#13;
 &#13;
                // draw the color using the sourcein blend mode so its only draw on the non-transparent pixels &#13;
                context.SetBlendMode(CGBlendMode.SourceIn); &#13;
                context.SetFillColor(color.CGColor); &#13;
                context.FillRect(rect); &#13;
 &#13;
                coloredImage = UIGraphics.GetImageFromCurrentImageContext(); &#13;
                UIGraphics.EndImageContext(); &#13;
            } &#13;
 &#13;
            return coloredImage; &#13;
        } &#13;
    } &#13;
</pre><p>The function starts with creating a new <code class="literal">UIImage</code> and setting it to null. We then create a new image context by calling <code class="literal">BeginImageContext</code> and passing in the image size from the <code class="literal">UIImage</code> we pass in to the function. We then wrap the current context in a using statement to make sure we free memory taken from image processing in the context. We use the current context to assign correct (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) translation and scale to match the <code class="literal">UIImage</code> passed in. After this, we create a new <code class="literal">Rect</code> to match the bounds of the <code class="literal">UIImage</code> we passed into the function. We then call <code class="literal">SetBlendMode</code> to assign the image's transparency and call <code class="literal">DrawImage</code> to draw the image. Now that we have drawn the image within the context, we then call <code class="literal">SetBlendMode</code> again to using the <code class="literal">CGBlendMode.SourceIn</code> so that it only draws on the nontransparent pixels. We then set the fill color of the context to the color we passed into the function, which will be the tint color. The image context will then fill the bounds of the <code class="literal">Rect</code> we created earlier. Finally, we end the image processing by calling <code class="literal">EndImageContext</code> and return the new <code class="literal">colouredImage</code> to the caller.</p><p>Fantastic! We have now used the native <code class="literal">UIGraphics</code> framework to perform image tinting for iOS; let's do the same for Android.</p></div>
<div class="section" title="Building the CustomImageRenderer for Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec142"/>Building the CustomImageRenderer for Android</h1></div></div></div><p>Add a new folder into the <code class="literal">Renderers</code> folder called <code class="literal">CusotmImage</code>, add a new file called <code class="literal">CustomImageRenderer.cs</code>, and implement the following:</p><pre class="programlisting">public class CustomImageRenderer : ViewRenderer&lt;CustomImage, ImageView&gt;  &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private readonly string _tag; &#13;
 &#13;
        private ImageView _imageView; &#13;
 &#13;
        private CustomImage _customImage; &#13;
 &#13;
        private ILogger _log; &#13;
 &#13;
        private Bitmap _bitmap; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Constructors &#13;
 &#13;
        public CustomImageRenderer() &#13;
        { &#13;
            _log = IoC.Resolve&lt;ILogger&gt; (); &#13;
            _tag = string.Format ("{0} ", GetType ()); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>We are going to use an <code class="literal">ImageView</code> as the native control. We also have a local <code class="literal">CustomImage</code>, which will reference the element we are rendering on. We also have a local <code class="literal">Bitmap</code>, which will be the image we are tinting. Then we have the <code class="literal">_log</code> and <code class="literal">tag</code> properties again for logging any exceptions.</p><p>Let's now add the <code class="literal">OnElementChanged</code> method:</p><pre class="programlisting">        #region Protected Methods &#13;
 &#13;
        protected override void OnElementChanged (ElementChangedEventArgs&lt;CustomImage&gt; e) &#13;
        { &#13;
            base.OnElementChanged (e); &#13;
 &#13;
            if (Control == null) &#13;
            { &#13;
                _imageView = new ImageView(Context); &#13;
 &#13;
                SetNativeControl(_imageView); &#13;
            } &#13;
 &#13;
            if (e.NewElement != null) &#13;
            { &#13;
                _customImage = e.NewElement; &#13;
 &#13;
                SetAspect(); &#13;
 &#13;
                Android.App.Application.SynchronizationContext.Post(state =&gt; &#13;
                { &#13;
                    UpdateControlColor(); &#13;
                }, null); &#13;
 &#13;
                LoadImage().ConfigureAwait(false); &#13;
 &#13;
                e.NewElement.CustomPropertyChanged += HandleCustomPropertyChanged; &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Here we create a new <code class="literal">ImageView</code> as the control. When the <code class="literal">NewElement</code> is not null, we assign it to <code class="literal">_customImage</code>, set the aspect ratio of the <code class="literal">ImageView</code>, add the tint color, and load the image.</p><p>Now we have to handle disposal by overriding the <code class="literal">Dispose</code> method:</p><pre class="programlisting">protected override void Dispose(bool disposing) &#13;
        { &#13;
            if (_bitmap != null) &#13;
            { &#13;
                _bitmap.Recycle(); &#13;
                _bitmap.Dispose(); &#13;
            } &#13;
 &#13;
            Element.CustomPropertyChanged -= HandleCustomPropertyChanged; &#13;
 &#13;
            base.Dispose(disposing); &#13;
        }  &#13;
</pre><p>Then we add the <code class="literal">private</code> methods. We are going to start with the <code class="literal">SetAspect</code> function. Like our iOS implementation, we will map the <code class="literal">Xamarin.Forms</code> image aspect value to the native <code class="literal">ImageViewScaleType</code>:</p><pre class="programlisting">        private void SetAspect() &#13;
        { &#13;
            if (Element != null) &#13;
            { &#13;
                switch (Element.Aspect)  &#13;
                { &#13;
                case Aspect.AspectFill: &#13;
                    _imageView.SetScaleType (ImageView.ScaleType.FitXy); &#13;
                    break; &#13;
                case Aspect.AspectFit: &#13;
                    _imageView.SetScaleType (ImageView.ScaleType.FitCenter); &#13;
                    break; &#13;
                case Aspect.Fill: &#13;
                    _imageView.SetScaleType (ImageView.ScaleType.FitXy); &#13;
                    break; &#13;
                default: &#13;
                    _imageView.SetScaleType (ImageView.ScaleType.FitCenter); &#13;
                    break; &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>Then we have the <code class="literal">delegate</code> function for handling all our property changes:</p><pre class="programlisting">        private void HandleCustomPropertyChanged (object sender, string propertyName) &#13;
        { &#13;
            switch (propertyName) &#13;
            { &#13;
                case "TintColorString": &#13;
                case "TintOn": &#13;
                    Android.App.Application.SynchronizationContext.Post(state =&gt; &#13;
                    { &#13;
                        UpdateControlColor(); &#13;
                    }, null); &#13;
                    break; &#13;
                case "Path": &#13;
                    LoadImage().ConfigureAwait(false); &#13;
                    break; &#13;
            } &#13;
        } &#13;
</pre><p>Our <code class="literal">LoadImage</code> is a bit better than the iOS version because it loads the image asynchronously:</p><pre class="programlisting">        private async Task LoadImage() &#13;
        { &#13;
            try &#13;
            { &#13;
                _bitmap = await ReadBitmapImageFromStorage(Element.Path); &#13;
 &#13;
                if (_imageView != null &amp;&amp; _bitmap != null) &#13;
                { &#13;
                    Android.App.Application.SynchronizationContext.Post(state =&gt; _imageView.SetImageBitmap(_bitmap), null); &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                _log.WriteLineTime(_tag + "\n" + &#13;
                    "LoadAsync() Failed to load view model.  \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
        } &#13;
</pre><p>We only call the <code class="literal">SetImageBitmap</code> on the <code class="literal">ImageView</code> if the <code class="literal">ImageView</code> and <code class="literal">Bitmap</code> is not null.</p><p>Next we have the <code class="literal">UpdateControlColor</code> function for tinting the image. Android offers a much simpler solution for tinting using the <code class="literal">SetColorFilter</code> function. We must pass in a <code class="literal">PorterDuff.Mode</code>, which the <code class="literal">SetColorFilter</code> will use to determine how to compose the image based on the alpha value:</p><pre class="programlisting">        private void UpdateControlColor() &#13;
        { &#13;
            try  &#13;
            { &#13;
                if (_customImage.TintOn &amp;&amp; !string.IsNullOrEmpty(_customImage.TintColorString)) &#13;
                { &#13;
                    var color = Android.Graphics.Color.ParseColor(_customImage.TintColorString); &#13;
                    _imageView.SetColorFilter (color, PorterDuff.Mode.SrcAtop); &#13;
                } &#13;
            } &#13;
            catch (Exception e)  &#13;
            { &#13;
                _log.WriteLineTime ("CustomImageRenderer: " + e); &#13;
            } &#13;
        } &#13;
</pre><p>Next we have the <code class="literal">ReadBitmapImageFromStorage</code> function, where we will be loading a <code class="literal">Bitmap</code> from the <code class="literal">Path</code> property of the <code class="literal">CustomImage</code>. We use the <code class="literal">GetIdentifier</code> function from the <code class="literal">Resources</code> framework to retrieve the integer ID of the image resource we want to load.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip128"/>Tip</h3><p>Remember, the image must be inside our <code class="literal">drawable</code> or <code class="literal">mipmap</code> folder for the image to be found.</p></div></div><p>We then open the raw file as a stream using the <code class="literal">OpenRawResource</code> function, and using the <code class="literal">BitmapFactory</code> framework, we can use the raw resource stream to decode a <code class="literal">Bitmap</code> object that will be returned:</p><pre class="programlisting">        private async Task&lt;Bitmap&gt; ReadBitmapImageFromStorage(string fn) &#13;
        { &#13;
            try &#13;
            { &#13;
                if (!string.IsNullOrEmpty(fn)) &#13;
                { &#13;
                    var file = fn.Split('.').FirstOrDefault(); &#13;
 &#13;
                    var id = Resources.GetIdentifier(file, "drawable", Context.PackageName); &#13;
 &#13;
                    using (Stream stream = Resources.OpenRawResource(id)) &#13;
                    { &#13;
                        if (stream != null) &#13;
                        { &#13;
                            return await BitmapFactory.DecodeStreamAsync(stream); &#13;
                        } &#13;
                    } &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                _log.WriteLineTime( &#13;
                    "MyCareManager.Droid.Renderers.CustomImageRenderer; \n" + &#13;
                    "ErrorMessage: Failed to load image " + fn + "\n " + &#13;
                    "Stacktrace: Login Error  \n " + &#13;
                    error); &#13;
            } &#13;
 &#13;
            return null; &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Great! We have now built all our <code class="literal">CustomRenderers</code> for the solution. Let's see how we use these with our user interface screens.</p></div>
<div class="section" title="Triggers"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec143"/>Triggers</h1></div></div></div><p>The first page will consist of two buttons, an image, a label, and extra additional UI functionality known as <span class="strong"><strong>triggers</strong></span>. Triggers are declarative objects used in XAML, which contain actions executed when certain conditions or events occur. The main advantage of triggers is we can box up these handle actions for as many UI elements that need to perform the same actions. We have the option of the following four different types of triggers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Property trigger</strong></span>: This is executed when a property on a control is set to a particular value.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data trigger</strong></span>: This is same as the property trigger but uses data binding.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Event trigger</strong></span>: This is occurs when an event occurs on the control.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multi trigger</strong></span>: This is allows multiple trigger conditions to be set before an action occurs.</li></ul></div><p>In our solution, we are going to add two event triggers for button click events.</p><p>Let's start with adding a new folder called <code class="literal">Triggers</code> into the <code class="literal">Camera</code> project, add a new file called <code class="literal">ButtonClickTrigger.cs</code>, and implement the following:</p><pre class="programlisting">    public class ButtonClickedTrigger : TriggerAction&lt;Button&gt; &#13;
    { &#13;
        #region Protected Methods &#13;
 &#13;
        protected override void Invoke(Button sender) &#13;
        { &#13;
            sender.TextColor = Color.Blue; &#13;
            sender.BackgroundColor = Color.Aqua; &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Our first trigger is for handling the <code class="literal">Clicked</code> event on the <code class="literal">CameraButton</code>. When this button is clicked, the background and text color of the button will change. We must override the <code class="literal">Invoke</code> function to claim the <code class="literal">Button</code> performing the action.</p><p>Now let's add another folder for the <code class="literal">Pages</code>, add a new file called <code class="literal">MainPage.xaml</code>, and implement the following:</p><pre class="programlisting">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ui:ExtendedContentPage   &#13;
     &#13;
     &#13;
     &#13;
    x:Class="Camera.Pages.MainPage" &#13;
    BackgroundColor="White" &#13;
    Title="Welcome"&gt; &#13;
 &#13;
    &lt;ui:ExtendedContentPage.Content&gt; &#13;
        &lt;Grid x:Name="Grid" RowSpacing="10" Padding="10, 10, 10, 10" VerticalOptions="Center"&gt; &#13;
            &lt;Grid.RowDefinitions&gt; &#13;
                &lt;RowDefinition Height="*"/&gt; &#13;
                &lt;RowDefinition Height="Auto"/&gt; &#13;
                &lt;RowDefinition Height="Auto"/&gt; &#13;
                &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
            &lt;Grid.ColumnDefinitions&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
            &lt;Image x:Name="Image" Source="camera.png" HeightRequest="120" WidthRequest="120"  &#13;
                    Grid.Row="0" Grid.Column="0"/&gt; &#13;
 &#13;
            &lt;Button x:Name="CameraButton" Text="{Binding CameraTitle}"  &#13;
                Command="{Binding CameraCommand}" Style="{StaticResource BaseButtonStyle}" Grid.Row="2" Grid.Column="0"&gt; &#13;
                &lt;Button.Triggers&gt; &#13;
                    &lt;EventTrigger Event="Clicked"&gt; &#13;
                        &lt;t:ButtonClickedTrigger/&gt; &#13;
                    &lt;/EventTrigger&gt; &#13;
                &lt;/Button.Triggers&gt; &#13;
            &lt;/Button&gt; &#13;
             &#13;
            &lt;Button x:Name="ExitButton" Text="{Binding ExitTitle}"  &#13;
                Command="{Binding ExitCommand}" Style="{StaticResource ButtonStyleWithTrigger}"  &#13;
                Grid.Row="3" Grid.Column="0"/&gt; &#13;
        &lt;/Grid&gt; &#13;
    &lt;/ui:ExtendedContentPage.Content&gt; &#13;
&lt;/ui:ExtendedContentPage&gt;  &#13;
</pre><p>We must include the namespace reference to location of the <code class="literal">Triggers</code> folder. Then turn attention to the <code class="literal">CameraButton</code>, where we will attach the <code class="literal">ButtonClickedTrigger</code>. When the button is touched, the <code class="literal">Invoke</code> method of the trigger will be called.</p><p>The next trigger we add will perform a nice warping animation to a button when it is clicked. Let's add another file called <code class="literal">VisualElementPopTriggerAction.cs</code> and implement the following:</p><pre class="programlisting">public class VisualElementPopTriggerAction : TriggerAction&lt;VisualElement&gt; &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public Point Anchor { set; get; } &#13;
 &#13;
        public double Scale { set; get; } &#13;
 &#13;
        public uint Length { set; get; } &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Constructors &#13;
 &#13;
        public VisualElementPopTriggerAction() &#13;
        { &#13;
            Anchor = new Point(0.5, 0.5); &#13;
            Scale = 2; &#13;
            Length = 500; &#13;
        } &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Protected Methods &#13;
 &#13;
        protected override async void Invoke(VisualElement visual) &#13;
        { &#13;
            visual.AnchorX = Anchor.X; &#13;
            visual.AnchorY = Anchor.Y; &#13;
            await visual.ScaleTo(Scale, Length / 2, Easing.SinOut); &#13;
            await visual.ScaleTo(1, Length / 2, Easing.SinIn); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>The <code class="literal">Anchor</code> property is used for the point (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) in which the <code class="literal">ScaleTo</code> function will reference. Since the reference points <code class="literal">X</code> and <code class="literal">Y</code> are <code class="literal">0.5</code>, when animate an expansion on the button, it will expand evenly on both the left/right and top/bottom. The <code class="literal">Invoke</code> method will be called when the button is clicked to begin the animation. We are also using the Sin easing for each animation:</p><div class="section" title="Easing.SinIn"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Easing.SinIn</h2></div></div></div><p>Starts slow and speeds:</p><div class="mediaobject"><img src="graphics/image_08_002.jpg" alt="Easing.SinIn"/></div></div><div class="section" title="Easing.SinOut"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Easing.SinOut</h2></div></div></div><p>Starts fast and slows down:</p><div class="mediaobject"><img src="graphics/image_08_003.jpg" alt="Easing.SinOut"/></div><p>Let's have a look at how we will use the <code class="literal">VisualElementPopTriggerAction</code> inside a style. Add in the <code class="literal">App.Xaml</code> file and implement the following styles:</p><pre class="programlisting">            &lt;Style x:Key="BaseButtonStyle" TargetType="Button"&gt; &#13;
                &lt;Setter Property="TextColor"&gt; &#13;
                    &lt;Setter.Value&gt; &#13;
                        &lt;OnPlatform x:TypeArguments="Color" &#13;
                            Android="Navy" &#13;
                            WinPhone="Black" &#13;
                            iOS="Black"&gt; &#13;
                        &lt;/OnPlatform&gt; &#13;
                    &lt;/Setter.Value&gt; &#13;
                &lt;/Setter&gt; &#13;
                &lt;Setter Property="FontSize" Value="20" /&gt; &#13;
                &lt;Setter Property="FontFamily" Value="Arial" /&gt; &#13;
                &lt;Setter Property="BackgroundColor" Value="Silver" /&gt; &#13;
            &lt;/Style&gt; &#13;
             &#13;
            &lt;Style x:Key="ButtonStyleWithTrigger" TargetType="Button" &#13;
                    BasedOn="{StaticResource BaseButtonStyle}"&gt; &#13;
                &lt;Style.Triggers&gt; &#13;
                    &lt;EventTrigger Event="Clicked"&gt; &#13;
                        &lt;t:VisualElementPopTriggerAction/&gt; &#13;
                    &lt;/EventTrigger&gt; &#13;
                &lt;/Style.Triggers&gt; &#13;
            &lt;/Style&gt; &#13;
</pre><p>Can you see what technique we are using here?</p><p>This is known as <span class="strong"><strong>style inheritance</strong></span>. The <code class="literal">ButtonStyleWithTrigger</code> style inherits all the styling properties of the <code class="literal">BaseButtonStyle</code> by using the <code class="literal">BasedOn</code> property.</p><p>Wait! Aren't we missing the <code class="literal">DescriptionLabel</code> from the <code class="literal">MainPage</code>?</p><p>We still have one more element to add to the <code class="literal">MainPage</code>. But first we are going to talk about another object used in XAML known as <span class="strong"><strong>PlatformEffects</strong></span>.</p></div></div>
<div class="section" title="Platform effects"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec144"/>Platform effects</h1></div></div></div><p>Platform effects are used to simplify native control customization, reducing the need to create <code class="literal">CustomRenderers</code> for small styling changes. This means we don't have to create a custom renderer every single time we want native customization. To implement a <code class="literal">PlatformEffect</code>, we first create a class that subclasses the <code class="literal">PlatformEffect</code> framework. Then we have to write platform-specific implementations for each.</p><p>Following is a small overview of how the rendering process will look among the different projects:</p><div class="mediaobject"><img src="graphics/image_08_004.jpg" alt="Platform effects"/></div><p>Let's add a new folder called <code class="literal">Effects</code> inside the <code class="literal">Camera</code> project, add in a new file called <code class="literal">LabelShadowEffect.cs</code>, and implement the following:</p><pre class="programlisting">public class LabelShadowEffect : RoutingEffect &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public float Radius { get; set; } &#13;
 &#13;
        public Color Color { get; set; } &#13;
 &#13;
        public float DistanceX { get; set; } &#13;
 &#13;
        public float DistanceY { get; set; } &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Constructors &#13;
 &#13;
        public LabelShadowEffect() : base("Camera.LabelShadowEffect") &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Our <code class="literal">LabelShadowEffect</code> must inherit the <code class="literal">PlatformEffect</code> framework. The <code class="literal">Radius</code> property is responsible for the corner radius of the shadow. Then we have the <code class="literal">Color</code> property that will set the color of the shadow. Finally, we have the <code class="literal">DistanceX</code> and <code class="literal">DistanceY</code> properties for assigning the position of the shadow.</p><p>Now we must create the platform implementations. Let's start with iOS, add in a new folder called <code class="literal">Effects</code>, add in a new file called <code class="literal">LabelShadowEffectiOS.cs</code>, and implement the following:</p><pre class="programlisting">public class LabelShadowEffectiOS : PlatformEffect &#13;
    { &#13;
        #region Protected Methods &#13;
 &#13;
        protected override void OnAttached() &#13;
        { &#13;
            try &#13;
            { &#13;
                var effect = (LabelShadowEffect)Element.Effects.FirstOrDefault(e =&gt; e is LabelShadowEffect); &#13;
 &#13;
                if (effect != null) &#13;
                { &#13;
                    Control.Layer.CornerRadius = effect.Radius; &#13;
                    Control.Layer.ShadowColor = effect.Color.ToCGColor(); &#13;
                    Control.Layer.ShadowOffset = new CGSize(effect.DistanceX, effect.DistanceY); &#13;
                    Control.Layer.ShadowOpacity = 1.0f; &#13;
                } &#13;
            } &#13;
            catch (Exception ex) &#13;
            { &#13;
                Console.WriteLine("Cannot set property on attached control. Error: ", ex.Message); &#13;
            } &#13;
        } &#13;
 &#13;
        protected override void OnDetached() &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>All <code class="literal">PlatformEffects</code> must override the <code class="literal">OnAttached</code> and <code class="literal">OnDetached</code> methods. The <code class="literal">OnAttached</code> method is where we set up all native shadow effects. We start with retrieving the first <code class="literal">PlatformEffect</code> from the <code class="literal">Effects </code>list of the <code class="literal">Element </code>object. Like our <code class="literal">CustomRenderers</code>, we have access to the original <code class="literal">Xamarin.Forms</code> element that we are customizing. In the <code class="literal">OnDetached</code> method, we would normally dispose any objects that are no longer required.</p><p>We must also add assembly lines above the namespace block like the following:</p><pre class="programlisting">[assembly: Xamarin.Forms.ResolutionGroupName("Camera")] &#13;
[assembly: Xamarin.Forms.ExportEffect(typeof(Camera.Droid.Effects.LabelShadowEffectiOS), "LabelShadowEffect")] &#13;
</pre><p>We must add a <code class="literal">ResolutionGroupName</code> to specify the namespace for the effects; this prevents collisions with other effects of the same name. We also add the <code class="literal">ExportEffect</code> attribute to register the effect with a unique ID that is used by <code class="literal">Xamarin.Forms</code>, along with the group name, to locate the effect prior to applying it to a control.</p><p>Now let's add the equivalent for Android. Add a new folder in the <code class="literal">Camera.Droid</code> project, add a new file called <code class="literal">LabelShadowEffectDroid.cs</code>, and implement the following:</p><pre class="programlisting">public class LabelShadowEffectDroid : PlatformEffect &#13;
    { &#13;
        #region Protected Methods &#13;
 &#13;
        protected override void OnAttached() &#13;
        { &#13;
            try &#13;
            { &#13;
                var control = Control as Android.Widget.TextView; &#13;
 &#13;
                var effect = (LabelShadowEffect)Element.Effects.FirstOrDefault(e =&gt; e is LabelShadowEffect); &#13;
 &#13;
                if (effect != null) &#13;
                { &#13;
                    control.SetShadowLayer(effect.Radius, effect.DistanceX, effect.DistanceY, effect.Color.ToAndroid()); &#13;
                } &#13;
            } &#13;
            catch (Exception ex) &#13;
            { &#13;
                Console.WriteLine("Cannot set property on attached control. Error: ", ex.Message); &#13;
            } &#13;
        } &#13;
 &#13;
        protected override void OnDetached() &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>In our Android implementation, we start with retrieving the control as a native <code class="literal">TextView</code>. We then retrieve the first <code class="literal">LabelShadowEffect</code> object from the list of effects from the <code class="literal">Element</code>. We then use the method <code class="literal">SetShadowLayer</code> to create native shadowing on the <code class="literal">TextView</code>.</p><p>Great! Now we have our native implementations, let's add the <code class="literal">DescriptionLabel</code> object to the <code class="literal">MainPage</code>:</p><pre class="programlisting">&lt;Label x:Name="DesciptionLabel" Text="{Binding DescriptionMessage}" TextColor="Black"  &#13;
                    HorizontalOptions="Center" Font="Arial, 20" Grid.Row="1" Grid.Column="0"&gt; &#13;
                &lt;Label.Effects&gt; &#13;
                    &lt;e:LabelShadowEffect Radius="5" DistanceX="5" DistanceY="5"&gt; &#13;
                        &lt;e:LabelShadowEffect.Color&gt; &#13;
                            &lt;OnPlatform x:TypeArguments="Color" iOS="Black" Android="Blue" WinPhone="Red" /&gt; &#13;
                        &lt;/e:LabelShadowEffect.Color&gt; &#13;
                    &lt;/e:LabelShadowEffect&gt; &#13;
                &lt;/Label.Effects&gt; &#13;
            &lt;/Label&gt; &#13;
</pre><p>Here we are able to attach the effect inside our XAML. We must also add the namespace to the <code class="literal">Effects</code> folder:</p><pre class="programlisting">  &#13;
</pre><p>This is how the <code class="literal">MainPage</code> will look once complete:</p><div class="mediaobject"><img src="graphics/image_08_005.jpg" alt="Platform effects"/></div></div>
<div class="section" title="Building the CameraPage"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec145"/>Building the CameraPage</h1></div></div></div><p>Now for the final page of the solution, the <code class="literal">CameraPage</code> introduces some new tricks to handle orientation changes with <code class="literal">Grid</code> positions. We will be using <code class="literal">Converters</code> to change rows and columns on the <code class="literal">Grid</code> to reposition elements when we change orientation.</p><p>We are going to start with adding some converters to the project. Let's create a new folder in the <code class="literal">Camera</code> project, add a new file called <code class="literal">NotConverter.cs</code>, and implement the following:</p><pre class="programlisting">public class NotConverter : IValueConverter &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            var b = value as bool?; &#13;
 &#13;
            if (b != null) &#13;
            { &#13;
                return !b; &#13;
            } &#13;
 &#13;
            return value; &#13;
        } &#13;
 &#13;
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException(); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>Our first converter is responsible for taking a Boolean value and returning the opposite. Next we have the <code class="literal">OrientationToBoolConverter</code>. Add a new file and implement the following:</p><pre class="programlisting">public class OrientationToBoolConverter:IValueConverter &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public object Convert (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            try &#13;
            { &#13;
                var str = parameter as string; &#13;
 &#13;
                if (str != null)  &#13;
                { &#13;
                    // split string by ',', convert to int and store in case list &#13;
                    var cases = str.Split(',').Select(x =&gt; bool.Parse(x)).ToList(); &#13;
 &#13;
                    if (value is Orientation) &#13;
                    { &#13;
                        switch ((Orientation)value) &#13;
                        { &#13;
                            case Orientation.LandscapeRight: &#13;
                            case Orientation.LandscapeLeft: &#13;
                                return cases[0]; &#13;
                            case Orientation.Portrait: &#13;
                                return cases[1]; &#13;
                            case Orientation.None: &#13;
                                return 0; &#13;
                        } &#13;
                    } &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                IoC.Resolve&lt;ILogger&gt;().WriteLineTime("OrientationToBoolConverter \n" + &#13;
                    "Convert() Failed to switch flash on/off \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
 &#13;
            return 0; &#13;
        }  &#13;
 &#13;
        public object ConvertBack (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException (); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>This converter uses the <code class="literal">Orientation</code><code class="literal">enum</code> we created at the start of the chapter. It will receive an <code class="literal">Orientation </code>value and a string as the parameter like the following:</p><pre class="programlisting">'false, true' &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note129"/>Note</h3><p>Converters can take parameters as well as values, so passing a string containing multiple cases allows us to use a set of specific return values to map to the values passed in.</p></div></div><p>We will then use the <code class="literal">Split</code> method to break up the string by the comma character, meaning we will have two strings that will be parsed in as a Boolean. These will be used as the return cases for the different orientations.</p><p>Now let's add another converter, which will convert a Boolean into a string:</p><pre class="programlisting">public class BoolToStringConverter:IValueConverter &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public object Convert (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            try &#13;
            { &#13;
                var str = parameter as string; &#13;
 &#13;
                if (str != null)  &#13;
                { &#13;
                    // split string by ',', convert to int and store in case list &#13;
                    var cases = str.Split(',').Select(x =&gt; x).ToList(); &#13;
 &#13;
                    if (value is bool) &#13;
                    { &#13;
                        return (bool)value ? cases[0] : cases[1]; &#13;
                    } &#13;
                } &#13;
            } &#13;
            catch (Exception error)  &#13;
            { &#13;
                IoC.Resolve&lt;ILogger&gt;().WriteLineTime("BoolToStringConverter \n" + &#13;
                    "Convert() Failed to switch flash on/off \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
 &#13;
            return string.Empty; &#13;
        } &#13;
 &#13;
        public object ConvertBack (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException (); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>We will use this on the camera page when the flash is turned on/off. If the flash is on, the string <span class="emphasis"><em>on</em></span> will be returned. If the flash is off, we will return the string <span class="emphasis"><em>off</em></span>. We use the same method as the <code class="literal">OrientationToBoolConverter</code> as we pass in a string value for the return cases.</p><p>Next, add another file called <code class="literal">BoolToPartialConverter.cs</code> and implement the following:</p><pre class="programlisting">public class BoolToPartialConverter:IValueConverter &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public object Convert (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            try &#13;
            { &#13;
                var str = parameter as string; &#13;
 &#13;
                if (str != null)  &#13;
                { &#13;
                    // split string by ',', convert to int and store in case list &#13;
                    var cases = str.Split(',').Select(x =&gt; Double.Parse(x)).ToList(); &#13;
 &#13;
                    if (value is bool) &#13;
                    { &#13;
                        return (bool)value ? cases[0] : cases[1]; &#13;
                    } &#13;
                } &#13;
            } &#13;
            catch (Exception error)  &#13;
            { &#13;
                IoC.Resolve&lt;ILogger&gt;().WriteLineTime("BoolToPartialConverter \n" + &#13;
                    "Convert() Failed to switch flash on/off \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
 &#13;
            return 0; &#13;
        } &#13;
 &#13;
        public object ConvertBack (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException (); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>This will be used for updating opacity based upon the value being <code class="literal">true</code> or <code class="literal">false</code>. We use a string for the opacity values being returned for each Boolean value.</p><p>Our next converter <code class="literal">OrientationToIntConverter</code> is responsible for converting Orientation values into integers. This is the converter that will be responsible for changing the rows and columns numbers when the orientation changes:</p><pre class="programlisting">public class OrientationToIntConverter:IValueConverter &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public object Convert (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            try &#13;
            { &#13;
                var str = parameter as string; &#13;
 &#13;
                if (str != null)  &#13;
                { &#13;
                    // split string by ',', convert to int and store in case list &#13;
                    var cases = str.Split(',').Select(x =&gt; Int32.Parse(x)).ToList(); &#13;
 &#13;
                    if (value is Orientation) &#13;
                    { &#13;
                        switch ((Orientation)value) &#13;
                        { &#13;
                            case Orientation.LandscapeRight: &#13;
                            case Orientation.LandscapeLeft: &#13;
                                return cases[0]; &#13;
                            case Orientation.Portrait: &#13;
                                return cases[1]; &#13;
                            case Orientation.None: &#13;
                                return cases[0]; &#13;
                        } &#13;
                    } &#13;
                } &#13;
            } &#13;
            catch (Exception error) &#13;
            { &#13;
                IoC.Resolve&lt;ILogger&gt;().WriteLineTime("OrientationToIntConverter \n" + &#13;
                    "Convert() Failed to switch flash on/off \n " + &#13;
                    "ErrorMessage: \n" + &#13;
                    error.Message + "\n" + &#13;
                    "Stacktrace: \n " + &#13;
                    error.StackTrace); &#13;
            } &#13;
 &#13;
            return 0; &#13;
        } &#13;
 &#13;
        public object ConvertBack (object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException (); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Again, we are using a string to contain the return cases, which we parse into a new integer using the <code class="literal">Int32.Parse</code> method.</p><p>Our last converter will be responsible for converting a byte array into an <code class="literal">ImageSource</code>. This is used for the binding created from the <code class="literal">CameraViewModel</code> in our <code class="literal">Camera.Portable</code> project. Since we don't have the <code class="literal">ImageSource</code> framework in our portable project, we will use byte arrays to hold the image data received from the camera:</p><pre class="programlisting">public class ByteArrayToImageSourceConverter : IValueConverter &#13;
    { &#13;
        #region Public Methods &#13;
 &#13;
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#13;
        { &#13;
            byte[] bytes = value as byte[]; &#13;
            var defaultFile = parameter as string; &#13;
 &#13;
            if (bytes != null &amp;&amp; bytes.Length &gt; 1) &#13;
            { &#13;
                return ImageSource.FromStream(() =&gt; new MemoryStream(bytes)); &#13;
            } &#13;
 &#13;
            if (defaultFile != null) &#13;
            { &#13;
                return ImageSource.FromFile(defaultFile); &#13;
            } &#13;
 &#13;
            return ImageSource.FromFile ("loading.png"); &#13;
        } &#13;
 &#13;
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) &#13;
        { &#13;
            throw new NotImplementedException(); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>In the <code class="literal">Convert</code> method, we check to see if the byte array is not null and contains data, and if so, we use the <code class="literal">FromStream</code> method from the <code class="literal">ImageSource</code> framework to create a new <code class="literal">MemoryStream</code> from the byte array.</p><p>Now that we have all our converters, we must add these to the <code class="literal">App.xaml</code>:</p><pre class="programlisting">&lt;converters:NotConverter x:Key="notConverter"/&gt; &#13;
            &lt;converters:OrientationToBoolConverter x:Key="orientationToBoolConverter"/&gt; &#13;
            &lt;converters:BoolToStringConverter x:Key="boolToStringConverter"/&gt; &#13;
            &lt;converters:BoolToPartialConverter x:Key="boolToPartialConverter"/&gt; &#13;
            &lt;converters:OrientationToIntConverter x:Key="orientationToIntConverter"/&gt; &#13;
            &lt;converters:ByteArrayToImageSourceConverter x:Key="byteArrayToImageSourceConverter"/&gt;  &#13;
</pre><p>Excellent! Let's build the interface for the <code class="literal">CameraPage</code>. We will see how these converters are used on each UI element.</p><p>Add a new file called <code class="literal">CameraPage.xaml</code> and implement the following:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt; &#13;
&lt;ui:ExtendedContentPage  &#13;
     &#13;
     &#13;
     &#13;
    x:Class="Camera.Pages.CameraPage" &#13;
    BackgroundColor="#F2F2F2"&gt; &#13;
 &#13;
    &lt;Grid x:Name="MainLayout" BackgroundColor="Black"  &#13;
            RowSpacing="0" ColumnSpacing="0"&gt; &#13;
        &lt;Grid.RowDefinitions&gt; &#13;
            &lt;RowDefinition Height="*" /&gt; &#13;
            &lt;RowDefinition Height="40" /&gt; &#13;
            &lt;RowDefinition Height="*" /&gt; &#13;
            &lt;RowDefinition Height="*" /&gt; &#13;
            &lt;RowDefinition Height="*" /&gt; &#13;
            &lt;RowDefinition Height="*" /&gt; &#13;
            &lt;RowDefinition Height="60" /&gt; &#13;
        &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
        &lt;Grid.ColumnDefinitions&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;ColumnDefinition Width="60"/&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;ColumnDefinition Width="100"/&gt; &#13;
        &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
   &lt;/Grid&gt; &#13;
&lt;/ui:ExtendedContentPage&gt;  &#13;
</pre><p>We start with an empty <code class="literal">Grid</code>, which has seven rows and six columns. The first element to add is the <code class="literal">CameraView</code>:</p><pre class="programlisting">&lt;controls:CameraView x:Name="CameraView" BackgroundColor="Black" Grid.Row="0"  &#13;
            Grid.RowSpan="{Binding PageOrientation, Converter={StaticResource orientationToIntConverter}, ConverterParameter='7, 6'}"  &#13;
            Grid.Column="0" Grid.ColumnSpan="{Binding PageOrientation, Converter={StaticResource orientationToIntConverter}, ConverterParameter='5, 6'}"/&gt; &#13;
</pre><p>Here we can see the use of the <code class="literal">OrientationToIntConverter</code>. The <code class="literal">PageOrientation</code> property from the view-model. When this property is set, and the <code class="literal">OnPropertyChanged</code> method is called. The <code class="literal">Convert</code> method will return a new integer, changing the number of rows the <code class="literal">CameraView</code> will take up. This is the same on the <code class="literal">ColumnSpan</code> property; the amount of columns taken by the <code class="literal">CameraView</code> will change when the orientation changes.</p><p>Next we add the <code class="literal">FocusView</code> as follows:</p><pre class="programlisting">&lt;controls:FocusView x:Name="FocusView"  &#13;
        Grid.Row="0"  &#13;
        Grid.RowSpan="{Binding PageOrientation, Converter={StaticResource orientationToIntConverter}, ConverterParameter='7, 6'}"  &#13;
            Grid.Column="0" Grid.ColumnSpan="{Binding PageOrientation, Converter={StaticResource orientationToIntConverter}, ConverterParameter='5, 6'}"/&gt; &#13;
</pre><p>This will match the entire space of the <code class="literal">CameraView</code>. The <code class="literal">FocusView</code> will lay on top of the <code class="literal">CameraView</code> to receive the touch events and pass the (x, y) coordinate down to the <code class="literal">CameraView</code> to perform a focus.</p><p>Next, we are going to add another <code class="literal">Grid</code> for containing the flash and photo buttons:</p><pre class="programlisting">        &lt;Grid x:Name="CameraButtonContainerPortrait" ColumnSpacing="5"  &#13;
            IsEnabled="{Binding PageOrientation, Converter={StaticResource orientationToBoolConverter}, ConverterParameter='false, true'}}"  &#13;
            Opacity="0" Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="6"&gt; &#13;
            &lt;Grid.RowDefinitions&gt; &#13;
                &lt;RowDefinition Height="*"/&gt; &#13;
            &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
            &lt;Grid.ColumnDefinitions&gt; &#13;
                &lt;ColumnDefinition Width="35"/&gt; &#13;
                &lt;ColumnDefinition Width="45"/&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
                &lt;ColumnDefinition Width="45"/&gt; &#13;
                &lt;ColumnDefinition Width="35"/&gt; &#13;
            &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
            &lt;ContentView BackgroundColor="Black"  &#13;
                Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="5"/&gt; &#13;
 &#13;
            &lt;controls:CustomImage x:Name="CameraButtonPortrait" Path="photo_camera_button.png"  &#13;
                    TintOn="false" WidthRequest="50" HeightRequest="50"  &#13;
                    HorizontalOptions="Center" VerticalOptions="Center" Grid.Row="0" Grid.Column="2"&gt; &#13;
                &lt;controls:CustomImage.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleShutter"/&gt; &#13;
                &lt;/controls:CustomImage.GestureRecognizers&gt; &#13;
            &lt;/controls:CustomImage&gt; &#13;
 &#13;
            &lt;Label x:Name="FlashLabelPortrait" &#13;
                Text="{Binding IsFlashOn, Converter={StaticResource boolToStringConverter}, ConverterParameter='On, Off'}" &#13;
                TextColor="#0ca6df" XAlign="Start" YAlign="Center"  &#13;
                Grid.Row="0" Grid.Column="1"&gt; &#13;
                &lt;Label.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleFlash"/&gt; &#13;
                &lt;/Label.GestureRecognizers&gt; &#13;
            &lt;/Label&gt; &#13;
 &#13;
            &lt;controls:CustomImage x:Name="FlashImagePortrait" Path="photo_light.png"  &#13;
                    Margin="10, 0, 0, 0"  &#13;
                    VerticalOptions="Center" &#13;
                    TintOn="false" WidthRequest="20"  &#13;
                    HeightRequest="35" &#13;
                    Grid.Row="0" Grid.Column="0"&gt; &#13;
                &lt;controls:CustomImage.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleFlash"/&gt; &#13;
                &lt;/controls:CustomImage.GestureRecognizers&gt; &#13;
            &lt;/controls:CustomImage&gt; &#13;
        &lt;/Grid&gt; &#13;
</pre><p>Here we see the use of the <code class="literal">CustomImage</code> instead of a button because we want to be able to show a specific image for each button.</p><p>This panel is positioned under the <code class="literal">CameraView</code> like the following:</p><div class="mediaobject"><img src="graphics/image_08_006.jpg" alt="Building the CameraPage"/></div><p>Next we have the <code class="literal">LoadingView</code> for displaying status of camera activity for initialization and taking photos:</p><pre class="programlisting">        &lt;controls:LoadingView x:Name="LoadingView"  &#13;
            Grid.Row="0" Grid.RowSpan="7" Grid.Column="0" Grid.ColumnSpan="6"/&gt; &#13;
</pre><p>We now need to add another element for the camera buttons in landscape mode:</p><pre class="programlisting">        &lt;Grid x:Name="CameraButtonContainerLandscape" RowSpacing="5"  &#13;
                IsEnabled="{Binding PageOrientation, Converter={StaticResource orientationToBoolConverter}, ConverterParameter='true, false'}}"  &#13;
                Opacity="0" Grid.Row="0" Grid.RowSpan="7"  &#13;
                Grid.Column="{Binding PageOrientation, Converter={StaticResource orientationToIntConverter}, ConverterParameter='5, 4'}"&gt; &#13;
            &lt;Grid.RowDefinitions&gt; &#13;
                &lt;RowDefinition Height="45"/&gt; &#13;
                &lt;RowDefinition Height="40"/&gt; &#13;
                &lt;RowDefinition Height="*"/&gt; &#13;
                &lt;RowDefinition Height="40"/&gt; &#13;
                &lt;RowDefinition Height="45"/&gt; &#13;
            &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
            &lt;Grid.ColumnDefinitions&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
            &lt;ContentView BackgroundColor="Black" &#13;
                Grid.Row="0" Grid.RowSpan="5" Grid.Column="0"/&gt; &#13;
 &#13;
            &lt;controls:CustomImage x:Name="CameraButtonLandscape" Path="photo_camera_button.png"  &#13;
                    TintOn="false" WidthRequest="50"  &#13;
                    HeightRequest="50"  &#13;
                    HorizontalOptions="Center" VerticalOptions="Center"  &#13;
                    Grid.Row="2" Grid.Column="0"&gt; &#13;
                &lt;controls:CustomImage.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleShutter"/&gt; &#13;
                &lt;/controls:CustomImage.GestureRecognizers&gt; &#13;
            &lt;/controls:CustomImage&gt; &#13;
 &#13;
            &lt;Label x:Name="FlashLabelLandscape"  &#13;
                    Text="{Binding IsFlashOn, Converter={StaticResource boolToStringConverter}, ConverterParameter='On, Off'}"  &#13;
                    TextColor="#0ca6df" &#13;
                    XAlign="Center" YAlign="Start" Grid.Row="1" Grid.Column="0"&gt; &#13;
                &lt;Label.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleFlash"/&gt; &#13;
                &lt;/Label.GestureRecognizers&gt; &#13;
            &lt;/Label&gt; &#13;
 &#13;
            &lt;controls:CustomImage x:Name="FlashImageLandscape" Path="photo_light.png" &#13;
                    Margin="0, 10, 0, 0" HorizontalOptions="Center"  &#13;
                    TintOn="false" WidthRequest="30"  &#13;
                    HeightRequest="30" &#13;
                    Grid.Row="0" Grid.Column="0"&gt; &#13;
                &lt;controls:CustomImage.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleFlash"/&gt; &#13;
                &lt;/controls:CustomImage.GestureRecognizers&gt; &#13;
            &lt;/controls:CustomImage&gt; &#13;
        &lt;/Grid&gt; &#13;
</pre><p>The following image shows the <code class="literal">CameraPage</code> in landscape:</p><div class="mediaobject"><img src="graphics/image_08_007-1.jpg" alt="Building the CameraPage"/></div><p>The last element to add is another <code class="literal">Grid</code> that will appear when we take a photo:</p><div class="mediaobject"><img src="graphics/image_08_008.jpg" alt="Building the CameraPage"/></div><pre class="programlisting">        &lt;Grid x:Name="PhotoEditLayout" IsEnabled="{Binding PhotoEditOn}" BackgroundColor="White"  &#13;
                Opacity="{Binding PhotoEditOn, Converter={StaticResource boolToPartialConverter}, ConverterParameter='1, 0'}"  &#13;
                RowSpacing="0" Grid.Row="0" Grid.RowSpan="7" Grid.Column="0" Grid.ColumnSpan="6"&gt; &#13;
            &lt;Grid.RowDefinitions&gt; &#13;
                &lt;RowDefinition Height="*"/&gt; &#13;
                &lt;RowDefinition Height="60"/&gt; &#13;
            &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
            &lt;Grid.ColumnDefinitions&gt; &#13;
                &lt;ColumnDefinition Width="10"/&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
                &lt;ColumnDefinition Width="10"/&gt; &#13;
            &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
            &lt;Image x:Name="PhotoToEdit"  &#13;
                Source="{Binding PhotoData, Converter={StaticResource byteArrayToImageSourceConverter}}"  &#13;
                Aspect="AspectFit"  &#13;
                BackgroundColor="White"  &#13;
                IsOpaque="true" &#13;
                Grid.Row="0" Grid.RowSpan="2" Grid.Column="0" Grid.ColumnSpan="5" /&gt; &#13;
 &#13;
            &lt;BoxView BackgroundColor="Black" Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="5"/&gt; &#13;
             &#13;
            &lt;controls:CustomImage x:Name="TrashImage" Path="photo_trash.png"  &#13;
                    TintColorString="#FFFFFF" TintOn="true" HorizontalOptions="Center"  &#13;
                    WidthRequest="40" HeightRequest="40" &#13;
                    Grid.Row="1" Grid.Column="1"&gt; &#13;
                &lt;controls:CustomImage.GestureRecognizers&gt; &#13;
                    &lt;TapGestureRecognizer Tapped="HandleDelete"/&gt; &#13;
                &lt;/controls:CustomImage.GestureRecognizers&gt; &#13;
            &lt;/controls:CustomImage&gt; &#13;
        &lt;/Grid&gt; &#13;
</pre><p>The <code class="literal">Grid</code> contains the <code class="literal">Image</code> that will be bound to the <code class="literal">PhotoData</code> property on the view-model. This is where we use the <code class="literal">ByteArrayToImageSourceConverter</code>. Whenever the byte array is changed and the <code class="literal">OnPropertyChanged</code> method is called, a new image will be created from the byte array in the view-model. There is also a <code class="literal">CustomImage</code> that will add another button for closing the screen, deleting the image data, and returning to the camera to take another photo.</p></div>
<div class="section" title="Adding native orientation events"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec146"/>Adding native orientation events</h1></div></div></div><p>Our next step is to add the notifications that are going to fire every time an orientation occurs. These events will come from the native side, so in order to have these pass down to our <code class="literal">Xamarin.Forms</code> project, we are going to use the static events on the <code class="literal">OrientationPage</code>.</p><p>Let's start with the iOS project. Open the <code class="literal">AppDelegate.cs</code> file and add the following function:</p><pre class="programlisting">        public override void DidChangeStatusBarOrientation(UIApplication application, UIInterfaceOrientation oldStatusBarOrientation) &#13;
        { &#13;
            // change listview opacity based upon orientation &#13;
            switch (UIApplication.SharedApplication.StatusBarOrientation) &#13;
            { &#13;
                case UIInterfaceOrientation.Portrait: &#13;
                case UIInterfaceOrientation.PortraitUpsideDown: &#13;
                    OrientationPage.NotifyOrientationChange(Orientation.Portrait); &#13;
                    break; &#13;
                case UIInterfaceOrientation.LandscapeLeft: &#13;
                    OrientationPage.NotifyOrientationChange(Orientation.LandscapeLeft); &#13;
                    break; &#13;
                case UIInterfaceOrientation.LandscapeRight: &#13;
                    OrientationPage.NotifyOrientationChange(Orientation.LandscapeRight); &#13;
                    break; &#13;
            } &#13;
        }  &#13;
</pre><p>The <code class="literal">DidChangeStatusBarOrientation</code> function is contained in all <code class="literal">AppDelegate</code> objects. When we override this, we reference the exact orientation in the <code class="literal">UIApplication.SharedApplication.StatusBarOrientation</code> property of the <code class="literal">AppDelegate</code>. Every time an orientation occurs, this method will be called and we will then call the static method <code class="literal">NotifyOrientationChange</code> on the <code class="literal">OrientationPage</code> to fire the event back to the <code class="literal">Xamarin.Forms</code> page.</p><p>Let's do the same for Android. Open the <code class="literal">MainActivity.cs</code> file and add the following:</p><pre class="programlisting">public override void OnConfigurationChanged(Android.Content.Res.Configuration newConfig) &#13;
        { &#13;
            base.OnConfigurationChanged(newConfig); &#13;
 &#13;
            switch (newConfig.Orientation) &#13;
            { &#13;
                case Android.Content.Res.Orientation.Portrait: &#13;
                    OrientationPage.NotifyOrientationChange(Portable.Enums.Orientation.Portrait); &#13;
                    break; &#13;
                case Android.Content.Res.Orientation.Landscape: &#13;
                    OrientationPage.NotifyOrientationChange(Portable.Enums.Orientation.LandscapeLeft); &#13;
                    break; &#13;
            } &#13;
        }  &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip130"/>Tip</h3><p>Unfortunately for Android, we can only gather whether the orientation is in landscape or portrait. IOS has the ability to determine whether we are in landscape left or landscape right.</p></div></div><p>Like the <code class="literal">DidChangeStatusBarOrientation</code> function, the Android <code class="literal">OnConfigurationChanged</code> method will be called whenever the orientation changes. We use a switch statement again to call the static method on the <code class="literal">OrientationPage</code>.</p><p>Let's now add the logic behind the <code class="literal">CameraPage</code>. Here we will be responding to the native orientation events when they occur.</p><p>Open the <code class="literal">CameraPage.xaml.cs</code> file and implement the private properties:</p><pre class="programlisting">public partial class CameraPage : ExtendedContentPage, INavigableXamarinFormsPage &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private float CAMERA_BUTTON_CONTAINER_WIDTH = 70f; &#13;
 &#13;
        private CameraPageViewModel _model; &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><p>We use the <code class="literal">CAMERA_BUTTON_CONTAINER_WIDTH</code> property when we render the camera stream on iOS, to make sure the stream bounds do not render behind the button container.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip131"/>Tip</h3><p>When the camera is rendered for iOS, we have to reduce the render bound width by a certain amount to make sure that the camera bounds don't render behind the button container. Every time the orientation changes, we will use this value to reduce the width of the render bounds.</p></div></div><p>We also have the <code class="literal">CameraPageViewModel</code> to keep locally when we retrieve it from the IoC container. Let's add the constructor as follows:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public CameraPage(CameraPageViewModel model) : base(model) &#13;
        { &#13;
            BindingContext = model; &#13;
            _model = model; &#13;
 &#13;
            InitializeComponent(); &#13;
 &#13;
            Appearing += HandleAppearing; &#13;
            Disappearing += HandleDisappearing; &#13;
 &#13;
            CameraView.Photo += HandlePictureTaken; &#13;
            CameraView.AvailabilityChange += HandleCameraAvailability; &#13;
            CameraView.Loading += HandleLoading; &#13;
            CameraView.Busy += HandleBusy; &#13;
 &#13;
            FocusView.TouchFocus += HandleFocusChange; &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Here we retrieve the <code class="literal">CameraPageViewModel</code> from the IoC container. We also register event functions when the page appears and disappears. We also register event functions on the <code class="literal">CameraView</code> when we take a photo, when the camera initialization occurs, when the camera is loading, and when the camera is busy. Then, we register one event for the <code class="literal">TouchFocus</code> event on the <code class="literal">FocusView</code>. Every time a new point (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) is received, we pass this to the <code class="literal">CameraView</code> to perform a focus.</p><p>Let's add the <code class="literal">EventHandler</code> functions for page appearing and disappearing. Here we will register and deregister to the orientation <code class="literal">OrientationHandler</code> event:</p><pre class="programlisting">        private void HandleDisappearing(object sender, EventArgs e) &#13;
        { &#13;
            OrientationHandler -= HandleOrientationChange; &#13;
 &#13;
            _model.OnDisappear(); &#13;
        } &#13;
 &#13;
        private void HandleAppearing(object sender, EventArgs e) &#13;
        { &#13;
            OrientationHandler += HandleOrientationChange; &#13;
 &#13;
            _model.OnAppear(); &#13;
        } &#13;
</pre><p>Let's add the <code class="literal">HandleOrientationChange</code> method for updating the button container width by resizing the width of the <code class="literal">ColumnDefinition</code>. After we resize the <code class="literal">ColumnDefinition</code>, we then call <code class="literal">Reset</code> on the <code class="literal">FocusView</code> object; if the camera is ready to take a photo, we center the focus point of the camera to the middle of the screen. Then call the <code class="literal">NotifyOrientationChange</code> on the <code class="literal">CameraView</code> to update the renderer camera stream bounds and rotation:</p><pre class="programlisting">public void HandleOrientationChange(object sender, Orientation arg) &#13;
        { &#13;
            FocusView.Orientation = CameraView.Orientation = OrientationPage.PageOrientation = _model.PageOrientation = arg; &#13;
 &#13;
            switch (PageOrientation) &#13;
            { &#13;
                case Orientation.LandscapeLeft: &#13;
                case Orientation.LandscapeRight: &#13;
                    MainLayout.ColumnDefinitions[5].Width = new GridLength(CAMERA_BUTTON_CONTAINER_WIDTH,  &#13;
                                                                           GridUnitType.Absolute); &#13;
                    break; &#13;
                case Orientation.Portrait: &#13;
                    MainLayout.ColumnDefinitions[4].Width = new GridLength(CAMERA_BUTTON_CONTAINER_WIDTH,  &#13;
                                                                           GridUnitType.Absolute); &#13;
                    break; &#13;
            } &#13;
 &#13;
            if (_model.CanCapture) &#13;
            { &#13;
                FocusView.Reset(); &#13;
            } &#13;
 &#13;
            CameraView.NotifyOrientationChange(arg); &#13;
        } &#13;
</pre><p>Next, we have the <code class="literal">HandleBusy</code> and <code class="literal">HandleLoading</code> functions, which simply set the <code class="literal">CameraLoading</code> property on the view-model:</p><pre class="programlisting">        private void HandleBusy(object sender, bool e) &#13;
        { &#13;
            _model.CameraLoading = e; &#13;
        } &#13;
 &#13;
        private void HandleLoading(object sender, bool e) &#13;
        { &#13;
            _model.CameraLoading = e; &#13;
        } &#13;
</pre><p>Then add the <code class="literal">HandleShutter</code>, which will call the <code class="literal">NotifyShutter</code> method on the <code class="literal">CameraView</code>:</p><pre class="programlisting">public void HandleShutter(object sender, EventArgs args) &#13;
        { &#13;
            CameraView.NotifyShutter(); &#13;
        } &#13;
</pre><p>Then we have the <code class="literal">HandleFlash</code> function responsible for updating the <code class="literal">FlashOn</code> property of the view-model and calling the <code class="literal">NotifyFlash</code> method on the <code class="literal">CameraView</code>:</p><pre class="programlisting">        public void HandleFlash(object sender, EventArgs args) &#13;
        { &#13;
            _model.IsFlashOn = !_model.IsFlashOn; &#13;
            CameraView.NotifyFlash(_model.IsFlashOn); &#13;
        } &#13;
</pre><p>The <code class="literal">HandlePictureTaken</code> function is called every time the camera button is touched and data is received from the native camera. We then pass the byte array back to the view-model using the <code class="literal">AddPhoto</code> method:</p><pre class="programlisting">        public void HandlePictureTaken(object sender, byte[] data) &#13;
        { &#13;
            if (_model.CanCapture) &#13;
            { &#13;
                _model.AddPhoto(data); &#13;
            } &#13;
 &#13;
        } &#13;
</pre><p>Next we have the <code class="literal">HandleCameraAvailability</code> method, which is called when the native camera availability status changes. If the camera is available, we the set the view-model properties, assign the starting orientation, and set up <code class="literal">IsVisible</code> bindings on the camera button containers to the <code class="literal">PageOrientation</code> property of the view-model.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip132"/>Tip</h3><p>We must set up the <code class="literal">IsVisible</code> bindings after the camera has become available because a layout pass is not called on items that are invisible when the page is loaded. We need the height and width to be set on these items even if the items are invisible.</p></div></div><pre class="programlisting">        public void HandleCameraAvailability(object sender, bool available) &#13;
        { &#13;
            _model.CanCapture = available; &#13;
 &#13;
            if (available) &#13;
            { &#13;
                _model.CameraLoading = false; &#13;
 &#13;
                // wait until camera is available before animating focus target, we have to invoke on UI thread as this is run asynchronously &#13;
                Device.BeginInvokeOnMainThread(() =&gt; &#13;
                    { &#13;
                    // set starting list opacity based on orientation &#13;
                    var orientation = (Height &gt; Width) ? Orientation.Portrait : Orientation.LandscapeLeft; &#13;
                    // set starting orientation &#13;
                    HandleOrientationChange(null, orientation); &#13;
 &#13;
                    // these bindings are created after page intitalizes &#13;
                    PhotoEditLayout.SetBinding(VisualElement.IsVisibleProperty, new Binding("PhotoEditOn")); &#13;
 &#13;
                    // camera button layouts &#13;
                    CameraButtonContainerLandscape.SetBinding(VisualElement.OpacityProperty, new Binding("PageOrientation", converter: new OrientationToDoubleConverter(), converterParameter: "1, 1")); &#13;
                        CameraButtonContainerLandscape.SetBinding(VisualElement.IsVisibleProperty, new Binding("PageOrientation", converter: new OrientationToBoolConverter(), converterParameter: "true, false")); &#13;
                        CameraButtonContainerPortrait.SetBinding(VisualElement.OpacityProperty, new Binding("PageOrientation", converter: new OrientationToDoubleConverter(), converterParameter: "0, 1")); &#13;
                        CameraButtonContainerPortrait.SetBinding(VisualElement.IsVisibleProperty, new Binding("PageOrientation", converter: new OrientationToBoolConverter(), converterParameter: "false, true")); &#13;
 &#13;
                        FocusView.Reset(); &#13;
                }); &#13;
            }  &#13;
 &#13;
        }  &#13;
</pre><p>Now we must add the <code class="literal">OnNavigatedTo</code> method. Here we will set a new binding on the <code class="literal">IsVisible</code> property of the <code class="literal">LoadingView</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note133"/>Note</h3><p>Remember, we must set the <code class="literal">IsVisible</code> binding after the page has done the layout so that the <code class="literal">LoadingView</code> bounds are set correctly according to the <code class="literal">Grid</code>.</p></div></div><p>We must also call the <code class="literal">SetFocusPoints</code> on the <code class="literal">FocusView</code> to set the starting focus points in both landscape and portrait. These starting points will be calculated from the height and width properties to get the center of the screen. Then we call <code class="literal">NotifyOpenCamera</code> to begin the process on the native camera to initialize it and open the camera. On only for iOS do we call the <code class="literal">NotifyWidths</code> method, so the widths of the button container are passed to the iOS native camera class:</p><pre class="programlisting">        public void OnNavigatedTo(IDictionary&lt;string, object&gt; navigationParameters) &#13;
        { &#13;
            _model.CameraLoading = false; &#13;
 &#13;
            LoadingView.SetBinding(VisualElement.IsVisibleProperty, new Binding("CameraLoading")); &#13;
 &#13;
            _model.CanCapture = CameraView.CameraAvailable; &#13;
 &#13;
            switch (PageOrientation) &#13;
            { &#13;
                case Orientation.Portrait: &#13;
                    FocusView.SetFocusPoints(new Point(Width / 2, Height / 2),  &#13;
                                             new Point(Height / 2, Width / 2)); &#13;
                    break; &#13;
                case Orientation.LandscapeLeft: &#13;
                case Orientation.LandscapeRight: &#13;
                    FocusView.SetFocusPoints(new Point(Height / 2, Width / 2),  &#13;
                                             new Point(Width / 2, Height / 2)); &#13;
                    break; &#13;
            } &#13;
 &#13;
            CameraView.NotifyOpenCamera(true); &#13;
 &#13;
#if __IOS__ &#13;
                CameraView.NotifyWidths (CAMERA_BUTTON_CONTAINER_WIDTH); &#13;
#endif &#13;
 &#13;
            this.Show(navigationParameters); &#13;
        } &#13;
</pre><p>Lastly, we have the <code class="literal">HandleDelete</code> method for removing the photo edit view and clearing the image bytes to free memory:</p><pre class="programlisting">        public void HandleDelete(object sender, EventArgs args) &#13;
        { &#13;
            _model.ResetEditPhoto(); &#13;
        } &#13;
 &#13;
        #endregion &#13;
    }  &#13;
</pre><p>Excellent! We now have implemented our entire <code class="literal">CameraPage</code> and native camera implementation for iOS and Android.</p></div>
<div class="section" title="Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec147"/>Challenge</h1></div></div></div><p>We have built almost everything in the <code class="literal">Camera.Portable</code> and <code class="literal">Camera</code> projects, but there are still pieces missing. Here is another challenge. Fill in the missing pieces of the solution and get it compiling The remaining files are the exact same from all our other <code class="literal">Xamarin.Forms</code> solutions, but now it is your turn to finish off the project.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip134"/>Tip</h3><p>To see the finished version, refer to <a class="ulink" href="https://github.com/flusharcade/chapter8-camera">https://github.com/flusharcade/chapter8-camera</a>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec148"/>Summary</h1></div></div></div><p>In this chapter, we built complete control over the native camera hardware for iOS and Android. We looked at implementing Grid changes using Converters, and built <code class="literal">CustomRenderers</code> for accessing native tinting features and touch events. We also created event triggers for buttons and <code class="literal">PlatformEffects</code> for creating shadow on a Label on the <code class="literal">MainPage</code>.</p><p>Congratulations! We have made it to the end of our Xamarin journey.</p></div></body></html>