- en: What Next?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: In this book, we have discovered the MVVM architectural pattern and explored
    the process of developing a WPF application, while taking advantage of the pattern's
    **Separation of Concerns** and adhering to its principles. We investigated a number
    of different ways of communicating between the various application layers and
    structuring our code base.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们发现了MVVM架构模式，并探讨了利用该模式的优势开发WPF应用程序的过程，同时遵循其**关注点分离**的原则。我们调查了各种在不同应用程序层之间进行通信和构建我们的代码库的方法。
- en: Importantly, we considered a variety of ways of debugging our WPF applications
    and tracking down our coding problems. In particular, we revealed some tips and
    tricks to help us to identify the causes of our data binding errors. In addition,
    we also learned how viewing trace information can help us to detect problems,
    even after our applications have been deployed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们考虑了多种调试我们的WPF应用程序和追踪编码问题的方法。特别是，我们揭示了一些技巧和窍门，帮助我们识别数据绑定错误的根源。此外，我们还学习了如何通过查看跟踪信息来帮助我们检测问题，即使是在我们的应用程序部署之后。
- en: We moved on to investigate the benefit of utilizing an application framework
    and began designing and developing our own. We structured it in a way that did
    not tie our framework to any particular feature or technology and experimented
    with a variety of ways to encapsulate our required functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续研究利用应用程序框架的好处，并开始设计和开发我们自己的框架。我们以不将我们的框架绑定到任何特定功能或技术的方式构建它，并尝试了多种封装所需功能的方法。
- en: We devoted a whole chapter to the essential art of data binding and took a detailed
    look at the creation of Dependency Properties and Attached Properties. We looked
    at setting Dependency Property metadata and were introduced to the crucial Dependency
    Property Setting Precedence List. We then covered both standard and hierarchical
    data templates and studied some interesting data binding examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专门用了一章来探讨数据绑定这一基本艺术，详细研究了依赖属性和附加属性的创建。我们研究了设置依赖属性元数据，并介绍了关键的依赖属性设置优先级列表。然后我们涵盖了标准和层次数据模板，并研究了几个有趣的数据绑定示例。
- en: Investigating the rich inheritance hierarchy of the built-in WPF controls enabled
    us to see how their functionality is built up from each successive base class
    in the hierarchy. This, in turn, enabled us to see that some controls are better
    to use in some situations than others. We also found out how to customize the
    built-in controls and considered how best to make our own controls.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 调查内置WPF控件丰富的继承层次结构使我们能够看到它们的功能是如何从层次结构中的每个后续基类构建起来的。这反过来又使我们能够看到在某些情况下某些控件比其他控件更好用。我们还了解了如何自定义内置控件，并考虑了如何最好地创建我们自己的控件。
- en: While the animation possibilities in a WPF application are practically endless,
    we investigated the more usable options, primarily focusing on the syntax used
    in XAML. We then added animation functionality directly into our application framework,
    where it could be used with little effort on the part of developers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在WPF应用程序中动画的可能性几乎是无限的，但我们调查了更实用的选项，主要关注XAML中使用的语法。然后我们直接在我们的应用程序框架中添加了动画功能，这样开发者就可以轻松使用。
- en: After turning our attention to the look of our applications, we investigated
    a number of techniques, such as borderless windows and adding shadows and glowing
    effects to more advanced methods to make our application stand out from the crowd.
    We also incorporated animations into our everyday controls, in order to bring
    about a sense of exclusivity to our applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在将注意力转向我们应用程序的外观之后，我们调查了多种技术，例如无边框窗口以及为更高级的方法添加阴影和发光效果，以使我们的应用程序在众多应用程序中脱颖而出。我们还把动画融入我们的日常控件中，以便为我们的应用程序带来一种独特感。
- en: We thoroughly investigated the data validation options that the .NET Framework
    offers us, primarily concentrating on the two available validation interfaces,
    and exploring a number of different ways of implementing them. We probed advanced
    techniques, such as multilevel validation and using data annotation attributes,
    and then added a complete validation system into our application framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们彻底调查了.NET Framework为我们提供的数据验证选项，主要集中在前两个可用的验证接口，并探索了多种实现方式。我们探讨了高级技术，如多级验证和使用数据注释属性，然后在我们的应用程序框架中添加了一个完整的验证系统。
- en: We further extended our application framework with an asynchronous data operation
    system that was combined with a complete user feedback component, including an
    animated feedback display mechanism. We continued by investigating how we can
    provide in-application help and user preferences and implement work-heavy functions
    to save users time and effort.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步扩展了我们的应用程序框架，加入了一个异步数据操作系统，该系统结合了一个完整的用户反馈组件，包括一个动画反馈显示机制。我们继续研究如何提供应用程序内的帮助和用户偏好，并实现耗时功能以节省用户的时间和精力。
- en: We also explored a number of options that we can use to increase the performance
    of our WPF applications, from declaring our resources more efficiently to using
    lighter weight controls and more efficient methods of rendering drawings, images,
    and text. We saw more performant methods of data binding and discovered the importance
    of detaching event handlers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探索了多种可以用来提高我们的WPF应用程序性能的选项，从更有效地声明资源到使用更轻量级的控件和更高效的渲染绘图、图像和文本的方法。我们看到了更高效的数据绑定方法，并发现了解除事件处理程序的重要性。
- en: Finally, we investigated the last task in any professional application's development,
    its deployment. We looked at a number of alternative methods but primarily focused
    on the most popular ClickOnce technology. We investigated how ClickOnce deployments
    are done and how we can safely store and access data in isolated storage. We ended
    with a number of ways to access the various application versions available to
    us in .NET.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了任何专业应用程序开发中的最后一个任务，即部署。我们考虑了多种替代方法，但主要关注最流行的ClickOnce技术。我们研究了ClickOnce部署是如何进行的，以及我们如何在隔离存储中安全地存储和访问数据。我们以多种方式结束，这些方式可以让我们访问.NET中可用的各种应用程序版本。
- en: Overall, we've covered a plethora of information that, together, will enable
    us to create efficient, visually appealing, highly usable, and highly productive
    applications in WPF. What's more, we've now got our own application framework
    that we can reuse for each new application that we create. *So, what's next?*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们涵盖了大量的信息，这些信息共同将使我们能够创建高效、视觉上吸引人、高度可用和高度生产力的WPF应用程序。更重要的是，我们现在有了自己的应用程序框架，我们可以为每个新创建的应用程序重复使用它。*那么，接下来是什么？*
- en: Turning your attention to future projects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将注意力转向未来的项目
- en: You could apply the concepts and ideas from this book to other areas and continue
    to experiment and explore their effect in these new areas. For example, we've
    learned about `Adorner` objects, so you could use that new-found knowledge to
    implement some visual feedback for the common drag and drop functionality in the
    main window's adorner layer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这本书中的概念和想法应用到其他领域，并继续在这些新领域中实验和探索它们的效果。例如，我们学习了关于`Adorner`对象的知识，因此你可以利用这一新发现的知识在主窗口的adorner层中实现一些视觉反馈，用于常见的拖放功能。
- en: You could then further extend this idea, using what you've discovered about
    Attached Properties, and completely encapsulate this drag and drop functionality,
    enabling the developers that utilize your application framework to make use of
    this feature in a property-based manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以进一步扩展这个想法，使用你关于附加属性所发现的知识，完全封装这个拖放功能，使利用你的应用程序框架的开发者能够以属性方式使用这个功能。
- en: For example, you could create a `DragDropProperties` class that declared Attached
    Properties, such as `IsDragSource`, `IsDragTarget`, `DragEffects`, `DragDropType`,
    and `DropCommand`, and it could be extended by your relevant Attached Property
    classes, such as a `ListBoxProperties` class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个`DragDropProperties`类，声明附加属性，如`IsDragSource`、`IsDragTarget`、`DragEffects`、`DragDropType`和`DropCommand`，并且它可以由你的相关附加属性类扩展，例如`ListBoxProperties`类。
- en: You could then declare a `BaseDragDropManager` class to be used in the `DragDropProperties`
    class, that stitches everything together, by attaching and removing the appropriate
    event handlers, starting the drag and drop procedure, updating the cursor via
    the drag and drop effects as it moves across the screen, and executing the `ICommand`
    object assigned to the `DropCommand` Property.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`DragDropProperties`类中声明一个`BaseDragDropManager`类，用于将一切连接起来，通过附加和移除适当的事件处理程序，启动拖放过程，通过拖放效果更新光标，并在光标在屏幕上移动时执行分配给`DropCommand`属性的`ICommand`对象。
- en: This leads to a further area that could be extended. Not only can we handle
    UI events in Attached Properties, but we can also combine them to perform more
    complex functionality. For example, let's say that we have an Attached Property
    of type `string`, named `Label`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个可以进一步扩展的领域。我们不仅可以在附加属性中处理UI事件，还可以将它们组合起来执行更复杂的功能。例如，假设我们有一个类型为`string`的附加属性，名为`Label`。
- en: 'When this property is set, it could apply a particular `ControlTemplate` element
    from resources to the current `TextBox` object''s `Template` property. This template
    could display the text from this property in a secondary text element and therefore
    act as an internal label. When the `TextBox` object has a value, the label text
    element could be hidden via an `IValueConverter` implementation that extends our
    `BaseVisibilityConverter` class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当此属性被设置时，它可以将资源中的特定`ControlTemplate`元素应用到当前`TextBox`对象的`Template`属性。此模板可以显示此属性中的文本在一个次要文本元素中，因此充当内部标签。当`TextBox`对象有值时，标签文本元素可以通过扩展我们的`BaseVisibilityConverter`类的`IValueConverter`实现来隐藏：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As shown in the preceding example, we could then declare another Attached Property,
    named `LabelColor`, of type `Brush`, which specifies the color to be used by the
    `Label` Attached Property when it is set. Note that if the `LabelColor` property
    is not set, then it will either use its default value if it is set, or the value
    specified in the `FallbackValue` property.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们还可以声明另一个附加属性，名为`LabelColor`，类型为`Brush`，它指定了当设置`Label`附加属性时要使用的颜色。请注意，如果未设置`LabelColor`属性，则它将使用默认值，如果设置了，或者使用`FallbackValue`属性中指定的值。
- en: Improving our application framework
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的应用程序框架
- en: Another area that you can continue to work on is customizing our application
    framework further and adapting it to your individual requirements. With this in
    mind, you could continue to build up a complete collection of customized controls
    with a particular look and feel in an external resource file to use in all of
    your applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以继续在自定义应用程序框架方面进行工作，并使其适应你的个别需求。考虑到这一点，你可以在外部资源文件中构建一个完整的自定义控件集合，具有特定的外观和感觉，以便在所有应用程序中使用。
- en: There are also many other examples provided throughout this book that could
    be easily extended. For example, you could update our `DependencyManager` class
    to enable multiple concrete classes to be registered for each interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还提供了许多其他示例，这些示例可以轻松扩展。例如，你可以更新我们的`DependencyManager`类，以使每个接口可以注册多个具体类。
- en: 'Instead of using a `Dictionary<Type, Type>` object to store our registrations,
    you could define new custom objects. You could declare a `ConcreteImplementation`
    struct that has a `Type` property and an `object` array to hold any constructor
    input parameters that may be required for its initialization:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`Dictionary<Type, Type>`对象来存储我们的注册信息，你可以定义新的自定义对象。你可以声明一个具有`Type`属性和`object`数组以存储可能需要的任何构造函数输入参数的`ConcreteImplementation`结构体：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You could then declare a `DependencyRegistration` class that you could use
    to pair the interface type with the collection of concrete implementations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个`DependencyRegistration`类，用于将接口类型与具体实现集合配对：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our `DependencyManager` class, you could change the type of the `registeredDependencies`
    field to a collection of this new `DependencyRegistration` type. The current `Register`
    and `Resolve` methods could then also be updated to use this new collection type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`DependencyManager`类中，你可以将`registeredDependencies`字段的类型更改为`DependencyRegistration`类型集合。然后，当前的`Register`和`Resolve`方法也可以更新为使用此新集合类型。
- en: 'Alternatively, you could include other common functionality that is contained
    within popular Dependency Injection and Inversion of Control containers, such
    as the automatic registering of concrete classes to interfaces at the assembly
    level. For this, you could use some basic reflection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以包含其他常见的功能，这些功能包含在流行的依赖注入和控制反转容器中，例如在程序集级别自动注册具体类到接口。为此，你可以使用一些基本的反射：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method first accesses the assembly that contains the generic type parameter
    and then gets a collection of the interfaces in that assembly. It then iterates
    through the interface collection and finds a collection of classes that implements
    each interface, instantiating a `ConcreteImplementation` element with each. Each
    match is added into the `registeredDependencies` collection with its relating
    interface type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先访问包含泛型类型参数的组件，然后获取该组件中的接口集合。然后它遍历接口集合，找到实现每个接口的类集合，并为每个匹配项实例化一个`ConcreteImplementation`元素。每个匹配项都被添加到`registeredDependencies`集合中，并与其相关的接口类型相关联。
- en: 'In this way, you could pass any interface type from our `Models`, `Managers`,
    and `ViewModels` projects to automatically register all of the interfaces and
    concrete classes found inside their assemblies. There is a clear benefit to doing
    this in larger applications, as it will mean that you don''t have to manually
    register each type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你可以将我们的`Models`、`Managers`和`ViewModels`项目中的任何接口类型传递过去，以自动注册它们组件中找到的所有接口和具体类。在更大的应用程序中这样做有明显的优势，因为它意味着你不必手动注册每个类型：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Additionally, you could declare another method that registers all types found
    in the assembly of the type specified by the generic type parameter `T`, where
    matches of implemented interfaces are found. This could be used during testing,
    so that you could just pass any type from the mock projects during testing, again
    saving time and effort:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以声明另一个方法，用于注册由泛型类型参数`T`指定的类型的组件中找到的所有类型，其中找到实现接口的匹配项。这可以在测试期间使用，这样你就可以在测试期间只需传递模拟项目中的任何类型，再次节省时间和精力：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As with all serious development projects, there is a need to test the code that
    makes up the code base. Doing so obviously helps to reduce the number of bugs
    in the application, but also alerts us when existing functionality has been broken,
    while adding new code. They also provide a safety net for refactoring, allowing
    us to continually improve our designs, while ensuring that existing functionality
    is not broken.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有严肃的开发项目一样，我们需要测试构成代码库的代码。这样做显然有助于减少应用程序中的错误数量，但也会在添加新代码的同时提醒我们现有功能是否被破坏。它们还为重构提供了一个安全网，使我们能够持续改进我们的设计，同时确保现有功能不会被破坏。
- en: Therefore, one area that you could improve in the application would be to implement
    a full test suite. This book has explained a number of ways for us to swap out
    code during testing and this pattern can be easily extended. If a manager class
    uses some sort of resource that cannot be used during testing, then you can create
    an interface for it, add a mock class, and use the `DependencyManager` class to
    instantiate the relevant concrete implementation during runtime and testing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在应用程序中改进的一个领域是实施一个完整的测试套件。这本书已经解释了在测试期间替换代码的多种方法，并且这种模式可以很容易地扩展。如果一个管理类使用某种在测试期间不能使用的资源，那么你可以为它创建一个接口，添加一个模拟类，并在运行时和测试期间使用`DependencyManager`类来实例化相关的具体实现。
- en: Another area from the book that could be extended relates to our `AnimatedStackPanel`
    class. You could extract the reusable properties and animation code from this
    class to an `AnimatedPanel` base class so that it could service several different
    types of animated panels.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 书中可以扩展的另一个领域与我们的`AnimatedStackPanel`类有关。你可以从这个类中提取可重用的属性和动画代码到一个`AnimatedPanel`基类，以便它可以服务于多种不同类型的动画面板。
- en: As suggested in [Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml), *Mastering
    Practical Animations*, you could then further extend the base class by exposing
    additional animation properties so that users of your panel could have more control
    over the animations that it provides. For example, you could add alignment, direction,
    duration, and/or animation type properties to enable users of your framework to
    use a wide variety of animation options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml)《精通实用动画》中建议的，你可以进一步扩展基类，通过公开额外的动画属性，使用户能够对提供的动画有更多的控制。例如，你可以添加对齐、方向、持续时间以及/或动画类型属性，以便框架的用户能够使用广泛的动画选项。
- en: These properties could be divided between the entry and exit animations, to
    enable independent control over them. By providing a wide variety of these additional
    properties in a base class, you can vastly simplify the process of adding new
    animated panels.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可以在进入和退出动画之间分配，以实现对其的独立控制。通过在基类中提供广泛的这些附加属性，你可以极大地简化添加新动画面板的过程。
- en: For example, you could add a new `AnimatedWrapPanel`, or perhaps an `AnimatedColumnPanel`,
    by simply extending the base class, and only have to implement the two `MeasureOverride`
    and `ArrangeOverride` methods in the new panel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过简单地扩展基类来添加一个新的`AnimatedWrapPanel`，或者可能是一个`AnimatedColumnPanel`，只需要在新面板中实现两个`MeasureOverride`和`ArrangeOverride`方法。
- en: Logging errors
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录错误
- en: In a number of places in the code examples in this book, you may have seen `Log
    error` comments. In general, it is not only good practice to log errors, but it
    can also help you to track down bugs and improve the overall user experience of
    the users of your applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码示例中，你可能在多个地方看到了`Log error`注释。一般来说，记录错误不仅是良好的实践，而且还可以帮助你追踪错误并提高你应用程序用户的整体用户体验。
- en: 'The easiest place to log errors to would be an `Errors` database and the minimum
    useful information fields that you''d want to store would include details of the
    current user, the time the error occurred, the exception message, the stack trace,
    and the assembly or area that it occurred in. This latter field can be found in
    the `Module` property of the exception''s `TargetSite` property:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记录错误最简单的地方是`Errors`数据库，你想要存储的最少有用信息字段应包括当前用户的详细信息、错误发生的时间、异常消息、堆栈跟踪以及它发生的组件或区域。这个字段可以在异常的`TargetSite`属性的`Module`属性中找到：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the use of the custom `FlattenInnerExceptions` method that also outputs
    the messages from any inner exceptions that the thrown exception may contain.
    One alternative to building your own `FlattenInnerExceptions` method would be
    to simply save the `ToString` output of the exception, which will also contain
    details of any inner exceptions that it may contain, although it will also contain
    stack trace and other information as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用自定义的`FlattenInnerExceptions`方法，该方法还会输出抛出异常可能包含的任何内部异常的消息。构建自己的`FlattenInnerExceptions`方法的另一个选择是简单地保存异常的`ToString`输出，这将包含任何内部异常的详细信息，尽管它也会包含堆栈跟踪和其他信息。
- en: Using online resources
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用在线资源
- en: As a final note, if you are not already familiar with the **Microsoft Docs**
    website, you really should acquaint yourself with it. It is maintained for the
    Microsoft developer community and includes everything from detailed APIs for their
    various languages, tutorial walkthroughs, and code examples, through to downloads
    of their software.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的注意事项，如果你还不熟悉**Microsoft Docs**网站，你真的应该熟悉一下。它是为Microsoft开发者社区维护的，包括从各种语言的详细API、教程演练和代码示例，到软件下载等所有内容。
- en: It can be found at [https://docs.microsoft.com](https://docs.microsoft.com) and
    should be the first place you look when questions arise over the members of the
    various classes in .NET. Should you not find your required information in their
    APIs, then you can ask questions in their forums and quickly receive answers from
    both the community and from Microsoft employees.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在[https://docs.microsoft.com](https://docs.microsoft.com)上找到，并且当出现关于.NET中各种类成员的问题时，应该是你首先查看的地方。如果你在它们的API中没有找到所需的信息，你可以在它们的论坛中提问，并迅速从社区和Microsoft员工那里获得答案。
- en: Another great developer resource is the **Stack Overflow** question and answer
    site for development professionals, where I still answer questions when I can
    find the time. It can be found online at [http://stackoverflow.com/](http://stackoverflow.com/)
    and with answers often provided by the community within seconds, it really is
    hard to beat and is one of the best development forums around.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个伟大的开发者资源是**Stack Overflow**开发专业人士问答网站，我在有时间的时候仍然会回答问题。它可以在[http://stackoverflow.com/](http://stackoverflow.com/)上找到，社区成员通常在几秒钟内提供答案，这确实很难超越，并且是周围最好的开发论坛之一。
- en: For further tutorials, check out the WPF Tutorial.net website at [https://www.wpftutorial.net/](https://www.wpftutorial.net/),
    where you can find a wealth of tutorials, from basic to complex. And for interesting
    and novel downloadable custom controls and additional tutorials, try visiting
    the WPF section of the Code Project website at [https://www.codeproject.com/kb/wpf/](https://www.codeproject.com/kb/wpf/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多教程，请访问[https://www.wpftutorial.net/](https://www.wpftutorial.net/)网站，在那里你可以找到从基础到复杂的丰富教程。对于有趣和创新的可下载自定义控件和额外教程，请尝试访问Code
    Project网站的WPF部分[https://www.codeproject.com/kb/wpf/](https://www.codeproject.com/kb/wpf/)。
- en: All that remains now is for me to wish you well with your future application
    development and your blossoming development careers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是祝愿你在未来的应用程序开发以及你蒸蒸日上的职业生涯中一切顺利。
