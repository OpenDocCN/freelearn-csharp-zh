<html><head></head><body>
		<div><h1 id="_idParaDest-166"><em class="italic"><a id="_idTextAnchor249"/>Chapter 8</em>: Using the Features and Services of ABP</h1>
			<p>ABP Framework is a full-stack application development framework, so it has many building blocks for every aspect of an enterprise solution. In the last three chapters, we have explored the fundamental services, data access infrastructure, and cross-cutting concern solutions provided by ABP Framework.</p>
			<p>In this final chapter of <em class="italic">Part 2</em>, <em class="italic">Fundamentals of ABP Framework</em>, we will continue with some ABP features frequently used in business applications, in the following order:</p>
			<ul>
				<li>Obtaining the current user</li>
				<li>Using the data filtering system</li>
				<li>Controlling the audit logging system</li>
				<li>Caching data</li>
				<li>Localizing the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>)</li>
			</ul>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor250"/>Technical requirements</h1>
			<p>If you want to follow and try the examples, you need to install an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>)/editor (such as Visual Studio) to build ASP.NET Core projects.</p>
			<p>You can download the code examples from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor251"/>Obtaining the current user</h1>
			<p>If your application<a id="_idIndexMarker498"/> requires user authentication for some functionalities, you generally need to get information about the current user. ABP provides the <code>ICurrentUser</code> service to obtain detailed information for the currently logged-in user. For web applications, the implementation of <code>ICurrentUser</code> is completely integrated with ASP.NET Core's authentication system, so you can easily get claims of the current user.</p>
			<p>See the following code block for simple usage of the <code>ICurrentUser</code> service:<a id="_idTextAnchor252"/></p>
			<pre>using System;
using Volo.Abp.DependencyInjection;
using Volo.Abp.Users;
namespace DemoApp
{
    public class MyService : ITransientDependency
    {
        private readonly ICurrentUser _currentUser;
        public MyService(ICurrentUser currentUser)
        {
            _currentUser = currentUser;
        }
        public void Demo()
        {
            Guid? userId = _currentUser.Id;
            string userName = _currentUser.UserName;
            string email = _currentUser.Email;
        }
    }
}</pre>
			<p>In this<a id="_idIndexMarker499"/> example, the <code>MyService</code> constructor injects the <code>ICurrentUser</code> service, then gets the unique <code>Id</code>, <code>Username</code>, and <code>Email</code> values of the current user.</p>
			<p>Here are the properties of the <code>ICurrentUser</code> interface:</p>
			<ul>
				<li><code>IsAuthenticated</code> (<code>bool</code>): Returns <code>true</code> if the <a id="_idIndexMarker500"/>current user has logged in (authenticated).</li>
				<li><code>Id</code> (<code>Guid?</code>): The <code>null</code> if the current user has not logged in.</li>
				<li><code>UserName</code> (<code>string</code>): Username of the current user. Returns <code>null</code> if the current user has not logged in.</li>
				<li><code>TenantId</code> (<code>Guid?</code>): Tenant ID of the current user. It is usable for multi-tenant applications. Returns <code>null</code> if the current user is not related to a tenant.</li>
				<li><code>Email</code> (<code>string</code>): Email address of the current user. Returns <code>null</code> if the current user has not logged in or has not set an email address.</li>
				<li><code>EmailVerified</code> (<code>bool</code>): Returns <code>true</code> if the current user's email address has been verified.</li>
				<li><code>PhoneNumber</code> (<code>string</code>): Phone number of the current user. Returns <code>null</code> if the current user has not logged in or has not set a phone number.</li>
				<li><code>PhoneNumberVerified</code> (<code>bool</code>): Returns <code>true</code> if the current user's phone number has been verified.</li>
				<li><code>Roles</code> (<code>string[]</code>): All roles of the current user as a string array.<p class="callout-heading">Injecting the ICurrentUser Service</p><p class="callout"><code>ICurrentUser</code> is a <a id="_idIndexMarker502"/>widely used service. Thus, some base ABP classes (such as <code>ApplicationService</code> and <code>AbpController</code>) provide it pre-injected. In these classes, you can directly use the <code>CurrentUser</code> property instead of manually injecting this service.</p></li>
			</ul>
			<p>ABP can work <a id="_idIndexMarker503"/>with any authentication provider since it works with the current claims that are provided by ASP.NET Core. <strong class="bold">Claims</strong> are key-value pairs issued on<a id="_idIndexMarker504"/> user login and stored in the authentication ticket. If you are using cookie-based authentication, they are stored in a cookie and sent to the server in every request. If you are using token-based authentication, they are sent by the client in every request, typically in<a id="_idIndexMarker505"/> the <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) header.</p>
			<p>The <code>ICurrentUser</code> service gets all the information from the current claims. If you want to query the current claims directly, you can use the <code>FindClaim</code>, <code>FindClaims</code>, and <code>GetAllClaims</code> methods. These methods are especially useful if you create your own custom claims.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor253"/>Defining custom claims</h2>
			<p>ABP provides an easy way to <a id="_idIndexMarker506"/>add your custom claims to the authentication ticket so that you can safely get these custom values on the next requests of the same user. You can implement the <code>IAbpClaimsPrincipalContributor</code> interface to add custom claims to the authentication ticket.</p>
			<p>In the following example, we are adding social security number information—a custom claim—to the authentication<a id="_idTextAnchor254"/> ticket:</p>
			<pre>public class SocialSecurityNumberClaimsPrincipalContributor 
    : IAbpClaimsPrincipalContributor, ITransientDependency
{
    public async Task ContributeAsync(
        AbpClaimsPrincipalContributorContext context)
    {
        ClaimsIdentity identity = context.ClaimsPrincipal
            .Identities.FirstOrDefault();
        var userId = identity?.FindUserId();
        if (userId.HasValue)
        {
            var userService = context.ServiceProvider
              .GetRequiredService&lt;IUserService&gt;();            
            var socialSecurityNumber = await userService
              .GetSocialSecurityNumberAsync(userId.Value);
            if (socialSecurityNumber != null)
            {
                identity.AddClaim(new Claim
                  ("SocialSecurityNumber",   
                    socialSecurityNumber));
            }
        }
    }
}</pre>
			<p>In this example, we<a id="_idIndexMarker507"/> are first getting the <code>ClaimsIdentity</code> and finding the current user's ID. Then, we are getting the social security number from <code>IUserService</code>, which is a custom service that you should develop yourself. You can get any service from the <code>ServiceProvider</code> to query the data that you need. Finally, we are adding a new <code>Claim</code> to the <code>identity</code>. <code>SocialSecurityNumberClaimsPrincipalContributor</code> is then used whenever a user logs in to the application.</p>
			<p>You can use custom claims to authorize the current user for specific business requirements, filter data, or just show on the UI. Notice that authentication ticket claims cannot be changed unless you invalidate the authentication ticket and force the user to re-authenticate, so do not store frequently changed data in the claims. You can use the caching system (which will be introduced in the <em class="italic">Caching data</em> section) if your purpose is to store user data where it can be quickly accessed later.</p>
			<p><code>ICurrentUser</code> is a core <a id="_idIndexMarker508"/>service that you frequently use in your application code. The next section introduces the data filtering system that seamlessly works most of the time.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor255"/>Using the data filtering system</h1>
			<p>Filtering data in a query is very common in database operations. If you are using <code>WHERE</code> clause. If you are using <code>Where</code> extension method in<a id="_idIndexMarker510"/> C#. While most of<a id="_idIndexMarker511"/> these filtering conditions vary in your queries, some expressions are applied to all queries you run if you implement patterns such as soft-delete and multi-tenancy.</p>
			<p>ABP automates the data filtering process to help you avoid repeating the same filtering logic everywhere in your application code.</p>
			<p>In this section, we will first see the pre-built data filters of ABP Framework, then learn how to disable the filters when we need to. Finally, we will see how to implement our custom data filters.</p>
			<p>We typically use simple interfaces to enable filtering for entities. ABP defines two pre-defined data filters to implement soft-delete and multi-tenancy patterns.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor256"/>The soft-delete data filter</h2>
			<p>If you use the<a id="_idIndexMarker512"/> soft-delete pattern for an entity, you never delete the entity in the database physically. Instead, you mark it as <em class="italic">deleted</em>.</p>
			<p>ABP defines the <code>ISoftDelete</code> interface to standardize the property to mark an entity as soft-delete. You can implement that interface for an entity, as shown in the following code block:</p>
			<pre>public class Order : AggregateRoot&lt;Guid&gt;, ISoftDelete
{
    public bool IsDeleted { get; set; }
    //...other properties
}</pre>
			<p>The <code>Order</code> entity, in this example, has an <code>IsDeleted</code> property that is defined by the <code>ISoftDelete</code> interface. Once you implement that interface, ABP automates the following tasks for you:</p>
			<ul>
				<li>When you delete an <a id="_idIndexMarker513"/>order, ABP identifies that the <code>Order</code> entity implements the soft-delete pattern, prevents the deletion, and sets <code>IsDeleted</code> to <code>true</code>. So, the order is not physically deleted in the database.</li>
				<li>When you query orders, ABP automatically filters deleted entities (by adding an <code>IsDeleted == false</code> condition to the query) to avoid accidentally retrieving deleted orders from the database.</li>
			</ul>
			<p>Data filtering is related to queries, so, the first task is not directly related to data filtering but is a supporting logic implemented by ABP Framework.</p>
			<p class="callout-heading">Data Filtering Limitations</p>
			<p class="callout">The data filtering<a id="_idIndexMarker514"/> automation only works when you use repositories or <code>DbContext</code> (for <code>DELETE</code> or <code>SELECT</code> command, you should handle this yourself because ABP cannot intercept your operation in such cases.</p>
			<p>The soft-delete filter is one of the built-in ABP data filters. Another built-in filter is for multi-tenancy.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor257"/>The multi-tenancy data filter</h2>
			<p>Multi-tenancy<a id="_idIndexMarker515"/> is <a id="_idIndexMarker516"/>a widely used pattern to share resources between tenants in <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>) solutions. It is essential to isolate the data between different tenants in <a id="_idIndexMarker517"/>a multi-tenant application. One tenant cannot read or write to another tenant's data, even if they are located in the same physical database.</p>
			<p>ABP has a complete multi-tenant system, which will be explained in detail in <a href="B17287_16_Epub_AM.xhtml#_idTextAnchor457"><em class="italic">Chapter 16</em></a>,<em class="italic"> Implementing Multi-Tenancy</em>. However, it would be good to mention the multi-tenancy filter here since it is related to the data filtering system.</p>
			<p>ABP defines the <code>IMultiTenant</code> interface to enable the multi-tenancy data filter for an entity. We can implement that interface for an entity, as shown in the following code block:</p>
			<pre>public class Order : AggregateRoot&lt;Guid&gt;, IMultiTenant
{
    public Guid? TenantId { get; set; }
    //...other properties
}</pre>
			<p>The <code>IMultiTenant</code> interface defines the <code>TenantId</code> property, as shown in this example. ABP uses <code>Guid</code> values for tenant IDs.</p>
			<p>Once we implement <a id="_idIndexMarker518"/>the <code>IMultiTenant</code> interface, ABP automatically filters all queries for the <code>Order</code> entity using the ID of the current tenant. The current tenant's ID is obtained from the <code>ICurrentTenant</code> service, which will be explained in <a href="B17287_16_Epub_AM.xhtml#_idTextAnchor457"><em class="italic">Chapter 16</em></a>, <em class="italic">Implementing Multi-Tenancy</em>.</p>
			<p class="callout-heading">Working with Multiple Data Filters</p>
			<p class="callout">Multiple data filters can<a id="_idIndexMarker519"/> be enabled for the same entity. For example, the <code>Order</code> entity defined in this section could implement both the <code>ISoftDelete</code> and <code>IMultiTenant</code> interfaces.</p>
			<p>As you see, implementing a data filter for an entity is pretty easy—just implement the interface related to the data filter. All data filters are enabled by default unless you explicitly disable them.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor258"/>Disabling a data filter</h2>
			<p>Disabling an automatic<a id="_idIndexMarker520"/> filter can be necessary in some cases—for example, you may want to disable the soft-delete filter to read deleted entities from the database, or maybe you want to allow the user to recover deleted entities. You may want to disable the multi-tenancy filter to query data from all the tenants in a multi-tenant system. For whatever reason, ABP provides an easy and safe way to disable a data filter.</p>
			<p>The following example<a id="_idIndexMarker521"/> shows how to get all the orders from the database, including deleted ones, by disabling the <code>ISoftDelete</code> data filter using t<a id="_idTextAnchor259"/>he <code>IDataFilter</code> service:</p>
			<pre>public class OrderService : ITransientDependency
{
    private readonly IRepository&lt;Order, Guid&gt; 
    _orderRepository;
    private readonly IdataFilter _dataFilter;
    public OrderService(
        Irepository&lt;Order, Guid&gt; orderRepository,
        IdataFilter dataFilter)
    {
        _orderRepository = orderRepository;
        _dataFilter = dataFilter;
    }
    public async Task&lt;List&lt;Order&gt;&gt; GetAllOrders()
    {
        using (_dataFilter.Disable&lt;IsoftDelete&gt;())
        {
            return await _orderRepository.GetListAsync();
        }
    }
}</pre>
			<p><code>OrderService</code>, in this example, injects the <code>Order</code> repository and the <code>IdataFilter</code> service. It then uses the <code>_dataFilter.Disable&lt;IsoftDelete&gt;()</code> expression to disable the soft-delete filter. In the <code>using</code> statement, the <a id="_idIndexMarker522"/>filter is disabled, and we can query deleted orders too.</p>
			<p class="callout-heading">Always Use a using Statement</p>
			<p class="callout">The <code>Disable</code> method returns a disposable object so that we can use it in a <code>using</code> statement. Once the <code>using</code> block ends, the filter automatically turns back to the previous state, which means that if it was enabled before that <code>using</code> block, it returns to the enabled state. If it was already disabled before the <code>using</code> statement, the <code>Disable</code> method does not affect it, and it remains disabled after the <code>using</code> statement. This system allows us to safely disable a filter without affecting any logic that calls the <code>GetAllOrders</code> method. It is always recommended to disable a filter in a <code>using</code> statement. </p>
			<p><code>IdataFilter</code> service provides two more methods:</p>
			<ul>
				<li><code>Enable&lt;Tfilter&gt;</code>: Enables a<a id="_idIndexMarker523"/> data filter. You can use this to temporarily enable a data filter in a scope in which the filter was disabled. It has no effect if the filter is already enabled. It is always recommended to enable a filter in a <code>using</code> statement, just as with the <code>Disable</code> method.</li>
				<li><code>IsEnabled&lt;Tfilter&gt;</code>: Returns <code>true</code> if the given filter is currently enabled. You generally do not need this method since <code>Enable</code> and <code>Disable</code> work as expected in both cases.</li>
			</ul>
			<p>We've learned how to use the <code>Disable</code> and <code>Enable</code> pre-built data filters. The next section shows how to create custom data filters.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor260"/>Defining custom data filters</h2>
			<p>Just as with <a id="_idIndexMarker524"/>pre-built data filters, you may want to define your own filters. A data filter is represented by an interface, so the first step is to define an interface for your filter.</p>
			<p>Assume that you want to archive your entities and automatically filter the archived data to not retrieve them into the application by default. For this example, we can define such a simple interface (you can define this in your <a id="_idTextAnchor261"/>domain layer), as follows:</p>
			<pre>public interface Iarchivable
{
    bool IsArchived { get; }
}</pre>
			<p>The <code>IsArchived</code> property will be used to filter the entities. Entities with <code>IsArchived</code> is <code>true</code> will be eliminated by default. Once we define such an interface, we can implement it for the entities that can be archived. <a id="_idTextAnchor262"/>See the following example:</p>
			<pre>public class Order : AggregateRoot&lt;Guid&gt;, Iarchivable
{
    public bool IsArchived { get; set; }
    //...other properties
}</pre>
			<p>The <code>Order</code> entity, in this example, implements the <code>Iarchivable</code> interface, which makes it possible to apply the data filter on that entity.</p>
			<p>Note that the <code>Iarchivable</code> interface doesn't define a setter for <code>IsArchived</code>, but the <code>Order</code> entity defines it. That is my design decision; we don't need to set <code>IsArchived</code> over the interface, but we need to set it on the entity.</p>
			<p>Since <a id="_idIndexMarker525"/>data filtering is done at the database provider level, custom filter implementation also depends on the database provider. This section will show how to implement the <code>Iarchivable</code> filter for the EF Core provider. If you are looking for MongoDB, please refer to <a id="_idIndexMarker526"/>ABP's documentation: <a href="https://docs.abp.io/en/abp/latest/Data-Filtering">https://docs.abp.io/en/abp/latest/Data-Filtering</a>.</p>
			<p>ABP uses EF Core's <code>DbContext</code> class.</p>
			<p>The first step is to define a property in your <code>DbContext</code> class that will be used in the f<a id="_idTextAnchor263"/>ilter expression, as follows:</p>
			<pre>protected bool IsArchiveFilterEnabled =&gt; DataFilter?.IsEnabled&lt;Iarchivable&gt;() ?? false;</pre>
			<p>This property directly uses the <code>IdataFilter</code> service to get the filter state. The <code>DataFilter</code> property comes from the base <code>AbpDbContext</code> class, and it can be <code>null</code> if the <code>DbContext</code> instance was not resolved from the <code>null</code> check.</p>
			<p>The next step is <a id="_idIndexMarker528"/>to override the <code>ShouldFilterEntity</code> method to decide if a given entity t<a id="_idTextAnchor264"/>ype should be filtered or not:</p>
			<pre>protected override bool ShouldFilterEntity&lt;Tentity&gt;(
    ImutableEntityType entityType)
{
    If (typeof(IArchivable) 
        .IsAssignableFrom(typeof(TEntity)))
    {
        return true;
    }
    
    return base.ShouldFilterEntity&lt;TEntity&gt;(entityType);
}</pre>
			<p>ABP Framework calls this method for each entity type in this <code>DbContext</code> class (it is called only once—the first time the <code>DbContext</code> class is used after an application start). If this method returns <code>true</code>, it enables the EF Core global filters for that entity. Here, I just checked if the given entity implemented the <code>IArchivable</code> interface and returned <code>true</code> in that case. Otherwise, call the <code>base</code> method so that it checks for other data filters.</p>
			<p><code>ShouldFilterEntity</code> only decides to enable filtering or not. The actual filtering logic should be<a id="_idIndexMarker529"/> implemented by overriding the<a id="_idTextAnchor265"/> <code>CreateFilterExpression</code> method:</p>
			<pre>protected override Expression&lt;Func&lt;TEntity, bool&gt;&gt; CreateFilterExpression&lt;TEntity&gt;()
{
    var expression = 
        base.CreateFilterExpression&lt;Tentity&gt;();
    if (typeof(Iarchivable)  
        .IsAssignableFrom(typeof(TEntity)))
    {
        Expression&lt;Func&lt;TEntity, bool&gt;&gt; archiveFilter =
            e =&gt; !IsArchiveFilterEnabled ||
                 !EF.Property&lt;bool&gt;(e, "IsArchived");
        expression = expression == null 
            ? archiveFilter 
            : CombineExpressions(expression, 
                archiveFilter);
    }
    return expression;
}</pre>
			<p>The implementation seems a bit complicated because it creates and combines expressions. The important part is how the <code>archiveFilter</code> expression was defined. <code>!IsArchiveFilterEnabled</code> checks if the filter is disabled. If the filter is disabled, then the other condition is not evaluated, and all the entities are retrieved without filtering. <code>!EF.Property&lt;bool&gt;(e, "IsArchived")</code> checks if the <code>IsArchived</code> value is <code>false</code> for that entity, so it eliminates entities with <code>IsArchived</code> as <code>true</code>.</p>
			<p>As you've seen<a id="_idIndexMarker530"/> from the preceding code block, I haven't used the <code>Order</code> entity in the filter implementation. That means the implementation is generic and can work with any entity type—all you need is to implement the <code>IArchivable</code> interface for the entity that you want to apply the filter for.</p>
			<p>In summary, ABP allows us to create and control global query filters easily. It also uses that system to implement two popular patterns—soft-delete and multi-tenancy. The next section introduces the audit logging system, ABP's other feature that is very common in enterprise software solutions.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor266"/>Controlling the audit logging system</h1>
			<p>ABP's audit logging system<a id="_idIndexMarker531"/> tracks all requests and entity changes and writes them into a database. Then, you can get a report of what was done in your application, when it was made, and who did it.</p>
			<p>The audit log system is installed and properly configured when you create a new solution from the startup templates. Most of the time, you use it without any configuration. However, ABP allows you to control, customize, and extend the audit logging system. But first, let's understand what an audit log object is.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor267"/>Audit log object</h2>
			<p>An audit log object<a id="_idIndexMarker532"/> is a group of actions and related entity changes performed together in a limited scope, typically in an HTTP request for a web application. We will talk more about audit log scopes in the next section.</p>
			<p>The diagram in <em class="italic">Figure 8.1</em> represents an audit log object:</p>
			<div><div><img src="img/Figure_8.1_B17287.jpg" alt="Figure 8.1 – Audit log object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Audit log object</p>
			<p>Let's explain that diagram by<a id="_idIndexMarker533"/> beginning from the root object, as follows:</p>
			<ul>
				<li><code>AuditLogInfo</code>: In every scope (typically, a web request), there is one <code>AuditLogInfo</code> object that contains information about the current user, current tenant, HTTP request, client and browser details, and execution time and duration of the operation.</li>
				<li><code>AuditLogActionInfo</code>: In every audit log, there may be zero or more actions. An action is typically a controller action call, a page handler call, or an application service method call. It includes the class name, method name, and method arguments in that call.</li>
				<li><code>EntityChangeInfo</code>: An audit log object may contain zero or more changes on the entities in the database. Each entity change contains the change type (created, updated, or deleted), entity type (full class name), and ID of the changed entity.</li>
				<li><code>EntityPropertyChangeInfo</code>: For every entity change, it logs the changes on the properties (fields in the database). This object contains the name, type, old value, and the new value of the affected property.</li>
				<li><code>Exception</code>: A list of exceptions occurred during this audit log scope.</li>
				<li><code>Comment</code>: Additional comments/logs related to this audit log.</li>
			</ul>
			<p>The audit log object is saved into multiple tables in a relational database: <code>AbpAuditLogs</code>, <code>AbpAuditLogActions</code>, <code>AbpEntityChanges</code>, and <code>AbpEntityPropertyChanges</code>. I've written the fundamental properties of the audit log object in the previous list. You can check these database tables or investigate the <code>AuditLogInfo</code> object to <a id="_idIndexMarker534"/>see all the details.</p>
			<p class="callout-heading">MongoDB Limitation</p>
			<p class="callout">Entity changes are not logged for MongoDB since ABP uses EF Core's change-tracking system to get the entity change information, and the MongoDB driver has no such change-tracking system.</p>
			<p>As mentioned at the beginning of this section, an audit log object is created per audit log scope.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor268"/>Audit log scope</h2>
			<p>The audit log <a id="_idIndexMarker535"/>scope uses<a id="_idIndexMarker536"/> the <strong class="bold">Ambient Context Pattern</strong>. When you create a new audit log scope, all actions and changes made in this scope are saved as a single audit log object.</p>
			<p>There are a few ways to establish an audit log scope.</p>
			<h3>Audit log middleware</h3>
			<p>The first and the most<a id="_idIndexMarker537"/> common way to create an audit log scope is to use the audit log middleware in the ASP.NET Core pipeline configuration:</p>
			<pre>app.UseAuditing();</pre>
			<p>This is typically placed before the <code>app.UseEndpoints()</code> or <code>app.UseConfiguredEndpoints()</code> endpoint configuration. When you use this middleware, every HTTP request writes a separate audit log record, which is the wanted behavior most of the time and is already configured in the startup templates by default.</p>
			<h3>Audit log interceptor</h3>
			<p>If you don't<a id="_idIndexMarker538"/> use the audit log middleware or if your application is not a request/reply-style ASP.NET Core application (for example, a desktop or Blazor Server application), then ABP creates a new audit log scope per application service method.</p>
			<h3>Manually creating audit scopes</h3>
			<p>You typically won't need <a id="_idIndexMarker539"/>to do this, but if you want to create an audit scope manually, you can use the <code>IAuditingManager</code> servic<a id="_idTextAnchor269"/>e, as shown in the following code block:</p>
			<pre>public class MyServiceWithAuditing : ITransientDependency
{
    //...inject IAuditingManager _auditingManager;
    public async Task DoItAsync()
    {
        using (var auditingScope = 
            _auditingManager.BeginScope())
        {
            try
            {
                //TODO: call other services...
            }
            catch (Exception ex)
            {  _auditingManager.Current.Log.Exceptions.Add(ex);
                throw;
            }
            finally
            {
                await auditingScope.SaveAsync();
            }
        }
    }
}</pre>
			<p>Once you inject the <code>IAuditingManager</code> service, you can use the <code>BeginScope</code> method to create a new scope. Then, create a <code>try</code>-<code>catch</code> block to save the audit log, including exception cases. In the <code>try</code> section, you can just perform your logic, call any other service, and so on. All these operations and the changes in these operations are saved as a single audit log object in the <code>finally</code> block.</p>
			<p>Inside an audit log scope (regardless of whether it is created by ABP or manually by you), <code>_auditingManager.Current.Log</code> can be used to get the current audit log object to investigate or manipulate it (for example, add comment lines or additional information). If you are not in an audit log scope, then <code>_auditingManager.Current</code> returns <code>null</code>, so check for <code>null</code> if you are unsure as to whether there is a surrounding audit log scope.</p>
			<p>I've introduced the <a id="_idIndexMarker540"/>audit log object and audit log scopes, which work seamlessly by default. Now, let's see options to understand the defaults and the global configuration possibilities for the audit log system.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor270"/>Auditing options</h2>
			<p>The <code>AbpAuditingOptions</code> class is <a id="_idIndexMarker541"/>used to configure default options for the auditing system. It can be configured using the standard <code>options</code> p<a id="_idTextAnchor271"/>attern, as shown in the following example:</p>
			<pre>Configure&lt;AbpAuditingOptions&gt;(options =&gt;
{
    options.IsEnabled = false;
});</pre>
			<p>You can configure <code>options</code> inside the <code>ConfigureServices</code> method of your module. See the following list for the main options for the auditing system:</p>
			<ul>
				<li><code>IsEnabled</code> (<code>bool</code>; default: <code>true</code>): The main point to completely disable the auditing system.</li>
				<li><code>IsEnabledForGetRequests</code> (<code>bool</code>; default: <code>false</code>): ABP does not save audit logs for HTTP <code>GET</code> requests by default because <code>GET</code> requests are not supposed to change the database. However, you can set this to <code>true</code>, which enables audit logging for <code>GET</code> requests too.</li>
				<li><code>IsEnabledForAnonymousUsers</code> (<code>bool</code>; default: <code>true</code>): Set this to <code>false</code> if you want to write audit logs only for authenticated users. If you save audit logs for anonymous users, you will see <code>null</code> for <code>UserId</code> values for these users.</li>
				<li><code>AlwaysLogOnException</code> (<code>bool</code>; default: <code>true</code>): If an exception occurs in your application code, ABP saves the audit log by default, without considering the <code>IsEnabledForGetRequests</code> and <code>IsEnabledForAnonymousUsers</code> options. Set this to <code>false</code> to disable that behavior.</li>
				<li><code>hideErrors</code> (<code>bool</code>; default: <code>true</code>): ABP ignores exceptions while saving audit log objects to the database. Set this to <code>false</code> to throw exceptions instead of hiding them.</li>
				<li><code>ApplicationName</code> (<code>string</code>; default: <code>null</code>): If multiple applications are using the same database to save the audit logs, you can set this option in each application so that you can<a id="_idIndexMarker542"/> filter the logs based on the application name.</li>
				<li><code>IgnoredTypes</code> (<code>List&lt;Type&gt;</code>): You can ignore some specific types in the audit log system, including entity types.</li>
			</ul>
			<p>In addition to these simple global options, you can e<a id="_idTextAnchor272"/>nable/disable change tracking for entities.</p>
			<h3>Enabling entity histories</h3>
			<p>The audit log object contains <a id="_idIndexMarker543"/>entity changes with property details. However, it is disabled for all entities by default because it may write too many logs into the database, which may rapidly increase the database size. It is suggested to enable it in a controlled way for the entities you want to track.</p>
			<p>There are two ways to enable entity histories for entities, as outlined here:</p>
			<ul>
				<li>The <code>[Auditing]</code> attribute is used to enable it for a single entity. It will be explained in the next section.</li>
				<li>The <code>EntityHistorySelectors</code> option is used to enable it for multiple entities.</li>
			</ul>
			<p>In the following example, I've enabled the <code>EntityHistorySelectors</code> option for all entities:</p>
			<pre>Configure&lt;<a id="_idTextAnchor273"/>AbpAuditingOptions&gt;(options =&gt;
{
    options.EntityHistorySelectors.AddAllEntities();
});</pre>
			<p>The <code>AddAllEntities</code> method is a shortcut. <code>EntityHistorySelectors</code> is a list of named selectors, and you can add a lambda expression to select the entities you want. The following code is equivalent to the preceding configuration code:</p>
			<pre>Configure&lt;AbpAuditingOptions&gt;(options =&gt;
{
    options.EntityHistorySelectors.Add(
        new NamedTypeSelector("MySelectorName", type =&gt; 
            true)
    );
});</pre>
			<p>The first argument of <code>NamedTypeSelector</code> is the selector name—<code>MySelectorName</code>, for this example. Selector names are arbitrary, and they can be used later to find or remove a selector from the selector list. You typically don't use it; just give it a unique name. The second argument of <code>NamedTypeSelector</code> takes an expression. It gives you an entity <code>type</code> and waits for <code>true</code> or <code>false</code>. Returns <code>true</code>, if you want to enable entity histories for a given entity type. So, you can pass an expression such as <code>type =&gt; type.Namespace.StartsWith("MyRootNamespace")</code> to select all entities with a namespace. You can add as many selectors as you need. All selectors are tested. If one of them returns <code>true</code>, the entity is selected for logging property changes.</p>
			<p>Besides these global<a id="_idIndexMarker544"/> options and selectors, there are ways to enable/disable audit logging per class, method, and property level.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor274"/>Disabling and enabling audit logging in detail</h2>
			<p>When you use the<a id="_idIndexMarker545"/> audit log system, you typically want to log every access. However, in some cases, you may want to disable audit logging for some specific actions or entities. Here are some potential reasons for that: the action parameters may be <a id="_idIndexMarker546"/>dangerous to write into the logs (for example, it may contain the user's password), the action call or entity change might be out of the user's control, so it isn't worth recording for audit purposes, or the operation can be a bulk operation that writes too many audit logs and decreases performance.</p>
			<p>ABP defines the <code>[DisableAuditing]</code> and <code>[Audited]</code> attributes to control logged objects declaratively. There are two targets that you can control for audit logging: service calls and entity histories.</p>
			<h3>Controlling audit logging for service calls</h3>
			<p>Application<a id="_idIndexMarker547"/> service methods, Razor Page handlers, and <code>[DisableAuditing]</code> attribute at the class or method level.</p>
			<p>The following example uses the <code>[DisableAuditing]</code> attribute on an application service class:</p>
			<pre>[DisableAuditing]
public class OrderAppService : ApplicationService, IOrderAppService
{
    public async Task CreateAsync(CreateOrderDto input)
    {
    }
    public async Task DeleteAsync(Guid id)
    {
    }
}</pre>
			<p>With this usage, ABP <a id="_idIndexMarker549"/>won't include the execution of these <a id="_idIndexMarker550"/>methods into the audit log object. If you just want to disable one of the methods, you can use it at the method level:</p>
			<pre>public class OrderAppService : ApplicationService, IOrderAppService
{
    [DisableAuditing]
    public async Task CreateAsync(CreateOrderDto input)
    {
    }
    public async Task DeleteAsync(Guid id)
    {
    }
}</pre>
			<p>In this case, the <code>CreateAsync</code> method call is not included in the audit log, while the <code>DeleteAsync</code> method call is written into the audit log object. The same behav<a id="_idTextAnchor275"/>ior could be accomplished using the following code:</p>
			<pre>[DisableAuditing]
public class OrderAppService : ApplicationService, IOrderAppService
{
    public async Task CreateAsync(CreateOrderDto input)
    {
    }
    [Audited]
    public async Task DeleteAsync(Guid id)
    {
    }
}</pre>
			<p>I disabled audit logging for all methods except the <code>DeleteAsync</code> method because the <code>DeleteAsync</code> method declares the <code>[Audited]</code> attribute.</p>
			<p>The <code>[Audited]</code> attribute <a id="_idIndexMarker551"/>can be used on any class (used with the DI system) to enable audit logging on that class, even if the class is not audit-logged by <a id="_idIndexMarker552"/>default. Moreover, you can use it in any method of any class to just enable it for that particular method call. If you use the <code>[Audited]</code> attribute on a class, you can then disable a specific method using the <code>[DisableAuditing]</code> attribute.</p>
			<p>When ABP includes a method call information in the audit log object, it also includes all the parameters of the executed method. That is super-useful to understand which changes were made in your system; however, you may want to exclude some properties of the input in some cases. Consider a scenario that you get credit card information from the user. You probably don't want to include this in the audit logs. You can use the <code>[DisableAuditing]</code> attribute on any property of an input object in such a case. See the following example, which excludes a property of a <code>Dto</code> input from the audit log:</p>
			<pre>public class CreateOrderDto
{
    public Guid CustomerId { get; set; }
    public string DeliveryAddress { get; set; }
    [DisableAuditing]
    public string CreditCardNumber { get; set; }
}</pre>
			<p>For this example, ABP won't write the <code>CreditCardNumber</code> value into the audit log.</p>
			<p>Disabling audit logging<a id="_idIndexMarker553"/> for method calls won't affect the entity<a id="_idIndexMarker554"/> histories. If an entity is changed and it was selected for audit logging, changes are still logged. The next section explains how to control the audit logging system for entity histories.</p>
			<h3>Controlling audit logging for entity histories</h3>
			<p>In the <em class="italic">Enabling entity histories</em> section, we saw how to enable entity histories for one or more<a id="_idIndexMarker555"/> entities by defining selectors. However, if <a id="_idIndexMarker556"/>you want to enable the entity histories for a single entity, there is an alternative and simpler way: just add the <code>[Audited]</code> attribute above your entity class:</p>
			<pre>[Audited]
public class Order : AggregateRoot&lt;Guid&gt;
{
}</pre>
			<p>In this example, I added the <code>[Audited]</code> attribute to an <code>Order</code> entity to configure the audit logging system to enable entity histories for this entity.</p>
			<p>Suppose you've used selectors to enable entity histories for many or all entities but want to disable them for a specific entity. In that case, you can use the <code>[DisableAuditing]</code> attribute for that entity class.</p>
			<p>The <code>[DisableAuditing]</code> attribute can also be used on a property of an entity to exclude this property from the audit logs, as shown in the following example:</p>
			<pre>[Audited]
public class Order : AggregateRoot&lt;Guid&gt;
{
    public Guid CustomerId { get; set; }
    [DisableAuditing]
    public string CreditCardNumber { get; set; }
}</pre>
			<p>For that <a id="_idIndexMarker557"/>example, ABP won't write the <code>CreditCardNumber</code> value<a id="_idIndexMarker558"/> into the audit log.</p>
			<h3>Storing audit logs</h3>
			<p>The core of the ABP <a id="_idIndexMarker559"/>Framework has been designed to not assume any data store by introducing abstractions wherever it needs to touch a data source. The audit logging system is not an exception. It defines the <code>IAuditingStore</code> interface to abstract where the audit log objects are saved. That interface only has a single method:</p>
			<pre>Task SaveAsync(AuditLogInfo auditInfo);</pre>
			<p>You can implement this interface to save audit logs where you want. If you use ABP's startup templates to create a new solution, it is configured to save audit logs to the application's main database, so you normally don't have to implement the <code>IAuditingStore</code> interface manually.</p>
			<p>We've seen different ways to control and customize the audit log system. Audit logging is an essential system for enterprise systems to track and log changes in your system. The next section introduces the caching system, another essential feature of a web application.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor276"/>Caching data</h1>
			<p>Caching is <a id="_idIndexMarker560"/>one of the most fundamental systems to improve your application's performance and scalability. ABP extends ASP.NET Core's <strong class="bold">distributed caching</strong> system and makes it compatible with other features of ABP Framework, such as multi-tenancy.</p>
			<p>Distributed caching is essential <a id="_idIndexMarker561"/>if you run multiple instances of your application or have a distributed system, such as a microservice solution. It provides consistency between different applications and allows the sharing of cached values. A distributed cache is typically an external, standalone application, such as Redis and Memcached.</p>
			<p>It is suggested to use the distributed caching system even if your application has a single running instance. Don't worry about the performance since the default implementation of distributed cache works in memory. That means it is not distributed unless you explicitly configure a real <a id="_idIndexMarker562"/>distributed cache provider, such as Redis.</p>
			<p class="callout-heading">Distributed Caching in ASP.NET Core</p>
			<p class="callout">This section focuses on ABP's caching features and doesn't cover all ASP.NET Core's distributed caching system features. You can refer to Microsoft's documentation to learn more about distributed caching in <a id="_idIndexMarker563"/>ASP.NET Core: <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed">https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed</a>. </p>
			<p>In this section, I will show you how to use the <code>IDistributedCache&lt;T&gt;</code> interface, configure options, and deal with error handling and batch operations. We will also learn about using Redis as the distributed cache provider. Finally, I will talk about invalidating cached values.</p>
			<p>Let's start from the basics—the <code>IDistributedCache&lt;T&gt;</code> interface.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor277"/>Using the IDistributedCache&lt;T&gt; interface</h2>
			<p>ASP.NET<a id="_idIndexMarker564"/> Core defines an <code>IDistributedCache</code> interface, but it is not type-safe. It sets and gets <code>byte</code> arrays rather than objects. ABP's <code>IDistributedCache&lt;T&gt;</code> interface, on the other hand, is designed as generic with type-safe method parameters (<code>T</code> stands for the type of items stored in the cache). It internally uses the standard <code>IDistributedCache</code> interface to be 100% compatible with ASP.NET Core's caching system. ABP's <code>IDistributedCache&lt;T&gt;</code> interface has two main advantages, as follows:</p>
			<ul>
				<li>Automatically serializes/deserializes the objects to <code>byte</code> arrays. So, you don't deal with serialization and deserialization.</li>
				<li>It automatically adds the cache name prefix to the cache keys to allow the use of the same key for different kinds of cache objects.</li>
			</ul>
			<p>The first step in using the <code>IDistributedCache&lt;T&gt;</code> interface is to define a class to represent items in the cache. I've define<a id="_idTextAnchor278"/>d the following class to store a user's information in the cache:</p>
			<pre>public class UserCacheItem
{
    public Guid Id { get; set; }
    public string UserName { get; set; }
    public string EmailAddress { get; set; }
}</pre>
			<p>That is a plain C# class. The<a id="_idIndexMarker565"/> only restriction is that it should be serializable because it is serialized to JSON while saving to the cache and deserialized while reading from the cache (for example, do not add references to other objects that should not or cannot be stored in the cache; keep it simple).</p>
			<p>Once we've defined the cache item class, we can inject the <code>IDistributedCache&lt;T&gt;</code> interface, as shown in the following code block:</p>
			<pre>public<a id="_idTextAnchor279"/> class MyUserService : ITransientDependency
{
    private readonly IDistributedCache&lt;UserCacheItem&gt; 
        _userCache;
    public MyUserService(IDistributedCache&lt;UserCacheItem&gt; 
        userCache)
    {
        _userCache = userCache;
    }
}</pre>
			<p>I've injected the <code>IDistributedCache&lt;UserCacheItem&gt;</code> service to work with the distributed cache for <code>UserCacheItem</code> objects. The following code block shows how we can use it to get cached user information and fall back to the database query if the given user was not found in the cache:</p>
			<pre>pu<a id="_idTextAnchor280"/>blic async Task&lt;UserCacheItem&gt; GetUserInfoAsync(Guid userId)
{
    return await _userCache.GetOrAddAsync(
        userId.ToString(), 
        async () =&gt; await GetUserFromDatabaseAsync(userId),
        () =&gt; new DistributedCacheEntryOptions
        {
            AbsoluteExpiration = 
                DateTimeOffset.Now.AddHours(1)
        }
    );
}</pre>
			<p>I've passed three <a id="_idIndexMarker566"/>parameters to the <code>GetOrAddAsync</code> method:</p>
			<ul>
				<li>The first parameter is the cache key, which should be a string value, so I converted the <code>Guid</code> <code>userId</code> value to a string value.</li>
				<li>The second parameter is a factory method that is executed if the given key is not found in the cache. I passed the <code>GetUserFromDatabaseAsync</code> method here. In that method, you should build the cache item from its data source.</li>
				<li>The final parameter is a factory method that returns a <code>DistributedCacheEntryOptions</code> object. This is optional and configures the expiration time for the cached item. The factory method is only called if the <code>GetOrAddAsync</code> method adds the entry.</li>
			</ul>
			<p>Cache keys are <code>string</code> data types by default. However, ABP defines another interface, <code>IDistributedCache&lt;TCacheItem, TCacheKey&gt;</code>, allowing you to specify the cache key so that you don't need to convert your keys to <code>string</code> data types manually. We could inject the <code>IDistributedCache&lt;UserCacheItem, Guid&gt;</code> service and remove the <code>ToString()</code> usage in the first parameter for this example.</p>
			<p><code>DistributedCacheEntryOptions</code> has the following options to control the lifetime of the<a id="_idIndexMarker567"/> cached item:</p>
			<ul>
				<li><code>AbsoluteExpiration</code>: You can set an absolute time, as we've done in this example. The item is automatically deleted from the cache at that time.</li>
				<li><code>AbsoluteExpirationRelativeToNow</code>: An alternative way to set the absolute expiration time. We could rewrite the option in this example so that it reads <code>AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)</code>. The result will be the same.</li>
				<li><code>SlidingExpiration</code>: Sets how long the cache item can be inactive (not accessed) before it is removed. This means that if you continue to access the cached item, the expiration time is automatically extended.</li>
			</ul>
			<p>If you don't pass the expiration time parameter, the default value is used. You can configure the default value and some other global options using the <code>AbpDistributedCacheOptions</code> class explained in the next section. Before that, let's see the other methods of the <code>IDistributedCache&lt;UserCacheItem&gt;</code> service, as follows:</p>
			<ul>
				<li><code>GetAsync</code> is used to read data from the cache with a cache key.</li>
				<li><code>SetAsync</code> is used to save an item to the cache. It overwrites the existing value if available.</li>
				<li><code>RefreshAsync</code> is used to reset the sliding expiration time for the given key.</li>
				<li><code>RemoveAsync</code> is used to delete an item from the cache.<p class="callout-heading">About Synchronous Cache Methods</p><p class="callout">All the methods also have synchronous versions, such as the <code>GET</code> method for the <code>GetAsync</code> method. However, it is suggested to use the asynchronous version wherever possible.</p></li>
			</ul>
			<p>These methods are the<a id="_idIndexMarker568"/> standard methods of ASP.NET Core. ABP adds methods to work with multiple items for each method, such as <code>GetManyAsync</code> for <code>GetAsync</code>. Working with <code>Many</code> methods has a significant performance gain if you have a lot of items to read or write. The <code>GetOrAddAsync</code> method (used in the <code>GetUserInfoAsync</code> example in this section) is also defined by ABP Framework to safely read a cache value, fall back to the original data source, and set the cache value in a single method call.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor281"/>Configuring cache options</h2>
			<p><code>AbpDistributedCacheOptions</code> is the main options class to configure the caching system. You can<a id="_idIndexMarker569"/> configure it in the <code>ConfigureServices</code> method of your module cl<a id="_idTextAnchor282"/>ass (you can do this in the domain or application layers), as follows:</p>
			<pre>Configure&lt;AbpDistributedCacheOptions&gt;(options =&gt;
{
    options.GlobalCacheEntryOptions
        .AbsoluteExpirationRelativeToNow = 
            TimeSpan.FromHours(2);
});</pre>
			<p>I've configured the <code>GlobalCacheEntryOptions</code> property to configure the default cache expiration time to <code>2</code> hours in this code block.</p>
			<p><code>AbpDistributedCacheOptions</code> has some other properties too, as outlined here:</p>
			<ul>
				<li><code>KeyPrefix</code> (<code>string</code>; default: <code>null</code>): A prefix value that is added to the beginning of all cache keys for that application. This option can be used to isolate your application's cache items when using a distributed cache shared by multiple applications.</li>
				<li><code>hideErrors</code> (<code>bool</code>; default: <code>true</code>): A value to control the default value of error handling on cache service methods.</li>
			</ul>
			<p>As you've seen in <a id="_idIndexMarker570"/>the previous examples, these options can be overridden by passing parameters to the methods of the <code>IDistributedCache</code> service.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor283"/>Error handling</h2>
			<p>When we use an<a id="_idIndexMarker571"/> external process (such as Redis) for distributed caching, it is probable to have problems while reading data from and writing data to the cache. The cache server may be offline, or we may have temporary network problems. These temporary problems can be ignored most of the time, especially while trying to read data from the cache. You can safely try to read from the original data source if the cache service is not available at the moment. It may be slower but is better than throwing an exception and failing the current request.</p>
			<p>All the <code>IDistributedCache&lt;T&gt;</code> methods get an optional <code>hideErrors</code> parameter to control the exception-handling behavior. If you pass <code>false</code>, then all the exceptions are thrown. If you pass <code>true</code>, then ABP hides cache-related errors. If you don't specify a value, the default value is used, as explained in the previous section.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor284"/>Using the cache in a multi-tenancy application</h2>
			<p>If your application is <a id="_idIndexMarker572"/>multi-tenant, ABP automatically adds the <a id="_idIndexMarker573"/>current tenant's ID to the cache key to distinguish between cache values of different tenants. In this way, it provides isolation between tenants.</p>
			<p>If you want to create a cache that is shared between tenants, you can use the <code>[IgnoreMultiTenancy]</code> attribute for the cache item class, as shown in the following code block:</p>
			<pre>[IgnoreMultiTenancy]
public class MyCacheItem
{ /* ... */ }</pre>
			<p>For this<a id="_idIndexMarker574"/> example, <code>MyCacheItem</code> values can be <a id="_idIndexMarker575"/>accessed by different tenants.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor285"/>Using Redis as the distributed cache provider</h2>
			<p>Redis<a id="_idIndexMarker576"/> is a popular tool that is used as a distributed cache. ASP.NET Core provides a cache integration package for Redis. You can use it by following Microsoft's documentation (<a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed">https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed</a>), and it works perfectly.</p>
			<p>ABP also <a id="_idIndexMarker577"/>provides a Redis integration package <a id="_idIndexMarker578"/>that extends Microsoft's integration to support the batch operations (such as <code>GetManyAsync</code>, mentioned in the <em class="italic">Using the IDistributedCache&lt;T&gt; interface</em> section). So, it is suggested to use ABP's integration <code>Volo.Abp.Caching.StackExchangeRedis</code> NuGet package to use Redis as the cache provider. You can install it using the ABP <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) with the following command in the directory of the project you want to use:</p>
			<pre>abp add-package Volo.Abp.Caching.StackExchangeRedis</pre>
			<p>After the installation, all you need to do is to add a configuration to the <code>appsettings.json</code> file to connect to the Redis server, as follows:</p>
			<pre>"Redis": {
  "Configuration": "127.0.0.1"
}</pre>
			<p>You write the server address and port (a connection string) to the <code>Configuration</code> option. Please see Microsoft's documentation for details of the configuration: <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed">https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed</a>.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor286"/>Invalidating cache values</h2>
			<p>There is a popular<a id="_idIndexMarker579"/> saying that cache invalidation is one of the two hard problems in computer science (the other one is naming things). A cached value is typically a duplication of data originally located somewhere costly to read frequently or a computed value that is costly to recalculate. In such cases, it increases performance and scalability, but the problem begins when the original data changes and makes the cached value outdated. We should carefully watch these changes and remove or refresh the related data in the cache. That is called cache invalidation.</p>
			<p>The cache invalidation process depends greatly on the cached data and your application logic. However, there are some specific cases where ABP can help you to invalidate cached data.</p>
			<p>One specific case is that we may want to invalidate a cache item when an entity has changed (is updated or deleted). For this case, we can register for events published by ABP Framework. The fo<a id="_idTextAnchor287"/>llowing code invalidates a user cache item when the related user entity changes:</p>
			<pre>public class MyUserService : 
    ILocalEventHandler&lt;EntityChangedEventData&lt;IdentityUser&gt;&gt;,
    ITransientDependency
{
    private readonly IDistributedCache&lt;UserCacheItem&gt; 
        _userCache;
    private readonly IRepository&lt;IdentityUser, Guid&gt; 
         _userRepository;
    //...omitted other code parts 
    public async Task HandleEventAsync(
        EntityChangedEventData&lt;IdentityUser&gt; data)
    {
        await _userCache.RemoveAsync 
            (data.Entity.Id.ToString());
    }
}</pre>
			<p><code>MyUserService</code> registers for an <code>EntityChangedEventData&lt;IdentityUser&gt;</code> local event. This event is triggered when a new <code>IdentityUser</code> entity is created or an existing <code>IdentityUser</code> entity is updated or deleted. The <code>HandleEventAsync</code> method is called in that case with the related entity in the <code>data.Entity</code> property. This method simply removes the user from the cache with the <code>Id</code> value of the changed entity.</p>
			<p>Local events <a id="_idIndexMarker580"/>work in the current process. That means the handler class (<code>MyUserService</code> here) should be in the same process as the entity change.</p>
			<p class="callout-heading">About the Event Bus System</p>
			<p class="callout">Local and distributed events are interesting features of ABP Framework that are not included in this book. See the<a id="_idIndexMarker581"/> ABP documentation if you want to learn more about them: <a href="https://docs.abp.io/en/abp/latest/Event-Bus">https://docs.abp.io/en/abp/latest/Event-Bus</a>.</p>
			<p>In this section, we've learned how to work with the distributed caching system, configure options, and deal with error handling. We've also introduced the Redis cache provider installation. Finally, we've introduced automatic ABP events that can help us to invalidate cached values.</p>
			<p>The next section will be related to UI localization, the final ABP feature I will introduce in this chapter.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor288"/>Localizing the user interface</h1>
			<p>If you are building a global product, you probably want to show the UI localized on the basis of the current user's <a id="_idIndexMarker582"/>language. ASP.NET Core provides a system to localize your application's UI. ABP adds some useful features and conventions to make it even easier and flexible.</p>
			<p>This section explains how to define the languages that you want to support, create text for different languages, and get the correct text for the current user. You will understand the localization resource concept and embedded localization resource files.</p>
			<p>We can begin by defining the languages supported by your application.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor289"/>Configuring supported languages</h2>
			<p>The first question about<a id="_idIndexMarker583"/> localization is this: <em class="italic">Which languages do you want to support on your UI?</em> ABP provides a simple configuration to define languages, using <code>AbpLocalizationOptions</code>, as shown in the following code block:</p>
			<pre>Configure&lt;AbpLocalizationOptions&gt;(options =&gt;
{
    options.Languages.Add(new LanguageInfo("en", "en", 
        "English"));
    options.Languages.Add(new LanguageInfo("tr", "tr", 
        "Türkçe"));
    options.Languages.Add(new LanguageInfo("es", "es", 
        "Español"));
});</pre>
			<p>You can write that code into the <code>ConfigureServices</code> method of your module class. In fact, that configuration is already done (with a lot of languages) when you create a new solution using the ABP application startup templates. You just edit the list as needed.</p>
			<p>The <code>LanguageInfo</code> constructor takes a few parameters:</p>
			<ul>
				<li><code>cultureName</code>: The culture <a id="_idIndexMarker584"/>name (code) for the language, which is set to <code>CultureInfo.CurrentCulture</code> on runtime.</li>
				<li><code>uiCultureName</code>: The UI culture name (code) for the language, which is set to <code>CultureInfo.</code> <code>CurrentUICulture</code> on runtime.</li>
				<li><code>displayName</code>: Name of the language that is shown to the user while selecting this language. It is suggested to write that name in its original language.</li>
				<li><code>flagIcon</code>: A string value that the UI can use to show a country flag near the language name.</li>
			</ul>
			<p>ABP determines one of these languages based on the current HTTP request.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor290"/>Determining the current language</h2>
			<p>ABP determines the <a id="_idIndexMarker585"/>current language by using the <code>AbpRequestLocalizationMiddleware</code> class. This is an ASP.NET Core middleware that is added to the ASP.NET Core request pipeline with the following line of code:</p>
			<pre>app.UseAbpRequestLocalization();</pre>
			<p>When the request passes through this middleware, one of the configured languages is selected and set to <code>CultureInfo.CurrentCulture</code> and <code>CultureInfo.CurrentUICulture</code>. These are the standard systems of .NET to set and get the current culture in localization.</p>
			<p>The current language is<a id="_idIndexMarker586"/> selected based on the following HTTP request parameters in the given priority order:</p>
			<ol>
				<li>If the <code>culture</code> query string parameter is set, it is used to determine the current language. An example is <code>http://localhost:5000/?culture=en-US</code>.</li>
				<li>If the <code>.AspNetCore.Culture</code> cookie value is set, then it is used as the current language.</li>
				<li>If the <code>Accept-Language</code> HTTP header is set, it is used as the current language. The browser generally sends this last one by default.<p class="callout-heading">About ASP.NET Core's Localization System</p><p class="callout">The behaviour explained in this section was the default behavior. However, ASP.NET Core's language determination system is more flexible and customizable. Please see Microsoft's<a id="_idIndexMarker587"/> documentation for more information: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization</a>.</p></li>
			</ol>
			<p>After defining the languages we want to support, we can define our localization resources.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor291"/>Defining a localization resource</h2>
			<p>ABP is 100% compatible with <a id="_idIndexMarker588"/>ASP.NET Core's localization system. So, you can use the <code>.resx</code> files as localization resources by following Microsoft's documentation: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization</a>. However, ABP offers a lightweight, flexible, and extensible way to define localized texts using simple JSON files.</p>
			<p>When you create a new solution using the ABP startup templates, the <code>Domain.Shared</code> project contains the localization resource of the application with the localization JSON files:</p>
			<div><div><img src="img/Figure_8.2_B17287.jpg" alt="Figure 8.2 – Localization resource and localization JSON files&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Localization resource and localization JSON files</p>
			<p>For this example, the <code>DemoAppResource</code> class represents the localization resource. An application can have more than one localization resource, and each defines its own JSON files. You can think of a localization resource as a group of localization texts. It helps to build modular systems where each module has its own localization resource.</p>
			<p>A localization <a id="_idIndexMarker589"/>resource class is an empty class, as shown in the following code:</p>
			<pre>[LocalizationResourceName("DemoApp")]
public class DemoAppResource
{ }</pre>
			<p>This class refers to the related resource when you want to use texts in that localization resource. The <code>LocalizationResourceName</code> attribute sets a string name to the resource. Every localization resource has a unique name that is used in the client-side code to refer to the resource. We will explore client-side localization in <em class="italic">Using localization in the client side</em> section.</p>
			<p class="callout-heading">Default Localization Resource of the Application</p>
			<p class="callout">You typically have a single (default) localization resource in your application that comes with the startup template when creating a new ABP solution. The default localization resource class's name starts with the project name—for example, <code>ProductManagementResource</code> if you've specified <code>ProductManagement</code> as the project name.</p>
			<p>Once we have a localization resource, we can create a JSON file for each language we support.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor292"/>Working with the localization JSON files</h2>
			<p>A localization file <a id="_idIndexMarker590"/>is a simple JSON-formatted file, as shown in the following code block:</p>
			<pre>{
  "culture": "en",
  "texts": {
    "Home": "Home",
    "WelcomeMessage": "Welcome to the application."
  }
}</pre>
			<p>There are two main root<a id="_idIndexMarker591"/> elements in that file, as outlined here:</p>
			<ul>
				<li><code>culture</code>: The culture code for the related language. It matches the culture code that was introduced in <em class="italic">Configuring the supported languages</em> section.</li>
				<li><code>texts</code>: Contains key-value pairs for the localization texts. The key is used to access the localized texts and should be the same in all JSON files of different languages. The value is the localized text for the current culture (language).</li>
			</ul>
			<p>After defining localization texts for each language, we can request localized texts at runtime.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor293"/>Getting localized texts</h2>
			<p>ASP.NET Core defines<a id="_idIndexMarker592"/> an <code>IStringLocalizer&lt;T&gt;</code> interface to get the localized texts in the current culture, where <code>T</code> stands for the localization resource<a id="_idTextAnchor294"/> class. You can inject that interface into your class, as shown in the following code block:</p>
			<pre>public class LocalizationDemoService : ITransientDependency
{
    private readonly IStringLocalizer&lt;DemoAppResource&gt; 
        _localizer;
    public LocalizationDemoService(
        IStringLocalizer&lt;DemoAppResource&gt; localizer)
    {
        _localizer = localizer;
    }
    public string GetWelcomeMessage()
    {
        return _localizer["WelcomeMessage"];
    }
}</pre>
			<p>In the preceding code block, the <code>LocalizationDemoService</code> class injects the <code>IStringLocalizer&lt;DemoAppResource&gt;</code> service, which is used to access localized texts for the <code>DemoAppResource</code> class. In the <code>GetWelcomeMessage</code> method, we simply get the localized text for the <code>WelcomeMessage</code> key. If the current language is English, it returns <code>Welcome to the application.</code>, as we defined in the JSON file in the<a id="_idIndexMarker593"/> previous section.</p>
			<p>We can pass parameters while localizing text.</p>
			<h3>Parameterized texts</h3>
			<p>Localization texts can<a id="_idIndexMarker594"/> contain parameters, as shown in the<a id="_idIndexMarker595"/> following example:</p>
			<pre>"WelcomeMessageWithName": "Welcome {0} to the application."</pre>
			<p>Parameters can be passed to the localizer, as shown in the following code block:</p>
			<pre>public string GetWelcomeMessage(string name)
{
    return _localizer["WelcomeMessageWithName", name];
}</pre>
			<p>The given name for this example replaces the <code>{0}</code> placeholder.</p>
			<h3>The fallback logic</h3>
			<p>The localization <a id="_idIndexMarker596"/>system uses fallbacks to parent or default cultures when the requested text is not found in the current culture's JSON file.</p>
			<p>For example, assume that you've requested to get a <code>WelcomeMessage</code> text while the current culture (<code>CultureInfo.CurrentUICulture</code>) is <code>de-DE</code> (German–Germany). In that case, one of the following scenarios occurs:</p>
			<ul>
				<li>If you haven't defined a JSON file with <code>"culture": "de-DE"</code> or you have defined a JSON file but it doesn't contain the <code>WelcomeMessage</code> key, then it falls back to the parent culture (<code>"de"</code>), tries to find the given key in that culture, and returns it if available.</li>
				<li>If it is not found in the parent culture, it falls back to the default culture of the localization resource (see the next section to configure the default culture).</li>
				<li>If it is not <a id="_idIndexMarker597"/>found in the default culture, then the given key (<code>WelcomeMessage</code>, for this example) is returned as the response.</li>
			</ul>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor295"/>Configuring localization resources</h2>
			<p>A localization resource <a id="_idIndexMarker598"/>should be added to <code>AbpLocalizationOptions</code> before using it. This configuration is already done in the startup template with the following code:</p>
			<pre>Configure&lt;AbpVirtualFileSystemOptions&gt;(options =&gt;
{
    options.FileSets.AddEmbedded&lt;DemoAppDomainSharedModule&gt;(); 
    });
Configure&lt;AbpLocalizationOptions&gt;(options =&gt;
{
    options.Resources
        .Add&lt;DemoAppResource&gt;("en")
        .AddBaseTypes(typeof(AbpValidationResource))
        .AddVirtualJson("/Localization/DemoApp");
    options.DefaultResourceType = typeof(DemoAppResource);
});</pre>
			<p>Localization JSON files are generally defined as embedded resources. We are configuring ABP's virtual filesystem (using the <code>AbpVirtualFileSystemOptions</code>) to add all embedded files in that assembly into the virtual filesystem so that the localization files are also added.</p>
			<p>Then, in the second part, we add <code>DemoAppResource</code> to the <code>Resources</code> dictionary so that ABP recognizes it. Here, the <code>"en"</code> parameter sets the default culture of that localization resource.</p>
			<p>ABP's localization system is pretty advanced. It allows you to reuse the texts of a localization resource by inheriting the localization resource from another localization resource. In this example, we are inheriting <code>AbpValidationResource</code>, which is defined in ABP Framework and contains standard validation error messages.</p>
			<p>The <code>AddVirtualJson</code> method is used to set the JSON files related to that resource using the virtual filesystem.</p>
			<p>Finally, <code>DefaultResourceType</code> sets <a id="_idIndexMarker599"/>the default localization resource for that application. You can have a default resource used in some places where you don't specify the localization resource. The next section explains the main usage point of this configuration.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor296"/>Localizing in special services</h2>
			<p>Injecting the <code>IStringLocalizer&lt;T&gt;</code> service everywhere can be tedious. ABP pre-injects the <a id="_idIndexMarker600"/>localizer into some special base classes. When you inherit from <a id="_idIndexMarker601"/>these classes, you can directly use the <code>L</code> shortcut property to localize texts.</p>
			<p>The following example shows how to localize text in an application service method:</p>
			<pre>public class MyAppService : ApplicationService
{
    public async Task FooAsync()
    {
        var str = L["WelcomeMessage"];
    }
}</pre>
			<p>The <code>L</code> property, in this example, is defined by the <code>ApplicationService</code> base class, so you don't need to inject the <code>IStringLocalizer&lt;T&gt;</code> service manually. You may wonder, as we haven't specified a localization resource, which one is used here. The answer is the <code>DefaultResourceType</code> option that was explained in the previous section.</p>
			<p>If you want to specify another localization resource for a particular application service, then set the <code>LocalizationResource</code> property in the constructor of your service:</p>
			<pre>public class MyAppService : ApplicationService
{
    public MyAppService()
    {
        LocalizationResource = typeof(AnotherResource);
    }
    //...
}</pre>
			<p>In addition <a id="_idIndexMarker602"/>to the <code>ApplicationService</code> class, some other common base<a id="_idIndexMarker603"/> classes, such as <code>AbpController</code> and <code>AbpPageModel</code>, provide the same <code>L</code> property as a shortcut of injecting the <code>IStringLocalizer&lt;T&gt;</code> service.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor297"/>Using localization on the client side</h2>
			<p>One of the ABP's benefits for <a id="_idIndexMarker604"/>the localization system is that all the <a id="_idIndexMarker605"/>localization resources are directly usable on the client-side code.</p>
			<p>For example, the following code localizes the <code>WelcomeMessage</code> key in the JavaScript code for an ASP.NET Core MVC/Razor Pages application:</p>
			<pre>var str = abp.localization.localize('WelcomeMessage', 'DemoApp');</pre>
			<p><code>DemoApp</code> is the <a id="_idIndexMarker606"/>localization resource name, and <code>WelcomeMessage</code> is<a id="_idIndexMarker607"/> the localization key here. Client-side localization will be covered in <em class="italic">Part 4</em>, <em class="italic">User Interface and API Development,</em> of this book.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor298"/>Summary</h1>
			<p>In this chapter, we learned some essential features that you will need in almost any web application. </p>
			<p>The <code>ICurrentUser</code> service allows you to get information about the current user in your application. You can work with the standard claims (such as username and ID) and define custom claims based on your requirements.</p>
			<p>We have explored the data filtering system that automates filtering data while querying from the database. In this way, we can easily implement some patterns such as soft-delete and multi-tenancy. We also learned how to define custom data filters and disable the filters whenever necessary.</p>
			<p>We have understood how the audit log system works to track and save all the operations done by users. We can control the audit log system declaratively and conventionally with attributes and options.</p>
			<p>Caching data is another essential concept to improve the performance and scalability of the system. We've learned about ABP's <code>IDistributedCache&lt;T&gt;</code> service, which provides a type-safe way to interact with the cache provider and automates some common tasks such as serialization and exception handling.</p>
			<p>Finally, we've explored the localization infrastructure of ASP.NET Core and ABP Framework to define and consume localized texts in our applications easily.</p>
			<p>Now we have come to the end of this chapter, we've completed <em class="italic">Part 2</em>, <em class="italic">Fundamentals of ABP Framework</em> of this book, covering ABP Framework and ASP.NET Core infrastructure fundamentals. The next part is a practical guide for implementing <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>) using ABP Framework. DDD is one of the core concepts upon which ABP is based. It includes principles, patterns, and practices to build maintainable business solutions.</p>
		</div>
	</body></html>