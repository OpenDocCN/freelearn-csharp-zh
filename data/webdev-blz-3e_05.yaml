- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Creating Advanced Blazor Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建高级 Blazor 组件
- en: In the last chapter, we learned all the basics of creating a component. This
    chapter will teach us how to take our components to the next level.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了创建组件的所有基础知识。这一章将教会我们如何将我们的组件提升到下一个层次。
- en: This chapter will focus on some of the features that will make our components
    reusable, which will enable us to save time and also give us an understanding
    of how to use reusable components made by others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍一些将使我们的组件可重用的功能，这将使我们节省时间，并让我们了解如何使用他人制作的可重用组件。
- en: We will also look at some built-in components that will help you by adding additional
    functionality (compared to using HTML tags) when you build your Blazor app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看一些内置组件，这些组件在构建 Blazor 应用程序时将帮助你添加额外的功能（与使用 HTML 标签相比）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索绑定
- en: Actions and EventCallback
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作和 EventCallback
- en: Using RenderFragment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RenderFragment
- en: Exploring the new built-in components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索新内置组件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will start building our components. For this, you’ll need
    the code we developed in *Chapter 4*, *Understanding Basic Blazor Components*.
    You are good to go if you have followed the instructions in the previous chapters.
    If not, then make sure you clone/download the repository. The starting point for
    this chapter can be found in the `chapter04` folder, and the finished `chapter`
    is in `chapter05`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建我们的组件。为此，你需要我们在 *第 4 章*，*理解基本 Blazor 组件* 中开发的代码。如果你遵循了前几章的说明，那么你就可以开始了。如果没有，那么请确保你克隆/下载了存储库。本章的起点可以在
    `chapter04` 文件夹中找到，而完成的 `chapter` 在 `chapter05` 中。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05)
    找到本章结果的源代码。
- en: Exploring binding
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索绑定
- en: When building applications, data is important, and we can use binding to show
    or change data. By using binding, you can connect variables within a component
    (so that it updates automatically) or by setting a component attribute. Perhaps
    the most fantastic thing is that by using binding, Blazor understands when it
    should update the UI and the variable (if the data changes in the UI).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建应用程序时，数据很重要，我们可以使用绑定来显示或更改数据。通过使用绑定，你可以连接组件内的变量（以便自动更新）或通过设置组件属性。最神奇的是，通过使用绑定，Blazor
    能够理解何时应该更新 UI 和变量（如果 UI 中的数据发生变化）。
- en: 'In Blazor, there are two different ways that we can bind values to components,
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 中，我们可以以两种不同的方式将值绑定到组件，如下所示：
- en: One-way binding
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向绑定
- en: Two-way binding
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向绑定
- en: By using binding, we can send information between components and make sure we
    can update a value when we want to.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用绑定，我们可以在组件之间发送信息，并确保我们可以在需要时更新一个值。
- en: One-way binding
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向绑定
- en: We have already discussed one-way binding in *Chapter 4*, *Creating Basic Blazor
    Components*. Let’s look at the component again and continue building on it in
    this section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *第 4 章*，*创建基本 Blazor 组件* 中讨论了单向绑定。让我们再次查看该组件，并在本节中继续构建它。
- en: In this section, we will combine parameters and binding.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将结合参数和绑定。
- en: 'The `Counter.razor` example looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter.razor` 示例如下所示：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The component will show the current count and a button that will increment the
    current count. This is one-way binding. Even though the button can change the
    value of `currentCount`, it only flows in one direction to the screen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将显示当前计数和一个按钮，该按钮将增加当前计数。这是单向绑定。尽管按钮可以更改 `currentCount` 的值，但它只单向流向屏幕。
- en: Since this part is designed to demonstrate the functionality and theory and
    is not part of the finished project we are building, you don’t have to write or
    run this code. The source code for these components is available on GitHub.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这部分是为了演示功能性和理论，而不是我们正在构建的完整项目的一部分，因此你不需要编写或运行此代码。这些组件的源代码可在 GitHub 上找到。
- en: 'We can add a parameter to the `Counter` component. The code will then look
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `Counter` 组件添加一个参数。代码将如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code sample has two parameters, one for `CurrentCount` and one for `IncrementAmount`.
    By adding parameters to the components, we can change their behavior. This sample
    is, of course, a bit silly. The chances are that you won’t have any use for a
    component like this that just counts up when pressing a button. But it illustrates
    the idea very well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例有两个参数，一个用于`CurrentCount`，一个用于`IncrementAmount`。通过向组件添加参数，我们可以改变它们的行为。当然，这个示例有点愚蠢。你可能不会用到这种在按下按钮时只进行计数的组件。但它很好地说明了这个想法。
- en: We can now take the component and add it to another component. This is how we
    can create a reusable component and change its behavior by changing the value
    of the parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将组件添加到另一个组件中。这就是我们如何创建可重用组件并通过更改参数的值来改变其行为的方法。
- en: 'We change its behavior like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样改变它的行为：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this sample, we have two variables, `incrementamount` and `currentcount`,
    that we pass into our `CounterWithParameter` component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有两个变量，`incrementamount`和`currentcount`，我们将它们传递到我们的`CounterWithParameter`组件中。
- en: If we were to run this, we would see a `Counter` component that counts in increments
    of `10`. However, the `currentcount` variable will not be updated since it is
    only a one-way binding (one direction).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们会看到一个`Counter`组件，它会以`10`的增量进行计数。然而，`currentcount`变量将不会更新，因为它只是一个单向绑定（一个方向）。
- en: To help us with that, we can implement two-way binding so that our parent component
    will be notified of any changes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们实现这一点，我们可以实现双向绑定，这样我们的父组件就会通知任何变化。
- en: Two-way binding
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向绑定
- en: '**Two-way binding** binds values in both directions, and our `Counter` component
    will be able to notify our parent component of any changes. In the next chapter,
    *Chapter 6*, *Building Forms with Validation*, we will talk even more about two-way
    binding.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向绑定**在两个方向上绑定值，我们的`Counter`组件将能够通知父组件任何变化。在下一章，*第6章*，*使用验证构建表单*中，我们将更详细地讨论双向绑定。'
- en: 'To make our `CounterWithParameter` component bind in two directions, we need
    to add an `EventCallback`. The name must consist of the parameter’s name followed
    by `Changed`. This way, Blazor will update the value if it changes. In our case,
    we would need to name it `CurrentCountChanged`. The code would then look like
    this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的`CounterWithParameter`组件进行双向绑定，我们需要添加一个`EventCallback`。名称必须由参数的名称后跟`Changed`组成。这样，Blazor就会在值发生变化时更新值。在我们的例子中，我们需要将其命名为`CurrentCountChanged`。代码将如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By merely using that naming convention, Blazor knows that `CurrentCountChanged`
    is the event that will get triggered when a change to `CurrentCount` occurs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅使用该命名约定，Blazor就知道`CurrentCountChanged`是当`CurrentCount`发生变化时将被触发的事件。
- en: '`EventCallback` cannot be `null`, so there is no reason to do a null check
    (more on that in the next section).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventCallback`不能为`null`，因此没有必要进行空检查（更多内容将在下一节中介绍）。'
- en: 'We also need to change how we listen for changes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改我们监听变化的方式：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to add `@bind-` before the `CurrentCount` binding. You can also use
    the following syntax to set the name of the event:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`CurrentCount`绑定前添加`@bind-`前缀。您也可以使用以下语法来设置事件的名称：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using `:event`, we can tell Blazor exactly what event we want to use; in
    this case, the `CurrentCountChanged` event.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`:event`，我们可以告诉Blazor我们想要使用哪个事件；在这种情况下，是`CurrentCountChanged`事件。
- en: In the next chapter, *Chapter 6*, *Building Forms with Validation*, we will
    continue to look at binding with input/form components.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*第6章*，*使用验证构建表单*中，我们将继续探讨与输入/表单组件的绑定。
- en: We can, of course, also create events using **EventCallback**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然也可以使用**EventCallback**创建事件。
- en: Actions and EventCallback
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作和EventCallback
- en: To communicate changes, we can use **EventCallback**, as shown in the *Two-way
    binding* section. `EventCallback<T>` differs a bit from what we might be used
    to in .NET. `EventCallback<T>` is a class that is specially made for Blazor to
    be able to have the event callback exposed as a parameter for the component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通信变化，我们可以使用**EventCallback**，如*双向绑定*部分所示。`EventCallback<T>`与我们在.NET中可能习惯的有所不同。`EventCallback<T>`是一个专门为Blazor设计的类，以便将事件回调暴露为组件的参数。
- en: In .NET, in general, you can add multiple listeners to an event (multi-cast),
    but with `EventCallback<T>`, you will only be able to add one listener (single-cast).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，通常可以给事件添加多个监听器（多播），但使用`EventCallback<T>`，你只能添加一个监听器（单播）。
- en: 'It is worth mentioning that you can use events the way you are used to from
    .NET in Blazor. However, you probably want to use `EventCallback<T>` because there
    are many upsides to using `EventCallback` over traditional .NET events, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可以像在.NET中一样使用事件。然而，你可能想使用`EventCallback<T>`，因为与传统的.NET事件相比，使用`EventCallback`有很多优点，如下所示：
- en: .NET events use classes, and `EventCallback` uses structs. This means that in
    Blazor, we don’t have to perform a null check before calling `EventCallback` because
    a struct cannot be null.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET事件使用类，而`EventCallback`使用结构体。这意味着在Blazor中，我们不需要在调用`EventCallback`之前执行空检查，因为结构体不能为空。
- en: '`EventCallback` is asynchronous and can be awaited. When `EventCallback` has
    been called, Blazor will automatically execute `StateHasChanged` on the consuming
    component to ensure the component updates (if it needs to be updated).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventCallback`是异步的，并且可以被等待。当`EventCallback`被调用时，Blazor将自动在消费组件上执行`StateHasChanged`以确保组件更新（如果需要更新）。'
- en: So, if you require multiple listeners, you can use `Action<T>`. Otherwise, it
    would be best if you used `EventCallback<T>`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你需要多个监听器，你可以使用`Action<T>`。否则，最好使用`EventCallback<T>`。
- en: Some event types have event arguments that we can access. They are optional,
    so you don’t need to add them in most cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件类型具有我们可以访问的事件参数。它们是可选的，所以在大多数情况下你不需要添加它们。
- en: 'You can add them by specifying them in a method, or you can use a lambda expression
    like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方法中指定它们来添加它们，或者你可以使用像这样的lambda表达式：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the `button` is clicked, it will set a variable called `message` to a string
    containing the mouse coordinates. The lambda has one parameter, `e`, of the `MouseArgs`
    type. However, you don’t have to specify the type, and the compiler understands
    what type the parameter is.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击`button`时，它将设置一个名为`message`的变量，该变量包含鼠标坐标的字符串。Lambda表达式有一个参数`e`，其类型为`MouseArgs`。然而，你不必指定类型，编译器会理解参数的类型。
- en: Now that we have added actions and used **EventCallback** to communicate changes,
    we will see how we can execute **RenderFragment** in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了操作并使用**EventCallback**来通信更改，我们将在下一节中看到如何执行**RenderFragment**。
- en: Using RenderFragment
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RenderFragment
- en: To make our components even more reusable, we can supply them with a piece of
    Razor syntax. In Blazor, you can specify **RenderFragment**, which is a fragment
    of Razor syntax that you can execute and show.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的组件更加可重用，我们可以向它们提供一段Razor语法。在Blazor中，你可以指定**RenderFragment**，这是一个你可以执行并显示的Razor语法片段。
- en: There are two types of render elements, `RenderFragment` and `RenderFragment<T>`.
    `RenderFragment` is simply a Razor fragment without any input parameters, and
    `RenderFragment<T>` has an input parameter that you can use inside the Razor fragment
    code by using the `context` keyword. We won’t go into depth about how to use this
    now, but later in this chapter, we will talk about a component (**Virtualize**)
    that uses `RenderFragment<T>`, and in the next chapter, *Chapter 6*, *Building
    Forms with Validation*, we will implement a component using `RenderFragment<T>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的渲染元素，`RenderFragment`和`RenderFragment<T>`。`RenderFragment`是一个没有输入参数的简单Razor片段，而`RenderFragment<T>`有一个输入参数，你可以在Razor片段代码中使用`context`关键字来使用它。我们现在不会深入讨论如何使用它，但在本章的后面，我们将讨论一个使用`RenderFragment<T>`的组件（**Virtualize**），在下一章（第6章），我们将实现一个使用`RenderFragment<T>`的组件。
- en: We can make `RenderFragment` the default content inside of the component tags
    as well as giving it a default value. We will explore this next and build a component
    using these features.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`RenderFragment`作为组件标签内的默认内容，同时也可以给它一个默认值。我们将在下一节中探讨这一点，并使用这些特性构建一个组件。
- en: 'When using components in a list, it can add some overhead. It needs to execute
    the whole lifetime cycle for each component. Here is where render fragments come
    to the rescue. We can create a method that returns a render fragment without the
    overhead of a component. Take this example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当在列表中使用组件时，它可能会增加一些开销。它需要为每个组件执行整个生命周期。这就是渲染片段发挥作用的地方。我们可以创建一个返回渲染片段的方法，而不需要组件的开销。以下是一个例子：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have a component with a method that returns a render fragment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个返回渲染片段的方法的组件。
- en: The method could be static if we needed to use it in other components as well.
    When doing a loop like this, it will boost performance and will have a lower impact
    on memory consumption compared to having a component reference.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在其他组件中使用它，这个方法可以是静态的。当进行这样的循环时，它将提高性能，并且与有组件引用相比，对内存消耗的影响更低。
- en: '**GRID COMPONENT**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格组件**'
- en: If you want to dig deeper into render fragments, please check out **Blazm.Components**,
    which have a grid component that heavily uses `RenderFragment<T>`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解渲染片段，请查看 **Blazm.Components**，它有一个使用 `RenderFragment<T>` 的网格组件。
- en: 'You can find it on GitHub here: [https://github.com/EngstromJimmy/Blazm.Components](https://github.com/EngstromJimmy/Blazm.Components).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到它：[https://github.com/EngstromJimmy/Blazm.Components](https://github.com/EngstromJimmy/Blazm.Components)。
- en: ChildContent
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子内容
- en: By naming the render fragment `ChildContent`, Blazor will automatically use
    whatever is between the component tags as content. This only works, however, if
    you are using a single render fragment; if you are using more than one, you will
    have to specify the `ChildComponent` tag as well. We will build a component using
    a `childcontent` render fragment in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将渲染片段命名为 `ChildContent`，Blazor 将自动使用组件标签之间的任何内容。然而，这仅在您使用单个渲染片段时才有效；如果您使用多个，您还必须指定
    `ChildComponent` 标签。我们将在下一节中构建一个使用 `childcontent` 渲染片段的组件。
- en: Default value
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值
- en: 'We can supply `RenderFragment` with a default value or set it in code by using
    an `@` symbol:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供带有默认值的 `RenderFragment` 或通过使用 `@` 符号在代码中设置它：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building an alert component
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个警报组件
- en: To better understand how to use render fragments, let’s build an alert component
    that will use render fragments. The built-in templates use Bootstrap, so we will
    do the same for this component. Bootstrap has many components that are easy to
    import to Blazor. When working on big projects with multiple developers, building
    components is an easy way to ensure that everyone in a team is writing code the
    same way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用渲染片段，让我们构建一个将使用渲染片段的警报组件。内置模板使用 Bootstrap，因此我们将为此组件做同样的事情。Bootstrap
    有许多组件很容易导入到 Blazor 中。当在大型项目上与多个开发者合作时，构建组件是确保团队中每个人以相同方式编写代码的简单方法。
- en: 'Let’s build a simple alert component based on Bootstrap:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于 Bootstrap 构建一个简单的警报组件：
- en: Create a folder by right-clicking on `SharedComponents project`| **Add** | **New
    folder** and name the folder `ReusableComponents`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `SharedComponents 项目` 上右键单击并选择 **添加** | **新建文件夹** 来创建一个文件夹，并将其命名为 `ReusableComponents`。
- en: Create a new Razor component and name it `Alert.razor`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Razor 组件，并将其命名为 `Alert.razor`。
- en: 'Replace the content with the following code in the `Alert.razor` file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Alert.razor` 文件中，将内容替换为以下代码：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code is taken from Bootstrap’s web page, [http://getbootstrap.com](http://getbootstrap.com),
    and it shows an alert that looks like this:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码是从 Bootstrap 的网页 [http://getbootstrap.com](http://getbootstrap.com) 复制的，它显示了一个看起来像这样的警报：
- en: '![Figure 5.1 – The default look of a Bootstrap alert component ](img/B21849_05_01.png)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.1 – Bootstrap 警报组件的默认外观](img/B21849_05_01.png)'
- en: 'Figure 5.1: The default look of a Bootstrap alert component'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.1：Bootstrap 警报组件的默认外观
- en: There are two ways in which we could customize this `alert` component. We could
    add a `string` parameter for the message.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式自定义这个 `alert` 组件。我们可以添加一个 `string` 参数用于消息。
- en: However, since this is a section on render fragments, we will explore the second
    option – yes, you guessed it, *render fragments*.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，由于这是一个关于渲染片段的部分，我们将探索第二种选项——是的，你已经猜到了，*渲染片段*。
- en: 'Add a code section with a `RenderFragment` property called `ChildContent` and
    replace the alert text with the new property:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有 `RenderFragment` 属性的代码部分，并将其命名为 `ChildContent`，并用新属性替换警报文本：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we have a `RenderFragment` and set a default value, displaying the fragment
    between the `div` tags. We also want to add an `enum` for the different ways you
    can style the alert box.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个 `RenderFragment` 并设置了一个默认值，在 `div` 标签之间显示片段。我们还想添加一个 `enum` 来表示不同的样式化警报框的方式。
- en: 'In the `code` section, add an `enum` containing the different styles available:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `代码` 部分，添加一个包含不同样式的 `enum`：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a parameter/property for the `enum` style:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `enum` 风格添加一个参数/属性：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final step is to update the `class` attribute for `div`. Change the `class`
    attribute to look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是更新 `div` 的 `class` 属性。将 `class` 属性更改为以下样子：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `SharedComponents` project, in the `Pages` folder, create a new razor
    component and name it `AlertTest.razor`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，在 `Pages` 文件夹中，创建一个新的 razor 组件，并将其命名为 `AlertTest.razor`。
- en: 'Replace the code with the following snippet:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将代码替换为以下片段：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The page shows three alert components:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面显示了三个警报组件：
- en: The first one has the `Danger` style, and we are not specifying what property
    to set for the `This is a test` text, but by convention, it will use the property
    called `ChildContent`.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个具有 `Danger` 风格，我们没有指定为 `This is a test` 文本设置哪个属性，但按照惯例，它将使用名为 `ChildContent`
    的属性。
- en: In the second one, we have specified the `ChildContent` property. If you use
    more render fragments in your component, you must set them like this, with full
    names.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二个中，我们指定了 `ChildContent` 属性。如果你在组件中使用更多的渲染片段，你必须像这样设置它们，使用全名。
- en: In the last one, we didn’t specify anything that will give the property the
    default render fragment we specified in the component.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一个中，我们没有指定任何内容，这将给属性赋予我们在组件中指定的默认渲染片段。
- en: 'Run the `BlazorServer` project and navigate to `/AlertTest` to see the test
    page:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `BlazorServer` 项目并导航到 `/AlertTest` 以查看测试页面：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_05_02.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图，描述自动生成](img/B21849_05_02.png)'
- en: 'Figure 5.2: Screenshot of the test page'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：测试页面的截图
- en: We have finished our first reusable component!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的第一个可重用组件！
- en: Creating reusable components is how I prefer to make my Blazor sites because
    I don’t have to write the same code twice. This becomes even more apparent if
    you are working in a larger team. It makes it easier for all developers to produce
    the same code and end result, and with that, they can get a higher code quality
    and require fewer tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可重用组件是我更喜欢用来制作我的 Blazor 网站的方式，因为我不必写两次相同的代码。如果你在一个更大的团队中工作，这一点会更加明显。这使得所有开发者都能产生相同的代码和最终结果，并且通过这种方式，他们可以获得更高的代码质量并减少测试需求。
- en: When we upgraded to the latest Bootstrap version, a few CSS classes were deprecated
    and replaced by others. Thankfully, we followed this approach by making reusable
    components, so we only had to change a handful of places. There were a couple
    of places where we still had some old code base (not using components), and it
    became very apparent that creating components was worth the effort.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们升级到最新的 Bootstrap 版本时，一些 CSS 类已被弃用并由其他类替换。幸运的是，我们通过创建可重用组件来遵循这种方法，所以我们只需要更改几个地方。有几个地方我们仍然有一些旧的代码库（未使用组件），这变得非常明显，创建组件是值得努力的。
- en: Blazor has a bunch of built-in components. In the next section, we will dig
    deeper into what they are and how to use them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 有很多内置组件。在下一节中，我们将深入了解它们是什么以及如何使用它们。
- en: When it comes to reusable components, we really invest some time in that. If
    you find yourself writing the same code twice, you might want to add that into
    a component. At my old job, we started using `Radzen`, an open-source component
    library (among other things). At my current job, we use `MudBlazor`. We use `Progress
    Telerik` on our stream. Using third-party components can speed up the development,
    but often, these components are built for many different users. They can do a
    lot of things. This means that every single developer on our team now has access
    to all that power. With great power comes great responsibility.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到可重用组件时，我们在那上面投入了相当多的时间。如果你发现自己正在写两次相同的代码，你可能想把它添加到一个组件中。在我以前的工作中，我们开始使用
    `Radzen`，这是一个开源的组件库（以及其他一些东西）。在我目前的工作中，我们使用 `MudBlazor`。我们在流中使用 `Progress Telerik`。使用第三方组件可以加快开发速度，但通常，这些组件是为许多不同的用户构建的。它们可以做很多事情。这意味着我们团队上的每个开发者现在都可以访问所有这些力量。权力越大，责任越大。
- en: In one of my presentations, I had that quote with a picture of Batman and text
    saying “Superman.” I didn’t get a single reaction. I have never failed with a
    joke like that. But joking aside, this means that all developers need to keep
    in mind how to use the components. Otherwise, the UI might look different depending
    on which developer uses the components. I put a lot of time into designing reusable
    components that help the team to be productive. Hiding the parameters we don’t
    use, giving the components reasonable default values. So, even if you use third-party
    components, try to figure out what you are using and perhaps create an abstraction
    on top of the third-party components. If you don’t know, the quote is from Spiderman,
    or Uncle Ben, to be precise. But it did remind me of one of my favorite puns.
    Do you know why Spiderman always has such witty comebacks? Because with great
    power comes great response-ability. I will show myself out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的一次演讲中，我引用了这句话，配图是蝙蝠侠，文字写着“超人”。我没有得到任何反应。我从未用这样的笑话失败过。但开个玩笑，这意味着所有开发者都需要记住如何使用组件。否则，UI
    可能会因为使用组件的开发者不同而看起来不同。我投入了很多时间来设计可重用组件，帮助团队提高生产力。隐藏我们不使用的参数，为组件提供合理的默认值。所以，即使你使用第三方组件，也尽量弄清楚你在使用什么，也许可以在第三方组件之上创建一个抽象层。如果你不知道，这句话来自蜘蛛侠，或者更准确地说，是本叔叔。但它确实让我想起了我最喜欢的双关语。你知道为什么蜘蛛侠总是有如此机智的回应吗？因为能力越大，责任越大。我要退场了。
- en: Exploring the new built-in components
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索新的内置组件
- en: When Blazor first came out, there were a couple of things that were hard to
    do, and, in some cases, we needed to involve JavaScript to solve the challenge.
    In this section, we will look at some of the new components we got in .NET 5,
    all the way to .NET 8.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Blazor 首次推出时，有几件事情很难做，在某些情况下，我们需要涉及 JavaScript 来解决挑战。在本节中，我们将查看我们在 .NET 5
    到 .NET 8 中获得的一些新组件。
- en: 'We will take a look at the following new components or functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看以下新组件或函数：
- en: Setting the focus of the UI
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 UI 的焦点
- en: Influencing the HTML head
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响 HTML 头部
- en: Component virtualization
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件虚拟化
- en: Error boundaries
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误边界
- en: Sections
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分
- en: Setting the focus of the UI
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 UI 的焦点
- en: One of my first Blazor blog posts was about how to set the focus on a UI element,
    but now this is built into the framework. The previous solution involved JavaScript
    calls to change the focus on a UI element.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一篇 Blazor 博客文章是关于如何在 UI 元素上设置焦点，但现在这已经内置到框架中了。之前的解决方案涉及对 UI 元素的 JavaScript
    调用来更改焦点。
- en: By using `ElementReference`, you can now set the focus on the element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `ElementReference`，你现在可以设置元素的焦点。
- en: 'Let’s build a component to test the behavior of this new feature:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个组件来测试这个新特性的行为：
- en: In the `SharedComponents` project, in the `Pages` folder, add a new Razor component,
    and name it `SetFocus.razor`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，在 `Pages` 文件夹中，添加一个新的 Razor 组件，并将其命名为 `SetFocus.razor`。
- en: 'Open `SetFocus.razor` and add a `page` directive:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SetFocus.razor` 并添加一个 `page` 指令：
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add an element reference:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个元素引用：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ElementReference` is precisely what it sounds like, a reference to an element.
    In this case, it is an input textbox.'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ElementReference` 就像它的名字一样，是对一个元素的引用。在这种情况下，它是一个输入文本框。'
- en: 'In the `_Imports` file, add the following line:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `_Imports` 文件中，添加以下行：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the textbox and a button:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加文本框和按钮：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using `@ref`, we specify a reference to any type of component or tag that we
    can use to access the input box. The `button onclick` method will execute the
    `FocusAsync()` method and set the focus on the textbox.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `@ref`，我们指定了对任何类型组件或标签的引用，我们可以使用它来访问输入框。`button onclick` 方法将执行 `FocusAsync()`
    方法并将焦点设置在文本框上。
- en: Press *F5* to run the project and then navigate to `/setfocus`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F5* 运行项目，然后导航到 `/setfocus`。
- en: Press the **Set focus** button and notice how the textbox gets its focus.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **设置焦点** 按钮，注意文本框如何获得焦点。
- en: It could seem like a silly example since this only sets the focus, but it is
    a handy feature, and the `autofocus` HTML attribute won’t work for Blazor. It
    would make more sense to call `FocusAsync` in the `OnAfterRender` method to get
    the focus change when we load the page, but that wouldn’t make it as cool a demo.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能看起来很愚蠢，因为它只设置了焦点，但这是一个实用的功能，而 `autofocus` HTML 属性在 Blazor 中不起作用。在 `OnAfterRender`
    方法中调用 `FocusAsync` 以在页面加载时获取焦点更改会更合理，但这不会让演示变得那么酷。
- en: In my blog post, I had another approach. My goal was to set the focus of an
    element without having to use code. In the upcoming chapter, *Chapter 6*, *Building
    Forms with Validation*, we will implement the `autofocus` feature from my blog
    post but use the new .NET features instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的博客帖子中，我采取了另一种方法。我的目标是设置一个元素的焦点，而无需使用代码。在即将到来的第6章，*使用验证构建表单*中，我们将实现我的博客帖子中的`autofocus`功能，但使用新的.NET功能。
- en: The release of .NET 5 solves many things we previously had to write with JavaScript;
    setting the focus is one example. In .NET 6, we have a way to influence the HTML
    head.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5的发布解决了我们之前必须用JavaScript编写的一些问题；设置焦点就是一个例子。在.NET 6中，我们有一种方法可以影响HTML头。
- en: Influencing the HTML head
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响`HTML head`
- en: Sometimes, we want to set our page’s title or change the social network meta
    tags. The `head` tag is located in the `App` component, and that part of the page
    isn’t reloaded/rerendered (only the components within the routes component are
    rerendered). In previous versions of Blazor, you had to write code for that yourself
    using JavaScript.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要设置页面的标题或更改社交网络`meta`标签。`head`标签位于`App`组件中，页面这部分不会重新加载/重新渲染（只有路由组件内的组件会重新渲染）。在Blazor的早期版本中，你必须自己使用JavaScript编写代码来实现这一点。
- en: But .NET has a new component called `HeadOutlet` that can solve that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但.NET有一个名为`HeadOutlet`的新组件可以解决这个问题。
- en: 'To use these components, we will create a page to view one of our blog posts.
    And we will use many of the techniques we have learned:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些组件，我们将创建一个页面来查看我们的博客帖子之一。我们将使用我们学到的大多数技术：
- en: In the `SharedComponents` project, open `Home.razor`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，打开`Home.razor`。
- en: 'Change the `foreach` loop to look like this:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`foreach`循环修改如下：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We added a link to the title to look at one blog post. Notice how we can use
    the `@` symbol inside the `href` attribute to get the ID of the post.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在标题中添加了一个链接来查看一个博客帖子。注意我们如何在`href`属性内部使用`@`符号来获取帖子的ID。
- en: In the Pages folder, add a Razor component, and name it `Post.razor`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pages`文件夹中，添加一个Razor组件，并将其命名为`Post.razor`。
- en: 'In the `code` section, add a parameter that will hold the ID of the post:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`code`部分中，添加一个参数来保存帖子的ID：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will hold the ID of the blog post that comes from the URL.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将保存来自URL的博客帖子的ID。
- en: 'Add a `page` directive to get the set, the URL, and the ID:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`page`指令以获取集合、URL和ID：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `page` directive will set the URL for our blog post to `/post/`, followed
    by the ID of the post. We don’t have to add a `using` statement to all our components.
    Instead, open `_Imports.razor` and add the following namespaces:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`page`指令将为我们的博客帖子设置URL为`/post/`，后跟帖子的ID。我们不必在所有组件中添加`using`语句。相反，打开`_Imports.razor`并添加以下命名空间：'
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will ensure that all our components will have these namespaces by default.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将确保所有我们的组件默认具有这些命名空间。
- en: 'Open `Post.razor` again and, just beneath the `page` directive, inject the
    API (the namespace is now supplied from `_Imports.razor`):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开`Post.razor`，在`page`指令下方注入API（命名空间现在由`_Imports.razor`提供）：
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our API will now be injected into the component, and we can retrieve our blog
    post. We also have access to a navigation manager.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将API注入到组件中，我们可以检索我们的博客帖子。我们还可以访问导航管理器。
- en: 'In the `code` section, add a property for our blog post:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`code`部分中，为我们的博客帖子添加一个属性：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will contain the blog post we want to show on the page.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将包含我们想在页面上显示的博客帖子。
- en: 'To load the blog post, add the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要加载博客帖子，请添加以下代码：
- en: '[PRE25]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, we are using the `OnParametersSetAsync()` method. This is to make
    sure that the parameter is set when we get data from the database and that the
    content updates when the parameter changes.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`OnParametersSetAsync()`方法。这是为了确保我们在从数据库获取数据时设置参数，并且当参数更改时内容会更新。
- en: 'We must also show the post and add the necessary `meta` tags. To do that, add
    the following code just above the `code` section:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须在帖子中显示并添加必要的`meta`标签。为此，只需在`code`部分上方添加以下代码：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the page is first loaded, the `BlogPost` parameter can be null, so we first
    need to check whether we should show the content at all.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当页面首次加载时，`BlogPost`参数可能为空，因此我们首先需要检查是否应该显示内容。
- en: By adding the `Title` component, Blazor will set the title of our site to, in
    this instance, the title of our blog post.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加`Title`组件，Blazor将设置我们网站的标题，在本例中是博客帖子的标题。
- en: According to the information I gathered on **Search Engine Optimization** (**SEO**),
    the meta tags we have added are the bare minimum to use with Facebook and X (formerly
    known as Twitter). We don’t have an image for each blog post, but we can have
    one that is site-wide (for all blog posts) if we would like. Just change `Pathtoanimage.png`
    to the name of the image and put the image in the `wwwroot` folder.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据我收集的关于 **搜索引擎优化**（**SEO**）的信息，我们添加的元标签是使用 Facebook 和 X（以前称为 Twitter）时所需的最基本内容。我们没有为每篇博客文章添加图片，但如果我们愿意，我们可以有一个网站范围内的图片（适用于所有博客文章）。只需将
    `Pathtoanimage.png` 更改为图片名称，并将图片放入 `wwwroot` 文件夹中。
- en: If the blog post is loaded, then show an `H3` tag with the title and the text
    beneath that. You might remember `MarkupString` from *Chapter 4*, *Understanding
    Basic Blazor Components*. This will output the string from our blog post without
    changing the HTML (not escaping the HTML).
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果加载了博客文章，则显示一个带有标题和下方文本的 `H3` 标签。你可能还记得来自 *第 4 章*，*理解基本 Blazor 组件* 中的 `MarkupString`。这将输出我们博客文章中的字符串，而不会更改
    HTML（不会转义 HTML）。
- en: 'Run the project by pressing *F5* and navigate to a blog post to see the title
    change:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *F5* 键运行项目，并导航到一篇博客文章，可以看到标题的变化：
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_05_03.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21849_05_03.png)'
- en: 'Figure 5.3: Blog post screenshot'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：博客文章截图
- en: Our blog is starting to take form. We have a list of blog posts, and can view
    a single post; we are far from done but we’re well on our way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的博客开始成形。我们有一个博客文章列表，可以查看单个文章；我们还有很长的路要走，但我们已经走上了正轨。
- en: Component virtualization
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件虚拟化
- en: '**Virtualize** is a component in Blazor that will make sure that it only renders
    the components or rows that can fit the screen. If you have a large list of items,
    rendering all of them will have a big impact on memory.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Virtualize** 是 Blazor 中的一个组件，它将确保只渲染可以适应屏幕的组件或行。如果你有一个包含大量项的列表，渲染所有这些项将对内存产生重大影响。'
- en: Many third-party component vendors offer grid components with the same virtualization
    function. The `Virtualize` component was, in my opinion, the most exciting thing
    in the .NET 5 release.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 许多第三方组件供应商提供具有相同虚拟化功能的网格组件。在我看来，`Virtualize` 组件是 .NET 5 版本中最令人兴奋的事情之一。
- en: The `Virtualize` component will calculate how many items can fit on the screen
    (based on the size of the window and the height of an item). Blazor will add a
    `div` tag before and after the content list if you scroll the page, ensuring that
    the scrollbar is showing the correct position and scale (even though there are
    no items rendered).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Virtualize` 组件将计算屏幕上可以容纳多少项（基于窗口大小和项的高度）。如果你滚动页面，Blazor 将在内容列表前后添加一个 `div`
    标签，确保滚动条显示正确的位置和比例（即使没有渲染任何项）。'
- en: The `Virtualize` component works just like a `foreach` loop.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Virtualize` 组件的工作方式与 `foreach` 循环类似。'
- en: 'The following is the code we currently have in our `Home.razor` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们目前在 `Home.razor` 文件中的代码：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Right now, it will show all our blog posts in our database in a long list. Granted,
    we only have a few right now, but we might have many posts one day.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它将显示我们数据库中的所有博客文章的长列表。诚然，我们现在只有几个，但有一天我们可能会有很多文章。
- en: 'We can change the code (don’t change the code just yet) to use the new `Virtualize`
    component by changing it to the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将代码（现在不要更改代码）更改为使用新的 `Virtualize` 组件，将其更改为以下内容：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Instead of the `foreach` loop, we use the `Virtualize` component and add a render
    fragment that shows how each item should be rendered. The `Virtualize` component
    uses `RenderFragment<T>`, which, by default, will send in an item of type `T`
    to the render fragment. In the case of the `Virtualize` component, the object
    will be one blog post (since items are `List<T>` of blog posts). We access each
    post with the variable named `context`. However, we can use the `Context` property
    on the `Virtualize` component to specify another name, so instead of `context`,
    we are now using `p`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用 `foreach` 循环，而是使用 `Virtualize` 组件并添加一个渲染片段，以显示每个项应该如何渲染。`Virtualize`
    组件使用 `RenderFragment<T>`，默认情况下，它将发送类型为 `T` 的项到渲染片段。在 `Virtualize` 组件的情况下，对象将是一篇博客文章（因为项是博客文章的
    `List<T>`）。我们使用名为 `context` 的变量访问每篇文章。然而，我们可以在 `Virtualize` 组件上使用 `Context` 属性来指定另一个名称，因此我们现在使用的是
    `p` 而不是 `context`。
- en: 'The `Virtualize` component is even more powerful than this, as we will see
    in the next feature that we implement:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Virtualize` 组件比这更强大，正如我们将在下一个要实现的功能中看到的那样：'
- en: In the `SharedComponents` project, open `Home.razor`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedComponents` 项目中，打开 `Home.razor`。
- en: Delete the `OnInitializedAsync` method and `protected List<BlogPost> posts =
    new List<BlogPost>()`; we don’t need them anymore.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`OnInitializedAsync`方法和`protected List<BlogPost> posts = new List<BlogPost>()`；我们不再需要它们了。
- en: 'Change the loading of the post to `Virtualize`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将帖子的加载改为`Virtualize`：
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, we are using the `ItemsProvider` delegate, which will take care
    of getting posts from our API.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`ItemsProvider`委托，它将负责从我们的API获取帖子。
- en: We pass in a method called `LoadPosts`, which we also need to add to the file.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们传递一个名为`LoadPosts`的方法，我们还需要将其添加到文件中。
- en: 'Now, let’s add the `LoadPosts` method by adding the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下代码来添加`LoadPosts`方法：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will add a `totalBlogposts` property where we store how many posts we currently
    have in our database. The `LoadPost` method returns `ValueTask` with `ItemsProviderResult<Blogpost>`.
    The method has `ItemsProviderRequest` as a parameter, which contains the number
    of posts the `Virtualize` component wants and how many it wants to skip.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在数据库中添加一个`totalBlogposts`属性，用于存储我们目前拥有的帖子数量。`LoadPost`方法返回带有`ItemsProviderResult<Blogpost>`的`ValueTask`。该方法以`ItemsProviderRequest`作为参数，其中包含`Virtualize`组件想要的帖子数量以及它想要跳过的数量。
- en: If we don’t know how many total posts we have, we need to retrieve that information
    from our API by calling the `GetBlogPostCountAsync` method. Then, we need to figure
    out how many posts we should get; either we get as many posts as we need, or we
    get all the remaining posts (whatever value is the smallest).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道总共有多少帖子，我们需要通过调用`GetBlogPostCountAsync`方法从我们的API检索该信息。然后，我们需要确定我们应该获取多少帖子；要么获取我们需要的所有帖子，要么获取所有剩余的帖子（无论值是多少）。
- en: Then, we call our API to get the actual posts by calling `GetBlogPostsAsync`
    and returning `ItemsProviderResult`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`GetBlogPostsAsync`并返回`ItemsProviderResult`来调用我们的API获取实际的帖子。
- en: We have implemented a `Virtualize`component that will load and render only the
    number of blog posts needed to fill the screen. But this is an interactive component
    that needs interactivity to work. If you try to run the project now, you will
    notice that the screen is blank. If we add `@rendermode InteractiveServer` to
    the `Home` component, it starts to work again. Right now, `InteractiveServer`
    is the only thing we can use. This is the only scenario we have everything set
    up for when it comes to DI.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个`Virtualize`组件，它将只加载和渲染填充屏幕所需的博客帖子数量。但这是一个需要交互才能工作的交互式组件。如果你现在尝试运行项目，你会注意到屏幕是空的。如果我们向`Home`组件添加`@rendermode
    InteractiveServer`，它就会再次开始工作。目前，`InteractiveServer`是我们唯一能用的东西。这是我们在DI方面设置好的唯一场景。
- en: Error boundaries
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误边界
- en: In .NET 6, we have a very handy component to handle errors called **ErrorBoundary**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6中，我们有一个非常方便的组件来处理错误，称为**ErrorBoundary**。
- en: 'We can surround the component with an `ErrorBoundary` component; if an error
    occurs, it will show an error message instead of the whole page failing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`ErrorBoundary`组件包围组件；如果发生错误，它将显示错误消息而不是整个页面失败：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This component takes two render fragments. By specifying it as in the previous
    example, we only set the `ChildContent` render fragment. This is the default.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件接受两个渲染片段。通过指定如前例所示，我们只设置了`ChildContent`渲染片段。这是默认的。
- en: 'We can also supply a custom error message like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以提供自定义的错误消息，如下所示：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this sample, we specify `ChildContent`, which makes it possible for us to
    specify more than one property, as is the case with `ErrorContent`. This is a
    great component to extend and create your own functionality. You can get access
    to the exception by using the `context` parameter (as we did with `virtualize`):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们指定了`ChildContent`，这使得我们能够指定多个属性，就像`ErrorContent`一样。这是一个很好的组件，可以扩展并创建自己的功能。您可以通过使用`context`参数（就像我们在`virtualize`中做的那样）来访问异常：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a great way to handle errors in the UI.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在UI中处理错误的好方法。
- en: Sections
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分
- en: .NET 8 gives us the ability to add sections. You might remember a similar feature
    of `WebForms`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8为我们提供了添加部分的能力。你可能还记得`WebForms`中类似的特性。
- en: We can use the `SectionOutlet` component to define an area in a layout component
    where we want to insert content. Then, inside our components, we can add a `SectionContent`
    where we add the content we want to appear in the outlet.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SectionOutlet`组件在布局组件中定义一个区域，我们想在其中插入内容。然后，在我们的组件内部，我们可以添加一个`SectionContent`，在其中添加我们想要在出口中显示的内容。
- en: If we have more than one `SectionContent` referencing the `SectionOutlet`, it
    will render the latest `SectionContent`. We can refer to a `SectionOutlet` by
    using a section name or a section ID. A section name is simply a string that we
    can use. The ID is an object, so we can get a nicer syntax to keep track of our
    sections.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个以上的 `SectionContent` 引用了 `SectionOutlet`，它将渲染最新的 `SectionContent`。我们可以通过使用部分名称或部分
    ID 来引用一个 `SectionOutlet`。部分名称只是一个我们可以使用的字符串。ID 是一个对象，因此我们可以获得更优雅的语法来跟踪我们的部分。
- en: We can add a section to the layout file and add content to that section from
    our components. It’s a layout thing. Let’s say we want to add contextual menus.
    For example, that way, we could change a menu that is in a completely different
    component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在布局文件中添加一个部分，并从我们的组件中添加内容到该部分。这是一个布局问题。假设我们想添加上下文菜单。例如，这样我们就可以更改一个完全不同的组件中的菜单。
- en: Let’s look at some code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码。
- en: 'First, we might need to add this namespace:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可能需要添加这个命名空间：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Preferably in the _imports.razor file (since this is one of the build-in components.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在 `_imports.razor` 文件中（因为这是内置组件之一）。
- en: 'In a layout component, we add an outlet like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局组件中，我们添加一个出口，如下所示：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, in our component, we can add a `SectionContent` like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的组件中，我们可以添加一个 `SectionContent`，如下所示：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we instead want to use the section ID, we can do it like this: In the layout
    file, let’s assume it is called `MainLayout`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用部分 ID，可以这样做：在布局文件中，假设它被命名为 `MainLayout`。
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the code section of `MainLayout`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainLayout` 的代码部分：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, inside the component, we change it to this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在组件内部，我们将其更改为这样：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is a great way to change the layout files. By doing this, we can create
    more advanced layouts that work with every page/component. We can move more of
    the layout to the layout file instead of putting it in each component. I love
    this feature. This will clean up so much code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种改变布局文件的好方法。通过这样做，我们可以创建更高级的布局，这些布局可以与每个页面/组件一起工作。我们可以将更多的布局移动到布局文件中，而不是将其放在每个组件中。我喜欢这个功能。这将清理掉很多代码。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at more advanced scenarios for building components.
    Building components is what Blazor is all about. Components also make it easy
    to make changes along the way because there is only one point where you must implement
    the change. We also implemented our first reusable component, which will help
    maintain the same standard across the team and reduce duplicated code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了构建组件的更高级场景。构建组件正是 Blazor 的核心所在。组件还使得在过程中进行更改变得容易，因为只有一个地方必须实现更改。我们还实现了我们的第一个可重用组件，这将有助于在整个团队中保持相同的标准并减少重复代码。
- en: We also used some Blazor features to load and display data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一些 Blazor 功能来加载和显示数据。
- en: In the next chapter, we will look at forms and validation to start building
    the administration part of our blog.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨表单和验证，以开始构建我们博客的管理部分。
- en: Join our community on Discord
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
- en: '![](img/QR_Code2668029180838459906.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2668029180838459906.png)'
