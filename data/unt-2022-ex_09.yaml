- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Introduction to Object Pooling in Unity 2022
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 2022中对象池的介绍
- en: In [*Chapter 5*](B18347_05.xhtml#_idTextAnchor096), we imported and prepped
    artwork for use with additional 2D animation tooling, which is bringing the game
    to life. We also processed player input using an input action map – instead of
    reading device input directly – with the new Input System, and we made a `PlayerController`
    script to move the player.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18347_05.xhtml#_idTextAnchor096)中，我们导入并准备了艺术作品以用于额外的2D动画工具，这使游戏栩栩如生。我们还使用新的输入系统通过输入动作映射处理玩家输入——而不是直接读取设备输入——并创建了一个`PlayerController`脚本来移动玩家。
- en: We dove deeper into Mecanim as we learned how to transition between animations
    and drive animation state changes from code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了Mecanim，学习了如何在动画之间进行转换，并从代码中驱动动画状态变化。
- en: In this chapter, you will be introduced to object pooling while we use this
    optimization pattern for the player’s shooting mechanic, and we’ll accomplish
    that using Unity’s object pooling API. The object pooling software design will
    be based on a pooled player shooting model UML diagram.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍对象池，同时我们将使用这种优化模式为玩家的射击机制，我们将使用Unity的对象池API来实现这一点。对象池软件设计将基于池化玩家射击模型UML图。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The object pooling pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池模式
- en: A pooled player shooting model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 池化玩家射击模型
- en: By the end of this chapter, you’ll be able to create an optimized shooting mechanic
    for a ranged weapon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够为远程武器创建一个优化的射击机制。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along in this chapter with the same artwork created for the project
    in the book, download the assets from the following GitHub link: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与书中为项目创建的相同艺术作品一起学习本章，请从以下GitHub链接下载资源：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6)。
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop, or a graphics program that can export layered Photoshop
    PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用你自己的艺术作品进行学习，你需要使用Adobe Photoshop或能够导出分层Photoshop PSD/PSB文件的图形程序（例如Gimp、MediBang
    Paint、Krita和Affinity Photo）创建类似的艺术作品。
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上下载完整的项目[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: The object pooling pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池模式
- en: The **object pooling** design pattern is a type of **creational** or **abstract
    factory** design pattern that uses a stack to hold a collection of initialized
    object instances. It is excellent for use in situations when you will have either
    a large number of objects that need to be spawned or objects that will be created
    and destroyed rapidly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象池**设计模式是一种**创建型**或**抽象工厂**设计模式，它使用栈来存储初始化的对象实例集合。它非常适合在需要大量需要生成或快速创建和销毁的对象的情况下使用。'
- en: Since we will be shooting projectile objects from a weapon – which can be performed
    at a high rate by the player – this is a great place to apply object pooling because
    repeatedly instantiating and destroying objects comes with a high cost. In this
    case, object pooling provides a way to optimize CPU, memory, and **garbage** **collection**
    (**GC**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从武器中射击投射物——玩家可以以高频率执行此操作——因此这是一个应用对象池的绝佳地方，因为反复实例化和销毁对象会带来高昂的成本。在这种情况下，对象池提供了一种优化CPU、内存和**垃圾回收**（**GC**）的方法。
- en: Rather than creating a new projectile object directly every time the player
    needs to shoot, we’ll instead reuse an already instantiated projectile object
    by requesting it from the objects in the pool. As such, the Object Pool provides
    methods for requesting (getting) and returning (releasing) objects. So, for example,
    for a pool of 10 projectile objects, we’ll get one at a time from the pool when
    the player shoots and return the projectile that was shot when it expires (e.g.,
    hit something).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次玩家需要射击时都直接创建一个新的投射物对象，我们将通过从池中的对象请求来重用已经实例化的投射物对象。因此，对象池提供了请求（获取）和返回（释放）对象的方法。例如，对于10个投射物对象的池，当玩家射击时，我们将一次从池中获取一个，并在它过期时（例如，击中某个物体）返回被射击的投射物。
- en: If you recall from our **Game Design Document** (**GDD**) in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    specifically *Table 4.1*, we defined shooting capabilities, so we’ll use object
    pooling to implement this mechanic in a performant and optimized way, using Unity’s
    new **object** **pooling** **API**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们**游戏设计文档**（**GDD**）中的[第4章](B18347_04.xhtml#_idTextAnchor079)，特别是*表4.1*，我们定义了射击能力，因此我们将使用对象池以高效和优化的方式实现这一机制，使用Unity的新**对象**
    **池** **API**。
- en: The Unity object pooling API
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 对象池 API
- en: Unity has added a new namespace to the engine – `UnityEngine.Pool` – that includes
    several new classes to implement the object pooling pattern. For our requirement
    of a weapon to shoot bullets, we’ll use the `ObjectPool<T0>` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 为引擎添加了一个新的命名空间 – `UnityEngine.Pool` – 其中包含几个新类以实现对象池模式。对于我们需要射击子弹的武器，我们将使用`ObjectPool<T0>`类。
- en: Additional reading | Unity documentation
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**ObjectPool<T0>**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**ObjectPool<T0>**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml)'
- en: 'The following is a list of required actions we’ll need when working with the
    object pool:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们工作时需要执行的一系列必要操作：
- en: '`Creating` (instantiating): Making a new object instance in the pool available.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Creating`（实例化）：在池中创建一个新的对象实例使其可用。'
- en: '`Getting` (requesting): Retrieving an available object instance from the pool
    (or creating and returning a new one if more are needed).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Getting`（请求）：从池中检索一个可用的对象实例（如果需要更多，则创建并返回一个新的实例）。'
- en: '`Releasing` (returning): Putting an active object instance back into the pool
    for reuse when it’s finished with.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Releasing`（归还）：将一个活动的对象实例放回池中以供重用时使用。'
- en: '`Destroying` (removing): Removing an instantiated object from the pool completely
    if it grows over its size limit.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destroying`（移除）：如果实例化对象的数量超过其大小限制，则完全从池中移除。'
- en: Thankfully, or by design, the `ObjectPool<T0>` class provides everything we
    need, such as creating a pool and taking and returning items to the pool. Now,
    let’s create a new object pool for our projectiles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，或者说是设计上的考虑，`ObjectPool<T0>`类提供了我们所需要的一切，例如创建池以及从池中取回和归还项目。现在，让我们为我们的弹道创建一个新的对象池。
- en: Creating a new object pool
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的对象池
- en: 'Let’s have a look at the following code that creates a new object pool of `BulletPrefab`
    projectiles (of type `ProjectileBase`; there’ll be more on this shortly in the
    *Creating the pooled player shooting* *model* section):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码，它创建了一个新的`BulletPrefab`弹道对象池（类型为`ProjectileBase`；关于这一点，我们将在*创建池化玩家射击*
    *模型*部分稍后详细说明）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we can see a method (a local function in this case) declared
    for each of the required `ObjectPool` parameters, corresponding to the actions
    we listed previously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到一个方法（在这种情况下是一个本地函数）被声明，对应于我们之前列出的每个必要的`ObjectPool`参数。
- en: A local function (C#)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数（C#）
- en: The new **ObjectPool** creation code uses local functions instead of a common
    approach, using lambdas (anonymous delegates), so that we, for one, avoid unnecessary
    memory allocations. We create a local function by declaring a method inside the
    body of an already existing method; this also limits the scope of a local function
    to only being able to be called from within the method, which promotes encapsulation
    over using private member methods (we don’t need these methods outside the scope
    of setting up the object pool, and they only need to be called once).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**ObjectPool**创建代码使用本地函数而不是常见的使用lambda（匿名委托）的方法，这样我们就可以避免不必要的内存分配。我们通过在已存在的方法体内声明一个方法来创建一个本地函数；这也限制了本地函数的作用域，使其只能在该方法内部被调用，这促进了封装，而不是使用私有成员方法（我们不需要在设置对象池的作用域之外使用这些方法，并且它们只需要被调用一次）。
- en: A delegate has to be created when using a lambda, which is an unnecessary allocation
    if a local function is used. Allocations to capture local variables are also avoided,
    as local functions are really just functions; no delegates are necessary. In addition,
    calling a local function is also cheaper, and performance can be increased even
    further if in-lined by the compiler (eliminating call-linkage overhead).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用lambda时，必须创建一个委托，如果使用本地函数，这将是一个不必要的分配。避免捕获局部变量的分配，因为本地函数实际上只是函数；不需要委托。此外，调用本地函数的成本也更低，如果由编译器内联（消除调用链接开销），性能还可以进一步提高。
- en: Also, local functions just look better! They provide better code readability
    and verbose parameter names – a lambda anonymous delegate would obscure each parameter
    type! (Can you tell I’m just a bit biased here?)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，局部函数看起来更好！它们提供了更好的代码可读性和详尽的参数名称——一个 lambda 匿名委托会隐藏每个参数类型！（你能看出我有点偏心吗？）
- en: 'Here’s some additional reading on the subject: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于此主题的额外阅读材料：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions)。
- en: 'Here are some interesting design notes from when local functions were added
    to C# 7: [https://github.com/dotnet/roslyn/issues/3911](https://github.com/dotnet/roslyn/issues/3911).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于在 C# 7 中添加局部函数时的有趣设计注释：[https://github.com/dotnet/roslyn/issues/3911](https://github.com/dotnet/roslyn/issues/3911)。
- en: 'I’ve declared the following local functions within the `Start()` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `Start()` 方法中声明了以下局部函数：
- en: '`CreatePooledItem`: This will instantiate an object of type `ProjectileBase`
    when a new item is needed. This is a bullet Prefab we have a reference to on the
    player’s weapon.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatePooledItem`: 当需要新项目时，这将实例化一个类型为 `ProjectileBase` 的对象。这是一个我们存储在玩家武器上的子弹
    Prefab。'
- en: '`OnGetFromPool`: We’ll use `_poolProjectiles.Get()` to return a `ProjectileBase`
    object instance, while this method calls `gameObject.SetActive(true)` to enable
    the object for use.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnGetFromPool`: 我们将使用 `_poolProjectiles.Get()` 来返回一个 `ProjectileBase` 对象实例，而此方法将调用
    `gameObject.SetActive(true)` 来启用对象以供使用。'
- en: '`OnReturnToPool`: Calling `_poolProjectiles.Release(projectile)` will execute
    `projectile.gameObject.SetActive(false)` on the object instance passed in, making
    sure it’s inactive (disabled) while sitting in the pool waiting to be retrieved.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnReturnToPool`: 调用 `_poolProjectiles.Release(projectile)` 将在传入的对象实例上执行 `projectile.gameObject.SetActive(false)`，确保它在池中等待被检索时处于非活动（禁用）状态。'
- en: '`OnDestroyPoolItem`: Calling `Destroy(projectile.gameObject)` when an item
    is removed from the pool means the object will no longer exist in the scene.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroyPoolItem`: 当从池中移除项目时调用 `Destroy(projectile.gameObject)` 意味着该对象将不再存在于场景中。'
- en: To clarify some of the preceding actions, *instantiate* means an object is created
    and exists in the Scene. When the instantiated object’s active state is `SetActive(true)`,
    it is visible in the Scene, and code is executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明前面的某些操作，*实例化* 意味着一个对象被创建并存在于场景中。当实例化对象的活动状态为 `SetActive(true)` 时，它在场景中可见，并且代码将被执行。
- en: Setting the GameObject as `SetActive(false)` will ensure that it doesn’t display
    in the Scene, and for each component, the `Update()` method will no longer be
    called.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GameObject 设置为 `SetActive(false)` 将确保它不在场景中显示，并且对于每个组件，`Update()` 方法将不再被调用。
- en: Additional parameters affecting the object pool
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响对象池的额外参数
- en: 'Beyond the preceding action methods, we have three additional parameters that
    affect how the pool functions. They are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的操作方法之外，我们还有三个影响池功能的额外参数。它们如下：
- en: '`collectionCheck`: We can save some CPU cycles if we set this parameter to
    `false`, as it won’t check whether an object was returned to the pool already
    (be cautious with this value, since it will throw errors if you try to release
    an item already in the pool).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionCheck`: 如果我们将此参数设置为 `false`，我们可以节省一些 CPU 循环，因为它不会检查对象是否已经返回到池中（对此值要小心，因为它会在尝试释放池中已有的项目时引发错误）。'
- en: '`defaultCapacity`: You should set this value to the number of projectiles we’ll
    generally need to have available on screen simultaneously (you can best determine
    this number by playtesting the rate of fire).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultCapacity`: 您应该将此值设置为我们将同时在屏幕上需要显示的弹幕数量（您可以通过测试射击速率来确定此数值）。'
- en: '`maxSize`: This value will prevent the pool from growing too large and getting
    out of hand. Any instances above this number will be destroyed instead of being
    returned to the pool (exceeding the maximum size often will trigger unwanted garbage
    collection, and resizing is an expensive operation – more CPU cycles – so you’ll
    want to fine-tune this value by playtesting too).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxSize`: 此值将防止池变得过大而失控。任何超过此数值的实例都将被销毁而不是返回到池中（经常超过最大大小会触发不希望的垃圾回收，并且调整大小是一个昂贵的操作——更多的
    CPU 循环——因此您也需要通过测试来微调此值）。'
- en: Let’s put our new Object Pool to good use now by implementing the shooting mechanic,
    using a pool of bullet projectiles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过实现射击机制，使用子弹弹幕池来充分利用我们的新对象池。
- en: A pooled player shooting model
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池化玩家射击模型
- en: We will use an **OOP** (**object-oriented programming**) design approach to
    the player shooting setup, allowing for easy future extensibility of new types
    of weapons and projectiles.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对玩家射击设置使用 **OOP**（**面向对象编程**）设计方法，以便于未来轻松扩展新的武器和弹丸类型。
- en: Creating the pooled player shooting model
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建池化玩家射击模型
- en: 'Let’s consider the following class diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下类图：
- en: '![Figure 6.1 – A pooled player shooting UML class diagram](img/B18347_06_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 池化玩家射击 UML 类图](img/B18347_06_1.jpg)'
- en: Figure 6.1 – A pooled player shooting UML class diagram
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 池化玩家射击 UML 类图
- en: '*Figure 6**.1* presents a UML diagram. **UML** stands for **Unified Modeling
    Language**, and it’s a standardized approach to specifying and visualizing the
    relationships of artifacts within software projects. There are several types of
    UML diagrams, each serving a specific purpose. The class diagram we’re using displays
    the static structure of a system, including classes, attributes, methods, and
    their relationships. It’s one of the most widely used diagrams in software architecture.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.1* 展示了一个 UML 图。**UML** 代表 **统一建模语言**，它是一种在软件项目中指定和可视化工件关系的标准化方法。有几种类型的
    UML 图，每种图都有其特定的用途。我们使用的类图显示了系统的静态结构，包括类、属性、方法和它们之间的关系。它是软件架构中最广泛使用的图之一。'
- en: Additional reading | UML diagram
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | UML 图
- en: 'UML: [https://www.uml.org/what-is-uml.htm](https://www.uml.org/what-is-uml.htm)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'UML: [https://www.uml.org/what-is-uml.htm](https://www.uml.org/what-is-uml.htm)'
- en: 'PlantUML Language Reference Guide: [https://plantuml.com/guide](https://plantuml.com/guide)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: PlantUML 语言参考指南：[https://plantuml.com/guide](https://plantuml.com/guide)
- en: 'PlantText UML Editor: [https://www.planttext.com/](https://www.planttext.com/)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PlantText UML 编辑器：[https://www.planttext.com/](https://www.planttext.com/)
- en: 'Okay, we’ve modeled the system for the pooled player shooting part of our game’s
    code, but what does it mean? Referring to the diagram in *Figure 6**.1*, let’s
    break down the structure with these points:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经为游戏代码中池化玩家射击部分建模了系统，但这意味着什么呢？参考 *图 6**.1* 中的图，让我们用以下这些点来分解结构：
- en: 'The `PlayerShootingPooled` class (*C*) – responds to `SendMessage()` of player
    input’s `OnFire()` event to shoot the weapon’s projectile:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShootingPooled` 类（*C*） – 对玩家输入的 `OnFire()` 事件的 `SendMessage()` 响应以射击武器的弹丸：'
- en: This uses the `_poolProjectiles` object, which represents the stack of instantiated
    `ProjectileBase` objects (that is, `Bullet`)
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使用了 `_poolProjectiles` 对象，它代表实例化的 `ProjectileBase` 对象的堆栈（即 `Bullet`）
- en: It gets the `Bullet` (*C*) object Prefab (derived from the `ProjectileBase`
    (*A*) class type) for use in the `_poolProjectiles` (the `ObjectPool<ProjectileBase>`
    type) stack
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它获取 `Bullet` (*C*) 对象预制件（从 `ProjectileBase` (*A*) 类类型派生而来）用于在 `_poolProjectiles`（`ObjectPool<ProjectileBase>`
    类型）堆栈中：
- en: It has a reference to the current ranged weapon (the `WeaponRanged` (*C*) class
    type) equipped to the player
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个指向当前配备给玩家的远程武器（`WeaponRanged` (*C*) 类类型）的引用
- en: 'The `WeaponRanged` class (*C*) – represents any number of ranged weapon types
    we can equip the player with:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeaponRanged` 类（*C*） – 表示我们可以为玩家配备的任何数量的远程武器类型：'
- en: It implements the `IWeapon` (*I*) interface, meaning that we must declare the
    same members (like a contract). Therefore, any classes that implement the interface
    will have the same members available (this allows us to swap out object types
    without having to change code that consumes the interface members).
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了 `IWeapon` (*I*) 接口，这意味着我们必须声明相同的成员（就像一个合同）。因此，任何实现该接口的类都将具有相同的成员可用（这允许我们在不更改消耗接口成员的代码的情况下交换对象类型）。
- en: 'The `Bullet` class (*C*) is a component added to our bullet Prefab and assigned
    in the Inspector to the `WeaponRanged`-serialized `_bulletPrefab` field. The bullet
    Prefab is retrieved via the public `BulletPrefab` property (encapsulating the
    private variable) for consumption in the `PlayerShootingPooled` class:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bullet` 类（*C*）是我们添加到子弹预制件中的组件，并在检查器中分配给 `WeaponRanged` 序列化的 `_bulletPrefab`
    字段。子弹预制件通过公共 `BulletPrefab` 属性（封装私有变量）检索，用于在 `PlayerShootingPooled` 类中消费：'
- en: This extends the inherited abstract class, `ProjectileBase` (making `Bullet`
    a subclass); we cannot instantiate a class-declared `abstract` and must instead
    use the derived class. However, members declared in the `base` class are available
    in the derived class.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这扩展了继承的抽象类 `ProjectileBase`（使 `Bullet` 成为子类）；我们不能实例化声明为 `abstract` 的类，而必须使用派生类。然而，在
    `base` 类中声明的成员在派生类中也是可用的。
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When we say *serializable*, we’re indicating that we’ll be able to make an assignment
    in the Inspector – a private field in most cases (in a C# script, the private
    field is decorated with the **[****SerializeField]** attribute).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 *serializable* 时，我们是指我们将在检查器中做出分配——在大多数情况下是一个私有字段（在 C# 脚本中，私有字段用 **[****SerializeField]**
    属性装饰）。
- en: After reading through the preceding details and reviewing the class diagram,
    you may have started visualizing what our code should look like `… … …`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前面的细节并审查了类图之后，你可能已经开始想象我们的代码应该是什么样子 `… … …`
- en: Well, you can stop daydreaming about it now because the code follows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你现在可以停止做白日梦了，因为代码如下。
- en: 'Create a new C# script in `Assets/Scripts`, named `PlayerShootingPooled.cs`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 中创建一个新的 C# 脚本，命名为 `PlayerShootingPooled.cs`：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ve declared the `_weapon1` variable to assign the reference to the `WeaponRanged`
    Prefab object attached to the player’s hand in the Editor (at design time). We
    also declared public variables `PoolDefaultCapacity` and `PoolMaxSize`, with default
    values of `10` and `25`, respectively, for the default and maximum sizes of our
    private `ObjectPool`, declared as `_poolProjectiles`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已声明 `_weapon1` 变量，用于分配对玩家手中在编辑器（设计时）附加的 `WeaponRanged` 预制对象引用。我们还声明了公共变量 `PoolDefaultCapacity`
    和 `PoolMaxSize`，分别具有默认值 `10` 和 `25`，用于我们私有 `ObjectPool` 的默认和最大大小，该 `ObjectPool`
    声明为 `_poolProjectiles`。
- en: We’ll then use the `Start()` code from the previous *The Unity object pooling
    API* section (excluded from the preceding code) and declare an `OnFire()` method,
    to be called via `PlayerInput SendMessage()` when the player presses the *fire*
    button. Within `OnFire()`, we will provide a `Bullet` instance, returned from
    calling `_poolProjectiles.Get()`, to shoot with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用上一节 *The Unity object pooling API* 中的 `Start()` 代码（不包括在之前的代码中）并声明一个
    `OnFire()` 方法，当玩家按下 *fire* 按钮时，将通过 `PlayerInput SendMessage()` 调用它。在 `OnFire()`
    方法中，我们将提供一个 `Bullet` 实例，该实例是通过调用 `_poolProjectiles.Get()` 返回的，用于射击。
- en: Lastly, we will declare the `ReturnProjectile()` method, since it will be invoked
    by the `_weapon1.Shoot()` callback when the bullet is finished… doing what bullets
    do.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将声明 `ReturnProjectile()` 方法，因为它将在 `_weapon1.Shoot()` 回调中调用，当子弹完成…执行子弹应该做的事情时。
- en: A note on code architecture
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码架构的说明
- en: When we create the pool item, we could pass a reference to **_poolProjectiles**
    and call **Release()** on it directly, but if we make this an **event**, we can
    provide **ReturnProjectile()** as a callback. Plus, we have the option of adding
    any additional callbacks. I don’t have any immediate plans for it. Still, it’s
    nice to consider the options to create a flexible approach, without having to
    refactor the code later to introduce the ability and possibly break functioning/tested
    code in the process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建池项目时，我们可以传递对 **_poolProjectiles** 的引用并直接对其调用 **Release()**，但如果我们将其作为一个
    **事件**，我们可以提供 **ReturnProjectile()** 作为回调。此外，我们还有添加任何其他回调的选项。我目前没有立即的计划。不过，考虑这些选项以创建一个灵活的方法，而不必在以后重构代码以引入功能，并可能在这个过程中破坏功能/测试过的代码，总是好的。
- en: 'Now, we will create a new C# script in `Assets/Scripts` named `WeaponRanged.cs`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `Assets/Scripts` 中创建一个新的 C# 脚本，命名为 `WeaponRanged.cs`：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `WeaponRanged` script is where we’ll assign a reference to our bullet Prefab
    in the Inspector, using the serialized private field, `_bulletPrefab` – a weapon
    that shoots will require something to shoot, after all.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponRanged` 脚本是我们将在检查器中使用序列化的私有字段 `_bulletPrefab` 分配我们的子弹预制件的引用的地方——毕竟，射击武器需要射击的东西。'
- en: We’ve kept `_bulletPrefab` encapsulated and then allowed only read (getter)
    access to the reference via the `BulletPrefab` public property. So, *encapsulation*
    here means we don’t want any other classes to have access to set a bullet reference.
    The weapon will manage its own projectiles (although we could still add functionality
    later to assign a new bullet Prefab via a public setter method, such as `WeaponRanged.SetBulletPrefab(GameObject)`
    or similar).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `_bulletPrefab` 封装起来，然后只允许通过 `BulletPrefab` 公共属性进行读取（getter）访问引用。因此，这里的
    *封装* 意味着我们不希望其他类访问设置子弹引用。武器将管理自己的弹丸（尽管我们还可以稍后添加功能，通过公共设置器方法，如 `WeaponRanged.SetBulletPrefab(GameObject)`
    或类似的方法，来分配新的子弹预制件）。
- en: The `Transform` variable, `_projectileSpawn`, provides a location where we’ll
    spawn the bullet Prefab that is shot from the weapon – we will set this up in
    the `WeaponRanged 1` Prefab later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform` 变量 `_projectileSpawn` 提供了一个位置，我们将在这里生成从武器射出的子弹预制件——我们将在稍后的 `WeaponRanged
    1` 预制件中设置它。'
- en: Lastly, the `Shoot()` method sets the position of the projectile that the pool
    provided to the projectile spawn position, and then it calls the `Init()` method
    on it (presumably to fire it off in the correct direction by applying some force
    to it).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Shoot()` 方法将弹池提供的弹丸的位置设置为弹丸生成位置，然后调用其上的 `Init()` 方法（可能是为了通过对其施加一些力来正确发射）。
- en: We will also provide a reference to `poolingReturnCallback` so that the bullet
    Prefab can be released back to the pool when it collides with another object,
    or its lifespan expires.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提供对 `poolingReturnCallback` 的引用，以便当子弹 Prefab 与另一个对象碰撞或其生命周期结束时，可以将其释放回池中。
- en: 'Now, we will create a new C# script in `Assets/Scripts/Interfaces` named `IWeapon.cs`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `Assets/Scripts/Interfaces` 目录下创建一个新的 C# 脚本，命名为 `IWeapon.cs`：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WeaponRanged` class implements the `IWeapon` interface to satisfy the contract,
    which means `WeaponRanged` must implement the `BulletPrefab` property and the
    `Shoot()` method declared in the `IWeapon` interface. Note that interface members
    in C# are public by default!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponRanged` 类实现了 `IWeapon` 接口以满足契约，这意味着 `WeaponRanged` 必须实现 `IWeapon` 接口中声明的
    `BulletPrefab` 属性和 `Shoot()` 方法。请注意，C# 中的接口成员默认是公共的！'
- en: The weapon and object pooling portions of the class diagram in *Figure 6**.1*
    are now satisfied. Let’s finish up the class diagram implementation with the projectile
    that will be shot from the weapon.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类图中的武器和对象池部分现在已满足。让我们通过从武器发射的弹丸来完成类图实现。
- en: 'Create a new C# script in `Assets/Scripts` named `Bullet.cs`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式在 `Assets/Scripts` 目录下创建一个新的 C# 脚本，命名为 `Bullet.cs`：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Bullet` class extends the `ProjectileBase` class, meaning that it will
    inherit all the members and/or be required to **override** members. You can declare
    unique properties for a derived class that differentiate it from other derived
    classes (a tenet of **inheritance** in OOP design).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet` 类扩展了 `ProjectileBase` 类，这意味着它将继承所有成员并/或需要 **重写** 成员。你可以在派生类中声明独特的属性，以区分它与其他派生类（面向对象设计中的
    **继承** 原则之一）。'
- en: We’re overriding the `OnTriggerEnter2D()` method – we’re required to, since
    it’s declared as `abstract` in the inherited `ProjectileBase` class – to perform
    the specific Bullet collision action.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重写 `OnTriggerEnter2D()` 方法 – 我们必须这样做，因为它在继承的 `ProjectileBase` 类中被声明为 `abstract`
    – 以执行特定的子弹碰撞动作。
- en: Note that we’re also calling the `Collided()` method in the inherited class
    by using the `base` keyword. `Collided()` is declared as `virtual`, which means
    we can redefine it in a derived class while also using it for the same basic/default
    functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在继承的类中通过使用 `base` 关键字调用了 `Collided()` 方法。`Collided()` 被声明为 `virtual`，这意味着我们可以在派生类中重新定义它，同时也可以使用它来实现相同的基本/默认功能。
- en: This bit of code – `((CollideWith & (1 << collision.gameObject.layer)) != 0)`
    – in the `OnTriggerEnter2D()` method evaluates whether the GameObject the `Bullet`
    collided with is included in the layers selected in `CollideWith LayerMask`. For
    example, we’ll select *Environment*, *Wall*, *Ground*, *Enemy*, and so on, but
    not *Player* for `Bullet` to collide with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码 – `((CollideWith & (1 << collision.gameObject.layer)) != 0)` – 在 `OnTriggerEnter2D()`
    方法中评估了 `Bullet` 碰撞的 GameObject 是否包含在 `CollideWith LayerMask` 中选定的层中。例如，我们将选择 *Environment*、*Wall*、*Ground*、*Enemy*
    等等，但不包括 *Player* 以便 `Bullet` 能够与之碰撞。
- en: Additional reading | Unity documentation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'LayerMask: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 层掩码：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml)
- en: 'Bitwise and shift operators: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符和移位运算符：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-)。
- en: We’ve seen how `Bullet` extends the `ProjectileBase` class (via OOP inheritance),
    so let’s have a look at the `ProjectileBase` class now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `Bullet` 如何通过面向对象继承扩展了 `ProjectileBase` 类，现在让我们看看 `ProjectileBase` 类。
- en: 'Create a new C# script in `Assets/Scripts` named `ProjectileBase.cs`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 目录下创建一个新的 C# 脚本，命名为 `ProjectileBase.cs`：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see our bullet projectile’s default properties and behavior. By
    declaring `ProjectileBase` as an abstract base class, it cannot be instantiated
    (made a new instance of) directly, so we must declare a new class that extends
    or inherits from it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的子弹投射物的默认属性和行为。通过将 `ProjectileBase` 声明为抽象基类，它不能被直接实例化（创建新实例），因此我们必须声明一个新的类，该类扩展或继承自它。
- en: Note that any derived classes can still be referenced by the base class it extends
    (in OOP, this is the **polymorphism** principle). The derived class must override
    any members declared as abstract but can optionally override members declared
    as virtual (while also being able to call base virtual methods for default behavior).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何派生类仍然可以通过它扩展的基类被引用（在面向对象编程中，这是 **多态** 原则）。派生类必须重写任何声明为抽象的成员，但可以选择重写声明为虚拟的成员（同时也能够调用基虚拟方法以实现默认行为）。
- en: 'Let’s break down the code’s relevant items:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码的相关项：
- en: Variable declarations for `_rb`, `_velocity`, and `_lifetime` provide a reference
    to the `RigidBody2D` component of the projectile Prefab, as well as configurable
    values for the rate of velocity and lifetime of the object
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_rb`, `_velocity`, 和 `_lifetime` 变量的声明为投射物 Prefab 的 `RigidBody2D` 组件提供了引用，同时也为对象的速率和寿命提供了可配置的值。'
- en: When `Init()` is called, the passed-in callback action is assigned to `_onCollisionAction`
    to be invoked later, and then `_rg.velocity` is set for `direction` and rate of
    `_velocity`, firing it off in the direction the weapon is pointing
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `Init()` 时，传入的回调动作被分配给 `_onCollisionAction` 以供稍后调用，然后设置 `_rg.velocity` 的
    `direction` 和 `_velocity` 的速率，将其发射到武器指向的方向。
- en: 'Then, we have two abstract methods that must be overridden in the derived class(es)
    (for example, `Bullet`):'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有两个抽象方法必须在派生类（例如，`Bullet`）中重写：
- en: '`OnTriggerEnter2D()`: This Unity message event is called when another object
    collides with the object.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter2D()`: 当另一个对象与该对象发生碰撞时，Unity的消息事件会被调用。'
- en: '`LifetimeExpired()`: In `Init()`, we invoke this method with a delay so that
    the projectile object only exists active in the Scene for a certain amount of
    time (releasing it back to the pool to be reused). The `_lifetime` value should
    be adjusted during playtesting so that the weapon’s range works well in-game.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LifetimeExpired()`: 在 `Init()` 中，我们使用延迟调用此方法，使得投射物对象仅在场景中存在一定时间（将其释放回对象池以供重用）。在游戏测试期间，应调整
    `_lifetime` 值，以确保武器的射程在游戏中表现良好。'
- en: Finally, we have the `Collided()` method, which first cancels calling the `LifetimeExpired()`
    method at the `_lifetime` value (for example, as we don’t want to call `LifetimeExpired()`
    if `Collided()` was already called by a collision event) and then invokes the
    `_onCollisionAction` callback (releasing the object back to the pool).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有 `Collided()` 方法，它首先取消在 `_lifetime` 值处调用 `LifetimeExpired()` 方法（例如，因为我们不希望在
    `Collided()` 已经被碰撞事件调用后再次调用 `LifetimeExpired()`），然后调用 `_onCollisionAction` 回调（将对象释放回对象池）。
- en: Pooled player shooting model code
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 池化玩家射击模型代码
- en: 'The complete aforementioned pooled Player shooting code can be downloaded from
    the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的上述池化玩家射击代码可以从以下 GitHub 仓库下载：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts)。
- en: Following the design model from the UML class diagram in *Figure 6**.1*, we
    have now finished writing the code portion and are ready to move on to implementing
    it with the player.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照来自 *图 6**.1* 的 UML 类图的设计模型，我们现在已经完成了代码部分的编写，并准备好将其与玩家实现。
- en: Implementing the pooled shooting model
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现池化射击模型
- en: 'Now, let’s see how we implement the pooled player shooting model by creating
    the required Prefabs – a weapon and a projectile – for integration with the player.
    The Prefabs we’ll need, along with the steps to create them, are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何通过创建所需的 Prefab（武器和投射物）来实现池化玩家射击模型，以便与玩家集成。我们需要以下 Prefab，以及创建它们的步骤如下：
- en: '`Bullet 1`: The first projectile Prefab asset we’ll shoot from a ranged weapon:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`子弹 1`：我们将从远程武器发射的第一个投射物 Prefab 资产：'
- en: Import the `bullet1` artwork from the project files to the `Assets/Sprites`
    folder and set the PPU to `1280` (to set our larger bullet sprite to a good in-game
    size, which will be possibly adjusted later in relation to the size of the weapon
    firing the bullet). Also, set `64` for optimization, since it is a relatively
    small and fast-moving sprite.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目文件中导入 `bullet1` 美术资源到 `Assets/Sprites` 文件夹，并将 PPU 设置为 `1280`（为了将较大的子弹精灵设置为合适的游戏内大小，这可能会在稍后根据发射子弹的武器大小进行调整）。同时，为了优化，将其设置为
    `64`，因为它是一个相对较小且移动速度较快的精灵。
- en: 'Create an empty GameObject in the `Bullet 1`. Remember that you can easily
    parent a GameObject in the `Rigidbody2D` and `CircleCollider2D` components to
    the parent object to enable `Rigidbody2D` component, set `0`, and enable `CircleCollider2D`
    component, set `0.13`), as shown in *Figure 6**.2*:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Bullet 1` 中创建一个空 GameObject。请记住，您可以将 `Rigidbody2D` 和 `CircleCollider2D` 组件轻松地作为父对象的孩子来启用
    `Rigidbody2D` 组件，设置为 `0`，并启用 `CircleCollider2D` 组件，设置为 `0.13`），如图 *图 6**.2* 所示：
- en: '![Figure 6.2 – the bullet Prefab setup](img/B18347_06_2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 子弹 Prefab 设置](img/B18347_06_2.jpg)'
- en: Figure 6.2 – the bullet Prefab setup
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 子弹 Prefab 设置
- en: Now, add the `Bullet` script to the parent object, and assign the `Rigidbody2D`
    field by clicking and dragging the `Rigidbody2D` section title to the field.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `Bullet` 脚本添加到父对象中，并通过点击并拖动 `Rigidbody2D` 部分标题到该字段来分配 `Rigidbody2D` 字段。
- en: Set **Velocity** and **Lifetime** to some initial starting values, and then
    assign the layers that the bullet should collide with, using the **CollideWith**
    field (note that you may need to add a new layer before you can assign it).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **速度** 和 **生命周期** 设置为一些初始起始值，然后使用 **CollideWith** 字段分配子弹应与之碰撞的层（注意，在分配之前您可能需要添加一个新层）。
- en: Lastly, drag the parent `Bullet 1` object from the `Assets/Prefabs` folder.
    Our bullet Prefab is now ready to be used with the weapon Prefab we’ll create
    next.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从 `Assets/Prefabs` 文件夹中拖动父 `Bullet 1` 对象。我们的子弹 Prefab 现在可以与我们将要创建的武器 Prefab
    一起使用了。
- en: '`WeaponRanged 1`: A ranged weapon that the player will hold and shoot a bullet
    projectile from:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeaponRanged 1`：玩家将持有并从其中发射子弹弹射物的远程武器：'
- en: Import the `gun1` weapon artwork, and in the Sprite Editor, set a custom pivot
    (see *A* in *Figure 6**.3*) on the handle so that when it is attached (or spawned)
    to the player, it is in the correct position and can rotate on a pivot point (as
    you might expect it to behave).
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `gun1` 武器艺术品，并在精灵编辑器中，在把手处设置一个自定义的枢轴（见 *图 6**.3* 中的 *A*），这样当它附加（或生成）到玩家时，它处于正确的位置并且可以在枢轴点上旋转（正如您可能期望的那样）。
- en: Pivot | Unity documentation
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 枢轴 | Unity 文档
- en: When working with a GameObject, the pivot serves as the reference point to position,
    rotate, and scale it. In Unity, when using the Transform tools, you can switch
    between the pivot or center of a GameObject in the Tool Settings overlay.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 GameObject 一起工作时，枢轴作为定位、旋转和缩放它的参考点。在 Unity 中，当使用 Transform 工具时，您可以在工具设置覆盖层之间切换
    GameObject 的枢轴或中心。
- en: 'Position GameObjects | Gizmo handle position toggles: [https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml](https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定位 GameObjects | Gizmo 处理器位置切换：[https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml](https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml)
- en: Drag the gun sprite into the `WeaponRanged 1`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将枪精灵拖动到 `WeaponRanged 1`。
- en: 'Now, add a new empty GameObject, named `ProjectileSpawnPoint`, as a sibling
    to the gun sprite object that we’ll use as the **Transform** position to spawn
    the projectile. Position this GameObject at the front of the gun’s muzzle (see
    *B* in *Figure 6**.3*):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个新的空 GameObject，命名为 `ProjectileSpawnPoint`，作为枪精灵对象的同级对象，我们将使用它作为 **Transform**
    位置来生成弹射物。将此 GameObject 定位于枪口前端（见 *图 6**.3* 中的 *B*）：
- en: '![Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup](img/B18347_06_3.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 武器 Prefab 精灵和弹射点设置](img/B18347_06_3.jpg)'
- en: Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 武器 Prefab 精灵和弹射点设置
- en: Now, add `WeaponRanged` as a component to the parent GameObject.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `WeaponRanged` 作为组件添加到父 GameObject 中。
- en: The only two assignments we need to make on the `WeaponRanged` component are
    the `Bullet 1` from the `ProjectileSpawnPoint` object to the `WeaponRanged 1`
    object from the `Assets/Prefabs` folder.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WeaponRanged` 组件上，我们只需要进行两项分配：将 `ProjectileSpawnPoint` 对象中的 `Bullet 1` 分配到
    `Assets/Prefabs` 文件夹中的 `WeaponRanged 1` 对象。
- en: Our pooled player shooting model is ready to be used with the player character.
    Yay!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可回收玩家射击模型现在可以与玩家角色一起使用了。耶！
- en: Adding pooled shooting to the player character
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将池化射击添加到玩家角色中
- en: We’ll dig right into adding the weapon to our player. You can either make sure
    the player is in the current Scene or double-click on the `Player` Prefab in the
    **Project** window to open it up in **Prefab** Mode.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接开始将武器添加到我们的玩家中。您要么确保玩家处于当前场景中，要么在**项目**窗口中双击`Player`预制体以将其打开到**预制体**模式。
- en: 'We’ll use the player’s (actor’s) bones to ensure the weapon follows the character’s
    hand while animating. Perform the following steps to anchor the weapon to the
    player’s hand:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用玩家的（演员的）骨骼来确保武器在动画时跟随角色的手。执行以下步骤将武器锚定到玩家的手中：
- en: Find the hand bone under the `root_bone` hierarchy. In our case, it’s `bone_8`
    as shown in *Figure 6**.4*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`root_bone`层次结构下找到手骨。在我们的例子中，它是`bone_8`，如图*图 6**.4*所示。
- en: Add an empty GameObject as a child of `bone_8`, and name it `Weapon_Attachment`;
    this will serve as the attachment point for the weapon. Making it separate from
    the bone provides additional options for positioning/rotating. Also, naming it
    with an `_Attachment` suffix means we can easily search for any/all objects in
    the **Hierarchy** that serve as attachment points.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个空GameObject作为`bone_8`的子对象添加，并命名为`Weapon_Attachment`；这将成为武器的附件点。将其与骨骼分开提供额外的定位/旋转选项。此外，使用`_Attachment`后缀命名意味着我们可以轻松搜索**层次结构**中作为附件点的任何/所有对象。
- en: You can now go ahead and drag the `WeaponRanged 1` Prefab from the `Weapon_Attachment`
    object (this becomes a nested Prefab, which means we can configure its properties
    at any time, independent of the `Player` Prefab).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以继续将`WeaponRanged 1`预制体从`Weapon_Attachment`对象拖动出来（这变成了一个嵌套预制体，这意味着我们可以在任何时间配置其属性，而无需依赖于`Player`预制体）。
- en: 'The following screenshot shows our player setup with the weapon in hand. In
    the following *Figure 6**.4*, you can see that I have also temporarily dragged
    in a `Bullet 1` Prefab to check its scale in relation to the weapon (seen in context
    with the player character):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的玩家设置，手持武器。在接下来的*图 6**.4*中，您可以看到我还临时拖入了一个`Bullet 1`预制体，以检查其与武器的比例（与玩家角色一起显示）：
- en: '![Figure 6.4 – The weapon Prefab added to the player](img/B18347_06_4.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 添加到玩家中的武器预制体](img/B18347_06_4.jpg)'
- en: Figure 6.4 – The weapon Prefab added to the player
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 添加到玩家中的武器预制体
- en: As a final step, we need to add the `PlayerShootingPooled` script as a component
    to the root object of our `Player` Prefab. Then, we will drag the `WeaponRanged
    1` object from the **Hierarchy** to the **Weapon 1** field on the component (as
    shown in *Figure 6**.4*).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要将`PlayerShootingPooled`脚本作为组件添加到我们的`Player`预制体的根对象中。然后，我们将从**层次结构**中将`WeaponRanged
    1`对象拖动到组件上的**武器 1**字段（如图*图 6**.4*所示）。
- en: 'Here’s what our Prefab components – based on the classes in our UML diagram
    – look like in the Inspector with all their respective field assignments:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的Prefab组件的外观，基于UML图中的类，在检查器中，所有相应的字段分配如下：
- en: '![Figure 6.5 – Prefab configuration for the pooled player shooting setup](img/B18347_06_5.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 池化玩家射击设置的预制体配置](img/B18347_06_5.jpg)'
- en: Figure 6.5 – Prefab configuration for the pooled player shooting setup
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 池化玩家射击设置的预制体配置
- en: New to Unity 2022
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新增于Unity 2022
- en: This may not be new specifically to the 2022 tech stream, but I believe it’s
    a workflow improvement worth mentioning. You can simultaneously open up a focused
    **Inspector** window for different assets or GameObjects, without constantly changing
    your selection and using the Inspector. First, select the object, and then either
    right-click and choose **Properties…** (at the bottom) or press *Alt/Cmd +* *P*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能并不是2022年技术流特有的，但我相信这是一个值得提及的工作流程改进。您可以同时打开一个针对不同资产或GameObject的专注**检查器**窗口，而无需不断更改选择并使用检查器。首先，选择对象，然后右键单击并选择**属性…**（在底部）或按*Alt/Cmd
    +* *P*。
- en: Let’s go ahead and playtest the results of our efforts!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续测试我们努力的成果！
- en: Referring to *Figure 6**.4*, enter `PlayerCharacter1` object to pose the actor’s
    arm with the weapon attachment in a shooting position – using the IK `LimbSolver2D`
    target makes this easy-peasy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图 6**.4**，进入`PlayerCharacter1`对象，将带有武器附件的演员手臂摆放在射击位置 – 使用IK `LimbSolver2D`目标使这变得轻而易举。
- en: We’ll give the player a proper shooting animation that points the weapon in
    a direction in [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151) so that we can
    target those pesky robot enemies (not that it’s their fault!).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为玩家添加一个适当的射击动画，使武器指向[*第 8 章*](B18347_08.xhtml#_idTextAnchor151)中的方向，这样我们就可以针对那些讨厌的机器人敌人（不是他们的错！）进行瞄准。
- en: This section taught us how to add a ranged weapon to the player by attaching
    it to a character’s limb, all while using previously created Prefabs. I can’t
    stress how important it is to understand and use a good Prefab workflow in your
    projects!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本节教会了我们如何通过将武器附加到角色的肢体上，使用之前创建的预制件来为玩家添加远程武器。我无法强调理解和使用良好的预制件工作流程在项目中的重要性！
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced object pooling and implemented it for the player’s shooting
    mechanic, using Unity’s object pooling API, while basing the software design on
    our pooled player shooting model UML diagram.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了对象池的概念，并实现了玩家射击机制的对象池，使用了Unity的对象池API，同时基于我们池化玩家射击模型的UML图进行软件设计。
- en: We finished by attaching the ranged weapon to the player, using our configured
    Prefab components.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将配置好的预制组件附加到玩家身上，完成了游戏。
- en: In the following chapter, we’ll add some juice to the player character with
    some visual effects, create some enemy NPCs (non-player characters), and finish
    by introducing enemy behavior through a state pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加一些视觉效果来增强玩家角色的表现，创建一些敌人NPC（非玩家角色），并通过状态模式介绍敌人的行为。
