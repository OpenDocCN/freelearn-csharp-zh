- en: '*Chapter 11*: Canceling Asynchronous Work'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we’ve looked at a few examples of how to cancel threads
    and tasks. This chapter will explore more of the methods available to cancel concurrent
    and parallel work with C# and .NET. The methods in this chapter will provide alternative
    ways to cancel background operations using callbacks, polling, and wait handles.
    You will gain a deeper understanding of how to safely cancel asynchronous work
    with a variety of methods using some practical scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Canceling managed threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling parallel work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering patterns for thread cancellation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple cancelation sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to cancel different types
    of asynchronous and parallel tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.2 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To complete any WinForms or WPF samples, you will need to install the .NET desktop
    development workload for Visual Studio. These projects will only run on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Canceling managed threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Canceling asynchronous work in .NET is based on the use of a `CancellationTokenSource`
    object manages these requests and contains a token. If you want to cancel several
    operations with the same trigger, the same token should be provided to all of
    the threads to be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: A `CancellationTokenSource` instance has a `Token` property to access the `CancellationToken`
    property and pass it to one or more asynchronous operations. The request to cancel
    can only be made from the `CancellationTokenSource` object. The `CancellationToken`
    property provided to the other operations receives the signal to cancel but cannot
    initiate a cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: '`CancellationTokenSource` implements the `IDisposable` interface, so be sure
    to call `Dispose` when you are freeing your managed resources. A `using` statement
    or block to automatically dispose of the token source would be preferred if it
    is practical for your workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that cancellation is not forced on the listening
    code. The asynchronous code that receives a cancellation request must determine
    whether it can currently cancel its work. It might decide to immediately cancel,
    cancel after finishing some intermediate tasks, or finish its work and ignore
    the request. There can be valid reasons why a routine will ignore a request to
    cancel. It is possible that the work is almost complete or that canceling in the
    current state will cause some data corruption. The decision to cancel must be
    mutual between the requestor and the listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how to cooperatively cancel some work being processed
    on a background thread on the `ThreadPool` thread:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, create a new .NET 6 console application named `CancelThreadsConsoleApp.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class named `ManagedThreadsExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method named `ProcessText` in the `ManagedThreadsExample` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method appends the value of the iterator variable, `x`, to the `string`
    variable of `text` until a cancellation request is received. There is a `Thread.Sleep(500)`
    statement to allow the calling method some time to cancel the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a method named `CancelThread`, in `Program.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calls `ThreadPool.QueueUserWorkItem` to queue the `ProcessText`
    method in the `ThreadPool` thread. The method also receives a cancellation token
    from `tokenSource.Token`. After waiting for five seconds, `tokenSource.Cancel`
    is called, and `ProcessText` will receive the cancellation request.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `tokenSource` is created in a `using` statement. This ensures that
    it will be properly disposed of when it goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to `CancelThread` to the `Main` method in `Program.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the application and observe the console output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Running the CancelThreadsConsoleApp project ](img/Figure_11.1_B18852.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Running the CancelThreadsConsoleApp project
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop should have enough time to execute 9 or 10 times before receiving
    the request to cancel. How does your output match up?
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some basics of cancellation and worked with a common
    method of using a cancellation token, let’s create some examples of how to cancel
    parallel loops and PLINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling parallel work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will work with some examples of canceling parallel operations.
    There are a few operations that fall into this realm. There are static parallel
    operations that are part of the `System.Threading.Tasks.Parallel` class and there
    are PLINQ operations. Both of these types use a `CancellationToken` property,
    as we used in our managed threading example in the previous section. However,
    handling the cancellation request is slightly different. Let’s look at an example
    to understand the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a parallel loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create a sample that illustrates how to cancel a `Parallel.For`
    loop. The same method of cancellation is leveraged for the `Parallel.ForEach`
    method. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CancelThreadsConsoleApp` project from the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ManagedThreadsExample` class, create a new `ProcessTextParallel` method
    with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Essentially, the preceding code does the same thing as the `ProcessText` method
    in our last example. It appends a numeric value to the `text` variable until a
    cancellation is requested. Let’s examine the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are setting `token.Value` to the `CancellationToken` property of a
    `ParallelOptions` object. These options are passed as the third parameter to the
    `Parallel.For` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second major difference is that we handle the cancellation request by catching
    an `OperationCanceledException` type. This exception type will be thrown when
    our other code in `Program.cs` requests a cancellation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, add a method named `CancelParallelFor` to `Program.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, the user is instructed to press a key to start the operation
    and to press the *X* key when they are ready to cancel the operation. The code
    to handle receiving `x` `KeyChar` from the console and sending a `Cancel` request
    is performed on another thread in order to keep the current thread free to call
    `ProcessTextParallel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `Main` method to call `CancelParallelFor` and comment out
    the call to `CancelThread`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the project. Follow the prompts to cancel the `Parallel.For` loop,
    and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Canceling a Parallel.For loop from the console ](img/Figure_11.2_B18852.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Canceling a Parallel.For loop from the console
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the numbers are not in sequence at all. In this case, it appears
    that the `Parallel.For` operation used two different threads. The first thread
    started at `0`, while the second thread was operating on integers starting with
    `37500`. This is the midway point of the maximum value of `75000` provided to
    the method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will briefly examine how to cancel a PLINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a PLINQ query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Canceling a PLINQ query is also achieved by catching the `OperationCanceledException`
    type. However, instead of using the `ParallelOptions` object that is used with
    parallel loops, you can call `WithCancellation` as part of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to cancel a PLINQ query, let’s walk through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start this example by adding a method named `ProcessNumsPlinq`, to the `ManagedThreadsExample`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method creates an array of 25 million integers and uses the PLINQ query
    to determine which of them are divisible by seven. The `token.Value` is passed
    to the `WithCancellation` operation in the query. When an exception is thrown
    by a cancellation request, the exception details are written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a method named `CancelPlinq` to `Program.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, the cancellation will be triggered automatically after 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Main` method to call `CancelPlinq`, and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Canceling a PLINQ operation in the console application ](img/Figure_11.3_B18852.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Canceling a PLINQ operation in the console application
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous examples, there is no query output to examine. You cannot
    get partial output from a PLINQ query. The `result` variable will be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will work with some different methods of cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering patterns for thread cancellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different methods of listening for cancellation requests from a thread
    or task. So far, we have seen examples of managing these requests by either handling
    the `OperationCanceledException` type or checking the value of `IsCancellationRequested`.
    The pattern of checking `IsCancellationRequested`, usually inside a loop, is called
    `ManualResetEvent` or `ManualResetEventSlim`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by trying another example of handling a cancellation request by
    polling.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling with polling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create another example that uses polling to cancel
    a background task. The previous example of polling was running in a background
    thread on the `ThreadPool` thread. This example will also start a `ThreadPool`
    thread, but it will leverage `Task.Run` to start the background thread. We will
    create and process a million `System.Drawing.Point` objects, finding those with
    a `Point.X` value of less than `50`. Users will have the option to cancel processing
    by pressing the *X* key:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new .NET console application project named `CancellationPatterns`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class to the project named `PollingExample`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a private static method to `PollingExample` named `GeneratePoints`. This
    will generate the number of `Point` objects that we desire with random `X` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don’t forget to add a `using` statement to use the `Point` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a private static method named `FindSmallXValues` to `PollingExample`.
    This method loops through the list of points and outputs those with an `X` value
    of less than `50`. Each time through the loop, it checks the token for cancellation
    and breaks out of the loop when it occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `Thread.SpinWait` statement is added at the end of the loop to give users
    some time to cancel the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a public static method to `PollingExample` named `CancelWithPolling`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding method creates the `CancellationTokenSource` object and passes
    it to `FindSmallXValues` and also `Task.Run`. If you wanted to cancel the `Task`,
    instead of breaking out of the loop when `IsCancellationRequested` becomes `true`,
    you would call `token.ThrowIfCancellationRequested`. This would throw an exception
    in the `Task`. The `CancelWithPolling` method would then require a `try`/`catch`
    block around the `Task.Run` call. It’s a best practice to use exception handling
    with all multithreaded code anyway. In this case, you would have two exception
    handlers: one to handle `OperationCanceledException` and a second to handle `AggregateException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `CancelWithPolling` method has code to determine when the
    user presses the *X* key to cancel the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open `Program.cs` and add some code to execute the sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the application, and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Running the cancellation polling example ](img/Figure_11.4_B18852.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Running the cancellation polling example
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how long you wait before canceling, you might have a different
    number of points found by the process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how you can register a callback method to
    handle cancellation requests.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling with callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some code in .NET supports the registration of a callback method to cancel
    processing. One class that supports cancellation with callbacks is `System.Net.WebClient`.
    In this example, we will use `WebClient` to start downloading a file. The download
    will be canceled after three seconds. To ensure the file download is large enough
    that it has not been completed after three seconds, we will download a large lossless
    audiobook file from **Internet Archive** (https://archive.org/). We will download
    the first part of the audiobook of *The Odyssey* by Homer. This file is 471.1
    MB. You can view all of the free downloads for this book at https://archive.org/details/lp_the-odyssey_homer-anthony-quayle.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CallbackExample`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by adding a method named `GetDownloadFileName` to build the path where
    the file will be downloaded. We will download it to the same folder where our
    assembly is executing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add an `async` method named `DownloadAudioAsync`. This method will handle
    the file download and cancellation. There are several exception handlers to catch
    any type of exception that the `DownloadFileTaskAsync` method might throw. In
    turn, all of them throw an `OperationCanceledException` type to be handled by
    the parent method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `using` statement for the `WebClient` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a public `async` method named `CancelWithCallback`. This method calls
    `DownloadAudioAsync`, waits for three seconds, and calls `Cancel` on the `CancellationTokenSource`
    object. Awaiting the task in a `try` block means we can handle the `OperationCanceledException`
    type directly. If you used `task.Wait` instead, you would have to catch `AggregateException`
    and check whether one of the `InnerException` objects is an `OperationCanceledException`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this step, it might be necessary to adjust the number of seconds in the `tokenSource.Token.WaitHandle.WaitOne`
    call. The timing can vary based on your computer’s download speed and processing
    speed. Try adjusting the value if you do not see a `Download canceled` message
    in the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, comment out the existing code in `Program.cs`, and add the following
    code to call the `CallbackExample` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the application, and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Canceling a download with CancellationToken and a callback
    ](img/Figure_11.5_B18852.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Canceling a download with CancellationToken and a callback
  prefs: []
  type: TYPE_NORMAL
- en: You can verify that the download started and did not complete by looking in
    the folder where your assembly was running. You should see a file named **audio.flac**
    with a file size of **0 KB**. You can safely delete this file as it could cause
    exceptions if you try to download it again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to cancel a background task with a callback method,
    let’s wrap up this section by working through an example with wait handles.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling with wait handles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will use `ManualResetEventSlim` to cancel a background task
    that would not otherwise be responsive to user input. This object has `Set` and
    `Reset` events to start/resume or pause an operation. When operations have not
    yet started or have been paused, calling `ManualResetEventSlim.Wait` will cause
    the operation to pause on that statement until another thread calls `Set` to start
    or resume processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will iterate over 100,000 integers and output to the console for
    each even number. This process can be started, paused, resumed, or canceled thanks
    to the `ManualResetEventSlim` object and `CancellationToken`. Let’s try this example
    in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding a `WaitHandleExample` class to the **CancellationPatterns**
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a private variable named `resetEvent` to the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a private static method named `ProcessNumbers` to the class. This method
    iterates over the numbers and only continues processing when `resetEvent.Wait`
    allows it to proceed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a public static async method named `CancelWithResetEvent` to the
    class. This method creates the list of numbers to process, calls `ProcessNumbers`
    within a `Task.Run` call, and uses a `while` loop to listen for user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update `Program.cs` to contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program to test it. Follow the console prompts to start, pause, resume,
    and cancel the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Testing the CancelWithResetEvent method in the console ](img/Figure_11.6_B18852.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Testing the CancelWithResetEvent method in the console
  prefs: []
  type: TYPE_NORMAL
- en: You should see in the console output that several event numbers have been found
    before the operation is canceled. The amount of processing completed could vary
    based on your computer’s processors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will wrap up cancellation by learning how to handle
    cancellation requests from multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple cancellation sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Background tasks can leverage `CancellationTokenSource` to receive cancellation
    requests from as many sources as necessary. The static `CancellationTokenSource.CreateLinkedTokenSource`
    method accepts an array of `CancellationToken` objects to create a new `CancellationTokenSource`
    object that will notify us of cancellation if any of the source tokens receives
    a request to cancel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of how to implement this in our **CancellationPatterns**
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the `PollingExample` class. We are going to create an overload
    of the `CancelWithPolling` method that accepts a `CancellationTokenSource` parameter.
    The two overloads of `CancelWithPolling` will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add a new class named `MultipleTokensExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method named `CancelWithMultipleTokens` in the `MultipleTokensExample`
    class. This method accepts `parentToken` as a parameter, creates its own `tokenSource`,
    and then combines them into a `combinedSource` object to pass to the `CancelWithPolling`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re calling `tokenSource.Cancel`, but if `Cancel` is invoked on any of the
    three `CancellationTokenSource` objects, the processing in `CancellWithPolling`
    will receive a cancellation request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some code to `Program.cs` to call `CancelWithMultipleTokens`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program, and you should see an output similar to what you saw in the
    subsection *Canceling with polling* of the section *Discovering patterns for thread
    cancellation*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try changing which `CancellationTokenSource` object is used to invoke `Cancel`.
    The output should remain the same regardlesss of the source of the cancellation
    request.
  prefs: []
  type: TYPE_NORMAL
- en: A background `Task` will also end if you throw an exception within the `Task`.
    This has a similar effect of ending the background processing, but `TaskStatus`
    will be `Faulted` instead of `Canceled`.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our review of cancellation requests from multiple sources and
    our tour of canceling tasks and threads with C# and .NET. Let’s review what we
    have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a number of new ways to cancel background threads
    and tasks. It is important to provide your users with a method of canceling long-running
    tasks or automatically canceling them when users or the operating system closes
    or suspends your application.
  prefs: []
  type: TYPE_NORMAL
- en: After working through the examples in this chapter, you now understand how to
    use polling, callbacks, and wait handles to cooperatively cancel background tasks.
    Additionally, you learned how to handle cancellation requests from more than one
    source.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how .NET developers can unit test code
    that employs multithreaded constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which property of a `CancellationToken` object indicates whether a cancellation
    request has been made?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which data type provides a `CancellationToken` object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What exception type is thrown when `ThrowIfCancellationRequested` is invoked?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What cancellation pattern is used by the `WebClient` object in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which .NET type can pause or resume operations with a `CancellationToken` object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which reset event is used to pause processing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which static method in `CancellationTokenSource` can combine multiple `CancellationToken`
    objects into a single source?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
