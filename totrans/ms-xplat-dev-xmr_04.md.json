["```cs\nvar myImageResourceId = Resource.Drawable.XamarinLogo;\n\nvar myImageView = (ImageView) FindViewById(Resource.Id.MyImageView);\n\n// Set the Image resource using the id.\nmyImageView.SetImageResource(myImageResourceId);\n\n// OR:\n\n// Retrieving the resource itself and then assigning it.\nDrawable myImageResource = Resources.GetDrawable(myImageResourceId);\nmyImageView.SetImageDrawable(myImageResource);\n```", "```cs\n<ImageView android:src=\"img/xamarinlogo\" \n           android:layout_width=\"wrap_content\" \n           android:layout_height=\"match_parent\" />\n```", "```cs\nTask.Run(async () =>\n{\n    using (var dataPackageStream = Assets.Open(\"Data.csv\"))\n    using (var streamReader = new StreamReader(dataPackageStream))\n    {\n        var content = await streamReader.ReadToEndAsync();\n        // TODO: Do something with the comma separated content.\n    }\n});\n```", "```cs\nvar image = UIImage.FromFile(\"XamarinLogo.png\");\n\n//\n// OR making a roundtrip (get the path, read the file, create // image\n// Similar to /data/Containers/Bundle/Application/<id>/XamarinMasteriOS.app/XamarinLogo.png\nvar imagePath = NSBundle.MainBundle.GetUrlForResource(\"XamarinLogo\", \"png\").Path;\nvar fileContent = System.IO.File.ReadAllBytes(imagePath);\n\nvar secondImage = UIImage.LoadFromData(NSData.FromArray(fileContent));\n```", "```cs\n// Retrieve an object for accessing private to this activity\nISharedPreferences myPreferences = GetPreferences(FileCreationMode.Private);\n\n// Retrieve and hold the contents of the preference file 'MyCustomPreferences'\nISharedPreferences myCustomPreferences = GetSharedPreferences(\"MyCustomPreferences\", FileCreationMode.Private);\n```", "```cs\nvar myStringValue = myCustomPreferences.GetString(\"MyStringValue\", string.Empty);\nvar myIntValue = myCustomPreferences.GetInt(\"MyIntValue\", default(int));\n```", "```cs\nISharedPreferencesEditor myEditor = myCustomPreferences.Edit();\nmyEditor.PutString(\"MyStringValue\", myStringValue);\nmyEditor.PutInt(\"MyIntValue\", myIntValue);\n\n// Apply the current changes from the editor back \n// to the Singleton SharedPreferences class\nmyEditor.Apply();\n\n// OR\n// Commit the changes to the singleton instance \n// AND the disk immediately\nmyEditor.Commit();\n```", "```cs\n// Creating a file in the application internal storage root\nusing(var fileStreamInRootPath = this.OpenFileOutput(\"FileInRootPath\", FileCreationMode.Private))\nusing (var streamWriter = new StreamWriter(fileStreamInRootPath))\n{\n    streamWriter.Write(\"Hello World!\");\n}\n\n//\n// Reading the contents of the file\nusing(var fileStreamInRootPath = this.OpenFileInput(\"FileInRootPath\"))\nusing (var streamReader = new StreamReader(fileStreamInRootPath))\n{\n    var stringContent = streamReader.ReadToEnd();\n}\n\n// Getting the file path.\n// e.g.: /data/data/Xamarin.Master.Android/files/FileInRootPath\nvar filePath = FilesDir.AbsolutePath + \"/\" + \"FileInRootPath\";\n\n// Using the Xamarin (Mono) implementation.\nSystem.IO.File.AppendAllText(filePath, \"\\r\\nAdditional Content\");\nvar allText = System.IO.File.ReadAllText(filePath);\n```", "```cs\nmyNSDictionary.WriteToFile(dictionaryPath, true);\n\nDebug.WriteLine(\"File Contents:\");\nvar fileContents = System.IO.File.ReadAllText(dictionaryPath);\nDebug.WriteLine(fileContents);\n\nvar myNewNSDictionary = NSDictionary.FromFile(dictionaryPath);\n\nDebug.WriteLine(\"Values read from plist:\");\nforeach (var key in myNewNSDictionary.Keys)\n{\n    var keyValue = myNewNSDictionary[key];\n    Debug.WriteLine(string.Format(\"Value for the key '{0}' is '{1}'\", key, keyValue));\n}\n```", "```cs\nFile Contents:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n <key>firstKey</key>\n <string>firstValue</string>\n <key>secondKey</key>\n <string>secondValue</string>\n <key>thirdKey</key>\n <integer>8</integer>\n</dict>\n</plist>\nValues read from plist:\nValue for the key 'firstKey' is 'firstValue'\nValue for the key 'secondKey' is 'secondValue'\nValue for the key 'thirdKey' is '8'\n\n```", "```cs\n// Path similar to /data/data/Xamarin.Master.Android/cache\nvar cacheFilePath = this.CacheDir.AbsolutePath + \"/\" + \"CacheFile\";\n\n// Writing to the file\nSystem.IO.File.AppendAllLines(cacheFilePath, new[] { \"Cached Content\" });\n\n// Reading the file\nvar cachedContent = System.IO.File.ReadAllText(cacheFilePath);\n```", "```cs\n// getting the root application sandbox path\nvar documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);\n// paths to caches and temporary files directories.var cache = Path.Combine(documents, \"..\", \"Library\", \"Caches\");\nvar tmp = Path.Combine(documents, \"..\", \"tmp\");\n```", "```cs\nTrace.WriteLine(Environment.RootDirectory, \"FileSystem\");\nTrace.WriteLine(Environment.DataDirectory, \"FileSystem\");\n\nTrace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryDownloads).AbsolutePath, \"FileSystem\");\nTrace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryDocuments).AbsolutePath, \"FileSystem\");\n\n// Call with GetExternalFilesDir\nTrace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryMovies).AbsolutePath, \"FileSystem\");\nTrace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryMusic).AbsolutePath, \"FileSystem\");\nTrace.WriteLine(this.GetExternalFilesDir(Environment.DirectoryPictures).AbsolutePath, \"FileSystem\");\n\nTrace.WriteLine(Environment.GetExternalStoragePublicDirectory(Environment.DirectoryMovies).AbsolutePath, \"FileSystem\");\nTrace.WriteLine(Environment.GetExternalStoragePublicDirectory(Environment.DirectoryMusic).AbsolutePath, \"FileSystem\");\nTrace.WriteLine(Environment.GetExternalStoragePublicDirectory(Environment.DirectoryPictures).AbsolutePath, \"FileSystem\");\n\nTrace.WriteLine(Environment.DownloadCacheDirectory, \"FileSystem\");\nTrace.WriteLine(Environment.ExternalStorageDirectory, \"FileSystem\");\n```", "```cs\nI/mono-stdout(10079): FileSystem: /system\nI/mono-stdout(10079): FileSystem: /data\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Download\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Documents\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Movies\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Music\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Android/data/Xamarin.Master.Android/files/Pictures\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Movies\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Music\nI/mono-stdout(10079): FileSystem: /storage/emulated/0/Pictures\nI/mono-stdout(10079): FileSystem: /cache\nI/mono-stdout(10079): FileSystem: /storage/emulated/0\n```", "```cs\npublic class LocationInfo\n{\n    [PrimaryKey, AutoIncrement]\n    public int LocationInfoId { get; set; }\n\n    public string Name { get; set; }\n\n    public double Latitude { get; set; }\n\n    public double Longitude { get; set; }\n}\n```", "```cs\npublic TravelContext(string sqlitePath, ISQLitePlatform platform)\n{\n    var connectionString = new SQLiteConnectionString(sqlitePath, false);\n    var connectionWithLock = new SQLiteConnectionWithLock(platform, connectionString);\n    m_SqliteConnection = new SQLiteAsyncConnection(() => connectionWithLock);\n\n    // OR with non-async connection\n    //var connection = new SQLiteConnection(platform, sqlitePath);\n}\n```", "```cs\nprivate void InitTablesAsync()\n{\n    var tasks = new List<Task<CreateTablesResult>>();\n\n    tasks.Add(m_SqliteConnection.CreateTableAsync<LocationInfo>());\n    tasks.Add(m_SqliteConnection.CreateTableAsync<City>());\n    tasks.Add(m_SqliteConnection.CreateTableAsync<Landmark>());\n    tasks.Add(m_SqliteConnection.CreateTableAsync<Comment>());\n\n    // OR\n    //var initTask = m_SqliteConnection.CreateTablesAsync<LocationInfo, City, Landmark, Comment>();\n\n    var initTask = Task.WhenAll(tasks);\n    initTask.ConfigureAwait(false);\n}\n```", "```cs\nvar dbPath = Path.Combine(this.FilesDir.Path, \"myTravelDb.db3\");\n\n// TODO: Use Dependency Injection\nvar platform = new SQLitePlatformAndroid();\n\nvar myDbContext = new TravelContext(dbPath, platform);\n\nvar landmarksInCityTask = await myDbContext.Landmarks\n    .Where(item => item.CityId == cityId).ToListAsync();\n```", "```cs\npublic interface ISettingsProvider\n{\n    string this[string key] { get; set; }\n}\n```", "```cs\npublic class SettingsProvider : ISettingsProvider\n{\n    private readonly ISharedPreferences m_SharedPreferences;\n\n    public SettingsProvider(string name = \"default\")\n    {\n        // Retrieve and hold the contents of the preference file'\n        m_SharedPreferences = Application.Context.GetSharedPreferences(name, FileCreationMode.Private);\n    }\n\n    public string this[string key]\n    {\n        get\n        {\n            if (m_SharedPreferences.Contains(key))\n                m_SharedPreferences.GetString(key, string.Empty);\n            return string.Empty;\n        }\n        set\n        {\n            var editor = m_SharedPreferences.Edit();\n            editor.PutString(key, value);\n            editor.Apply();\n        }\n    }\n}\n```", "```cs\npublic string this[string key]\n{\n    get\n    {\n        if (m_MyNSMutableDictionary.ContainsKey(new NSString(key)))\n        {\n            return MyNSMutableDictionary [key].ToString();\n        }\n\n        return string.Empty;\n    }\n    set\n    {\n        MyNSMutableDictionary [key] = new NSString(value);\n        MyNSMutableDictionary.WriteToFile(GetPropertyListPath(), true);\n    }\n}\n```", "```cs\npublic interface IFilePickerService\n{\n    Task<string> PickFileAsync();\n}\n```", "```cs\nreturn new MvxCommand(() =>\n{\n    m_FilePickerService.PickFileAsync()\n        .ContinueWith(task =>\n        {\n            Debug.WriteLine(\"File Picked:\" + task.Result);\n        });\n});\n```", "```cs\nprivate TaskCompletionSource<string> m_PickFileCompletionSource;\n```", "```cs\npublic Task<string> PickFileAsync()\n{\n    m_PickFileCompletionSource = new TaskCompletionSource<string>();\n\n    Intent intent = new Intent();\n    intent.SetType(\"*/*\");\n    intent.SetAction(Intent.ActionGetContent);\n    intent.AddCategory(Intent.CategoryOpenable);\n\n    try\n    {\n        StartActivityForResult(intent, 0);\n    }\n    catch(ActivityNotFoundException ex)\n    {\n        throw new InvalidOperationException(\"Could not find a file manager\");\n    }\n\n    return m_PickFileCompletionSource.Task;\n}\n```", "```cs\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n\n    if (resultCode == Result.Ok)\n    {\n        m_PickFileCompletionSource.TrySetResult(data.Data.Path);\n    }\n    else if(resultCode == Result.Canceled)\n    {\n        m_PickFileCompletionSource.SetCanceled();\n    }\n}\n```", "```cs\npublic MainView()\n{\n    Mvx.RegisterType<IFilePickerService>(()=>this);\n}\n```", "```cs\npublic Task<string> PickFileAsync()\n{\n    var taskCompletionSource = new TaskCompletionSource<string>();\n\n    var documentTypes = new string[] { UTType.PNG, UTType.Image, UTType.BMP };\n\n    var filePicker = new UIDocumentPickerViewController(documentTypes, UIDocumentPickerMode.Open);\n\n    EventHandler<UIDocumentPickedEventArgs> documentPickedHandler = (sender, args) =>\n    {\n        taskCompletionSource.SetResult(args.Url.Path);\n    };\n\n    filePicker.DidPickDocument += documentPickedHandler;\n\n    return taskCompletionSource.Task;\n}\n```", "```cs\npublic class PreferencesBackupService : BackupAgentHelper\n{\n    // TODO: Override the methods we might need\n}\n```", "```cs\n<application android:label=\"Xamarin.Master.Android\" \n             android:icon=\"@drawable/Icon\" \n             android:backupAgent=\"PreferencesBackupService\">\n  <meta-data android:name=\"com.google.android.backup.api-key\"  \n             android:value=\"...\" />\n</application>\n```", "```cs\n09-22 18:28:33.647 E/ActivityThread(32153): Agent threw during creation: java.lang.ClassNotFoundException: Didn't find class \"Xamarin.Master.Android.PreferencesBackupService\" on path: DexPathList[[zip file \"/data/app/Xamarin.Master.Android-1.apk\"],nativeLibraryDirectories=[/data/app-lib/Xamarin.Master.Android-1, /system/lib]]\n\n```", "```cs\n[Register(\"Xamarin.Master.Android.PreferencesBackupService\")]\npublic class PreferencesBackupService : BackupAgentHelper \n```", "```cs\n[assembly: Application(AllowBackup = true, BackupAgent = typeof(PreferencesBackupService))]\n[assembly: MetaData(\"com.google.android.backup.api_key\", Value = \"...\")]\n```", "```cs\nmd5d06a1058f86cf8319abb1555c0b54fbf.PreferencesBackupService\n\n```", "```cs\npublic override void OnCreate()\n{\n    var preferencesHelper = new SharedPreferencesBackupHelper(this, \"ApplicationSettings\");\n    AddHelper(\"ApplicationPreferences\", preferencesHelper);\n\n    Debug.WriteLine(\"PreferencesBackupService was created\", \"BackUp\");\n\n    base.OnCreate();\n}\n```", "```cs\nadb shell bmgr enable true\nadb shell bmgr run\n\n```", "```cs\nBackupManager backupManager = new BackupManager(this);\n\n// Notifying the backup manager about data changes\nbackupManager.DataChanged();\n\n// Using an implementations of RestoreObserver class to request restore\nbackupManager.RequestRestore(new MyRestoreObserver());\n```", "```cs\ncom.apple.developer.ubiquity-kvstore-identifier\ncom.apple.developer.ubiquity-container-identifiers\n\n```", "```cs\n/// <summary>\n/// Synchronizes local values to the cloud\n/// </summary>\nprivate void SyncUpSettings()\n{\n    var store = NSUbiquitousKeyValueStore.DefaultStore;\n    //\n    // Can use designated set functions for different value types\n    // string, bool, NSData, NSDictionary, NSObject[], long, double\n    store.SetString(\"myStringValue\", \"New String Value\");\n    store.SetLong(\"myLongValue\", 1234);\n    store.SetBool(\"myBoolValue\", true);\n    store.Synchronize();\n}\n```", "```cs\n/// <summary>\n/// Gets the values from synchronized local storage\n/// </summary>\n/// <returns></returns>\nprivate Dictionary<string,object> GetValues()\n{\n    var results = new Dictionary<string,object>();\n    var store = NSUbiquitousKeyValueStore.DefaultStore;\n\n    //\n    // Getting the synchronized LOCAL values\n    results.Add(\"myStringValue\",store.GetString(\"myStringValue\"));\n    results.Add(\"myLongValue\", store.GetLong(\"myLongValue\"));\n    results.Add(\"myBoolValue\", store.GetBool(\"myBoolValue\"));\n\n    return results;\n}\n```", "```cs\nNSNotificationCenter.DefaultCenter.AddObserver(\n    NSUbiquitousKeyValueStore.DidChangeExternallyNotification, (notification) =>\n    {\n        NSDictionary userInfo = notification.UserInfo;\n\n        // NInt: 0-ServerChange, 1-InitialSyncChange, \n        // 2-QuotaViolationChange\n        NSNumber reasonNumber = (NSNumber) userInfo.ObjectForKey(NSUbiquitousKeyValueStore.ChangeReasonKey);\n\n        // NSString[] You can used the changed items list to sync only those values\n        NSArray changedKeys = (NSArray) userInfo.ObjectForKey(NSUbiquitousKeyValueStore.ChangedKeysKey);\n\n        // OR get the latest values from synchronized local storage\n        var latestValues = GetValues();\n    });\n```", "```cs\npublic class EntityDocument<T> : UIDocument\n{\n    public EntityDocument(NSUrl url)\n        : base(url)\n    {\n        m_Type = typeof(T);\n    }\n```", "```cs\n/// <summary>\n/// Content down-sync'd from the cloud\n/// </summary>\npublic override bool LoadFromContents(NSObject contents, string typeName, out NSError outError)\n{\n    // TODO: Implement a try/catch block to return (if any) errors as well as negative result (i.e. return false).\n    outError = null;\n\n    if (contents != null)\n    {\n        var serializedData = NSString.FromData((NSData)contents, NSStringEncoding.UTF8);\n        m_Entity = JsonConvert.DeserializeObject<T>(serializedData);\n    }\n\n    // LoadFromContents called when an update occurs\n    NSNotificationCenter.DefaultCenter.PostNotificationName(string.Format(\"{0}DocumentModified\",m_Type.Name), this);\n\n    return true;\n}\n```", "```cs\n/// <summary>\n/// Content to up-sync to the cloud\n/// </summary>\npublic override NSObject ContentsForType(string typeName, out NSError outError)\n{\n    // TODO: Implement a try/catch block to return (if any) errors as well as negative result (i.e. return false).\n    outError = null;\n\n    if (m_Entity != null)\n    {\n        var serializedData = JsonConvert.SerializeObject(m_Entity);\n\n        NSData docData = new NSString(serializedData).Encode(NSStringEncoding.UTF8);\n\n        return docData;\n    }\n\n    return null;\n}\n```", "```cs\nprivate void GetLocationsInfo(string locationName)\n{\n    var locationDataQuery = new NSMetadataQuery();\n    locationDataQuery.SearchScopes = new NSObject[] {NSMetadataQuery.UbiquitousDocumentsScope};\n\n    locationDataQuery.Predicate = NSPredicate.FromFormat(string.Format(\"{0} == %@\",\n        NSMetadataQuery.ItemFSNameKey), new NSString(locationName + \"Data.txt\"));\n\n    NSNotificationCenter.DefaultCenter.AddObserver(this, new Selector(\"locationLoaded:\"),\n      NSMetadataQuery.DidFinishGatheringNotification, locationDataQuery);\n\n    locationDataQuery.StartQuery();\n}\n```", "```cs\n[Export(\"locationLoaded:\")]\nprivate void DidFinishGatheringHandler(NSNotification notification)\n{\n    var locationQuery = (NSMetadataQuery) notification.Object;\n    locationQuery.DisableUpdates();\n    locationQuery.StopQuery();\n    NSNotificationCenter.DefaultCenter.RemoveObserver(this, NSMetadataQuery.DidFinishGatheringNotification, locationQuery);\n\n    LoadLocationInfo(locationQuery);\n\n    // listen for notifications that the document was modified via the // server \n    NSNotificationCenter.DefaultCenter.AddObserver(this, new Selector(\"itemReloaded:\"),\n      new NSString(\"LocationInfoDocumentModified\"),\n      null);\n\n}\n```", "```cs\nprivate void LoadLocationInfo(NSMetadataQuery locationDataQuery)\n{\n    if (locationDataQuery.ResultCount == 1)\n    {\n        NSMetadataItem item = (NSMetadataItem) locationDataQuery.ResultAtIndex(0);\n        var url = (NSUrl)item.ValueForAttribute(NSMetadataQuery.ItemURLKey);\n        m_LocationData = new EntityDocument<LocationInfo>(url);\n        m_LocationData.Open((success) =>\n        {\n            if (success)\n            {\n                var info = m_LocationData.Entity;\n                // TODO: Do something with the location info loaded\n            }\n            else\n                Console.WriteLine(\"failed to open iCloud           document\");\n        });\n    }\n}\n```", "```cs\n[Export(\"itemReloaded:\")]\nprivate void DataReloadedHandler(NSNotification notification)\n{\n    var locationData = (EntityDocument<LocationInfo>) notification.Object;\n    var entityData = locationData.Entity;\n    // TODO: Do something with the location info loaded.\n}\n```", "```cs\nprivate void SyncLocationDataChanges(LocationInfo info)\n{\n    m_LocationData.Entity = info;\n    m_LocationData.UpdateChangeCount(UIDocumentChangeKind.Done); \n\n}\n```"]