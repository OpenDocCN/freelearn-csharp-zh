- en: '*Chapter 8*: The Scriptable Render Pipeline in Unity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [*Chapter 7*](B17146_07_Final_ASB_ePub.xhtml#_idTextAnchor121), *Understanding
    the Mathematics of Computer Graphics in Unity*, we learned about the mathematics
    used in computer graphics. This knowledge is general computer graphics knowledge,
    and all 3D software and game engines use those mathematical concepts. For a game
    engine, rendering is one of the most important functions. In this chapter, we
    will specifically explore the rendering functions provided by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following key topics will be explored in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Scriptable Render Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unity's Universal Render Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Universal Render Pipeline shaders and materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing performance of the Universal Render Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand what the **Scriptable Render
    Pipeline** is and how to enable the Scriptable Render Pipeline-based **Universal
    Render Pipeline** and **High Definition Render Pipeline** in your project. You
    will also know how to use the **Universal Render Pipeline Asset** to configure
    your render pipeline and how to use the **Volume framework** to apply post-processing
    effects to your game. You will also know how to create a custom shader and material
    that can be used in the Universal Render Pipeline, how to use Unity's **Frame
    Debugger** tool to view the information of the rendering process, and how to use
    the **SRP Batcher** to reduce the number of draw calls in your project.
  prefs: []
  type: TYPE_NORMAL
- en: It sounds exciting! Now, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Scriptable Render Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its first release in 2004, the Unity game engine has grown into the world's
    most widely used real-time content creation platform. A large number of games
    are developed using the Unity game engine. At the same time, Unity is being rapidly
    applied to the content design and production process of traditional industries,
    including VR, AR, and MR simulation applications, architectural design display,
    automobile design and manufacturing, and even film and television animation production.
    The development of real-time rendering technology based on computer graphics is
    an important reason for the rapid growth and widespread use of the Unity engine.
  prefs: []
  type: TYPE_NORMAL
- en: Before the Unity 2018 version, developers could only use the **built-in render
    pipeline** provided by Unity. Since the Unity engine itself is a closed source
    engine, the built-in render pipeline in Unity is like a black box for developers,
    and developers cannot know the specific logic implementation of rendering inside
    the Unity engine. Furthermore, games developed using Unity's built-in render pipeline
    will use the same set of rendering logic on different platforms. It is very difficult
    for developers to customize the render pipeline for different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of the Scriptable Render Pipeline, developers can view its
    code directly on GitHub and use C# code to control the rendering process, customizing
    a unique rendering pipeline for their games or applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code of the Scriptable Render Pipeline on GitHub: [https://github.com/Unity-Technologies/Graphics](https://github.com/Unity-Technologies/Graphics).'
  prefs: []
  type: TYPE_NORMAL
- en: The Scriptable Render Pipeline is a toolbox provided by Unity for developers,
    through which developers can freely implement specific rendering functions in
    Unity. For the convenience of developers, there are two pre-build render pipelines
    based on the Scriptable Render Pipeline available, namely the Universal Render
    Pipeline and the High Definition Render Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using Scriptable Render Pipeline-based pre-built render pipelines, we can
    directly modify a specific function in the render pipelines without having to
    implement a new pipeline from scratch, simultaneously obtaining excellent rendering
    results and continuous updates. Therefore, when using Unity to develop games,
    there are three ready-made render pipelines to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: The legacy built-in render pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Universal Render Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The High Definition Render Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you can also choose to develop your own render pipeline based on
    the Scriptable Render Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some open source projects on GitHub made using the Universal
    Render Pipeline or the High Definition Render Pipeline, which you can download
    and use.
  prefs: []
  type: TYPE_NORMAL
- en: The Fontainebleau Demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first one is the **Fontainebleau Demo** project, made with the High Definition
    Render Pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The Fontainebleau Demo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – The Fontainebleau Demo
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.1*, this project allows you to walk in a forest in first-person
    mode. You can find the project here: [https://github.com/Unity-Technologies/FontainebleauDemo](https://github.com/Unity-Technologies/FontainebleauDemo).'
  prefs: []
  type: TYPE_NORMAL
- en: The Spaceship Demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second project I want to introduce is the **Spaceship Demo** project. This
    is a playable AAA first-person mode demo, as shown in *Figure 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Spaceship Demo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.02_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The Spaceship Demo
  prefs: []
  type: TYPE_NORMAL
- en: 'In this open source project, you can see how to implement GPU-accelerated particle
    effects, such as realistic flames, smoke, and electrical spark visual effects.
    You can find the project here: [https://github.com/Unity-Technologies/SpaceshipDemo](https://github.com/Unity-Technologies/SpaceshipDemo).'
  prefs: []
  type: TYPE_NORMAL
- en: The BoatAttack Demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you choose to use the Universal Render Pipeline as the render pipeline of
    your game, then this open source project is worth checking out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The BoatAttack Demo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.03_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The BoatAttack Demo
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.3*, this is a boat racing game, made using the Universal
    Render Pipeline. You can find the project here: [https://github.com/Unity-Technologies/BoatAttack](https://github.com/Unity-Technologies/BoatAttack).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to open source projects on GitHub, Unity also provides developers
    with free resources on Unity's **Asset Store** for developers to learn and use.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Heretic: Digital Human'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first one I want to share is the **The Heretic: Digital Human** project
    on the Asset Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The Heretic: Digital Human on the Asset Store'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.04_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4 – The Heretic: Digital Human on the Asset Store'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.4*, this is a free project that shows how to make a digital
    human with real skin, eyes, eyebrows, and so on. You can find the project here:
    [https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-digital-human-168620](https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-digital-human-168620).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Heretic: VFX Character'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second project is from **The Heretic** on the Asset Store as well, and
    it''s free to download:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Heretic: VFX Character'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.05_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.5 – The Heretic: VFX Character'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.5*, this project demonstrates how to create a VFX-based
    character with the High Definition Render Pipeline in Unity. You can find the
    project here: [https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-vfx-character-168622](https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-vfx-character-168622).'
  prefs: []
  type: TYPE_NORMAL
- en: Well, after introducing a lot of projects based on Scriptable Render Pipeline,
    which are open source and free, are you more interested in this render pipeline
    now? If so, then we will briefly introduce the two pre-built render pipelines
    based on the Scriptable Render Pipeline, namely the Universal Render Pipeline
    and the High Definition Render Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Render Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Universal Render Pipeline is a pre-built render pipeline based on the Scriptable
    Render Pipeline in Unity. As its name implies, this render pipeline can be used
    on all platforms supported by Unity. Different pipelines cannot be mixed, so once
    you choose to use the Universal Render Pipeline, the built-in render pipeline
    and the High Definition Render Pipeline will not be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Unity uses the legacy built-in render pipeline by default, but you can enable
    the Universal Render Pipeline in your project in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to develop a new project, then you can use the **3D Sample Scene
    (URP)** project template provided by **Unity Hub** to create a new Universal Render
    Pipeline project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – The 3D Sample Scene (URP) project template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.06_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – The 3D Sample Scene (URP) project template
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.6*, the **3D Sample Scene (URP)** project template configures
    project settings to use the Universal Render Pipeline in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – A new URP project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.07_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – A new URP project
  prefs: []
  type: TYPE_NORMAL
- en: After waiting for the new project to be created, you can view the sample scene
    rendered using the Universal Render Pipeline, as shown in *Figure 8.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you want to switch an existing project from the built-in render
    pipeline to the Universal Render Pipeline, recreating a new project using the
    Universal Render Pipeline is not suitable for your project. At this point, choosing
    to use Unity''s Package Manager to install the Universal Render Pipeline is a
    more suitable option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Opening the Package Manager window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.08_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Opening the Package Manager window
  prefs: []
  type: TYPE_NORMAL
- en: 'The Package Manager window can be opened by clicking on **Window** | **Package
    Manager** in the Unity Editor toolbar, as shown in the previous figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Package Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.09_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 8.9*, you can find the **Universal RP** package in the packages
    list and install it in your project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we briefly introduced the Universal Render Pipeline and how
    to install it in your project. A more detailed introduction on how to use it will
    be covered in the *Working with Unity's Universal Render Pipeline* section. Next,
    let's continue our journey to briefly explore the High Definition Render Pipeline
    and how to install it in your project.
  prefs: []
  type: TYPE_NORMAL
- en: The High Definition Render Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The High Definition Render Pipeline is another pre-built render pipeline based
    on the Scriptable Render Pipeline in Unity. Unlike the Universal Render Pipeline,
    it does not support all platforms supported by Unity, only supporting high-end
    platforms. The following table shows the platforms supported by the High Definition
    Render Pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.10_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – The platforms supported by the High Definition Render Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous table, the High Definition Render Pipeline is currently
    mainly used for platforms such as consoles or desktop computers. If you are developing
    a mobile-oriented project, then the High Definition Render Pipeline is not a suitable
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to cover as many usage scenarios as possible, this chapter will
    mainly focus on the use of the Universal Render Pipeline – hence the brief introduction
    to the High Definition Render Pipeline. However, if you want to try it or really
    need to use the High Definition Render Pipeline, installing it is very similar
    to installing the Universal Render Pipeline, as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if you are starting a new project, you can use the **3D Sample Scene
    (HDRP)** project template provided by Unity Hub to create a new High Definition
    Render Pipeline project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.11*, the **3D Sample Scene (HDRP)** project template
    configures project settings to use the High Definition Render Pipeline in the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The 3D Sample Scene (HDRP) template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – The 3D Sample Scene (HDRP) template
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting for the new project to be created, you can view the sample scene
    rendered using the High Definition Render Pipeline, as shown in *Figure 8.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – A new HDRP project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – A new HDRP project
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can also install the **High Definition RP** package from the
    Package Manager in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Installing High Definition RP via Package Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Installing High Definition RP via Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 8.13*, you can find the **High Definition RP** package in
    the packages list and install it to your project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we briefly introduced the High Definition Render Pipeline and
    how to install it in your project.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, *An Introduction to the Scriptable Render Pipeline*,
    you should now have an understanding of what the Scriptable Render Pipeline is
    and how to install a Scriptable Render Pipeline-based Universal Render Pipeline
    and High Definition Render Pipeline in your project. Next, we will discuss in
    detail how to use the Universal Render Pipeline correctly in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unity's Universal Render Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Universal Render Pipeline is widely used by Unity developers. It is not
    only used to develop games for PC or video game consoles; you can also use it
    to develop mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new Universal Render Pipeline project through the Unity Hub
    project template. Through the project template, Unity will automatically set up
    all the render pipeline resources for us. The project also contains a sample scene,
    as shown in *Figure 8.14*. You can find a camera, a directional light, a spot
    light, a post-process volume, reflection probes, and some models in this scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – The sample scene of the Universal Render Pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – The sample scene of the Universal Render Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: For starters, this sample scene is a good starting point. We will use it to
    explain how to use the Universal Render Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the sample scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first explore this sample scene. As you can see in *Figure 8.14*, this
    scene is not complicated, but it contains most of the functions of the Universal
    Render Pipeline. We will introduce these components in the scene separately.
  prefs: []
  type: TYPE_NORMAL
- en: The main camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with the main camera in the scene. We can select the **Main Camera**
    in the **Hierarchy** window to open the **Inspector** window of it, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The Main Camera object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – The Main Camera object
  prefs: []
  type: TYPE_NORMAL
- en: There is a **Camera** component attached to the **Main Camera** object, which
    provides all the functions related to the camera object. You can set the background,
    culling mask, anti-aliasing setting, perspective settings of the camera, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Another component that you need to be aware of is the **Universal Additional
    Camera Data** component, which you can find at the bottom of *Figure 8.15*. If
    you are using the Universal Render Pipeline, Unity does not allow you to remove
    it from the camera because this component is used to store data internally.
  prefs: []
  type: TYPE_NORMAL
- en: The directional light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is only one directional light in this sample project, which is used to
    simulate the sunlight. You can modify the color, intensity, and shadow effect
    of the light by modifying the settings of the **Light** component attached to
    the light object in the scene. You can also modify the rotation property of the
    **Transform** component of the light object to adjust the direction of the directional
    light, as shown in *Figure 8.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – The Directional Light object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – The Directional Light object
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the intensity value of this light is **2**, and soft shadows
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: The Spot Light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four types of lights in Unity, which are **Directional Light**, **Point
    Light**, **Spot Light**, and **Area Light**. In this sample scene, in addition
    to a directional light used to simulate the sunlight, there is also a spot light
    used to simulate a spotlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – The Spot Light object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – The Spot Light object
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding figure, the effect of the spotlight object in Unity
    is like spotlights in the real world. The settings of a spot light are similar
    to the settings of a directional light in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – The Spot Light settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – The Spot Light settings
  prefs: []
  type: TYPE_NORMAL
- en: You still can modify the color, intensity, and shadow effect of the spot light
    by modifying the settings of the **Light** component attached to the **Spot Light**
    object, and you can also modify the range and the inner/outer spot angle of this
    spot light, as shown in *Figure 8.18*.
  prefs: []
  type: TYPE_NORMAL
- en: The Post-process Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the Post-process Volume object in the sample scene.
    In game development, post-processing is a technique that is often used to add
    various effects to a rendered image, common effects such as tone mapping, depth
    of field, bloom, anti-aliasing, and motion blur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Post-process Volume'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Post-process Volume
  prefs: []
  type: TYPE_NORMAL
- en: The Universal Render Pipeline provides the **Volume** component and the **Volume
    Profile** object to manage different post-processing effects applied to rendered
    images, as shown in *Figure 8.19*. One advantage of using the **Volume** component
    is that component and specific settings can be decoupled. All settings on the
    **Volume** component come from the associated **Volume Profile** object. We will
    discuss the **Volume Profile** object in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sample scene, the **Tonemapping**, **Bloom**, and **Vignette** effects
    are applied. If you''re curious about the original rendered image without post-processing,
    let''s see what happens when we disable this post-process volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – The original image (top) versus the post-processed image (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – The original image (top) versus the post-processed image (bottom)
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.20* shows a comparison of the original image and the post-processed
    image of the sample scene.'
  prefs: []
  type: TYPE_NORMAL
- en: The reflection probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **reflection probe** can provide efficient reflection information for related
    models in a scene by sampling the scene around itself so that the surface of the
    model in the scene has a realistic reflection effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Reflection probes in the scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Reflection probes in the scene
  prefs: []
  type: TYPE_NORMAL
- en: In this sample scene, we can see there are three reflection probes as child
    objects of the GameObject named **Reflection Probes**, as shown in the preceding
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we select one of these reflection probes, then the corresponding reflection
    probe will be displayed in the scene view and show the reflection information,
    as shown in *Figure 8.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Viewing the reflection information in the scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Viewing the reflection information in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Since the reflection probes in different positions will obtain different reflection
    information, in order to use the reflection information correctly, they need to
    be placed in the proper place. While the definition of "proper place" varies from
    scene to scene, a general guideline is that you should place reflection probes
    near any large objects in the scene that will be significantly reflected. For
    example, place reflection probes in the areas around the center and corners of
    walls in the scene. Of course, this doesn't mean ignoring all the smaller objects
    in the scene. For example, a campfire in a scene may be a small object compared
    to a wall, but reflecting the fire from the campfire is just as important to create
    a realistic rendering of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The Universal Render Pipeline asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this new sample project is created using the Universal Render Pipeline
    template, Unity has automatically set everything up for us to make the Universal
    Render Pipeline work properly. However, if your project is using the built-in
    render pipeline for development and you want to switch to using the Universal
    Render Pipeline, or if your project has been developed using the Universal Render
    Pipeline but you want to use another render pipeline, it is necessary to know
    how to set up it in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are using the **forward rendering path** in the Universal
    Render Pipeline. The so-called **rendering path** refers to a series of operations
    related to lighting and shading. Unity's built-in render pipeline provides different
    rendering paths, such as the forward rendering path and the **deferred rendering
    path**. After version 12.0.0 of the Universal Render Pipeline, developers can
    also use the deferred rendering path in the pipeline, but that is beyond the scope
    of this chapter. If you are interested in this topic, you can find out more at
    [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html)
    and [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/urp-universal-renderer.html#rendering-path-comparison](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/urp-universal-renderer.html#rendering-path-comparison).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will walk you through the following steps to learn how to set up a render
    pipeline for your project in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the **Project Settings** window. You can open this window through
    **Edit** | **Project Settings** in the Unity Editor toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, click the **Graphics** item in the category list on the left to open
    the **Graphics** Settings panel, as shown in *Figure 8.23*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.23 – The Graphics settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – The Graphics settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the **Scriptable Render Pipeline Settings** property
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Scriptable Render Pipeline Settings** property of the **Graphics** settings
    is associated with an object of the **Universal Render Pipeline Asset** type named
    **UniversalRP-HighQuality**, which is automatically created when this project
    is created using the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **Scriptable Render Pipeline Settings** property of the **Graphics**
    settings is set to none, then Unity will use the default built-in render pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find this **Universal Render Pipeline Asset** object in the **Assets**
    > **Settings** folder of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.24 – The Universal Render Pipeline Asset objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – The Universal Render Pipeline Asset objects
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select the **UniversalRP-HighQuality** object to open the **Inspector**
    window so that we can check the detailed information of this **Universal Render
    Pipeline Asset** object. As shown in *Figure 8.25*, a **Universal Render Pipeline
    Asset** object provides various settings for the current Universal Render Pipeline,
    such as rendering functions and rendering quality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.25 – The Inspector window of this Universal Render Pipeline Asset
    object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – The Inspector window of this Universal Render Pipeline Asset object
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s walk through these settings. We can configure the general settings
    of the render pipeline in the **General** section, as shown in *Figure 8.26*.
    For example, if the **Depth Texture** option is enabled, you can access the depth
    map generated by the render pipeline from your shader code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.26 – The General settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – The General settings
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In game development, **depth textures** are used to represent the depth information
    of objects in 3D space from the camera's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also control the global rendering quality:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.27 – The Quality settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – The Quality settings
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.27*, we enable the global **HDR** option, and the global **Anti
    Aliasing** setting is **2x**. We can also modify the rendering resolution by adjusting
    the **Render Scale** slider.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very important factor for real-time rendering, the lighting of the Universal
    Render Pipeline can also be configured in the **Lighting** section, as shown in
    *Figure 8.28*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.28 – The Lighting settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – The Lighting settings
  prefs: []
  type: TYPE_NORMAL
- en: The main light in the settings panel is the brightest directional light in the
    game scene. You can decide whether to enable it and whether to allow it to cast
    shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.29*, you can find the **Shadows** settings under the **Lighting**
    settings. You can modify the parameters here to adjust what the shadows look like
    in Unity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.29 – The Shadows settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 – The Shadows settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s explore the **Advanced** settings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.30 – The Advanced settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.30 – The Advanced settings
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can check the **SRP Batcher** option to enable the SRP Batcher function
    to improve the performance of the Universal Render Pipeline, which we will explain
    in detail in the *Increasing performance of the Universal Render Pipeline* section.
    We can also modify the level of the **Debug** log output, as shown in *Figure
    8.30*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If there is no Universal Render Pipeline Asset in your project, you can create
    a new one by clicking **Assets** > **Create** > **Rendering** > **Universal Render
    Pipeline** > **Pipeline Asset** in the Unity Editor toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced the Universal Render Pipeline Asset in Unity
    and how to switch between different render pipelines by changing the **Scriptable
    Render Pipeline Settings** property of the **Graphics** settings. Next, we will
    explore another important asset in the Universal Render Pipeline, namely the Volume
    Profile.
  prefs: []
  type: TYPE_NORMAL
- en: The Volume framework and post-processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Volume** framework is provided to game developers by the Scriptable Render
    Pipeline. By using this framework, developers can decouple a component from the
    specific settings of the component. Those render pipelines based on the Scriptable
    Render Pipeline, such as the Universal Render Pipeline and the High Definition
    Render Pipeline, use this framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned before, the Universal Render Pipeline uses the **Volume** component
    and the **Volume Profile** object to manage different post-processing effects
    applied to rendered images. The following steps demonstrate how to enable the
    Volume framework and apply some post-processing effects to the sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to add a **Volume** component to a GameObject in the
    scene to enable the Volume framework, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.31 – Adding a Volume component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.31 – Adding a Volume component
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.31*, the **Profile** property of this **Volume** component is
    **0**, so we can either create a new **Volume Profile** file by clicking the **New**
    button below it or assign an existing **Volume Profile** file to it. Here, we
    will create a new **Volume Profile** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.32 – Creating a new Volume Profile file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.32 – Creating a new Volume Profile file
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Add Override** button to open the **Volume Overrides** panel, and
    click the **Post-processing** item to open the **Post-processing** overrides list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.33 – Add Override'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.33 – Add Override
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.34*, you can see lots of post-processing effects in the **Post-processing**
    overrides list. You can choose the effects that you want to apply to the rendered
    image, such as **Bloom**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.34 – Post-processing effects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.34 – Post-processing effects
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s modify the configuration of the **Bloom** effect; check the
    **Threshold** and **Intensity** options and set their values to **0.9** and **4**
    respectively, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.35 – Setting up the Bloom effect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.35 – Setting up the Bloom effect
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing the preceding steps, switch to the game view. We can see the
    game scene in *Figure 8.36* after applying the **Bloom** effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.36 – The applied Bloom effect image (top) versus the original image
    (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.36_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.36 – The applied Bloom effect image (top) versus the original image
    (bottom)
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we started by exploring the sample scene that is included in
    the template to learn the functions of the Universal Render Pipeline. Then, we
    introduced how to switch between different render pipelines and the Universal
    Render Pipeline Assets. Finally, we demonstrated how to use the Volume framework
    to implement post-processing in the Universal Render Pipeline. The next stop of
    our journey is to explore the shaders and materials that are important for rendering
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The Universal Render Pipeline shaders and materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Shaders** and **materials** are essential for rendering models in Unity.
    Shaders are used to provide algorithms to calculate the color of each pixel. A
    material provides various parameters for the shader associated with it to determine
    how to render the model, such as providing texture as the input of the shader
    and defining how the shader samples the texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.37 – Materials and shaders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.37_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.37 – Materials and shaders
  prefs: []
  type: TYPE_NORMAL
- en: If we select a model in the scene, such as the safety hat model, the material
    settings will be displayed in the **Inspector** window, as shown in *Figure 8.37*.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each material can be associated with a specified shader, and the parameters
    required by this shader are displayed in the **Inspector** window. The commonly
    used shader when using the Universal Render Pipeline is **Universal Render Pipeline/Lit**,
    and this safety hat model is rendered using this shader as well. By adjusting
    various parameters, the **Universal Render Pipeline/Lit** shader can be used to
    render different material surfaces, such as metal, glass, and wood.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The shader with **Lit** in its name implies that this shader will perform lighting
    calculations. The shader with **Unlit** in the name means that the shader does
    not consider the lighting factor when calculating the color of a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the shader associated with a material by selecting a different
    one through the **Shader** drop-down window, as shown in *Figure 8.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.38 – Shaders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.38_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.38 – Shaders
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have determined the shader associated with the material, we can then
    provide various parameters for this specific shader through this material:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.39 – The parameters of the shader'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.39_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.39 – The parameters of the shader
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.39*, developers can specify various maps in the **Surface Inputs**
    section for the **Universal Render Pipeline/Lit** shader. The textures associated
    with these map parameters are used to provide different information for the shader.
    We will explain in detail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base Map** is used to provide the base color of the surface to the shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metallic Map** is used to provide metallic workflow information to the shader
    to determine how "metal-like" the surface is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal Map** is used to add more details to the surface of the model that
    do not exist on the original model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occlusion Map** is used to provide information to the shader to simulate
    shadows from ambient lighting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters required by different shaders may be different, and due to different
    shader algorithms, the final rendering results are also different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.40 – The Unlit shader'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.40_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.40 – The Unlit shader
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we change the shader associated with this material to **Universal
    Render Pipeline/Unlit**, then only **Base Map** remains in the **Surface Inputs**
    section to provide the base color for the surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.41 – The safety hat model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.41_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.41 – The safety hat model
  prefs: []
  type: TYPE_NORMAL
- en: The safety hat model rendered with this material will only display the basic
    color and will no longer be affected by any lighting. You can see the difference
    between the safety hat model and the surrounding models in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading project materials to Universal Render Pipeline materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, if you choose to use the Universal
    Render Pipeline, the built-in render pipeline will no longer be available. This
    includes not only the built-in render pipeline itself but also the shaders used
    with the built-in render pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, when changing an existing project that is being developed using
    the built-in render pipeline to use the Universal Render Pipeline, developers
    often encounter a problem known as "material errors":'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42 – The built-in Standard shader cannot be used in the Universal
    Render Pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.42_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.42 – The built-in Standard shader cannot be used in the Universal Render
    Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can change the shader used to render the safety hat model from
    **Universal Render Pipeline/Unlit** to the built-in **Standard** shader. Then,
    you can see that the safety hat model displays a pink color, which means that
    there is an error in the material, as shown in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if your project is developing using the built-in render pipeline
    but you need to switch to using the Universal Render Pipeline, then in order to
    ensure that the Universal Render Pipeline can work correctly, you need to upgrade
    the existing materials to Universal Render Pipeline materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually modify the shaders associated with the existing materials,
    such as replacing the built-in **Standard** shader with the **Universal Render
    Pipeline/Lit** shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.43 – Upgrading the project materials'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.43_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.43 – Upgrading the project materials
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Unity also provides a function for developers to upgrade
    existing materials to Universal Render Pipeline materials automatically. You can
    find it by clicking **Edit** > **Render Pipeline** > **Universal Render Pipeline**
    > **Upgrade Project Materials to UniversalRP Materials** in the Unity Editor toolbar,
    as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.44 – Material Upgrader'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.44_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.44 – Material Upgrader
  prefs: []
  type: TYPE_NORMAL
- en: Then, the **Material Upgrader** window will pop up. As shown in *Figure 8.44*,
    the changes cannot be undone, so if you want to upgrade all of the materials in
    your project to Universal Render Pipeline materials and have backed up the project,
    click the **Proceed** button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This **Material Upgrader** tool can only upgrade the built-in shaders to Universal
    Render Pipeline shaders but not the custom shaders created by developers. Therefore,
    the custom shaders still need to be modified manually.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shader and a Shader Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may want to create a new shader to implement some custom features
    that can be used with the Universal Render Pipeline. There are two ways to do
    it – you can either create a new shader file or a Shader Graph file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new shader file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, even if our project uses the Universal Render Pipeline, we can
    still use the legacy way to create custom shader files using shader templates
    in the built-in render pipeline in Unity. As shown in *Figure 8.45*, we can click
    **Assets** > **Create** > **Shader** to create a new shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.45 – Create a shader file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.45_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.45 – Create a shader file
  prefs: []
  type: TYPE_NORMAL
- en: 'Some built-in shader templates are listed, such as `CustomShader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.46 – CustomShader'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.46_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.46 – CustomShader
  prefs: []
  type: TYPE_NORMAL
- en: Then, a shader file is created in our project, as shown in the preceding figure.
    You can open a shader source file in your IDE by double-clicking it, and then
    you can use Unity's **ShaderLab language** to write shader code that defines how
    Unity calculates the color rendered for each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: How to write shaders in Unity's ShaderLab language is beyond the scope of this
    chapter, but if you're interested, you can find more information at [https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@7.7/manual/writing-custom-shaders-urp.html](mailto:https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@7.7/manual/writing-custom-shaders-urp.html).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating a shader file, we can also create a new custom Shader
    Graph file to render these models in the scene. Let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Shader Graph file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Compared with the legacy way of creating a shader file, creating a new **Shader
    Graph** file is easier. The Shader Graph feature was introduced to Unity for the
    first time in Unity 2018\. When developing a Shader Graph file, you don't need
    to write shader code but use the visualization node to develop directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still create a new unlit shader, but this time, we will use Shader Graph
    instead of a shader file, as shown in the following steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.47*, click `CustomShaderGraph`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.47 – Creating a new Shader Graph file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.47_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.47 – Creating a new Shader Graph file
  prefs: []
  type: TYPE_NORMAL
- en: 'A new Shader Graph file is created, and its suffix is `.shadergraph`, as shown
    in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.48 – A Shader Graph file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.48_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.48 – A Shader Graph file
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click this file, and this time, the Shader Graph file will not be opened
    in an IDE but a visual node editor, displayed directly in the Unity Editor, as
    shown in *Figure 8.49*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.49 – The Shader Graph editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.49_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.49 – The Shader Graph editor
  prefs: []
  type: TYPE_NORMAL
- en: 'This visual node editor is a lot to take in, so let''s walk through it in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, a shader usually consists of two parts, namely the **Vertex** program
    and the **Fragment** program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Vertex** program is usually used to convert the 3D coordinates of the
    vertices of the model into 2D coordinates in the screen space. We already introduced
    the knowledge of coordinate systems in the previous chapter. In this example,
    there are three nodes in the vertex program, namely **Position**, **Normal**,
    and **Tangent**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, the **Fragment** program determines the color of the pixels,
    and in this example, the **Fragment** program only has one node, named **Base
    Color**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also preview the result of this shader in the **Main Preview** window
    in the lower-right corner, as shown in *Figure 8.49*. This shader we just created
    here will render pixels in blue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've created a new Shader Graph file and opened it in the Shader Graph
    editor, which allows us to edit, add, and delete nodes, we will next take a look
    at how to edit a node in a Shader Graph file. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Editing the properties of a node in Shader Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can edit the properties of an existing node in the Shader Graph file. As
    we mentioned earlier, there is a node named **Base Color**, so let''s edit this
    node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.50 – Edit the Base Color node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.50_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.50 – Edit the Base Color node
  prefs: []
  type: TYPE_NORMAL
- en: In the Shader Graph editor, select the **Base Color** node in the **Fragment**
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the color input of this node to open the color picker window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the color you want to use in the color picker window – in this case,
    we chose yellow for the **Base Color** node. The **Main Preview** window shows
    us what's happening to the shader, as shown in *Figure 8.50*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, it is very easy to modify an existing node; in addition to modifying
    a node, we can also create a new one to provide more data to the shader. Let's
    continue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new node in Shader Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Developing a shader usually involves sampling a texture and returning a color
    value for the shader to use. Let''s perform the following steps to add a new node
    to add the ability to sample textures to our example shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in the Shader Graph editor and select **Create Node** from the
    pop-up menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.51 – Creating a node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.51_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.51 – Creating a node
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `texture` in the search bar in the top-left corner of the **Create Node**
    window, and then select **Sample Texture 2D** item in the results list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.52 – Selecting the Sample Texture 2D node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.52_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.52 – Selecting the Sample Texture 2D node
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 8.53*, a new **Sample Texture 2D** node is created. Click
    the **Texture** slot of this node to provide the texture asset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.53 – Clicking the Texture slot of the node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.53_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.53 – Clicking the Texture slot of the node
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a texture from the pop-up **Select Texture** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.54 – Selecting a texture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.54_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.54 – Selecting a texture
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, as shown in *Figure 8.55*, the **Sample Texture 2D** node samples the
    texture from its **Texture** input and gets the texture''s color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.55 – Loading data from a texture asset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.55_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.55 – Loading data from a texture asset
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have added a new node to the Shader Graph file, but the color obtained
    from texture sampling is still stored in the **Sample Texture 2D** node. Next,
    we need to connect it with the **Base Color** node in the **Fragment** section
    so that the shader can render the pixels with the colors obtained from this texture.
  prefs: []
  type: TYPE_NORMAL
- en: Connect two nodes in Shader Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can pass data such as color from one node to another by connecting two nodes
    in a Shader Graph file, so let''s connect the **Sample Texture 2D** node with
    the **Base Color** node using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the radio button next to the **RGBA(4)** output, as shown in *Figure
    8.56*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.56 – Clicking the radio button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.56_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.56 – Clicking the radio button
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, a line that can be dragged freely will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.57 – A line will appear'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.57_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.57 – A line will appear
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag this line to the color input of the **Base Color** node. As shown in *Figure
    8.58*, we connected these two nodes, and the **Main Preview** window shows us
    that the shader has rendered the pixel using the color obtained from the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.58 – Connecting two nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.58_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.58 – Connecting two nodes
  prefs: []
  type: TYPE_NORMAL
- en: Now you should know how to create a Shader Graph file and how to modify, add,
    and connect nodes in it. As developers, we do not need to write shader code when
    using Shader Graph, but Unity will automatically generate shader code based on
    the content of the Shader Graph file.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced knowledge related to Universal Render Pipeline
    shaders and materials, then demonstrated how to upgrade a built-in material to
    Universal Render Pipeline material, and finally, explored how to create a custom
    shader that can be used in the Universal Render Pipeline. Next, we will continue
    to discuss how to find performance issues and improve performance of the Universal
    Render Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing performance of the Universal Render Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering is a major function of a game engine. Therefore, it is very important
    to understand how to use Unity's render pipeline efficiently. In this section,
    the topic we will discuss is performance.
  prefs: []
  type: TYPE_NORMAL
- en: The Frame Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we should learn how to use tools to view and locate performance bottlenecks
    caused by rendering in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The **Frame Debugger** tool in the Unity Editor is our recommended tool, which
    allows us to easily view the entire process of rendering a frame in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow the following steps to see how Unity''s render pipeline renders
    a frame of your game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the game in the editor by clicking the **Play** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.59 – Playing the game in the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.59_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.59 – Playing the game in the editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Window** > **Analysis** > **Frame Debugger** in the Unity Editor toolbar
    to open the **Frame Debugger** window, as shown in *Figure 8.60*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.60 – Opening the Frame Debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.60_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.60 – Opening the Frame Debugger
  prefs: []
  type: TYPE_NORMAL
- en: In the **Frame Debug** window, click the **Enable** button to take a snapshot
    of the current frame of your game, as shown in *Figure 8.61*:![Figure 8.61 – The
    Frame Debugger
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.61_B17146.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.61 – The Frame Debugger
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.62*, we can see there are **109** draw calls, which call to the
    graphics APIs, such as **OpenGL**, **Direct3D**, and **Vulkan**, to draw objects.
    We can also select a specific draw call to view the detailed information of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.62 – Viewing the draw call information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.62_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.62 – Viewing the draw call information
  prefs: []
  type: TYPE_NORMAL
- en: Through the Frame Debugger tool, we can understand the entire rendering process
    and view the information of a specific draw call, which provides us with insight
    to determine what should be done to improve rendering performance. For example,
    in *Figure 8.62*, we can see that **33** draw calls are used to render opaque
    objects. Therefore, reducing the count of draw calls here is what we should do.
    Next, we will introduce how to use the SRP Batcher to do it.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP Batcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **SRP Batcher** is a feature provided by the Scriptable Render Pipeline,
    so every render pipeline based on the Scriptable Render Pipeline can use this
    feature to reduce the number of draw calls and improve rendering performance.
  prefs: []
  type: TYPE_NORMAL
- en: In order to ensure that the SRP Batcher can work correctly in your project,
    you need to ensure two things. The first is to enable the **SRP Batcher** function
    of the Universal Render Pipeline, and the second is to ensure that the shaders
    in your project are compatible with the SRP Batcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first make sure that the SRP Batcher is enabled in the render pipeline.
    As we mentioned in *The Universal Render Pipeline Asset* subsection, we can enable
    it by checking the **SRP Batcher** option in the **Advanced** settings of the
    Universal Render Pipeline Asset file that our project is using, as shown in *Figure
    8.63*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.63 – Enabling the SRP Batcher'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.63_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.63 – Enabling the SRP Batcher
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s check whether the shaders we are using to render these opaque
    objects are compatible with the SRP Batcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.64 – The SRP Batcher compatibility status of the shader'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.64_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.64 – The SRP Batcher compatibility status of the shader
  prefs: []
  type: TYPE_NORMAL
- en: We can find the SRP Batcher compatibility status of the shader in the **Inspector**
    window, as shown in the preceding figure. Here, the **Universal Render Pipeline/Lit**
    shader is used, which is compatible with the SRP Batcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the game and check the Frame Debugger again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.65 – The number of draw calls is reduced'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.65_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.65 – The number of draw calls is reduced
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 8.65*, the total number of draw calls has been reduced
    from **109** to **91**, the number of draw calls used to render opaque objects
    has been reduced from **33** to **20**, and each draw call is marked as **SRP
    Batch**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we started by introducing how to use Unity's Frame Debugger
    tool to view the entire rendering process and the information of a specific draw
    call. Then, we also explored how to reduce the number of draw calls and improve
    rendering performance by using the SRP Batcher.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces three ready-made render pipelines to choose from in
    Unity, namely the legacy built-in render pipeline and two pre-made render pipelines
    based on the Scriptable Render Pipeline – the Universal Render Pipeline and the
    High Definition Render Pipeline. At the same time, we also introduced some open
    source projects that use these render pipelines for you to learn and use.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed how to use the Universal Render Pipeline in Unity by first
    exploring a sample scene, and then we explained how to use the Universal Render
    Pipeline Asset to configure your render pipeline and the Volume framework to apply
    post-processing effects to your game.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced the concept of shaders and materials, demonstrated how to
    upgrade a built-in material to Universal Render Pipeline material, and explored
    how to create a custom shader that can be used in the Universal Render Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored how to use Unity's Frame Debugger tool to view the information
    of the rendering process and how to use the SRP Batcher to reduce the number of
    draw calls.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this chapter, you should now understand how to work with the Universal
    Render Pipeline correctly in Unity. In the next chapter, we will introduce how
    to use the **Data-Oriented Technology Stack** (**DOTS**) in Unity.
  prefs: []
  type: TYPE_NORMAL
