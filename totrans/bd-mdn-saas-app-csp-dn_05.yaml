- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Restful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s online-centric digital landscape, **application programming interfaces**
    (**APIs**) have become ubiquitous in the development of **Software-as-a-Service**
    (**SaaS**) applications. They allow different systems and applications to communicate
    with each other and share data. Among the different types of APIs, **Representational
    State Transfer** (**REST**)ful APIs have become the most widely used and accepted
    standard, and that is what we will focus on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the basics of building RESTful APIs and the
    key principles that guide their design. You will learn about the key components
    of a RESTful API, such as resources, representations, and the main HTTP verbs
    (`GET`, `POST`, `PUT`, `PATCH`, and `DELETE`).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will learn about the various strategies to version RESTful
    APIs, such as URL versioning, custom header versioning, media type versioning,
    and deprecation and sunsetting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What are RESTful APIs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching API operations to HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing better with REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning public APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the key principles
    and strategies to build RESTful APIs, and you will be well-equipped to design,
    develop, and test them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5).
  prefs: []
  type: TYPE_NORMAL
- en: What are RESTful APIs?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST was introduced by Roy Fielding in his doctoral dissertation at the University
    of California, Irvine, in 2000\. In his dissertation, Fielding defined the architectural
    constraints that formed the basis of RESTful systems and described how REST could
    be used to build scalable and flexible web services. The concepts outlined in
    his dissertation have since become widely adopted and are used as the foundation
    to build many modern web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs are a type of web-based interface that allows for communication
    between different software systems. They utilize a standard set of constraints
    and principles defined by the REST architecture to exchange data between a client
    and server. Resources are identified by unique URLs, and the behavior toward these
    resources is defined by the HTTP methods used. RESTful APIs are commonly used
    to build scalable and flexible web services and can return data in different formats,
    such as JSON or XML. They offer a simple and flexible way for different software
    systems to interact and exchange data over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down what the REST acronym means!
  prefs: []
  type: TYPE_NORMAL
- en: '**Representational** refers to the idea that each resource in a RESTful API
    is represented by a unique identifier (such as a URL) and can be represented in
    a variety of formats, such as JSON or XML. The representation of a resource is
    a snapshot of its current state and can be used by a client to manipulate the
    resource.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of a resource as an object, such as a description of a user in
    a system. The user will typically have a unique ID that is used to refer to that
    user. In a REST system, the user *resource* with an ID = 123 could be *represented*
    by the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.a-system.com/api/v1/users/123`'
  prefs: []
  type: TYPE_NORMAL
- en: The user can be retrieved, modified, or deleted by using this URL. The URL *represents*
    the user on any external system that is consuming the **PAI**.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET`, `POST`, `PUT`, and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to issue a `GET` request to the preceding dummy URL, you would receive
    the *state* of the object represented by that URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transfer** refers to the transfer of the representation of a resource from
    a server to a client and vice versa. The transfer is typically performed over
    the HTTP protocol and is based on the principles of statelessness and uniform
    resource identification. In RESTful APIs, the transfer of state is used to create,
    read, update, and delete resources on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs do not have to communicate over HTTP, although they very often
    do. They could use any other possible communication protocol, such as **remote
    procedure calls** (**RPCs**). However, the large majority of RESTful APIs use
    HTTP as the chosen communication mechanism, and that is all that we will consider
    in this chapter. If you have a use case for an alternative communication protocol,
    then I hope the information in this chapter is useful in a more general sense!
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details of building restful APIs, there are a few general
    points to consider that will aid our understanding of some of the more complex
    concepts that will follow.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of a RESTful API, idempotency is a property of an API endpoint
    that allows multiple identical requests to have the same effect as a single request.
    This means that, regardless of the number of times the same request is made, the
    end result should be the same.
  prefs: []
  type: TYPE_NORMAL
- en: An idempotent request will always produce the same response from a server, regardless
    of how many times it is executed. This property is useful to reduce the chance
    of errors and conflicts when making multiple requests to the same endpoint, especially
    when dealing with network connectivity issues or other types of failures.
  prefs: []
  type: TYPE_NORMAL
- en: The most common HTTP methods considered idempotent are `GET`, `PUT`, `DELETE`,
    and certain types of `POST` requests. On the other hand, non-idempotent methods,
    such as `POST` without specifying the idempotent semantics, may have unintended
    side effects if repeated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: This is to say that you can retrieve a resource at a URL as many times as you
    like, and the response will be the same every time. A `GET` request is idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of a RESTful API, a “safe” operation is one that is guaranteed
    not to modify the state of a server or have any side effects. Safe operations
    are read-only and do not alter any resources on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The most common example of a safe operation is a `GET` request, which retrieves
    data from the server without changing it. Other safe operations might include
    `OPTIONS`, `HEAD`, and some types of `POST` requests that are specifically designed
    to only retrieve data and not make any changes to the server state.
  prefs: []
  type: TYPE_NORMAL
- en: Safe operations are contrasted with “unsafe” operations, such as `PUT`, `POST`,
    and `DELETE`, operations that modify the state of the server and may have side
    effects. These operations are considered unsafe because they can have unintended
    consequences if executed improperly, such as deleting important data or altering
    resources in unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP status codes are three-digit numbers returned by a server in response to
    a client’s request. These codes indicate the outcome of the request and provide
    information about the status of the requested resource.
  prefs: []
  type: TYPE_NORMAL
- en: There are many HTTP status codes – I will briefly reference only the set that
    I think is most applicable to building RESTful APIs. Don’t worry about memorizing
    all of these! As you will see, when we start to build up the examples, it is quite
    intuitive which ones should be used and when! And remember, information like this
    is only ever a Google search away!
  prefs: []
  type: TYPE_NORMAL
- en: 'Each status code is a three-digit number. The first digit gives the category
    of the status code. There are five category codes, each with a specific meaning
    and purpose. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`100 Continue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200 OK` and `201 Created`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`301 Moved Permanently` and `302 Found`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 Bad Request` and `401 Unauthorized`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500 Internal Server Error` and `503` `Service Unavailable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many status codes within these categories. Some of the common and
    most applicable to RESTful APIs are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200 OK`: The request was successful, and the requested resource was returned.
    This status is commonly returned from a successful `GET`, `PUT`, or `PATCH` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201 Created`: The request was successful, and a new resource was created as
    a result. This status code is often returned as the result of a successful `POST`
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204 No Content`: The request was successful, but no resource was returned.
    This status is commonly returned from a successful `DELETE` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 Bad Request`: The request was malformed or invalid. With a RESTful API,
    requests are often in JSON format. This would imply that the object is not correct
    per the expectations of the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 Unauthorized`: The request requires authentication, and the client did
    not provide valid credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 Forbidden`: The client does not have access to the requested resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not Found`: The requested resource could not be found. The request is
    looking for a resource that is not there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405 Method Not Allowed`: The request method, such as `GET`, `POST`, and `DELETE`,
    is not allowed for the requested resource on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500 Internal Server Error`: An unspecified error occurred on the server. This
    status code is a “catch-all” error to let the user know that something has gone
    wrong on the server – for example, there could be an exception in the backend
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`503 Service Unavailable`: The server is currently unable to handle the request
    due to maintenance or high traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other HTTP status codes that can be used, each with a specific
    meaning and purpose. We will make use of these codes when we build out an example
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to dealing with an error code on a RESTful API, it is important
    to have a clear and consistent approach in place. The HTTP status code is an essential
    part of this approach, and by using the status codes correctly, clients of the
    API are able to understand what has gone wrong and will have an idea as to why.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the status codes correctly, it also helps to provide clear
    and informative error messages. These messages should explain what has gone wrong
    in an easily understood way and, if possible, provide guidance on how to resolve
    the issue.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding will help users of the API, but it is also very important that
    the developers of the API are also informed when there has been an error so that
    they can take action to resolve or prevent recurrences. Because developers cannot
    watch over every API interaction, this is typically done with logging.
  prefs: []
  type: TYPE_NORMAL
- en: Logging refers to the process of capturing and recording information about an
    API’s behavior and performance and persisting this information in a data store
    so that it can be searched later to identify issues and troubleshoot problems.
    Logging is an essential part of any API’s operational infrastructure, as it provides
    a record of what has happened on the system.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on API implementation, but we haven’t forgotten about
    logging and monitoring – we will cover both in detail in [*Chapter 9*](B19343_09.xhtml#_idTextAnchor219)!
  prefs: []
  type: TYPE_NORMAL
- en: JSON data formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While RESTful APIs do not have to use **JavaScript Object Notation** (**JSON**)
    formatting, it is an exceptionally popular choice and will be the formatting standard
    that is used throughout this book. JSON is a lightweight data exchange format
    that is easy for humans to read and write, and it is also easy for machines to
    parse and generate. It is completely language-independent, but it does make use
    of conventions that are familiar to the C family of languages (C, C++, C#, Java,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of some information represented as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JSON data takes the form of key-value pairs, where each key is a string, and
    each value can be of type string, number, Boolean, null, array, or another JSON
    object. The ability to nest JSON objects allows for complex types to be represented
    in this straightforward way.
  prefs: []
  type: TYPE_NORMAL
- en: The keys are always strings, so they are encased in double quotation marks.
    The values are encased in quotes if they are strings, square brackets if they
    are arrays, and curly brackets if they are objects. All of these are shown in
    the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: We have established that JSON-encoded data will be sent and received over HTTP.
    Next, we will look at how that data is transmitted, looking at the most common
    HTTP verbs and describing how and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Matching API operations to HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In language, a verb is a “doing” word. It describes an action, state, or occurrence.
    In English, examples of verbs include “run,” “think,” “sing,” and “do,” as well
    as many thousands more!
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP verbs describe things that you can “do” over HTTP! Five main verbs
    are used – `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`. Each of these serves a
    different purpose, although the precise purpose of each is not tightly defined,
    and it is not uncommon to accidentally use the wrong one. In this section, we
    will cover the uses of the five commonly used HTTP verbs, and we will give an
    example of them being used in our demo application.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GET` HTTP verb is used to *retrieve a resource from a server*. When a client
    sends a `GET` request to a server, the server responds by returning the requested
    resource to the client. The resource can be any type of data, such as a web page,
    image, or file. The `GET` verb is the most widely used HTTP verb and is considered
    to be a safe and idempotent method, which means that it can be called multiple
    times without any side effects. It is also cacheable, which means that the response
    can be stored in a cache and reused to improve performance. The `GET` verb should
    only be used to retrieve information and never to make changes on the server.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to RESTful APIs, the `GET` verb is used to retrieve a representation
    of a resource or a collection of resources from a server. The resource can be
    identified by a `GET` request can also include query parameters, which can be
    used to filter the results or specify the format of the returned data. The server
    responds to a `GET` request with a representation of the resource in the form
    of an HTTP response, along with the appropriate HTTP status code. The most common
    status code for a `GET` request is `200 OK`, indicating that the request was successful
    and the resource was returned.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `POST` HTTP verb is used to *submit an entity to be processed by the resource
    identified by the URI*. A `POST` request is typically used to create a new resource
    or (sometimes) to update an existing one. The `POST` verb is not idempotent, which
    means that it can have different effects depending on how many times it is called.
    It is also not safe, meaning that it can modify the resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: When a client sends a `POST` request to a RESTful API, typically, the server
    creates a new resource with the data provided in the request body and returns
    a response with a status code indicating the outcome of the request. The most
    common status code for a successful `POST` request is `201 Created`, indicating
    that a new resource has been successfully created. The URI of the newly created
    resource is typically included in the response headers so that the client application
    can retrieve and work with the newly created resource immediately. The data in
    a `POST` request can be in any format, such as JSON or XML, but it is usually
    in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DELETE` HTTP verb is used to *delete a resource from a server*. A `DELETE`
    request is used to remove the specified resource from the server. The `DELETE`
    verb is idempotent, which means that it can be called multiple times without any
    side effects. It is also not safe, meaning that it can modify the resource on
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: When a client sends a `DELETE` request to a RESTful API, the server deletes
    the specified resource and returns a response with a status code, indicating the
    outcome of the request. The most common status code for a successful `DELETE`
    request is `204 No Content`, indicating that the resource has been successfully
    deleted. The client usually doesn’t receive any content in the response body,
    only the status code. The `DELETE` request usually requires the URI of the resource
    to be specified in the request so that the server is able to identify which resource
    to delete.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that some RESTful APIs may not allow `DELETE` requests and
    will return a `405 Method Not Allowed` status code if a `DELETE` request is received.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PUT` HTTP verb is used to *update an existing resource or create a new
    one if it does not exist*. A `PUT` request is used to submit a representation
    of the resource to be updated or created. The representation of the resource is
    included in the request body and typically encoded in a format such as JSON or
    XML. The `PUT` verb is idempotent, which means that it can be called multiple
    times without any side effects. It is also not safe, meaning that it can modify
    the resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: When a client sends a `PUT` request to a RESTful API, the server updates the
    specified resource with the data provided in the request body and returns a response
    with a status code, indicating the outcome of the request. The most common status
    code for a successful `PUT` request is `200 OK`, indicating that the resource
    has been successfully updated. If a new resource is created, the `201 Created`
    status code will be returned. The URI of the updated resource is typically included
    in the response headers.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that `PUT` requests may require a client to send the full
    representation of the resource in the request body, including all properties,
    even if only a few of them are to be updated. This can make a `PUT` request inefficient
    in terms of bandwidth used, and it may be better to use the `PATCH` verb.
  prefs: []
  type: TYPE_NORMAL
- en: PATCH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PATCH` HTTP verb is used to *partially update an existing resource on a
    server*. A `PATCH` request is used to submit a set of changes to be made to the
    specified resource rather than replacing the entire resource. The set of changes
    is typically encoded in a format such as JSON or XML and is included in the request
    body. The `PATCH` verb is idempotent, which means that it can be called multiple
    times without any side effects. It is also not safe, meaning that it can modify
    the resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In a RESTful API context, the `PATCH` verb is typically used to partially update
    an existing resource on the server. When a client sends a `PATCH` request to a
    RESTful API, the server applies the changes provided in the request body to the
    specified resource and returns a response with a status code indicating the outcome
    of the request. The most common status code for a successful `PATCH` request is
    `200 OK`, indicating that the resource has been successfully updated. The URI
    of the updated resource is typically included in the response headers. The data
    in a `PATCH` request can be in any format, such as JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that `PATCH` requests require a client to send a specific
    set of changes to be made to the resource rather than the full representation
    of the resource. This makes `PATCH` requests more lightweight and efficient than
    `PUT` requests for partial updates.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important concept to understand when working with APIs is **data transfer
    objects** (**DTOs**). A DTO is a design pattern that is commonly used to transfer
    data between layers or systems. In the case of a RESTful API, this is typically
    to transfer data from the backend (API) to the frontend **user interface** (**UI**).
    The general purpose of DTOs is to decouple the structure of the data from the
    underlying systems that use it, allowing for more flexibility and easier maintenance.
    They also provide a standardized way to handle data, making it easier for different
    components of a system to communicate and exchange information.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs are particularly useful in RESTful APIs, as they provide a standard way
    to represent data when sending and receiving requests between a client and a server.
    When designing a RESTful API, the use of DTOs allows the API to define the structure
    of the data that is exchanged without having to tightly couple the implementation
    of the API to the structure of the data. This decoupling makes it easier to evolve
    the API and make changes to the underlying data model without affecting the API
    clients. Additionally, using DTOs enables the API to shape the data it returns
    to better match the needs of the client, reducing the amount of data transferred
    over the network and improving performance. Furthermore, DTOs can be used to validate
    the data being passed between the client and server, ensuring that only valid
    data is accepted and processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first set of DTOs that we will see in this chapter will look a lot like
    the entity types that we defined for our database in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082)
    and [*Chapter 4*](B19343_04.xhtml#_idTextAnchor102), and they will relate to operations
    that we may wish to perform on the database. For example, the following entity
    type represents `Habit` in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say that we wanted to create a simple `Habit` that only had a `Name`
    property populated and was tied to a certain `User`. We could send the following
    DTO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This could be used by the backend to create a simple `GoodHabit` object in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to retrieve the `GoodHabit` objects but only with the name and
    ID properties, we could use a DTO that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And, if we needed more information than simply a name and an ID, we could further
    define another DTO that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see how we can start with the entity type that has a lot of database-specific
    information, and we can selectively model that data in different ways for different
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: We will illustrate this point with examples later in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Designing better with REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good design with RESTful APIs is essential to create an API that is easy to
    use and understand. One of the key principles of REST is that it is based on the
    use of resources and their representations. Therefore, it’s essential to design
    the API’s resources and their representations in a way that is meaningful and
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: When designing resources, it’s important to use URIs that are meaningful and
    consistent. Resources should be named in a way that is easy to understand, and
    the URIs should be structured logically and hierarchically – for example, `/users/1/orders/2`
    is more meaningful than `/users?id=1&orderid=2`.
  prefs: []
  type: TYPE_NORMAL
- en: Representations of resources should be in a format that is easy to parse, such
    as JSON or XML. It’s also important to use the `Content-Type` and `Accept` headers
    to specify the format of the request and response. This allows the client to specify
    its preferred format and the server to provide the appropriate representation.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of a good RESTful API design is stateless communication.
    This means that a client and server should not maintain any state between requests.
    This can be achieved through the use of HTTP headers and cookies. This allows
    for a higher degree of scalability and flexibility, as the server does not have
    to maintain any state for each client.
  prefs: []
  type: TYPE_NORMAL
- en: Security is also an important aspect of RESTful API design. It’s important to
    use secure communication protocols, such as HTTPS, and to implement authentication
    and authorization mechanisms to protect an API’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the aforementioned points, good RESTful API design also includes
    error handling, caching, versioning, and documentation. Good documentation is
    essential for developers to understand how to use the API. It’s also important
    to provide clear and informative error messages to clients when an error occurs.
    In the previous chapter, we built up a database. In this chapter, we’ll now add
    an API to interact with the database that we built. We will use a very typical
    layer structure for a SaaS app that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The layering structure](img/B19343_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The layering structure
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see the database and the **object–relational
    mapping** (**ORM**) that we covered in previous chapters. In this chapter, we
    are learning about the API, so we will build a service layer to interact with
    the database and a controller layer to handle communication with the UI or any
    other client.
  prefs: []
  type: TYPE_NORMAL
- en: A service layer is an architectural pattern in software design that acts as
    an intermediary between the application’s UI and the underlying data storage.
    The main purpose of a service layer is to encapsulate and abstract the business
    logic of an application, promoting the separation of concerns and making it easier
    to maintain and modify the code. It also enables better unit testing, as the service
    layer can be tested in isolation from the rest of the application. Additionally,
    it can improve the scalability of an application by allowing the UI and data storage
    components to evolve independently.
  prefs: []
  type: TYPE_NORMAL
- en: In a RESTful API, controllers are responsible for handling HTTP requests from
    clients and returning appropriate HTTP responses. They act as an intermediary
    between a client and an application’s business logic, using the appropriate service
    layer to perform any necessary operations.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers are responsible for mapping URLs to specific actions in an application,
    such as retrieving data from a database, creating new resources, or updating existing
    ones. They parse an incoming request to determine the desired action and then
    use the appropriate service layer to perform that action and generate a response.
  prefs: []
  type: TYPE_NORMAL
- en: An example API design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will recall that in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), we
    started to build out the `HabitService` API with a couple of endpoints. We’ll
    start from where we left off in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082),
    but we will add a lot more functionality to the controller!
  prefs: []
  type: TYPE_NORMAL
- en: 'The three endpoints that we have already added are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `GET` endpoint that gets a single habit based on a passed-in ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another `GET` endpoint that returns all of the habits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, a `POST` endpoint that will create a new habit in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we will add an endpoint for each of the five primary HTTP verbs
    that we have discussed in this chapter. We already have `GET` and `POST`, so we
    will add `PUT`, `PATCH`, and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But, before we write the endpoints, we will first add the DTOs. We already
    have a `CreateHabitDto` that was added in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082).
    Run the following script from the root folder, or add the files manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following into the `HabitDetailDto` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following to the `HabitDto` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, add the following to the `UpdateHabitDto` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That is all that is required for the DTOs. We will use these when we start to
    build out the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: AutoMapper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now need to consider a tool that we will use to convert between the database
    types and the DTOs. That tool is AutoMapper.
  prefs: []
  type: TYPE_NORMAL
- en: AutoMapper is an open source library that enables you to establish a configuration
    to convert one object to another. This can be particularly useful when translating
    between different types of objects, such as database entities and DTOs. Even though
    both the DTO and the entities might have a similar structure, their implementation
    can differ. This library helps to keep your codebase clean and maintainable by
    reducing the amount of repetitive and boilerplate mapping code that is needed
    to translate between different types, making your application more efficient and
    easier to modify or add new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'AutoMapper is designed to make it easy to map one type of object to another,
    and it provides a simple, fluent API to define the mappings. Some of the key features
    of AutoMapper include:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for flattening and unflattening of object hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for converting between different data types and custom-type converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for advanced configuration options, such as mapping to and from interfaces
    and inheritance hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for custom logic and conventions to be used during mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for **Language Integrated Query** (**LINQ**) expressions to define mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AutoMapper can help to keep your codebase clean and maintainable by reducing
    the amount of repetitive, boilerplate mapping code that is required to convert
    between different types. This can make your application more efficient, and it
    makes it easier to add new features or make changes to existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with AutoMapper, install the tool in the API project with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the packages updated, as shown in the preceding code snippet, we can start
    to create mappings for the database types that we have created.
  prefs: []
  type: TYPE_NORMAL
- en: You will recall that we added an entity type called ‘Habit’ in the database
    project in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), and we have added
    a number of additional properties to the object in [*Chapter 4*](B19343_04.xhtml#_idTextAnchor102).
    If you run the `HabitService` and use Thunder Client to hit the endpoint that
    returns all of the habits, you will see that the data which is returned includes
    all of these additional properties.
  prefs: []
  type: TYPE_NORMAL
- en: This habit class represents a database entity. It is very specific to the database
    and works very well to represent the idea of a good habit for that specific use
    case. But, it does not work well to transmit data to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: We would rather that the data was sent to the UI in the form of a DTO, such
    as the one we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to include the collections for the progress updates or the
    reminders. Including this information could add a huge amount to the required
    bandwidth of the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TenentName` property is of no use to the user because they will already
    know which tenant they are!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DTO that we have created looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are taking the ID, name, and description of the habit directly
    from the entity type, but more complex transformations are also possible.
  prefs: []
  type: TYPE_NORMAL
- en: While we could simply copy the properties over manually, that could quickly
    get very tedious, so we’ll use `AutoMapper` to do this automatically!
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by going into the `Program.cs` class and adding the `AutoMapper` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open up the `HabitsController` class, and add the following to the `using`
    statements: using `AutoMapper`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following to the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `using` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the constructor to take in the mapper, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify the two existing `GET` endpoints in the controller to use `AutoMapper`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before, the controller was simply returning the entity object from the database,
    now that object is being mapped automatically to a DTO, which is returned from
    the controller. This does require a little configuration, though.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to tell `AutoMapper` how it should convert between the two
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Mappers` in the `HabitService` project and a class called
    `HabitMapper.cs`. You can use this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateMap` method instructs `AutoMapper` to map between the two types.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now hit the endpoint using Thunder Client to get the habits, and you
    should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A successful response](img/B19343_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A successful response
  prefs: []
  type: TYPE_NORMAL
- en: This section has demonstrated how we can automatically convert between database
    types and types for data transfer. This is a very important piece of the API puzzle,
    and understanding how to operate AutoMapper will help you write better code and
    also reduce the amount of data sent between the API and any connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: Modify the service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can build the additional endpoints on the API to update and delete
    the habits, we need to add some functionality to the service class. We already
    created the service class and interface in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082),
    but we will extend the functionality here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HabitService` class that implements the preceding interface will need
    to have two methods added to delete and update the habits that are stored in the
    database. Add the following two methods to the `HabitService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to add a `using` statement to the service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That is all that is required in the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: That has been quite a lot of configuration, but we are now ready to build the
    controller class.
  prefs: []
  type: TYPE_NORMAL
- en: Add to the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have done most of the heavy lifting already by adding the DTOs, configuring
    AutoMapper, and building the service layer. We will need to add three additional
    endpoints to the controller. Let’s start with the `DELETE` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward. It uses the service method to delete the entry
    in the database and then returns `NoContent` – which is considered best practice
    for a delete method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the endpoint to update the object with the `PUT` verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There is some error trapping here, which returns `404` if the client attempts
    to update an entry that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the endpoint that updates an object using the `PATCH` verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a little more involved, as it uses `JsonPatchDocument` to modify the
    object. You will also need to add two `using` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That is all that we need to do at this stage. We now have a good example of
    the five most common HTTP verbs. Before we move on, we should test that these
    all work. We will use Thunder Client for this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the endpoint that we have just added, we will need a test client. In
    keeping with the theme of using **Visual Studio Code** (**VS Code**), we will
    add an extension to the code so that we can do everything in one place. We have
    touched on this tool a couple of times already, but we will take a close look
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see the Thunder Client icon on the extensions toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The Thunder Client icon](img/B19343_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The Thunder Client icon
  prefs: []
  type: TYPE_NORMAL
- en: 'With Thunder Client, you can hit your API straight from VS Code and check that
    it is behaving as expected. We’ll do this now. Start the API running by going
    to the terminal in VS Code, navigating to the API project, and typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will build the project and get the API running. Now we can start adding
    the tests!
  prefs: []
  type: TYPE_NORMAL
- en: Add a GET request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Thunder Client icon (*if you don’t see this on the left-hand menu,
    exit and restart the* *Docker environment*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `GoodHabits`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on the newly created collection, click `GET` Habits (don’t click
    on the bit below the **New Request** button; right-click the collection).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your collection should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The Thunder Client collection](img/B19343_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The Thunder Client collection
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `tenant` key with the `CloudSphere` value (you’ll remember from
    [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082) that we need to specify the tenant
    for the multi-tenancy).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you’re done, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The configured request](img/B19343_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The configured request
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a correctly configured `GET` request that should
    return all of the habits in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, click the `GET` request and test the endpoint. You will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The returned habits](img/B19343_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The returned habits
  prefs: []
  type: TYPE_NORMAL
- en: We have put in quite a lot of work to get to this stage! We are showing the
    data from the `SeedData` file in the database project, returned from our `HabitsService`.
    We will shortly build a UI to present this information.
  prefs: []
  type: TYPE_NORMAL
- en: Add a POST request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Repeat the preceding, building a `POST`user request. In this case, we’ll need
    to specify the habit details in the body in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The configured POST request](img/B19343_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The configured POST request
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the JSON specified matches the `CreateHabitDto` class.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to set the tenant in the header and change the request type to
    `POST`! Hitting **Send** will confirm that the habit has been created.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have tested the `get all` endpoint and the `POST` endpoint. It would
    be a useful exercise to add another `GET` to test the `get-by-id` endpoint as
    well!
  prefs: []
  type: TYPE_NORMAL
- en: Add a DELETE request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We may want to delete a habit from the database, so we have added the required
    methods to the service and the controller. We can test this again in the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The configured DELETE request](img/B19343_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The configured DELETE request
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that no content is required in the body. But
    don’t forget to add the tenant header!
  prefs: []
  type: TYPE_NORMAL
- en: Add a PUT request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing the `PUT` endpoint that we have added is fairly straightforward. Configure
    a `PUT` request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The configured PUT request](img/B19343_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The configured PUT request
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how to configure a `PUT` request. This will alter
    the name and description of the habit with `id=103`. You may need to change the
    ID in the URL if you have made changes to the data along the way. You can check
    that this has made the changes by hitting the `get-by-id` endpoint again.
  prefs: []
  type: TYPE_NORMAL
- en: Add a PATCH request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing the `PATCH` endpoint is a little more tricky. You will recall that
    the `PATCH` endpoint that we built in the controller is expecting a `JsonPatchDocument`
    object, so this is what we will have to supply. A `Patch` document could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the `replace` operator to change the value of the `Name`
    variable. We can set up the request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The configured PATCH request](img/B19343_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The configured PATCH request
  prefs: []
  type: TYPE_NORMAL
- en: Configuring this and hitting send will update the habit with `id=103`. Again,
    you may need to change the ID in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the service will return a `204 No Content` response upon
    a successful patch. This is the expected behavior and is considered best practice
    for the response to a successful `PATCH`.
  prefs: []
  type: TYPE_NORMAL
- en: This would be a good time to talk a bit more about HTTP codes!
  prefs: []
  type: TYPE_NORMAL
- en: Using the correct HTTP codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter, we talked about HTTP status codes, and we looked at
    a few that may be useful to consider, even for the very basic examples we saw
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two that we should add and test are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If a request is made to get a user that does not exist, the correct status code
    should be `404` `Not found`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a successful request is made to create a new user, the correct status code
    should be `201 Created`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we have separated the service and the controller, we do not have to
    change any of the service logic to facilitate this. The controller has the sole
    responsibility for assigning the HTTP status codes. While the example here is
    fairly straightforward, I hope you can see how separating the logic in this way
    can be very beneficial when things start to get more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by modifying the `GET` method, which takes an `id` parameter to
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have simply added a check to see whether the user object is `null`, and if
    so, we return `NotFound()`, which will return the `404` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test this in Thunder Client by requesting a user ID that you know doesn’t
    exist in your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Habit not found](img/B19343_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Habit not found
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have demonstrated that requesting a non-existent
    user now results in a `404` HTTP status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s fix the HTTP code to create a new user. Modify the `Create` endpoint
    to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have changed the return from `Ok()` to `CreatedAtAction(…)`. This will return
    `201 – Created` and also the location of the newly created resource to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back into Thunder Client and create another user, you will see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Created with a 201 status code](img/B19343_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Created with a 201 status code
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Headers** tab will give you the location of the newly created
    resource. This can be very useful to consumers of your API who may want to interact
    with the new resource immediately.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the `PUT` and the `PATCH` endpoints in `HabitsController`, you
    can see that we are returning a few different status codes depending on what has
    happened when processing the response. It would be a good exercise to go through
    these and convince yourself that you have understood why each of them has been
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `PATCH` endpoint, you will see that it performs the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks to see whether the ID provided is valid and, if not, returns `404
    –` `Not Found`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It checks to see whether the updated model is valid and, if not, returns a validation
    problem (a subset of `400` `Bad Request`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are any other issues with the update, it returns `400` `Bad Request`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no issues, it returns `204` `No Content`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `No Content` HTTP status code (`204`) is used to indicate that the server
    has successfully processed the request and that there is no response body to return.
    In the case of a `PATCH` request, the `No Content` status code is used to indicate
    that the server has successfully processed the update to the resource without
    returning any content in the response. The idea is that the client already knows
    what the updated resource looks like, and therefore, there is no need to return
    the updated resource information in the response. The client can simply assume
    that the update was successful and that the resource was updated as requested.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning public APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Versioning public RESTful APIs is the process of creating and maintaining multiple
    versions of an API to accommodate changes and new features. This ensures that
    existing clients are not affected by changes made to the API and that new clients
    can take advantage of the new features.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning is a critical aspect of API development and maintenance because it
    enables the evolution of an API over time while maintaining compatibility with
    existing clients. This is particularly important in cases where APIs are used
    by multiple clients, and breaking changes would impact the functionality of those
    clients. With versioning, multiple versions of an API can coexist, and clients
    can choose to upgrade to the latest version or continue using an earlier version
    that suits their needs. This way, versioning provides the necessary flexibility
    for APIs to evolve and improve over time without disrupting the stability of existing
    integrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several strategies to version RESTful APIs, each with its own advantages
    and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/v1/users` or `/v2/users`. This approach is easy to implement and understand,
    but it can be difficult to maintain and scale as the number of versions increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-API-Version`. This approach allows for more flexibility, as the URI does
    not have to change, but it can be more complex to implement and may not be supported
    by all clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/vnd.example.v1+json` or `application/vnd.example.v2+json`. This
    approach allows for more flexibility, as the URI and headers do not have to change,
    but it can be more complex to implement and may not be supported by all clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deprecation and sunsetting**: This strategy involves marking old versions
    of the API as deprecated and eventually sunsetting them. This approach allows
    for a gradual transition and gives clients time to update their code before the
    old version is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noting that the most appropriate versioning strategy will depend
    on the specific needs of an API and its clients. It’s important to communicate
    the versioning strategy and the timeline for the deprecation of old versions to
    the API’s clients in order to minimize disruption and allow them to plan accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to version an API is to include the version number in the
    URL of the API endpoint. For example, the URL of an API endpoint might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method allows different versions of an API to coexist and makes it easy
    to manage changes to the API over time by simply changing the version number in
    the URL. This also allows clients to choose which version of the API they want
    to use in their applications, and it helps prevent breaking changes in the API
    from affecting existing client applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a second version of the preceding example was created, it could be found
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A huge benefit of this is that both versions can exist at the same time and
    users who have clients that still expect the `v1` version can continue to work
    seamlessly. Of course, supporting multiple versions can be hard, and ideally,
    this would be a transient state with the intention to deprecate the `v1` version
    at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Example code showing how to version an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we built a controller to manage the users and added
    a number of endpoints to it. We have not yet added any versioning to the API,
    though; note that the URLs that we have tested with (using Thunder Client) do
    not have a version associated with them, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let’s change that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening a console and adding the versioning package to the `HabitService`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `using` statement into `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the following into `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The first flag sets the default API version. This allows a client to work with
    the API without specifying a version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second flag instructs the application to use the default if nothing is specified.
    This is an example of defensive programming – your users will thank you for this!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third flag is returns options – this returns the available versions in the
    response header so that a calling client can see that there are options available
    for that method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `ApiVersionReader` makes it possible for clients to choose whether
    to put the version in the URL or the request header. Again, it’s good to give
    consumers of the API the choice in this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we need to update `HabitsController` to work with multiple versions.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this point, we’ll just use a simple `GET` endpoint. But you can
    apply the same logic to any of the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the attributes of the `HabitsController` class to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s prove what we have done by adding an endpoint to the controller and mapping
    it to `version 1.0`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have flagged this method as virtual so that we can override it in a subsequent
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `HabitsControllerv2.cs` and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that this maps the `version` endpoint to the `v2` API. You can test this
    in Thunder Client in the usual way, and you will see that changing the version
    you provide in the URL changes which response you get.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we have specified the `Route` attribute twice – once with the
    version included and once without. This allows the default versioning that we
    specified in `Program.cs` to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Thunder Client, run three tests – one test without a version, one with `v1`,
    and one with `v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No version: http://localhost:5100/api/Habits/version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version 1: `http://localhost:5100/api/v1/Habits/version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version 2: `http://localhost:5100/api/v2/Habits/version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see that the first one returns `v1`, as that is the default, and you
    will see that the other two perform as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: You should also note that the requests that we previously set up in Thunder
    Client continue to operate as expected. This is great from the point of view of
    a consumer of the API. We have just introduced versioning and added `v2` without
    breaking any existing functionality!
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have demonstrated quite extensively how to test your API
    using Thunder Client. Testing APIs (and testing in general) is a huge subject
    that could be the subject of a book on its own. If you are interested, I have
    provided some pointers for further reading in the following section!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides some examples of the type of testing that you may
    want to carry out to ensure that your API is functioning correctly. Unit testing
    involves testing individual components of an API to ensure that they are working
    as expected. This is typically done using a unit testing framework, such as NUnit,
    and can be automated:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing involves testing an API end to end to ensure that all the
    components are working together correctly. This can be done manually or by using
    an automated testing tool, such as Selenium or TestComplete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing involves testing an API in conjunction with other systems,
    such as a database or other API. This can be done using an integration testing
    framework, such as Cucumber or FitNesse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing involves testing an API to ensure that it can handle the
    expected load and is performing optimally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security testing involves testing an API to ensure that it is secure and not
    vulnerable to common security threats, such as SQL injection or cross-site scripting.
    This can be done using a security testing tool, such as Nessus or OWASP ZAP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability testing involves testing an API to ensure that it is easy to use and
    understand. This can be done manually or by using a usability testing tool, such
    as UserTesting or Crazy Egg.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman is a popular tool for testing RESTful APIs. It allows developers to
    easily create, send, and analyze HTTP requests. It has a user-friendly interface
    and supports various features, such as request and response validation, environment
    variables, and automated testing. It also allows us to test end-to-end scenarios,
    and it can be integrated with other tools such as Jenkins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s worth noting that testing RESTful APIs is an ongoing process that should
    be done throughout the development process, not just at the end. This will help
    to ensure that an API works as expected and any issues are identified and resolved
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have demonstrated testing an API using Thunder Client inside
    VS Code. This is a very useful tool, with the benefit that the tests that are
    defined are saved in the repo and are checked against the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a *lot* in this chapter! I hope it has not been overwhelming!
    We started at the start with a definition of REST. Then, we covered HTTP status
    codes and HTTP verbs to give some background on some of the underlying fundamentals
    of REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at an example, covered the five most important HTTP verbs (`GET`,
    `POST`, `DELETE`, `PUT`, and `PATCH`), and showed how we could build them and
    test them with Thunder Client right within VS Code!
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at `AutoMapper` and how to simplify object conversions to create
    DTOs from entity types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked through an example of how to version an API and looked at
    some additional testing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will consider microservices, and we’ll look at how we
    can break up this application into a number of smaller microservices!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP response status codes: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using HTTP Methods for RESTful Services: [https://www.restapitutorial.com/lessons/httpmethods.html](https://www.restapitutorial.com/lessons/httpmethods.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HATEOAS and Why It’s Needed in RESTful API? [https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/](https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing an API: [https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/](https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use API versioning in ASP.NET Core Web API and integrate it with Swagger
    using .NET 6: [https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/](https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the advantages of using `PATCH` over `PUT`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using AutoMapper?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What HTTP code should be used when a new resource has been created?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `500` range of HTTP codes signify?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does REST stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of DTOs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
