- en: Performing I/O Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行I/O操作
- en: In any programming language, all applications are dependent upon some sort of
    data. These applications interact with one another, passing data present in different
    sources such as file objects and external web services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，所有应用程序都依赖于某种类型的数据。这些应用程序相互交互，传递存在于不同来源中的数据，如文件对象和外部Web服务。
- en: In this chapter, we will look at the different functionalities provided in C#
    to access and utilize data in file objects and external web services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨C#提供的不同功能，以访问和利用文件对象和外部Web服务中的数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performing I/O operations on file objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件对象上执行I/O操作
- en: Different helper classes available in the `System.Net` namespace that help us
    with I/O operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net`命名空间中可用的不同辅助类，帮助我们进行I/O操作'
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like in the previous chapters covered in this book, the programs explained in
    this chapter will be developed in Visual Studio 2017.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书前面章节中介绍的内容类似，本章中解释的程序将在Visual Studio 2017中开发。
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14)。
- en: File I/O operations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O操作
- en: '**File** is a very crude term representing a collection of data stored on a
    disk at a particular directory path. While writing C# applications, there are
    several occasions when we will need to use file objects:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**是一个非常粗略的术语，表示存储在特定目录路径上的数据集合。在编写C#应用程序时，我们会在几个场合需要使用文件对象：'
- en: To store data in an application or pass it across to another application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据存储在应用程序中或将其传递给另一个应用程序
- en: To access configuration settings that are necessary for application execution
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问应用程序执行所需的配置设置
- en: To access files that are present in a directory path
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问目录路径中存在的文件
- en: These operations are called I/O operations. C# provides a namespace, `System.IO`,
    that has some helper classes. These helper classes help us execute I/O operations
    on file objects. In this section, we will look at those helper classes in C#.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作被称为I/O操作。C#提供了一个名为`System.IO`的命名空间，其中包含一些辅助类。这些辅助类帮助我们执行文件对象上的I/O操作。在本节中，我们将探讨C#中的这些辅助类。
- en: Working with System.IO helper classes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用System.IO辅助类
- en: 'The `System.IO` namespace contains a collection of classes that allow us to
    do file manipulation in C#. It includes classes that allow us to do operations
    such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.IO`命名空间包含一系列类，允许我们在C#中进行文件操作。它包括允许我们执行以下操作的类：'
- en: Read data from a file
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: Write data to a file
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入文件
- en: Create/delete new files
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/删除新文件
- en: At different points during this chapter, through code examples, we will look
    at all of these I/O operations that we can perform on a file. However, before
    we start looking at those examples, we need to understand a very important concept,
    *Stream*, on which I/O operations are based.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的不同部分，通过代码示例，我们将查看我们可以在文件上执行的所有这些I/O操作。然而，在我们开始查看这些示例之前，我们需要理解一个非常重要的概念，即基于I/O操作的基础概念*流*。
- en: A stream signifies a sequence of bytes exchanged between applications during
    an I/O operation. In C#, it's represented by an abstract class called `System.IO.Stream`.
    It provides a wrapper class to transfer bytes, and all classes that need to read/write
    bytes from any source must inherit from this particular class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 流表示在I/O操作期间应用程序之间交换的字节序列。在C#中，它由一个名为`System.IO.Stream`的抽象类表示。它提供了一个包装类来传输字节，所有需要从任何来源读取/写入字节的类都必须从这个特定的类继承。
- en: Before we move on to learn more about streams and how we deal with it them in
    C#, let's first look at how we deal with drives, directories, and some other basic
    operations with files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习更多关于流以及如何在C#中处理它们之前，让我们首先看看我们如何处理驱动器、目录以及文件的一些其他基本操作。
- en: Drives and directories
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动器和目录
- en: 'A drive represents a storage medium for the filesystem. It can be a hard drive,
    a CD, or any other storage type. In .NET Framework, we have a `DriveInfo` class
    in the `System.IO` namespace, which helps us access the filesystem information
    that is available on the drive. It provides methods that can help us access information
    such as name, size, and the free space available on the drive. Please refer to
    the following code implementation, in which we are looping through all the files
    available on the drive:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器代表文件系统的存储介质。它可以是硬盘驱动器、CD或任何其他存储类型。在.NET Framework中，我们在`System.IO`命名空间中有一个`DriveInfo`类，它帮助我们访问驱动器上的文件系统信息。它提供了可以帮助我们访问诸如名称、大小和驱动器上的可用空间等信息的方法。请参考以下代码实现，其中我们正在遍历驱动器上可用的所有文件：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding piece of code, we are browsing through all the drives (that
    is, C, D, E, and so on) available on the filesystem and are publishing information
    related to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在遍历文件系统上所有可用的驱动器（即C、D、E等），并发布与以下相关的信息：
- en: The name of the drive
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动器的名称
- en: The type of drive, that is, fixed, RAM, CD ROM, removable, and so on
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动器的类型，即固定、RAM、CD ROM、可移动的等等
- en: The total available memory size on the drive
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动器上的总可用内存大小
- en: The total free memory available on the drive
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动器上可用的总空闲内存
- en: 'If we execute the code, the execution will loop through all the drives that
    are present in the filesystem. Once a drive is retrieved, the execution will retrieve
    certain properties about the drive, such as free space, total size, and drive
    type. Thus, when we execute the program, we will get the following output. Please
    note that we may not get all the information as it also depends upon the security
    permissions on the directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，执行将循环遍历文件系统中的所有驱动器。一旦检索到驱动器，执行将检索有关驱动器的某些属性，例如可用空间、总大小和驱动器类型。因此，当我们执行程序时，我们将得到以下输出。请注意，我们可能不会得到所有信息，因为这还取决于目录的安全权限：
- en: '![](img/afdd2c02-9e45-42c1-80be-08f0ee2b310d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afdd2c02-9e45-42c1-80be-08f0ee2b310d.png)'
- en: In the system in which we are executing this program, we just have a C drive.
    Thus, while the program is executing, we are showing the properties of the C drive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行此程序的系统中，我们只有一个C驱动器。因此，当程序执行时，我们正在显示C驱动器的属性。
- en: 'There are other properties on the `driveinfo` object as well. If we click on
    Go to Definition on the `DriveInfo` class, we can see the attributes of the class.
    Please visit the following link for more information: [https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`driveinfo`对象上还有其他属性。如果我们点击`DriveInfo`类的“转到定义”，我们可以看到类的属性。请访问以下链接获取更多信息：[https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2)。'
- en: 'Each drive in a filesystem comprises directories and files. A directory in
    itself can comprise multiple sub-directories and files. If we need to do an operation
    on a particular directory, we do it using the `DirectoryInfo` class in C#. In
    the following code snippet, we are creating an object of the `DirectoryInfo` class,
    passing the location of a particular directory path:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统中的每个驱动器都包含目录和文件。一个目录本身可以包含多个子目录和文件。如果我们需要对特定目录进行操作，我们使用C#中的`DirectoryInfo`类来完成。在下面的代码片段中，我们正在创建一个`DirectoryInfo`类的对象，传递特定目录路径的位置：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the `directoryInfo` object, we are then looping through all the child directories
    and are showing the information related to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`directoryInfo`对象，我们接下来将遍历所有子目录，并显示以下相关信息：
- en: Name of the directory
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录的名称
- en: Time the directory was created
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录创建的时间
- en: Time the directory was last modified
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录最后修改的时间
- en: 'When we execute the preceding program, we do so on the `C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples`
    file path. Please note that this is where we have been placing the codebase for
    the chapters we''ve got through in this book. Thus, when we execute this program,
    it will loop through the sub-folders of all those chapters and will fetch information
    such as `Directory Name`, `Directory created time`, and `Directory last modified
    time`. The following is the output that we will get for the program:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的程序时，我们是在 `C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples`
    文件路径上执行的。请注意，这是我们放置本书中所有章节代码库的地方。因此，当我们执行此程序时，它将遍历所有这些章节的子文件夹，并将获取诸如“目录名称”、“目录创建时间”和“目录最后修改时间”等信息。以下是我们将获得的程序输出：
- en: '![](img/f4612923-6053-45fa-bd9e-66bfc4286adb.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4612923-6053-45fa-bd9e-66bfc4286adb.png)'
- en: There are additional operations available with the `DirectoryInfo` object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DirectoryInfo` 对象还有其他可用操作。
- en: Checking whether the directory exists
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查目录是否存在
- en: 'Using a particular directory path, we can identify if any directory with that
    path exists in the filesystem or not. In the code implementation, we are creating
    a `DirectoryInfo` object and then using the `Exists` property to check whether
    the directory exists in the filesystem:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定的目录路径，我们可以确定在文件系统中是否存在具有该路径的目录。在代码实现中，我们创建一个 `DirectoryInfo` 对象，然后使用 `Exists`
    属性来检查目录是否存在于文件系统中：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we execute the code using the path mentioned during the creation of the
    `DirectoryInfo` object, the program execution will determine whether there is
    a directory in the filesystem in the specified path. Thus, when the program is
    executed, as we do not currently have a sub-folder called `Chapter 20` in the
    `Book70483Samples` base folder we will see Does not exists in the console output
    window. The following is globally the relevant output on the console window:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用在创建 `DirectoryInfo` 对象时提到的路径执行代码，程序执行将确定在指定路径的文件系统中是否存在目录。因此，当程序执行时，由于我们目前在
    `Book70483Samples` 基础文件夹中没有名为 `Chapter 20` 的子文件夹，我们将在控制台输出窗口中看到“不存在”。以下是在控制台窗口中的全局相关输出：
- en: '![](img/bbe540ac-7c34-4fd9-ac85-449f85e1c677.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbe540ac-7c34-4fd9-ac85-449f85e1c677.png)'
- en: In the next section, we will look at how to create a directory in a filesystem
    using C#.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 C# 在文件系统中创建目录。
- en: Creating a directory
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录
- en: 'Using the `DirectoryInfo` class, we can also create new directories in the
    filesystem. The following code illustrates how we create a new directory in the
    system:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DirectoryInfo` 类，我们还可以在文件系统中创建新目录。以下代码演示了如何创建系统中的新目录：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the preceding code is executed, it will create a subdirectory called `Chapter
    20` in the root folder.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行前面的代码，它将在根文件夹中创建一个名为 `Chapter 20` 的子目录。
- en: 'In the preceding code, we are passing an absolute path to create the directory.
    However, if we need to create a subdirectory in a particular directory, we can
    just execute the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们传递了一个绝对路径来创建目录。然而，如果我们需要在特定目录中创建子目录，我们只需执行以下代码：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, `parentDirectory` is the parent directory in which we
    want to create the subdirectory. `NameChildDirectory` is the name that we want
    to give to the child directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`parentDirectory` 是我们想要在其中创建子目录的父目录。`NameChildDirectory` 是我们想要给子目录取的名字。
- en: Looping through the files
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历文件
- en: 'Using the `DirectoryInfo` class, we can also loop through the files present
    in the directory. The following code shows how we can loop through the files and
    access their properties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DirectoryInfo` 类，我们还可以遍历目录中的文件。以下代码展示了我们如何遍历文件并访问它们的属性：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code snippet, we are looping through the files present in
    the `Chapter 20` directory and showing the information present in it. In the `Chapter
    20` folder, we have only one file: `dynamics365eula.txt`. Thus, when the program
    is executed, it will pick up the file and will read the file information present
    in it. To illustrate this, we are displaying the filename, the time the file was
    created, and the time the file was last accessed. So when the code is executed,
    we will get the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在遍历 `Chapter 20` 目录中的文件，并显示其中的信息。在 `Chapter 20` 文件夹中，我们只有一个文件：`dynamics365eula.txt`。因此，当程序执行时，它将选择该文件并读取其中的文件信息。为了说明这一点，我们显示了文件名、文件的创建时间和最后访问时间。因此，当代码执行时，我们将获得以下输出：
- en: '![](img/d9d8c047-0d90-4dd4-bfe0-928a8cdce0ce.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9d8c047-0d90-4dd4-bfe0-928a8cdce0ce.png)'
- en: Now that we have some knowledge about drives and `DirectoryInfo`, we will explore
    some helper classes that allow us to do operations on files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对驱动器和 `DirectoryInfo` 有了一些了解，我们将探索一些辅助类，这些类允许我们对文件进行操作。
- en: Working with files
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: In this section, we will go through the helper classes that allow us to do operations
    on the files present in a directory. C# provides the `File` and `FileInfo` helper
    classes to do operations on files. While going through the following code snippets,
    we will be looking at some of the typical operations that we can do with file
    objects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍允许我们对目录中存在的文件进行操作的辅助类。C# 提供了 `File` 和 `FileInfo` 辅助类来对文件进行操作。在查看以下代码片段时，我们将查看一些我们可以使用文件对象执行的典型操作。
- en: Checking whether a file exists
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件是否存在
- en: 'This basically involves checking whether a file with the given path exists
    or not. This can help us write fail-safe code in such a way that we read a file
    only after establishing that it exists in the given path:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涉及检查给定路径是否存在文件。这可以帮助我们编写容错代码，以便仅在确认文件存在于给定路径后读取文件：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`File` is a static class available in the `System.IO` namespace. This class
    provides operations that we can use to execute functionalities related to file
    access. In the preceding code, we have declared a file path and, using the static
    `File` class, we are checking whether the file indeed exists in the given path.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 是在 `System.IO` 命名空间中可用的静态类。此类提供了我们可以用来执行与文件访问相关的功能的操作。在前面的代码中，我们已声明了一个文件路径，并使用静态的
    `File` 类检查文件是否确实存在于给定的路径中。'
- en: Moving a file from one location to another
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件从一个位置移动到另一个位置
- en: 'In this operation, we basically cut the file from one location and paste it
    into another. The following code snippet shows how this can be done:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们基本上是将文件从一个位置剪切到另一个位置。以下代码片段显示了如何执行此操作：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, we are first checking whether the file exists
    in a particular location. If the file is present in the location, we are copying
    it into another location.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先检查文件是否存在于特定位置。如果文件存在于该位置，我们将将其复制到另一个位置。
- en: Once the code is executed, we will notice that the file is cut from the source
    location and is pasted in to the target location.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，我们会注意到文件是从源位置剪切到目标位置的。
- en: Copying a file from one location to another
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个位置复制文件到另一个位置
- en: 'In this operation, we basically copy the file from one location and paste it
    into another. Please note the `Move` operation will delete the file present in
    the source folder. However, the `Copy` operation will copy the file present in
    the source folder to the destination folder. The following code snippet shows
    how this can be done:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们基本上是将文件从一个位置复制到另一个位置。请注意，`Move` 操作将删除源文件夹中存在的文件。然而，`Copy` 操作将把源文件夹中存在的文件复制到目标文件夹。以下代码片段显示了如何执行此操作：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the code is executed, we will see that the file is copied from the source
    file location and pasted in to the target file location path.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，我们会看到文件是从源文件位置复制到目标文件位置路径的。
- en: Deleting a file
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'In this operation, we delete a file present in the specified location:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们将删除指定位置存在的文件：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the code is executed, we will see that the file is deleted from the source
    file location. Once the code is executed, we will see that the file specified
    in the `sourceFileLocation` path has been deleted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，我们会看到文件已从源文件位置删除。一旦代码执行，我们会看到在 `sourceFileLocation` 路径中指定的文件已被删除。
- en: Please note that operations that work with the `File` class work the same way
    with the `FileInfo` class. The same implementations that we have done with the
    `File` class can be done via the `FileInfo` class as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与 `File` 类一起工作的操作与 `FileInfo` 类以相同的方式工作。我们可以通过 `FileInfo` 类执行与 `File` 类相同的实现。
- en: 'In all the preceding examples, we have been hard-coding the path property of
    the file. This is not a recommended practice as it is error-prone. For example,
    if you look at the actual path of any file and compare it to what we need to supply
    in the program, you will notice a difference:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的示例中，我们一直在硬编码文件的路径属性。这不是一种推荐的做法，因为它容易出错。例如，如果你查看任何文件的实际路径并将其与我们需要在程序中提供的路径进行比较，你会注意到一个差异：
- en: 'Actual path: `C:\File Location\Chapter 20\Sample.txt`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际路径：`C:\File Location\Chapter 20\Sample.txt`
- en: 'Path which we need to specify in the program: `C:\\File Location\\Chapter 20\\Sample.txt`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to provide some extra slashes in the path. Also, when we are combining
    the folder path with the file path, we need to concatenate them with an extra
    `\` as well. For these reasons, hardcoding the path is not a recommended practice.
    A better approach is to use the `Path` helper class. The following code shows
    how to use it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code implementation, we have declared a folder path. Please
    also note the use of `&` before the filename. This is an escape character that
    allows us to not specify an extra `\` in the folder path structure. We have also
    declared a filename and are now combining the two together using the helper static
    class: `Path`. Once we have combined them, we retrieve the properties in the resulting
    file path. If the code is executed, we get the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c6a1269-e54e-48ec-a187-e1c11e4fab4f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Let''s examine the output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`Path.GetDirectoryName`: This returns the directory name of the combined path
    file. Note that it has the complete absolute directory path.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path.GetExtension`: This returns the file extension of the combined path file.
    In this case, it''s a `.txt` file.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path.GetFileName`: This returns the name of the file.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path.GetPathRoot`: This returns the root of the filepath. In this case, it''s
    `C:`, hence it''s mentioned in the output.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are aware of basic operations on files, we will look at how to access
    and modify the contents of a file. For this, we will look at the operations available
    in `FileStream`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Stream object
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main operations with files are related to reading, writing, retrieving,
    and updating text present in file. In .NET, these operations are performed using
    an exchange of bytes in I/O operations. This sequence of bytes is a stream, and
    in .NET, it's represented using the abstract `Stream` class. This class forms
    the basis of all I/O operations in .NET such as `FileStream` and `MemoryStream`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'With stream we can perform the following operations in .NET:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Reading data in the stream object
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data into the stream object
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for or finding relevant information from the stream object
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the different operations that are implemented using stream
    objects. In the next section, we will go through the `FileStream` object, which
    aids operations on the file object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: FileStream
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `FileStream` object, we can read and write information back to the
    file in the directory. It's done using the `File` and `FileInfo` object we discussed
    in the previous section in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets go through the following code example, in which we are writing information
    to a file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code implementation, we are doing the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Opening the `Sample.txt` file that's present in the specified location
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `File` object from it and then converting the data present in the
    file to a `FileStream` object
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to the file using the `Write` operation available in the `FileStream`
    object
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FileStream` 对象中可用的 `Write` 操作将数据写入文件
- en: Please note that we are using the `using` block for the `FileStream` object.
    Due to this, the `Dispose` method will be automatically called for the `FileStream`
    object. Therefore, the memory from unmanaged resources will be reclaimed automatically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用 `using` 块来处理 `FileStream` 对象。因此，`Dispose` 方法将自动为 `FileStream` 对象调用。因此，非托管资源中的内存将自动回收。
- en: Please note that in the preceding implementation, we are encoding the string
    value before we are writing that data to the `FileStream` object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的实现中，我们在将数据写入 `FileStream` 对象之前对字符串值进行了编码。
- en: 'Another way of handling the same functionality is to use the `StreamWriter`
    helper class. The following code implementation shows how it can be handled using
    the `StreamWriter` helper class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理相同功能的另一种方法是使用 `StreamWriter` 辅助类。以下代码实现展示了如何使用 `StreamWriter` 辅助类来处理：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While choosing between the two helper classes, we need to consider the data
    we are dealing with. A `FileStream` object deals with an array of bytes. However,
    the `StreamWriter` class implements `TextWriter`. It only deals with string data
    and automatically encodes it into bytes so that we don't have to explicitly do
    it. However, in cases when we use the `FileStream` class, we must encode and decode
    the bytes to data into the string representation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择两个辅助类之间，我们需要考虑我们正在处理的数据。`FileStream` 对象处理字节数组。然而，`StreamWriter` 类实现了 `TextWriter`
    接口。它只处理字符串数据，并自动将其编码为字节，这样我们就不必显式地执行此操作。然而，在当我们使用 `FileStream` 类时，我们必须对字节进行编码和解码，以将数据转换为字符串表示形式。
- en: In the next section, we will look at some best practices relating to exception
    handling while dealing with file I/O operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些与文件 I/O 操作相关的最佳实践。
- en: Exception handling
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: In any real-world scenario, multiple people might be working with the same file
    concurrently. Using threading in C#, we can lock objects while a particular operation
    is happening on a resource. However, such locking is not available on files present
    in the filesystem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何实际场景中，可能有多个人同时处理同一个文件。在 C# 中使用线程，我们可以在对资源执行特定操作时锁定对象。然而，在文件系统中，文件上的锁定不可用。
- en: 'So, it''s quite possible that files that are being accessed in the program
    have been moved or even deleted altogether by a different application or user.
    C# provides some exceptions with which we can handle such scenarios in a better
    way. Please refer to the following code implementation, where we are handling
    an exception:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完全有可能程序正在访问的文件已经被另一个应用程序或用户移动或完全删除。C# 提供了一些异常处理机制，我们可以用它们更好地处理这类情况。请参考以下代码实现，其中我们处理了一个异常：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From a functionality perspective, in the preceding code we are reading file
    present in the given location. We are retrieving all the text present in the file
    and then passing it back to the calling function. Please also note the following
    best practices that we are using in the code implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '从功能角度来看，在前面的代码中，我们正在读取给定位置中的文件。我们检索文件中的所有文本，并将其传递回调用函数。请注意，在代码实现中我们还使用了以下最佳实践： '
- en: In the code, we are first checking whether the file exists in the directory
    location using the `Exists` method. If the file exists, we proceed to extract
    data from the file.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中，我们首先使用 `Exists` 方法检查文件是否存在于目录位置。如果文件存在，我们继续从文件中提取数据。
- en: Even though we have checked that the file exists before we proceed, there are
    still some circumstances in which the file is removed, deleted, or becomes inaccessible
    after the code moves to the next block. To handle such scenarios, we are catching
    the `DirectoryNotFoundException` and `FileNotFoundException` exceptions. `DirectoryNotFoundException`
    is thrown when the directory specified in the path no longer exists. `FileNotFoundException`
    is thrown when the file specified in the path no longer exists.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们在继续之前已经检查了文件是否存在，但在代码移动到下一个块之后，仍然有一些情况下文件被移除、删除或变得不可访问。为了处理这些情况，我们捕获了 `DirectoryNotFoundException`
    和 `FileNotFoundException` 异常。当路径中指定的目录不再存在时，会抛出 `DirectoryNotFoundException`。当路径中指定的文件不再存在时，会抛出
    `FileNotFoundException`。
- en: Now that we have a fair understanding of how to execute I/O operations on a
    file, we will look at examples of calling external web services to get a response
    from them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何在文件上执行 I/O 操作有了相当的了解，我们将查看调用外部 Web 服务并从它们获取响应的示例。
- en: Reading data from a network
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络读取数据
- en: While developing applications in .NET Framework, we will encounter several scenarios
    where we need to call external APIs to get the required data. .NET Framework provides
    a `System.Net` namespace that provides a large number of helper classes that allow
    us to execute these operations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 .NET Framework 应用程序时，我们会遇到需要调用外部 API 获取所需数据的多种场景。.NET Framework 提供了一个 `System.Net`
    命名空间，它包含大量辅助类，使我们能够执行这些操作。
- en: In this section, we will go through an example in which we will use the `WebRequest`
    and `WebResponse` classes to call the external APIs and process their responses.
    We will be calling an external page, and we also process the response that we
    will get from the call. We will also be looking at code examples in which we will
    learn how to make asynchronous calls to an external web server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个示例来了解如何使用 `WebRequest` 和 `WebResponse` 类调用外部 API 并处理它们的响应。我们将调用一个外部页面，并处理我们从调用中获得的响应。我们还将查看代码示例，了解如何对外部
    Web 服务器进行异步调用。
- en: WebRequest and WebResponse
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebRequest 和 WebResponse
- en: '`WebRequest` is an abstract base class provided by .NET Framework for accessing
    data from the internet. Using this class, we send a request to a particular URL,
    such as `www.google.com`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebRequest` 是由 .NET Framework 提供的一个抽象基类，用于从互联网访问数据。使用这个类，我们可以向特定的 URL 发送请求，例如
    `www.google.com`。'
- en: On the other hand, `WebResponse` is an abstract class that provides a response
    from the URL called by the `WebRequest` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`WebResponse` 是一个抽象类，它提供了 `WebRequest` 类调用的 URL 的响应。
- en: 'The `WebRequest` object is created by calling the static `Create` method. In
    the method, we pass the address URL that we want to call in the request. The request
    inspects the address we are passing to it and selects a protocol implementation,
    for example, HTTP or FTP. Based upon the web address passed, an appropriate instance
    of the derived class, such as `HttpWebRequest` for HTTP or `FtpWebRequest` for
    FTP, is returned when the `WebRequest` object is created. The `WebRequest` class
    also allows us to specify some other properties, such as the authentication and
    content type. Let''s go through the following code implementation, which will
    help us learn more about this class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebRequest` 对象是通过调用静态的 `Create` 方法创建的。在方法中，我们传递要请求的地址 URL。请求检查我们传递给它的地址，并选择一个协议实现，例如
    HTTP 或 FTP。根据传递的 Web 地址，当创建 `WebRequest` 对象时，返回适当的派生类实例，例如 `HttpWebRequest` 用于
    HTTP 或 `FtpWebRequest` 用于 FTP。`WebRequest` 类还允许我们指定一些其他属性，例如身份验证和内容类型。让我们通过以下代码实现来了解这个类：'
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code implementation, we are creating a `WebRequest` object
    for `http://google.com`. We are using a `GET` method in the `HTTP` request and
    passing parameters embedded in the URL itself. As the protocol is `HTTP`, we are
    converting the `WebResponse` object to `httpWebResponse`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们为 `http://google.com` 创建了一个 `WebRequest` 对象。我们在 `HTTP` 请求中使用 `GET`
    方法，并通过 URL 本身嵌入的参数传递。由于协议是 `HTTP`，我们将 `WebResponse` 对象转换为 `httpWebResponse`。
- en: Once we have captured the response, we are retrieving the stream of bytes into
    a `Stream` object and are then using a `StreamReader` object to retrieve the response
    from `google.com`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们捕获了响应，我们将从 `google.com` 获取的字节流检索到 `Stream` 对象中，然后使用 `StreamReader` 对象从 `google.com`
    获取响应。
- en: 'A very important thing to note here is that in the `finally` block, we are
    closing all the response, stream, and reader objects that have been created in
    the `try`...`catch` block. This is essential: as we are dealing with unmanaged
    resources, it''s important to reclaim the memory for better performance.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个非常重要的事情是，在 `finally` 块中，我们正在关闭在 `try`...`catch` 块中创建的所有响应、流和读取器对象。这是至关重要的：因为我们正在处理非托管资源，为了更好的性能，回收内存是很重要的。
- en: 'For further reading, please refer to the following blog from Microsoft, which
    discusses the different parameters that we can set in the `WebRequest` object
    when we are making a call: [https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阅读，请参考以下来自微软的博客，其中讨论了我们在调用 `WebRequest` 对象时可以设置的不同参数：[https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2)。
- en: In the preceding code, we were making synchronous calls to the external web
    service and waiting for a response. However, in a real-world scenario, this may
    not be the ideal implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们正在对外部 Web 服务进行同步调用并等待响应。然而，在实际场景中，这可能不是理想的实现。
- en: The external server to which we are making a call may take some time to send
    us the response. Therefore, if our application continues to wait for a response
    during this time, the responsiveness of the application will be challenged. To
    avoid such scenarios, we can make I/O calls asynchronous. In the next section,
    we will learn why we need to look at making asynchronous I/O calls and how they're
    implemented in code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用的外部服务器可能需要一些时间来发送响应。因此，如果我们的应用程序在等待响应期间继续等待，那么应用程序的响应性将受到挑战。为了避免此类场景，我们可以使
    I/O 调用异步。在下一节中，我们将学习为什么我们需要考虑进行异步 I/O 调用以及它们如何在代码中实现。
- en: Asynchronous I/O operations
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步 I/O 操作
- en: When we were going through the `WebRequest` and `WebResponse` section, we wrote
    a program in which we made a call to `google.com`. In very crude terms, when the
    request is made, it's picked up by the Google server, which then assigns a thread
    to cater to this request. The thread then sends the response to the calling machine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们正在学习 `WebRequest` 和 `WebResponse` 部分时，我们编写了一个程序，在其中我们调用了 `google.com`。用非常粗略的话来说，当请求被发送时，它会被
    Google 服务器接收，然后分配一个线程来处理这个请求。该线程然后将响应发送给调用机器。
- en: Theoretically, however, there is always a possibility that fewer free threads
    are available on the server. Also, there is the possibility that the server may
    take a long time to complete the request and send the response to the caller.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，然而，总是存在服务器上可用的空闲线程较少的可能性。此外，还有可能服务器可能需要很长时间来完成请求并发送响应给调用者。
- en: The challenge here is that we must design communication between the caller and
    the server is such a way that the performance and responsiveness of the application
    are not compromised. We do that by making the calls asynchronous.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战是我们必须设计调用者和服务器之间的通信方式，以确保应用程序的性能和响应性不受影响。我们通过使调用异步来实现这一点。
- en: If we make these operations asynchronous, we can rest assured that, while the
    server is processing the request and sending us the response, our application
    remains responsive and users can continue using the application. We do this using
    the `async`/`await` keywords.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使这些操作异步，我们可以确信，当服务器正在处理请求并发送响应时，我们的应用程序保持响应，用户可以继续使用应用程序。我们通过使用 `async`/`await`
    关键字来实现这一点。
- en: 'Any method that is written asynchronously in C# must have the following characteristics:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用 C# 编写的异步方法都必须具有以下特征：
- en: The method definition must have the `async` keyword to indicate that the method
    is executed asynchronously.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法定义必须包含 `async` 关键字，以指示该方法以异步方式执行。
- en: 'The method must have one of the following return types:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法必须具有以下返回类型之一：
- en: '`Task`: If the function has no return statements'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`：如果函数没有返回语句'
- en: '`Task<TResult>`: If the function has a return statement in which the object
    being returned is of type `TResult`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<TResult>`：如果函数有一个返回语句，返回的对象是类型 `TResult`'
- en: '`Void`: If the function is an event handler'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Void`：如果函数是一个事件处理器'
- en: In the function, we execute an asynchronous call to an external web server.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中，我们执行对外部 Web 服务器的异步调用。
- en: The function may have an `await` statement. The `await` statement basically
    tells the compiler that the application must wait at that statement for the asynchronous
    process executed by the external web server to finish.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可能包含一个 `await` 语句。`await` 语句基本上告诉编译器，应用程序必须等待该语句，直到外部 Web 服务器执行异步过程完成。
- en: 'Let''s go through all these points in the following code implementation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码实现来逐一分析这些点：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Please refer to the following in the preceding code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下前述代码：
- en: We have defined a function called `ExecuteOperationAsync`. To indicate the asynchronous
    behavior of the function, we have used the `async` keyword in the function definition.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`ExecuteOperationAsync`的函数。为了表明函数的异步行为，我们在函数定义中使用了`async`关键字。
- en: We have declared the return type of the function as `Task<int>`, which indicates
    that the function will return an object of type `int`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将函数的返回类型声明为`Task<int>`，这表示函数将返回一个类型为`int`的对象。
- en: We have declared an object of the `HttpClient` helper class and are making a
    call to `http://google.com`. We are making the request call asynchronously.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明了一个`HttpClient`辅助类的对象，并对其进行了`http://google.com`的调用。我们正在异步地发出请求调用。
- en: To ensure that the application carries on doing other work, we are calling the
    `ExecuteParallelWork` function so that, until the response arrives, the application
    does not stop processing.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保应用程序继续执行其他工作，我们调用了`ExecuteParallelWork`函数，这样，直到响应到达，应用程序不会停止处理。
- en: We have used an `await` statement so that the compiler stops at that point and
    waits for the response for a asynchronous request call. Once the response is received,
    it checks the length of the response string and returns the result to the calling
    function.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用了一个`await`语句，这样编译器会在那个点停止并等待异步请求调用的响应。一旦收到响应，它会检查响应字符串的长度并将结果返回给调用函数。
- en: Now that we have a fair understanding of how asynchronous calls work in I/O
    operations, we will look at how to use them in I/O operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对I/O操作中异步调用的工作原理有了相当的了解，我们将探讨如何在I/O操作中使用它们。
- en: In the next section, we will look at how different I/O operations can be made
    asynchronous using this keyword.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用这个关键字使不同的I/O操作异步化。
- en: Async operations on file
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件上的异步操作
- en: In this section, we will learn how to perform I/O operations on a file asynchronously.
    This can be helpful in scenarios when the data that we are writing to the file
    is large.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何异步地对文件执行I/O操作。当我们要写入文件的数据量很大时，这可能会很有帮助。
- en: 'The following code implementation shows how to write data to a file asynchronously.
    Please note that we must use the `FileStream` object to execute file I/O operations
    asynchronously:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现展示了如何异步地将数据写入文件。请注意，我们必须使用`FileStream`对象来执行异步文件I/O操作：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code implementation, we are creating a new file in a given
    directory location. The calling function does not require a value to be returned,
    so we have just set the return type as `Task`. To create the file and write data
    to it, we have used a `FileStream` object. For a detailed analysis of the properties
    passed in the constructor of the class, please refer to the following link: [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们正在创建一个给定目录位置的新文件。调用函数不需要返回值，因此我们已将返回类型设置为`Task`。为了创建文件并向其写入数据，我们使用了`FileStream`对象。有关类构造函数中传入的属性详细分析的更多信息，请参阅以下链接：[https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2)。
- en: After creating the object, we are generating a random sequence of bytes and
    are then writing it asynchronously to the `FileStream` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象后，我们生成一个随机字节序列，然后将其异步写入`FileStream`对象。
- en: For a code implementation related to calling web requests asynchronously, we
    can refer to the implementation in the previous example where we created an object
    called `HttpClient` and made a call asynchronously.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与异步调用Web请求相关的代码实现，我们可以参考上一个示例中的实现，其中我们创建了一个名为`HttpClient`的对象并进行了异步调用。
- en: In the next section, we will learn how to execute multiple I/O operations asynchronously
    and in a parallel manner.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何异步且并行地执行多个I/O操作。
- en: This is quite useful in scenarios where the application must wait for the completion
    of different functions that are executing in parallel.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序必须等待并行执行的不同函数完成的情况下，这非常有用。
- en: Using the await statement for parallel asynchronous calls
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`await`语句进行并行异步调用
- en: 'While writing programs, we often come across situations in which we must wait
    for results from different asynchronous calls. This is required when the processing
    is dependent upon multiple responses from an external medium, such as web services.
    Let''s look at the following code example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，我们经常遇到必须等待来自不同异步调用结果的情况。当处理依赖于来自外部介质（如 Web 服务）的多个响应时，这是必需的。让我们看看以下代码示例：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are executing asynchronous calls to different servers.
    Suppose we have to wait for the output from all of them before we can proceed;
    we can use the `WhenAll` statement. The `WhenAll` statement will ensure that the
    execution waits for responses from all three asynchronous calls before the processing
    can move ahead.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在执行对不同服务器的异步调用。假设我们必须等待所有这些的输出，我们才能继续；我们可以使用 `WhenAll` 语句。`WhenAll`
    语句将确保在处理可以继续之前，执行将等待来自所有三个异步调用的响应。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to execute I/O operations related to files and
    networks in C#. We went over namespaces that provide helper classes for executing
    I/O operations. We started with the basic operations that we can perform on drives
    and directories. We looked at code that we can use to loop through files in directories.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 C# 中执行与文件和网络相关的 I/O 操作。我们回顾了提供执行 I/O 操作辅助类的命名空间。我们从可以在驱动器和目录上执行的基本操作开始。我们查看了一些代码示例，这些代码示例可以用来遍历目录中的文件。
- en: Then we looked at the helper classes that help us with I/O operations on files.
    We looked at the `File` and `FileInfo` classes, which help us create, copy, move,
    and delete files. We looked at best practices for dealing with directory and file
    paths. We then looked at s*treams*, or sequences of bytes, which allow us to edit
    information present in files. We then looked at best practices for exception handling
    in files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们查看了一些辅助类，这些类帮助我们进行文件 I/O 操作。我们查看了一些 `File` 和 `FileInfo` 类，这些类帮助我们创建、复制、移动和删除文件。我们查看了一些处理目录和文件路径的最佳实践。然后我们查看了一些
    *stream*，即字节序列，它允许我们编辑文件中存在的信息。然后我们查看了一些文件异常处理的最佳实践。
- en: After that, we looked at helper classes for dealing with I/O operations over
    networks. We looked at a code example in which we made HTTP calls over the internet.
    We then looked at a code implementation in which we made asynchronous I/O calls.
    Whenever possible, it's always beneficial to use asynchronous operations because
    it's better for the overall performance of the application. We went over code
    examples for executing asynchronous operations on both I/O and over the internet.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们查看了一些处理网络 I/O 操作的辅助类。我们查看了一个代码示例，其中我们在互联网上进行了 HTTP 调用。然后我们查看了一个代码实现示例，其中我们进行了异步
    I/O 调用。在可能的情况下，始终使用异步操作是有益的，因为它对应用程序的整体性能更有利。我们回顾了在 I/O 和互联网上执行异步操作的代码示例。
- en: In the next chapter, we will look at how LINQ queries can we used in C# to work
    efficiently when we are querying different data sources, such as XML and SQL.
    Working with code examples, we will explore the different components of LINQ,
    along with the different operators that we can use while working with LINQ queries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在 C# 中使用 LINQ 查询来高效地查询不同的数据源，例如 XML 和 SQL。通过代码示例，我们将探索 LINQ 的不同组件，以及在使用
    LINQ 查询时可以使用的不同运算符。
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which syntax should we use to append text to a file?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用哪种语法来向文件追加文本？
- en: '`File.CreateText`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File.CreateText`'
- en: '`FileInfo.Create`'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileInfo.Create`'
- en: '`File.Create`'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File.Create`'
- en: '`File.AppendText`'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File.AppendText`'
- en: Which syntax should we use if the application needs to wait for asynchronous
    calls from multiple sources?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序需要等待来自多个来源的异步调用，我们应该使用哪种语法？
- en: '`async`'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async`'
- en: '`await`'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`await`'
- en: '`Task`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task`'
- en: '`Task.WhenAll`'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.WhenAll`'
- en: Which one of the following statements is incorrect?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个语句是不正确的？
- en: '`StreamWriter` only works with text; however, `FileStream` works with bytes.'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StreamWriter` 只与文本一起工作；然而，`FileStream` 与字节一起工作。'
- en: We can lock files in .NET.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 .NET 中锁定文件。
- en: 'If we have an asynchronous function, it can have one of three return types:
    `Task`, `Task<TResult>`, and `Void`.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个异步函数，它可以有三种返回类型：`Task`、`Task<TResult>` 和 `Void`。
- en: '`DirectoryNotFoundException` is thrown when the directory in the file path
    is no longer available.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件路径中的目录不再可用时，会抛出 `DirectoryNotFoundException`。
- en: Answers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**File.AppendText.**'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**File.AppendText.**'
- en: '**Task.WhenAll.**'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Task.WhenAll.**'
- en: '**Except "B" that is we can lock files, all other statements are true.**'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**除了“B”之外，即我们可以锁定文件，所有其他语句都是正确的。**'
