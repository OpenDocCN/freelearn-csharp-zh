- en: '*Chapter 13*: Working with the Blazor WebAssembly UI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor is a relatively new **Single-Page Application** (**SPA**) framework for
    building interactive web applications using C# instead of JavaScript. Blazor is
    one of the built-in UI options provided by ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will briefly discuss what Blazor is and the main pros and
    cons of using this new framework. I will then continue by explaining how you can
    create new ABP solutions using the Blazor UI option. At the end of the chapter,
    you will have understood the architecture and design of the ABP Blazor integration
    and learned about the essential ABP services that you will use in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with the ABP Blazor UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the theming system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the basic services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the UI services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming HTTP APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with global scripts and styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development. We will use the ABP CLI at some points,
    so you need to install the ABP CLI, as explained in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026),
    *Getting Started with ABP Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the example application from the following GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples given in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I indicated in the introduction, Blazor is an SPA framework used to build
    interactive web applications, just like other SPA frameworks such as Angular,
    React, and Vue.js. However, it has one important difference – we can use C# to
    build the application instead of JavaScript, which means we can run .NET in browsers.
    Blazor uses the .NET core runtime to execute the .NET code in the browser (for
    Blazor WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running .NET in browsers is not a new idea. Microsoft has done it before with
    Silverlight. To run Silverlight applications, we had to install a plugin on the
    browser. Blazor, on the other hand, runs natively on the browser, thanks to **WebAssembly**
    technology, which is defined as the following on [https://webassembly.org](https://webassembly.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
    virtual machine. Wasm is designed as a portable compilation target for programming
    languages, enabling deployment on the web for client and server applications."'
  prefs: []
  type: TYPE_NORMAL
- en: A higher-level language, such as C#, can be compiled into WebAssembly and run
    natively in the browser. WebAssembly is supported by all major web browsers, so
    we don't need to install any custom plugin. If you're wondering whether Blazor
    is the new Silverlight, I can simply say, no, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'As .NET developers, Blazor brings incredible opportunities to us:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use our existing C# skills to develop applications by harnessing the
    full power of the language and the runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use existing .NET libraries, such as our favorite NuGet packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can share code (such as DTO classes, application service contracts, localization,
    and validation code) between the server and the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the familiar Razor syntax to build UI pages and components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides using C#, Blazor provides JavaScript interoperability to call JavaScript
    code from C# and vice versa. That means that we can use existing JavaScript libraries
    and write our JavaScript code whenever we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Writing C# and sharing code between server and client applications is a huge
    advantage for a .NET developer. ABP also takes advantage of this and shares the
    infrastructure between the MVC/Razor Pages UI and Blazor UI as much as possible.
    You will see that many services are very similar to the MVC/Razor Pages UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a .NET developer and a software company manager, I am very impressed by
    Blazor and will use it in future projects. However, that doesn''t mean it has
    no drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The bundle size, initial load time, and runtime performance are worse than its
    JavaScript competitors, such as Angular and React. However, Microsoft is investing
    in Blazor and working hard to improve its performance. For example, **Ahead-of-Time**
    (**AOT**) compilation has been introduced with .NET 6.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI components and ecosystem are not mature yet since Blazor is still in
    the early stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging is not so straightforward yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these drawbacks are tolerable for your projects, you can definitely start
    using Blazor today.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, Blazor has two kinds of runtime models. Until now, I have mostly
    talked about **Blazor WebAssembly**. The second model is called **Blazor Server**.
    While the component development model is identical, the hosting logic and the
    runtime model are completely different.
  prefs: []
  type: TYPE_NORMAL
- en: With Blazor WebAssembly, .NET code runs in the browser on the Mono runtime,
    and we don't have to run .NET on the server side. A small initializer JavaScript
    code downloads the standard .NET **Dynamic Link Libraries** (**DLLs**) and runs
    them in the browser. This model is similar to, and a direct competitor of, Angular
    and React because it runs the client-side logic completely in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Blazor Server runs .NET code completely on the server. It
    establishes a real-time SignalR connection between the client and the server.
    The browser runs JavaScript and communicates to the server over that SignalR connection.
    It sends events to the server, and the server executes the necessary .NET code
    and sends **Document Object Model** (**DOM**) changes to the browser. Finally,
    the browser applies the DOM changes to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor Server model has a pretty faster initial load time compared to Blazor
    WebAssembly. However, it communicates to the server for all events and DOM changes,
    so we need a good and stable connection between the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: My purpose in this book is not to provide a complete introduction, overview,
    and use cases of Blazor but to give a short enough introduction to understanding
    what it is. Also, this chapter will focus on Blazor WebAssembly, but most of the
    topics are applicable to Blazor Server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start ABP's Blazor integration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the ABP Blazor UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to start a new project using ABP''s startup solution templates.
    You can either download it from [https://abp.io/get-started](https://abp.io/get-started)
    or create it using the ABP CLI. I will use the CLI approach in this book. If you
    haven''t installed it yet, open a command-line terminal and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new solution using the `abp new` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`DemoApp` is the solution name in this example. I''ve passed the `-u blazor`
    parameter to specify Blazor WebAssembly. If you want to use Blazor Server, you
    can specify the parameter as `-u blazor-server`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I haven''t specified a database provider, so it uses Entity Framework Core
    by default (specify the `-d mongodb` parameter if you want to use MongoDB). After
    creating the solution, we need to create the initial database migration. As a
    first step, we should execute the following command in the `src/DemoApp.DbMigrator`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the initial code-first migration and applies against the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution contains two applications:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the server (backend) application that hosts the HTTP APIs and
    provides the authentication UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second application is the frontend Blazor WebAssembly application that contains
    the application UI and communicates to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we first run the `DemoApp.HttpApi.Host` server application for this example.
    Then, we can run the `DemoApp.Blazor` Blazor application to run the UI. You can
    click on the `admin` as the username and `1q2w3E*` as the password to log in to
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: I won't dig into the details of the application, since we've done it already
    in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting Started with
    ABP Framework*. The next section explains how the user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenID Connect** (**OIDC**) is Microsoft''s suggested way to authenticate
    Blazor WebAssembly applications. ABP follows that suggestion and provides it as
    preconfigured in the startup solution.'
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor application doesn't contain login, register, or other authentication-related
    UI pages. It uses the **Authorization Code** flow with **Proof Key for Code Exchange**
    (**PKCE**) enabled to redirect the user to the server application. The server
    handles all the authentication logic and redirects the user back to the Blazor
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The authentication configuration is stored in the `wwwroot/appsettings.json`
    file of the Blazor application. See the following example configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Authority` is the backend server application's root URL. `ClientId` is
    the name of the Blazor application that is known by the server. Finally, `ResponseType`
    specifies the authorization code flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration is used in the module class, the `DemoAppBlazorModule` class
    for this example, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthServer` is the key that matches the configuration key. If you want to
    customize the authentication options, these are the points you need to start from.
    For example, you can revise the requested scopes or change the OIDC configuration.
    For more information about Blazor WebAssembly authentication, please refer to
    Microsoft''s documentation: [https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will introduce the theming system for the Blazor UI.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the theming system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ABP provides a theming system for the Blazor UI, as explained when we covered
    the MVC/Razor Pages UI in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*. The theme system brings flexibility, so we can
    develop our applications and modules without depending on a particular UI theme/style.
  prefs: []
  type: TYPE_NORMAL
- en: All of the ABP themes for the Blazor UI use a set of base libraries. The fundamental
    base library is Bootstrap, whose components are designed to work with JavaScript.
    Fortunately, some component libraries wrap the Bootstrap components and provide
    a simpler .NET API, which is more suitable for use in Blazor applications.
  prefs: []
  type: TYPE_NORMAL
- en: One of these component libraries is **Blazorise**. It is actually an abstraction
    library and can work with multiple providers such as Bootstrap, Bulma, and Ant
    Design. ABP startup templates use the Bootstrap provider of the Blazorise library.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Blazorise and see the components in action on its
    website: [https://blazorise.com](https://blazorise.com). The following figure
    is a screenshot from the form components demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Blazorise demo: form components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.01_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1 – Blazorise demo: form components'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the Blazorise library, the ABP Blazor UI uses **Font Awesome** as the
    CSS font icon library. So, any module or application can use these libraries on
    their pages without an explicit dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The UI theme is responsible for rendering the layout, including the header,
    menu, toolbar, page alerts, and footer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to add new items to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Working with menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Menu management in the ABP Blazor UI is very similar to the ABP MVC/Razor Pages
    UI, which was covered in [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `AbpNavigationOptions` to add contributors to the menu system. ABP executes
    all the contributors to build the menu dynamically. The startup solution includes
    a menu contributor and is added to `AbpNavigationOptions` as per the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`DemoAppMenuContributor` is a class that implements the `IMenuContributor`
    interface. The `IMenuContributor` interface defines the `ConfigureMenuAsync` method,
    which we should implement as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two standard menu names defined as constants in the `StandardMenus`
    class (in the `Volo.Abp.UI.Navigation` namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Main`: The main menu of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User`: The user context menu. It is opened when you click your username on
    the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the preceding example checks the menu name and adds items only to the main
    menu. The following code block adds a new menu item to the main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can resolve services from dependency injection using the `context.ServiceProvider`
    object. The `context.GetLocalizer` method is a shortcut to resolve an `IStringLocalizer<T>`
    instance. Similarly, we can use the `context.IsGrantedAsync` shortcut method to
    check the permission of the current user, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Menu items can be nested. The following example adds a `Crm` menu item and
    an `Orders` menu item under it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I've called `AddItem` on the first `ApplicationMenuItem` object to add a child
    item. You can do the same for the `Orders` menu item to build deeper menus.
  prefs: []
  type: TYPE_NORMAL
- en: We've used localization and authorization services while creating menu items.
    In the next section, we will see how to use these services in other parts of our
    Blazor application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the basic services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will show you how to use some fundamental services in Blazor
    applications. As you will see, they are almost the same as the server-side services
    that we covered in earlier chapters. Let's start with the authorization service.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing the users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We typically use authorization in Blazor applications to hide/disable some pages,
    components, and functionalities on the user interface. While the server always
    checks the same authorization rules for security, client-side authorization checks
    provide a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: '`IAuthorizationService` is used to programmatically check permissions/policies,
    as on the server side. You can inject and use its methods, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthorizationService` has different ways to work. Please refer to the *Working
    with authorization and permission systems* section of [*Chapter 7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213),
    *Exploring Cross-Cutting Concerns*, to learn more about the authorization system.'
  prefs: []
  type: TYPE_NORMAL
- en: The component in the preceding example is inherited from the `AbpComponentBase`
    class. We can directly use the `AuthorizationService` property without manual
    injection since the `AbpComponentBase` class pre-injects it for us. The `AuthorizationService`
    property type is `IAuthorizationService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t inherit from the `AbpComponentBase` class, you can inject it
    using the `[Inject]` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the same `IAuthorizationService` on the view side of your Razor
    components when you need it. However, there are some alternative ways to make
    your application code cleaner. For example, you can use the `[Authorize]` attribute
    on a component to make it available only for authenticated users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[Authorize]` attribute works similarly to the server side. You can pass
    a policy/permission name to check for a specific permission, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is typical to show a part of the UI if the user has a specific permission.
    The following example uses the `AuthorizeView` element to show a message if the
    current user has permission to edit orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can conditionally render the action buttons or other parts
    of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP is 100% compatible with Blazor''s authorization system, so you can refer
    to Microsoft''s documentation to see more examples and details: [https://docs.microsoft.com/en-us/aspnet/core/blazor/security](https://docs.microsoft.com/en-us/aspnet/core/blazor/security).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use the localization system, another
    common UI service.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor applications share the same API for localizing texts. We can inject and
    use the `IStringLocalizer<T>` service to get the localized texts for the current
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Razor component uses the `IStringLocalizer<T>` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use the standard `@inject` directive and specify the localization resource
    type in the generic `IStringLocalizer<T>` interface. The same interface can also
    be injected and used in any service in your application. Please refer to the *Localizing
    the user interface* section of [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*, to learn about working with the localization
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn to get information about the current user in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the current user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You sometimes may need to know the current user''s username, email address,
    and other details in your application. We use the `ICurrentUser` service to access
    the current user, as on the server side. The following example component renders
    a welcome message by the current user''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition to standard properties such as `Name`, `Surname`, `UserName`, and
    `Email`, you can use the `ICurrentUser.FindClaimValue(...)` method to get custom
    claims issued by the server.
  prefs: []
  type: TYPE_NORMAL
- en: I've introduced the basic ABP Blazor services typically used by all the applications.
    I kept them short since the APIs are almost the same with the server side, and
    we've already covered them in detail in previous chapters. In the next section,
    I will continue with the UI services used to inform the user.
  prefs: []
  type: TYPE_NORMAL
- en: Using the UI services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common in every application to show messages, notifications, and alerts
    to users to inform or warn them. In the next sections, I will introduce ABP's
    built-in APIs for these services.
  prefs: []
  type: TYPE_NORMAL
- en: Showing message boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message boxes are used to show blocking messages or confirmation dialogs to
    the user. The user clicks on the **Ok** button to disable the message or clicks
    the **Yes** or **Cancel** buttons to make a decision on configuration dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five types of messages – `Info`, `Success`, `Warn`, `Error`, and
    `Confirm`. The following example shows a `Success` message sent to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Message` property, in this example, is coming from the `AbpComponentBase`
    class (`DemoAppComponentBase` inherits it), and its type is `IUiMessageService`.
    Alternatively, you can inject `IUiMessageService` manually for your components,
    pages, or services. All the `IUiMessageService` methods can take an extra `title`
    parameter and an `options` action to customize the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the result of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – A simple success message without a title'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.02_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – A simple success message without a title
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a confirmation dialog sent to the user and takes
    action if the user clicks the **Yes** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Confirm` method returns a `bool` value, so you can see whether the user
    has accepted the dialog message. The following figure shows the result of this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – A confirmation dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.03_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – A confirmation dialog
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to show a non-blocking information message to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Showing notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages boxes focus users on the message. They should click the **Ok** button
    to return to the application UI. On the other hand, notifications are non-blocking
    informative messages. They are shown in the bottom-right corner of the screen
    and automatically disappear after a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of notifications – `Info`, `Success`, `Warn`, and `Error`.
    The following example shows a confirmation dialog and shows a `Success` notification
    if the user accepts the confirmation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Notify` property comes from the `AbpComponentBase` base class. You can
    inject the `IUiNotificationService` interface and use it anywhere to show notifications
    on the UI. All the notification methods can take an extra `title` parameter and
    an `options` action to customize the dialog. The following figure shows the result
    of the `Notify.Success` method used in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – An example notification message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.04_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – An example notification message
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces alerts, another way to show a message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Showing alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using alerts is a sticky way to show a non-blocking message to the user. The
    user, optionally, can dismiss the alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of alerts – `Info`, `Success`, `Warning`, and `Danger`.
    The following example shows a `Success` alert sent to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I've used the `Alerts` property coming from the base class.
    You can always inject the `IAlertManager` service and use it like `IAlertManager.Alerts.Success(…)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the alert methods take `text` (required), a `title` (optional), and
    `dismissible` (optional and default – `true`) parameters. If an alert is dismissible,
    then the user can make it disappear by clicking the **X** button. The following
    figure shows the alert created in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – A Success alert message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.05_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – A Success alert message
  prefs: []
  type: TYPE_NORMAL
- en: Alerts are rendered by the theme on top of the page content. Besides the standard
    `Info`, `Success`, `Warning`, and `Danger` methods, you can use the `Add` method
    by specifying `AlertType` to use all Bootstrap styles, such as `Primary`, `Secondary`,
    or `Dark`.
  prefs: []
  type: TYPE_NORMAL
- en: You've now learned three ways to show information messages to the user. In the
    next section, we will investigate how the Blazor application consumes the HTTP
    APIs of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming HTTP APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the standard `HttpClient` to manually set up and perform an HTTP
    request to the server. However, ABP provides C# client proxies to call HTTP API
    endpoints easily. You can directly consume your application services from the
    Blazor UI and let ABP Framework handle the HTTP API calls for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have an application service interface, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Application service interfaces are defined in the `Application.Contracts` project
    (the `DemoApp.Application.Contracts` project for the example solution I've created).
    The Blazor application has a reference to that project. This way, we can use the
    `ITestAppService` interface on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application services are implemented in the `Application` project (the `DemoApp.Application`
    project for the example solution I''ve created). We can simply implement the `ITestAppService`
    interface, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can directly inject `ITestAppService` into any page/component, as with
    any other local service, and call its methods, just like a standard method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I used the standard `[Inject]` attribute on top of the `TestAppService`
    property to tell Blazor to inject it for me. Then, I've overridden it in the `OnInitializedAsync`
    method to call the `GetDataAsync` method. As we know, the `OnInitializedAsync`
    method is called just after the component/page is initially rendered and ready
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s that easy. When we call the `GetDataAsync` method, ABP actually makes
    an HTTP API call to the server by handling all the complexity, including authentication,
    error handling, and JSON serialization. It reads the server''s root URL from the
    `RemoteServices` configuration in the `wwwroot/appsettings.json` file of the Blazor
    project. An example configuration is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this section, I've used ABP's dynamic C# client proxy approach to consume
    HTTP APIs from the Blazor application. We will return to this topic in [*Chapter
    14*](B17287_14_Epub_AM.xhtml#_idTextAnchor429), *Building HTTP APIs and Real-Time
    Services*, by also introducing the static C# client proxies.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will explore how we can add script and style files to our Blazor
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with global scripts and styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Importing script and style files for the Blazor Server UI is the same as the
    MVC/Razor Pages UI for ABP Framework. You can refer to [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, to learn how to use it. This section is based
    on Blazor WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor WebAssembly is a Single-Page Application and it has a single entry point
    by default. The `index.html` file is in the `wwwroot` folder, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – The index.html file in the wwwroot folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.06_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – The index.html file in the wwwroot folder
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html` is a plain HTML file. The server sends it to the browser without
    any processing. Remember that a simple static file server can serve a Blazor WebAssembly
    application. The browser first loads the `index.html` document and then loads
    the styles and scripts imported by this document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `index.html` document, you will see a part within the `ABP:Styles`
    comments, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code part (including the comments) is automatically created (and then
    updated) by the ABP CLI when you execute the following command in the root folder
    of the Blazor project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you execute this command, it creates (or regenerates) the global style
    bundle. This bundle contains all the necessary styles, including the .NET runtime,
    Blazor, and other used libraries, in a minified format. Whenever you add a new
    Blazor-related ABP NuGet package/module into your application, you rerun the `abp
    bundle` command and it regenerates the bundle with the necessary dependencies
    included.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP''s `bundle` command does a great job. When installing a module, you don''t
    need to know its global script files or extra dependencies. Just run this command,
    and you have the updated, production-ready global bundle file. Every module contributes
    its own dependencies into that bundle, and then ABP generates the bundle by respecting
    the module dependency order. To manipulate the bundle, you should define a class
    that implements the `IBundleContributor` interface. The Blazor project in the
    startup solution template already contains a bundle contributor, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`AddScripts` and `AddStyles` methods are used to add JavaScript and CSS files
    to the global bundles. You can also remove or change an existing file (which was
    added by a package your application depends on) using the `context.BundleDefinitions`
    collection, but that''s rarely needed. Here, the `excludeFromBundle` parameter
    adds the `main.css` file separately from the global bundle. You can remove that
    parameter to include it in the `global.css` bundle file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the style bundle, the `index.html` file contains an `ABP:Scripts`
    part, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code part is created (and updated) by the ABP CLI with the `abp
    bundle` command. If you want to include files, you can do it inside the `AddScripts`
    method of your bundle contributor class. The paths of the files are considered
    relative to the `wwwroot` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a quick introduction to the ABP Framework Blazor UI to understand
    its architecture and the services you will frequently use in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is one of the most challenging aspects of an application, and
    ABP provides an industry-standard solution that you can directly use in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned about the services to get the current user's identity information,
    check the user's permissions, and localize the user interface. We also explored
    the services to show message boxes, notifications, and alerts to the user.
  prefs: []
  type: TYPE_NORMAL
- en: ABP's dynamic C# client proxy system makes it super-easy to consume server-side
    HTTP APIs. Finally, you've learned how to use the global bundling system to handle
    bundling and minification in your Blazor applications.
  prefs: []
  type: TYPE_NORMAL
- en: I intentionally didn't cover two topics in this chapter. The first one is Blazor
    itself. It is a very detailed topic to cover in a single chapter of a book. I
    advise you to read Microsoft's documentation ([https://docs.microsoft.com/en-us/aspnet/core/blazor](https://docs.microsoft.com/en-us/aspnet/core/blazor))
    or purchase a dedicated book if you are new to the Blazor framework. Check out
    the book *Web Development with Blazor*, by *Jimmy Engström*, from *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second topic I haven''t covered in this chapter is complex UI components,
    such as data tables, modals, and tabs. They are so specific to the UI kit you
    are using. ABP comes with the Blazorise library, and you can refer to its documentation
    to learn its components: [https://blazorise.com/docs](https://blazorise.com/docs).
    I also suggest going through ABP Framework''s Blazor UI tutorial to understand
    the fundamental development model with the most-used components, data tables,
    and modals: [https://docs.abp.io/en/abp/latest/Getting-Started](https://docs.abp.io/en/abp/latest/Getting-Started).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on building HTTP APIs and consuming them
    in client applications. We will also look at using the SignalR library for real-time
    communication between a client and a server.
  prefs: []
  type: TYPE_NORMAL
