["```cs\n    //----------------------------Abstract Factory\n     public interface INumeric\n     { \n         BigNumOperations Operations ();\n     }\n    //----------------------------Abstract Product\n    public abstract class BigNumOperations\n    { \n       public abstract string Multiply (string x, string y);\n       public virtual string Multiply (\n         string x,\n         string y,\n         CancellationToken ct,\n         BlockingCollection<string> log)\n       {\n         return this.Multiply(x, y); \n       }\n```", "```cs\n    public string Power (string number, int exponent) \n    { \n        int remainingEvenExp = exponent / 2; \n        int remainingOddExp = exponent % 2; \n        string result = number; \n        if (remainingEvenExp > 0) \n        { \n            string square = this.Multiply(number, number); \n            result = square; \n            if (remainingEvenExp > 1) \n            { \n                if (remainingOddExp == 1) \n                { \n                    result = this.Multiply( \n                        this.Power(square, remainingEvenExp), \n                        number); \n                } \n                else \n                { \n                    result = this.Power(square, remainingEvenExp); \n                } \n             } \n             else \n             { \n                if (remainingOddExp == 1) \n                { \n                    result = this.Multiply(square, number); \n                } \n             } \n         } \n         return result; \n    } \n\n     // Creates, Initializes and Returns a Jagged Array \n\n     public static int[][] CreateMatrix (int rows, int cols) \n     { \n        int[][] result = new int[rows][]; \n        for (int i = 0; i < rows; ++i) \n            result[i] = new int[cols]; \n        return result; \n     } \n   } \n\n    // ----------------------------Concrete Product-1 \n\n    public class BigNumOperations1 : BigNumOperations \n    { \n        /// <summary> \n        /// Serial Implementation of Schönhage-Strassen Algorithm \n        /// <param name=\"x\">String number Sequence-1</param> \n        /// <param name=\"y\">String number Sequence-2</param> \n        /// <returns>String Equivalent Product Sequence</returns> \n        /// </summary> \n\n        public override string Multiply (string x, string y) \n        { \n            int n = x.Length; \n            int m = y.Length; \n            int prodDigits = n + m - 1; \n            int[] linearConvolution = new int[prodDigits]; \n            int[][] longMultiplication = CreateMatrix(m, prodDigits); \n\n            //----------------------------Step-1 \n\n            for (int i = m - 1; i >= 0; i--) \n            { \n                int row = m - 1 - i; \n                int col = 0; \n                int iProduct; \n                for (int j = n - 1; j >= 0; j--) \n                { \n                    col = i + j; \n                    iProduct = (( int ) \n                      Char.GetNumericValue(y[i])) * \n                      (( int ) Char.GetNumericValue(x[j])); \n                    longMultiplication[row][col] = iProduct; \n                } \n            } \n\n            //----------------------------Step-2 \n\n            for (int j = prodDigits - 1; j >= 0; j--) \n            { \n                int sum = 0; \n                for (int i = 0; i < m; i++) \n                { \n                    sum += longMultiplication[i][j]; \n                } \n                linearConvolution[j] = sum; \n            } \n\n            //----------------------------Step-3 \n\n            int nextCarry = 0; \n            int[] product = new int[prodDigits]; \n            for (int i = (n + m - 2); i >= 0; i--) \n            { \n                linearConvolution[i] += nextCarry; \n                product[i] = linearConvolution[i] % 10; \n                nextCarry = linearConvolution[i] / 10; \n            } \n            return (nextCarry > 0 ? nextCarry.ToString() : \"\") + \n              new string \n              ( \n                  Array.ConvertAll<int, char> \n                  (product, c => Convert.ToChar(c + 0x30)) \n              ); \n        } \n    } \n\n    // Concrete Factory-1 \n\n    public class BigNumber1 : INumeric \n    { \n      public BigNumOperations Operations() \n      { \n        return new BigNumOperations1(); \n      } \n    }\n```", "```cs\n    // Concrete Product-2 \n\n    public class BigNumOperations2 : BigNumOperations \n    { \n        public override string Multiply (string x, string y) \n        { \n          int n = x.Length; \n          int m = y.Length; \n          int prodDigits = n + m - 1; \n          int[] linearConvolution = new int[prodDigits]; \n          int[][] longMultiplication = CreateMatrix(m, prodDigits); \n\n          //----------------------------Step-1 \n\n          Parallel.For(0, m, i => \n          { \n              int row = m - 1 - i; \n              int col = 0; \n              int iProduct; \n              for (int j = 0; j < n; j++) \n              { \n                  col = i + j; \n                  iProduct = (( int ) Char.GetNumericValue(y[i]))\n                    * (( int ) Char.GetNumericValue(x[j])); \n                  longMultiplication[row][col] = iProduct; \n              } \n          }); \n\n          //----------------------------Step-2 \n\n          Parallel.For(0, prodDigits, j => \n          { \n              int sum = 0; \n              for (int i = 0; i < m; i++) \n              { \n                  sum += longMultiplication[i][j]; \n              } \n              linearConvolution[j] = sum; \n          }); \n\n          //----------------------------Step-3 \n\n          //Use code from Concrete Product-1 here... \n        }  \n    } \n\n    // Concrete Factory-2 \n\n    public class BigNumber2 : INumeric \n    { \n      public BigNumOperations Operations() \n      { \n        return new BigNumOperations2(); \n      } \n    }\n```", "```cs\n    public static void Power (string[] args) \n    { \n        var bigN1 = new BigNumber1(); \n        var bigN2 = new BigNumber2(); \n        var x = args[0]; \n        int y = Convert.ToInt32(args[1]); \n\n        var watch = Stopwatch.StartNew(); \n        var val1 = bigN1.Operations().Power(x, y); \n\n       Console.WriteLine(\n         \"Serial Computation of {0} ^ {1}: {2} seconds\", \n          x, y, watch.ElapsedMilliseconds / 1000D); \n\n        watch = Stopwatch.StartNew(); \n        var val2 = bigN2.Operations().Power(x, y); \n\n        Console.WriteLine( \n          \"Parallel Computation of {0} ^ {1}: {2} seconds\", \n          x, y, watch.ElapsedMilliseconds / 1000D); \n\n        Console.WriteLine(\"Computed Values are {0}!!!\",  \n          val1.Equals(val2) ? \"EQUAL\" : \"DIFFERENT\"); \n    }\n```", "```cs\n    // Concrete Product-3 \n\n    public class BigNumOperations3 : BigNumOperations \n    { \n        public override string Multiply (string x, string y,   \n          CancellationToken ct, BlockingCollection<string> log) \n        { \n            int n = x.Length; \n            int m = y.Length; \n            int prodDigits = n + m - 1; \n            int[] linearConvolution = new int[prodDigits]; \n            int[][] longMultiplication = CreateMatrix(m, prodDigits); \n\n var degreeOfParallelism = Environment.ProcessorCount; \n var tasks = new Task[degreeOfParallelism]; \n\n            //----------------------------Step-1 \n\n            for (int taskNumber = 0;  \n              taskNumber < degreeOfParallelism;  \n                taskNumber++) \n            { \n              int taskNumberCopy = taskNumber; \n              tasks[taskNumber] = Task.Factory.StartNew( \n                () => \n                { \n                    var max =  \n                        m * (taskNumberCopy + 1) /  \n                        degreeOfParallelism; \n                    var min =  \n                        m * taskNumberCopy /  \n                        degreeOfParallelism; \n                    for (int i = min; i < max; i++) \n                    { \n                        int row = m - 1 - i; \n                        int col = 0; \n                        int iProduct; \n                        for (int j = 0; j < n; j++) \n                        { \n                            col = i + j; \n                            iProduct =  \n                                (( int ) Char \n                                .GetNumericValue(y[i])) * \n                                (( int ) Char \n                                .GetNumericValue(x[j])); \n                            longMultiplication[row][col] =  \n                                iProduct; \n                        } \n                    } \n                }); \n        } \n\n        Task.WaitAll(tasks);        //Blocking Call \n\n        //----------------------------Step-2 \n\n        for (int taskNumber = 0;  \n            taskNumber < degreeOfParallelism;  \n            taskNumber++) \n        { \n            int taskNumberCopy = taskNumber; \n            tasks[taskNumber] = Task.Factory.StartNew( \n                () => \n                { \n                    var max =  \n                        prodDigits * (taskNumberCopy + 1) /  \n                        degreeOfParallelism; \n                    var min =  \n                        prodDigits * taskNumberCopy /  \n                        degreeOfParallelism; \n                    for (int j = min; j < max; j++) \n                    { \n                        int sum = 0; \n                        for (int i = 0; i < m; i++) \n                        { \n                            sum += longMultiplication[i][j]; \n                        } \n                        linearConvolution[j] = sum; \n                    } \n                }); \n        } \n\n        Task.WaitAll(tasks);        //Blocking Call \n\n        //----------------------------Step-3 \n\n        //Use code from Concrete Product-1 here... \n\n      } \n    } \n\n    // Concrete Factory-3 \n\n    public class BigNumber3 : INumeric \n    { \n      public BigNumOperations Operations() \n      { \n        return new BigNumOperations3(); \n      } \n    }\n```", "```cs\n    // Concrete Product-4 \n\n    public class BigNumOperations4 : BigNumOperations \n    { \n        /// <summary> \n        /// Serial Cancellable Implementation of  \n        /// Schönhage-Strassen Algorithm \n        /// <param name=\"x\">String number Sequence-1</param> \n        /// <param name=\"y\">String number Sequence-2</param> \n        /// <returns>String Equivalent Product Sequence</returns> \n        /// </summary> \n\n        public override string Multiply ( \n            string x,  \n            string y,  \n CancellationToken ct, \n            BlockingCollection<string> log) \n        { \n if (ct.IsCancellationRequested == true) \n            { \n ct.ThrowIfCancellationRequested(); \n            } \n            //Use code from Concrete Product-1 here... \n\n            //----------------------------Step-1 \n\n            for (int i = m - 1; i >= 0; i--) \n            { \n            //Use code from Concrete Product-1 here... \n\n                for (int j = n - 1; j >= 0; j--) \n                { \n if (ct.IsCancellationRequested) \n                    { \n ct.ThrowIfCancellationRequested(); \n                    } \n\n            //Use code from Concrete Product-1 here... \n\n                } \n            } \n\n            //----------------------------Step-2 \n\n            for (int j = prodDigits - 1; j >= 0; j--) \n            { \n if (ct.IsCancellationRequested) \n                { \n ct.ThrowIfCancellationRequested(); \n                } \n\n                //Use code from Concrete Product-1 here... \n            } \n\n                //----------------------------Step-3 \n\n            for (int i = (n + m - 2); i >= 0; i--) \n            { \n if (ct.IsCancellationRequested) \n                { \n ct.ThrowIfCancellationRequested(); \n                } \n\n                //Use code from Concrete Product-1 here... \n        } \n    }\n```", "```cs\n    /// <summary> \n    /// Adaptive Speculation for determining the best strategy \n    /// for your environment. Leveraging Task.WaitAny method \n    /// </summary> \n    /// <param name=\"args\"></param> \n\n    public static void AdaptivePower (string[] args) \n    { \n        var bigN1 = new BigNumber4(); \n        var bigN2 = new BigNumber5(); \n        var bigN3 = new BigNumber6(); \n\n        var val1 = \"\"; \n        var val2 = \"\"; \n        var val3 = \"\"; \n\n        var x = args[0]; \n        int y = Convert.ToInt32(args[1]); \n\n        var tasks = new Task[3]; \n        var tokenSource = new CancellationTokenSource(); \n        var token = tokenSource.Token; \n BlockingCollection<string> log = new BlockingCollection<string>(); \n        Stopwatch watch; \n\n        tasks[0] = Task.Factory.StartNew(() => \n        { \n            watch = Stopwatch.StartNew(); \n            val1 = bigN1.Operations() \n              .Power(x, y, token, log); \n\n            Console.WriteLine(\"Elapsed Time for Serial \" + \n              \"Computation of {0} ^ {1}: {2} seconds \" + \n                \">> {3}\", x, y, watch.ElapsedMilliseconds / 1000D, val1); \n        }, token); \n\n        tasks[1] = Task.Factory.StartNew(() => \n        { \n              watch = Stopwatch.StartNew(); \n              val2 = bigN2.Operations() \n                .Power(x, y, token, log); \n\n              Console.WriteLine(\"Elapsed Time for \" + \n                \"Parallel.For Computation of \" + \n                  \"{0} ^ {1}: {2} seconds >> {3}\", x, y, \n                    watch.ElapsedMilliseconds / 1000D, val2); \n            }, token); \n\n        tasks[2] = Task.Factory.StartNew(() => \n        { \n              watch = Stopwatch.StartNew(); \n              val3 = bigN3.Operations() \n                .Power(x, y, token, log); \n              Console.WriteLine(\"Elapsed Time for Parallel \" + \n                \"Task Computation of {0} ^ {1}: {2} \" + \n                  \"seconds >> {3}\", x, y,  \n                    watch.ElapsedMilliseconds / 1000D, val3); \n        }, token); \n\n        Console.WriteLine(\"Determining Fastest Algorithm \" \n          + \"Implementation...\"); \n\n        Task.WaitAny(tasks);    // Wait for fastest task to complete. \n        tokenSource.Cancel();   // Cancel all the other slower tasks. \n\n        try \n        { \n            Task.WaitAll(tasks); \n        } \n        catch (AggregateException ae) \n        { \n            ae.Flatten().Handle(e => e is OperationCanceledException); \n        } \n        finally \n        { \n            if (tokenSource != null) \n                tokenSource.Dispose(); \n            foreach (string logItem in log) \n            { \n Console.WriteLine(logItem); \n            } \n            Console.WriteLine(\"Adaptive Speculation Complete!!!\"); \n        } \n    }\n```", "```cs\n    // Concrete Product-4 \n\n    public class BigNumOperations4 : BigNumOperations \n    { \n      /// <summary> \n      /// Serial Cancellable & Loggable Implementation of  \n      /// Schönhage-Strassen Algorithm \n      /// <param name=\"x\">String number Sequence-1</param> \n      /// <param name=\"y\">String number Sequence-2</param> \n      /// <returns>String Equivalent Product Sequence</returns> \n      /// </summary> \n\n      public override string Multiply (string x, string y,  \n        CancellationToken ct, BlockingCollection<string> log) \n     { \n        if (ct.IsCancellationRequested == true) \n        { \n log.Add(\"Serial Implementation Task was \" + \n          \"cancelled before it got started!\"); \n          ct.ThrowIfCancellationRequested(); \n        } \n        //Use code from Concrete Product-1 here... \n\n        //----------------------------Step-1 \n\n            for (int i = m - 1; i >= 0; i--) \n            { \n                //Use code from Concrete Product-1 here... \n\n                for (int j = n - 1; j >= 0; j--) \n                { \n                    if (ct.IsCancellationRequested) \n                    { \n log.Add(\"Serial Implementation Step1 \" +\n \"was cancelled!\"); \n                        ct.ThrowIfCancellationRequested(); \n                    } \n\n                    //Use code from Concrete Product-1 here... \n\n                } \n            } \n\n            //----------------------------Step-2 \n\n            for (int j = prodDigits - 1; j >= 0; j--) \n            { \n                if (ct.IsCancellationRequested) \n                { \n log.Add(\"Serial Implementation Step2 \" + \n \"was cancelled!\"); \n                    ct.ThrowIfCancellationRequested(); \n                } \n\n                //Use code from Concrete Product-1 here... \n            } \n\n            //----------------------------Step-3 \n\n            for (int i = (n + m - 2); i >= 0; i--) \n            { \n                if (ct.IsCancellationRequested) \n                { \n log.Add(\"Serial Implementation Step3 \" +\n \"was cancelled!\"); \n                    ct.ThrowIfCancellationRequested(); \n                } \n\n                //Use code from Concrete Product-1 here... \n        } \n    }\n```"]