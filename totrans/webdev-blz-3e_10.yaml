- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript Interop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at JavaScript. In specific scenarios, we
    still need to use JavaScript, or we will want to use an existing library that
    relies on JavaScript. Blazor uses JavaScript to update the **Document Object Model**
    (**DOM**), download files, and access local storage on the client.
  prefs: []
  type: TYPE_NORMAL
- en: So, there are, and always will be, cases when we need to communicate with JavaScript
    or have JavaScript communicate with us. Don’t worry, the Blazor community is an
    amazing one, so chances are someone has already built the interop we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET to JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript to .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an existing JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript interop in WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure you have followed the previous chapters or use the `Chapter09` folder
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: If you are jumping into this chapter using the code from GitHub, make sure you
    have added the `Auth0` account information in the settings files. You can find
    the instructions in *Chapter 8*, *Authentication and Authorization*.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many say Blazor is the JavaScript killer, but the truth is that Blazor needs
    JavaScript to work. Some events only get triggered in JavaScript, and if we want
    to use those events, we need to make an interop.
  prefs: []
  type: TYPE_NORMAL
- en: I jokingly say that I have never written so much JavaScript as when I started
    developing with Blazor. it’s not that bad.
  prefs: []
  type: TYPE_NORMAL
- en: I have written a couple of libraries that require JavaScript to work. They are
    called `Blazm.Components` and `Blazm.Bluetooth`.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a grid component that uses JavaScript interop to trigger C#
    code (JavaScript to .NET) when the window is resized, to remove columns if they
    can’t fit inside the window.
  prefs: []
  type: TYPE_NORMAL
- en: When that is triggered, the C# code calls JavaScript to get the size of the
    columns based on the client width, which only the web browser knows, and based
    on that answer, it removes columns if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The second one, `Blazm.Bluetooth`, makes it possible to interact with Bluetooth
    devices using Web Bluetooth, which is a web standard accessible through JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses two-way communication; Bluetooth events can trigger C# code, and C#
    code can iterate over devices and send data to them. They are both open source,
    so if you are interested in looking at a real-world project, you can check them
    out on my GitHub: [https://github.com/EngstromJimmy](https://github.com/EngstromJimmy).'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, in most cases, I would argue that we won’t need to write
    JavaScript ourselves. The Blazor community is very big, so chances are that someone
    has already written what we need. But we don’t need to be afraid of using JavaScript
    either. Next, we will look at different ways to add JavaScript calls to our Blazor
    project.
  prefs: []
  type: TYPE_NORMAL
- en: .NET to JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling JavaScript from .NET is pretty simple. There are two ways of doing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Global JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go through both ways to see what the difference is.
  prefs: []
  type: TYPE_NORMAL
- en: Global JavaScript (the old way)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the JavaScript method, we need to make it accessible. One way is to
    define it globally through the JavaScript window object. This is a bad practice
    since it is accessible by all scripts and could replace the functionality in other
    scripts (if we accidentally use the same names).
  prefs: []
  type: TYPE_NORMAL
- en: What we can do, for example, is use scopes, create an object in global space,
    and put our variables and methods on that object so that we lower the risk a bit,
    at least.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a scope could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create an object with the name `myscope`. Then, we declare a method on that
    object called `methodName`. In this example, there is no code in the method; this
    only demonstrates how it could be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to call the method from C#, we would call it using `JSRuntime` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two different methods we can use to call JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InvokeVoidAsync`, which calls JavaScript but doesn’t expect a return value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvokeAsync<T>`, which calls JavaScript and expects a return value of type
    `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also send in parameters to our JavaScript method if we want. We also
    need to refer to JavaScript, and JavaScript must be stored in the `wwwroot` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The other way is JavaScript isolation, which uses the methods described here,
    but with modules.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET 5, we got a new way to add JavaScript using JavaScript Isolation, which
    is a much nicer way to call JavaScript. It doesn’t use global methods, and it
    doesn’t require us to refer to the JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: This is awesome for component vendors and end users because JavaScript will
    be loaded when needed. It will only be loaded once (Blazor handles that for us),
    and we don’t need to add a reference to the JavaScript file, which makes it easier
    to start and use a library.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s implement that instead.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated JavaScript can be stored in the `wwwroot` folder, but since an update
    in .NET 6, we can add them in the same way we add isolated CSS. Add them to your
    component’s folder and name it, adding `.js` to the end (`mycomponent.razor.js`).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do just that!
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we can delete categories and components. Let’s implement a
    simple JavaScript call to reveal a prompt to make sure that the user wants to
    delete the category or tag. But we have talked about doing things in a reusable
    way, so let’s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, select the `ReusableComponents/BlogButton.razor`
    file, create a new JavaScript file, and name the file `BlogButton.razor.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new file (it is located under `BlogButton.razor` in the solution explorer)
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: JavaScript Isolation uses the standard **EcmaScript** (**ES**) modules and can
    be loaded on demand. The methods it exposes are only accessible through that object
    and not globally, as with the *old* way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `BlogButton.razor` and inject `IJSRuntime` at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `code` section, let’s add a method that will call JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IJSObjectReference` is a reference to the specific script that we will import
    further down. It has access to the exported methods in our JavaScript, and nothing
    else.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We run the `Import` command and send the filename as a parameter. This will
    run the `let mymodule = import("/_content/SharedComponents/ReusableComponents/BlogButton.razor.js")`
    JavaScript command and return the module. We also add a `ConfirmMessage` parameter
    so we know that if we have a `ConfirmMessage` we should show a confirm message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, in our `OnButtonClick` method, we first check whether we `shoudExecute`
    the method or not. Change it to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can use our button to confirm whether we want to delete the `Category`
    or `Tag`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `ItemList.razor`, and let’s add our `BlogButton` to the component. Inside
    the `Virtualize` component, change the content to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of just calling our `Delete` event callback, we first call our new method.
    Let JavaScript confirm that you really want to delete it, and if so, then run
    the `Delete` event callback.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple implementation of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript to .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What about the other way around? I would argue that calling .NET code from JavaScript
    isn’t a very common scenario, and if we find ourselves in that scenario, we might
    want to think about what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: As Blazor developers, we should avoid using JavaScript as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: I am not bashing JavaScript in any way, but I see this often happen where developers
    kind of shoehorn what they’ve used before into their Blazor projects.
  prefs: []
  type: TYPE_NORMAL
- en: They are solving things with JavaScript that are easy to do with an `if` statement
    in Blazor. So, that’s why I think it’s essential to think about when to use JavaScript
    and when not to use JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, times when JavaScript is the only option, and as I mentioned
    earlier, `Blazm` uses communication both ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways of doing a callback from JavaScript to .NET code:'
  prefs: []
  type: TYPE_NORMAL
- en: A static .NET method call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance method call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component instance method call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Static .NET method call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To call a .NET function from JavaScript, we can make the function static, and
    we also need to add the `JSInvokable` attribute to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a function such as this in the `code` section of a Razor component,
    or inside a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JavaScript file, we can call that function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `DotNet` object comes from the `Blazor.js` or `blazor.server.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlazorWebAssemblySample` is the name of the assembly, and `ReturnArrayAsync`
    is the name of the static .NET function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to specify the name of the function in the `JSInvokeable`
    attribute if we don’t want it to be the same as the method name like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, JavaScript calls back to .NET code, which returns an `int` array.
  prefs: []
  type: TYPE_NORMAL
- en: It is returned as a promise in the JavaScript file that we are waiting for,
    and then (using the `then` operator) we continue with the execution, adding a
    `4` to the array and then outputting the values in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Instance method call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is a bit tricky; we need to pass an instance of the .NET object
    to call it (this is the method that `Blazm.Bluetooth` is using).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a class that will handle the method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This class takes a string (a name) in the constructor and a method called `SayHello`
    that returns a string containing `"Hello,"` and the name we supplied when we created
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to create an instance of that class, supply a name, and create `DotNetObjectReference<T>`,
    which will give JavaScript access to the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need JavaScript that can call the .NET function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using the export syntax, and we export a function called
    `sayHello`, which takes an instance of `DotNetObjectReference` called `dotnetHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: In that instance, we invoke the `SayHello` method, which is the `SayHello` method
    on the .NET object. In this case, it will reference an instance of the `HelloHelper`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to call the JavaScript method, and we can do that from a class
    or, in this case, from a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go through the class. We inject `IJSRuntime` because we need one to call
    the JavaScript function. To avoid any memory leaks, we also have to make sure
    to implement `IDisposable` interface, and toward the bottom of the file, we make
    sure to dispose of the `DotNetObjectReference` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We create a private variable of the `DotNetObjectReference<HelloHelper>` type,
    which is going to contain our reference to our `HelloHelper` instance. We create
    `IJSObjectReference` so that we can load our JavaScript function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create an instance of `DotNetObjectReference.Create(new HelloHelper("Bruce
    Wayne"))` of our reference to a new instance of the `HelloHelper` class, which
    we supply with the name `"Bruce Wayne"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have `objRef`, which we will send to the JavaScript method, but first,
    we load the JavaScript module, and then we call `JavaScriptMethod` and pass in
    the reference to our `HelloHelper` instance. Now, the JavaScript `sayHello` method
    will run `hellohelperref.invokeMethodAsync('SayHello')`, which will make a call
    to `SayHelloHelper` and get back a string with `"Hello, Bruce Wayne"`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two more ways that we can use to call .NET functions from JavaScript.
    We can call a method on a component instance where we can trigger an action, but
    it is not a recommended approach for Blazor Server. We can also call a method
    on a component instance by using a `helper` class.
  prefs: []
  type: TYPE_NORMAL
- en: Since calling .NET from JavaScript is rare, we won’t go into the two examples.
    Instead, we’ll dive into things to think about when implementing an existing JavaScript
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an existing JavaScript library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best approach, in my opinion, is to avoid porting JavaScript libraries.
    Blazor needs to keep the DOM and the render tree in sync, and having JavaScript
    manipulate the DOM can jeopardize that.
  prefs: []
  type: TYPE_NORMAL
- en: Most component vendors, such as Telerik, Synfusion, Radzen, and, of course,
    `Blazm`, have native components. They don’t just wrap JavaScript but are explicitly
    written for Blazor in C#. Even though the components use JavaScript in some capacity,
    the goal is to keep that to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you are a library maintainer, my recommendation would be to write a native
    Blazor version of the library, keep JavaScript to a minimum, and, most importantly,
    not force Blazor developers to write JavaScript to use your components.
  prefs: []
  type: TYPE_NORMAL
- en: Some components will be unable to use JavaScript implementations since they
    need to manipulate the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is pretty smart when syncing the DOM and render tree, but try to avoid
    manipulating the DOM. If you need to use JavaScript for something, make sure to
    put an HTML tag outside the manipulation area, and Blazor will then keep track
    of that tag and not think about what is inside the tag.
  prefs: []
  type: TYPE_NORMAL
- en: Since we started using Blazor at my workplace very early, many vendors had not
    yet come out with Blazor components. We needed a graph component fast. On our
    previous website (before Blazor), we used a component called **Highcharts**.
  prefs: []
  type: TYPE_NORMAL
- en: '`Highcharts` is free to use for non-commercial projects. When building our
    wrapper, we had a couple of things we wanted to ensure. We wanted the component
    to work in a similar way to the existing one, and we wanted it to be as simple
    to use as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through what we did.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we added a reference to the `Highcharts` JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we added a JavaScript file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `loadHighchart` method takes `id` of the `div` tag, which should be converted
    into a chart, and the JSON for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a method that converts the JSON into a JSON object so that it
    can be passed into the `chart` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Highchart` Razor component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The important thing to notice here is that we have two nested `div` tags: one
    on the outside that we want Blazor to track and one on the inside that Highcharts
    will add things to.'
  prefs: []
  type: TYPE_NORMAL
- en: We pass a JSON parameter in the JSON for the configuration and then call our
    JavaScript function. We run our JavaScript interop in the `OnAfterRenderAsync`
    method because, otherwise, it would throw an exception, as you may recall from
    *Chapter 4*, *Understanding Basic Blazor Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only thing left to do is to use the component, and that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This test code will show a pie chart that looks like *Figure 10.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A yellow and black pie chart  Description automatically generated](img/B21849_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Chart example'
  prefs: []
  type: TYPE_NORMAL
- en: We have now gone through how we got a JavaScript library to work with Blazor,
    so this is an option if there is something we need.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, component vendors are investing in Blazor, so chances are that
    they have what we need, so we might not need to invest time in creating our own
    component library.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interop in WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the things mentioned so far in this chapter will work great for Blazor Server
    and Blazor WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: But with Blazor WebAssembly, we have direct access to the `JSRuntime` (since
    all the code is running inside the browser). Direct access will give us a really
    big performance boost. For most applications, we are doing one or two JavaScript
    calls. Performance is not really going to be a problem. Some applications are
    more JavaScript-heavy though and would benefit from using the `JSRuntime` directly.
  prefs: []
  type: TYPE_NORMAL
- en: We have had direct access to the `JSRuntime` using the `IJSInProcessRuntime`
    and `IJSUnmarshalledRuntime`. But with .NET 7, both are now obsolete, and we have
    gotten a nicer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the GitHub repository, I have added a couple of files to the `SharedComponents`
    project if you want to try the code.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at calling JavaScript from .NET. Please note that since
    our project is prerendering on the server, these code samples will not work (since
    they don’t work when running on the server). These samples must run in a WebAssembly-only
    project or disable the prerendering. They are included in the source code on GitHub
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use these features, we need to enable them in the project file
    by enabling `AllowUnsafeBlocks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: .NET to JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show the difference, the following sample is the same `ShowAlert` function
    as earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Razor file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using `JSHost` to import the JavaScript and give it the name `"nettojs"`.
    A source generator generates the implementation for calling the JavaScript, and
    to be sure that it can pick up what it should do, we need to add some code in
    a code-behind. We will go into more depth on source generators in *Chapter 17*,
    *Examining Source Generators*. The code-behind looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We add a `JSImport` attribute to a method, which will automatically be mapped
    to the JavaScript call.
  prefs: []
  type: TYPE_NORMAL
- en: This is a much nicer implementation, I think, and a lot faster.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at calling .NET from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript to .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When calling a .NET method from JavaScript, a new attribute makes that possible
    called `JSExport`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Razor file implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Calling `JSHost.ImportAsync` is not necessary for the `JSExport` part of the
    demo, but we need it to call JavaScript so that we can make the .NET call from
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, here we need to have the methods in a code-behind class that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `SupportedOSPlatform` attribute to ensure that this code
    can only run on a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript portion of this demo looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We call the `showMessage` JavaScript function from .NET, and it will then call
    the `setMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `setMessage` function uses the `globalThis` object to access the .NET runtime
    and get access to the `getAssemblyExports` method.
  prefs: []
  type: TYPE_NORMAL
- en: It will retrieve all the exports for our assembly and then run the method. The
    .NET method will return the `"This is a message from .NET"` string and show the
    string in an alert box.
  prefs: []
  type: TYPE_NORMAL
- en: Even though I prefer not to make any JavaScript calls in my Blazor applications,
    I love having the power to bridge between .NET code and JavaScript code with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught us about calling JavaScript from .NET and calling .NET from
    JavaScript. In most cases, we won’t need to do JavaScript calls, and chances are
    that the Blazor community or component vendors have solved the problem for us.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can port an existing library if needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to look at state management.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2668029180838459906.png)'
  prefs: []
  type: TYPE_IMG
