<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;10.&#xA0;Type Augmentation and Generic Computations">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch10"/>
 Chapter 10. Type Augmentation and Generic Computations</h1>
</div>
</div>
</div>
<p>To this point in the book, it was easy to notice the direct link between the use pattern and the correspondent language feature. For example, <a class="link" title="Chapter 5.  Algebraic Data Types" href="text00049.html#page">Chapter 5</a>
 , <span class="emphasis">
<em>Algebraic Data Types</em>
</span>
 , clearly showed that the native F# algebraic types are substitutes for custom classes. Increased quality and speed of implementations based on algebraic data types reflect the payoff for the feature use.</p>
<p>In this chapter, I will consider a certain language features that do not make the payoff from their use obvious. Nevertheless, these features are ubiquitous in F#. I mean the ambivalent pair of code generalization against the code specialization.</p>
<p>We are going to cover the following topics:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Code generalization techniques, or making the same functional code applicable to multiple function argument types</li>
<li class="listitem">Code specialization techniques, or making the functional code more specific than usually may be achieved by using standard features</li>
</ul>
</div>
<p>Each of the preceding patterns carries promises of certain benefits: improved performance, more succinctness, and better static type control. The goal of this chapter is to show you how to recognize the situations when these patterns are applicable and apply them, achieving the expected benefits.</p>
<div class="section" title="Code generalization">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch10lvl1sec63"/>
 Code generalization</h1>
</div>
</div>
</div>
<p>Let me begin by stating that F# <span class="strong">
<strong>automatically generalizes</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d</a>
 ) arguments of functions where it is possible to deal with the multiplicity of types.</p>
<p>So far, we have mostly been dealing with the generalization of data collections. That is, a sequence is agnostic to the type of its elements. That's why we were able to write functions that operate on sequences of arbitrary generic type. And F# type inference spots and carries this property on.</p>
<p>Suppose that we proudly implement our own function of reversing a list as follows (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">let reverse ls = 
    let rec rev acc = function 
    | h::t -&gt; rev (h::acc) t 
    | []   -&gt; acc 
    rev [] ls 
</pre>
<p>Then, we may notice that the F# compiler infers the <code class="literal">reverse : ls:'a list -&gt; 'alist</code>
 signature for it, where <code class="literal">'a</code>
 indicates that the function can be applied to any type of list elements. And if we decide to check out how exactly our <code class="literal">reverse</code>
 function would behave with different argument types, we may observe its behavior is consistent for the following arguments (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">reverse [1;2;3] 
// val it : int list = [3; 2; 1] 
reverse ["1";"2";"3"] 
// val it : string list = ["3"; "2"; "1"] 
</pre>
<p>And even if we try to slightly abuse type system and mix different boxed types (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">reverse [box 1.0; box 2.0M; box 3I] 
//val it : obj list = [3 {IsEven = false; 
//                        IsOne = false; 
//                        IsPowerOfTwo = false; 
//                        IsZero = false; 
//                        Sign = 1;}; 2.0M; 1.0] 
</pre>
<p>The <code class="literal">reverse</code>
 function behaves as genuinely generic with regard to the type of argument list elements.</p>
<p>Fine, now let's do something seemingly similar and also utterly simple, such as shifting the argument to the left by a single bit (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">let twice x  = x &lt;&lt;&lt; 1 
</pre>
<p>All of a sudden, the F# compiler infers the very specific <code class="literal">twice : x:int -&gt; int</code>
 function signature. What's going on? Apparently, there are some types that allow this geeky way of making the value twice as big, for example, <code class="literal">int64</code>
 . Interestingly, let's look at what happens when we follow the function definition by the usage, as following (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">let twice x = x &lt;&lt;&lt; 1 
twice 10L 
//val twice : x:int64 -&gt; int64 
//val it : int64 = 20L 
</pre>
<p>Now the F# compiler has seemingly changed its mind about the signature of the <code class="literal">twice</code>
  function, this time inferring the argument and result types as <code class="literal">int64</code>
 . This action is irreversible, which means that trying to follow the preceding evaluation with <code class="literal">twice 10</code>
 will be now rejected with this diagnostics: <span class="emphasis">
<em>this expression was expected to have type</em>
</span>
 <code class="literal">int64</code>
  <span class="emphasis">
<em>but it has type</em>
</span>
 <code class="literal">int</code>
  <span class="emphasis">
<em>here</em>
</span>
 .</p>
<p>What's going on? Why does the generalization seemingly fail?</p>
<div class="section" title="Statically resolved type parameters">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch10lvl2sec111"/>
 Statically resolved type parameters</h2>
</div>
</div>
</div>
<p>As we just noticed, the F# compiler inferred a monomorphic type for the (<code class="literal">&lt;&lt;&lt;</code>
 ) operator. A step toward polymorphism would assume the ability to express it somehow - while staying within the .NET type system that only such types are fine to be <code class="literal">twice</code>
 argument that work with the operator (<code class="literal">&lt;&lt;&lt;</code>
 ). In other words, the compiler should deal with a <span class="strong">
<strong>type constraint</strong>
</span>
 .</p>
<p>The problem is that this kind of constraint cannot be expressed within the F# compilation target language <span class="strong">
<strong>MSIL</strong>
</span>
 . That is, the latest <span class="strong">
<strong>.NET CLI standard</strong>
</span>
 (<a class="ulink" href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf</a>
 ) in the <span class="emphasis">
<em>II.10.1.7 Generic Parameters</em>
</span>
 section constraints a type either by being a <span class="strong">
<strong>value type</strong>
</span>
 or a <span class="strong">
<strong>reference type</strong>
</span>
 for a concrete reference type that has the <span class="strong">
<strong>default constructor</strong>
</span>
 . This is the problem of the .NET type system rather than the F# language or compiler.</p>
<p>
<span class="strong">
<strong>F# 4.0 Language Specification</strong>
</span>
 (<a class="ulink" href="http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf">http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf</a>
 ) hints at the observed compiler behavior in section <span class="emphasis">
<em>5.2.3</em>
</span>
 :</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>Uses of overloaded operators do not result in generalized code unless definitions are marked as inline. For example, take a look at the function as shown here:</em>
</span>
 <code class="literal">let f x = x + x</code>
</p>
<p>
<span class="emphasis">
<em>It results in an f function, which can be used only to add one type of value, such as int or float. The exact type is determined by later constraints</em>
</span>
 .</p>
</blockquote>
</div>
<p>Fortunately, the F# compiler may enforce these (and some other) type of constraints at compile-time using the mechanism of <span class="strong">
<strong>statically resolved type parameters</strong>
</span>
 . This type parameter for our (<code class="literal">&lt;&lt;&lt;</code>
 ) operator will have the special "hat" prefix <code class="literal">^a</code>
 , assuming that the type is statically known at the point of compilation (compared to <code class="literal">'a</code>
 , assuming that the type can be anything). As this kind of statically polymorphic function would require a specific manner of compilation depending on the concrete statically resolved type that is aligned with constraints, the F# compiler achieves this goal with the help of <span class="strong">
<strong>inlining</strong>
</span>
 , as the language specification has hinted.</p>
</div>
<div class="section" title="Function inlining">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch10lvl2sec112"/>
 Function inlining</h2>
</div>
</div>
</div>
<p>Let me apply the inlining mechanism to this failing <code class="literal">twice</code>
 function as shown here (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">let inline twice' x = x &lt;&lt;&lt; 1 
// val inline twice' : 
//     x: ^a -&gt;  ^a when 
//        ^a : (static member ( &lt;&lt;&lt; ) :  ^a * int32 -&gt;  ^a) 
</pre>
<p>Note how the automatically inferred signature of the inlined <code class="literal">twice'</code>
 function carries the <span class="strong">
<strong>hat</strong>
</span>
 type <code class="literal">^a</code>
 along with the sought-for constraint regarding the type parameter statically resolved at compile-time: type <code class="literal">^a</code>
 must have an operator (<code class="literal">&lt;&lt;&lt;</code>
 ) with the <code class="literal">^a * int32 -&gt; ^a</code>
 signature.</p>
<p>Great, now <code class="literal">twice'</code>
 begins to look like a polymorphic function, allowing, for example, the following evaluations (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">twice' 5    // int32 argument 
twice' 5u   // uint32 argument 
twice' 5L   // int64 argument 
twice' 5UL  // uint64 argument 
twice' 5y   // sbyte argument 
twice' 5uy  // byte argument 
twice' 5s   // int16 argument 
twice' 5us  // uint16 argument 
twice' 5I   // biginteger argument 
twice' 5n   // nativeint argument 
</pre>
<p>At the same time, it disallows the following evaluations (<code class="literal">Ch10_1.fsx</code>
 ):</p>
<pre class="programlisting">twice' 5m //The type 'decimal' does not support the operator '&lt;&lt;&lt;' 
twice' 5.0 // The type 'float' does not support the operator '&lt;&lt;&lt;' 
twice' "5"// The type 'string' does not support the operator '&lt;&lt;&lt;' 
twice' '5' // The type 'char' does not support the operator '&lt;&lt;&lt;' 
</pre>
<p>The compiler has provided all the above niceties after we merely added the <code class="literal">inline</code>
 qualifier to the function definition. But you should realize that the compiler literally injects the inlined function implementation into MSIL adjusting it for argument(s) having statically resolved concrete types. Inlining is the compilation method that allows to alleviate .NET CLR limitations.</p>
</div>
<div class="section" title="Static constraints">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_4"><a id="ch10lvl2sec113"/>
 Static constraints</h2>
</div>
</div>
</div>
<p>As it was inferred by the F# compiler for the <code class="literal">twice'</code>
 function earlier, the argument <code class="literal">x</code>
 can be any type <code class="literal">^a</code>
 as long as <code class="literal">^a : (static member (&lt;&lt;&lt;) : ^a * int32 -&gt; ^a).</code>
 This condition, either inferred by the F# compiler or, perhaps, intentionally imposed by the programmer is named a <span class="strong">
<strong>static constraint</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D</a>
 ). There are about a dozen of argument type constraint kinds. You may check the <span class="strong">
<strong>documentation</strong>
</span>
 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints</a>
 ) for their complete list.</p>
<p>Constraints can be combined together with the help of the <code class="literal">and</code>
 construction, as shown in the following code snippet (<code class="literal">Ch10_2.fsx</code>
 ):</p>
<pre class="programlisting">let inline constrained (param: ^a 
    when ^a: equality and ^a: comparison) = () 
 
type Good = Good 
 
[&lt;NoEquality; NoComparison&gt;]type Bad = Bad 
 
Good |&gt; constrained 
// Compiles just fine 
Bad |&gt; constrained 
// Error: type Bad does not support comparison constraint 
</pre>
<p>We have two discriminated unions here: <code class="literal">Good</code>
 , which is <span class="strong">
<strong>equitable</strong>
</span>
 and <span class="strong">
<strong>comparable</strong>
</span>
 by default, and <code class="literal">Bad</code>
 , which is also normally equitable and comparable, but here it is decorated with <code class="literal">[&lt;NoEquality; NoComparison&gt;]</code>
 attributes. As the <code class="literal">constrained</code>
 function requires its generic <code class="literal">param</code>
 argument to be of both equitable and comparable types, <code class="literal">constrained Good</code>
 gets compiled, while <code class="literal">constrained Bad</code>
 does not.</p>
</div>
<div class="section" title="Explicit or inferred constraining?">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_5"><a id="ch10lvl2sec114"/>
 Explicit or inferred constraining?</h2>
</div>
</div>
</div>
<p>A few years ago, I was tinkering with creating F# generic code. At that time, my thinking was along these lines: if I need to create a generic function that can deal with a restricted handful of argument types, the right approach would be to appropriately and explicitly constrain the latter. I even asked on <span class="strong">
<strong>StackOverflow</strong>
</span>
 (<a class="ulink" href="http://stackoverflow.com/q/16737675/917053">http://stackoverflow.com/q/16737675/917053</a>
 ) what the idiomatic approach would be. <span class="strong">
<strong>One of the answers</strong>
</span>
 (<a class="ulink" href="http://stackoverflow.com/a/16738811/917053">http://stackoverflow.com/a/16738811/917053</a>
 ) I want to quote here:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>Explicit constraints are a way of stating <span class="emphasis">
<em>what you want to do</em>
</span>
 . What could be better than <span class="emphasis">
<em>doing it</em>
</span>
 and having the compiler statically prove that the argument is valid for the operations?</em>
</span>
</p>
</blockquote>
</div>
<p>Enlightening observation, isn't it?</p>
<p>Nevertheless, what if you still want to explicitly limit the list of generic functions' valid argument types based on some external considerations? Then, you may use the following approach I was hinted at in <span class="strong">
<strong>the other answer</strong>
</span>
 (<a class="ulink" href="http://stackoverflow.com/a/16739483/917053">http://stackoverflow.com/a/16739483/917053</a>
 ) to my StackOverflow question, which is based on overloading static methods of the auxiliary type (<code class="literal">Ch10_2.fsx</code>
 ):</p>
<pre class="programlisting">[&lt;AutoOpen&gt;] 
module Restrict = 
    let inline private impl restricted = 
        printfn "%s type is OK" (restricted.GetType().FullName) 
 
    type Restricting = Restrict with 
        static member ($) (Restrict, value: byte) = impl value 
        static member ($) (Restrict, value: sbyte) = impl value 
        static member ($) (Restrict, value: int) = impl value 
        static member ($) (Restrict, value: uint32) = impl value 
        static member ($) (Restrict, value: bigint) = impl value 
 
    let inline doit restricted = Restrict $ restricted 
</pre>
<p>There are three components in the preceding snippet:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">The <span class="strong">
<strong>private</strong>
</span>
 function, <code class="literal">impl</code>
 , which performs a required action on a generic restricted argument of type <code class="literal">'a</code>
 ; in other words, upon an argument that's not constrained whatsoever</li>
<li class="listitem">The auxiliary type <code class="literal">Restricting</code>
 , which has a single discriminated union case, <code class="literal">Restrict</code>
 , augmented by the overloaded static member <code class="literal">$</code>
 upon the required set of types (<code class="literal">byte</code>
 , <code class="literal">sbyte</code>
 , <code class="literal">int</code>
 , <code class="literal">uint32</code>
 , <code class="literal">bigint</code>
 picked just for the sake of illustration)</li>
<li class="listitem">The user-facing function <code class="literal">doit</code>
 , whose restricted argument has been statically constrained by the other two pieces</li>
</ul>
</div>
<p>Let's look at the workings of the preceding in the following script (<code class="literal">Ch10_2.fsx</code>
 ):</p>
<pre class="programlisting">doit 1uy 
doit 1y 
doit 1 
doit 1u 
doit 1I 
doit 1L // does not compile 
doit 1.0 // does not compile 
doit 1.0m // does not compile 
doit '1' // does not compile 
</pre>
<p>The first five use cases matching the restricted types compile just fine; the last four do not compile with the same diagnostics as expected:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>no overloads match the <code class="literal">op_Dollar"</code>
 method</em>
</span>
</p>
</blockquote>
</div>
<p>The successful execution of the first five use cases is presented in the following screenshot:</p>
<div class="mediaobject"><img src="Image00048.jpg" alt="Explicit or inferred constraining?"/>
<div class="caption">
<p>Executing explicitly constrained generic code</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
<div class="section" title="Inlining scope">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_6"><a id="ch10lvl2sec115"/>
 Inlining scope</h2>
</div>
</div>
</div>
<p>Inlining in F# is not limited to just module-level functions. It is perfectly fine to use inlining for static and instance methods of F# types. For example, in the following snippet, where we have type <code class="literal">Bar</code>
 with a static method <code class="literal">doIt</code>
 and <code class="literal">type Foo</code>
 on any generic type <code class="literal">^T</code>
 that has static member <code class="literal">doIt</code>
 with the matching signature and the <code class="literal">inline</code>
 member <code class="literal">Invoke</code>
 calling the <code class="literal">doIt</code>
 method of <code class="literal">^T</code>
 as shown here (<code class="literal">Ch10_2.fsx</code>
 ):</p>
<pre class="programlisting">type Bar() = 
  static member doIt() = 42 
 
type Foo&lt; ^T when ^T: (static member doIt: unit -&gt; int)&gt;(data: ^T []) = 
  member inline this.Invoke () = (^T : (static member doIt : unit -&gt; int) ()) 
 
let result = (Foo([|Bar()|]).Invoke()) 
// val result : int = 42 
</pre>
<p>An intricate matter that the preceding sample illustrates is accessing static or instance <code class="literal">inline</code>
 methods from outside of F# using, for example, a plain C# -&gt; F# interoperability scenario. Remember that normal MSIL cannot support such constraints.</p>
<p>To address this subtlety the compiled MSIL for <code class="literal">Invoke</code>
 method implementation above that C# may access just throws an exception. The actual inlined body of the function is kept accessible only from F# in its assembly's metadata.</p>
</div>
<div class="section" title="Inline optimizations">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_7"><a id="ch10lvl2sec116"/>
 Inline optimizations</h2>
</div>
</div>
</div>
<p>The relationship between inlining and code optimization is quite subtle. Usually, it is difficult to predict what consequences of generalization via inlining would be.</p>
<p>However, sometimes, it is possible to achieve tremendous performance improvements via inlining. A notorious example is the F# handling of the <code class="literal">System.DateTime</code>
 equality, where the compilation of the <code class="literal">datetime1 = datetime2</code>
 expression involves boxing. Take a look at the following snippet (<code class="literal">Ch10_2.fsx</code>
 ):</p>
<pre class="programlisting">open System 
#time "on" 
let x, y = DateTime.MinValue, DateTime.MaxValue 
for i = 0 to 10000000 do x = y |&gt; ignore 
//Real: 00:00:00.421, CPU: 00:00:00.406, GC gen0: 115, gen1: 2, gen2: 1 
</pre>
<p>Here, using just the <code class="literal">=</code>
 operator, we observe a certain garbage collection activity.</p>
<p>However, suppose we just inline the redefined equality operator, <code class="literal">==</code>
 , as shown in the following snippet (<code class="literal">Ch10_2.fsx</code>
 ):</p>
<pre class="programlisting">open System 
#time "on" 
let inline eq&lt;'a when 'a :&gt; IEquatable&lt;'a&gt;&gt; (x:'a) (y:'a) = x.Equals y 
let inline (==) x y = eq x y 
for i = 0 to 10000000 do x == y |&gt; ignore 
//Real: 00:00:00.022, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0 
</pre>
<p>Then, we achieve no garbage collection activity whatsoever and an impressive <span class="emphasis">
<em>19(!)</em>
</span>
 times better performance.</p>
</div>
<div class="section" title="Writing generic code">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_8"><a id="ch10lvl2sec117"/>
 Writing generic code</h2>
</div>
</div>
</div>
<p>I would like to wrap up the theme of writing generic code with just another example of a non-trivial generic function that I have implemented as a <span class="strong">
<strong>sample for a "functional programming" interview</strong>
</span>
 (<a class="ulink" href="https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/">https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/</a>
 ): given an arbitrary positive number, find a next higher number consisting of the same digits. If that does not exist, then return the original number.</p>
<p>We will approach the solution as a generic function, allowing the argument to be of any integral type, or anything consisting of just digits, be it <code class="literal">byte</code>
 , <code class="literal">BigInteger</code>
 , or <code class="literal">nativeint</code>
 .</p>
<p>The base line approach would be to split the number into a list of digits, making the list of all digit permutations, assembling digits back into numbers, sorting the list of numbers, and finally, picking the element next to the given argument. Apparently, the time and space complexities of this "solution" are awful, so let's improve it:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">The first useful observation of the optimized solution would be that the solution exists if a pair of adjacent digits exists in the given number, where the left-hand side is strictly less than the right-hand side.</li>
<li class="listitem">The next useful observation would be that if we scan the list of digits of the given number from right to left by a sliding window of width 2, then the first pair that matches the first observation would be the place of change. Everything to the left of it (if any exists) must stay intact.</li>
<li class="listitem">The final useful observation is to take the pair that matches the second observation. The sublist to the right including the right element of the pair is sorted from right to left. The digit that must substitute the left element of the pair must be the minimally greater digit from the sublist. The left element that we just substituted should be placed some place to the right, preserving the sublist order.</li>
</ul>
</div>
<p>Now, if we concatenate (if nonempty) the sublist to the left of the changing digit, followed by the substituting digit, followed by the reversed sublist after accommodating the changing digit and convert the resulting digit list to the number, this would yield the solution with a surprisingly good time complexity of <code class="literal">O(n)</code>
 and a space complexity of <code class="literal">O(n)</code>
 , where n is the number of digits in the original number. The solution snippet is as follows (<code class="literal">Ch10_3.fsx</code>
 ):</p>
<pre class="programlisting">let inline nextHigher number = 
    let g0 = LanguagePrimitives.GenericZero&lt;'a&gt; 
    let g1 = LanguagePrimitives.GenericOne&lt;'a&gt; 
    let g10 = (g1 &lt;&lt;&lt; 3) + (g1 &lt;&lt;&lt; 1) 
 
    let toDigits n = 
        let rec toDigitList digits n = 
            if n = g0 then digits 
            else toDigitList ((n % g10) :: digits) (n / g10) 
        toDigitList [] n 
 
    let fromDigits digits = 
        let rec fromDigitList n = function 
            | [] -&gt; n 
            | h::t -&gt; fromDigitList (n * g10 + h) t 
        fromDigitList g0 digits 
 
    let make p ll  = 
        ll |&gt; List.rev |&gt; List.partition ((&lt;) p) 
        |&gt; fun (x,y) -&gt; (x.Head::y) @ (p::(x.Tail)) 
 
    let rec scan (changing: 'a list) source = 
        match source with 
        | [] -&gt; changing 
        | h::t -&gt; if h &gt;= changing.Head then 
                    scan (h::changing) t 
                  else 
                    (List.rev t) @ (make h changing) 
 
    number |&gt; toDigits 
           |&gt; List.rev |&gt; fun x -&gt; scan [(x.Head)] (x.Tail) 
           |&gt; fromDigits 
</pre>
<p>Let's see this in action by running some usage cases via FSI as shown in the following screenshot:</p>
<div class="mediaobject"><img src="Image00049.jpg" alt="Writing generic code"/>
<div class="caption">
<p>Generic implementation of non-trivial function</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Take into account the complexity of the static constraint expression that the F# compiler has inferred for <code class="literal">nextHigher</code>
 , as shown in the preceding screenshot. It would be really challenging to come up with an expression that complicated from the top of your head. Let the compiler do its job indeed.</p>
</div>
</div>
</div>


<div class="section" title="Type augmentation">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch10lvl1sec64"/>
 Type augmentation</h1>
</div>
</div>
</div>
<p>The opposite of generalization is specialization, and it is associated with <span class="strong">
<strong>type augmentation</strong>
</span>
 in F#. It is worth noting that the official <span class="strong">
<strong>F# 4.0 Language Specification</strong>
</span>
 (<a class="ulink" href="http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf">http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf</a>
 ) does not introduce this terminology using <span class="strong">
<strong>type extension</strong>
</span>
 instead. Nevertheless, the <span class="emphasis">
<em>type augmentation</em>
</span>
 expression is de-facto ubiquitous and used interchangeably with <span class="emphasis">
<em>type extension</em>
</span>
 . Personally, I believe that <span class="emphasis">
<em>augmentation</em>
</span>
 is free of the undesired connotation that <span class="emphasis">
<em>extension</em>
</span>
 carries as something that's <span class="emphasis">
<em>added</em>
</span>
 to an existing matter. Augmentation is a better synonym for the <span class="emphasis">
<em>specialization</em>
</span>
 of an existing matter by adding, customizing, or even removing features. So we will stick to it here.</p>
<p>The following figure shows two flavors of type augmentation available in F#. Both use the same syntax but represent different use cases. Intrinsic augmentation customizes your own code, while optional augmentation may customize types outside of your code:</p>
<div class="mediaobject"><img src="Image00050.jpg" alt="Type augmentation"/>
<div class="caption">
<p>F# flavors of type augmentation</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>But why would you need to customize your own code in the first place? This is where certain F#-specific patterns of usage kick in. They can be spotted time and again both inside the F# core libraries and outside in third-party extensions. They explain how a bare type gets created first and then acquires an associated module that carries some helper functions and finally, how the type gets extended by some static methods. We can consider the <span class="strong">
<strong>definition of complex type</strong>
</span>
 (<a class="ulink" href="https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs">https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs</a>
 ) as a manifestation of this pattern:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">On <code class="literal">complex.fs</code>
  <span class="strong">
<strong>source line 13</strong>
</span>
 (<a class="ulink" href="https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L13">https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L13</a>
 ), the bare type <code class="literal">Complex</code>
 is defined as having custom <code class="literal">equality</code>
 and <code class="literal">comparison</code>
 properties and being the value type</li>
<li class="listitem">On <code class="literal">complex.fs</code>
  <span class="strong">
<strong>source line 39</strong>
</span>
 (<a class="ulink" href="https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L39">https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L39</a>
 ), the module <code class="literal">Complex</code>
 is defined as carrying the entire slew of helper functions covering, in particular, all math operations in complex numbers</li>
<li class="listitem">Finally, on <code class="literal">complex.fs</code>
  <span class="strong">
<strong>source line 99</strong>
</span>
 (<a class="ulink" href="https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L99">https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L99</a>
 ), type <code class="literal">Complex</code>
 is supplied by static operators for complex math numbers expressed via previously defined helper functions</li>
</ul>
</div>
<p>The preceding definition may be considered as a very neat template of idiomatic intrinsic augmentation.</p>
<p>Let me walk you through some typical use cases of augmenting types.</p>
<div class="section" title="Augment by removing">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch10lvl2sec118"/>
 Augment by removing</h2>
</div>
</div>
</div>
<p>At first glance, augment by removing may sound like an oxymoron. However, it is not; just bear with me. Take a look at the following code snippet (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">type Outcome = 
| Success 
| Failure 
with 
    member x.IsFailure = 
        match x with 
        | Failure -&gt; true 
        | _ -&gt; false 
    member x.IsSuccess = not x.IsFailure 
</pre>
<p>Here, my intent was to hide the pattern matching behind properties of the discriminated union type <code class="literal">Outcome</code>
 . However, suddenly, this seemingly innocuous piece of code does not compile, as the following screenshot shows:</p>
<div class="mediaobject"><img src="Image00051.jpg" alt="Augment by removing"/>
<div class="caption">
<p>F# DU implementation detail leaks out</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The F# compiler accompanies the red squiggle line under the <code class="literal">IsFailure</code>
 property name with a surprise message (refer to the preceding screenshot), prompting that the compiler also augments each <code class="literal">&lt;Name&gt;</code>
 use case of discriminated unions with the <code class="literal">Is&lt;Name&gt;</code>
 private property by default, and by defining the identically named property, we made this detail leak out.</p>
<p>Can we effectively remove default compiler-generated augmentation from the <code class="literal">Outcome</code>
 definition? It so happens that we can do that using the .NET attribute especially designated for this purpose: <span class="strong">
<strong>DefaultAugmentation</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d</a>
 ).</p>
<p>If we just decorate the <code class="literal">Outcome</code>
 type definition with the <code class="literal">[&lt;DefaultAugmentation(false)&gt;]</code>
 attribute, then everything gets back to the intuitively expected behavior, and the property name clash shown above vanishes.</p>
</div>
<div class="section" title="Augment by adding">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch10lvl2sec119"/>
 Augment by adding</h2>
</div>
</div>
</div>
<p>Now let me do quite the opposite and augment types by adding features. I'm going to use a real (simplified, of course) case from Jet.com technology practices.</p>
<p>Imagine that Jet's e-commerce platform supports the following transaction kinds (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">type Sale = 
    | DirectSale of decimal 
    | ManualSale of decimal 
 
type Refund = 
    | Refund of decimal 
</pre>
<p>When we aggregate these transactions for payment or analytics purposes, it is highly desired that you operate upon collections that represent any mix of valid transactions. But we cannot mix different types in a typed collection, can we?</p>
<p>The naive brute-force approach might be exploiting the fact that any .NET type is a subtype of <code class="literal">System.Object.</code>
 So, the following collection might be perfectly OK (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">let ll: obj list = [box (DirectSale 10.00M); box (Refund -3.99M)] 
</pre>
<p>However, this approach wipes out one of the major benefits of F#, namely static type safety, which means that unfortunately, having the following collection is also perfectly OK from the standpoint of the F# compiler:</p>
<pre class="programlisting">let ll': obj list = [box (Refund -3.99M); box 1; box "Anything"] 
</pre>
<p>A hardcore OOP developer would continue to lean on inheritance, introducing something like the <code class="literal">Transaction</code>
 superclass as shown here (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">type Transaction = 
  | Sale of Sale 
  | Refund of Refund 
 
let ll: Transaction list = [Sale (DirectSale 5.00M); Sale (ManualSale 5.00M); Refund (Refund.Refund -1.00M)] 
</pre>
<p>This is an acceptable approach, but it's not flexible from the standpoint of potential future extensions. Also it is awkward overall.</p>
<p>Any other ideas? Yes, type augmentation comes to the rescue! Well, in a sense.</p>
<p>Let me define a dummy <span class="strong">
<strong>marker interface </strong>
</span>
 <code class="literal">ITransaction</code>
 , as following:</p>
<pre class="programlisting">type ITransaction = interface end 
</pre>
<p>Now, unfortunately, F# does not allow you to add an interface to an already defined type later. But we can still define our transactions, augmenting the standard DU as following (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">type Sale = 
    | DirectSale of decimal 
    | ManualSale of decimal 
    interface ITransaction 
 
type Refund = 
    | Refund of decimal 
    interface ITransaction 
</pre>
<p>Furthermore, we can use the idiomatic trick with F# supporting function contravariant arguments:</p>
<pre class="programlisting">let mixer (x: ITransaction) = x 
</pre>
<p>Now we can represent the sought-for collection as following:</p>
<pre class="programlisting">let ll: list&lt;_&gt; = [mixer(DirectSale 10.00M); mixer(Refund -3.99M)] 
</pre>
<p>So far, so good. Now <code class="literal">ll</code>
 is strongly typed <code class="literal">ITransaction</code>
 list, but it can carry any current (and future, if required) transaction kinds. Having the latter mixed together is not a big deal if a disassembly back to concrete transactions is needed, as following (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">#nowarn "25" 
 
let disassemble (x: ITransaction) = 
    match x with 
    | :? Sale as sale -&gt; (function DirectSale amount -&gt; (sprintf 
"%s%.2f" "Direct sale: " amount, amount) 
    | ManualSale amount -&gt; (sprintf "%s%.2f" "Manual sale: " amount,
amount)) sale 
    | :? Refund as refund -&gt; (function Refund amount -&gt; (sprintf
"%s%.2f" "Refund: " amount, amount)) refund 
</pre>
<p>(The cryptic turning off the compiler warning "25" in the beginning of the above script addresses the manner the matching by type works. The F# compiler assumes that it may be more types "implementing" <code class="literal">ITransaction</code>
 than are included into preceding <code class="literal">match</code>
 expression. I know that I covered all cases there, so the warning would be just a noise.)</p>
<p>Equipped with this machinery, it is easy to perform, for example, an aggregation of a list of concrete transactions in a single payment (<code class="literal">Ch10_4.fsx</code>
 ):</p>
<pre class="programlisting">[mixer(DirectSale 4.12M);mixer(Refund -0.10M);mixer(ManualSale 3.62M)] 
|&gt; List.fold (fun (details, total) transaction -&gt; 
    let message, amount = disassemble transaction in 
    (message::details, total + amount)) 
    ([],0.00M) 
|&gt; fun (details,total) -&gt; 
    (sprintf "%s%.2f" "Total: " total) :: details 
|&gt; List.iter (printfn "%s") 
</pre>
<p>Running the preceding script in FSI will produce the results shown in the following screenshot:</p>
<div class="mediaobject"><img src="Image00052.jpg" alt="Augment by adding"/>
<div class="caption">
<p>Augmenting DU with the marker interface</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch10lvl1sec65"/>
 Summary</h1>
</div>
</div>
</div>
<p>This chapter demonstrated how to approach matters of code generalization and/or specialization in situations when such adjustments are appropriate.</p>
<p>In the next chapter, we will just scratch the surface of the advanced F# patterns, as their detailed coverage may require another book.</p>
</div>
</body></html>