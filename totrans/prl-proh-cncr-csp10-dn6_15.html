<html><head></head><body>
<div><div><h1 id="_idParaDest-187"><em class="italic"><a id="_idTextAnchor186"/>Chapter 12</em>: Unit Testing Async, Concurrent, and Parallel Code</h1>
<p>Unit testing asynchronous, concurrent, and parallel code can be a challenge for .NET developers. Fortunately, there are some steps you can take to help ease the difficulty. This chapter will provide some concrete advice and useful examples of how developers can unit test code that leverages multi-threaded constructs. These examples will illustrate how unit tests can still be reliable while covering code that performs multithreaded operations. In addition, we will explore a third-party tool that facilitates the creation of automated unit tests that monitor your code for potential memory leaks.</p>
<p>Creating unit tests for your .NET projects is important to maintain the health of your code base as it grows and evolves. When developers make changes to code that has unit test coverage, they can run the existing tests to feel confident that no existing functionality has been broken by the code changes. Visual Studio makes it simple to create, run, and maintain unit test projects throughout the life cycle of your code. </p>
<p>The <strong class="bold">Test Explorer</strong> window in Visual Studio can detect and run unit tests created with Microsoft’s MSTest framework, as well as third-party frameworks such as NUnit and xUnit.net. Whether you are developing applications for Windows, mobile devices, or the cloud, you should always plan to develop a suite of unit tests for your projects and define goals for test coverage.</p>
<p class="callout-heading">Note</p>
<p class="callout">This chapter assumes that you have some familiarity with unit testing and good unit testing practices. For a good primer on unit testing projects with xUnit.net, you can review Microsoft’s documentation at <a href="https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test">https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test</a> and at <a href="https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing">https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing</a>.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Unit testing asynchronous code</li>
<li>Unit testing concurrent code</li>
<li>Unit testing parallel code</li>
<li>Checking for memory leaks with unit tests</li>
</ul>
<p>By the end of this chapter, you will be armed with tools and advice to help you confidently write modern multithreaded code with unit test coverage.</p>
<p class="callout-heading">Note</p>
<p class="callout">The unit tests in this chapter are created with<a id="_idIndexMarker617"/> the <strong class="bold">xUnit.net</strong> unit testing framework. You<a id="_idIndexMarker618"/> can achieve the same results with your unit testing framework of choice, including <strong class="bold">MSTest</strong> and <strong class="bold">NUnit</strong>. The<a id="_idIndexMarker619"/> memory unit testing framework we will be demonstrating later in this chapter uses xUnit.net, but it also supports MSTest and NUnit.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.2 or later</li>
<li>.NET 6</li>
<li>A JetBrains dotMemory Unit standalone console runner</li>
</ul>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12</a>.</p>
<p>Let’s get started by examining how to write unit tests that cover <code>async</code> C# methods.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Unit testing asynchronous code</h1>
<p>Unit testing<a id="_idIndexMarker620"/> asynchronous code requires the same<a id="_idIndexMarker621"/> approach as writing good asynchronous C# code. If you need a refresher on how to work with <code>async</code> methods, you can review <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<p>When writing <a id="_idIndexMarker622"/>a unit test for an <code>async</code> method, you will use the <code>await</code> keyword to wait for the method to complete. This requires that your unit test method is <code>async</code> and returns <code>Task</code>. Just like other C# code, creating <code>async void</code> methods <a id="_idIndexMarker623"/>is not permitted. Let’s look at a very simple test method:</p>
<pre class="source-code">[Fact]</pre>
<pre class="source-code">private async Task GetBookAsync_Returns_A_Book()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    // Arrange</pre>
<pre class="source-code">    BookService bookService = new();</pre>
<pre class="source-code">    var bookId = 123;</pre>
<pre class="source-code">    // Act</pre>
<pre class="source-code">    var book = await bookService.GetBookAsync(bookId);</pre>
<pre class="source-code">    // Assert</pre>
<pre class="source-code">    Assert.NotNull(book);</pre>
<pre class="source-code">    Assert.Equal(bookId, book.Id);</pre>
<pre class="source-code">}</pre>
<p>This probably looks like most tests you have written for synchronous code. There are only a couple of differences: </p>
<ul>
<li>First, the test method is <code>async</code> and returns <code>Task</code>.</li>
<li>Second, the call to <code>GetBookAsync</code> uses the <code>await</code> keyword to wait for the result. Otherwise, this test follows the<a id="_idIndexMarker624"/> typical <strong class="bold">Arrange–Act–Assert</strong> pattern and tests the result as you typically would. </li>
</ul>
<p>Let’s create a simple project to try this in Visual Studio and see the results:</p>
<ol>
<li>Start by creating a new <code>AsyncUnitTesting</code>:</li>
</ol>
<div><div><img alt="Figure 12.1 – Creating a new Class Library project " height="1066" src="img/Figure_12.1_B18552.jpg" width="1628"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Creating a new Class Library project</p>
<ol>
<li value="2">Next, we<a id="_idIndexMarker625"/> are<a id="_idIndexMarker626"/> going to add a test project to the <code>AsyncUnitTesting.Tests</code>:</li>
</ol>
<div><div><img alt="Figure 12.2 – Adding an xUnit Test project to the solution " height="1075" src="img/Figure_12.2_B18552.jpg" width="1644"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Adding an xUnit Test project to the solution</p>
<ol>
<li value="3">In<a id="_idIndexMarker627"/> the <code>BookOrderService.cs</code>. When Visual Studio asks whether you want to rename all uses of <code>Class1</code>, select <strong class="bold">Yes</strong>.</li>
<li>Open the <code>BookOrderService</code> class and add an <code>async</code> method named <code>GetCustomerOrdersAsync</code>:<pre>public async Task&lt;List&lt;string&gt;&gt; 
    GetCustomerOrdersAsync(int customerId)
{
    if (customerId &lt; 1)
    {
        throw new ArgumentException("Customer ID must 
            be greater than zero.", nameof
                (customerId));
    }
    var orders = new List&lt;string&gt;
    {
        customerId + "1",
        customerId + "2",
        customerId + "3",
        customerId + "4",
        customerId + "5",
        customerId + "6"
    };
    // Simulate time to fetch orders
    await Task.Delay(1500);
    return orders;
}</pre></li>
</ol>
<p>This<a id="_idIndexMarker629"/> method takes <code>customerId</code> as a parameter <a id="_idIndexMarker630"/>and returns <code>List&lt;string&gt;</code> containing the order numbers. If <code>customerId</code> provided is less than <code>1</code>, <code>ArgumentException</code> is thrown. Otherwise, a list of six order numbers is created, with <code>customerId</code> as the prefix. After injecting <code>Task.Delay</code> of <code>1500</code> milliseconds, <code>orders</code> is returned to the calling method.</p>
<ol>
<li value="5">Next, right-click the <strong class="bold">AsyncUnitTesting.Tests</strong> project and click on <strong class="bold">Add</strong> |<strong class="bold"> Project Reference</strong>. In the <strong class="bold">Reference Manager</strong> dialog, check the box for the <strong class="bold">AsyncUnitTesting</strong> project and click <strong class="bold">OK</strong>.</li>
<li>Now, rename the <code>UnitTest1</code> class <code>BookOrderServiceTests</code> and open the file in the Visual Studio editor.</li>
<li>It’s time to<a id="_idIndexMarker631"/> start adding tests. Let’s start by testing the <a id="_idIndexMarker632"/>happy path. Add a test method named <code>GetCustomerOrdersAsync_Returns_Orders_For_Valid_CustomerId</code>:<pre>[Fact]
public async Task GetCustomerOrdersAsync_Returns_
    Orders_For_Valid_CustomerId()
{
    var service = new BookOrderService();
    int customerId = 3;
    var orders = await service.GetCustomerOrdersAsync
        (customerId);
    Assert.NotNull(orders);
    Assert.True(orders.Any());
    Assert.StartsWith(customerId.ToString(), 
        orders[0]);
}</pre></li>
</ol>
<p>After calling <code>GetCustomerOrdersAsync</code> with <code>customerId</code> of <code>3</code>, our code has three assertions: </p>
<ul>
<li>First, we’re checking that the list of orders is not <code>null</code>. </li>
<li>Second, we’re checking that the list contains some items.</li>
<li>Finally, we check that the first order starts with <code>customerId</code>.</li>
</ul>
<ol>
<li value="8">Click on <strong class="bold">Test</strong> | <strong class="bold">Run All Tests</strong> to ensure that this test passes.</li>
<li>Let’s write that same test with a new <code>customerId</code> but without <code>async</code> and <code>await</code>. Assume <a id="_idIndexMarker633"/>that you have some legacy test code that just cannot be refactored, and <a id="_idIndexMarker634"/>you have to test the <code>GetCustomerOrdersAsync</code> method. That code would look like this:<pre>[Fact]
public void GetCustomerOrdersAsync_Returns_Orders
    _For_Valid_CustomerId_Sync()
{
    var service = new BookOrderService();
    int customerId = 5;
    List&lt;string&gt; orders = service.GetCustomer
        OrdersAsync(customerId).GetAwaiter()
            .GetResult();
    Assert.NotNull(orders);
    Assert.True(orders.Any());
    Assert.StartsWith(customerId.ToString(), 
        orders[0]);
}</pre></li>
</ol>
<p>The test method is not <code>async</code> and returns <code>void</code>. Instead of using <code>await</code> to allow <code>GetCustomerOrdersAsync</code> to run to completion, we are calling <code>GetAwaiter().GetResult()</code>. The setup and assertion sections of the code remain the same.</p>
<ol>
<li value="10">Click on <strong class="bold">Test</strong> | <strong class="bold">Run All Tests</strong> to make sure both of our tests are <em class="italic">green</em> (passing).</li>
<li>Finally, we are going to test the exception case. Create another test but pass a negative <code>customerId</code> to the method under test. The entire call to <code>GetCustomerOrdersAsync</code> will be wrapped in an <code>Assert.ThrowsAsync&lt;ArgumentException&gt;</code> invocation:<pre>[Fact]
public async Task GetCustomerOrdersAsync_
    Throws_Exception_For_Invalid_CustomerId()
{
    var service = new BookOrderService();
    await Assert.ThrowsAsync&lt;ArgumentException&gt;(async 
        () =&gt; await service.GetCustomerOrdersAsync
            (-2));
}</pre></li>
<li>Execute <strong class="bold">Run All Tests</strong> one<a id="_idIndexMarker635"/> last time and ensure that they are all passing:</li>
</ol>
<div><div><img alt="Figure 12.3 – Viewing three passing tests in Test Explorer " height="451" src="img/Figure_12.3_B18552.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Viewing three passing tests in Test Explorer</p>
<p>We now<a id="_idIndexMarker636"/> have three passing unit tests for the <code>GetCustomerOrdersAsync</code> method. The first two are essentially testing the same thing, but they are demonstrating two different ways of writing the test. You will be using the <code>async</code> method in most cases. The final test provides test coverage of the code that throws <code>ArgumentException</code>. If you are using Visual Studio Enterprise edition or a third-party tool such as dotCover, you can use their visualization tools to view which parts of your code are covered by unit tests and which are not.</p>
<p>Now that we have some familiarity with testing <code>async</code> methods, let’s move on to working with concurrent data structures in a system under test.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Unit testing concurrent code</h1>
<p>In this<a id="_idIndexMarker637"/> section, we will adapt a sample from <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, to add unit test coverage. When your code uses <code>async</code> and <code>await</code>, adding reliable test coverage is very simple. At the end of the example, we will examine an alternative method of waiting to perform your <a id="_idIndexMarker638"/>assertions by using the <code>SpinLock</code> struct.</p>
<p>Let’s create an xUnit.net unit test project for the <code>ConcurrentOrderQueue</code> project and add several tests:</p>
<ol>
<li value="1">Start by copying the <strong class="bold">ConcurrentOrderQueue</strong> project from <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>. You can get the source code from the GitHub repository if you do not already have a copy of it: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue</a>.</li>
<li>Open the <strong class="bold">ConcurrentOrderQueue</strong> solution in Visual Studio.</li>
<li>Right-click the solution file in <code>ConcurrentOrderQueue.Tests</code>. Make sure to add the new project inside the <strong class="bold">ConcurrentOrderQueue</strong> folder.</li>
<li>If your new test project also appears as a folder under the <strong class="bold">ConcurrentOrderQueue</strong> project, right-click on the <strong class="bold">ConcurrentOrderQueue.Tests</strong> folder and select <strong class="bold">Exclude from Project</strong>.</li>
<li>Add <code>UnitTest1</code> class <code>OrderServiceTests</code>.</li>
<li>In order to control which <code>CustomerId</code> values are used to generate the list of orders, we are going to create a new overload for the public <code>EnqueueOrders</code> method in the <code>OrderService</code> class:<pre>public async Task EnqueueOrders(List&lt;int&gt; customerIds)
{
    var tasks = new List&lt;Task&gt;();
    foreach (int id in customerIds)
    {
        tasks.Add(EnqueueOrders(id));
    }
    await Task.WhenAll(tasks);
}</pre></li>
</ol>
<p>This method takes a list of <code>customerId</code> and calls the private <code>EnqueueOrders</code> method for each of them, adding <code>Task</code> from each call to <code>List&lt;Task&gt;</code> to be <a id="_idIndexMarker639"/>awaited before exiting the method.</p>
<ol>
<li value="7">We <a id="_idIndexMarker640"/>can now optimize the parameterless version of <code>EnqueueOrders</code> by having it call this new overload:<pre>public async Task EnqueueOrders()
{
    await EnqueueOrders(new List&lt;int&gt; { 1, 2 });
}</pre></li>
<li>Create a new unit test method in the <code>OrderServiceTests</code> class to test <code>EnqueueOrders</code>:<pre>[Fact]
public async Task EnqueueOrders_Creates_Orders_For_
    All_Customers()
{
    var orderService = new OrderService();
    var orderNumbers = new List&lt;int&gt; { 2, 5, 9 };
    await orderService.EnqueueOrders(orderNumbers);
    var orders = orderService.DequeueOrders();
    Assert.NotNull(orders);
    Assert.True(orders.Any());
    Assert.Contains(orders, o =&gt; o.CustomerId == 2);
    Assert.Contains(orders, o =&gt; o.CustomerId == 5);
    Assert.Contains(orders, o =&gt; o.CustomerId == 9);
}</pre></li>
</ol>
<p>The test will call <code>EnqueueOrders</code> with three customer IDs. After <code>EnqueueOrders</code> and <code>DequeueOrders</code> are complete, we assert that the <code>orders</code> collection is not <code>null</code>, contains some orders, and contains orders with all three of our customer IDs.</p>
<ol>
<li value="9">Run the new test and ensure that it passes.</li>
</ol>
<p>This<a id="_idIndexMarker641"/> covers <a id="_idIndexMarker642"/>the basics of working with a system under test that uses <code>ConcurrentQueue</code>. Let’s consider another scenario where we are working with code but cannot use <code>async</code> and <code>await</code> in our tests. Perhaps the method under test is not <code>async</code>. One of the tools at our disposal is the <code>SpinWait</code> struct. This struct contains some methods that provide non-locking mechanisms for waiting in our code. We will use <code>SpinWait.WaitUntil()</code> to wait until all orders have been enqueued.</p>
<p>The following steps will demonstrate how to reliably test the result of a method when you cannot explicitly wait for it to complete:</p>
<ol>
<li value="1">Start by adding a new public variable to the <code>OrderService</code> class to expose the number of customers whose orders have been enqueued:<pre>public int EnqueueCount = 0;</pre></li>
<li>Next, increment <code>EnqueueCount</code> at the end of the private <code>EnqueueOrders</code> method:<pre>private async Task EnqueueOrders(int customerId)
{
    for (int i = 1; i &lt; 6; i++)
    {
        ...
    }
    <strong class="bold">EnqueueCount++;</strong>
}</pre></li>
<li>Now, create an <code>EnqueueOrdersSync</code> public method to be called from our new test. It <a id="_idIndexMarker643"/>will be similar to the public <code>EnqueueOrders</code> method. The differences between the previous example and this one are <a id="_idIndexMarker644"/>that it is not <code>async</code>, it resets <code>EnqueueCount</code> to <code>0</code>, and it does not wait for the tasks to be completed:<pre>public void EnqueueOrdersSync(List&lt;int&gt; customerIds)
{
    EnqueueCount = 0;
    var tasks = new List&lt;Task&gt;();
    foreach (int id in customerIds)
    {
        tasks.Add(EnqueueOrders(id));
    }
}</pre></li>
<li>Next, we <a id="_idIndexMarker645"/>will create a new synchronous test method to<a id="_idIndexMarker646"/> test <code>EnqueueOrdersSync</code>:<pre>[Fact]
public <strong class="bold">void</strong> EnqueueOrders_Creates_Orders_For_All
    _Customers_SpinWait()
{
    var orderService = new OrderService();
    var orderNumbers = new List&lt;int&gt; { 2, 5, 9 };
<strong class="bold">    orderService.EnqueueOrdersSync(orderNumbers);</strong>
<strong class="bold">    SpinWait.SpinUntil(() =&gt; orderService.EnqueueCount </strong>
<strong class="bold">        == orderNumbers.Count);</strong>
    var orders = orderService.DequeueOrders();
    Assert.NotNull(orders);
    Assert.True(orders.Any());
    Assert.Contains(orders, o =&gt; o.CustomerId == 2);
    Assert.Contains(orders, o =&gt; o.CustomerId == 5);
    Assert.Contains(orders, o =&gt; o.CustomerId == 9);
}</pre></li>
</ol>
<p>The differences are highlighted in the preceding code snippet. <code>SpinWait.SpinUntil</code> will wait without locking until the <code>orderService.EnqueueCount</code> value matches the <code>orderNumbers.Count</code>. If you want to ensure it doesn’t spin forever, there are overloads for providing a timeout period as either <code>TimeSpan</code> or in milliseconds.</p>
<ol>
<li value="5">Run the tests again and make sure that they both pass. We now have unit test methods that are testing the two methods available to enqueue orders in the <code>OrderService</code> class. In your own projects, you would add more scenarios to increase the test coverage of the class. You should always test things, such as how your code handles invalid input.</li>
</ol>
<p>It is important<a id="_idIndexMarker647"/> to <a id="_idIndexMarker648"/>remember when unit testing multithreaded code that if you are not using <code>async</code> and <code>await</code> or some other synchronization method, your tests are going to be unreliable. Having unreliable tests is as bad as having no tests at all. Be sure to design and develop your unit tests with care. It is best to use <code>async</code>/<code>await</code> wherever possible for maximum reliability.</p>
<p>In the next section, we will build some unit tests for code that use the <code>Parallel.ForEach</code> and <code>Parallel.ForEachAsync</code> methods.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Unit testing parallel code</h1>
<p>Creating <a id="_idIndexMarker649"/>unit tests <a id="_idIndexMarker650"/>for code that use <code>Parallel.Invoke</code>, <code>Parallel.For</code>, <code>Parallel.ForEach</code>, and <code>Parallel.ForEachAsync</code> is relatively straightforward. While they can run processes in parallel when conditions are suitable, they run synchronously relative to the invoking code. Unless you wrap <code>Parallel.ForEach</code> in a <code>Task.Run</code> statement, the flow of code will not continue until all iterations of the loop have been completed.</p>
<p>The one caveat to consider when testing code that uses parallel loops is the type of exceptions to expect. If an exception is thrown within the body of one of these constructs, the surrounding code must catch <code>AggregateException</code>. The exception to this <code>Exception</code> rule is <code>Parallel.ForEachAsync</code>. Because it is called with <code>async</code>/<code>await</code>, you must handle <code>Exception</code> instead of <code>AggregateException</code>. Let’s create an example to illustrate these scenarios:</p>
<ol>
<li value="1">Create a new <code>ParallelExample</code>.</li>
<li>Rename <code>Class1</code> <code>TextService</code> and create a method named <code>ProcessText</code> in this class:<pre>public List&lt;string&gt; ProcessText(List&lt;string&gt; 
    textValues)
{
    List&lt;string&gt; result = new();
    Parallel.ForEach(textValues, (txt) =&gt; 
    {
        if (string.IsNullOrEmpty(txt))
        {
            throw new Exception("Strings cannot be 
                empty");
        }
        result.Add(string.Concat(txt, 
            Environment.TickCount));
    });
    return result;
}</pre></li>
</ol>
<p>This <a id="_idIndexMarker651"/>method accepts a list of strings and appends <code>Environment.TickCount</code> to each value inside a <code>Parallel.ForEach</code> loop. If <a id="_idIndexMarker652"/>any of the strings are <code>null</code> or empty, <code>Exception</code> will be thrown.</p>
<ol>
<li value="3">Next, create the <code>async</code> version of <code>ProcessText</code> and name it <code>ProcessTextAsync</code>. The <code>async</code> version uses <code>Parallel.ForEachAsync</code> to perform the same operation:<pre>public <strong class="bold">async Task&lt;List&lt;string&gt;&gt;</strong> 
    ProcessTextAsync(List&lt;string&gt; textValues)
{
    List&lt;string&gt; result = new();
    <strong class="bold">await Parallel.ForEachAsync(textValues, async </strong>
<strong class="bold">        (txt, _) =&gt;</strong>
    {
        if (string.IsNullOrEmpty(txt))
        {
            throw new Exception("Strings cannot 
                be empty");
        }
        result.Add(string.Concat(txt, 
            Environment.TickCount));
        <strong class="bold">await Task.Delay(100);</strong>
    });
    return result;
}</pre></li>
<li>Add a <a id="_idIndexMarker653"/>new <code>ParallelExample.Tests</code>.</li>
<li>Rename the <code>UnitTest1</code> class <code>TextServiceTests</code> and add a <strong class="bold">Project </strong>reference to the <strong class="bold">ParallelExample</strong> project.</li>
<li>Next, we will add two unit tests to test the <code>ProcessText</code> method:<pre>[Fact]
public void ProcessText_Returns_Expected_Strings()
{
    var service = new TextService();
    var fruits = new List&lt;string&gt; { "apple", "orange", 
        "banana", "peach", "cherry" };
    var results = service.ProcessText(fruits);
    Assert.Equal(fruits.Count, results.Count);
}
[Fact]
public void ProcessText_Throws_Exception_For
    _Empty_String()
{
    var service = new TextService();
    var fruits = new List&lt;string&gt; { "apple", "orange", 
        "banana", "peach", "" };
    Assert.Throws&lt;AggregateException&gt;(() =&gt; 
        service.ProcessText(fruits));
}</pre></li>
</ol>
<p>The<a id="_idIndexMarker655"/> first test calls <code>ProcessText</code> with a list of five-string values<a id="_idIndexMarker656"/> containing fruit names. The assertion checks that <code>results.Count</code> matches <code>fruits.Count</code>. </p>
<p>The second test makes the same call, but one of the <code>fruits</code> string values is empty. This test will ensure that <code>AggregateException</code> is thrown by the <code>Parallel.ForEach</code> loop in the method under test.</p>
<ol>
<li value="7">Add two more tests. These two tests will run the same assertions on the <code>ProcessTextAsync</code> method. The difference here is that <code>Assert.ThrowsAsync</code> must check for <code>Exception</code> instead of <code>AggregateExceptoin</code> because we are using <code>async</code>/<code>await</code>:<pre>[Fact]
public async Task ProcessTextAsync_Returns_Expected
    _Strings()
{
    var service = new TextService();
    var fruits = new List&lt;string&gt; { "apple", "orange", 
        "banana", "peach", "cherry" };
    var results = await service.ProcessTextAsync
         (fruits);
    Assert.Equal(fruits.Count, results.Count);
}
[Fact]
public async Task ProcessTextAsync_Throws_Exception
    _For_Empty_String()
{
    var service = new TextService();
    var fruits = new List&lt;string&gt; { "apple", "orange", 
        "banana", "peach", "" };
    await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; 
        await service.ProcessTextAsync(fruits));
}</pre></li>
<li>Run all <a id="_idIndexMarker657"/>four tests with the <strong class="bold">Run All Tests in View</strong> button<a id="_idIndexMarker658"/> in the <strong class="bold">Text Explorer</strong> window. If the window is not visible in Visual Studio, you can open it from <strong class="bold">View</strong> | <strong class="bold">Test Explorer</strong>. All tests should pass:</li>
</ol>
<div><div><img alt="Figure 12.4 – Four tests passing in the TextServiceTests class " height="538" src="img/Figure_12.4_B18552.jpg" width="1265"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Four tests passing in the TextServiceTests class</p>
<p>You now have two tests for each of the methods for processing text in the <code>TextService</code> class. They<a id="_idIndexMarker659"/> are testing valid and invalid input data successfully. Spend some time on your <a id="_idIndexMarker660"/>own to examine how the test coverage could be expanded. What other types of input could be used?</p>
<p>In the final section of this chapter, we will examine how you can build memory leak detection into your automated unit test suite.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Checking for memory leaks with unit tests</h1>
<p>Memory leaks <a id="_idIndexMarker661"/>are by no means unique to multithreaded <a id="_idIndexMarker662"/>code, but they certainly can happen. The more code that is executing in your application, the more likely it is that some objects <a id="_idIndexMarker663"/>are going to leak. The company that makes the popular .NET tools, <strong class="bold">ReSharper</strong> and <strong class="bold">Rider</strong>, also <a id="_idIndexMarker664"/>makes a tool called <strong class="bold">dotMemory</strong> for <a id="_idIndexMarker665"/>analyzing memory leaks. While these tools are not free, JetBrains does <a id="_idIndexMarker666"/>offer its memory unit testing tool for free. It’s called <strong class="bold">dotMemory Unit</strong>.</p>
<p>In this section, we will create a dotMemory Unit test to check whether we are leaking one of our objects. You can run these dotMemory Unit tests for free with .NET on the command line by downloading the standalone test runner here: https://www.jetbrains.com/dotmemory/unit/.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about <a id="_idIndexMarker667"/>using the free tooling, you can read about it here: <a href="https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml">https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml</a>. JetBrains also has integration for dotMemory Unit in its ReSharper and Rider tools. If you have licenses for either of these tools, it greatly simplifies the process of running these tests.</p>
<p>Let’s create an <a id="_idIndexMarker668"/>example demonstrating how to create<a id="_idIndexMarker669"/> a unit test that determines whether objects are being leaked in memory by the code under test:</p>
<ol>
<li value="1">Start by creating a new <code>MemoryExample</code>.</li>
<li>Rename <code>Class1</code> <code>WorkService</code> and add another class named <code>Worker</code>. Add the following code to the <code>Worker</code> class. The <code>DoWork</code> method in this class will handle a <code>TimerElapsed</code> event in <code>WorkService</code>:<pre>public class Worker : IDisposable
{
    public void Dispose()
    {
        // dispose objects here
    }
    public void DoWork(object? sender, 
        System.Timers.ElapsedEventArgs e)
    {
        Parallel.For(0, 5, (x) =&gt;
        {
            Thread.Sleep(100);
        });
    }
}</pre></li>
</ol>
<p>This class implements <code>IDisposable</code>, so we can use it with a <code>using</code> statement <a id="_idIndexMarker670"/>elsewhere.</p>
<ol>
<li value="3">Add a <code>WorkWithTimer</code> method<a id="_idIndexMarker671"/> to the <code>WorkService</code> class:<pre>public void WorkWithTimer()
{
    using var worker = new Worker();
    var timer = new System.Timers.Timer(1000);
    timer.Elapsed += worker.DoWork;
    timer.Start();
    Thread.Sleep(5000);
}</pre></li>
</ol>
<p>This code has some problems that will prevent the <code>worker</code> object from being released from memory. The <code>timer</code> object is not stopped or disposed of, and the <code>Elapsed</code> event is never unhooked. When we check for leaks, we should find some.</p>
<ol>
<li value="4">Add a new <code>MemoryExample.Tests</code>.</li>
<li>Add a project reference to <strong class="bold">MemoryExample</strong> and<a id="_idIndexMarker672"/> add a <strong class="bold">NuGet package reference</strong> to <strong class="bold">JetBrains.dotMemoryUnit</strong>:</li>
</ol>
<div><div><img alt="Figure 12.5 – Referencing the dotMemoryUnit NuGet package " height="102" src="img/Figure_12.5_B18552.jpg" width="1350"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Referencing the dotMemoryUnit NuGet package</p>
<ol>
<li value="6">Rename the <code>UnitTest1</code> class in <code>WorkServiceMemoryTests</code> and <a id="_idIndexMarker673"/>add the<a id="_idIndexMarker674"/> following code:<pre>using JetBrains.dotMemoryUnit;
<strong class="bold">[assembly: SuppressXUnitOutputExceptionAttribute]</strong>
namespace MemoryExample.Tests
{
    public class WorkServiceMemoryTests
    {
        [Fact]
        public void WorkWithSquares_Releases_Memory_
            From_Bitmaps()
        {
            var service = new WorkService();
            service.WorkWithTimer();
            <strong class="bold">GC.Collect();</strong>
            // Make sure there are no Worker 
                objects in memory
            <strong class="bold">dotMemory.Check(m =&gt; Assert.Equal(0, </strong>
<strong class="bold">                m.GetObjects(o =&gt;</strong>
<strong class="bold">                    o.Type.Is&lt;Worker&gt;())</strong>
<strong class="bold">                        .ObjectsCount));</strong>
        }
    }
}</pre></li>
</ol>
<p>A few lines are highlighted in the previous snippet. An <code>assembly</code> attribute must be added to suppress an error in the console runner when using xUnit.net with dotMemory Unit. After calling the method under test, <code>WorkWithTimer</code>, we are <a id="_idIndexMarker675"/>calling <code>GC.Collect</code> to attempt to clean all unused managed objects from memory. Finally, <code>dotMemory.Check</code> is called to determine whether there are any objects of the <code>Worker</code> type remaining in memory.</p>
<ol>
<li value="7">Run the <a id="_idIndexMarker676"/>following command either<a id="_idIndexMarker677"/> in <code>.\</code> characters are required:<pre>.\dotMemoryUnit.exe "c:\Program Files\dotnet\dotnet.exe" – test "c:\dev\net6.0\MemoryExample.Tests.dll"</pre></li>
</ol>
<p>The path to .NET should be the same on your system. You will need to replace the path to <code>MemoryExample.Tests.dll</code> with your own output path where this DLL resides. The test should fail, with one <code>Worker</code> object remaining in memory, and your output will look something like this:</p>
<div><div><img alt="Figure 12.6 – Reviewing the failed dotMemoryUnit test run " height="690" src="img/Figure_12.6_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Reviewing the failed dotMemoryUnit test run</p>
<ol>
<li value="8">In order<a id="_idIndexMarker679"/> to fix the problem, make the following <a id="_idIndexMarker680"/>changes to your <code>WorkService.WorkWithTimer</code> method:<pre>public void WorkWithTimer()
{
    using var worker = new Worker();
    <strong class="bold">using var timer = new System.Timers.Timer(1000);</strong>
    timer.Elapsed += worker.DoWork;
    timer.Start();
    Thread.Sleep(5000);
<strong class="bold">    timer.Stop();</strong>
<strong class="bold">    timer.Elapsed -= worker.DoWork;</strong>
}</pre></li>
</ol>
<p>To make sure the <code>worker</code> object instance is released, we’re initializing <code>timer</code> in a <code>using</code> statement, stopping <code>timer</code> when it’s finished, and unhooking the <code>timer.Elapsed</code> event handler.</p>
<ol>
<li value="9">Now, execute<a id="_idIndexMarker681"/> the <code>dotMemory</code> Unit command again. The test should succeed now:</li>
</ol>
<div><div><img alt="Figure 12.7 – The dotMemoryUnit test runs successfully " height="692" src="img/Figure_12.7_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – The dotMemoryUnit test runs successfully</p>
<p>That <a id="_idIndexMarker682"/>concludes this example and the section on memory unit tests. If you would like to read more about dotMemory Unit, you can find its documentation here: <a href="https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml">https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml</a>. The command-line tool can also be deployed to a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) build <a id="_idIndexMarker683"/>server to execute these tests as part of a CI build process.</p>
<p>Let’s finish up by reviewing what we have learned in the final chapter of this book.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Summary</h1>
<p>In this chapter, we learned about some tools and techniques to unit test .NET projects that contain different multithreaded constructs. We started by discussing the best methods for testing C# code that employs <code>async</code>/<code>await</code>. This will be common in modern applications, and it is important to have a suite of automated unit tests covering your <code>async</code> code. </p>
<p>We also walked through some examples of unit tests that test methods that leverage parallel constructs and concurrent data structures. In the last section of the chapter, we learned about dotMemory Unit from JetBrains. This free unit testing tool adds the ability to detect objects leaked by methods under test. It is a powerful automation tool for synchronous and asynchronous .NET code.</p>
<p>This is the final chapter. Thanks for following along on this multithreading journey. Hopefully, you didn’t encounter any deadlocks or race conditions along the way. This book provided guidance for your path through the modern, multithreaded world of .NET and C#. You should now have an understanding of the asynchronous, concurrent, and parallel methods and structures to build fast and reliable .NET applications. If you want to learn more about these topics, I suggest reading the <em class="italic">.NET Parallel Programming</em> blog (<a href="https://devblogs.microsoft.com/pfxteam/">https://devblogs.microsoft.com/pfxteam/</a>) and relying on the .NET documentation (<a href="https://docs.microsoft.com/dotnet/">https://docs.microsoft.com/dotnet/</a>). You can search for documentation on any of the topics in this book to learn more.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Questions</h1>
<ol>
<li value="1">What is the keyword used in .NET attributes that decorate an <code>xUnit.net</code> test method?</li>
<li>What method can you use to add <code>await</code> to your code without locks?</li>
<li>What type of exception should you expect in unit test assertions when the method under test contains a <code>Parallel.ForEach</code> loop?</li>
<li>What type of exception should you expect in unit test assertions when the method under test contains a <code>Parallel.ForEachAsync</code> loop?</li>
<li>How can you check that an object isn’t <code>null</code> in an xUnit.net assertion?</li>
<li>What is the name of the window in Visual Studio where unit tests can be managed and run?</li>
<li>What are the three most popular unit test frameworks for .NET?</li>
<li>Which JetBrains products provide tooling to run dotMemory Unit tests?</li>
</ol>
</div>
</div>
</body></html>