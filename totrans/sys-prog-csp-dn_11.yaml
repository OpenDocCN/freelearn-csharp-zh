- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Debugging Dances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Debugging and Profiling* *System Applications*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging** is the art of finding errors in your code and ensuring you have
    all the knowledge to fix them. That sounds simple enough, doesn’t it? Well, think
    again. Debugging can get complicated quickly, and you need good strategies to
    recover. Luckily, I am here to help you! In this chapter, we’re going to cover
    the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is debugging? What is **profiling**?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we use **breakpoints**?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other debugging tools do we have in Visual Studio?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we deal with multithreaded and asynchronous systems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we profile and benchmark our code to ensure it runs as fast as possible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging can get quite time-intensive. So, let’s not waste any time and get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, you can find the source code for all samples in this chapter in the
    GitHub repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: I only use Visual Studio in this chapter; I am not referring to any of the third-party
    tools that might do the same job. However, I will provide you with a list of alternative
    tools at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True story: I once worked for a manager who claimed he wanted to lay off the
    testers in my team. He said, “If your team performs better, they will not produce
    bugs, and therefore we can save on the testers.” Obviously, he was wrong. I left
    that company shortly after this happened.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing software is a creative job. People think software development is
    an exact science that is close to mathematics and physics, but it is not. Sure,
    the roots look mathematical, but what we, as software developers, do is something
    else. We take an idea, think of something that does not yet exist, and then turn
    those ideas into something that can help others. We create something out of thin
    air by our imagination and ingenuity.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the creative mind is sloppy. We cut corners when we are in the flow.
    We make mistakes trying to realize our vision. Testers and QA professionals are
    our safety net; they are there to catch the things we forget about. But having
    a safety net does not mean you can do whatever you want and wing it. Once you
    have the first outline of your code ready, it is time to switch from being the
    creative developer to the pensive, analytical developer – the one who looks at
    their code and notices areas of improvement; and still then you will miss things.
    So, you test yourself. That is when you find issues. Or, you see the system does
    not run as smoothly as you expected. Maybe you find the results are not what they
    are supposed to be. That is when the debugging dance starts: you run the system,
    you try to pinpoint the area where things go wrong, you fix things, and repeat
    the whole cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Debugging can be a fun journey, or it can be an extremely frustrating experience.
    I am here to help you move your debugging experiences into a more fun one. If
    debugging means fixing bugs, then developing means creating bugs. There is nothing
    wrong with that, as long as you realize this is the case and you can resolve the
    issues before shipping. Let me help you with that!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and profiling – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I remember when they taught me how to write Cobol code on the university mainframe.
    It was a challenge, to be honest. The mainframe was a costly machine with many
    terminals attached. If you do not know what that means, imagine you have one computer
    with multiple keyboards and monitors connected to it, where each user can use
    their session to do their work, isolated from the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This worked fine when you had to do some simple stuff, such as working on a
    document or a spreadsheet; the mainframe could handle multiple sessions well.
    However, compiling code is something else: that takes a lot of CPU power. They
    fixed that by having the students submit their code to the compiler, which would
    then run sequentially at night. You could see what you did wrong when you returned
    the next day. Imagine forgetting a semicolon somewhere, meaning you have to wait
    another 24 hours before you can see the results of your fix. That way of working
    taught me to think about my code very thoroughly.'
  prefs: []
  type: TYPE_NORMAL
- en: These days, when I enter C# code, I see the compiler working for me constantly.
    Visual Studio immediately tells me when I make a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Debugging** was out of the question. All we could do was stuff the code with
    logging messages, run the program, and see the output. Then, we could try to deduce
    the errors in our code from the log files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, it’s so much easier: you can step through your code, see the statements
    as they are executed, and inspect variables, memory, threads, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the requirements of the software have also become much more complex,
    so writing software in itself hasn’t gotten any easier.
  prefs: []
  type: TYPE_NORMAL
- en: But modern debugging tools help – a lot.
  prefs: []
  type: TYPE_NORMAL
- en: '*Debugging is the process of identifying, isolating, and fixing problems or
    “bugs” in software. These bugs can be anywhere from simple syntax errors to more
    elusive logic errors that produce the wrong output* *or flow.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler helps us fix the most obvious mistakes: a typo in a statement
    is caught immediately. However, code that compiles does not result in a flawless
    program. Debugging can help remedy that.'
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Profiling** is the twin of debugging. *While debugging aims to find logical
    errors, profiling is meant to help you find performance errors.* Performance errors
    can indicate that the system runs too slow, uses too much memory, or other things
    that stop the software from running as efficiently as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Profiling helps you improve the efficiency of your software. It shows you where
    the bottlenecks are. Profiling can help you pinpoint where your memory usage goes
    up and where your logic fails when encountering performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling can be as simple as logging some timing information or as complex
    as gathering 24 hours of activities of all your threads and performing a statistical
    analysis of that data. It all depends on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and profiling go hand in hand. With a profile session, you gather
    the evidence that something is not going as you want it to. You then use debugging
    techniques to find and fix the errors in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this process is more like a cycle. You debug, then you profile,
    then debug to find the issues, fix them, then debug the fixes, then profile the
    fixes, and so on. It’s a never-ending dance. However, it can be quite satisfying:
    in the end, you have much better code and a better-performing system, and that
    must make it all worth it!'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s investigate the tools we have to do all this magic!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Visual Studio** is a great tool. It has many features that help you during
    development and the debugging process. So, it is natural to start by looking at
    Visual Studio first. I will not spend much time on debugging basics in Visual
    Studio. Still, I think revisiting the most apparent tools we have is immensely
    clarifying.'
  prefs: []
  type: TYPE_NORMAL
- en: Debug builds versus Release builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s talk about that dropdown at the top in Visual Studio, where you can choose
    between **Debug** and **Release**. I am sure you have a feeling about what this
    is all about. You pick **Debug** when you are still writing the code, and want
    to debug your software. You choose **Release** when you are ready to release your
    product.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a bit more you should know about those options. Let me start
    by saying that you can still debug your code if it is built in Release mode. It’s
    just a bit harder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me compare the results of a Debug setting and a Release setting. The following
    table shows the main differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Debug** | **Release** |'
  prefs: []
  type: TYPE_TB
- en: '| **Purpose** | Primarily for development. | Primarily for production. |'
  prefs: []
  type: TYPE_TB
- en: '| **Optimization** | Minimal or no optimization. | Highly optimized for performance
    and efficiency. The compiler removes unused code and applies various optimizations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Symbols** | Includes debugging symbols (`.pdb` files), which provide detailed
    information about the code (e.g., variable names, line numbers, and so on). |
    No or limited symbols. You can still get a `.pdb` file, but it will have much
    less information. |'
  prefs: []
  type: TYPE_TB
- en: '| **Assertions** | Debug assertions are enabled. | Debug assertions are disabled.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Performance** | Generally slower because there is no optimization. | Generally
    faster and more efficient. |'
  prefs: []
  type: TYPE_TB
- en: '| **Size** | Larger files due to extra debugging information. | Smaller because
    of optimizations and removal of debugging information. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: Comparing Debug and Release builds'
  prefs: []
  type: TYPE_NORMAL
- en: I suggest you use Debug builds when debugging. That is what it is for.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best tool Visual Studio offers is the mighty **breakpoint**. It is a straightforward
    construct, but it can help us a lot when trying to understand what is happening
    inside our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest form, a breakpoint is a code point that stops the program when
    the application reaches the code statement to which the breakpoint is attached.
    You can add breakpoints to all sorts of things as long as they are statements.
    You cannot add a breakpoint to a code comment.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot set a breakpoint on a method declaration, but you can set it on the
    first `{` that marks the beginning of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Also, declarations of variables are not a valid target for a breakpoint unless
    you do an assignment simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, look at the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot add a breakpoint to the line where we declare `i`. We can add a breakpoint
    to the second line. Technically, that line consists of two parts: the declaration
    and the assignment; the breakpoint is set on the assignment part.'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace declarations and `using` statements are also invalid targets. Interfaces
    cannot have breakpoints, just as attribute declarations are excluded.
  prefs: []
  type: TYPE_NORMAL
- en: However, besides these obvious cases, you can place them wherever you want.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when a breakpoint is hit?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have some software, placed a breakpoint, and ran the software. At one point,
    the execution point reaches our breakpoint. The question is: what happens then?'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the execution stops. The program is frozen in time. In Visual Studio,
    some additional tools come to life:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locals**: This window opens or updates, showing all variables reachable in
    the current scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autos**: This window displays variables used in the current line and the
    surrounding context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Watch**: This window shows any variables you might have added to the Watch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Call Stack**: This window displays a series of method calls that led up to
    the current breakpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediate**: This window allows you to type commands, evaluate expressions,
    or change variable values on the fly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the program paused, you can inspect or modify variable values if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This helps you understand what happens in your program. However, it can lead
    to weird situations if you are not careful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at what I mean. Imagine you have this code somewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code iterates over the `i` variable, increasing it and adding its value
    to the `sum` variable. If you run this, you get the result of `55`. Now, place
    a breakpoint inside the loop. Run the code again, but after the ninth iteration,
    you decide you want to see what happens in that loop one more time. So, you change
    the value of `i` from `9` back to `0`. The `sum` variable will not make any sense
    anymore: the outcome is a vastly different value.'
  prefs: []
  type: TYPE_NORMAL
- en: This sample is simple, but these side effects can happen quite quickly. Changing
    variables might have unintended consequences. So, be aware of that.
  prefs: []
  type: TYPE_NORMAL
- en: Threads and breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later in this chapter, we will discuss debugging multithreaded applications,
    but I want to discuss one item here. I said that when the code hits a breakpoint,
    the debugger stops execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code is straightforward enough. First, we get a `thread` from `ThreadPool`.
    An infinite loop logs a message in `thread`, increases a `counter`, and waits
    for 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: In the main part of the code, we do something similar but at a different time.
    Running this program shows that we get two messages from the inner thread for
    each message from the outer thread. Now, place a breakpoint on the last `Task.Delay()`
    statement. Run the code, let the debugger hit the breakpoint, wait for a few seconds,
    and continue the run.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you do that a couple of times. In that case, you will notice that although
    the sequence of the messages to the console is slightly different, we still get
    twice as many messages from the inner thread. In other words, if we pause the
    outer thread, the inner thread is also paused.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is good, of course. You do not want other threads to continue, wreaking
    havoc on the program flow. But let’s change things a bit: replace the code where
    we create the thread with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having a `thread`, we now have a `timer`. This code achieves the
    same effect as our previous code: the `timer` works on a separate `thread` when
    the time has passed. If that happens, we will log the message and increase the
    counter.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we repeat the little trick we did with the breakpoint on the code
    in the last loop, you will notice a completely different behavior. The number
    of messages from the timer is no longer double the number we get from the main
    loop; it is much more than that.
  prefs: []
  type: TYPE_NORMAL
- en: A breakpoint does not stop timers. Neither does it stop classes such as `Stopwatch`.
    Time-based events still happen, so you have a different outcome than expected.
    Be mindful of that when you use timers!
  prefs: []
  type: TYPE_NORMAL
- en: Features of breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Breakpoints are more than just markers to show the debugger where to stop the
    execution. They have some properties that can be helpful if you use them correctly.
    Most of these settings are accessed by clicking the breakpoint in the **Breakpoints**
    window and selecting **Settings**. That window looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.1: The Breakpoint Settings window in Visual Studio](img/B20924_12_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The Breakpoint Settings window in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: You can also get this window by clicking on one of the settings you get when
    you right-click the breakpoint bullet in the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Active and inactive breakpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Breakpoints by default are active, meaning that if the debugger comes to the
    statement containing the breakpoint, the execution stops. But you can also disable
    the breakpoint: this means the breakpoint is still there, but it does not do anything.
    This option can be handy if you are debugging some code but want to skip a specific
    breakpoint at this time but do not want to delete it.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional breakpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A conditional breakpoint only breaks when a particular condition has been met.
    The condition can be a single condition or a set of conditions, all of which must
    be true. The condition can include variables from the code as well. Let’s imagine
    I want a breakpoint in the previous code sample. I want the breakpoint to be on
    the line with the `Task.Delay()`code. However, I only want that breakpoint to
    be active if the `outThreadCounter` variable is larger than `5` and only if that
    breakpoint has been hit 6 times. In our code, that should be the same (every time
    we go through that loop, `outThreadCounter` is increased), but if this doesn’t
    happen, you can verify it using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify this by placing a breakpoint, right-clicking on it, and then
    choosing **Conditions**.
  prefs: []
  type: TYPE_NORMAL
- en: Action breakpoints or tracepoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Action breakpoints** can be real breakpoints or breakpoints that do not break.
    But besides breaking (or not), you can also specify that the debugger should write
    something in the **Output** window. In other words, this is a very lightweight
    and temporary log system. You can output a static text or the contents of a variable.
    Underneath the option where you specify the output, you can place a checkmark
    in the box saying **Continue code execution**. If you check that box, the debugger
    does not stop at this breakpoint and only displays the required information in
    the Output window. When you do not stop executing the code and only display some
    information, we call these breakpoints **tracepoints**.'
  prefs: []
  type: TYPE_NORMAL
- en: One-time breakpoint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A **one-time breakpoint** only works once. It stops code execution when the
    breakpoint is hit and then disables itself. If you want to use it again, you must
    manually enable it. You create this breakpoint by selecting **Disable breakpoint**
    **once hit**.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent breakpoint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **dependent breakpoint** is only enabled after another breakpoint has been
    hit. This is particularly useful if you have a method that is called from different
    places in your code. Still, you only want to debug a particular path. In that
    case, you create a breakpoint in the flow you are interested in (you might even
    make it non-breakable so that it only acts as a trigger) and then connect the
    breakpoint in the method you are interested in into that first breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The effect is that the breakpoint is disabled until that first breakpoint is
    hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, take our last example. Increase the time for the `1`
    second (1000 milliseconds). Then, add a breakpoint to the line where we write
    the message to the console. Tick the **Action** box in the properties of this
    breakpoint, but do not add anything to the **Message** dialog. However, make sure
    you tick the **Continue code execution** box. The settings should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.2: Trigger breakpoint](img/B20924_12_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Trigger breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add another breakpoint to the line where we write the console the value
    of `outThreadCounter`. This time, change the settings to enable the **Only enable
    when the following breakpoint is hit** option and select the other breakpoint
    in the corresponding drop-down menu. That should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.3: Depend\uFEFFent breakpoint](img/B20924_12_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Dependent breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program, the debugger ignores the last breakpoint during the
    first second. Then, the execution stops since our first breakpoint has been hit.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can combine these settings at will.
  prefs: []
  type: TYPE_NORMAL
- en: Adding other breakpoints quickly
  prefs: []
  type: TYPE_NORMAL
- en: You probably know that you can add breakpoints to your code by clicking in what
    is known as **the gutter** to the left of the source code. If you do that, a red
    bullet appears in that gutter to indicate you have added a breakpoint at that
    position. But did you know you can also right-click in that gutter? If you do
    that, you get a pop-up menu to quickly add the breakpoints that were previously
    mentioned. In the long run, this might save you some mouse clicks!
  prefs: []
  type: TYPE_NORMAL
- en: Some other features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Breakpoints have some other nice features that might be helpful. You usually
    access these in the **Breakpoints** window in Visual Studio by right-clicking
    the chosen breakpoint. Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breakpoints can have labels**: This way, you can give more meaningful names
    to the breakpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You can group breakpoints**: If you create a breakpoint group, you can add
    breakpoints to them. This way, you can quickly turn a large group of breakpoints
    on or off instead of going through them individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You can search for breakpoints**: In the breakpoints window, you can search
    for class names, line numbers, output, labels, and so on. This feature might be
    helpful if you have a large group of breakpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You can sort breakpoints by name, condition, hit count, label, and more**:
    If you still can’t find what you need, you might want to reconsider your breakpoint
    strategy!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most developers I encounter never come near all these options: all they do
    is toggle a breakpoint on a line of code to stop execution. But I hope you begin
    to appreciate the power these tools can bring you.'
  prefs: []
  type: TYPE_NORMAL
- en: Debug windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio has a lot of windows that can help you get a grip on what is happening
    when you debug. Most of these windows are useless when editing code but come to
    life once the debugger starts. Let’s see what we have!
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already discussed breakpoints, but I want to point out the **Breakpoints**
    window. This window is where you see all the breakpoints in your application.
    It also shows additional information about those breakpoints. You can add columns
    to the window if you need more information. This is an example of what might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.4: The Breakpoints window](img/B20924_12_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: The Breakpoints window'
  prefs: []
  type: TYPE_NORMAL
- en: You can customize this window to fit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Locals, autos, and watches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When debugging, you probably want to see the values of the variables in your
    code. To see the value, you can hover the mouse over a variable in the code editor
    window. However, there are windows in Visual Studio dedicated to giving you access
    to that data. Let’s explore these.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Locals** window shows all the variables in the current scope. That can
    be pretty useful: you see all variables in the current block without being distracted
    by other variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Autos** window is even better: it tries to guess which variables interest
    you when you break in the code and show them and their values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at this. We have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it in the following code (I added line numbers so I can refer to the
    lines later on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, add a breakpoint on *line 3*. Run the code and see whether your output
    matches mine. I will step through all lines from *3* up until *7* and show you
    what the **Autos** window tells me.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first breakpoint is on *line 3*, so the debugger stops there. It breaks
    on *line 3*, with the following result in the **Autos** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| `myNumber` | `0` | Int |'
  prefs: []
  type: TYPE_TB
- en: Table 11.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, step to the following line. Then we get, if we stop on *line 4*, we get
    the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Table 11.3
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get no results. We stopped on `{`, and no variables can influence
    the path of the code now. So, there is nothing to show. Let’s continue and step
    to the following line, *line 5*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| `myClass` | `{``myClass}` | MyClass |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | `0` | Int |'
  prefs: []
  type: TYPE_TB
- en: '| `myClass.Counter` | `0` | int |'
  prefs: []
  type: TYPE_TB
- en: Table 11.4
  prefs: []
  type: TYPE_NORMAL
- en: If you step to that line, you will see two items. The top one, `myClass`, can
    be expanded so you can see properties that might interest you. In our case, this
    is `myClass.Counter`. We also see the `myClass.Counter` variable separately since
    the compiler is smart enough to see this is significant in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move to the next line, *line 6*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| `MyClass.Counter.get returned` | `0` | int |'
  prefs: []
  type: TYPE_TB
- en: '| `myClass` | `{``myClass}` | MyClass |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | `1` | Int |'
  prefs: []
  type: TYPE_TB
- en: '| `myClass.Counter` | `1` | int |'
  prefs: []
  type: TYPE_TB
- en: Table 11.5
  prefs: []
  type: TYPE_NORMAL
- en: 'That is interesting: the `MyClass.Counter.get`) and got a result. There is
    also an icon to show you that this is indeed the return value. The “get” returned
    zero, but then we applied the `++` operator to change the value locally.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line, *line 7*, produces this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| `MyClass.Counter.get returned` | `1` | int |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear
    returned` | `Counter 1` | string |'
  prefs: []
  type: TYPE_TB
- en: Table 11.6
  prefs: []
  type: TYPE_NORMAL
- en: We printed the line of text to the console and did that with the `$` interpolation
    command in front of the string. Now, you can see that doing that caused the `System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear()`
    method to be called, returning the resulting `Counter 1` string. Oh, and we lost
    `myClass` (well, it’s not lost; it’s just not shown any more since we will not
    use it in this scope anymore). As you can see, the **Locals** window is good at
    showing values of local variables and helping you figure out implicit method calls,
    such as the string interpolation and property getters!
  prefs: []
  type: TYPE_NORMAL
- en: The **Locals** window is pretty clever at figuring out what you need to see.
    Of course, if you disagree, there is always the **Watch** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Watch** window does the same as the previous two debug windows, but it
    only shows you what you ask it to show. Once the debugger stops the flow of your
    program, you can right-click on a variable and select **Add to Watch**. The variable
    will then pop up in the **Watch** window, where you can do the same things as
    you can do with **Locals** and **Autos**: inspect the variables and change the
    values if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this time, the variables stay there until you remove them. Suppose
    they go out of scope or are unreachable. In that case, you get an error in the
    **Watch** window telling you the variable does not exist in the current context.
    That doesn’t harm your experience, though: it will stay there as long as you need
    it, and if the variable comes back into context (in this or in a subsequent debugging
    session), it will be back again.'
  prefs: []
  type: TYPE_NORMAL
- en: Diagnostic Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Diagnostic Tools** window almost deserves its very own book. It does many
    things for us! Let’s dive into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most other debugging tools in Visual Studio, you cannot use the **Diagnostic
    Tools** until you are at a breakpoint in your code while debugging. We will use
    a very silly program to show you some of **Diagnostic Tools**’ possibilities.
    It’s a **console application**, and the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I also place a conditional breakpoint on the line with `passCounter++` (so,
    the first statement is in the while-loop). That condition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the breakpoint stops every 100 passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this, the application will break on the first pass. That makes sense:
    0 % of 100 equals 0\. You can then open the **Diagnostic Tools** window (if it
    doesn’t show up automatically, you can open it by going to the **Debug** menu,
    then choosing **Windows**, followed by selecting **Show Diagnostic Tools**). I
    suggest you make the window bigger than usual so you can see all the goodies it
    gives us. Mine looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.5: The Diagnostic Tools window](img/B20924_12_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: The Diagnostic Tools window'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the window, there are some charts. Since nothing has happened
    yet in our program, these are not very interesting. But that will change! Below
    the charts, there are some tabs. Initially, you see the **Summary** tab, which
    summarizes the contents of the other tabs.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Summary** tab, click **Take Snapshot** under the **Memory Usage** title.
    You can also do that in the **Memory Usage** tab itself. Doing this saves the
    current memory usage and allows it to be compared to a later point in time. Since
    our application hasn’t done much, this could give us a baseline. So, click on
    **Take Snapshot**. Then, continue running the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click **Take Snapshot**, the window should show you the **Memory Usage**
    tab, which shows the snapshot. Since we continued the program, we are not on the
    100th iteration, so we can take another snapshot. Do that. That results in my
    system in this view:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.6: Second pass in the Diagnostic Tools window](img/B20924_12_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Second pass in the Diagnostic Tools window'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is getting more interesting. We can see in the **Process Memory (MB)**
    chart that we have started to allocate a lot more memory. But the real exciting
    stuff happens in the **Memory Usage** tab below. You can see a lot here: in the
    second snapshot, we can see that we have allocated more objects and memory.'
  prefs: []
  type: TYPE_NORMAL
- en: You can click on most values, such as `Count Diff.` column to sort on that.)
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.7: Memory snapshot](img/B20924_12_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Memory snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: We have 99 more `Byte[]` objects in memory, resulting in an increase of 104,858,955
    bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: You can do all sorts of things here. You can click on the line you want to learn
    more about and then drill down into the source code of that object. That way,
    you can probably discover why your memory usage is increasing.
  prefs: []
  type: TYPE_NORMAL
- en: A lot is going on in **Diagnostic Tools**. I suggest you play around with it
    and see what it can tell you about your system!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging multithreaded and asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s join the league of super debuggers. We are about to embark on a journey
    into the depths of multithreaded systems and where they go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multithreaded code is notoriously hard to debug. Imagine you have two threads
    that interact with each other, and then things go wrong. However, if you step
    through the methods in Visual Studio, things work just fine, and that makes sense:
    some bugs appear only when certain timing conditions happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Watch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What about this: you have multiple threads, and something goes wrong. You want
    to inspect what happens in that thread. But if you set a breakpoint, how do you
    know you are in the correct thread?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fear not: Visual Studio can help with this. Let’s start with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates 10 threads. Each thread has an infinite loop, displaying
    some text and counting up. However, each thread does this at a different speed:
    they all wait for a random time between each iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a conditional breakpoint somewhere in that loop, with the condition saying
    it should break with this condition: `counter % 10 == 0`. Now, run the program.'
  prefs: []
  type: TYPE_NORMAL
- en: You see the `counter` value in the **Autos** or **Locals** windows. That can
    be helpful; that variable is local to the thread you are currently in. Visual
    Studio did pause all other threads for us, but we have no idea what the state
    of the data is in those threads. How can we find out?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to that question is this: open the **Parallel Watch** window. Again,
    you can find this in the **Debug** | **Windows** menu. On my system, after breaking
    in my breakpoint, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.8: The Parallel Watch window](img/B20924_12_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: The Parallel Watch window'
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, I have apparently stopped execution in thread 14628\.
    That doesn’t tell me much.
  prefs: []
  type: TYPE_NORMAL
- en: Add a Parallel Watch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But as you can see, on the top of the window, it says `counter` variable there.
    As soon as I do that, the **Watch** window shows me the value of that variable,
    but it does that for each thread:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.9: Parallel Watch with counter added](img/B20924_12_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Parallel Watch with counter added'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the screenshot, all threads have their version of the `counter`,
    each with a different value. This is helpful!
  prefs: []
  type: TYPE_NORMAL
- en: Jumping to frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this window is primarily a **Watch** window, meaning it shows the variables
    you are interested in and their values, there are other things you can do here
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since we stopped somewhere in the loop, you can hover over the variables in
    your code to see the values. However, as we discovered, those values only apply
    to that thread. You can add all the variables you are interested in into the **Parallel
    Watch** window, but what if you just want to see a variable once? Well, the **Parallel
    Watch** window can help you. Select one of the other threads in that window and
    right-click on that line, and you will see a context menu. One of the options
    is **Switch To Frame**. If you do that, the debugger makes the chosen thread the
    current one, allowing you to investigate the values of all variables in scope
    for that particular thread.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can jump between all active threads and inspect all values of
    all variables in scope per thread.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing and thawing threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability to inspect variables in different threads is a potent tool. You
    can probably imagine that certain variables affect other threads. Finding issues
    usually requires a lot of logging and inspections of those logs to determine the
    results of unwanted behavior. Being able to break the code and see what is happening
    saves you from a lot of that work.
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes, all those threads running simultaneously can get in the way.
    In those cases, you might want to focus on one or some threads in isolation. The
    **Freeze** and **Thaw** options can help in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing a thread is nothing more than pausing it during debugging. You temporarily
    halt the execution of one or more threads so you can focus on what is important
    to you. When you have all the information you need, you can thaw the frozen threads
    and let them resume their regular work. You can use the **Thread** window, but
    you can also do that in the **Parallel Watch** window. All you have to do is right-click
    on the thread you want to freeze and select **Freeze** from the context menu.
    If you resume the program, the thread you have chosen to freeze will not do anything
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that behavior in action, change the number of threads in our code to
    2 instead of 2\. Rerun the program and see which thread is active when the breakpoint
    hits. Obviously, one of the threads will cause the breakpoints condition (the
    `counter` variable in that thread must be a multiple of 10) to be satisfied. If
    you then resume the program, the other thread will likely be the following thread
    to stop: it is probably also close to satisfying the condition (I say “probably,”
    since the random behavior of the `Wait()` statement might, in theory, make it
    possible to act otherwise).'
  prefs: []
  type: TYPE_NORMAL
- en: Restart the program and wait for the first time the breakpoint becomes active.
    This time, right-click on the other thread and select **Freeze**. Resume the program.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.10: Freezing threads in Parallel Watch](img/B20924_12_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Freezing threads in Parallel Watch'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pause symbol should be in front of the chosen thread. Resume the program.
    When the program breaks again, it will be on the same thread as the first time
    it did this. If you resume, the third time will also be on that thread. That makes
    sense: the other thread is not doing anything and thus never satisfies the breakpoint
    conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can work on that one working thread to make sure you get what is going
    on. When you are ready to have the thread join the rest of the program, wait until
    the breakpoint happens again. Then, you can right-click the frozen thread and
    “thaw” it. Resume the program and see whether everything is back to normal: the
    debugger will break as soon as the condition is met in any of the threads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Freeze and Thaw: a word of warning'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably saw, the program continues after thawing the thread without
    adjusting anything. Typically, the `counter` variable values in both threads should
    be close to each other. However, after freezing one thread, it falls behind, and
    it doesn’t catch up on that lag anymore. Freezing and thawing threads can have
    an unpredictable side effect: if the rest of your code somehow relies on that
    thread running, you might have inadvertently changed the logic flow. So, be aware
    of that!'
  prefs: []
  type: TYPE_NORMAL
- en: Freezing and thawing can be a lovely addition to your tool belt. So, use them
    if needed, but use them wisely!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging deadlocks with Parallel Stacks and Thread windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deadlocks are pretty nasty. Simply put, a **deadlock** is when two threads wait
    for each other and thus cannot continue. It’s like driving your car on a narrow
    road and seeing someone coming from the other side. One of you will have to back
    off, or you will never leave that road. Deadlocks are like that, but your application
    freezes since neither of the involved threads is willing to drive back. I think
    it is obvious that you would not want that in your code.
  prefs: []
  type: TYPE_NORMAL
- en: However, as simple as the issue sounds, it can be challenging to debug and fix.
    But Visual Studio is here to help!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a simple program. This is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we do here? Simply put, we create two threads. They each use a `lock`
    statement. This means no other thread can enter that scope until the thread that
    owns the `lock` statement is done. That is not an issue in this code: both threads
    use a different `lock`. However, we also tried to use the other `lock` object
    in the thread. Because we have a `Thread.Sleep(1000)` in each thread, both threads
    have enough time to acquire the `lock` before accessing the other `lock`. But
    that never happens. No thread can release the `lock` since it waits for the other
    thread – and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it. You will see that both threads print out their initial statements about
    acquiring their `lock`s. And then: nothing. The program is completely frozen.
    It doesn’t do anything anymore. We have a deadlock on our hands.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, what is going on is obvious. Still, I am sure you can imagine
    these situations can be tricky to find in typical programs. The good news is that
    Visual Studio usually knows what is happening and can tell us.
  prefs: []
  type: TYPE_NORMAL
- en: Stop the program execution by going to the **Debug** menu, and then clicking
    on **Break All**. When Visual Studio has the focus, you can also press *Ctrl*
    + *Alt* + *Break*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking like this stops all threads as if the debugger has hit a breakpoint.
    Visual Studio stops at one of the three threads (the main thread or one of the
    bad-behaving ones), and you get a warning like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.11: Deadlock detected by Visual Studio](img/B20924_12_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Deadlock detected by Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at least know what caused the freezing: we have a deadlock. It is time
    to find out what is going on.'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Figure 11**.12*, you see the **Show Parallel Stacks** option in that dialog
    box. You can also get the **Parallel Stacks** window through the **Debug** | **Windows**
    menu option. Doing that gives you a nice visual representation of all currently
    known threads. On my machine, that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.12: Parallel Stacks in action](img/B20924_12_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Parallel Stacks in action'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have very few threads running, spotting the issue is straightforward.
    The offending threads are marked with a red circle with a white line: the symbol
    globally known as a stop sign. This symbol indicates the threads that are currently
    deadlocked. To make it even more apparent, the information box below says **[Deadlocked,
    double-click or press enter to view]**. You can double-click on the **Waiting
    on lock** line to jump to the source code for this thread.'
  prefs: []
  type: TYPE_NORMAL
- en: This window helps you identify thread issues very quickly. You can see which
    threads are running, if there are any issues, and where those threads originated
    from.
  prefs: []
  type: TYPE_NORMAL
- en: But if that is not enough, you can go deeper by looking at the **Threads** window.
  prefs: []
  type: TYPE_NORMAL
- en: Threads window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might have guessed from the name, the **Threads** window shows you all
    the threads you might be interested in. Let’s continue with our deadlock example.
    You have looked at **Parallel Stacks**, but you cannot find what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you open the **Threads** window. On my machine, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.13: The Threads window](img/B20924_12_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: The Threads window'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are all the threads currently known in my application. They are all up
    and running, and the current thread has an ID of `95264` (or managed thread ID
    `10`). It is a thread from the thread pool since the name is `.NET TP Worker`.
    You can also see the location: it is in my application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the down arrow next to the name, you get more details:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.14: The Thread window with more details](img/B20924_12_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: The Thread window with more details'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the screenshot, this gives me more information, including
    the text that this thread is deadlocked and is waiting on a lock owned by thread
    `14840`. The **Thread** window also shows information about that particular thread,
    so you can open that one if you want to. Double-clicking on the location brings
    you to the source code, where you can investigate what you were doing before the
    whole thing came crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging threading issues is not easy. But without these tools, they can be
    found more easily than ever before. Of course, the best course of action is not
    to make mistakes in the first place, but as I explained to my manager all those
    years ago, we do not live in that kind of world.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling application performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have established that system programmers care about speed. Applications
    need to be as efficient and as fast as possible. But what if you think your application
    can go faster but do not know where or what to improve? That is where profiling
    and benchmarking can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiling is measuring and analyzing the performance of your application in
    terms of factors such as CPU usage, memory pressure, network performance, and
    so on. It’s like putting your app under a microscope. Things we look at during
    profiling are, amongst others, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU usage**: Identify which parts of your application are using the most
    processing power'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory usage**: Track how much memory is used and finding memory leaks or
    excessive allocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function call frequency**: See which methods are called the most and how
    long they take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance hotspots**: Pinpoint areas of code that are slower than they
    should be'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking** is related, but it is different. Benchmarking is measuring
    the performance of your code under different circumstances or comparing different
    approaches. This process involves running predefined tests and capturing metrics.
    Some of the metrics are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution time**: Measuring how long it takes for a piece of code to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Throughput**: Assessing how many operations or transactions can be processed
    in a given period'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: Determining the delay between the initiation and the execution
    of a task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling and benchmarking go hand in hand and are often used together to improve
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: The prime application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To investigate how we might do this, let’s start with a program we want to
    improve performance. It is a simple program that calculates all the primes in
    the range 0 – 100,000 and sums them up. It’s nothing fancy or helpful, but it
    requires the CPU to do much work. We also want to see whether we can make things
    better. So, let’s start by looking at the code. First, we create a class called
    `PrimeCalculator`. That’s easy enough. The main method of this class is the `Run`
    method. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special going on here. We create a `Stopwatch` to time the
    duration, then call the `SumOfPrimes()` method that does all the actual work.
    Finally, we display the results and the duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at `SumOfPrimes()` next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is also pretty basic. We loop for all values between `2` and the
    given limit (`2` since `1` is technically not a prime number) and check whether
    that number is a prime. If it is, we add it to the sum. Let’s move to `IsPrime()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method is a lousy implementation to see whether a number is a prime, but
    it is simple enough to follow. We do this by checking whether the number we give
    it is divisible by any number that is less than the square root of that number.
    If it is divisible, it is not a prime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I run this on the machine I am writing this text on, I get
    the sum of 454, 396, 537 and a total duration of 21 milliseconds. I have no idea
    if that sum is correct; I have no intention of calculating it by hand on my calculator
    app on my phone. It doesn’t matter: we are here to see whether we can spot bottlenecks.'
  prefs: []
  type: TYPE_NORMAL
- en: 21 milliseconds sounds like a short amount of time, but in reality, it is pretty
    long. After all, computers are fast these days, so I am sure I can improve on
    it. We can use the profiling tools from Visual Studio to see where the bottlenecks
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Visual Studio, under the main **Debug** menu, you find the **Performance
    Profile** option. The default shortcut key for that is *Alt* + *F2*, which might
    be helpful if you repeatedly run this (and you will!)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select that option, you see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.15: Start of a profiling session](img/B20924_12_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: Start of a profiling session'
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiling can be done on many different levels. However, the most crucial choice
    is what you want to profile. By default, this tool chooses the current application.
    As you can see, in my case, that is the `11_Profiling` project. You can select
    other projects or running processes, browse for an application, and so on. Click
    that large **Change Target** button to change if necessary. There is also a warning
    underneath that button: we might want to switch from a Debug profile to a Release
    profile. Release is more closely related to what you run in production, so the
    figures you get are more like the ones you expect to see when you have deployed
    your application. However, Release mode optimizes your code, making it harder
    to find programming mistakes. So, I tend to leave it to Debug during development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you have to decide what you want to see. There are many options here:
    you might want to see async/awaits, or maybe you are interested in database communications.
    In my case, I want to know about **CPU Usage**. I also leave **.NET Counters**
    and **Memory Usage** checked; they might be helpful.'
  prefs: []
  type: TYPE_NORMAL
- en: If you click the **Start** button, your program will build and run. In the background,
    Visual Studio starts collecting the information.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the program runs and ends, signaling Visual Studio to stop collecting.
    If your application keeps running, you must stop the program manually or click
    the **stop collecting** button in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done that, Visual Studio shows you an overview of what it has
    collected.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.16: First results from a profiling session](img/B20924_12_16.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: First results from a profiling session'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are not that impressive since we have a straightforward program.
    However, you can see in the `_11_Profiling.PrimeCalculator.IsPrime(int)` method
    takes a lot of time: 10 microseconds, or 10.64% of the total time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is good to know, but we want to see whether we can get more information.
    Click on that line, and you will get another view. You can select what you want
    to see at the top of that view. By default, you see all data grouped by **Functions**,
    but I want to see the call path. If you do that, you get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.17: The hot path leading to the slowest function](img/B20924_12_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: The hot path leading to the slowest function'
  prefs: []
  type: TYPE_NORMAL
- en: You can click **Show Hot Path** and **Expand Hot Path** to see how the process
    came to the slowest function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can double-click on a line to see the source code. So, if you
    double-click on the `IsPrime()` method, you get this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.18: The slowest lines of code highlighted](img/B20924_12_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: The slowest lines of code highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it becomes clear that the loop is the slowest part of the `IsPrime()`
    function. That makes sense: to make this loop work, the CPU has to calculate `Math.Sqrt(number)`
    every time. That takes time. How to improve that is obvious: pre-calculate that
    square root and use that variable in the `for` statement. That should speed things
    up!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, with the proper tooling, you can identify the bottlenecks in
    your application. Once you find them, you can restructure your code or replace
    parts with something faster. But how do you know which algorithm to use to speed
    things up? The answer to that is this: benchmark them!'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking different solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I know that the `number % i ==0` line is not the fastest way to see whether
    a number is divisible by another number. However, I am not really sure how much
    quicker other ways are. To find out, I can use some benchmarking to figure it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways you can start with benchmarking, but in a case such as
    this, where I have several options for a specific algorithm, I like to use the
    `Benchmarkdotnet` NuGet package. This free package makes benchmarking simple.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, start a new console application. Add the `Benchmarkdotnet` package
    to the project. Then, create a new class. I call this class `ModuloTesters` since
    I want to test the performance of the `Module` operator and any alternatives I
    can find.
  prefs: []
  type: TYPE_NORMAL
- en: 'I added a method called `TestModulo`. That method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is pretty simple. I just go through several iterations (`numberOfLoopCount`
    is defined as a constant in my class, and I have set it to 100,000) and calculate
    the modulo (`testNumber` is again a constant; it doesn’t really matter what it
    is, but I have set it to 400). The only thing that makes this method stand out
    from a typical method is the `[Benchmark]` attribute. This tells the benchmark
    tool that this method needs to be measured.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main program file, we need to kickstart the benchmarking. That is extremely
    easy: just add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Set the build mode to `Release`, and run without debugging. The `Benchmark`
    tool will run the methods marked with `Benchmark` a couple of times (well, more
    than just a couple) and present you with the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we look at those results, we need to add something. Benchmarking
    is meant to compare solutions to a problem. Right now, we have one solution: the
    modulo operator. So, there is nothing to compare against. Let’s fix that. Add
    a new method to the `ModuloTesters` class that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another way of calculating a module. But is it faster? There is only
    one way to find out: run the benchmark! If you do that, you see the results. On
    my machine, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.19: Benchmark results](img/B20924_12_19.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Benchmark results'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the new algorithm is quicker: it takes 316.4 microseconds instead of 316.7
    microseconds. Ok, I admit it is not that much faster. Maybe we can do better.
    You know what? We can. Let’s add a third benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since all the calculations can be done independently, we can probably do them
    in parallel. So, that is what I am doing here: I use the `Parallel.For()` statement
    to divide the work into jobs that run simultaneously. I need a lock to update
    `numberOfMatches`, which might slow down the loop. But that is a guess: let’s
    test this. Run the benchmark. This is what I get:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.20: New benchmark results](img/B20924_12_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: New benchmark results'
  prefs: []
  type: TYPE_NORMAL
- en: Now, that is interesting. The addition of `Parallel.For()` made a massive difference
    in the time spent on that method.
  prefs: []
  type: TYPE_NORMAL
- en: If you think that could benefit your code, you can apply the findings to the
    actual application you are working on. Of course, I would profile it first, make
    the changes, and then profile again to see whether you have not added new bottlenecks.
    But all in all, I think we have made our prime calculator a lot faster!
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio is an excellent tool for debugging and profiling your system.
    However, it is not the only one. There are many other solutions out there that
    can help you debug and profile your code. Some of them are paid, others are free.
    Some are easy to use, some are pretty hard to get to know. I will not discuss
    the other tools, but I want to give you a small list so you can investigate them
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Please look at what Visual Studio gives you first. Chances are, what you need
    is already there!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many debugging tools out there. This is just a sample of what you
    can try out.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool Name** | **Description** | **Company** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Visual** **Studio Debugger** | Integrated into Visual Studio, supports
    .NET, C++, and other languages with breakpoints, watch variables, and more. |
    Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **WinDbg** | A multipurpose debugger for Windows, useful for debugging user-mode
    and kernel-mode code and analyzing crash dumps. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Visual Studio** **Code Debugger** | Built into Visual Studio Code, supports
    various languages and platforms through extensions, with breakpoints and variable
    inspection. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Managed** **Debugger (MDbg)** | A simple command-line debugger for .NET
    applications, offering basic debugging capabilities for managed code. | Microsoft
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Debug Diagnostic** **Tool (DebugDiag)** | Assists in troubleshooting application
    crashes, hangs, memory leaks, and performance issues in user-mode processes. |
    Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **ProcDump** | Command-line utility to monitor applications for CPU spikes
    and generate crash dumps for analysis. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Microsoft Performance** **Tools (PerfView)** | Performance analysis tool
    for collecting and analyzing ETW data, valuable for .NET application performance
    and memory issues. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Son of Strike (SOS) Debugging** **Extension** | An extension for WinDbg
    that provides insights into .NET runtime internals, aiding in-depth debugging
    of .NET applications. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Windows Performance** **Recorder (WPR)** | Tools for recording and analyzing
    performance data on Windows systems, capturing detailed system and application
    behavior. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Remote** **Debugging Tools** | Tools for debugging applications running
    on different machines or environments, supporting both managed and native code.
    | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **GNU** **Debugger (GDB)** | A powerful debugger for various programming
    languages, especially C and C++, to see what is happening inside a program. |
    GNU Project |'
  prefs: []
  type: TYPE_TB
- en: '| **LLVM** **Debugger (LLDB)** | A modern, high-performance debugger part of
    the LLVM project, supporting languages such as C, C++, and Objective-C. | LLVM
    Project |'
  prefs: []
  type: TYPE_TB
- en: '| **Valgrind** | A programming tool for memory debugging, memory leak detection,
    and profiling, including tools such as Memcheck. | Valgrind Developers |'
  prefs: []
  type: TYPE_TB
- en: '| **Strace** | A diagnostic, debugging, and instructional utility for Linux
    that traces system calls and signals. | Open Source |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.7: Debugging tools'
  prefs: []
  type: TYPE_NORMAL
- en: I do not endorse any of these products; I have merely listed them here for your
    convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Profiling tools are also easy to find. A lot of companies next to Microsoft
    offer solutions for this. They each have their own strengths and weaknesses. So,
    please look at the following table as a guideline to help you find what is best
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool Name** | **Description** | **Company** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Visual** **Studio Profiler** | Integrated into Visual Studio, provides
    detailed performance and memory usage data for .NET and C++ applications. | Microsoft
    |'
  prefs: []
  type: TYPE_TB
- en: '| **WPR** | Captures detailed performance data on Windows systems for in-depth
    analysis. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **Windows Performance** **Analyzer (WPA)** | Analyzes performance data collected
    by WPR, helping to identify performance issues. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **PerfView** | Collects and analyzes ETW data, useful for investigating performance
    and memory issues in .NET applications. | Microsoft |'
  prefs: []
  type: TYPE_TB
- en: '| **.NET** **Memory Profiler** | A powerful tool for finding memory leaks and
    optimizing memory usage in .NET applications. | SciTech Software |'
  prefs: []
  type: TYPE_TB
- en: '| **ANTS Performance** **Profiler** | Provides .NET code profiling to find
    performance bottlenecks, including memory usage and execution time analysis. |
    Redgate |'
  prefs: []
  type: TYPE_TB
- en: '| **JetBrains** **dotTrace** | A .NET profiler for performance, memory, and
    coverage analysis, integrated with Visual Studio. | JetBrains |'
  prefs: []
  type: TYPE_TB
- en: '| **VTune** **Profiler** | Performance analysis tool for C, C++, and Fortran
    applications, offering deep insights into CPU and GPU performance. | Intel |'
  prefs: []
  type: TYPE_TB
- en: '| **Valgrind** | Includes a suite of tools such as Cachegrind for cache profiling
    and Massif for heap profiling, primarily for C and C++ programs. | Valgrind Developers
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Google Performance** **Tools (gperftools)** | A suite of utilities for
    performance profiling and heap analysis, providing insights into CPU and memory
    usage. | Google |'
  prefs: []
  type: TYPE_TB
- en: '| **YourKit** **Profiler** | A profiler for Java and .NET applications, offering
    comprehensive CPU and memory profiling features. | YourKit |'
  prefs: []
  type: TYPE_TB
- en: '| **Perf** | A performance analyzing tool in Linux that provides detailed information
    on CPU performance, helping identify bottlenecks. | Linux Community |'
  prefs: []
  type: TYPE_TB
- en: '| **GlowCode** | A performance and memory profiler for Windows, focusing on
    C++ and .NET applications. | Electric Software Inc. |'
  prefs: []
  type: TYPE_TB
- en: '| **AQtime** | An advanced performance and memory profiling tool for various
    programming languages, integrated with Visual Studio. | SmartBear |'
  prefs: []
  type: TYPE_TB
- en: '| **Perfino** | A Java profiler for production environments, focusing on performance
    monitoring and problem resolution. | EJ Technologies |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.8: Profiling tools'
  prefs: []
  type: TYPE_NORMAL
- en: These tables do not contain all the tools available. New tools are added regularly,
    while others go away. I suggest you try some of them and stick to what works best
    for you. Maybe you prefer a CLI solution. Perhaps you want to work with a graphical
    tool. Whatever your preference is, there is always a tool that fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code inevitably means making mistakes. That is part of the fun of the
    job, I believe. Coming up with new ideas, making something out of nothing, and
    then making it work and improve is a great process. However, you can only do that
    when you have the right tools and know how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the debugging tools that Visual Studio provides.
    We looked at what debugging and profiling actually are, discovered the possibilities
    with breakpoints, and looked at the other helpful debug windows.
  prefs: []
  type: TYPE_NORMAL
- en: We also investigated how to deal with multithreaded applications and the debug
    challenges they give us. We looked at the windows that could help us and investigated
    deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: To top it off, we talked about profiling and benchmarking to uncover performance
    bottlenecks and how to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we now know how to tackle most of the issues in our code. However, we have
    one more important thing to discuss: how do we secure our code? What does that
    even mean? That is a big topic. It is so big that I have a complete chapter about
    it, and that is what is next. Please, follow along!'
  prefs: []
  type: TYPE_NORMAL
