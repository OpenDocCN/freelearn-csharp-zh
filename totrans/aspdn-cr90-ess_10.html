<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-161">
    <a id="_idTextAnchor162">
    </a>
    
     10
    
   </h1>
   <h1 id="_idParaDest-162">
    <a id="_idTextAnchor163">
    </a>
    
     Deploying and Hosting Applications
    
   </h1>
   <p>
    
     After following a good development process, implementing good practices, and covering all the functionalities required for an application, it’s necessary to publish it in an environment.
    
    
     For this to be done successfully, it’s important to understand various concepts, practices, and application packaging models that go beyond the source material.
    
    
     In this chapter, we’ll discuss different approaches to hosting and deploying applications, as well as understand concepts related
    
    <a id="_idIndexMarker795">
    </a>
    
     to
    
    <strong class="bold">
     
      continuous integration and continuous deployment
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI/CD
     
    </strong>
    
     )
    
    
     
      and
     
    
    
     <a id="_idIndexMarker796">
     </a>
    
    
     
      containers.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 provides a robust configuration system that allows developers to manage configurations and behaviors effectively.
    
    
     This chapter will explore the importance of application configurations, how to manage them using the configuration system, and how to make your applications adaptive
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     In this chapter, we’ll cover the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Preparing to publish your application and
     
     
      
       host locally
      
     
    </li>
    <li>
     
      Publishing the solution in a
     
     
      
       cloud environment
      
     
    </li>
    <li>
     
      Understanding the Docker principles and how to pack the application in
     
     
      
       a container
      
     
    </li>
    <li>
     
      Understanding the DevOps approach
     
     
      
       with CI/CD
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-163">
    <a id="_idTextAnchor164">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To complete this chapter, the following tools must be present in your
    
    
     
      development environment:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       An Azure subscription
      
     </strong>
     
      : In this chapter, we’ll be creating resources in Microsoft Azure.
     
     
      To do this, if you haven’t already, you will need to have an Azure subscription so that you can access the platform.
     
     
      You can sign up for a subscription with limited credits to learn about the concepts presented in this chapter
     
     
      
       at
      
     
     <a href="https://azure.microsoft.com/en-us/free">
      
       
        https://azure.microsoft.com/en-us/free
       
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       A Docker Hub account
      
     </strong>
     
      : You will need to create an account on the Docker Hub website
     
     
      
       at
      
     
     <a href="https://hub.docker.com">
      
       
        https://hub.docker.com
       
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       The Azure Tools extension
      
     </strong>
     
      : You will need to install the Azure Tools extension for Visual Studio Code from
     
     <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack">
      
       https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack
      
     </a>
     
      .
     
     
      Once it’s been installed, log in with your
     
     
      
       Azure credentials.
      
     
    </li>
   </ul>
   <p>
    
     The code examples for this chapter can be found in this book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter10
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-164">
    <a id="_idTextAnchor165">
    </a>
    
     Preparing to publish your application and host locally
    
   </h1>
   <p>
    
     Publishing an application is a natural process in the software development life cycle.
    
    
     After development and testing, the next step is to make the application available to users.
    
    
     This involves creating a deployable version of the application and configuring it in an environment where it can be accessed
    
    
     
      and used.
     
    
   </p>
   <p>
    
     Let’s understand the details of publishing applications while following various strategies, from manual to automated ones, using CI/CD.
    
    
     But before we do this, let’s understand some of the fundamentals, such as the importance of the
    
    
     
      publishing process.
     
    
   </p>
   <h2 id="_idParaDest-165">
    <a id="_idTextAnchor166">
    </a>
    
     The importance of the publishing process
    
   </h2>
   <p>
    
     The publishing process
    
    <a id="_idIndexMarker797">
    </a>
    
     transforms your application from source code into a deployable format.
    
    
     This process ensures that all dependencies, configurations, and compiled code are packaged together, making it easier to deploy and run the application in
    
    
     
      different environments.
     
    
   </p>
   <p>
    
     The publishing process in ASP.NET Core 9 involves
    
    
     
      three steps:
     
    
   </p>
   <ol>
    <li>
     
      Restoring
     
     
      
       the package.
      
     
    </li>
    <li>
     
      Compiling
     
     
      
       the application.
      
     
    </li>
    <li>
     
      Generating a
     
     <a id="_idIndexMarker798">
     </a>
     
      
       publishable package.
      
     
    </li>
   </ol>
   <p>
    
     The publication package
    
    <a id="_idIndexMarker799">
    </a>
    
     that’s generated may vary, depending on the type of application that’s developed.
    
    
     It may contain different files, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      The application’s
     
     
      
       DLL files
      
     
    </li>
    <li>
     
      Third-party dependencies
     
     
      
       and libraries
      
     
    </li>
    <li>
     
      Static files (for example, JavaScript, CSS,
     
     
      
       and images)
      
     
    </li>
    <li>
     
      Configuration files (for
     
     
      
       example,
      
     
     
      <strong class="source-inline">
       
        appsettings.json
       
      </strong>
     
     
      
       )
      
     
    </li>
    <li>
     
      Executables for
     
     
      
       standalone deployments
      
     
    </li>
   </ul>
   <p>
    
     To understand how this process works, follow the instructions provided in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section to download the example application from this book’s GitHub repository.
    
    
     This will be used as the basis for
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Now, let’s understand how to generate
    
    
     
      publishing packages.
     
    
   </p>
   <h2 id="_idParaDest-166">
    <a id="_idTextAnchor167">
    </a>
    
     Generating a publishing package
    
   </h2>
   <p>
    
     We’ve been working with
    
    <a id="_idIndexMarker800">
    </a>
    
     the .NET platform CLI tool extensively throughout this book to create and run applications.
    
    
     The CLI tool also has a specific command for generating publishing packages for ASP.NET Core
    
    
     
      9 projects.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      publish
     
    </strong>
    
     command provides various options that allow us to configure the publication package’s output, as listed in
    
    
     <em class="italic">
      
       Table 10.1
      
     </em>
    
    
     
      :
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-4">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Option
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Example
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          &lt;
         
        </strong>
        
         <strong class="source-inline">
          
           PROJECT&gt;
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies
        
        <a id="_idIndexMarker801">
        </a>
        
         the project file to operate on.
        
        
         Defaults to the current directory if
        
        
         
          not specified.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish project_name.csproj</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          -
         
        </strong>
        
         <strong class="source-inline">
          
           c
          
         </strong>
        
        
         
          ,
         
        
        
         <strong class="source-inline">
          
           --configuration
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Defines the build configuration (
        
        <strong class="bold">
         
          Debug
         
        </strong>
        
         or
        
        <strong class="bold">
         
          Release
         
        </strong>
        
         ).
        
        
         Defaults
        
        
         
          to
         
        
        
         <strong class="bold">
          
           Debug
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –c Release</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          -
         
        </strong>
        
         <strong class="source-inline">
          
           f
          
         </strong>
        
        
         
          ,
         
        
       </p>
       <p>
        <strong class="source-inline">
         
          --
         
        </strong>
        
         <strong class="source-inline">
          
           framework
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies the target framework – for
        
        
         
          example,
         
        
        
         <strong class="source-inline">
          
           net8.0
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –f net8.0</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          --
         
        </strong>
        
         <strong class="source-inline">
          
           runtime
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Publishes the application for a specific runtime (for example,
        
        <strong class="source-inline">
         
          win-x64
         
        </strong>
        
         ,
        
        <strong class="source-inline">
         
          linux-x64
         
        </strong>
        
         ,
        
        
         
          or
         
        
        
         <strong class="source-inline">
          
           osx-x64
          
         </strong>
        
        
         
          ).
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –runtime linux-x64</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          -
         
        </strong>
        
         <strong class="source-inline">
          
           o
          
         </strong>
        
        
         
          ,
         
        
        
         <strong class="source-inline">
          
           --output
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies the output directory for the
        
        
         
          published files.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –o ./publish</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          --
         
        </strong>
        
         <strong class="source-inline">
          
           self-contained
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Publishes the application as a self-contained deployment, including the .
        
        
         
          NET runtime.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –self-contained</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          --
         
        </strong>
        
         <strong class="source-inline">
          
           no-restore
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Disables the ability to restore project dependencies during the publish operation.
        
        
         Assumes restoration has already been done.
        
        
         It’s useful during
        
        
         
          CI/CD pipelines.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –no-restore</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          --
         
        </strong>
        
         <strong class="source-inline">
          
           manifest
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies one or more target manifests to calculate the set of packages to include in the
        
        
         
          published output.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –manifest ProjectManyfest.xml</pre>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          --
         
        </strong>
        
         <strong class="source-inline">
          
           version-suffix
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Sets the
        
        <strong class="source-inline">
         
          $(VersionSuffix)
         
        </strong>
        
         property
        
        <a id="_idIndexMarker802">
        </a>
        
         value to use when building
        
        <a id="_idIndexMarker803">
        </a>
        
         the project.
        
        
         Useful for
        
        
         
          prerelease versions.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <pre class="console">
dotnet publish –version-suffix beta1</pre>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 10.1 – dotnet publish CLI tool options
    
   </p>
   <p>
    
     The use of
    
    <a id="_idIndexMarker804">
    </a>
    
     each option will depend on each scenario.
    
    
     In our context, we’ll use the
    
    <strong class="source-inline">
     
      &lt;PROJECT&gt;
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      -c
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      -o
     
    </strong>
    
     , and, when necessary,
    
    <strong class="source-inline">
     
      --
     
    </strong>
    
     <strong class="source-inline">
      
       no-restore
      
     </strong>
    
    
     
      options.
     
    
   </p>
   <p>
    
     Now, let’s generate a publishing package
    
    <a id="_idIndexMarker805">
    </a>
    
     for
    
    <a id="_idIndexMarker806">
    </a>
    
     the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application.
    
    
     To do this, open your terminal or bash, access the previously downloaded application directory, and execute the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet publish UrlShortener.csproj -c Release -o ./published</pre>
   <p>
    
     The preceding command will generate the
    
    <strong class="source-inline">
     
      publish
     
    </strong>
    
     package in the
    
    <strong class="source-inline">
     
      published
     
    </strong>
    
     folder.
    
    
     However, it’s important to understand the
    
    <strong class="source-inline">
     
      -c
     
    </strong>
    
     parameter in
    
    
     
      more detail:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="source-inline">
      
       -c
      
     </strong>
     
      option specifies the build configuration, and there are typically two main configurations:
     
     <strong class="bold">
      
       Debug
      
     </strong>
     
      
       and
      
     
     
      <strong class="bold">
       
        Release
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Debug
        
       </strong>
       
        configuration includes additional debug information and is optimized for debugging.
       
       
        When running the project locally with the
       
       <strong class="source-inline">
        
         dotnet run
        
       </strong>
       
        command, the default configuration is
       
       <strong class="bold">
        
         Debug
        
       </strong>
       
        , which allows the debugging process to be
       
       
        
         carried out.
        
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Release
        
       </strong>
       
        configuration is optimized for performance and does not include debug information.
       
       
        It’s typically used to deploy the application to
       
       
        
         production environments.
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     When accessing the
    
    <strong class="source-inline">
     
      published
     
    </strong>
    
     folder, we have to simulate the
    
    
     
      directory/file structure:
     
    
   </p>
   <pre class="console">
publish/
├── appsettings.Development.json
├── appsettings.json
├── Azure.Core.dll
├── Azure.Identity.dll
├── Microsoft.Bcl.AsyncInterfaces.dll
├── Microsoft.Data.SqlClient.dll
├── Microsoft.EntityFrameworkCore.Abstractions.dll
├── Microsoft.EntityFrameworkCore.dll
├── Microsoft.EntityFrameworkCore.Relational.dll
├── Microsoft.EntityFrameworkCore.SqlServer.dll
├── Microsoft.Identity.Client.dll
├── Microsoft.Identity.Client.Extensions.Msal.dll
├── Microsoft.IdentityModel.Abstractions.dll
├── Microsoft.IdentityModel.JsonWebTokens.dll
├── Microsoft.IdentityModel.Logging.dll
├── Microsoft.IdentityModel.Protocols.dll
├── Microsoft.IdentityModel.Protocols.OpenIdConnect.dll
├── Microsoft.IdentityModel.Tokens.dll
├── Microsoft.SqlServer.Server.dll
├── Microsoft.Win32.SystemEvents.dll
├── runtimes/
│ ├── (runtime-specific files and directories)
├── System.Configuration.ConfigurationManager.dll
├── System.Drawing.Common.dll
├── System.IdentityModel.Tokens.Jwt.dll
├── System.Memory.Data.dll
├── System.Runtime.Caching.dll
├── System.Security.Cryptography.ProtectedData.dll
├── System.Security.Permissions.dll
├── System.Windows.Extensions.dll
├── UrlShortener
├── web.config
└──wwwroot/
├── (static files like css, js, images)</pre>
   <p>
    
     As we can see, there are
    
    <a id="_idIndexMarker807">
    </a>
    
     several
    
    <strong class="source-inline">
     
      .dll
     
    </strong>
    
     files, which are
    
    <a id="_idIndexMarker808">
    </a>
    
     the dependencies that the application uses, in addition to static files such as
    
    <strong class="source-inline">
     
      wwwroot
     
    </strong>
    
     and
    
    
     
      configuration files.
     
    
   </p>
   <p>
    
     The contents of this folder are exactly what should be published in an environment, be it locally or via a
    
    
     
      cloud provider.
     
    
   </p>
   <p>
    
     By accessing the
    
    <strong class="source-inline">
     
      published
     
    </strong>
    
     directory through the terminal and executing the following command, it’s possible to run
    
    
     
      the application:
     
    
   </p>
   <pre class="console">
dotnet UrlShorterner.dll</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      UrlShorterner.dll
     
    </strong>
    
     file is the executable for an ASP.NET Core 9 application.
    
    
     It’s possible to run the application through the
    
    <strong class="source-inline">
     
      .dll
     
    </strong>
    
     file on your development machine since the .NET SDK is installed.
    
    
     The SDK must not be installed on servers that will run the applications.
    
    
     For this, you only need to install
    
    <strong class="bold">
     
      .
     
    </strong>
    
     <strong class="bold">
      
       NET Runtime
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     .NET Runtime
    
   </p>
   <p class="callout">
    
     .NET Runtime is a
    
    <a id="_idIndexMarker809">
    </a>
    
     software framework developed by Microsoft that provides a managed execution environment for running .NET applications.
    
    
     It includes the components needed to run .NET programs, manage memory, handle exceptions, and collect garbage.
    
    
     .NET Runtime is typically installed on servers and machines that run specific .NET applications.
    
    
     Unlike the .NET SDK, .NET Runtime has features for running applications rather than building and developing them.
    
    
     To learn
    
    <a id="_idIndexMarker810">
    </a>
    
     more about .NET Runtime, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/core/introduction">
     
      
       https://learn.microsoft.com/en-us/dotnet/core/introduction
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The .NET platform and ASP.NET Core 9 are portable, which means they can be run on different operating systems that have the SDK or .NET Runtime installed.
    
    <em class="italic">
     
      Table 10.2
     
    </em>
    
     shows the application servers that can be used in each of the most important
    
    
     
      operating systems:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002-1">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Operating System
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Prerequisites
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Linux
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <ul>
        <li>
         
          .NET
         
         
          
           SDK/Runtime, Kestrel
          
         
        </li>
        <li>
         
          Optional: Nginx/Apache,
         
         
          
           Hosting bundle
          
         
        </li>
       </ul>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          macOS
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <ul>
        <li>
         
          .NET
         
         
          
           SDK/Runtime, Kestrel
          
         
        </li>
        <li>
         
          
           Optional: Nginx/Apache
          
         
        </li>
       </ul>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Windows
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <ul>
        <li>
         
          .NET
         
         
          
           SDK/Runtime, Kestrel
          
         
        </li>
        <li>
         
          Optional: IIS, NGINX, HTTP.sys, ASP.NET Core
         
         
          
           Hosting bundle
          
         
        </li>
       </ul>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 10.2 – Web server options for ASP.NET Core 9 applications
    
   </p>
   <p>
    
     Generating publication packages using the CLI tool is straightforward.
    
    
     We’ll follow this process while automating via CI/CD, something we’ll cover in the
    
    <em class="italic">
     
      Understanding the DevOps approach with
     
    </em>
    
     <em class="italic">
      
       CI/CD
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     Now that we’ve learned how to generate publishing packages, it’s time to learn how to publish them in a
    
    
     
      cloud environment.
     
    
   </p>
   <h1 id="_idParaDest-167">
    <a id="_idTextAnchor168">
    </a>
    
     Publishing the solution in a cloud environment
    
   </h1>
   <p>
    
     The advantage of developing modern applications with ASP.NET Core 9 goes beyond the ability to use implementation best practices – it also encompasses the need to deliver high-quality solutions to
    
    
     
      application users.
     
    
   </p>
   <p>
    
     So far, we’ve learned about the importance of using various features of the .NET platform, such as using the .NET CLI to compile applications and install support tools such as Entity Framework Core.
    
    
     We’ve also learned about the process of generating publishable packages that can be run both locally and in any other environment that uses .
    
    
     
      NET Runtime.
     
    
   </p>
   <p>
    
     At the time of writing, it’s impossible not to work in a cloud environment.
    
    
     This offers us benefits such as elasticity, availability, security, and many other features that simplify the process of deploying, maintaining, and evolving applications through the continuous process of
    
    
     
      delivering value.
     
    
   </p>
   <p>
    
     To learn how to publish the solution in a cloud environment, we’ll use Azure as our
    
    
     
      cloud provider.
     
    
   </p>
   <p>
    
     Moving an ASP.NET Core 9 application to Azure allows developers to benefit from the dynamic capabilities provided by such a cloud provider while focusing on the application context and business objectives.
    
    
     Azure, through its diverse resources and services, allows applications to handle varied workloads, remain accessible to users, and stay protected against
    
    
     
      security threats.
     
    
   </p>
   <p>
    
     Based on the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application that we worked on previously and in conjunction with the process of generating publishable packages, we’ll implement the benefits of Azure and publish this application in a
    
    
     
      cloud environment.
     
    
   </p>
   <h2 id="_idParaDest-168">
    <a id="_idTextAnchor169">
    </a>
    
     Creating Azure app services and database resources
    
   </h2>
   <p>
    
     The Azure environment provides different types of resources for publishing applications, at different service levels and with varying
    
    
     
      publishing approaches.
     
    
   </p>
   <p>
    
     For this application, we’ll use a
    
    <a id="_idIndexMarker811">
    </a>
    
     resource called
    
    <strong class="bold">
     
      App Service
     
    </strong>
    
     , a
    
    <strong class="bold">
     
      Platform-as-a-Service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PaaS
     
    </strong>
    
     ) offering
    
    <a id="_idIndexMarker812">
    </a>
    
     provided by Azure that allows us to focus on our applications.
    
    
     App Service provides a great application server while also supplying us with a URL to access the
    
    
     
      published application.
     
    
   </p>
   <p>
    
     You must have prepared your environment based on the information provided in the
    
    <em class="italic">
     
      Technical
     
    </em>
    
     <em class="italic">
      
       requirements
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p class="callout-heading">
    
     Application services and PaaS
    
   </p>
   <p class="callout">
    
     Azure App Service is a
    
    <a id="_idIndexMarker813">
    </a>
    
     fully managed PaaS that allows developers to build, deploy, and scale web applications, mobile backends, and RESTful APIs in the programming language of their choice, without the need for infrastructure management.
    
    
     App Service provides a prepared server, providing the runtime needed to run your applications.
    
    
     The PaaS approach is a cloud computing model that provides a complete development and deployment environment in the cloud, freeing developers from the need to deal with infrastructure.
    
    
     For more details, see the
    
    <a id="_idIndexMarker814">
    </a>
    
     Azure App Service
    
    
     
      documentation:
     
    
    <a href="https://docs.microsoft.com/en-us/azure/app-service/">
     
      
       https://docs.microsoft.com/en-us/azure/app-service/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Our goal will not be to exhaust all resource options available in the Azure environment since a separate book dedicated to this subject would
    
    
     
      be needed.
     
    
   </p>
   <p>
    
     Instead, we’ll focus on publishing the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application while using Azure App Service as the
    
    
     
      web host.
     
    
   </p>
   <p>
    
     Follow these steps to
    
    <a id="_idIndexMarker815">
    </a>
    
     publish
    
    
     
      the application:
     
    
   </p>
   <ol>
    <li>
     
      Access the Azure
     
     
      
       portal (
      
     
     <a href="https://portal.azure.com">
      
       
        https://portal.azure.com
       
      
     </a>
     
      
       ).
      
     
    </li>
    <li>
     
      On the main screen, click on the
     
     <strong class="bold">
      
       Create a resource
      
     </strong>
     
      button, as shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     
      <em class="italic">
       
        .1
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.1 – Creating a new Azure resource" src="img/B21788_10_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.1 – Creating a new Azure resource
    
   </p>
   <ol>
    <li value="3">
     
      Then, select
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      under the
     
     <strong class="bold">
      
       Web App
      
     </strong>
     
      resource, as shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     
      <em class="italic">
       
        .2
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.2 – Creating a new Web App resource" src="img/B21788_10_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.2 – Creating a new Web App resource
    
   </p>
   <ol>
    <li value="4">
     
      On the
     
     <strong class="bold">
      
       Basics creation
      
     </strong>
     
      screen of the new
     
     <strong class="bold">
      
       Web App
      
     </strong>
     
      resource, fill in the information
     
     <a id="_idIndexMarker816">
     </a>
     
      provided in
     
     
      <em class="italic">
       
        Table 10.3
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <table class="No-Table-Style _idGenTablePara-1" id="table003">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Parameter
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Value
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Subscription
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Select
        
        
         
          your subscription.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A subscription is necessary to onboard the resources and
        
        
         
          related costs.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Resource Group
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Here, the value is
        
        <strong class="source-inline">
         
          rg-aspnetcore8
         
        </strong>
        
         .
        
        
         If this resource group doesn’t exist, click on
        
        <strong class="bold">
         
          Create new link
         
        </strong>
        
         below the
        
        <strong class="bold">
         
          Resource Group
         
        </strong>
        
         field and
        
        
         
          create it.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The resource is a logical group of resources
        
        
         
          in Azure.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Name
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          urlshortener.&lt;your
         
        </strong>
        
         <strong class="source-inline">
          
           last name&gt;
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         This parameter will be the URL of your application.
        
        
         Please keep
        
        
         
          it unique.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Publish
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Code
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         App Service has different ways to host and publish applications.
        
        
         In this case, we’re using the
        
        <strong class="bold">
         
          Code
         
        </strong>
        
         option because we’ll publish the
        
        
         
          generated package.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Runtime stack
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         
          .NET
         
        </strong>
        
         <strong class="bold">
          
           9 (LTS)
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         This parameter defines the type of application that will be hosted on App Service.
        
        
         It supports .NET, Node.js, Java, PHP,
        
        
         
          and Python.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Operational System
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Linux.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Linux is a good option for many use cases.
        
        
         However, for this exercise, you can select Windows as well.
        
        
         The definition of the operating system depends on the requirements of
        
        
         
          the application.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Region
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           EastUS 2
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The region where App Service will be hosted.
        
        
         We’re using
        
        <strong class="bold">
         
          East US 2
         
        </strong>
        
         because the database we’ll be creating is not available in the East
        
        
         
          US region.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Linux Pan
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Leave as-is.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         We’ll be creating a new service plan to host the application.
        
        
         The service plan is an important component of App Service.
        
        
         Depending on the pricing plan, the service plan can host more than
        
        
         
          one application.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Pricing plan
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Basic B1
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The
        
        <strong class="bold">
         
          Basic B1
         
        </strong>
        
         option is enough for this example.
        
        
         Keep in mind that if you select a different Pricing plan, you can be charged
        
        
         
          higher costs.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Zone redundancy
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Disabled.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         This parameter is used in production environments where applications require a
        
        
         
          high-availability configuration.
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 10.3 – Basic parameters of the new Web App resource
    
   </p>
   <p>
    
     5.
    
    
     Click
    
    <a id="_idIndexMarker817">
    </a>
    
     on the
    
    <strong class="bold">
     
      Next: Database &gt;
     
    </strong>
    
     
      button.
     
    
   </p>
   <p>
    
     6.
    
    
     Select the
    
    <strong class="bold">
     
      Create a database
     
    </strong>
    
     option and fill in the parameters as per
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.3 – Database server configuration" src="img/B21788_10_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.3 – Database server configuration
    
   </p>
   <p class="list-inset">
    
     At this stage, we’re configuring a database, which is necessary for the
    
    <strong class="bold">
     
      URLShortener
     
    </strong>
    
     application.
    
    
     We’ll use the Azure SQL Server resource since it provides a server where you can host different databases.
    
    
     For this example, we’re using just one database.
    
    
     However, if desired, other databases can be
    
    
     
      added later.
     
    
   </p>
   <p>
    
     7.
    
    
     Now, click on the
    
    <strong class="bold">
     
      Monitor + Secure
     
    </strong>
    
     tab and set the
    
    <strong class="bold">
     
      Enable Application Insights
     
    </strong>
    
     option
    
    
     
      to
     
    
    
     <strong class="bold">
      
       No
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="list-inset">
    
     This option aims to create a monitoring resource for the application.
    
    
     This is a best practice, especially for production resources.
    
    
     Therefore, at this stage, the objective is to publish the application; there’s no need for monitoring, something that can be
    
    
     
      added later.
     
    
   </p>
   <p>
    
     8.
    
    
     Next, click
    
    <strong class="bold">
     
      Review and Create
     
    </strong>
    
     .
    
    
     Then, click
    
    <strong class="bold">
     
      Create
     
    </strong>
    
     and wait for the resource to
    
    
     
      be created.
     
    
   </p>
   <p>
    
     9.
    
    
     On the review
    
    <a id="_idIndexMarker818">
    </a>
    
     screen, in the
    
    <strong class="bold">
     
      Database
     
    </strong>
    
     section, you’ll see username and password information, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     .
    
    
     Copy those details and keep them handy; we’ll need the password later to configure
    
    
     
      the database:
     
    
   </p>
   <div><div><img alt="Figure 10.4 – Database credentials" src="img/B21788_10_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.4 – Database credentials
    
   </p>
   <p>
    
     10.
    
    
     Finally, click
    
    <strong class="bold">
     
      Create
     
    </strong>
    
     and wait for the resource to
    
    
     
      be created.
     
    
   </p>
   <p>
    
     11.
    
    
     Once the resource has been created, click the
    
    <strong class="bold">
     
      Go to resource
     
    </strong>
    
     button, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .5
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.5: Resource created screen" src="img/B21788_10_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.5: Resource created screen
    
   </p>
   <p class="list-inset">
    
     You will be redirected to the previously created
    
    <strong class="bold">
     
      App Service
     
    </strong>
    
     settings
    
    
     
      summary screen.
     
    
   </p>
   <p class="list-inset">
    
     As shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     , you’ll be able to see the
    
    <strong class="bold">
     
      Default domain
     
    </strong>
    
     URL that’s been made
    
    <a id="_idIndexMarker819">
    </a>
    
     available so that you can access
    
    
     
      the application:
     
    
   </p>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 10.6 – Default domain URL of the created application services" src="img/B21788_10_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.6 – Default domain URL of the created application services
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Default domain
     
    </strong>
    
     URL is automatically created by Azure, according to the parameters defined when creating the application services and can be customized with a custom domain.
    
    
     We’ll keep the URL available and in operation.
    
    
     Upon clicking on the URL, you’ll be redirected to a page containing information similar to what’s shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .7
      
     </em>
    
    
     
      :
     
    
   </p>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 10.7 – Default website content of the new application services" src="img/B21788_10_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.7 – Default website content of the new application services
    
   </p>
   <p>
    
     At this point, the
    
    <a id="_idIndexMarker820">
    </a>
    
     server is up and running, but we must publish the application on Azure.
    
    
     However, before publishing the application, let’s configure
    
    
     
      the database.
     
    
   </p>
   <h2 id="_idParaDest-169">
    <a id="_idTextAnchor170">
    </a>
    
     Configuring Azure SQL Server
    
   </h2>
   <p>
    
     While creating our
    
    <a id="_idIndexMarker821">
    </a>
    
     application services, other resources were created, such as the database server and
    
    
     
      the database.
     
    
   </p>
   <p>
    
     We need to configure the database so that we have the table we used in the application to persist
    
    
     
      the URLs.
     
    
   </p>
   <p>
    
     We’ll use the Entity Framework Core tool to update the database in the same way we did it locally.
    
    
     However, the database service that’s automatically created by Azure is publicly inaccessible for
    
    
     
      security reasons.
     
    
   </p>
   <p>
    
     To do this, we must make some configuration changes in advance so that we can manipulate the database.
    
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Go to the previously created resource group – that is,
     
     <strong class="bold">
      
       rg-aspnetcore8
      
     </strong>
     
      .
     
     
      You will be able to see a list of
     
     
      
       created resources.
      
     
    </li>
    <li>
     
      Search for the
     
     <strong class="bold">
      
       UrlshortenerDB
      
     </strong>
     
      resource and
     
     
      
       access it.
      
     
    </li>
    <li>
     
      Then, in the
     
     <strong class="bold">
      
       Settings
      
     </strong>
     
      menu group, click
     
     
      <strong class="bold">
       
        Connection Strings
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      The connection string should look
     
     
      
       like this:
      
     
     <pre class="source-code">
Server=tcp:urlshortener-db-server-tanure.database.windows.net,1433;Initial Catalog=UrlshortenerDB;Persist Security Info=False;User ID=urlshortener-db-server-tanure-admin;<strong class="bold">Password={your_password}</strong>; MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;</pre>
    </li>
    <li>
     
      Note the
     
     <strong class="source-inline">
      
       Password={your_password}
      
     </strong>
     
      parameter.
     
     
      Replace this parameter with the password that you copied when you were creating your
     
     
      
       application services.
      
     
    </li>
    <li>
     
      Copy the
     
     <a id="_idIndexMarker822">
     </a>
     
      connection string from the
     
     <strong class="bold">
      
       ADO.NET (SQL
      
     </strong>
     
      <strong class="bold">
       
        Authentication)
       
      </strong>
     
     
      
       field.
      
     
    </li>
    <li>
     
      Now, open the
     
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
     
      file of the
     
     <strong class="bold">
      
       URLShortener
      
     </strong>
     
      application and change the
     
     <strong class="source-inline">
      
       DefaultConnection
      
     </strong>
     
      property to the connection string you copied previously.
     
     
      The result will look
     
     
      
       like this:
      
     
     <pre class="source-code">
"Logging": {
  "LogLevel": {
    "Default": "Information",
    "Microsoft.AspNetCore": "Warning"
  }
},
"ConnectionStrings": {
  "DefaultConnection":
    "Server=tcp:urlshortener-db-server-tanure.database.windows.net,1433;Initial Catalog=UrlshortenerDB;Persist Security Info=False;User ID=urlshortener-db-server-tanure-admin;Password=XL6l61uv9t4$K4Q6;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
  },
  "AllowedHosts": "*"
}</pre>
    </li>
    <li>
     
      Save the
     
     
      <strong class="source-inline">
       
        appsettings.json
       
      </strong>
     
     
      
       file.
      
     
    </li>
    <li>
     
      Now, let’s configure access to the database server.
     
     
      To do this, go back to the
     
     <strong class="bold">
      
       rg-aspnetcore8
      
     </strong>
     
      resource group and click on the
     
     <strong class="bold">
      
       urlshortener-db-server&lt;your last
      
     </strong>
     
      <strong class="bold">
       
        name&gt;
       
      </strong>
     
     
      
       resource.
      
     
    </li>
    <li>
     
      From the main
     
     <a id="_idIndexMarker823">
     </a>
     
      menu, go to
     
     <strong class="bold">
      
       Security
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Networking
      
     </strong>
     
      and click on the
     
     <strong class="bold">
      
       Add your client IPv4 address
      
     </strong>
     
      option, as shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     
      <em class="italic">
       
        .8
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.8 – Adding a firewall rule to access the private database of an IPv4 address" src="img/B21788_10_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.8 – Adding a firewall rule to access the private database of an IPv4 address
    
   </p>
   <p class="list-inset">
    
     This configuration will create a rule so that the database is only accessible via its current IP.
    
    
     Keep in mind that if your IP changes, you will have to perform these steps again to add the
    
    
     
      new IP.
     
    
   </p>
   <ol>
    <li value="11">
     
      Finally,
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Save
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     With this, we’ve
    
    <a id="_idIndexMarker824">
    </a>
    
     configured the application for the connection string of the database hosted in Azure and added a firewall rule so that the database can be accessed through our
    
    
     
      current IP.
     
    
   </p>
   <p>
    
     Now, we need to update the database.
    
    
     To do this, access your operating system’s terminal and navigate to the
    
    <strong class="bold">
     
      URLShortener
     
    </strong>
    
     project directory.
    
    
     Then, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet ef database update</pre>
   <p>
    
     Wait for the process to complete.
    
    
     To check whether the table was created correctly, in the Azure portal (
    
    <a href="https://portal.azure.com">
     
      https://portal.azure.com
     
    </a>
    
     ), access the
    
    <strong class="bold">
     
      rg-aspnetcore9
     
    </strong>
    
     resource group, then access the
    
    <strong class="bold">
     
      UrlShortenerDB
     
    </strong>
    
     resource.
    
    
     Click on the
    
    <strong class="bold">
     
      Query Editor
     
    </strong>
    
     menu and access the database with the credentials that were provided when you were creating the
    
    
     
      application service.
     
    
   </p>
   <p>
    
     As shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .9
     
    </em>
    
     , the new table has
    
    
     
      been created:
     
    
   </p>
   <div><div><img alt="Figure 10.9 – The database tables that were created using Entity Framework Core migrations" src="img/B21788_10_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.9 – The database tables that were created using Entity Framework Core migrations
    
   </p>
   <p>
    
     This is one of the benefits of using migrations through Entity Framework Core.
    
    
     By doing this, it’s possible to apply changes to a local database or server and maintain compliance with the
    
    
     
      application code.
     
    
   </p>
   <p>
    
     Now that the database has been configured, it’s time to publish the application.
    
    
     We’ll do this through Visual
    
    
     
      Studio Code.
     
    
   </p>
   <h2 id="_idParaDest-170">
    <a id="_idTextAnchor171">
    </a>
    
     Publishing an application with Visual Studio Code
    
   </h2>
   <p>
    
     With all the prerequisites for
    
    <a id="_idIndexMarker825">
    </a>
    
     hosting the
    
    <a id="_idIndexMarker826">
    </a>
    
     application in Azure configured, it’s time to publish
    
    
     
      the application.
     
    
   </p>
   <p>
    
     The process of publishing via Visual Studio Code or even with Visual Studio is
    
    
     
      quite straightforward.
     
    
   </p>
   <p>
    
     In the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section, it was suggested that you install and configure the Azure Tools extension
    
    <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack">
     
      (https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-node-azure-pack
     
    </a>
    
     ).
    
    
     This extension makes the manual publishing
    
    
     
      process easier.
     
    
   </p>
   <p>
    
     Follow these steps to publish the application version in the application services we
    
    
     
      created previously:
     
    
   </p>
   <ol>
    <li>
     
      Access the
     
     <strong class="bold">
      
       UrlShortener
      
     </strong>
     
      application directory and run the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">code .</strong></pre>
    </li>
    <li>
     
      Then, click on the Azure Tools extension icon in Visual Studio Code, as shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     
      <em class="italic">
       
        .10
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.10 – Azure Tools in Visual Studio Code" src="img/B21788_10_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.10 – Azure Tools in Visual Studio Code
    
   </p>
   <p class="list-inset">
    
     A list of
    
    <a id="_idIndexMarker827">
    </a>
    
     subscriptions that are
    
    <a id="_idIndexMarker828">
    </a>
    
     available to your user will be displayed.
    
    
     By expanding the subscription, we’ll be able to see the App Service resource and the resource that’s been created for the
    
    
     <strong class="bold">
      
       UrlShortener
      
     </strong>
    
    
     
      application.
     
    
   </p>
   <ol>
    <li value="3">
     
      Now, right-click on the
     
     <strong class="bold">
      
       urlshortener-&lt;your last name&gt;
      
     </strong>
     
      application and select the
     
     <strong class="bold">
      
       Deploy to Web App…
      
     </strong>
     
      option, as shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     
      <em class="italic">
       
        .11
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.11 – Deploying a web app using the Azure Tools extensions in Visual Studio Code" src="img/B21788_10_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.11 – Deploying a web app using the Azure Tools extensions in Visual Studio Code
    
   </p>
   <ol>
    <li value="4">
     
      You’ll be
     
     <a id="_idIndexMarker829">
     </a>
     
      asked for some configuration details so that you can deploy.
     
     
      Just confirm the options that are
     
     <a id="_idIndexMarker830">
     </a>
     
      provided and wait for the deployment process
     
     
      
       to complete.
      
     
    </li>
    <li>
     
      After the publication process is complete, a notification similar to the one shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     <em class="italic">
      
       .12
      
     </em>
     
      will
     
     
      
       be displayed:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.12 – A notification stating that application deployment has been completed" src="img/B21788_10_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.12 – A notification stating that application deployment has been completed
    
   </p>
   <ol>
    <li value="6">
     
      You can navigate to the published website by clicking the
     
     <strong class="bold">
      
       Browse Website
      
     </strong>
     
      button.
     
     
      You’ll see a result similar to the one shown in
     
     
      <em class="italic">
       
        Figure 10
       
      </em>
     
     
      <em class="italic">
       
        .13
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.13 – The URL Shortener application running on Azure" src="img/B21788_10_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.13 – The URL Shortener application running on Azure
    
   </p>
   <p>
    
     Now, you can use the
    
    <a id="_idIndexMarker831">
    </a>
    
     application that
    
    <a id="_idIndexMarker832">
    </a>
    
     contains the short URL functionality directly in your Azure
    
    
     
      environment publicly.
     
    
   </p>
   <p>
    
     The Azure Tools extension
    
    <a id="_idIndexMarker833">
    </a>
    
     automates the process of publishing new application versions by running the following processes in
    
    
     
      the background:
     
    
   </p>
   <ul>
    <li>
     
      
       Restoring packages
      
     
    </li>
    <li>
     
      Compiling
     
     
      
       the application
      
     
    </li>
    <li>
     
      Generating a
     
     
      
       publishing package
      
     
    </li>
    <li>
     
      Compressing the publishing package in
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        zip
       
      </strong>
     
     
      
       format
      
     
    </li>
    <li>
     
      Connecting to the
     
     
      
       Azure environment
      
     
    </li>
    <li>
     
      Deploying the ZIP file containing the
     
     
      
       publication package
      
     
    </li>
    <li>
     
      Extracting the
     
     
      
       ZIP file
      
     
    </li>
   </ul>
   <p>
    
     These steps are performed every time you choose to deploy using the Azure Tools extension.
    
    
     We’ll learn about another way to publish packages in a C/ICD model in the
    
    <em class="italic">
     
      Understanding DevOps approach with CI/CD
     
    </em>
    
     section of
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Hosting solutions in cloud environments is a necessary activity today and several resources can help us with
    
    
     
      this task.
     
    
   </p>
   <p>
    
     The definition of each hosting resource and service layer will depend on the application requirements, as well as the team’s level of knowledge.
    
    
     There are cases where we can use strategies that allow us to host our applications in different environments, in a way that’s agnostic to the specific resources of
    
    
     
      cloud providers.
     
    
   </p>
   <p>
    
     To achieve this, a strategy that’s often used in cloud-native applications is the containers strategy.
    
    
     We’ll learn about this in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-171">
    <a id="_idTextAnchor172">
    </a>
    
     Understanding the Docker principles and how to package the application in a container
    
   </h1>
   <p>
    
     Nowadays, using a container strategy has become essential, especially for cloud-native applications.
    
    
     Containers provide a consistent environment for development, testing, and deployment, ensuring applications run smoothly regardless of where they’re deployed.
    
    
     When using containers, we practically have everything needed for the application to run in a given environment, with no need to install additional packages
    
    
     
      or runtimes.
     
    
   </p>
   <p>
    
     With this, we have consistency, which is crucial for cloud environments such as Azure or any other cloud provider as they offer robust services to manage and scale containerized applications.
    
    
     As an analogy, the container strategy helps combat the behavior that generates the statement “
    
    <em class="italic">
     
      It works on
     
    </em>
    
     <em class="italic">
      
       my machine.
      
     </em>
    
    
     
      ”
     
    
   </p>
   <p>
    
     This phrase is true since the development environment has everything necessary to run an application.
    
    
     However, being agile in delivering value and having no dependencies for running applications, regardless of the environment, is one of the great advantages of containers.
    
    
     Before we create a container, let’s understand what
    
    
     
      they are.
     
    
   </p>
   <h2 id="_idParaDest-172">
    <a id="_idTextAnchor173">
    </a>
    
     Understanding what a container is
    
   </h2>
   <p>
    
     A container
    
    <a id="_idIndexMarker834">
    </a>
    
     is a self-contained executable software package that includes everything needed to run a piece of software.
    
    
     Containers are isolated from each other and the host system, providing a consistent runtime environment.
    
    
     This isolation ensures that the application behaves the same regardless of the environment in which
    
    
     
      it runs.
     
    
   </p>
   <p>
    
     Containers provide a type of virtualization
    
    <a id="_idIndexMarker835">
    </a>
    
     that’s different from what’s provided by traditional
    
    <strong class="bold">
     
      virtual
     
    </strong>
    
     <strong class="bold">
      
       machines
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       VMs
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p class="callout-heading">
    
     VMs
    
   </p>
   <p class="callout">
    
     VMs are
    
    <a id="_idIndexMarker836">
    </a>
    
     software emulations of physical computers.
    
    
     Each VM runs a complete operating system, including its own kernel, and simulates all the hardware that the operating system requires.
    
    
     VMs run on a hypervisor, which manages multiple VMs on a single
    
    
     
      physical host.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .14
     
    </em>
    
     shows some of the differences between
    
    <a id="_idIndexMarker837">
    </a>
    
     containers
    
    
     
      and
     
    
    
     <a id="_idIndexMarker838">
     </a>
    
    
     
      VMs:
     
    
   </p>
   <div><div><img alt="Figure 10.14 – Differences between containers and VMs" src="img/B21788_10_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.14 – Differences between containers and VMs
    
   </p>
   <p>
    
     As we can see, containers don’t depend on a complete operating system for their execution, only on a runtime that shares a machine’s resources, such as networking and processing.
    
    
     However, they are executed independently and
    
    
     
      in isolation.
     
    
   </p>
   <p>
    
     Containers
    
    <a id="_idIndexMarker839">
    </a>
    
     offer
    
    
     
      several benefits:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Portability
      
     </strong>
     
      : Containers
     
     <a id="_idIndexMarker840">
     </a>
     
      encapsulate all dependencies, making it easy to move applications between different environments without compatibility
     
     
      
       issues occurring.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Consistency
      
     </strong>
     
      : They ensure that applications run consistently across development, testing, and
     
     
      
       production environments.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scalability
      
     </strong>
     
      : They can easily be scaled up or down to handle varying loads, making them ideal for
     
     
      
       cloud environments.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Efficiency
      
     </strong>
     
      : Containers share the kernel and host system resources efficiently, resulting in lower overhead compared to
     
     <a id="_idIndexMarker841">
     </a>
     
      
       traditional VMs.
      
     
    </li>
   </ul>
   <p>
    
     To be able to run a container, it’s necessary to use a runtime to manage it, as is the case with ASP.NET Core 9 applications.
    
    
     The most famous container
    
    <a id="_idIndexMarker842">
    </a>
    
     runtime is
    
    <strong class="bold">
     
      Docker
     
    </strong>
    
     .
    
    
     We’ll understand its fundamentals in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-173">
    <a id="_idTextAnchor174">
    </a>
    
     Understanding Docker fundamentals
    
   </h2>
   <p>
    
     Docker
    
    <a id="_idIndexMarker843">
    </a>
    
     is an open source platform that automates the process of deploying, scaling, and managing containerized applications, providing a simple and powerful way to build, ship, and
    
    
     
      operate containers.
     
    
   </p>
   <p>
    
     Docker provides three components for
    
    
     
      managing containers:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Docker Engine
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker844">
     </a>
     
      runtime that
     
     
      
       manages containers
      
     
    </li>
    <li>
     <strong class="bold">
      
       Docker CLI
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker845">
     </a>
     
      command-line interface used to interact
     
     
      
       with Docker
      
     
    </li>
    <li>
     <strong class="bold">
      
       Docker Hub
      
     </strong>
     
      : A
     
     <a id="_idIndexMarker846">
     </a>
     
      cloud-based registry service for sharing and storing Docker images, similar to how we have GitHub for managing source
     
     
      
       code repositories
      
     
    </li>
   </ul>
   <p>
    
     Through these tools, Docker provides mechanisms that allow us to manipulate the components that involve the container development strategy.
    
    
     In this case, containers have the
    
    
     
      following components:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Images
      
     </strong>
     
      : An image
     
     <a id="_idIndexMarker847">
     </a>
     
      can be compared to a photo of a current version of your application, including everything needed to run your application.
     
     
      Images are the basis of containers and are created using
     
     <a id="_idIndexMarker848">
     </a>
     
      a
     
     <strong class="bold">
      
       Dockerfile
      
     </strong>
     
      , which contains a set of instructions for building
     
     
      
       the image.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Containers
      
     </strong>
     
      : A container
     
     <a id="_idIndexMarker849">
     </a>
     
      is a running instance of an image.
     
     
      We can relate an image to a class and a container to an instance of this class.
     
     
      Containers are created from images and run on Docker Engine.
     
     
      Each container is isolated from the others and has its own filesystem, CPU, memory, and
     
     
      
       process space.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Dockerfile
      
     </strong>
     
      : A Dockerfile
     
     <a id="_idIndexMarker850">
     </a>
     
      is a text document that contains a series of instructions on how to build a Docker image.
     
     
      It specifies the base image to use, the application code, dependencies, and any commands required to configure
     
     
      
       the environment.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Container registry
      
     </strong>
     
      : The container registry
     
     <a id="_idIndexMarker851">
     </a>
     
      is a repository for storing and distributing images.
     
     
      Docker Hub is a popular public registry, though there are private registries such as Azure Container
     
     
      
       Registry available.
      
     
    </li>
   </ul>
   <p>
    
     The relationship between Docker components and their container structure is shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .15
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.15 – The relationship between Docker and its container components" src="img/B21788_10_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.15 – The relationship between Docker and its container components
    
   </p>
   <p>
    
     As mentioned previously, Docker is the most used container solution, but there are other types of runtimes available that implement the same concepts
    
    
     
      presented here.
     
    
   </p>
   <p>
    <em class="italic">
     
      Table 10.4
     
    </em>
    
     explains some of the container runtimes
    
    <a id="_idIndexMarker852">
    </a>
    
     that are available on
    
    
     
      the market:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table004">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Runtime
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Website
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           containerd
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The
        
        <a id="_idIndexMarker853">
        </a>
        
         core runtime
        
        <a id="_idIndexMarker854">
        </a>
        
         used by Docker and Kubernetes.
        
        
         It focuses on simplicity
        
        
         
          and portability.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://containerd.io/">
         
          
           https://containerd.io/
          
         
        </a>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           CRI-O
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A
        
        <a id="_idIndexMarker855">
        </a>
        
         lightweight runtime for Kubernetes that
        
        <a id="_idIndexMarker856">
        </a>
        
         implements
        
        <a id="_idIndexMarker857">
        </a>
        
         the Kubernetes
        
        <strong class="bold">
         
          Container Runtime
         
        </strong>
        
         <strong class="bold">
          
           Interface
          
         </strong>
        
        
         
          (
         
        
        
         <strong class="bold">
          
           CRI
          
         </strong>
        
        
         
          ).
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://cri-o.io/">
         
          
           https://cri-o.io/
          
         
        </a>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           runc
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A
        
        <a id="_idIndexMarker858">
        </a>
        
         CLI tool for spawning and running containers
        
        <a id="_idIndexMarker859">
        </a>
        
         according to the
        
        
         
          OCI specification.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://github.com/opencontainers/runc">
         
          
           https://github.com/opencontainers/runc
          
         
        </a>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Podman
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A
        
        <a id="_idIndexMarker860">
        </a>
        
         daemonless container engine that’s
        
        <a id="_idIndexMarker861">
        </a>
        
         compatible
        
        
         
          with Docker.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://podman.io/">
         
          
           https://podman.io/
          
         
        </a>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           LXC
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A
        
        <a id="_idIndexMarker862">
        </a>
        
         traditional container runtime that provides a
        
        <a id="_idIndexMarker863">
        </a>
        
         
          VM-like experience.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://linuxcontainers.org/">
         
          
           https://linuxcontainers.org/
          
         
        </a>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         
          Kata
         
        </strong>
        
         <strong class="bold">
          
           Containers
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         This
        
        <a id="_idIndexMarker864">
        </a>
        
         runtime
        
        <a id="_idIndexMarker865">
        </a>
        
         combines the security of VMs with the speed of containers by running
        
        
         
          lightweight VMs.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://katacontainers.io/">
         
          
           https://katacontainers.io/
          
         
        </a>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Rancher
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Rancher
        
        <a id="_idIndexMarker866">
        </a>
        
         Desktop provides container and
        
        
         
          Kubernetes
         
        
        
         <a id="_idIndexMarker867">
         </a>
        
        
         
          management.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <a href="https://rancherdesktop.io/">
         
          
           https://rancherdesktop.io/
          
         
        </a>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 10.4 – Container runtime options
    
   </p>
   <p>
    
     As we can see, there are several options for running containers in environments and the use of each solution will depend on the requirements of each application and organization.
    
    
     However, it’s worth remembering that containers include images, other containers, a Dockerfile, and a container registry, all of which are used
    
    
     
      by runtimes.
     
    
   </p>
   <p>
    
     At this point, we can package the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application in
    
    
     
      a container.
     
    
   </p>
   <h2 id="_idParaDest-174">
    <a id="_idTextAnchor175">
    </a>
    
     Packing the UrlShortener application
    
   </h2>
   <p>
    
     Docker Engine provides us
    
    <a id="_idIndexMarker868">
    </a>
    
     with different types of resources and commands to manage containers.
    
    
     We’ll focus on the packaging process for the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application and use the main features of a container, which include images, containers, and a
    
    
     
      container registry.
     
    
   </p>
   <p>
    
     Before proceeding, make sure you’ve installed Docker Engine, as per the
    
    <em class="italic">
     
      Technical
     
    </em>
    
     <em class="italic">
      
       requirements
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     Our packaging process will take place through the
    
    
     
      following flow:
     
    
   </p>
   <div><div><img alt="Figure 10.16 – Container creation flow" src="img/B21788_10_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.16 – Container creation flow
    
   </p>
   <p>
    
     In Visual Studio Code, be sure to open the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application and perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In the root of the
     
     <a id="_idIndexMarker869">
     </a>
     
      directory, create a file called
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      .
     
     
      This file has
     
     
      
       no extension.
      
     
    </li>
    <li>
     
      Add the following content to
     
     
      
       the file:
      
     
     <pre class="source-code">
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["UrlShortener.csproj", "MyApp/"]
RUN dotnet restore "MyApp/UrlShortener.csproj"
COPY . ./MyApp
WORKDIR "/src/MyApp"
RUN dotnet build "UrlShortener.csproj" -c Release
  -o /app/build
FROM build AS publish
RUN dotnet publish "UrlShortener.csproj" -c Release
  -o /app/publish
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "UrlShortener.dll"]</pre>
    </li>
    <li>
     
      Save
     
     
      
       the file.
      
     
     <p class="list-inset">
      
       The preceding code
      
      <a id="_idIndexMarker870">
      </a>
      
       is a bit long and seems complicated, so let’s understand each line of
      
      
       
        our
       
      
      
       <strong class="source-inline">
        
         Dockerfile
        
       </strong>
      
      
       
        :
       
      
     </p>
     <ul>
      <li>
       <strong class="bold">
        
         Base image and initial configuration
        
       </strong>
       
        : At this stage, we’re configuring a base image that contains the
       
       <a id="_idIndexMarker871">
       </a>
       
        default configurations for running an ASP.NET Core
       
       
        
         9 application.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
        
       </strong>
       
        : This line specifies the base image of the final container, which uses the ASP.NET Core version 8.0 runtime image
       
       <a id="_idIndexMarker872">
       </a>
       
        from the
       
       <strong class="bold">
        
         Microsoft Container Registry
        
       </strong>
       
        (
       
       <strong class="bold">
        
         MCR
        
       </strong>
       
        ).
       
       
        All Docker images start with a reference to a base image.
       
       
        The
       
       <strong class="source-inline">
        
         AS base
        
       </strong>
       
        tag names this
       
       
        
         stage
        
       
       
        <strong class="source-inline">
         
          base
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         WORKDIR /app
        
       </strong>
       
        : This line sets the working directory within the container to
       
       <strong class="source-inline">
        
         /app
        
       </strong>
       
        .
       
       
        All subsequent commands will be executed in
       
       
        
         this directory.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         EXPOSE 8080
        
       </strong>
       
        : This line tells Docker that the container will listen on port
       
       <strong class="source-inline">
        
         8080
        
       </strong>
       
        at runtime.
       
       
        This is used for documentation purposes, as well as for configuring port mapping when running
       
       
        
         the container.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Build stage
        
       </strong>
       
        : The build stage
       
       <a id="_idIndexMarker873">
       </a>
       
        will be an image that’s responsible for compiling the application.
       
       
        It will use an image that already has the .NET SDK installed as
       
       
        
         a base.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
        
       </strong>
       
        : This line uses the .NET SDK image version 8.0 from MCR to build the application.
       
       
        The
       
       <strong class="source-inline">
        
         AS build
        
       </strong>
       
        tag names this
       
       
        
         stage
        
       
       
        <strong class="source-inline">
         
          build
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         WORKDIR /src
        
       </strong>
       
        : Sets the working directory
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          /src
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         COPY ["UrlShortener.csproj", "MyApp/"]
        
       </strong>
       
        : Copies the
       
       <strong class="source-inline">
        
         UrlShortener.csproj
        
       </strong>
       
        project file to the
       
       <strong class="source-inline">
        
         MyApp/
        
       </strong>
       
        directory in
       
       
        
         the container.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         RUN dotnet restore "MyApp/UrlShortener.csproj"
        
       </strong>
       
        : Restores the project dependencies specified in the
       
       
        <strong class="source-inline">
         
          UrlShortener.csproj
         
        </strong>
       
       
        
         file.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         COPY .
        
        
         ./MyApp
        
       </strong>
       
        : Copies all the files from the current directory on the host to the
       
       <strong class="source-inline">
        
         MyApp
        
       </strong>
       
        directory in
       
       
        
         the container.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         WORKDIR "/src/MyApp"
        
       </strong>
       
        : Sets the working directory
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          /src/MyApp
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         RUN dotnet build "UrlShortener.csproj" -c Release -o /app/build
        
       </strong>
       
        : Builds the project in
       
       <strong class="source-inline">
        
         Release
        
       </strong>
       
        configuration and outputs the build results to
       
       <a id="_idIndexMarker874">
       </a>
       
        the
       
       <strong class="source-inline">
        
         /
        
       </strong>
       
        <strong class="source-inline">
         
          app/build
         
        </strong>
       
       
        
         directory.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Publish stage
        
       </strong>
       
        : At this stage, the
       
       <a id="_idIndexMarker875">
       </a>
       
        publication package
       
       
        
         is generated.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         FROM build AS publish
        
       </strong>
       
        : This line uses the build stage as the base for the
       
       
        
         publish stage.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         RUN dotnet publish "UrlShortener.csproj" -c Release -o /app/publish
        
       </strong>
       
        : This line publishes the project, which means it compiles the application, copies all the necessary files, and produces a deployable version of the application in the
       
       <strong class="source-inline">
        
         /
        
       </strong>
       
        <strong class="source-inline">
         
          app/publish
         
        </strong>
       
       
        
         directory.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Final stage
        
       </strong>
       
        : The
       
       <a id="_idIndexMarker876">
       </a>
       
        final stage takes the package that was generated by the previous configuration and runs it on an image containing the settings from the
       
       
        
         base image.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         FROM base AS final
        
       </strong>
       
        : Uses the base stage as the base for the
       
       
        
         final image.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         WORKDIR /app
        
       </strong>
       
        : Sets the working directory
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          /app
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         COPY --from=publish /app/publish .
        
       </strong>
       
        : Copies the contents of the
       
       <strong class="source-inline">
        
         /app/publish
        
       </strong>
       
        directory from the publish stage to the current directory (
       
       <strong class="source-inline">
        
         /app
        
       </strong>
       
        ) in the
       
       
        
         final stage.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         ENTRYPOINT ["dotnet", "UrlShortener.dll"]
        
       </strong>
       
        : Sets the entry point for the container so that it can run the
       
       <strong class="source-inline">
        
         dotnet UrlShortener.dll
        
       </strong>
       
        command, which starts the ASP.NET
       
       
        
         Core application.
        
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     As explained previously, the code available in the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file uses various stages to generate an image of
    
    
     
      the application.
     
    
   </p>
   <p>
    
     The Docker build stage
    
    <a id="_idIndexMarker877">
    </a>
    
     is a phase of the Docker multi-stage build process where the application is compiled, dependencies are restored, and all the required files are prepared for deployment.
    
    
     In a multi-stage build, each stage can use a different base image and environment to perform
    
    
     
      specific tasks.
     
    
   </p>
   <p>
    
     The build stage typically uses a development image or SDK to compile and build the application, producing output artifacts that can be used in subsequent stages.
    
    
     This approach helps you create a clean, optimized final image that only contains the runtime dependencies and the application itself, without build tools or
    
    
     
      intermediate files.
     
    
   </p>
   <p class="callout-heading">
    
     Docker multi-stage build
    
   </p>
   <p class="callout">
    
     Docker’s multi-stage build process
    
    <a id="_idIndexMarker878">
    </a>
    
     allows you to generate optimized images and uses container technology to compile and generate publishable applications.
    
    
     To learn more about this, go
    
    
     
      to
     
    
    <a href="https://docs.docker.com/build/building/multi-stage/">
     
      
       https://docs.docker.com/build/building/multi-stage/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     When observing the flow of the multi-stage approach, we can automate the process of generating a Docker image by going through the package creation steps that we learned about previously.
    
    
     It’s possible to generate a Docker image without using the multi-stage process.
    
    
     In this case, it’s necessary to compile and generate the application package manually and, later, just copy the generated package into the image.
    
    
     This results in a
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file that looks similar to
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
COPY ./published .
ENTRYPOINT ["dotnet", "UrlShortener.dll"]</pre>
   <p>
    
     By doing this, the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file will certainly be simpler.
    
    
     However, before generating the image, it’s necessary to execute the
    
    <strong class="source-inline">
     
      docker build
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      docker publish
     
    </strong>
    
     commands so that we can generate the application package that will be copied to
    
    
     
      the image.
     
    
   </p>
   <p>
    
     Now that we understand the principles of generating a
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file, it’s time to generate
    
    
     
      an image.
     
    
   </p>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor176">
    </a>
    
     Generating a container image
    
   </h2>
   <p>
    
     To generate a Docker image, you
    
    <a id="_idIndexMarker879">
    </a>
    
     need to run the
    
    <strong class="source-inline">
     
      docker build
     
    </strong>
    
     command.
    
    
     This command will execute the code described in the
    
    
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     To do this, open your terminal and, in the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application directory, execute the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
docker build -t urlshortener:1.0 .</pre>
   <p>
    
     The preceding command compiles the image, which will be tagged, using the
    
    <strong class="source-inline">
     
      -t
     
    </strong>
    
     parameter, with the name
    
    <strong class="source-inline">
     
      urlshortener:1.0
     
    </strong>
    
     .
    
    
     The image tag works as the name of the image to be generated as is in
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       name_lower_case&gt;[:&lt;version&gt;]
      
     </strong>
    
    
     
      form.
     
    
   </p>
   <p>
    
     The version is optional.
    
    
     If it isn’t entered, Docker will use the latest version.
    
    
     However, it’s good practice to define a version for
    
    
     
      the image.
     
    
   </p>
   <p>
    
     After defining the image tag, the context where the compilation process will be executed is informed of this.
    
    
     The context is defined by the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     parameter, which indicates the local directory that contains the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file.
    
    
     It’s important to keep in mind that the
    
    <strong class="source-inline">
     
      build
     
    </strong>
    
     command needs to know where the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file is located so that it can be
    
    
     
      executed correctly.
     
    
   </p>
   <p>
    
     Once the image generation process has run, run the following command to see the list of images on
    
    
     
      your computer:
     
    
   </p>
   <pre class="console">
docker images</pre>
   <p>
    
     After executing the preceding command, you’ll be able to view the list of images in your local container registry, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .17
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.17 – List of Docker images in the local container registry" src="img/B21788_10_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.17 – List of Docker images in the local container registry
    
   </p>
   <p>
    
     In this example, there are
    
    <a id="_idIndexMarker880">
    </a>
    
     
      three images:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       localhost/urlshortener:1.0
      
     </strong>
     
      : This is the previously generated image that contains the application.
     
     
      The
     
     <strong class="source-inline">
      
       localhost/
      
     </strong>
     
      prefix before the image’s name represents the owner of the image – in this case, the
     
     
      
       local registry.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       mcr.microsoft.com/dotnet/sdk:8.0
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       mcr.microsoft.com/dotnet/aspnet:8.0
      
     </strong>
     
      : These images represent the .NET SDK and .NET Runtime for compiling and running the application in a container, respectively.
     
     
      These images are automatically downloaded from Docker Hub.
     
     
      Note the
     
     <strong class="source-inline">
      
       mcr.microsoft.com/dotnet
      
     </strong>
     
      prefix, which refers to the owner of
     
     
      
       the images.
      
     
    </li>
   </ul>
   <p>
    
     Additionally,
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .17
     
    </em>
    
     shows the size of the images in MB.
    
    
     The application image is smaller than the other two.
    
    
     Containers must be optimized as they could affect the performance and startup of
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Container images should be considered immutable – that is, each version is unique.
    
    
     This means that if there’s any change in the application, we must generate a new image with a different tag.
    
    
     It’s a best practice to follow this convention as it allows you to have control over the containers running on
    
    
     
      a server.
     
    
   </p>
   <p>
    
     With the image generated, it’s time to run a container and test
    
    
     
      its operation.
     
    
   </p>
   <h2 id="_idParaDest-176">
    <a id="_idTextAnchor177">
    </a>
    
     Running a Docker container
    
   </h2>
   <p>
    
     To run the Docker container from the
    
    <a id="_idIndexMarker881">
    </a>
    
     previously generated image, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
docker run -d -p 8899:8080 localhost/urlshortener:1.0</pre>
   <p>
    
     Let’s take a closer look at
    
    
     
      this command:
     
    
   </p>
   <ul>
    <li>
     
      It runs a new container from the
     
     
      <strong class="source-inline">
       
        localhost/urlshortener:1.0
       
      </strong>
     
     
      
       image.
      
     
    </li>
    <li>
     
      It runs the container in detached mode (
     
     <strong class="source-inline">
      
       -d
      
     </strong>
     
      ), allowing it to run in
     
     
      
       the background.
      
     
    </li>
    <li>
     
      It maps port
     
     <strong class="source-inline">
      
       8899
      
     </strong>
     
      on the host to port
     
     <strong class="source-inline">
      
       8080
      
     </strong>
     
      inside the container (
     
     <strong class="source-inline">
      
       -p 8899:8080
      
     </strong>
     
      ).
     
     
      This makes the application run on port
     
     <strong class="source-inline">
      
       8080
      
     </strong>
     
      inside the container that’s accessible via port
     
     <strong class="source-inline">
      
       8899
      
     </strong>
     
      on the
     
     
      
       host machine.
      
     
    </li>
   </ul>
   <p>
    
     The output of the successfully executed command will be a key that represents the container’s ID.
    
    
     To check whether the container is running, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
docker ps</pre>
   <p>
    
     An output similar to the one shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .18
     
    </em>
    
     will
    
    
     
      be displayed:
     
    
   </p>
   <div><div><img alt="Figure 10.18 – Running containers" src="img/B21788_10_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.18 – Running containers
    
   </p>
   <p>
    
     Now, open a browser
    
    <a id="_idIndexMarker882">
    </a>
    
     of your choice and go to
    
    <a href="http://localhost:8899">
     
     
     
      <strong class="source-inline">
       
        http://localhost:8899
       
      </strong>
     
    </a>
    
     <strong class="source-inline">
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Connection string
    
   </p>
   <p class="callout">
    
     If the application’s connection string has been configured for the database in Azure and you get a connection error when you access the application through the container, make sure you add your IP address, as presented in the
    
    <em class="italic">
     
      Configuring Azure SQL Server
     
    </em>
    
     section.
    
    
     You can also change the connection string by using environment variables in conjunction with the
    
    <strong class="source-inline">
     
      docker run
     
    </strong>
    
     command,
    
    
     
      as follows:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      docker run -d -p 8899:8080 -e ConnectionStrings__DefaultConnection="Server=.;Database=UrlShortenerDB;user id=sa;
     
    </strong>
    
     <strong class="source-inline">
      
       password=P4sword123;Encrypt=False;" localhost/urlshortener:1.0
      
     </strong>
    
   </p>
   <p class="callout">
    
     The preceding command contains the
    
    <strong class="source-inline">
     
      -e &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       EnvironmentVariable&gt;=&lt;value&gt;
      
     </strong>
    
    
     
      parameter.
     
    
   </p>
   <p>
    
     We can run the
    
    <strong class="source-inline">
     
      docker run
     
    </strong>
    
     command several times for the same image while changing the host port on which the container will run.
    
    
     For example, the following commands will run two new containers of the same application on ports
    
    <strong class="source-inline">
     
      9900
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       9910
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
docker run -d -p 9900:8080 localhost/urlshortener:1.0
docker run -d -p 9910:8080 localhost/urlshortener:1.0</pre>
   <p>
    
     Currently, three different containers contain the same application running in your
    
    
     
      local environment.
     
    
   </p>
   <p>
    
     To finish running the containers, execute the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
docker stop &lt;container ID&gt;</pre>
   <p>
    
     You can obtain the container ID from the list of running containers by running the
    
    <strong class="source-inline">
     
      docker
     
    </strong>
    
     <strong class="source-inline">
      
       ps
      
     </strong>
    
    
     
      command.
     
    
   </p>
   <p>
    
     Understanding Docker principles and how to package your ASP.NET Core 9 application in a container is very important for the modern software development model.
    
    
     Containers offer consistency, portability, and efficiency, making them ideal for
    
    
     
      cloud-native applications.
     
    
   </p>
   <p>
    
     As we’ve learned, the
    
    <a id="_idIndexMarker883">
    </a>
    
     use of containers is related to components such as images, which are generated according to the runtime and the published application.
    
    
     Later, the image that’s been used is made available through a public or private container registry.
    
    
     Finally, we can run different instances of an application that’s been published in a container registry through the use of an image, thus generating an executed application called
    
    
     
      a container.
     
    
   </p>
   <p>
    
     Next, we’ll learn how to automate the process of publishing applications in a
    
    
     
      cloud environment.
     
    
   </p>
   <h1 id="_idParaDest-177">
    <a id="_idTextAnchor178">
    </a>
    
     Understanding the DevOps approach with CI/CD
    
   </h1>
   <p>
    
     It’s common to talk about the DevOps culture in depth.
    
    
     Despite the term being a combination of two specific areas – that is,
    
    <strong class="bold">
     
      development
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Dev
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      operations
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Ops
     
    </strong>
    
     ) – this approach goes far beyond these
    
    
     
      two teams.
     
    
   </p>
   <p>
    
     The DevOps culture
    
    <a id="_idIndexMarker884">
    </a>
    
     connects processes, people, and tools, all of which work together to generate value and provide continuous learning in the face of constant
    
    
     
      market needs:
     
    
   </p>
   <div><div><img alt="Figure 10.19 – The DevOps culture cycle" src="img/B21788_10_19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.19 – The DevOps culture cycle
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .19
     
    </em>
    
     represents this continuous flow of collaboration in different aspects involving the
    
    
     
      DevOps culture.
     
    
   </p>
   <p>
    
     Among the practices suggested in the
    
    <a id="_idIndexMarker885">
    </a>
    
     DevOps culture, we have the CI/CD process, making development teams agile, eliminating dependencies, minimizing errors, and enabling continuous evolution and learning
    
    
     
      in teams.
     
    
   </p>
   <p>
    
     CI and CD processes are commonly called pipelines because they represent a set of sequential instructions that allow new pipes or tasks to be added and reorganized in
    
    
     
      this flow.
     
    
   </p>
   <p>
    
     Before we look at the pipeline development model, let’s understand the fundamentals of CI
    
    
     
      and CD.
     
    
   </p>
   <h2 id="_idParaDest-178">
    <a id="_idTextAnchor179">
    </a>
    
     CI
    
   </h2>
   <p>
    
     CI is a
    
    <a id="_idIndexMarker886">
    </a>
    
     development practice where developers regularly merge their code changes into a central repository, after which there are automated builds
    
    
     
      and testing.
     
    
   </p>
   <p>
    
     Development teams are distributed remotely and require a central repository, usually based on Git.
    
    
     When new code is developed and changed, it’s synchronized or integrated into the
    
    
     
      local repository.
     
    
   </p>
   <p>
    
     This process occurs asynchronously – that is, each developer synchronizes their code version at a different time to other developers.
    
    
     Then, the CI pipeline is executed, where the main objective is to detect integration problems in advance and then frequently integrate code changes and check them through
    
    
     
      automated tests.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .20
     
    </em>
    
     shows a basic
    
    <a id="_idIndexMarker887">
    </a>
    
     CI
    
    
     
      pipeline scenario:
     
    
   </p>
   <div><div><img alt="Figure 10.20 – The CI pipeline flow" src="img/B21788_10_20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.20 – The CI pipeline flow
    
   </p>
   <p>
    
     As we can see,
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .20
     
    </em>
    
     presents
    
    <a id="_idIndexMarker888">
    </a>
    
     a flow that we’re already used to executing manually.
    
    
     Automating these processes brings
    
    
     
      several benefits:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Early error detection
      
     </strong>
     
      : By integrating code changes frequently, CI helps us identify and resolve errors and integration issues early in the
     
     
      
       development process.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Improved code quality
      
     </strong>
     
      : Automated tests are run on each integration, ensuring that code changes don’t break existing functionality and maintain
     
     
      
       code quality.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Faster feedback cycle
      
     </strong>
     
      : Developers receive immediate feedback on their code changes, allowing them to fix issues immediately and
     
     
      
       iterate quickly.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Improved collaboration
      
     </strong>
     
      : CI promotes collaboration between team members by integrating code changes from different developers into a shared repository, ensuring everyone is working with the latest
     
     
      
       code base.
      
     
    </li>
   </ul>
   <p>
    
     Another great benefit of the
    
    <a id="_idIndexMarker889">
    </a>
    
     CI process is the practice of performing a code review, which allows team members to analyze the code to be integrated and carry out reviews of good practices and whether unit tests have been written,
    
    
     
      for example.
     
    
   </p>
   <p>
    
     The code review approach generates constant learning.
    
    
     However, despite being done manually, it’s extremely powerful for the evolution of teams and has support from CI so that no revisions are made to code that presents compilation errors or test failures.
    
    
     It’s a constant flow of learning, allowing teams to be proactive before they publish any version of an application to
    
    
     
      production environments.
     
    
   </p>
   <p class="callout-heading">
    
     Code review
    
   </p>
   <p class="callout">
    
     A code review
    
    <a id="_idIndexMarker890">
    </a>
    
     is a human review process in which one or more developers review code written by another developer.
    
    
     To learn more about this approach, take a look at the following
    
    <a id="_idIndexMarker891">
    </a>
    
     GitHub
    
    
     
      article:
     
    
    <a href="https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews">
     
      
       https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The CI pipeline is of great importance in the development flow as its main objective is to prepare an application package that follows the quality requirements defined by the development and business teams.
    
    
     As output, it delivers this package to the CD process, which executes the procedures for implementing this in one or
    
    
     
      more environments.
     
    
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor180">
    </a>
    
     CD
    
   </h2>
   <p>
    
     CD is the next step after
    
    <a id="_idIndexMarker892">
    </a>
    
     CI and automates the process of deploying applications to
    
    
     
      production environments.
     
    
   </p>
   <p>
    
     The CD pipeline
    
    <a id="_idIndexMarker893">
    </a>
    
     simulates what happens in CI, making it possible to add automated tests, among other processes, before the automatic deployment procedures are executed for new versions of applications in different environments, such as development, testing,
    
    
     
      and production.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .21
     
    </em>
    
     shows the CD pipeline.
    
    
     It’s very similar to the one for CI, but it consists of different tasks
    
    
     
      and processes:
     
    
   </p>
   <div><div><img alt="Figure 10.21 – The CD pipeline flow" src="img/B21788_10_21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.21 – The CD pipeline flow
    
   </p>
   <p>
    
     While the CI pipeline
    
    <a id="_idIndexMarker894">
    </a>
    
     generates a valid package based on the quality flow of the development process, the CD pipeline’s main objective is to obtain the package that’s been generated through the CI pipeline and distribute it in an on-premises or
    
    
     
      cloud environment.
     
    
   </p>
   <p>
    
     The CD pipeline brings the
    
    
     
      following benefits:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Accelerated delivery
      
     </strong>
     
      : CD enables
     
     <a id="_idIndexMarker895">
     </a>
     
      faster delivery of new features and bug fixes, reducing time to market and improving
     
     
      
       customer satisfaction.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Reduced deployment risk
      
     </strong>
     
      : By deploying small, incremental changes, CD minimizes the risk associated with large,
     
     
      
       infrequent deployments.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Consistent deployments
      
     </strong>
     
      : Automated deployment processes ensure deployments are consistent and repeatable, reducing
     
     
      
       human error.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Improved reliability
      
     </strong>
     
      : Continuous monitoring and automated rollback mechanisms increase the reliability of the
     
     
      
       deployment process.
      
     
    </li>
   </ul>
   <p>
    
     Although the CD pipeline is an automated process, which means it’s capable of publishing new versions of an application in different environments automatically, it’s possible to establish approval flows where those responsible for each environment can choose whether they approve a deployment.
    
    
     The act of approval triggers the automatic deployment flow or cancels it, depending on
    
    
     
      the need.
     
    
   </p>
   <p>
    
     The approvals gate approach brings compliance benefits and allows teams to have full control of the deployment flow in
    
    
     
      certain environments.
     
    
   </p>
   <p class="callout-heading">
    
     Review deployments
    
   </p>
   <p class="callout">
    
     Depending on the delivery flow of each organization, there’s a need to review deployments, especially in production environments.
    
    
     This approach generates an automated communication process between the CD pipeline and reviewers.
    
    
     Tools such as GitHub, Azure DevOps, and GitLab, among others, have mechanisms that allow you to configure this approval flow.
    
    
     You can learn more about the deployment review process through GitHub Actions
    
    
     
      at
     
    
    <a href="https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments">
     
      
       https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     CI and CD are great approaches to automating processes so that our applications can be delivered to different environments constantly and with quality in mind.
    
    
     This is something that allows us to deliver new versions of applications several times on the same day, at the same time, and it helps us quickly provide corrections and rollbacks in those environments,
    
    
     
      if necessary.
     
    
   </p>
   <p>
    
     In the next section, we’ll implement a CI/CD flow using GitHub Actions and learn how to automatically publish a Docker image in a
    
    
     
      container registry.
     
    
   </p>
   <h2 id="_idParaDest-180">
    <a id="_idTextAnchor181">
    </a>
    
     Automating with GitHub Actions
    
   </h2>
   <p>
    
     To demonstrate CI/CD in action, we’ll use GitHub Actions to automate the process of generating and publishing a Docker image from the
    
    <strong class="bold">
     
      UrlShortener
     
    </strong>
    
     application.
    
    
     Make sure you’ve installed everything mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section so that you can take advantage of the steps
    
    
     
      described here.
     
    
   </p>
   <p>
    
     To automate the process of including CI/CD, we’ll have to do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Configure secrets in the
     
     
      
       GitHub repository.
      
     
    </li>
    <li>
     
      Create
     
     
      
       GitHub Actions.
      
     
    </li>
    <li>
     
      Activate GitHub Actions with each push event that’s sent to
     
     
      
       the repository.
      
     
    </li>
    <li>
     
      Build a
     
     
      
       Docker image.
      
     
    </li>
    <li>
     
      Publish the created image to
     
     
      
       Docker Hub.
      
     
    </li>
    <li>
     
      Run the previously created Docker image on the
     
     
      
       local machine.
      
     
    </li>
   </ol>
   <p>
    
     Before you start automating, you must understand the basics of
    
    
     
      GitHub Actions.
     
    
   </p>
   <h3>
    
     Understanding the fundamentals of GitHub Actions
    
   </h3>
   <p>
    
     GitHub Actions
    
    <a id="_idIndexMarker896">
    </a>
    
     is an automation tool that’s built into GitHub that lets you create, manage, and run workflows directly in
    
    
     
      your repository.
     
    
   </p>
   <p>
    
     Actions, as it’s commonly known, can be triggered by various events, such as code submission, pull request creation, or
    
    
     
      time triggers.
     
    
   </p>
   <p>
    
     GitHub Actions can be created using the
    
    <strong class="bold">
     
      YML/YAML
     
    </strong>
    
     file structure
    
    <a id="_idIndexMarker897">
    </a>
    
     located in the
    
    <strong class="source-inline">
     
      .github/workflows
     
    </strong>
    
     directory of this book’s GitHub repository.
    
    
     The basic structure of a workflow is represented at a high level in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .22
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.22 – The basic structure of GitHub Actions" src="img/B21788_10_22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.22 – The basic structure of GitHub Actions
    
   </p>
   <p class="callout-heading">
    
     YAML files
    
   </p>
   <p class="callout">
    
     A
    
    <strong class="bold">
     
      YAML Ain’t Markup Language
     
    </strong>
    
     (
    
    <strong class="bold">
     
      YAML
     
    </strong>
    
     ) file
    
    <a id="_idIndexMarker898">
    </a>
    
     is a human-readable data standard that’s commonly used for configuration files and exchanging data between programming languages with different data structures.
    
    
     YAML files use indentation to denote structure, making them easy to read and write.
    
    
     It’s often used in scenarios where configuration needs to be human-readable and easily parsed by machines, such as in CI/CD pipelines, cloud provisioning files, and application configuration settings.
    
    
     In the context of GitHub Actions, YAML files define workflows that automate processes such as building, testing, and deploying applications.
    
    
     To learn more,
    
    
     
      visit
     
    
    <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions">
     
      
       https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .22
     
    </em>
    
     shows the main
    
    <a id="_idIndexMarker899">
    </a>
    
     components that are part of the structure of GitHub Actions.
    
    
     Let’s take a
    
    
     
      closer look:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       workflow.yml
      
     </strong>
     
      : A YAML file that defines
     
     
      
       the workflow.
      
     
    </li>
    <li>
     <strong class="bold">
      
       on
      
     </strong>
     
      : This specifies the events that trigger the workflow.
     
     
      Examples include
     
     <strong class="source-inline">
      
       push
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       pull_request
      
     </strong>
     
      ,
     
     
      
       and
      
     
     
      <strong class="source-inline">
       
        schedule
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       jobs
      
     </strong>
     
      : Defines a set of jobs to be executed within
     
     
      
       the workflow.
      
     
    </li>
    <li>
     <strong class="bold">
      
       build job
      
     </strong>
     
      : A job named
     
     <strong class="source-inline">
      
       build
      
     </strong>
     
      running on
     
     <strong class="source-inline">
      
       ubuntu-latest
      
     </strong>
     
      .
     
     
      Here,
     
     <strong class="source-inline">
      
       ubuntu-latest
      
     </strong>
     
      is a type of agent or machine that will execute all the steps of a job.
     
     
      This machine is made available by
     
     
      
       GitHub itself.
      
     
     <p class="list-inset">
      
       This flow contains a series
      
      
       
        of steps:
       
      
     </p>
     <ul>
      <li>
       <strong class="bold">
        
         Checkout code
        
       </strong>
       
        : Uses the
       
       
        <strong class="source-inline">
         
          actions/checkout@v2
         
        </strong>
       
       
        
         action.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Set up .NET Core
        
       </strong>
       
        : Uses the
       
       <strong class="source-inline">
        
         actions/setup-dotnet@v2
        
       </strong>
       
        action with .NET
       
       
        
         version
        
       
       
        <strong class="source-inline">
         
          '8.0.x'
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="bold">
        
         Build project
        
       </strong>
       
        : Runs the
       
       <strong class="source-inline">
        
         dotnet
        
       </strong>
       
        <strong class="source-inline">
         
          build
         
        </strong>
       
       
        
         command.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Run tests
        
       </strong>
       
        : Runs
       
       <a id="_idIndexMarker900">
       </a>
       
        the
       
       <strong class="source-inline">
        
         dotnet
        
       </strong>
       
        <strong class="source-inline">
         
          test
         
        </strong>
       
       
        
         command.
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p class="callout-heading">
    
     GitHub-hosted runners
    
   </p>
   <p class="callout">
    
     On GitHub, agents are called runners and are available for Windows, Linux,
    
    
     
      and macOS.
     
    
   </p>
   <p class="callout">
    
     Runners are a fundamental component for running GitHub Actions and are provisioned during a CI or
    
    
     
      CD pipeline.
     
    
   </p>
   <p class="callout">
    
     To learn more about
    
    <a id="_idIndexMarker901">
    </a>
    
     runners,
    
    
     
      visit
     
    
    <a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners">
     
      
       https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     With GitHub Actions, we have a multitude of possibilities for automating processes that aren’t restricted to
    
    
     
      CI/CD contexts.
     
    
   </p>
   <p>
    
     Now that we know how GitHub Actions works, let’s start by configuring our repository and creating our
    
    
     
      first actions.
     
    
   </p>
   <h3>
    
     Preparing a GitHub repository
    
   </h3>
   <p>
    
     To automate the
    
    <a id="_idIndexMarker902">
    </a>
    
     process of creating and publishing a Docker image through GitHub Actions, it’s important to understand how the pipeline we’ll create works, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .23
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.23 – Example of the GitHub Actions flow integrated with Docker Hub" src="img/B21788_10_23.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.23 – Example of the GitHub Actions flow integrated with Docker Hub
    
   </p>
   <p>
    
     Previously, we learned about the fundamentals of the container strategy when using Docker and used Docker’s build multi-stage approach to
    
    
     
      implement it.
     
    
   </p>
   <p>
    
     This multi-stage approach has all the necessary steps to generate an application package and, in the end, generate an image that’s ready to
    
    
     
      be used.
     
    
   </p>
   <p>
    
     As shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .23
     
    </em>
    
     , during the pipeline flow, some calls to Docker Hub are necessary.
    
    
     This is the public container registry that we used when we packaged the
    
    <strong class="bold">
     
      URLShortener
     
    </strong>
    
     application.
    
    
     However, we can generate a local image without the need to communicate with
    
    
     
      Docker Hub.
     
    
   </p>
   <p>
    
     To be able to publish a Docker image to a public or private container registry, authentication must
    
    
     
      be performed.
     
    
   </p>
   <p>
    
     In the case of Docker Hub, this authentication takes place using a username and password.
    
    
     Since this information is sensitive, we shouldn’t add it directly to a GitHub Actions YAML file, especially if the repository
    
    
     
      is public.
     
    
   </p>
   <p>
    
     The best practice is to
    
    <a id="_idIndexMarker903">
    </a>
    
     manage these credentials securely using Secrets.
    
    
     So, follow these steps to add the
    
    
     
      necessary secrets:
     
    
   </p>
   <ol>
    <li>
     
      Access your
     
     <strong class="bold">
      
       ASP.NET-8.0-Core-Essentials
      
     </strong>
     
      repository via your GitHub user.
     
     
      This should have been prepared as per the
     
     <em class="italic">
      
       Technical
      
     </em>
     
      <em class="italic">
       
        requirements
       
      </em>
     
     
      
       section.
      
     
    </li>
    <li>
     
      Then, access the
     
     
      <strong class="bold">
       
        Settings
       
      </strong>
     
     
      
       tab.
      
     
    </li>
    <li>
     
      From the side menu, access
     
     <strong class="bold">
      
       Secrets and variables
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        Actions
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the center of the screen, click the
     
     <strong class="bold">
      
       New repository
      
     </strong>
     
      <strong class="bold">
       
        secret
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      field
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        DOCKER_HUB_USERNAME
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Secret
      
     </strong>
     
      field, add your Docker
     
     
      
       Hub user.
      
     
    </li>
    <li>
     
      Click on the
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      <strong class="bold">
       
        Secret
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Again, click on the
     
     <strong class="bold">
      
       New repository
      
     </strong>
     
      <strong class="bold">
       
        secret
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      field
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        DOCKER_HUB_PASSWORD
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Secret
      
     </strong>
     
      field with
     
     
      
       your password.
      
     
    </li>
    <li>
     
      Click on the
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      <strong class="bold">
       
        Secret
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <p>
    
     Secrets will be accessed securely while we’re running GitHub Actions.
    
    
     Now, let’s create the
    
    
     
      CI/CD pipeline.
     
    
   </p>
   <h3>
    
     Creating the CI/CD pipeline
    
   </h3>
   <p>
    
     So far, we’ve learned
    
    <a id="_idIndexMarker904">
    </a>
    
     how to manage Docker Hub credentials securely, something we’ll need to do so that we can authenticate through the pipeline and submit the newly
    
    
     
      generated image.
     
    
   </p>
   <p>
    
     Still in the GitHub repository, access the
    
    <strong class="bold">
     
      Actions
     
    </strong>
    
     tab.
    
    
     As shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .24
     
    </em>
    
     , there are several readymade pipeline templates that suit different types of applications and are a great starting point for creating
    
    
     
      a pipeline:
     
    
   </p>
   <div><div><img alt="Figure 10.24 – GitHub Actions templates screen" src="img/B21788_10_24.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.24 – GitHub Actions templates screen
    
   </p>
   <p>
    
     For this example, we’ll
    
    <a id="_idIndexMarker905">
    </a>
    
     click on the
    
    <strong class="bold">
     
      set up a workflow yourself
     
    </strong>
    
     link, as highlighted in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .24
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     You’ll see an editor and a list of
    
    <strong class="bold">
     
      Featured Actions
     
    </strong>
    
     , as well as the file’s name, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .25
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.2﻿5 – GitHub Actions editor" src="img/B21788_10_25.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.25 – GitHub Actions editor
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    <em class="italic">
     
      .25
     
    </em>
    
     shows three important
    
    <a id="_idIndexMarker906">
    </a>
    
     areas of the GitHub
    
    
     
      Actions editor:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       A
      
     </strong>
     
      : This is where you can define the filename.
     
     
      Note the suggested directory structure.
     
     
      We’ll set the filename
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        cicd-pipeline.yml
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       B
      
     </strong>
     
      : This is where we’ll add the
     
     
      
       pipeline code.
      
     
    </li>
    <li>
     <strong class="bold">
      
       C
      
     </strong>
     
      : The pipeline consists of tasks, called actions.
     
     
      These actions are abstractions for executing tasks related to a certain technology.
     
     
      The technical community shares different types of custom actions that we
     
     
      
       can use.
      
     
    </li>
   </ul>
   <p>
    
     Add the
    
    <a id="_idIndexMarker907">
    </a>
    
     following code to the
    
    
     
      pipeline editor:
     
    
   </p>
   <pre class="source-code">
name: CI/CD Pipeline
<strong class="bold">on:</strong>
  push:
    branches:
      - main
<strong class="bold">jobs:</strong>
  <strong class="bold">build-and-deploy:</strong>
    name: Build and deploy
    runs-on: ubuntu-latest
    <strong class="bold">steps:</strong>
    - name: Checkout code
      <strong class="bold">uses: actions/checkout@v4.1.7</strong>
    - <strong class="bold">name: Build and publish Docker image</strong>
      run: |
        <strong class="bold">docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}</strong>
<strong class="bold">          /urlshortener:latest .</strong>
        <strong class="bold">echo ${{ secrets.DOCKER_HUB_PASSWORD }} |</strong>
<strong class="bold">          docker login -u ${{ secrets</strong>
<strong class="bold">          .DOCKER_HUB_USERNAME }} --password-stdin</strong>
        <strong class="bold">docker push</strong> ${{ secrets.DOCKER_HUB_USERNAME }}
          /urlshortener:latest
      <strong class="bold">working-directory: ./Chapter-10/UrlShortener</strong></pre>
   <p>
    
     The hierarchical
    
    <a id="_idIndexMarker908">
    </a>
    
     structure of YAML files is created using spaces.
    
    
     Therefore, nested elements define the hierarchy.
    
    
     If these spaces aren’t respected, the file won’t be valid.
    
    
     Let’s consider using two spaces for each item in the hierarchy, as shown in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
on:
<strong class="bold">&lt;space&gt;&lt;space&gt;</strong>push:
<strong class="bold">&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;</strong>branches:
<strong class="bold">&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;</strong>-main</pre>
   <p>
    
     Let’s take a closer look at this
    
    
     
      pipeline code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       on
      
     </strong>
     
      : This defines how the action will be executed.
     
     
      In this case, every time there is an update or push in the main branch, this action will be triggered, executing the
     
     
      
       CI pipeline.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Jobs
      
     </strong>
     
      : Jobs are processes that are executed sequentially.
     
     
      There might be jobs for
     
     <strong class="source-inline">
      
       build
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       test
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       generate-package
      
     </strong>
     
      , and more.
     
     
      Using
     
     <strong class="source-inline">
      
       Jobs
      
     </strong>
     
      allows us to have well-defined steps and dependencies between steps, thus creating the
     
     
      
       pipeline flow.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       build-and-deploy
      
     </strong>
     
      : This is the definition for a job named
     
     <strong class="source-inline">
      
       build-and-deloy
      
     </strong>
     
      .
     
     
      The
     
     <strong class="source-inline">
      
       name
      
     </strong>
     
      parameter produces a more user-friendly description during pipeline execution, but the job’s name can be referenced in the
     
     
      
       pipeline flow.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Steps
      
     </strong>
     
      : Steps are the tasks or actions that are performed in each Job.
     
     
      For this example, only two tasks need to
     
     
      
       be performed.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       uses: actions/checkout@v4.1.7
      
     </strong>
     
      : This is a native GitHub action that aims to clone the repository.
     
     
      The
     
     <strong class="source-inline">
      
       checkout
      
     </strong>
     
      action is necessary since runners are created on demand and don’t have the application’s
     
     
      
       source code.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       name: Build and publish Docker image
      
     </strong>
     
      : Here, we’re executing an inline action where we define a script to build and publish the
     
     
      
       Docker image.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       docker build -t ${{ secrets.DOCKER_HUB_USERNAME }} /urlshortener:latest .
      
     </strong>
     
      : This script builds the Docker image.
     
     
      Note the use of the secret containing the Docker Hub username.
     
     
      This is necessary so that we can tag the image with its owner – that is, the Docker Hub username.
     
     
      We’re using the
     
     <strong class="source-inline">
      
       latest
      
     </strong>
     
      label here to
     
     
      
       facilitate understanding.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       echo ${{ secrets.DOCKER_HUB_PASSWORD }} | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin
      
     </strong>
     
      : This command is executed in a Linux bash shell, which allows us to combine commands and
     
     <a id="_idIndexMarker909">
     </a>
     
      execute other commands by obtaining input and output from previously executed commands.
     
     
      In this case, we’re writing the secret that contains the Docker Hub user’s password and sending the output as a parameter to the
     
     <strong class="source-inline">
      
       docker login
      
     </strong>
     
      command.
     
     
      This way, the secret won’t be exposed in the pipeline execution log.
     
     
      The
     
     <strong class="source-inline">
      
       docker login
      
     </strong>
     
      command is required for publishing new versions
     
     
      
       of images.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       working-directory: ./Chapter-10/UrlShortener
      
     </strong>
     
      : The directory containing the
     
     
      <strong class="source-inline">
       
        Dockerfile
       
      </strong>
     
     
      
       file.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       docker push
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       docker push
      
     </strong>
     
      command submits the previously generated image to
     
     
      
       Docker Hub.
      
     
    </li>
   </ul>
   <p>
    
     With this, the pipeline has been configured and contains both the CI and CD pipelines, where a new version of the Docker image is published at the end of the pipeline.
    
    
     At this point, it’s time to run the created
    
    
     
      GitHub action.
     
    
   </p>
   <h3>
    
     Running the CI/CD pipeline
    
   </h3>
   <p>
    
     In the pipeline
    
    <a id="_idIndexMarker910">
    </a>
    
     editor, click the
    
    <strong class="bold">
     
      Commit Changes
     
    </strong>
    
     button.
    
    
     You’ll be taken to a new page where you must click
    
    <strong class="bold">
     
      Commit Changes
     
    </strong>
    
     once more.
    
    
     This is necessary since we’re creating a new file in
    
    
     
      the repository.
     
    
   </p>
   <p>
    
     When you commit these changes, the pipeline will be
    
    
     
      triggered automatically.
     
    
   </p>
   <p>
    
     Click on the
    
    <strong class="bold">
     
      Actions
     
    </strong>
    
     tab; you’ll see the pipeline’s execution, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .26
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 10.26 – Running the GitHub action" src="img/B21788_10_26.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.26 – Running the GitHub action
    
   </p>
   <p>
    
     After running the pipeline, the new image will be generated in Docker Hub, as shown in
    
    
     <em class="italic">
      
       Figure 10
      
     </em>
    
    
     <em class="italic">
      
       .27
      
     </em>
    
    
     
      :
     
    
   </p>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 10.27 – Container image published on Docker Hub by GitHub Actions" src="img/B21788_10_27.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.27 – Container image published on Docker Hub by GitHub Actions
    
   </p>
   <p>
    
     To test the new image on your local machine, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
docker run -d -p 7777:8080 -e ConnectionStrings__DefaultConnection="&lt;Your Connection String&gt;" &lt;your username&gt;/urlshortener:latest</pre>
   <p>
    
     The new image will be
    
    <a id="_idIndexMarker911">
    </a>
    
     downloaded, which means your application can be run on your local machine
    
    
     
      at
     
    
    
     <a href="http://localhost:7777">
      
       http://localhost:7777
      
     </a>
     <strong class="source-inline">
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     As we’ve learned, GitHub Actions can automate tasks in environments for the purpose of CD.
    
    
     This brings agility and consistency and allows teams to act quickly in the face of the constant changes demanded by
    
    
     
      the market.
     
    
   </p>
   <p>
    
     At this point, any changes that are made to your repository and submitted to GitHub will automatically generate a new version of the container for your Docker
    
    
     
      Hub user.
     
    
   </p>
   <p>
    
     GitHub Actions has several applications and, together with solutions developed in ASP.NET Core 9, it’s a powerful tool for creating
    
    
     
      high-quality applications.
     
    
   </p>
   <p>
    
     In this section, we learned about the fundamentals of working in a continuous flow of value delivery.
    
    
     We’ll explore how to attain a cloud-native application development mindset in the
    
    
     
      next chapter.
     
    
   </p>
   <h1 id="_idParaDest-181">
    <a id="_idTextAnchor182">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned how to publish ASP.NET Core 9 applications and generate a publishing package using the
    
    <strong class="source-inline">
     
      dotnet
     
    </strong>
    
     CLI tool.
    
    
     Furthermore, we learned how to publish an application in an Azure cloud environment and explored the fundamentals of Docker’s container strategy.
    
    
     Using the knowledge we’d acquired, we were able to learn how value delivery flows through DevOps practices such as CI and CD and benefits from automated processes via GitHub Actions.
    
    
     All the knowledge we’ve acquired in this chapter forms the basis for the next chapter, where we’ll learn about cloud-native development with ASP.NET
    
    
     
      Core 9.
     
    
   </p>
  </div>
 </body></html>