- en: Managing the Object Life Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a managed language. Unlike other languages, such as C++, where we need
    to explicitly manage memory cleanup, in C# we do not need to worry about it. The
    garbage collector in the .NET Framework manages the allocation and release of
    memory for us.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector ensures that, as long as we use managed types, that is,
    value and reference type variables, then we don't have to explicitly destroy an
    object in order to free its memory. However, as we discovered in [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml),
    *Creating and Using Types in C#*, C# also gives us the freedom to utilize the
    capabilities of pointer object types in it. In C#, we must declare that code using
    the unsafe syntax. Apart from that, for variables declared in unsafe code, we
    also need to manage the release of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, as well as looking into memory management for unsafe code
    we will delve into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between managed and unmanaged code in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How garbage collection works in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a garbage collector uses a managed heap to allocate memory to objects during
    application execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the mark-compact algorithm used by the garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage unmanaged resources in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding finalization and the performance implications of using the finalize
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `IDisposable` interface and how it helps overcome the shortcomings
    of the finalize method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how we can combine the `Dispose` method with the finalize method
    to ensure the best performance of our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding using the `using` block for all classes that implement the `IDisposable`
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the previous chapters in this book, the programs explained here will
    be developed in VS 2017.
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  prefs: []
  type: TYPE_NORMAL
- en: Managed code versus unmanaged code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand the difference between managed and unmanaged
    code. Recall that we also studied this in [Chapter 1](ccec4122-6067-4279-843b-6123b1eff017.xhtml),
    *Learning the Basics of C#*. Therefore, for a quick recap, we will just revise
    the concepts that we covered there.
  prefs: []
  type: TYPE_NORMAL
- en: 'These concepts apply not just to the C# language, they are also relevant to
    all languages written in the .NET Framework. The following are some of the differences
    between managed and unmanaged code:'
  prefs: []
  type: TYPE_NORMAL
- en: Managed code is executed by the **Common Language Runtime** (**CLR**). Due to
    this, the code is independent of the underlying OS. On the other hand, unmanaged
    code is code that is executed by the OS directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of managed code, the code is independent of the underlying framework
    or the OS. CLR compiles the code into an **Intermediate Language** (**IL**) code,
    which is then compiled to machine code. IL code consists of an underlying system
    or the OS on which the program is executing. On the other hand, in the case of
    unmanaged code, the code is directly compiled to the underlying machine code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As managed code is executed by the CLR, the .NET Framework provides several
    built-in capabilities such as garbage collection and type checking exceptions.
    However, for unmanaged code, as we will learn in this chapter, a programmer needs
    to explicitly manage memory cleanup activities, which are otherwise done by the
    garbage collector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, before we learn how a programmer can manage memory for unmanaged code,
    let's first understand how garbage collection works in C# and how useful it is.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Garbage collection is a functionality, provided by CLR in .NET, which helps
    us to clean up the memory occupied by managed objects. It is a thread that executes
    in the .NET Framework and, at regular intervals, checks whether there is any unused
    memory in the application. If it does find memory, then it reclaims that memory
    and destroys the underlying object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have implemented a .NET web application in C#. Now, let''s assume
    that during any interval of time, there are several people who are trying to access
    this .NET application. The following is one particular scenario that will give
    us an idea of why garbage collection is a very important part of C# or, for that
    matter, any .NET application:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user browses the application, they can execute a number of functionalities,
    such as accessing their profile or executing operations (for example, creating,
    updating, and deleting information).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information can be stored in different sources such as SQL, Oracle, or
    more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access this information and to execute these operations, the application
    will require the creation of different objects during the application runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming a scenario where memory is just being allocated to different objects
    but is not being cleaned up, over the course of time we will end up with a system
    that has too much unused memory. Memory cleanup is logical when the object declared
    in the memory is no longer required. For example, suppose that a user, after performing
    the intended operations in the application, logs out. In this case, the memory
    that was allocated for the operations of that particular user is no longer required.
    Therefore, that memory can be reclaimed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A the memory allocated to the application could be limited, this will lead to
    performance degradation over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection in the .NET Framework ensures that such situations never
    arise for managed code. This thread runs in the background of the application
    and, at set intervals, reclaims the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that garbage collection can only reclaim the unused memory of managed
    code. For unmanaged code, which we will learn about later, we need to explicitly
    write code to ensure that no memory leaks occur in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The garbage collector in .NET executes the following tasks in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Allocation of memory**: Each application running on .NET maintains a memory
    block required for its execution in a managed heap. The garbage collection manages
    the allocation of memory from this heap structure to the objects used in the program.
    In upcoming sections, we will learn more about managed heaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deallocation of memory**: The garbage collector runs at set time periods
    during the application runtime and looks for objects that are no longer required
    by the application. It then destroys those objects and reclaims the memory for
    future use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The garbage collector reclaims the memory when one of the following three conditions
    occurs during the execution of a program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The application has low memory**: Each application running in .NET requires
    memory for its successful execution. If CLR determines that the application is
    getting free low memory from the OS, it tells the garbage collector to free any
    unused memory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The relocation of memory**: Garbage collection in C# is based on generations.
    Generations are simply divisions in the managed heap used by the application.
    In C#, we can have three generations: generation 0, generation 1, and generation
    2\. In upcoming sections, we will learn how generations are classified. The garbage
    collector tries to optimize the performance of the system by classifying the objects
    used in the application among the three generations of a managed heap. In generation
    0, it keeps the newly created objects in the application run. In comparison, in
    successive runs it identifies the objects that are being used for a longer period
    in the application execution. It classifies them as generation 1 and generation
    2 and then loops through these generations less extensively than it does for generation
    0\. This, therefore, results in better performance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When the** **Collect** **method is called**: As programmers, we hardly need
    to call the garbage collector method explicitly, as .NET is smart enough to ensure
    that garbage collection occurs at regular intervals. However, there could be certain
    scenarios where we would need to call this method explicitly. In such cases, we
    can do it by calling the `GC.Collect` method. In this chapter, we will look at
    a program implementation in which we do this.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's go through some of the basic structures that garbage collection works
    with in C#. We will start with a managed heap, which we will explore in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Managed heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is executed in the .NET Framework, the garbage collector
    allocates a section of memory to store and manage the objects declared during
    the application execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This memory is referred to as the managed heap. It''s called "managed" because
    it''s used to save the managed variables. The following diagram illustrates what
    a typical heap structure looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb6be0e3-aaa6-48a7-b1fb-cfff26f5889a.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is a typical example of what a heap structure looks like.
    At the top of the structure, we have a root node. Each node can have two child
    nodes. The address of the child node is saved in the parent node itself.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector allocates and deallocates memory on this managed heap.
    The heap is referred to as the managed heap. When an object is allocated in the
    application, the object is stored in the heap. The object then saves the reference
    to the next object in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: While allocating the memory, the CLR checks whether any free memory is available
    in the heap. If memory is available, it allocates it from the heap. However, every
    so often, the garbage collector performs a check on all of the objects present
    in the managed heap and checks whether the object is being used in the application.
    The garbage collector loops through the heap and finds out which objects are not
    associated with the application root as well as those that are not referred to
    anywhere in the heap. These objects are classified as dead objects. The garbage
    collector then removes such dead objects from the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can begin to understand the phases in which the garbage collector
    works, let's understand how the garbage collector segregates the managed heap
    into different divisions called **generations**.
  prefs: []
  type: TYPE_NORMAL
- en: Generations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The garbage collector segregates the managed heap into three divisions or generations:'
  prefs: []
  type: TYPE_NORMAL
- en: Generation 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea behind this is to optimize the application by handling long-lived and
    short-lived objects in memory separately. For example, if we have determined that
    object `a` is a long-term object used during the application execution, then,
    ideally, the garbage collector would not want to check through this object on
    every occasion in order to see whether it is still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the garbage collector classifies short-term objects in generation 0
    and long-term objects in generation 1 or 2\. Only objects present in generation
    0 are checked during every run of the garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the objects present in higher generations are not checked
    as frequently. Therefore, this avoids unnecessary checks and improves the performance
    of the overall application.
  prefs: []
  type: TYPE_NORMAL
- en: Generation 0 is the youngest generation and all new objects are allocated to
    generation 0\. Generation 1 objects contain objects that live longer. Similarly,
    generation 2 consists of the longest living objects in the application execution.
    Let's go through the following example to see how generations help in optimizing
    application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have an application, *A*, which is declaring different objects
    during execution. The square brackets indicate the different divisions or generations
    maintained by the garbage collector. Each of the following steps indicates a particular
    stage during the application execution.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the following example is just for explanation purposes only.
    The garbage collection calls will depend on different factors and are not necessarily
    be based upon the scope of the function execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code example and see how it works. In the
    code example, we have declared a private `ReturnResult` function, which does not
    have any input parameter and returns an output parameter of the `object` type.
    In this function, just for the sake of explanation, we have declared some variables
    and are returning back one variable, `a`, to the calling function. Now, let''s
    execute the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application execution begins, the application calls the `ReturnResult`
    function. Then, in the function, when the execution encounters the `new` keyword,
    the garbage collector gets triggered. As all the variables are newly created variables,
    these variables will be added to generation 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a8fd323-914d-4cdc-9611-1863f0c0e418.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, suppose that in the next statement, we return the execution to the main
    function and pass object `a`. By doing so, the program execution shifts to the
    main operation. However, as we are just returning `a`, all the other `b`, `c`,
    `d`, and `e` objects will no longer be required in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we are also declaring new objects, `f`, `g`, and `h`, in the main
    program.
  prefs: []
  type: TYPE_NORMAL
- en: If the garbage collector is called during this time, it will identify that object
    `a` is still required in the program execution but all other objects can be released.
    Therefore, the garbage collector will reclaim the memory in the variables `b`,
    `c`, `d`, and `e`. The new objects, `f`, `g`, and `h`, will be added to generation
    0\. For object `a`, the garbage collector will assume that it's a long-lived object
    and this will be moved to the generation 1 division.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the generations now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0752b5d9-b10d-412c-8b7a-d4ef0e66a77f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s suppose that, again, the main program calls for another `ReturnResultFinal`
    function passing object `a`. The newly added program does not return anything
    back. The following is the code implementation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, the garbage collector can determine that all the other variables
    can be removed from the memory except `a`. During this time, it can also determine
    that this object can be promoted to generation 2\. This is what the generations
    now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e35c0c3-1b89-4ece-82eb-6b7be517598f.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we move on to the next topic, let's briefly go through the mark-compact
    algorithm, used by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The mark-compact algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mark-compact algorithm is used by the garbage collector to maintain the
    memory. Essentially, it can be classified into three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The mark phase**: In the mark phase, the garbage collector loops through
    the different objects in the heap and identifies the one that is being referenced
    by a root item. A root item can be either the starting point of the program execution
    or a particular function. If the element is being referenced, it marks the object.
    All other objects, which are not referenced, are then classified as **dead** objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The relocating phase**: In the relocating phase, the garbage collector moves
    all the objects that are being referenced, groups them together, and then updates
    the memory address for each of the next objects in the memory heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this, the garbage collector also classifies objects that are
    being used in the application to one of the different generations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The compacting phase**: In the compacting phase, the garbage collector destroys
    the dead objects classified in the previous phase and reclaims their memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire process that the garbage collector undertakes can lead to a performance
    impact on the application. This is due to the fact that during the program execution,
    the garbage collector needs to make sure that the references in the heap are not
    changed during its run. This means that all the other threads of the application
    are paused while the run is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this situation does not arise often as the garbage collector starts
    cleaning only when the memory available for the application execution is low.
    Therefore, while the memory is high, the collection algorithm does not kick in.
    Additionally, as explained while we were discussing generations, when the garbage
    collection starts, it first checks the generation 0 heap objects. If they survive
    the cleanup, they are promoted to the next generation. For objects in the higher
    generations, the garbage collector assumes that the objects in higher generations
    will probably be used in the application for a longer period of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how we can explicitly call the garbage
    collection method in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Calling garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it''s not recommended, and we hardly find any reason or circumstance
    where we seldom need to call the garbage collector explicitly during the program
    execution, we can use the following syntax to execute the `Collect` method in
    garbage collection. The following is the code implementation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`GC` is present in the system namespace. The `Collect` method executes the
    mark-compact algorithm, which we discussed in the previous section. The `WaitForPendingFinalizers`
    method pauses or suspends the current thread until the garbage collector finishes
    its execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a fair understanding of how garbage collection works in C#,
    we will look at how we can perform memory management for unmanaged objects or
    unmanaged code.
  prefs: []
  type: TYPE_NORMAL
- en: Managing unmanaged resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The garbage collection provided by the .NET Framework is good enough when we
    are dealing with managed objects. However, there are several instances in which
    we need to use unmanaged resources in our code. Some of these instances include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When we need to access OS memory using pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are doing I/O operations related to file objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of these circumstances, the garbage collector does not explicitly free
    up the memory. We need to explicitly manage the release of such resources. If
    we do not release such resources, then we may end up with problems related to
    memory leaks in the application, locks on OS files, leaks on connection threads
    to resources such as databases, and more.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these situations, C# provides finalization. Finalization allows us
    to cleanup unmanaged code in a class before the garbage collector is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that when using finalization, we cannot control when the code specified
    in finalization will be called. It's up to the garbage collector to determine
    when the object is no longer required. However, what we are sure of is that the
    finalization code will be called before the object gets cleaned up by the garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a finalizer in a class, we use the `~` syntax. The following is
    the code implementation we use to declare a finalizer for a particular class in
    C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have declared a `SampleFinalizerClass` syntax.
    In order to clean up unmanaged resources in the class, we have declared a finalizer.
    The name of the finalizer is the same as that of the class but is appended with
    a `~`.
  prefs: []
  type: TYPE_NORMAL
- en: In Finalizer, we can do things such as destroying pointer objects, releasing
    connections on files, releasing connection threads to databases, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Now, although using the `Finalizer` keyword does clean up unmanaged code before
    the object is destroyed by the garbage collector, it does introduce some extra
    overhead for the garbage collector. Let's examine the following example in order
    to understand the reason behind this overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The finalization mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will understand how the garbage collector performs finalization
    in the .NET Framework. To do finalization, it maintains two queues in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The finalization queue**: The finalization queue is a data structure maintained
    by the garbage collector, which contains a reference to all the objects in a managed
    heap that have implemented the finalize method. Using this queue, the garbage
    collector essentially identifies all the objects that it needs to call the finalize
    method for in order to clean up the unmanaged code before the object can itself
    be destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** **fReachable queue**: The `fReachable` queue is a data structure maintained
    by the garbage collector. It contains a reference to all the objects in the managed
    heap, which, even though they don''t have any reference with the application root,
    can be deleted. However, before deleting them, it must call the finalize method
    to clean up the unmanaged code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try and understand this with the following example. Suppose we have an
    application wherein we have declared an object class, `A`, which has the finalize
    method. All other objects don't have the finalize method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following representational diagram of the different structures
    that could be in the garbage collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dedb77c-e354-4a23-a698-642ff8bf6778.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These structures can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program Scope**: This represents the different objects that may be in the
    scope of the application root or, in other words, are being used in the particular
    block of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed Heap**: This represents the heap memory structure maintained by the
    garbage collector to allocate memory to the objects present in the program scope.
    There are two divisions in the managed heap. One is **Generation 0**, which is
    used for newly created short-lived objects, and another is **Generation 1**, which
    is used to save long-lived objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finalization Queue**: As indicated previously, this will contain a reference
    to all the objects in a managed heap that have an implementation of the finalize
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fReachable Queue**: As indicated previously, this will contain a reference
    to all the objects in a managed heap for which, although they are not used in
    the program scope, the garbage collector needs to call the finalize method before
    their memory can be reclaimed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the following two classes: `SampleFinalizeClass` and `SampleNoFinalizeClass`.
    Please note that the `SampleFinalizeClass` class has a finalize method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three objects; one for `SampleFinalizerClass` and two for `SampleNoFinalizerClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As objects `b`, `c`, and `d` are newly created objects, they will be added
    to generation 0 in the managed heap. While doing so, the garbage collector will
    also recognize that object `b` needs to have an additional call of the finalize
    method before it can be cleared. It will make this entry in the finalization queue
    by adding a reference to object `b`. The following diagram indicates what this
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/129f5e99-00bb-45ef-b767-9b1276a74486.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pass the execution to another function by passing it to object `c`. The following
    is the code snippet for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose that, during program execution when the control is at the `GarbageCollectorFinalize`
    function, the garbage collector gets called. The garbage collector will identify
    that object `d` is no longer required and, therefore, its memory can be reclaimed.
    However, object `c` is being still referenced. Therefore, it will make an assumption
    that this could be a long-lived object and will thus promote the object to generation
    1\.
  prefs: []
  type: TYPE_NORMAL
- en: For object `b`, it will recognize that it's not referenced now; however, it
    does have a finalize method and so cannot be cleaned. Therefore, it keeps object
    `b` in memory for now. However, it removes the entry in the **Finalization Queue**
    and adds an entry in the **fReachable Queue** so that the variable can be cleared
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object `b`, as it cannot be removed from memory in the same way as object `c`,
    will also be promoted to **Generation 1**. The following shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de4ee592-6c98-4834-900d-ae02780f3f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This illustrates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Even though object `b` may not still be required, it will be persisted for a
    longer period of time in the memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the previous example, the garbage collector will need to execute another
    iteration in order to clear these objects from the memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused objects that are implementing finalize may be moved to a higher generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to these reasons, it's highly advisable that whenever we need to declare
    an object that has the finalize method, we must implement the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go on to look at the `IDisposable` interface, let''s take a look
    at the following code implementation illustrating how the `Finalizer` function
    works in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code implementation, in which we declare a `Finalizer`
    class and then add a `Finalizer` function to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have added text in both the `Finalizer` class constructor and in
    the `Finalizer` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code snippet to create an object of this class. Additionally,
    note that we have set a `null` value to the object. Setting a `null` value signifies
    that the object is no longer required in the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, by using the `Console.ReadLine()` syntax, we are preventing the
    application from terminating. We have done this to analyze the output coming from
    the program. When we execute `.exe`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a53d7d64-7390-42c8-8af3-05d901e498b3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we are only getting the message from the constructor
    of the `Finalizer` class. Even though the object has been set as `null`, the finalizer
    of object `f` has not been executed yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is due to the fact that we cannot specify when the garbage collector kicks
    in. Now, press *Enter* in the `.exe` execution. Notice that the program stops
    the execution; however, before it terminates, the finalizer is called to reclaim
    the memory of object `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e03c708-2376-4ed3-9868-a081b3e63723.png)'
  prefs: []
  type: TYPE_IMG
- en: This proves we were right about finalizers, which we discussed earlier in this
    section. Even though object `f` was no longer needed in the application, it was
    still kept in the managed heap memory until the garbage collector executed the
    `Finalizer` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to implicitly call the garbage collector and note
    that the finalize method is called immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the program now, we will see the output from the finalizer of
    the `Finalizer` class, illustrating that the garbage collector immediately reclaimed
    the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42ecd167-1a77-40a3-a227-2845fd6b2624.png)'
  prefs: []
  type: TYPE_IMG
- en: When we call the `GC.Collect()` method, internally, it calls the finalizers
    for all the objects that are no longer required. Thus we get the message, Inside
    the finalizer of class Finalizer.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, we discovered that if we use `Finalizer`, we
    may have some performance implications in the program. Although we can use the
    `GC.Collect()` command to implicitly call the garbage collector, even that can
    cause some lag in the program. To overcome these issues, C# is capable of using
    the `IDisposable` interface in such circumstances. In the next section, we will
    understand how we can implement this interface and how it helps us achieve better
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finalize method, which we examined in the preceding section, has some performance
    implications for the system. With the `Finalizer` method, we are not sure of when
    the memory will be reclaimed by the garbage collector even after the object is
    no longer required. This implies that there is a possibility that unused memory
    will be persisted in a managed heap for longer than the desired amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: With the `IDisposable` interface, we can assume control over when the memory
    is reclaimed for unmanaged resources in the application. The `IDisposable` interface
    in C# only has one method, which is `Dispose()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, we can perform the same cleanup of unmanaged resources that
    we did in the `Finalizer` method. The following is the code implementation of
    the `IDisposable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding example, we have declared a `DisposeImplementation`
    class and have implemented a `IDisposable` interface in this class.
  prefs: []
  type: TYPE_NORMAL
- en: As we are implementing the `IDisposable` interface, we have defined a `Dispose`
    function in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Dispose` method, we need to clear all the unmanaged resources we
    are using in this class. While this approach is reliable in terms of when the
    resources will be reclaimed, there are some points we need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: It's the programmer's responsibility is to ensure that the `Dispose` method
    is called to reclaim the memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the programmer misses calling the `Dispose` method, there is a chance that
    the unmanaged resources will not be cleared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, as a good programming practice, we should use both the `Finalize`
    and `Dispose` methods together in any implementation related to unmanaged resources.
    This will ensure that if the programmer has missed calling the `Dispose` method,
    then the `Finalize` method will always be there to reclaim the memory of the unmanaged
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in order to ensure that we do not duplicate the work in `Finalize`
    and `Dispose`, we can use the approach illustrated in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: For the same class that we used in the preceding implementation, we will declare
    an `isDisposed` field. The value of this field is set to `false`. In the `Dispose`
    method, we will reset its value to `true` to indicate that the cleanup for the
    unmanaged resources has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to make sure that we do not do a cleanup of the resources a second time,
    we will check the value of this property in the `Finalize` method. If the `Dispose`
    property is set to `true`, indicating that cleanup has already occurred, then
    nothing will happen. If the `Dispose` property is set to `false`, indicating that
    cleanup has not occurred, then finalize will do a cleanup of the resources just
    as before. The following is the code implementation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's demonstrate these classes in two ways. First, we will call the `Dispose`
    method before calling the `GC.Collect()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `Dispose` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in the `Dispose` method we are setting the value in the
    flag to `true`. Apart from setting the flag, we will also be reclaiming memory
    from unmanaged resources. Therefore, when we call the finalize method, as the
    value in the flag is already set to `true`, the block inside the finalize method
    does not get executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3a46fce-6a6a-480c-8b1a-7c0a823b814b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s consider another scenario in which the programmer forgets to call
    the `Dispose` method explicitly. The following is the code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are not calling the `Dispose` method, so the value
    in the flag is set to `false`. Therefore, when the garbage collector executes
    the finalize method in object `d`, it also executes the code block to explicitly
    call the `Dispose` method for the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a52c72d8-0acc-43dd-ae4e-40a8a00a9e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is also a property that we can use to suppress calling the finalize method
    in the `Dispose` method. We can use this when we are sure that we don''t need
    to verify the resources in the finalize method. The following is the syntax we
    can use to suppress calling the finalize method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have used `GC.SupressFinalize()` for the current
    object. This will remove the references from the finalization queue, ensuring
    that the finalize method is never triggered for the current object. Therefore,
    if we execute the same input, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc6532b-860d-4595-821f-bd9f4c922543.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this pattern, we can ensure that unmanaged resources are released from
    memory without compromising the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at using the `using` block as a good practice
    for when we are dealing with any classes implementing the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The using block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any program is bound to have errors. There could be several unforeseen circumstances
    where our written logic will throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: If we are using unmanaged resources, then unhandled exceptions can be very harmful.
    They can lead to issues related to dangling memory, unclosed connections to file
    objects, and more.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the preceding example, where we have written a `Dispose`
    method to free up the memory. Let's say we have a scenario in which the application
    throws an exception before the `Dispose` method is called. In this case, the application
    will never have a chance to reclaim the memory occupied by the unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such scenarios, C# lets us use the `using` block in our code. When
    we use the `using` block, no matter what happens inside the `using` block, the
    `Dispose` method is always called. Let''s understand this with the following code
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding code block, we are using the same `DisposeImplementation`
    class but are using it inside the `using` block. We are not explicitly nullifying
    the `d` object, to indicate to the garbage collector that it''s no longer needed.
    Additionally, we are not explicitly calling the `Dispose` method to free up the
    unmanaged resources. Yet, when we run the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87a2f90f-36bc-42ff-a009-a13b405708e1.png)'
  prefs: []
  type: TYPE_IMG
- en: The `using` block handles it automatically. The `using` block ensures that as
    soon as the control is out of the `using` block, it will call the `Dispose` method
    for the object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's consider a scenario in which we get an error in the `using` block.
    For the sake of explanation, we will introduce an error manually by throwing an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the code, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83163c92-bfb7-450a-afb7-afed5615d21b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the code, we have thrown an exception that is not being handled. However,
    even then, the `Dispose` method of the `DisposeImplementation` object is called
    before the application errors out due to the exception. If we don''t use the `using`
    block, this will not happen. To illustrate this, remove the `using` block and
    throw the same exception in the application. The following is the code implementation
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding block, we have removed the `using` statement and are throwing
    an unhandled exception after the object is created. If we execute the code, we
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50af78a9-ada0-4830-85a2-ed16a9417456.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, during the program execution the
    `Dispose` method is never called for the `DisposeImplementation` object. This
    illustrates that, as a best practice, we must always use a `using` block for classes
    implementing the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about memory management for unmanaged resources
    in C#. We revised the differences between managed code and unmanaged code in C#.
    We then looked at garbage collectors and delved into how they work. We learned
    about the memory storage structure of a managed heap, which it uses internally
    to allocate memory to different objects created during program execution. We learned
    about the internal divisions of generations, which the garbage collector uses
    internally to improve the performance of the system. We also learned about the
    mark-compact algorithm, which the garbage collector uses. We then explored how
    we can invoke garbage collection implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we went on to understand concepts about memory management for
    unmanaged objects. We learned about the `Finalize` method and how it facilitates
    memory management of an unmanaged object. We learned about the performance implications
    of using the `Finalize` method, and then we went on to understand how the `IDisposable`
    interface helps overcome its shortcomings. We learned about how we implement the
    `IDisposable` interface in a class and how we can combine both the `Dispose` and
    `Finalize` methods to improve the performance of the system. Finally, we learned
    about using the `using` block for classes that implement the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how reflection works in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A garbage collector can reclaim memory for unmanaged resources used in C# code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following can be used to make sure the `Finalize` method is not
    called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GC.Collect();`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GC.SupressFinalize(this);`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GC.WaitForPendingFinalizers();`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Which one of the following statements is incorrect?
  prefs: []
  type: TYPE_NORMAL
- en: '`Finalize` can lead to performance implications due to the object remaining
    in memory longer than required.'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: Generation 0 is used to save objects that are short-lived.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if we use the `IDisposable` interface, we will not be able to suppress
    the calls that the garbage collector performs to execute the code in the `Finalize`
    method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `using` block ensures that the `Dispose` method is called by the garbage
    collector automatically.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**b**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**b**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**c, using SupressFinalize method we will be able to remove the reference from
    the finalize queue thus the finalize method will not be executed.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
