- en: Chapter 5. Reflection and Dynamic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The principles of Reflection in computer science are defined by Wikipedia as:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability of a computer program to examine, introspect, and modify its own
    structure and behavior.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The internal structure of the .NET assemblies we saw in the first chapter allows
    us to load and invoke types embedded inside our own or foreign assemblies at runtime
    with a technique called dynamic invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, classes related to CodeDOM and `Reflection.Emit` namespaces permit
    code generation at runtime, either in C# or other languages, including **Intermediate
    Language** (**IL**).
  prefs: []
  type: TYPE_NORMAL
- en: However, beyond the .NET-to-NET dialogs, we can use Interoperability to manipulate
    applications built in other non-NET programming languages. Actually, many professional
    applications find it suitable—and very useful—to count on external functionalities
    that we might detect as present in the host operating system. This means that
    we can interoperate with **Microsoft Office Suite** (**Word** and **Excel** being
    the most typical cases of these resources).
  prefs: []
  type: TYPE_NORMAL
- en: These applications can provide us with new and exciting possibilities, such
    as graph (charts) generation, text spelling, document template creation, and even
    add-in enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: That's why our goal in this chapter is to review some of the most useful concepts
    and use cases that a programmer might find of interest in relation with these
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with Reflection, analyzing the possibilities offered by .NET Framework
    to introspect the very structure of assemblies and invoke internal functionalities
    in a totally programmable way.
  prefs: []
  type: TYPE_NORMAL
- en: I will also cover the ability of emitting source code at runtime and generate
    new types and launch them at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, we will review the most noticeable and statistically used
    options offered by Interop programming, the name used to indicate when a program
    communicates with another application to establish a controlled, programmatic
    dialog in order to interchange data and emit instructions to other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in brief, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and the implementation of Reflection in the .NET framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical uses of Reflection in everyday programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using System.Emit to generate source code at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interop programming from the C# language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Interop with Microsoft Office apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Office add-ins or apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection in the .NET Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, it is good to start with the main definition (MSDN source), which
    states that:'
  prefs: []
  type: TYPE_NORMAL
- en: The classes in the System.Reflection namespace, together with System.Type, enable
    you to obtain information about loaded assemblies and the types defined within
    them, such as classes, interfaces, and value types. You can also use Reflection
    to create type instances at run time, and to invoke and access them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember, as we mentioned in the first chapter, that the organization of assemblies
    is such that they contain modules, which in turn contain types that contain members.
    Reflection techniques allow you to find out (introspect) which modules, types,
    and members are present inside a given assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, when we access any member via Interop, there''s a hierarchy of info
    properties linked to it: the generic member''s info, its System.Type (the type
    it belongs to) namespace, the method base, and also information related to its
    properties, fields and events, as the next graphic shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reflection in the .NET Framework](img/image00503.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As per the .NET architecture analyzed in previous chapters, the two core elements
    that enable this behavior are the assembly's metadata and the .NET's dynamic common
    type system.
  prefs: []
  type: TYPE_NORMAL
- en: A simple look at the basic members of the highest element in .NET hierarchy
    (`System.Object`) shows that Reflection is at the very core of its inception,
    since we have a `GetType()` method that is going to be present all along the chain
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, `GetType()` returns an instance of the `System.Type` class, served
    in a way that encapsulates all the metadata of the object being examined. It is
    with this `System.Type` instance that you will be able to traverse all details
    of the type or class (except the IL code) and also gain the ability to discover
    the surrounding context: the module that implements that type and its containing
    assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [Chapter 3](part0023.xhtml#aid-LTSU2 "Chapter 3. Advanced Concepts of
    C# and .NET"), *Advanced Concepts of C# and .NET*, we included the following sample
    to test the very basics of Reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we''re using `GetType()` and casting the result to a `Type` object,
    which we can later use to inspect the members of the `dyn` variable. A look at
    the Object Browser in the search for the `System.Type` instance makes things quite
    clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reflection in the .NET Framework](img/image00504.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot shows how `System.Type` implements the `IReflect` interface,
    which provides a gang of methods for introspection (most of them starting with
    `Get`, followed by the target introspection to find out fields, members, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note the presence of the `InvokeMember` method, which permits dynamic
    invocation of the type''s members at runtime and can be used for a variety of
    purposes. The return values of these methods are arrays that represent the information
    structure of every individual member: `MemberInfo[]`, `PropertyInfo[]`, `MethodInfo[]`,
    and `FieldInfo[]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start coding some of these ideas in a simple console application
    that declares a `Person` class with three properties and a method and learn how
    we get all this information at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please, notice that the `Person` class owns a property which uses a method
    declared in a distinct namespace (`System.Windows.Forms`). There''s no problem
    to access that method via Reflection and invoking it, only that we have to reference
    the namespace, together with `System.Reflection`, that we''ll use a bit later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re including the output in the code since it is pretty predictable, and
    we''re just asking for the type. However, let''s continue adding some more lines
    before the call to `Read()`, to find out more about the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we find out something else about the internal structure, as shown in the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reflection in the .NET Framework](img/image00505.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Some of the *hidden* members show up now, such as the default constructor created
    by the compiler (`.ctor`), the conversion of the `{get; set;}` declarations into
    pairs of field/access methods, and the inherited members from the object. Using
    these methods, we obtain all the information that's relative to a member.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can we find out the structure of another type, but we can also invoke
    its members, as mentioned earlier. For example, the `ShowPersonData` method receives
    two parameters to configure a `MessageBox` object, where it presents some information
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we need to be able to call the method and also configure and
    send the parameters it requires. We can do this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since parameters can be of any type, we create an object array that will be
    used at runtime to correspond every item in the array with its argument in the
    method. In this case, we want to pass the caption of the dialog box and the icon
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, we get the corresponding `MessageBox` object at runtime with the
    correct configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reflection in the .NET Framework](img/image00506.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, we can also perform the manipulation of properties in a similar
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output confirms that the property was of a read/write kind and also confirms
    the results of the change (note that we don''t pass any argument to read the data):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reflection in the .NET Framework](img/image00507.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Calling external assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we need information and/or functionality concerning a different assembly,
    that's also possible using the `Assembly` object or by referencing the assembly
    and obtaining its data from the static `GetType()` method of the `Type` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes those that are part of .NET Framework itself. To access all these
    functionalities, the `System.Reflection` namespace provides a cluster of related
    possibilities. A syntax such as this can serve the purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, we're reflecting on a reference type (`System.Math`) included in the basic
    library, `mscorlib`, to find out how many members are included, such as in the
    previous case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can load an assembly at runtime using the `Assembly` object
    and even create an instance of that object using the `CreateInstance()` static
    method with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to get all the referenced assemblies of the current (running)
    assembly. The `GetExecutingAssembly()` method returns an `Assembly` object pointing
    to itself, and by calling `GetReferencedAssemblies()`, we get all this information.
    The following code will suffice to obtain this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire output (including the three previous routines) looks like what is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling external assemblies](img/image00508.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Generic Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reflection of generic types is also available and can be checked using Boolean
    properties, such as `IsGenericType`, `IsGenericTypeDefinition`, or `GetGenericArguments()`.
    The same mechanisms apply in this case, only checking the corresponding types
    for the difference. The following is a short demo, which declares a generic `Dictionary`
    object and recovers information on its types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The—quite predictable—output shows characteristics about the type (generic)
    and its members (non generic) and iterates over a loop, checking for the genericity
    of every type (using the `IsGenericParameter` Boolean property) before printing
    its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generic Reflection](img/image00509.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, changing the methods' calls and/or adding some checking, we can also use
    generic types with Reflection, just as we did with the *classical* ones.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting code at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting possibility is the capacity of some classes in the .NET
    Framework to emit code at runtime and—eventually—compile and run it. Observe that
    Visual Studio itself creates code in many scenarios: when creating the structure
    of documents in different languages from a template, using code snippets, scaffolding
    an ORM in ASP.NET, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a task that can be achieved mainly in two ways: using CodeDOM or by
    means of classes inside the `System.Reflection.Emit` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: The System.CodeDOM namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first option refers to the `System.CodeDOM` and `System.CodeDOM.Compiler`
    namespaces, and it''s been present in .NET since the very first version of the
    framework. Note the DOM part of the name: it means Document Object Model, just
    like in HTML, XML, or other document structures.'
  prefs: []
  type: TYPE_NORMAL
- en: With classes inside CodeDOM, we can generate source code using templates that
    define coding structures in different languages, so we can even generate source
    code in all languages supported by .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate code for any .NET structure, CodeDOM classes represent any aspect
    of the generated code, and we should use two different mechanisms: one that expresses
    the elements to be built and another that—when lunched—produces the actual code.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine how can we generate the previous `Person` class; only, reduce
    it to a minimum of elements for sake of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of `CodeCompileUnit`, which is in charge of generating the DOM
    structure of our component (its code graph). This structure is responsible for
    scaffolding the different members our class contains: properties, fields, methods,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the elements have to be created one by one using classes available
    in CodeDOM, which represent every possible reserved word or structure (classes,
    methods, parameters, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, all elements created individually are included in the `CodeCompileUnit`
    object prior to its generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code, which produces a file that contains the same
    definition of a `Person` class that we used at the beginning of this chapter (for
    the sake of brevity, I''m just including here the initial lines and final lines.
    You''ll find the whole code in demo `Reflection1` inside this chapter''s source
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once we establish our entry point in `Program5`, its execution generates a file
    with the same code that we had in the `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you will have to check the `bin/debug` directory, since we didn't
    establish a different output path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see something like the following screenshot in your **Solution Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The System.CodeDOM namespace](img/image00510.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the generated code is pretty verbose. However, that's what it
    takes to generate code feature by feature. Let's go briefly through it and underline
    the most important classes implied in the generation, starting with the end of
    the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: The object that puts everything to work is the `CodeDomProvider` class. It has
    to be instantiated, indicating the language to be used (`CSharp`, in our case).
    At the end, we will invoke its `GenerateCodeFromCompileUnit` method, which will
    use all previous definitions to produce the actual code inside the file defined
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: So, at the top of `Program5`, we declare a `CompilerUnit` object. The other
    crucial component is the `CodeTypeDeclaration` object, which is in charge of storing
    all declarations used while code generation takes place.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the classes implied in the construction are merely helper classes
    to build each brick of the resulting class. This is the role of the `CodeNamespace`,
    `CodeNamespaceImport`, `CodeSnippetTypeMember`, `CodeCommentStatement`, `CodeMemberMethod`,
    and `CodeParameterDeclarationExpression` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may think that this is too much effort to just create the resulting
    class, keep in mind that the automatization of tasks inside Visual Studio follows
    similar paths and that you could create you own mechanisms of code generation
    suited to your needs or the company's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: With such programmable context, it's easy to imagine a number of situations
    in which code generation can be tuned by the generating program at runtime, allowing
    you to produce code with different variations depending on options we established
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: The Reflection.Emit namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Reflection.Emit` namespace is intended for code generation, allowing
    developers to create code or metadata from within their applications, independent
    of the specifics of the operating system's loaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, this namespace offers the following programmatic options:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the building of modules and assemblies at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates classes and types and emits IL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It launches a .NET compiler to build apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way the code is generated here is different from CodeDOM in several aspects.
    One of them is the ability to generate IL code at runtime, which means that the
    execution of some C# code will produce outputs not coded in C# but using these
    instruments.
  prefs: []
  type: TYPE_NORMAL
- en: One of the objects implied in this type of code generation is the `DynamicMethod`
    object included in the `System.Reflection.Emit` namespace. This object allows
    the obtention of another object of type `ILGenerator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get `ILGenerator`, you can produce IL code dynamically in a very straightforward
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how we finally call the `DynamicObject.Invoke` method as if it were
    a delegate. If you test the previous code, the output generated will correspond
    to what is the equivalent of the counterpart lines of the code programmed in C#,
    which produces the same information in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Reflection.Emit namespace](img/image00511.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Also, note the presence of the `OpCodes.Ret` value in the last call to `ilgen.Emit`.
    This generates a return statement, which pushes the return value, if present,
    from the evaluation stack to the caller's evaluation stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at fields related to OpCodes, you''ll discover that it provides
    an extensive list of field representations of MSIL instructions, as shown in the
    next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Reflection.Emit namespace](img/image00512.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you want to take a deep dive into these possibilities, there's
    a page on MSDN, which contains an exhaustive relation of all the OpCodes at [https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other big topic we want to cover in this chapter is the possibility of a
    .NET application "talking" to other installed applications in our system. This
    talking means instantiating these applications and interchanging data between
    them or asking the other applications to perform tasks we should program ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Initially (in versions previous to C# 4.0), this technology was exclusively
    COM-based. The trick was done via Interop using some DLLs called **Type Libraries**
    (**TLB**) or **Object Libraries** (**OLB**). The programmer should then use (reference)
    these libraries and instantiate their internal objects, which represent the internal
    components of the application to communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was possible using a **Runtime Callable Wrapper** (**RCW**) whose operational
    schema is explained in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interoperability](img/image00513.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how communication was made between the COM and .NET worlds. You have
    to keep in mind that COM is not a managed environment, and it executes instructions
    native to the Windows operating system. The RCW component was responsible for
    this and acted as a proxy between both execution contexts.
  prefs: []
  type: TYPE_NORMAL
- en: No optional parameters were available for a C# programmer in this model. So,
    you had to pass as many parameters as the method defined, using the `System.Reflection.Missing.Value`
    type, besides other difficulties present in the way Reflection was used to find
    out which members were present and usable, plus other related paraphernalia.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is code that illustrates such a situation in early versions. It assumes
    that a reference has been made to the corresponding TLB of Microsoft Word, which
    exposed an object called `ApplicationClass` to allow Word instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note how all the arguments that the `Open` method defines, had to be passed
    as `missing` for this case. As you see, this is a pretty clumsy way to open a
    document and access its members (actually, when using this Interop feature, operating
    from Visual Basic .NET was much easier and simple some time ago.).
  prefs: []
  type: TYPE_NORMAL
- en: Primary Interop Assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As technologies evolved, type libraries were replaced with something called
    **PIAs** (**Primary Interop Assemblies**), which play the same role as the RCWs
    but allow programmability in an easier manner.
  prefs: []
  type: TYPE_NORMAL
- en: So, the way to communicate with external (interoperable) applications becomes
    possible through those libraries that take care of the required marshalling of
    data types between two worlds which are—at first—not so easy to connect, especially
    for those programmers not skilled enough to use the COM platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema shows this communication architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Primary Interop Assemblies](img/image00514.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start from the beginning, only using the latest versions to see how we
    operate today.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain (and see in action) an instance of an interoperable application, the
    first step is to reference the corresponding PIA that will serve as the proxy.
    This is available in the **References** option of any .NET application, only not
    in the default DLL's tab but in the **Extensions** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you will see a bunch of DLLs available, and—in many cases—you'll observe
    duplications. You have to pay attention to the version number, which will vary
    depending on the Office version installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, you might find duplications of even the same versions in different
    locations in your box. This is due to the fact that the installation of Office
    allows the user to manually include these PIAs during the process or it might
    be due to the previous installation of older Office versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Primary Interop Assemblies](img/image00515.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you check the **COM** option of **Reference Manager**, you will also discover
    the presence of some entries with the word `Excel` inside. They might vary in
    your machine, but usually, they point to the corresponding executable being referenced
    (`Excel.exe`, in the next screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you mark this option as well and accept the selection, you won''t
    see a reference to `Excel.exe` in the list of your Project''s references. Instead,
    you''ll see a library whose name is the same as what it was in the previous case
    (when I referenced the PIA) but one that really points to a DLL in the GAC called
    `Microsoft.Office.Interop.Excel`, followed by a GUID number: the reference is
    "redirected" to point to the most suitable library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Primary Interop Assemblies](img/image00516.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The object model that Excel offers to the programmer recalls exactly that of
    its user interface. There's an `Application` object, which represents the entire
    application, and each `Workbook` object is represented by its corresponding object
    in the model. Each one contains a collection of the `Worksheet` objects. Once
    the starting point is ready, the `Range` object enables you to operate with individual
    (or groups of) cells.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, let's call an Excel instance in the modern, easier way, and show
    it with a new Excel book. In this sample, in order to interchange information
    between our application and Excel or Word later on, I'm using a basic Windows
    Forms application, which will launch Excel using the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhere in our Windows Form, we define this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This, indeed, launches Excel and passes this information to the four cells
    referenced in the code, as we can see in the output. Note the initial declarations
    to reference Excel and Word in our code. With this alias, it becomes easier to
    reference any object in the proxy and the code becomes less verbose. Since we
    call `OpenExcel` when the document is loaded, both applications will be opened,
    the second one being Excel presenting our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Primary Interop Assemblies](img/image00517.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is nothing amazing or unexpected, but we see that it's fairly easy to call
    other applications with Interop and pass data to them. Anyway, some peculiarities
    of Office Interop (also common to other applications) are evident here.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, you have to declare the `excel` object as `Visible`. That's because
    by default, Office Interop applications don't show up. This is very useful when
    you just want a functionality to happen and recover the results in your application
    without the target app bothering the final user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we''re using some objects you might not be familiar with, since
    they belong to the target application: `Range` represents a range of cells within
    the current Worksheet, the `get_Range` method recovers a `Set`/`Get` reference
    to the required cells we pass as an argument. Note, we can indicate the range
    required in the string we passed to this method or use an enumeration, such as
    in `get_Range(c1, c2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also create a `Range` object using a syntax like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Observe that in this case, we declare a `Sheet` object recovered from the available
    collection of sheets that Excel creates in the initial workbook. With this object
    and using an array-like syntax, we select the initial and ending cells to include
    in our range (by default, all of them are accessible).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that when we define a rectangle with our cells, several columns
    are collected, so the resulting modification ends up with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Primary Interop Assemblies](img/image00518.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Formatting cells
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most likely, we will have to format the contents we pass to an Excel sheet.
    This implies another way to operate (which is very coherent; let's underline that).
  prefs: []
  type: TYPE_NORMAL
- en: Most of these objects are defined separately and then applied to the corresponding
    object to be targeted. In the case of formatting, keep in mind that the format
    should be applied to cells that hold some value (it might well be that you opened
    an existing workbook object).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''re going to create another method in our Form to call Excel and create
    a style that we can apply to our cells. Something like this would be enough for
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that some objects always make a reference to the current (active in that
    moment) element, such as `ActiveWorkBook` or an alternative `ActiveSheet`. We
    also can count on an `ActiveCell` object that operates on a given range previously
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call `oRange.Columns.AutoFit()` in order to make every column as
    wide as the maximum length inside it. With this definition, we can call `FormatCells`
    whenever we need the style to be applied on any range. In this case, operating
    over the second range defined, the output shows the correct formatting applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting cells](img/image00519.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inserting multimedia in a sheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another interesting option is the ability to insert external images inside
    the area of our selection. This can even be performed using any content available
    on the clipboard. In this case, the code is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the Packt logo located in the selected cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting multimedia in a sheet](img/image00520.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re assuming that a picture with the Packt Publishing logo is available
    at the current (execution) path. Of course, we could save it in a resource file
    and recover it in some other fashion. For example, we can recover the front page
    image of this book from its corresponding link on the Packt Publishing site at
    [https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg](https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg)
    using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we need the help of the `WebRequest/WebResponse` objects that belong
    to the `System.Net` namespace as well as the `Stream` class, which you find as
    part of the `System.IO` namespace. As you can imagine, in the Windows Forms code,
    we change the previous code for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output shows this book''s front page located at cell A6 (remember
    that it''s important to select the destination target before you do this):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting multimedia in a sheet](img/image00521.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this manner, we have a bunch of possible additions to build Excel sheets,
    including external content, which, of course, doesn't have to be graphical and
    admits other types of content (even video).
  prefs: []
  type: TYPE_NORMAL
- en: When we deal with graphics in Excel, usually what we really want is to instruct
    Excel to build a business chart from some data. Once that is done, we can save
    it as an image file or recover it and present it in our application (often not
    showing Excel's user interface in any manner).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an Excel chart object up and running, we have to add a chart to the
    WorkBook''s chart collection in a manner similar to what we did with the WorkBook
    itself. To generate a given type of chart, a useful object is the `ChartWizard`
    object, which receives configuration parameters that allow us to indicate one
    from the many types of charts available and the text of `Title` required for our
    chart. So, we might end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The explanation of the different types of charts and styles can be found in
    the MSDN documentation and exceeds the coverage of this book (it is available
    at [https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx](https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx)).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we finally copy the generated graphic to the clipboard in order to
    use the same technique as earlier, although you can use some other approaches
    to get the image as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get some straightforward data to build the image, I''ve started from an
    old Microsoft demo, which recovers processes from the memory but changes the target
    to only processes related to Microsoft Office applications and reduces the code
    to a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In another event handler linked to a button (the entire demo is available,
    as always, with the companion code for this chapter), we launch the process in
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re assuming that a `PictureBox` control is present in the form with the
    name `pbChart`. However, before showing the results, note that if the user interacts
    with Excel, we need to manually close and destroy the resources created by the
    application; so, in the `form_closing` event, we''re including this sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides, we have created an Excel object at the beginning (declared in the
    form''s scope and instantiated in the `Initialize` event), so the `excel` variable
    is available alongside all methods in the form. When executing, we get both applications
    running (I keep Excel visible for demoing purposes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting multimedia in a sheet](img/image00522.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When pressing the **Generate GraphChart** button, we have a duplicate output
    showing the generated graphic in `ActiveWorkBook` along with the picture shown
    within the `PictureBox` control in the Form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting multimedia in a sheet](img/image00523.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Other common usages of Excel Interop include the automation of graphic reports,
    the generation of bulk e-mails, and automatic generation of business documents
    (invoices, receipts, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Interop with Microsoft Word
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other big star in Office Automation solutions is Microsoft Word. Just like
    Excel, it exposes a very complete **Object Model** (**OM**), updated to expose
    the new features accompanying every release, and it's fully programmable in the
    same fashion as what we've been doing with Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, Word's OM, or just WOM, is radically different from Excel and includes
    all the characteristics a programmer would need to automate practically any task.
    Actually, the user interface objects (as it happens with Excel) are faithfully
    represented, and that includes the ability to invoke dialog boxes that launch
    certain processes (such as spellcheck) or any other typical configuration feature
    of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Excel, automation takes place using a PIA (`Microsoft.Office.Interop.Word.dll`),
    and the initialization process is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Provided that we have a button (`btnOpenWord`), we instantiate a Word object
    at initialization time; so, when the user clicks, we just have to make Word visible
    and use the `Selection` object (which, in case there's nothing selected yet, refers
    to the caret).
  prefs: []
  type: TYPE_NORMAL
- en: 'From this point, `Selection` offers several methods to insert text (`InsertDatetime`,
    `InsertAfter`, `InsertBefore`, `InsertParagraph`, `Text`, and so on). Note how
    the resulting process writes to Word and the whole text inserted remains selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interop with Microsoft Word](img/image00524.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As always, it''s important to release objects used during runtime. So, we code
    the following in the `form_closing` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The manipulation of images is even easier, since we can reference any external
    image with a few lines of code. To load the same image as in the Excel demos,
    we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It's important to specify here the position of the image because otherwise,
    the whole selection would be replaced by the `AddPicture` method. This is why
    we add a fourth parameter (`Range`), which allows us to indicate where the image
    should go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, observe how we can always know every aspect of the document''s elements
    (the number of characters and collections of `Rows`, `Columns`, `Shapes`, `Tables`,
    `Paragraphs`, and so on). In addition, since we can now use named parameters,
    we just have to pass the required ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interop with Microsoft Word](img/image00525.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Formatting can also be achieved very easily by selecting a `Range` object and
    configuring it to the required values (we created a special button for this named
    `btnFormat`; so, in the `Click` event, we code the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous text in our document, once the click event is invoked, we''ll
    get the output shown in this capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interop with Microsoft Word](img/image00526.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another very common use of Word relates to its ability to operate with text
    and return such text to the caller function. This is especially useful in checking
    spelling and other internal engines, such as grammar revision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique consists of passing the required text to Word, selecting it,
    and launching the **Spell & Grammar** dialog box to operate on it. Once the text
    is revised, we can return the corrected text to the calling application. Let''s
    see how this works in a sample. We have a button labeled `Spell Check` (named
    `btnSpellCheck`), which launches the process of spelling correction using this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output consists of three elements: our .NET application, Word, and the
    **Spell & Grammar** dialog box, which is launched when we call the `CheckSpelling`
    method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interop with Microsoft Word](img/image00527.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the process is over, the corrected results are returned to the caller function,
    where we update the `RichTextBox` control used to hold the text. Note that you
    can keep Word invisible and the only functionality available in the user interface
    would be your application and the **Spell & Grammar** dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we check the presence of an opened document, which should otherwise
    generate a runtime exception. After the process, our `RichTextBox` control will
    contain the corrected text, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interop with Microsoft Word](img/image00528.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Besides this utility, practically any other Office-related functionality is
    available via automation in a similar manner. However, this is not the only way
    we can use and extend the Office functionality by means of .NET applications.
    Actually, one of the most successful options relies on Add-In constructions or
    Office apps.
  prefs: []
  type: TYPE_NORMAL
- en: Office apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the official page of Office 2013 (the version we''re using here, although
    this sample works perfectly well in the 2016 version), Office Apps are defined
    in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Apps for Office enable users to run the same solutions across applications,
    platforms, and devices, and provide an improved experience within Office applications
    by integrating rich content and services from the web.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key architecture is explained a bit further, pointing out that these apps
    run within supported Office 2013 applications by using the power of the web and
    standard web technologies such as HTML5, XML, CSS3, JavaScript, and REST APIs.
    This is very important for a number of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, the use of standard technologies allows us to incorporate any previous
    or already created, functional content we might have. If it works on the Web,
    it'll work on one of these apps (although automation via JavaScript APIs does
    not cover all possibilities that PIAs offer). However, on the other hand, APIs
    exposed by JavaScript 5/6 make a number of new programming options available to
    developers (Web Workers, Web Sockets, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is not enough, consider the huge amount of JavaScript and CSS frameworks
    available today: jQuery, BootStrap, Angular, among others. We can use all of them
    in these applications. Overall, we''re talking about a webpage that is hosted
    inside an Office client application (Excel, Word, PowerPoint, and Project are
    available options).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that these apps can run in desktop clients, Office Online, mobile browsers,
    and on premises and in the cloud as well. Options of deployment include the Office
    Store or on-site catalogs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works, by using the default template that Visual Studio 2015
    offers and analyzing and customizing these contents for an initial, working demo.
  prefs: []
  type: TYPE_NORMAL
- en: The Office app default project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, let''s create a new project and select the **Visual C#-Office/SharePoint-Apps**
    tree element: we''re offered three choices. If you select the **Apps for Office**
    option, a selection box will be shown (I''ll use **Task pane** here, but you also
    have **Content** and **Mail**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Office app default project](img/image00529.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other templates for many different types of apps are at your disposal on the
    site available at [http://dev.office.com/code-samples#?filters=office%20add-ins](http://dev.office.com/code-samples#?filters=office%20add-ins).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demo, I opt for Word as a destination Office application, although
    by default, all checkboxes are marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Office app default project](img/image00530.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you review the resulting files, you''ll notice that these apps are basically
    composed of two parts: a manifest file, which configures the app''s behavior,
    and a web page, which references all required resources: jQuery, style sheets,
    JavaScript initialization files, a `web.config` file, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the manifest file, you''ll see that Visual Studio offers a configuration
    file editor, where you can indicate every functional aspect. A note within the
    **Activation** tab of that window reminds us of the possible targets where this
    app will possibly work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Office app default project](img/image00531.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Actually, this template already works once compiled, and it operates over a
    block of selected text, passing it back to the **Task** pane, which will appear
    to the right of a new Word document, showing the `Home.html` page. This page,
    in turn, loads the `Home.js` and `app.js` files, which take care of initialization.
    Other `.css` files are added for formatting purposes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this, there''s a very important piece of JavaScript that is referenced
    via CDN, `office.js`. This is the library in charge of the traffic between the
    two worlds present here: the Office programming model and the HTML5/CSS3/JS world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a graphic schema on the page at [https://technet.microsoft.com/en-us/library/jj219429.aspx](https://technet.microsoft.com/en-us/library/jj219429.aspx),
    which offers a visual look at the scenario at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Office app default project](img/image00532.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run the test, launch the application from Visual Studio, and when Word appears,
    type some text and select it. Optionally, you can try the *lorem trick* (you might
    know it already): simply type `=lorem(n)` in the document, where *n* is the number
    of lorem paragraphs you want to generate, and lorem text will automatically get
    appended to the current text of the document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we do that and select a fragment, the button labeled **Get data from selection**
    will recover the selected text and present it at the bottom of the **Task** pane.
    You should see something similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Office app default project](img/image00533.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Architectural differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this time, there's no reference to Interop libraries. This is a big
    architectural change, and it's undertaken by the Office JavaScript Object Model—not
    as exhaustive as the ones in PIAs libraries but wide enough to provide us with
    a lot of useful options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a very simple method to show how we can operate in the opposite
    direction: inserting text into the document from the **Task** pane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a new element to the **Task** pane user interface. A
    simple button will suffice for our purposes, so we''ll add a new button next to
    the already existing `get-data-from-selection` button: one that I''ll call `insert-data-from-Task-Pane`
    in the `Home.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is programming the button''s click event handler in a manner
    similar to what the template demo does, only simplifying the code to the maximum
    here. Thus, inside the `Home.js` file and next to the initialization of the other
    button, we will add a similar function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the body of `insertDataFromTaskPane`, contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that no dialog boxes are allowed on a **Task** pane; so we notify the user
    about the success or error of the process, calling `showNotification` on the app
    object, which sends data to the **Task** pane notification area, previously configured
    in the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we''re moving in both directions here: from the **Task** pane
    to the Word document, inserting a couple of lines and notifying how things worked
    out in the opposite direction. Observe that the `setSelectedDataAsync` method
    provides us with a mechanism to insert data into the document in a manner similar
    to what we did previously with `insertAfter` methods of the PIAs object model.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, remember that in the JavaScript world it's usual to assign a callback
    function as the last argument of many function calls in order to allow feedback
    on the resulting method or add an extra functionality once execution is finished.
    The argument recovered in the function declaration (the `result` object) contains
    properties that include relevant information, such as the status of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: There's plenty of information about programming this type of application in
    the MSDN documentation, in which you'll be able to see new types of applications
    of this sort, especially applications that allow the construction of Add-ins for
    Office 365.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for the sake of completeness, let''s show the results of the previous
    code in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural differences](img/image00534.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw several aspects of programming that have to do with the ability of .NET
    Framework to introspect its own assemblies and invoke its functionality in a standard
    fashion and even use CodeDOM's possibilities to generate code at runtime, enabling
    a generation of templates and other code fragments at will.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw a brief intro to `Reflection.Emit` just to check how it's possible
    to generate IL code at runtime and insert it into other executable code.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we covered the most common scenarios used
    in Office Automation, a technique that allows us to call functionalities included
    in Office, such as Excel and Word, and interact with them via proxy libraries
    (the Primary Interop Assemblies) in a way in which we gain almost absolute control
    over the other applications, being able to pass and recover information between
    our application and the Office partner via instructions emitted to these proxies.
  prefs: []
  type: TYPE_NORMAL
- en: We finally included a short introduction to the new way of building components,
    which appeared in version 2013 of Office (Office apps) and saw the basic architecture
    of these types of components, reviewing the basic template Visual Studio offers
    and modifying it to include a simple, double direction functionality via **Office
    JavaScript Object Model**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on database programming, covering the foundations
    of interactions with relational models available in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
