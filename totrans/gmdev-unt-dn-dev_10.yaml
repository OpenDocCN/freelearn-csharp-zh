- en: '*Chapter 7*: Understanding the Mathematics of Computer Graphics in Unity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：理解 Unity 中计算机图形学的数学'
- en: Mathematics is a topic that is often discussed in game development. Although
    Unity has provided game developers with many helper functions to reduce the complexity
    of using mathematics in Unity, it is still necessary to have some basic mathematical
    knowledge about computer graphics, such as coordinate systems, vectors, matrices,
    and quaternions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数学是游戏开发中经常讨论的一个主题。尽管 Unity 为游戏开发者提供了许多辅助函数来减少在 Unity 中使用数学的复杂性，但仍然需要具备一些关于计算机图形学的基本数学知识，例如坐标系、向量、矩阵和四元数。
- en: 'In this chapter, we will explore the following key topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下关键主题：
- en: Getting started with coordinate systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从坐标系开始
- en: Working with vectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理向量
- en: Working with the transformation matrix
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换矩阵
- en: Working with quaternions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理四元数
- en: By the end of this chapter, you will have mathematical knowledge of computer
    graphics and know how to use vectors, matrices, quaternions, and Euler angles
    in scripts correctly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备计算机图形学的数学知识，并知道如何在脚本中正确地使用向量、矩阵、四元数和欧拉角。
- en: Now, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Getting started with coordinate systems
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从坐标系开始
- en: Like many files, most model files are binary files. When a game engine, such
    as Unity, needs to render a model, the data of the model, such as the vertex array
    of the model and the index of the vertex array, will be extracted and processed
    through the render pipeline of the game engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多文件一样，大多数模型文件都是二进制文件。当游戏引擎，如 Unity，需要渲染一个模型时，模型的日期，如模型的顶点数组和顶点数组的索引，将通过游戏引擎的渲染管道提取和处理。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about the render pipeline in computer graphics
    at [https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview)找到更多关于计算机图形学中渲染管道的信息。
- en: 'A graphics render pipeline mainly includes two functions: one to convert the
    3D coordinates of an object into 2D coordinates in the screen space and the other
    to color each pixel of the screen. Finally, the 3D model is rendered on the 2D
    screen.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图形渲染管道主要包含两个功能：一个是将对象的 3D 坐标转换为屏幕空间中的 2D 坐标，另一个是为屏幕上的每个像素着色。最后，3D 模型将在 2D 屏幕上渲染。
- en: 'In the process of the render pipeline, a lot of coordinate system conversion
    work will be involved, as you can see in *Figure 7.1*. So, it''s an important
    topic and we will introduce information about coordinate systems in this section:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染管道的过程中，将涉及大量的坐标系转换工作，正如你在*图 7.1*中看到的。因此，这是一个重要的主题，我们将在本节中介绍有关坐标系的信息：
- en: '![Figure 7.1 – Coordinate transformation process (CC BY 4.0)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 坐标变换过程（CC BY 4.0）'
- en: '](img/Figure_7.01_B17146.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17146.jpg)'
- en: Figure 7.1 – Coordinate transformation process (CC BY 4.0)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 坐标变换过程（CC BY 4.0）
- en: Understanding left-handed and right-handed coordinate systems
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解左手坐标系和右手坐标系
- en: A coordinate system is a geometric system that typically uses numbers to determine
    the position of a point in space.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标系是一种几何系统，通常使用数字来确定空间中某点的位置。
- en: In mathematics, there are many different types of coordinate systems, such as
    the **number line coordinate system**, **Cartesian coordinate system**, and **polar
    coordinate system**. In computer graphics, the **Cartesian coordinate system**
    is the most commonly used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，有许多不同类型的坐标系，例如**数轴坐标系**、**笛卡尔坐标系**和**极坐标系**。在计算机图形学中，**笛卡尔坐标系**是最常用的。
- en: '![Figure 7.2 – Cartesian coordinate system'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 坐标系'
- en: '](img/Figure_7.02_B17146.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17146.jpg)'
- en: Figure 7.2 – Cartesian coordinate system
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 坐标系
- en: The Cartesian coordinate system is also very common in our daily lives, that
    is, the *x* axis, *y* axis, and *z* axis are used to describe the coordinate information
    of the object. When used to describe 3D space, the Cartesian coordinate system
    can be either a **left-handed coordinate system** or a **right-handed coordinate
    system**. As their names imply, we can actually distinguish between the two by
    using the left hand and the right hand.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔坐标系在我们的日常生活中也非常常见，即使用 *x* 轴、*y* 轴和 *z* 轴来描述物体的坐标信息。当用于描述 3D 空间时，笛卡尔坐标系可以是**左手坐标系**或**右手坐标系**。正如它们的名称所暗示的，我们实际上可以通过使用左手和右手来区分这两种坐标系。
- en: '![Figure 7.3 – Coordinate systems (CC BY-SA 3.0)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – 坐标系统 (CC BY-SA 3.0)'
- en: '](img/Figure_7.03_B17146.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.03_B17146.jpg]'
- en: Figure 7.3 – Coordinate systems (CC BY-SA 3.0)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.3 – 坐标系统 (CC BY-SA 3.0)
- en: As shown in *Figure 7.3*, we can distinguish between the left-handed coordinate
    system and the right-handed coordinate system by visualizing the thumb pointing
    to the *x* axis, the index finger to the *y* axis, and the middle finger to the
    *z* axis.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Figure 7.3*所示，我们可以通过可视化拇指指向*x*轴、食指指向*y*轴和中指指向*z*轴来区分左手坐标系和右手坐标系。
- en: '![Figure 7.4 – Left-handed coordinate system in Unity'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.4 – Unity中的左手坐标系'
- en: '](img/Figure_7.04_B17146.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.04_B17146.jpg]'
- en: Figure 7.4 – Left-handed coordinate system in Unity
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.4 – Unity中的左手坐标系
- en: If we look in the Unity Editor, we can see that Unity uses the left-handed coordinate
    system, as shown in *Figure 7.4*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Unity编辑器中查看，我们可以看到Unity使用的是左手坐标系，如图*Figure 7.4*所示。
- en: Local space
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地空间
- en: Coordinate space is the space where 3D positions and transformations exist within
    the coordinate system, such as **local space** and **world space**. In Unity,
    we often work with local space or world space. Local space is related to the concept
    of the **parent-child relationship**, which means it uses the origin and axes
    of the GameObject's parent node in the hierarchy of GameObjects. The position,
    rotation, and scaling of the parent GameObject will affect the local space defined
    by it. Therefore, this is useful not when we are dealing with the transformation
    of a single GameObject but of a group of GameObjects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标空间是3D位置和变换存在于坐标系中的空间，例如**本地空间**和**世界空间**。在Unity中，我们经常使用本地空间或世界空间。本地空间与**父子关系**的概念相关，这意味着它使用GameObject层次结构中父节点的原点和轴。父GameObject的位置、旋转和缩放将影响由其定义的本地空间。因此，这在处理单个GameObject的变换时不是很有用，但在处理一组GameObject时非常有用。
- en: 'For example, in *Figure 7.5*, the five cube objects are all children of the
    GameObject named **LocalSpace**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*Figure 7.5*中，这五个立方体对象都是名为**LocalSpace**的GameObject的子对象：
- en: '![Figure 7.5 – LocalSpace parent object'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.5 – LocalSpace父对象'
- en: '](img/Figure_7.05_B17146.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.05_B17146.jpg]'
- en: Figure 7.5 – LocalSpace parent object
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.5 – LocalSpace父对象
- en: We can see that the `0`. Now, let's move this parent object down 2 units along
    the *y* axis and also rotate it 45 degrees around the *y* axis.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`0`。现在，让我们将此父对象沿*y*轴向下移动2个单位，并围绕*y*轴旋转45度。
- en: '![Figure 7.6 – LocalSpace parent object'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.6 – LocalSpace父对象'
- en: '](img/Figure_7.06_B17146.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.06_B17146.jpg]'
- en: Figure 7.6 – LocalSpace parent object
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.6 – LocalSpace父对象
- en: As shown in *Figure 7.6*, all these cubes have moved down 2 units along the
    *y* axis and rotated 45 degrees around the *y* axis. However, if we look at the
    position and rotation of individual cubes in the **Inspector** window, we can
    see that these values have not changed. This is because, currently, they are in
    local space defined by their parent object, and the position and rotation of a
    single cube relative to its parent object have not changed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Figure 7.6*所示，所有这些立方体都沿*y*轴向下移动了2个单位，并围绕*y*轴旋转了45度。然而，如果我们查看**Inspector**窗口中单个立方体的位置和旋转，我们可以看到这些值没有改变。这是因为，目前，它们位于由父对象定义的本地空间中，单个立方体相对于其父对象的位置和旋转没有改变。
- en: '![Figure 7.7 – Local space child object'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.7 – 本地空间子对象'
- en: '](img/Figure_7.07_B17146.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.07_B17146.jpg]'
- en: Figure 7.7 – Local space child object
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.7 – 本地空间子对象
- en: 'We can change the local position, local rotation, and local scale of a child
    object through C# code at runtime, as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过C#代码在运行时更改子对象的本地位置、本地旋转和本地缩放，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Attach this script to the child object named **Cube (1)** and run the game.
    We can see in the following screenshot that the child object has moved 2 units
    along the *x* axis relative to the parent object and is magnified 2 times along
    the *y* axis relative to the parent object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到名为**Cube (1)**的子对象上并运行游戏。我们可以在下面的屏幕截图中看到，相对于父对象，子对象沿*x*轴移动了2个单位，沿*y*轴相对于父对象放大了2倍：
- en: '![Figure 7.8 – Changing the local postion and local scale'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.8 – 更改本地位置和本地缩放'
- en: '](img/Figure_7.08_B17146.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.08_B17146.jpg]'
- en: Figure 7.8 – Changing the local postion and local scale
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.8 – 更改本地位置和本地缩放
- en: In this section, we discussed local space. Next, we will explore world space.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了本地空间。接下来，我们将探索世界空间。
- en: World space
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界空间
- en: Unlike local space, which is defined by a parent GameObject, world space is
    the coordinate system for the entire Scene. The center of the Scene is the origin
    of world space.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与由父GameObject定义的局部空间不同，世界空间是整个场景的坐标系。场景的中心是世界空间的起点。
- en: Let's create a new Cube object in the Scene and this time, this new cube is
    not a child of other GameObjects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中创建一个新的Cube对象，这次，这个新立方体不是其他GameObject的子对象。
- en: '![Figure 7.9 – World space'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.9 – World space'
- en: '](img/Figure_7.09_B17146.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.09 – World space'
- en: Figure 7.9 – World space
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 世界空间
- en: As shown in *Figure 7.9*, when the position of the cube is `0`, the cube is
    located in the center of the Scene. If we change the *x* value of the cube position
    from `0` to `1`, then the cube will advance 1 unit along the *x* axis of world
    space.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.9*所示，当立方体的位置为`0`时，立方体位于场景的中心。如果我们将立方体位置中的*x*值从`0`改为`1`，那么立方体将在世界空间的*x*轴上前进1个单位。
- en: '![Figure 7.10 – Moving in world space'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.10 – Moving in world space'
- en: '](img/Figure_7.10_B17146.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.10 – Moving in world space'
- en: Figure 7.10 – Moving in world space
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 在世界空间中移动
- en: 'We can also modify the position, rotation, and scale of a GameObject in world
    space in a C# script. The following code snippet shows how to do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在C#脚本中修改GameObject在世界空间中的位置、旋转和缩放。以下代码片段展示了如何进行此操作：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `position` property is the world space position of the transform. In addition
    to directly modifying the `position` or `rotation` properties, we can also call
    the following method to modify the `position` and `rotation` properties of the
    object at the same time:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`position`属性是变换的世界空间位置。除了直接修改`position`或`rotation`属性外，我们还可以调用以下方法来同时修改对象的`position`和`rotation`属性：'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that this method requires a `Vector3`-type parameter and a `Quaternion`-type
    parameter. We will introduce vectors and quaternions later in the *Working with
    vectors* and *Working with quaternions* sections, respectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，此方法需要一个`Vector3`类型的参数和一个`Quaternion`类型的参数。我们将在*与向量一起工作*和*与四元数一起工作*部分分别介绍向量和四元数。
- en: Screen space
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕空间
- en: As we mentioned at the beginning of this section, the coordinate system can
    be used to determine a point in space. This refers to not only 3D space but also
    2D space. Screen space is the space defined by the viewer's screen. It means that
    the screen space projects the content onto the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，坐标系可以用来确定空间中的点。这不仅指3D空间，也指2D空间。屏幕空间是由观众屏幕定义的空间。这意味着屏幕空间将内容投影到屏幕上。
- en: 'In screen space, the coordinates are in 2D; (**0,0**) is the lower-left corner
    and (screen.width, screen.height) is the upper-right corner, as shown in the following
    screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕空间中，坐标是2D的；（**0,0**）是左下角，而（screen.width, screen.height）是右上角，如以下截图所示：
- en: '![Figure 7.11 – Screen space'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.10 – Moving in world space'
- en: '](img/Figure_7.11_B17146.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.11 – Screen space'
- en: Figure 7.11 – Screen space
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 屏幕空间
- en: '2D elements are often described in screen space, and the most common is the
    UI. Another common use of screen space is to get the position of the mouse input.
    The reason is obvious: the mouse moves on the screen. The following code snippet
    demonstrates how to get the position of the mouse in a C# script:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 2D元素通常在屏幕空间中描述，最常见的是UI。屏幕空间的另一个常见用途是获取鼠标输入的位置。原因很明显：鼠标在屏幕上移动。以下代码片段演示了如何在C#脚本中获取鼠标的位置：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `mousePosition` property of the `Input` class will return the current mouse
    position in screen space, and the preceding code will print the mouse position
    to the **Console** window, as shown in *Figure 7.12*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input`类的`mousePosition`属性将返回屏幕空间中的当前鼠标位置，前面的代码将打印鼠标位置到**控制台**窗口，如*图7.12*所示：'
- en: '![Figure 7.12 – Mouse position'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.12 – Mouse position'
- en: '](img/Figure_7.12_B17146.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.12 – Mouse position'
- en: Figure 7.12 – Mouse position
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 鼠标位置
- en: After obtaining the screen space position of the mouse, we can use the methods
    provided by Unity's `Camera` class to convert the screen space position to the
    world space position. In addition, Unity allows us to create a ray that goes from
    the camera through a screen point to the game world. This can help us deal with
    a common situation in games where we need to know what the player is clicking
    on in the 3D game world, even though the player can only actually click on a 2D
    screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得鼠标的屏幕空间位置后，我们可以使用Unity的`Camera`类提供的方法将屏幕空间位置转换为世界空间位置。此外，Unity允许我们创建一个从相机通过屏幕点延伸到游戏世界的射线。这可以帮助我们处理游戏中的一种常见情况，即我们需要知道玩家在3D游戏世界中点击了什么，尽管玩家实际上只能点击2D屏幕。
- en: 'The method signatures of some methods are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法的签名如下：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we just mentioned, the `ScreenPointToRay` method is very useful because it
    returns a `Ray` instance from the camera pointing to the mouse position in the
    world space. I hope you still remember the Collider component in the physics system
    we introduced in the previous chapter because we can use this method to cast a
    ray to the collider and get the details of the collider, and it can also be used
    to draw a line in the Scene view of the Unity Editor to help with debugging.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，`ScreenPointToRay`方法非常有用，因为它从相机返回一个指向世界空间中鼠标位置的`Ray`实例。我希望你仍然记得我们在上一章中介绍的物理系统中的Collider组件，因为我们可以使用这个方法向Collider发射射线并获取Collider的详细信息，并且它还可以用于在Unity编辑器的场景视图中绘制线条以帮助调试。
- en: 'Next, we will modify the previous code to implement a function that can detect
    whether there is a collider at the mouse click position and draw a red line in
    the Scene view if there is a collider:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改之前的代码以实现一个可以检测鼠标点击位置是否有碰撞体，并在有碰撞体的情况下在场景视图中绘制红线的功能：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As the code snippet shows, we are calling the `ScreenPointToRay` method to
    create a ray pointing in the direction of the mouse from the location of the main
    camera in the scene, and then using this ray to detect colliders in the Scene
    by calling `Physics.Raycast`, and finally calling `Debug.DrawLine` to draw a red
    line in the Scene view, as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码片段所示，我们调用`ScreenPointToRay`方法从场景中主相机的位置创建一个指向鼠标方向的射线，然后通过调用`Physics.Raycast`使用这个射线检测场景中的碰撞体，最后调用`Debug.DrawLine`在场景视图中绘制一条红线，如下面的截图所示：
- en: '![Figure 7.13 – Drawing a red line'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 – 绘制红线'
- en: '](img/Figure_7.13_B17146.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B17146.jpg)'
- en: Figure 7.13 – Drawing a red line
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 绘制红线
- en: In *Figure 7.13*, the top is the game view, which is the window where the game
    is running, and the bottom is the Scene view, which is the window for debugging.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.13*中，顶部是游戏视图，即游戏运行窗口，底部是场景视图，即调试窗口。
- en: 'We have introduced you to coordinate systems in this section. Next, we will
    discuss another very important topic: vectors.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中介绍了坐标系。接下来，我们将讨论另一个非常重要的主题：向量。
- en: Working with vectors
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与向量一起工作
- en: 'In game development, we use vectors to define directions and positions. As
    shown in the following figure, we draw a line between two points to represent
    a vector. In this case, the vector starts from the origin, which is point **B
    (0, 0)** on the graph, to point **A (6, 2)**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，我们使用向量来定义方向和位置。如图所示，我们画一条线连接两个点来表示一个向量。在这种情况下，向量从原点开始，即图上的点**B (0, 0)**，到点**A
    (6, 2)**：
- en: '![Figure 7.14 – 2D position'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14 – 2D位置'
- en: '](img/Figure_7.14_B17146.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B17146.jpg)'
- en: Figure 7.14 – 2D position
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 2D位置
- en: We can see this vector is made up of two components, namely *x* and *y*. They
    represent the distance from the origin along the *x* axis and the *y* axis. Therefore,
    this vector can be used to define the position of point `(x*x+y*y)`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个向量由两个分量组成，即*x*和*y*。它们代表沿*x*轴和*y*轴从原点起测量的距离。因此，这个向量可以用来定义点`(x*x+y*y)`的位置。
- en: In Unity, we will use the Vector2 structure to represent 2D vectors and points.
    The magnitude property of Vector2 returns the value of the magnitude of this 2D
    vector.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，我们将使用Vector2结构来表示2D向量和点。Vector2的长度属性返回这个2D向量的长度值。
- en: 3D vectors are similar to 2D vectors, but we also need to consider the value
    of the *z* axis. The magnitude of a 3D vector is the square root of `(x*x+y*y+z*z)`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 3D向量与2D向量类似，但我们也需要考虑*z*轴的值。3D向量的长度是`(x*x+y*y+z*z)`的平方根。
- en: 'Unity also provides the `Vector3` structure to represent 3D vectors and points.
    If you look at the Inspector window of a GameObject in the Scene, you will find
    that the **Position**, **Rotation**, and **Scale** properties of the object are
    all Vector3 types, as shown in the following figure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还提供了 `Vector3` 结构来表示 3D 向量和点。如果你查看场景中 GameObject 的检查器窗口，你会发现在对象的 **位置**、**旋转**
    和 **缩放** 属性都是 Vector3 类型，如下面的图所示：
- en: '![Figure 7.15 – Transform of a GameObject'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – GameObject 的变换'
- en: '](img/Figure_7.15_B17146.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B17146.jpg)'
- en: Figure 7.15 – Transform of a GameObject
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – GameObject 的变换
- en: Vector addition
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量加法
- en: Since vectors can be used to describe positions, they can also be used to describe
    positions that change over time. A moving object has a velocity, which is the
    speed of the object in a given direction.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量可以用来描述位置，它们也可以用来描述随时间变化的位置。一个移动的物体有一个速度，这是物体在给定方向上的速度。
- en: '![Figure 7.16 – Vector addition'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16 – 向量加法'
- en: '](img/Figure_7.16_B17146.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B17146.jpg)'
- en: Figure 7.16 – Vector addition
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 向量加法
- en: 'As shown in *Figure 7.16*, suppose an object is currently located at point
    **A** and its velocity is (1, 1) per minute, which means the object will move
    in a direction that is 1 unit further on the *x* axis and 1 unit further on the
    *y* axis. So, we will add its current position vector to its velocity vector to
    calculate where it will end up after 1 minute:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 7.16* 所示，假设一个物体当前位于点 **A**，并且它的速度是每分钟 (1, 1)，这意味着物体将在 *x* 轴和 *y* 轴上各移动
    1 个单位。因此，我们将它的当前位置向量与其速度向量相加，以计算 1 分钟后它将到达的位置：
- en: '`(6, 2) + (1, 1) = (7, 3)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`(6, 2) + (1, 1) = (7, 3)`'
- en: The new position of this object after 1 minute is (7, 3).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个物体在 1 分钟后的新位置是 (7, 3)。
- en: How to subtract vectors
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何减去向量
- en: Vector subtraction and vector addition are very similar. We can reverse the
    direction of the second vector and use vector addition. Let's still use the previous
    example. Suppose a moving object is currently located at point A and its velocity
    is (-1, -1) per minute, which means the object will move in a direction that is
    -1 unit further on the *x* axis and -1 unit further on the *y* axis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 向量减法和向量加法非常相似。我们可以反转第二个向量的方向并使用向量加法。让我们仍然使用之前的例子。假设一个移动的物体当前位于点 A，并且它的速度是每分钟
    (-1, -1)，这意味着物体将在 *x* 轴和 *y* 轴上各移动 -1 个单位。
- en: '![Figure 7.17 – Vector subtraction'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.17 – 向量减法'
- en: '](img/Figure_7.17_B17146.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B17146.jpg)'
- en: Figure 7.17 – Vector subtraction
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 向量减法
- en: 'Let''s add its current position vector to its velocity vector to calculate
    where it will end up after 1 minute again:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次将它的当前位置向量与其速度向量相加，以计算 1 分钟后它将到达的位置：
- en: '`(6, 2) - (1, 1) = (6, 2) + (-1, -1) = (5, 1)`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`(6, 2) - (1, 1) = (6, 2) + (-1, -1) = (5, 1)`'
- en: The new position of this object after 1 minute is (5, 1).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个物体在 1 分钟后的新位置是 (5, 1)。
- en: 'In Unity, we can add vectors and subtract vectors in C# code, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，我们可以使用 C# 代码进行向量加法和向量减法，如下所示：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code snippet, we created two 3D vectors, `(1, 1, 1)` and `(1,
    2, 3`). Then, we added and subtracted them respectively and printed the results
    to the **Console** window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了两个 3D 向量 `(1, 1, 1)` 和 `(1, 2, 3)`。然后，我们分别对它们进行加法和减法操作，并将结果打印到
    **控制台** 窗口。
- en: '![Figure 7.18 – Adding vectors and subtracting vectors'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.18 – 向量加法和向量减法'
- en: '](img/Figure_7.18_B17146.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.18_B17146.jpg)'
- en: Figure 7.18 – Adding vectors and subtracting vectors
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 向量加法和向量减法
- en: 'In order to move objects in Unity, knowledge of vectors is needed. But sometimes
    we don''t have to directly calculate the result of vector addition or subtraction
    in the code. This is because Unity provides us with the `Transform.Translate`
    function to move objects. Of course, we still need to pass a vector parameter
    to provide velocity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Unity 中移动对象，需要了解向量的知识。但有时我们不必在代码中直接计算向量加法或减法的结果。这是因为 Unity 为我们提供了 `Transform.Translate`
    函数来移动对象。当然，我们仍然需要传递一个向量参数来提供速度：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet demonstrates how to move an object by calling the
    `Transform.Translate` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段演示了如何通过调用 `Transform.Translate` 函数来移动对象。
- en: Dot product
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点积
- en: In addition to vector addition and vector subtraction, 3D vector operations
    commonly used in game development also include **dot product** operations and
    **cross product** operations. We will introduce them separately in this section
    and the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向量加法和向量减法之外，在游戏开发中常用的3D向量操作还包括**点积**操作和**向量积**操作。我们将在本节和下一节中分别介绍它们。
- en: First, we will explore the dot product in Unity. The dot product or scalar product
    takes two vectors and returns a single scalar value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索Unity中的点积。点积或标量积接受两个向量并返回一个单一的标量值。
- en: 'Suppose there are two 3D vectors, named *vector1* and *vector2*;the calculation
    process of the dot product is very simple, as shown:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个3D向量，分别命名为*vector1*和*vector2*；点积的计算过程非常简单，如下所示：
- en: '`scalar value = (x1 * x2) + (y1 * y1) + (z1 * z2)`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`标量值 = (x1 * x2) + (y1 * y1) + (z1 * z2)`'
- en: In game development, vector dot product operations are often used to find out
    whether these two vectors are perpendicular to each other. If the result of their
    dot product operation is 0, the two vectors are perpendicular to each other. If
    the result is positive, the angle between the two vectors is less than 90 degrees.
    If the result is negative, the angle between the two vectors is greater than 90
    degrees.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，向量点积操作经常被用来判断这两个向量是否垂直。如果它们的点积操作结果是0，则两个向量是垂直的。如果结果是正数，则两个向量之间的角度小于90度。如果结果是负数，则两个向量之间的角度大于90度。
- en: Next, we can create two 3D vectors in the Unity Editor to demonstrate how to
    use the vector dot product operation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在Unity编辑器中创建两个3D向量来演示如何使用向量点积操作。
- en: '![Figure 7.19 – Two 3D vectors in the Editor'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19 – 编辑器中的两个3D向量'
- en: '](img/Figure_7.19_B17146.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B17146.jpg)'
- en: Figure 7.19 – Two 3D vectors in the Editor
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – 编辑器中的两个3D向量
- en: 'As shown in *Figure 7.19*, the green line represents the first vector, which
    is (0, 5, 0), and the yellow line represents the other vector, which is (5, 0,
    5). The result of the dot product operation of these two vectors is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.19*所示，绿色线代表第一个向量，它是(0, 5, 0)，黄色线代表另一个向量，它是(5, 0, 5)。这两个向量点积操作的结果如下：
- en: '`0 = (0 * 5) + (5 * 0) + (0 * 5)`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`0 = (0 * 5) + (5 * 0) + (0 * 5)`'
- en: At the same time, we can see in *Figure 7.19* that these two vectors are perpendicular.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们可以在*图7.19*中看到这两个向量是垂直的。
- en: 'If the first vector is (0, 5, 5), the result of the dot product operation of
    these two vectors will be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个向量是(0, 5, 5)，这两个向量点积操作的结果如下：
- en: '`25 = (0 * 5) + (5 * 0) + (5 * 5)`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`25 = (0 * 5) + (5 * 0) + (5 * 5)`'
- en: 'As shown in *Figure 7.20*, the two vectors are not perpendicular this time,
    and the included angle is less than 90 degrees:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.20*所示，这次两个向量不是垂直的，夹角小于90度：
- en: '![Figure 7.20 – Two 3D vectors in the Editor'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20 – 编辑器中的两个3D向量'
- en: '](img/Figure_7.20_B17146.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.20_B17146.jpg)'
- en: Figure 7.20 – Two 3D vectors in the Editor
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 – 编辑器中的两个3D向量
- en: 'If the first vector is (0, 1, -1), the result of the dot product operation
    of these two vectors will be as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个向量是(0, 1, -1)，这两个向量点积操作的结果如下：
- en: '`-5 = (0 * 5) + (1 * 0) + (-1 * 5)`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`-5 = (0 * 5) + (1 * 0) + (-1 * 5)`'
- en: 'As shown in *Figure 7.21*, the two vectors are not perpendicular this time,
    and the included angle is greater than 90 degrees:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.21*所示，这次两个向量不是垂直的，夹角大于90度：
- en: '![Figure 7.21 – Two 3D vectors in the Editor'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21 – 编辑器中的两个3D向量'
- en: '](img/Figure_7.21_B17146.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.21_B17146.jpg)'
- en: Figure 7.21 – Two 3D vectors in the Editor
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 – 编辑器中的两个3D向量
- en: 'Unity provides us with a function to calculate the result of the dot product
    of two 3D vectors, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为我们提供了一个函数来计算两个3D向量点积的结果，如下所示：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is a static function and we can call it directly in our C# code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态函数，我们可以在我们的C#代码中直接调用它：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Cross product
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量积
- en: On the other hand, the cross product takes two vectors as well but returns another
    vector instead of a single scalar value. This vector is perpendicular to both
    of the original two vectors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，向量积接受两个向量，但返回的是另一个向量，而不是单一的标量值。这个向量垂直于原始的两个向量。
- en: '![Figure 7.22 – Cross product (CC BY-SA 4.0)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22 – 向量积（CC BY-SA 4.0）'
- en: '](img/Figure_7.22_B17146.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.22_B17146.jpg)'
- en: Figure 7.22 – Cross product (CC BY-SA 4.0)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 – 向量积（CC BY-SA 4.0）
- en: Compared with the dot product, the calculation process of the cross product
    is more complicated. The preceding figure demonstrates this process.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与点积相比，叉积的计算过程更为复杂。前图展示了这一过程。
- en: 'Unity also offers another helpful function to calculate the result of the cross
    product of two 3D vectors, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还提供了一个有用的函数来计算两个3D向量的叉积结果，如下所示：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is a static function and we can call it directly in our C# code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态函数，我们可以在我们的C#代码中直接调用它：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code snippet, we calculate the result of the cross product of vector1
    and vector2 and at the same time, we also draw these three vectors in the Unity
    Editor, as shown in the following figure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们计算了向量1和向量2的叉积结果，同时，我们还在Unity编辑器中绘制了这三个向量，如图所示：
- en: '![Figure 7.23 – Cross product'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.23_B17146.jpg](img/Figure_7.23_B17146.jpg)'
- en: '](img/Figure_7.23_B17146.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.23_B17146.jpg](img/Figure_7.23_B17146.jpg)'
- en: Figure 7.23 – Cross product
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.23_B17146.jpg](img/Figure_7.23_B17146.jpg)'
- en: In this section, we introduced vectors and explored how to use vectors correctly
    in Unity scripts. Next, let's continue to explore another important concept in
    computer graphics, namely matrices.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了向量并探讨了如何在Unity脚本中正确使用向量。接下来，让我们继续探讨计算机图形学中的另一个重要概念，即矩阵。
- en: Working with the transformation matrix
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与变换矩阵一起工作
- en: In game development, the **transformation matrix** is also a common term. Specifically,
    we use the transformation matrix to encode transformations, including translation,
    rotation, and scaling transforms.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，**变换矩阵**也是一个常用术语。具体来说，我们使用变换矩阵来编码变换，包括平移、旋转和缩放变换。
- en: Unity provides us with the Matrix4x4 struct in C# to represent a standard 4x4
    transformation matrix.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为我们提供了C#中的`Matrix4x4`结构体来表示标准的4x4变换矩阵。
- en: '![Figure 7.24 – A 4x4 matrix'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24 – 一个4x4矩阵'
- en: '](img/Figure_7.24_B17146.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.24_B17146.jpg](img/Figure_7.24_B17146.jpg)'
- en: Figure 7.24 – A 4x4 matrix
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24 – 一个4x4矩阵'
- en: As shown in *Figure 7.24*, a transformation matrix is a grid of numbers. Although
    it is a common term, we rarely use this matrix directly in scripts. This is because
    the calculation of the matrix is relatively cumbersome, and Unity, as an easy-to-use
    game engine, has encapsulated the complex calculations in the `Transform` class
    for us, and we only need to call some functions. Therefore, in this section, we
    only give a brief introduction to the transformation matrix.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.24*所示，变换矩阵是一个数字网格。尽管这是一个常用术语，但我们很少直接在脚本中使用这个矩阵。这是因为矩阵的计算相对繁琐，而Unity作为一个易于使用的游戏引擎，已经为我们封装了复杂的计算在`Transform`类中，我们只需要调用一些函数。因此，在本节中，我们只简要介绍变换矩阵。
- en: Before we start, you should know that transformations include translation, rotation,
    scaling, and these operations can be represented as matrices. We will discuss
    them one by one in the following subsections.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你应该知道变换包括平移、旋转、缩放，这些操作可以用矩阵表示。我们将在以下小节中逐一讨论它们。
- en: Translation matrix
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平移矩阵
- en: 'We can move an object by using a translation matrix. The following diagram
    shows a translation matrix and how to move the original vector by multiplying
    the translation matrix:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用平移矩阵来移动一个对象。以下图示展示了平移矩阵以及如何通过乘以平移矩阵来移动原始向量：
- en: '![Figure 7.25 – Translation matrix (CC BY 4.0)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.25_B17146.jpg](img/Figure_7.25_B17146.jpg)'
- en: '](img/Figure_7.25_B17146.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.25_B17146.jpg](img/Figure_7.25_B17146.jpg)'
- en: Figure 7.25 – Translation matrix (CC BY 4.0)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 – 平移矩阵（CC BY 4.0）
- en: 'Let''s create a C# script and demonstrate how to move an object by using a
    matrix directly in Unity:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个C#脚本，并在Unity中直接使用矩阵来演示如何移动一个对象：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see in this code snippet, we used four `Vector4` instances to create
    an instance of the `Matrix4x4` struct. It should be noted here that each `Vector4`
    we used to create the matrix represents a column of the matrix, not a row. Therefore,
    the code creates a matrix, as shown in the following figure:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们使用了四个`Vector4`实例来创建一个`Matrix4x4`结构体的实例。需要注意的是，我们用来创建矩阵的每个`Vector4`代表矩阵的一列，而不是一行。因此，代码创建了一个如图所示的矩阵：
- en: '![Figure 7.26 – Creating a matrix'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.26_B17146.jpg](img/Figure_7.26_B17146.jpg)'
- en: '](img/Figure_7.26_B17146.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.26_B17146.jpg](img/Figure_7.26_B17146.jpg)'
- en: Figure 7.26 – Creating a matrix
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26 – 创建矩阵
- en: Then, we calculated the new position of the object by calling the `MultiplyPoint`
    function of `Matrix4x4`, where the parameter is the original position of the object.
    Finally, we set the position of the object to this new vector.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`Matrix4x4`的`MultiplyPoint`函数来计算对象的新位置，其中参数是对象的原位置。最后，我们将对象的位置设置为这个新向量。
- en: '![Figure 7.27 – Changing the position of the object'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.27_B17146.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.27 – Changing the position of the object
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If we create an object at the origin and run this script, the result will be
    that the object is moved to the point (3, 2, 1), as shown in *Figure 7.27*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Rotation matrix
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, a matrix can also be used to rotate an object, that is, a rotation
    matrix. This time, we also need to create an instance of `Matrix4x4` in the C#
    script, but instead of calling its constructor, we call this function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Rotate` function is a static function of `Matrix4x4`, and it creates and
    returns a rotation matrix. This function requires a quaternion-type parameter.
    We will introduce quaternions in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some code to rotate the object by using `Matrix4x4`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code will move the point from its original position to a place rotated
    90 degrees around the *y* axis.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Rotation matrix'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.28_B17146.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.28 – Rotation matrix
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Let's set the original position of this object to (1, 0, 0) and then run the
    code. The new position of this object should be (0, 0, -1), as shown in the preceding
    figure.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – The real result'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.29_B17146.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.29 – The real result
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: After running the code, we can see that the real result is consistent with what
    we expected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Scaling matrix
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we scale a vector, we will keep its direction unchanged and change the
    length by the amount we want to scale. We can also use a scaling matrix to scale
    a point away from the origin. You can imagine that a model is composed of many
    vertices. When we scale a model, we actually extend or shrink the positions of
    the vertices that make it up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity also provides us with the following function to directly create a scaling
    matrix in a C# script:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Matrix4x4`, and it creates and returns a scaling matrix:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In order to demonstrate how to apply a scaling matrix to a point, we created
    the preceding code snippet. As you can see in the code, we created a new `Vector3`
    to present the scaling factors. Then, we created a scaling matrix by calling the
    `Matrix4x4.Scale` function and finally, we applied this matrix to a point.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new GameObject in the Scene and locate this GameObject at the
    position (1, 1, 0).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – GameObject at (1, 1, 0)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.30_B17146.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.30 – GameObject at (1, 1, 0)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Then, attach this script to it and run the script.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – Apply the scaling matrix to this object'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.31_B17146.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.31 – Apply the scaling matrix to this object
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.31*, the new position of this object is (3, 2, 0). This
    is because this scaling matrix increases the point three times along the *x* axis
    from its original position and two times along the *y* axis.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – Scaling a point'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.32_B17146.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.32 – Scaling a point
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this section, in Unity development, matrix
    operations are relatively low-level operations. Unity has provided us with many
    functions to cover up the complexity of matrices. Developers don't often use matrices
    directly, but as an important concept, we still need to understand some concepts
    around them. However, when it comes to object rotation, Unity often uses another
    type to save rotation data. If you are interested in this, let's continue to explore
    **quaternions**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在这节开头提到的，在Unity开发中，矩阵操作是相对低级的操作。Unity为我们提供了许多函数来掩盖矩阵的复杂性。开发者通常不直接使用矩阵，但作为一个重要概念，我们仍然需要理解一些与之相关的概念。然而，当涉及到对象旋转时，Unity通常使用另一种类型来保存旋转数据。如果你对此感兴趣，让我们继续探索**四元数**。
- en: Working with quaternions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与四元数一起工作
- en: In Unity, the rotation of a transform is stored internally as a **quaternion**,
    which has four componenets, namely *x*, *y*, *z*, and *w*. However, these four
    components do not represent angles or axes, and we developers usually do not need
    to access them directly. You may be confused because if you look at the Inspector
    window of a transform, you will find the rotation is displayed as a Vector3.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，变换的旋转以**四元数**的形式内部存储，它有四个分量，即*x*、*y*、*z*和*w*。然而，这四个分量并不代表角度或轴，我们开发者通常不需要直接访问它们。你可能感到困惑，因为如果你查看变换的检查器窗口，你会发现旋转以Vector3的形式显示。
- en: '![Figure 7.33 – Rotation property in the Inspector window'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.33 – 检查器窗口中的旋转属性'
- en: '](img/Figure_7.33_B17146.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.33_B17146.jpg)'
- en: Figure 7.33 – Rotation property in the Inspector window
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.33 – 检查器窗口中的旋转属性
- en: This is because although Unity uses quaternions to store rotations internally,
    in addition to quaternions, rotations can also be represented by three angle values
    of *x*, *y*, and *z*, namely **Euler angles**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为尽管Unity使用四元数来内部存储旋转，除了四元数之外，旋转还可以用*x*、*y*和*z*三个角度值来表示，即**欧拉角**。
- en: Therefore, for the convenience of developers to edit, Unity displays the value
    of the equivalent Euler angle in the Inspector.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了方便开发者编辑，Unity在检查器中显示等效欧拉角的值。
- en: So, why doesn't Unity use Euler angles to store rotations directly? It is composed
    of three axes angles and is in a format that is easy for humans to read. This
    is because the Euler angle is affected by the **gimbal lock**, which means that
    the "degree of freedom" is lost.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么Unity不直接使用欧拉角来存储旋转呢？它由三个轴角度组成，并且以人类易于阅读的格式存在。这是因为欧拉角受到**陀螺仪锁定**的影响，这意味着“自由度”丢失了。
- en: On the other hand, using quaternion rotation will not cause the gimbal lock
    issue. Therefore, Unity uses quaternions to store rotations internally. But what
    you have to remember is that the four components of a quaternion do not represent
    angles, so we will not modify the value of a component individually, and it is
    very complicated to modify a quaternion directly. Fortunately, Unity provides
    us with many built-in C# functions in the `Quaternion` struct to manage quaternion
    rotations easily. It is our best choice to use the `Quaternion` structure and
    its functions to manage the rotation values in Unity.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用四元数旋转不会引起陀螺仪锁定问题。因此，Unity使用四元数来内部存储旋转。但你需要记住的是，四元数的四个分量并不代表角度，所以我们不会单独修改一个分量的值，直接修改四元数是非常复杂的。幸运的是，Unity在`Quaternion`结构中为我们提供了许多内置的C#函数，以便轻松管理四元数旋转。在Unity中使用`Quaternion`结构和其函数来管理旋转值是我们的最佳选择。
- en: We can divide these functions into three groups according to their purpose,
    namely creating rotations, manipulating rotations, and working with Euler angles.
    Let's explore them next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据其目的将这些函数分为三组，即创建旋转、操作旋转和与欧拉角一起工作。让我们接下来探索它们。
- en: Creating rotations
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建旋转
- en: 'The first function we will introduce is `LookRotation` and the function signature
    of this function is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一个函数是`LookRotation`，该函数的函数签名如下：
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a static function; you can pass in parameters to specify the forward
    and upward direction for it, and it will return the correct rotation value according
    to the passed-in parameters.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态函数；你可以传入参数来指定其前进和向上方向，然后它会根据传入的参数返回正确的旋转值。
- en: 'In the following example, we set up a Scene in which there are two objects,
    named `target` and `player`, and created a new C# script called `LookAtScript.cs`.
    We then attached this script to the player object, as shown in *Figure 7.34*.
    The blue cube represents the player and the red sphere represents the target object:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们设置了一个场景，其中有两个对象，分别命名为 `target` 和 `player`，并创建了一个名为 `LookAtScript.cs`
    的新 C# 脚本。然后，我们将此脚本附加到玩家对象上，如图 *图 7.34* 所示。蓝色立方体代表玩家，红色球体代表目标对象：
- en: '![Figure 7.34 – Objects in the Scene'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.34 – 场景中的对象'
- en: '](img/Figure_7.34_B17146.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.34 – B17146.jpg](img/Figure_7.34_B17146.jpg)'
- en: Figure 7.34 – Objects in the Scene
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.34 – 场景中的对象
- en: 'In the following script, we demonstrate how to implement the function that
    the player always faces the target object no matter where the target moves:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的脚本中，我们演示了如何实现一个函数，使玩家无论目标移动到何处，都能始终面向目标对象：
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we calculated the direction from the player to the target. Next, we called
    the `Quaternion.LookRotation` function to calculate the rotation value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算了从玩家到目标的方向。然后，我们调用 `Quaternion.LookRotation` 函数来计算旋转值。
- en: '![Figure 7.35 – The player facing the target'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.35 – 玩家面向目标'
- en: '](img/Figure_7.35_B17146.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.35 – B17146.jpg](img/Figure_7.35_B17146.jpg)'
- en: Figure 7.35 – The player facing the target
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.35 – 面向目标的玩家
- en: Finally, we moved the target object and the player also moved to face the target,
    as shown in *Figure 7.35*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将目标对象和玩家移动，使它们面向目标，如图 *图 7.35* 所示。
- en: Manipulating rotations
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作旋转
- en: 'There are some functions that are used to manipulate rotations and `Quaternion.Slerp`
    is one of them. The following is the function signature of it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些函数用于操作旋转，`Quaternion.Slerp` 就是其中之一。以下是其函数签名：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a static function. The result of calling `Quaternion.Slerp` is that
    the object will start to rotate, slower, then faster in the middle.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态函数。调用 `Quaternion.Slerp` 的结果是对象将开始缓慢旋转，然后在中间加快速度。
- en: In the following example, we still use the Scene we set up earlier, this time
    creating a new C# script called `OrbitScript.cs`. Then, we will attach this script
    to the player object to implement a gravity orbit effect.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们仍然使用之前设置的场景，这次创建一个名为 `OrbitScript.cs` 的新 C# 脚本。然后，我们将此脚本附加到玩家对象上以实现重力轨道效果。
- en: '![Figure 7.36 – Attaching the script to the GameObject'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.36 – 将脚本附加到 GameObject'
- en: '](img/Figure_7.36_B17146.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.36 – B17146.jpg](img/Figure_7.36_B17146.jpg)'
- en: Figure 7.36 – Attaching the script to the GameObject
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.36 – 将脚本附加到 GameObject
- en: 'The code of `OrbitScript.cs` is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrbitScript.cs` 的代码如下：'
- en: '[PRE20]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this script, we reused some code from `LookAtScript.cs`. We also first calculated
    the angle of the player toward the target. But unlike the previous script, we
    did not directly modify the player's rotation, but saved the target rotation and
    the player's current rotation with two temporary variables, namely `targetRotation`
    and `currentRotation`. Then, the `Quaternion.Slerp` function was called to make
    the player gradually turn to the target, which is also the key to achieving the
    effect of gravity orbit. Finally, we called the `transform.Translate` function
    to keep the player moving forward.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们重用了 `LookAtScript.cs` 中的某些代码。我们首先计算了玩家朝向目标的角度。但与之前的脚本不同，我们没有直接修改玩家的旋转，而是使用两个临时变量
    `targetRotation` 和 `currentRotation` 保存了目标旋转和玩家当前旋转。然后，调用 `Quaternion.Slerp` 函数使玩家逐渐转向目标，这也是实现重力轨道效果的关键。最后，我们调用
    `transform.Translate` 函数以保持玩家向前移动。
- en: '![Figure 7.37 – Running the game'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.37 – 运行游戏'
- en: '](img/Figure_7.37_B17146.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.37 – B17146.jpg](img/Figure_7.37_B17146.jpg)'
- en: Figure 7.37 – Running the game
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.37 – 运行游戏
- en: If we run the game, we will find that the player will move around the target
    and turn to face the target, as shown in *Figure 7.37*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行游戏，我们会发现玩家会在目标周围移动并转向面向目标，如图 *图 7.37* 所示。
- en: Working with Euler angles
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用欧拉角
- en: If in some cases you prefer to use Euler angles instead of quaternions, Unity
    allows you to convert Euler angles to a quaternion, but you should not retrieve
    Euler angles from a quaternion and apply it to the quaternion after modifying
    it, because this may cause problems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某些情况下你更愿意使用欧拉角而不是四元数，Unity 允许你将欧拉角转换为四元数，但你不应该从四元数中检索欧拉角，并在修改后将其应用到四元数上，因为这可能会引起问题。
- en: '`Quaternion.Euler` is one of these functions that we can use to convert Euler
    angles into quaternions. The following is its function signature:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Quaternion.Euler` 是这些我们可以用来将欧拉角转换为四元数的函数之一。以下是其函数签名：'
- en: '[PRE21]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function requires a `Vector3`-type parameter, which provides the angle
    around the *x* axis, the angle around the *y* axis, and the angle around the *z*
    axis. Based on this data, this function returns the corresponding quaternion rotation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要一个 `Vector3` 类型的参数，该参数提供了围绕 *x* 轴、*y* 轴和 *z* 轴的角度。基于这些数据，此函数返回相应的四元数旋转。
- en: 'The following code snippet demonstrates how to use Euler angles in the script
    correctly:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何在脚本中正确使用欧拉角：
- en: '[PRE22]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the code, we created Euler angles that rotate around the *x* axis, and then
    called the `Quaternion.Euler` function to convert Euler angles into quaternions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们创建了围绕 *x* 轴旋转的欧拉角，然后调用了 `Quaternion.Euler` 函数将欧拉角转换为四元数。
- en: '![Figure 7.38 – Converting Euler angles into quaternions'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.38 – 将欧拉角转换为四元数'
- en: '](img/Figure_7.38_B17146.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.38 – 将欧拉角转换为四元数](img/Figure_7.38_B17146.jpg)'
- en: Figure 7.38 – Converting Euler angles into quaternions
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.38 – 将欧拉角转换为四元数
- en: Attach this script to a cube and run the game. You will find the cube rotates
    around the *x* axis.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到一个立方体上并运行游戏。你会发现立方体围绕 *x* 轴旋转。
- en: In this section, we introduced you to quaternions and explored how to use quaternions
    correctly in Unity scripts. It should be noted that in Unity, rotation can not
    only be represented by quaternions, but also by Euler angles. When Euler angles
    are used to represent rotation, its format is easy for humans to read, but due
    to the influence of the gimbal lock, Unity still uses quaternions to save rotations
    internally.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您介绍了四元数，并探讨了如何在 Unity 脚本中正确使用四元数。需要注意的是，在 Unity 中，旋转不仅可以由四元数表示，也可以由欧拉角表示。当使用欧拉角来表示旋转时，其格式对人类来说易于阅读，但由于陀螺仪锁定的影响，Unity
    仍然使用四元数来内部保存旋转。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter first introduced the concept of the coordinate system in computer
    graphics, and then discussed the coordinate system used by Unity. Then, we discussed
    the concept of vectors and how to perform vector operations such as vector addition,
    vector subtraction, dot product, and cross product in Unity.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了计算机图形学中的坐标系概念，然后讨论了 Unity 使用的坐标系。接着，我们讨论了向量的概念以及如何在 Unity 中执行向量运算，如向量加法、向量减法、点积和叉积。
- en: We also introduced the concept of a matrix and demonstrated how to use a matrix
    to translate, rotate, and scale in Unity.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了矩阵的概念，并演示了如何在 Unity 中使用矩阵进行平移、旋转和缩放。
- en: Finally, we explored how to create rotations and manipulate rotations in quaternions,
    and demonstrated how to use Euler angles in the script correctly.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何创建旋转以及在四元数中操作旋转，并演示了如何在脚本中正确使用欧拉角。
- en: By reading this chapter, you should now have a bit more mathematical knowledge
    about computer graphics. In the next chapter, we will introduce the Scriptable
    Render Pipeline in Unity.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你现在应该对计算机图形学有了更多的数学知识。在下一章中，我们将介绍 Unity 中的可脚本渲染管线。
