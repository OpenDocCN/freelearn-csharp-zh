<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor015"/>Taking Control with Source Control</h1>
<p>Source control is a developer’s best friend and provides them with a way to experiment with code without losing important changes. Source control is the ability to track and maintain changes made to code throughout a development process. While this could include code, it can also be used for documentation, assets (such as images), and other resources. Being able to test certain conditions and the ability to refactor code without worrying about the code base is what most developers consider a superpower.</p>
<p>Source control is extremely important when working in a team environment. If a developer checks in code and later realizes they made a mistake, source control gives developers a way to revert changes or update a branch and re-commit. Companies not using some type of source control almost always raises a red flag.</p>
<p>In this chapter, we’ll look at common practices developers use in the industry when using source control. We’ll also cover various ways to implement branching workflows for your code as well as examine the different types of branches in each workflow. To finish off the chapter, we’ll review common etiquette among developers when using source control.</p>
<p>In this chapter, we’re going to cover the following topics:</p>
<ul>
<li>Branching Strategies</li>
<li>Creating short-lived branches</li>
<li>Always “Get Latest” Before Committing </li>
<li>Understanding Common Practices </li>
</ul>
<p>By the end of this chapter, you’ll have learned the best approach to creating a repository of your code in an organized fashion, along with common guidelines in the developer community.</p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Technical requirements</h1>
<p>While this section touches on a number of guidelines regarding source control, the only requirement for this chapter is a computer with any OS. Git is optional.</p>
<p>If you don’t have Git installed, you can download and install it at the following URL:</p>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>We have used mermaid-js to visually show the branching strategies. As of February 2022, GitHub pages now support Mermaid-js. Some of the sections will include mermaid diagrams to demonstrate the different branching hierarchies.</p>
<p>For more information on Mermaid-js, navigate to the following URL:</p>
<p><a href="https://mermaid-js.github.io">https://mermaid-js.github.io</a></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Branching Strategies</h1>
<p>In this section, we’ll explore various branching strategies, explaining how each one works, and highlighting<a id="_idIndexMarker000"/> the differences between them.</p>
<p>While every company has its unique workflow, we’ll focus on some commonly used strategies in the industry.</p>
<p>With GitFlow being the initial workflow, everyone is familiar with it in the industry and its successors have improved by making minor changes to the workflow.</p>
<p>In the next sections, we’ll discuss each workflow, but first, we have to understand the fundamentals of GitFlow.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>GitFlow</h2>
<p>One of the most <a id="_idIndexMarker001"/>common and most mature workflows in the industry is <a id="_idIndexMarker002"/>GitFlow. It was created by <em class="italic">Vincent Driessen</em> in 2010.</p>
<p>A minimal Git repository should have the following branches:</p>
<ul>
<li>main/master/trunk (referred to as main from this point on)</li>
<li>develop</li>
</ul>
<p>The <code>main</code> branch is what you start with when creating a new repository. The purpose of this branch is to <em class="italic">always</em> have stable and production-ready code for release at any time.</p>
<p>The <code>develop</code> branch is for writing new code and preventing untested code from being merged into <code>main</code>.</p>
<p>If you’re a standalone developer working on a side project, this may be a suitable workflow. If everything works in <code>develop</code>, you merge your changes into <code>main</code> and deploy your first<a id="_idIndexMarker003"/> version.</p>
<p>The good news is you can evolve your branching hierarchy even further. You can easily create additional branches, such as feature, release, or hotfix branches, for a better workflow, which we’ll cover later.</p>
<p>Keep in mind that each branching workflow discussed as follows allows any team, whether it’s 1 developer or 50 developers, to have a solid understanding of GitFlow.</p>
<p>In any source control system, there are usually three types of branches used to assist with managing a software workflow: feature, release, and hotfix branches.</p>
<h3>Feature Branches</h3>
<p>Feature branching isolates a new feature into a single<a id="_idIndexMarker004"/> branch so a developer can write code without <a id="_idIndexMarker005"/>worrying about affecting the core code in the <code>develop</code> branch.</p>
<p>In the following example (see <em class="italic">Figure 1</em><em class="italic">.1</em>), a team created a GitHub repository. It called its primary branch <code>main</code> and the development branch <code>develop</code>.</p>
<div><div><img alt="Figure 1.1: Feature branches in GitFlow" src="img/Figure_1.01_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: Feature branches in GitFlow</p>
<p>Once everyone received their tasks, one developer was assigned to create the <code>feature/settings</code> from the <code>develop</code> branch.</p>
<p>Another developer was <a id="_idIndexMarker007"/>assigned the <code>feature/printing</code> branch also from the <code>develop</code> branch.</p>
<p class="callout-heading">Naming Branches</p>
<p class="callout">Apart from the <a id="_idIndexMarker008"/>standardized main and develop branches, one common way to name branches is to prefix the names. Some examples include the following:</p>
<p class="callout">* <code>feature/</code>, <code>features/</code>, or <code>feature-</code>: The branch name should be as descriptive and helpful as possible. For example, <code>feature/1234-settings</code> relates to the <code>feature/jd-settings</code>).</p>
<p class="callout">* <code>"bug/&lt;userstory/task number&gt;-&lt;problem&gt;/"</code>: This example is helpful for immediately identifying bugs. An example of this technique could be <code>bug/1234-string-overflow</code>. Prefixing<a id="_idIndexMarker009"/> a branch with “bugfix” is also acceptable.</p>
<p>Once they are finished and everything’s approved, each developer merges their changes into the <code>develop</code> branch.</p>
<h3>Release Branches</h3>
<p>Release branches are meant for last-minute polishing, minor bug fixes, and/or preparing for a new release of <a id="_idIndexMarker010"/>your software (how exciting!)</p>
<p>Let’s examine <a id="_idIndexMarker011"/>how a release branch fits into our previous example. The following diagram shows what a release branch in GitFlow looks like:</p>
<div><div><img alt="Figure 1.2: Release branch in GitFlow" src="img/Figure_1.02_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: Release branch in GitFlow</p>
<p>Initially, developers create a feature branch based on what they were assigned. Once they merge their changes to <code>develop</code>, a new release is created from the <code>develop</code> branch. The release branch is merged into <code>main</code> and tagged with the version number. The main branch will now merge into the <code>develop</code> branch so developers have the latest changes in case there were code changes during the release process.</p>
<p>It’s exactly the same as the feature branch, but if you notice, we’re creating the <code>release</code> branch from the <code>develop</code> branch and not from the <code>main</code> branch.</p>
<p>After the <code>release</code> branch is created and confirmed to work as expected, the <code>release</code> branch is merged into the <code>main</code> branch.</p>
<p>Once merged into <code>main</code>, it’s recommended to somehow identify a successful release. By convention, a tag with the<a id="_idIndexMarker012"/> version number is the best approach.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Hotfix branches</h2>
<p>While most developers <a id="_idIndexMarker013"/>don’t make coding mistakes (uh-huh), there are times when immediate changes are required to the <code>main</code> branch.</p>
<p>Going back to our example, it seems there was a problem with a developer’s code. The application bombs when anyone selects the <strong class="bold">Settings</strong> option, making the application unusable. It requires a <a id="_idIndexMarker014"/>hotfix branch.</p>
<p>The following diagram <a id="_idIndexMarker015"/>shows an example of how to implement a hotfix branch:</p>
<div><div><img alt="Figure 1.3: Hotfix branch in GitFlow" src="img/Figure_1.03_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: Hotfix branch in GitFlow</p>
<p>Hotfix branches are created from the <code>main</code> branch and, once the code is verified, need to be merged back into <code>main</code> and also the <code>develop</code> branch.</p>
<p>The long-running branches in GitFlow are main and develop. The short-lived branches include the features, hotfix, and bugfix branches.</p>
<p>Now that we’ve covered <a id="_idIndexMarker016"/>GitFlow and its branch types, we’ll look at the next workflow, called GitHub Flow, and how it’s different from GitFlow.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>GitHub Flow</h2>
<p>Over time, GitFlow<a id="_idIndexMarker017"/> has evolved into <a id="_idIndexMarker018"/>easier workflows. The first of these workflows was GitHub Flow, which was created in 2011.</p>
<p>GitHub Flow was meant to simplify things by removing the <code>develop</code> branch and creating features off the <code>main</code> branch.</p>
<p>The following <a id="_idIndexMarker019"/>diagram shows how feature branches work along with a hotfix branch.</p>
<div><div><img alt="Figure 1.4: Hotfix branch in GitHub flow" src="img/Figure_1.04_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: Hotfix branch in GitHub flow</p>
<p>In <em class="italic">Figure 1</em><em class="italic">.4</em>, two features were created and both features were merged back into <code>main</code>. Immediately, version 1.0.0 was released. After the release of 1.0.0, some text was wrong on the site and the legal team requested for it to be fixed.</p>
<p>One of the developers created a hotfix branch, changed the label, requested a PR, got it approved, merged the<a id="_idIndexMarker020"/> change into <code>main</code>, updated the version, and immediately deployed the code to production.</p>
<p>What’s the difference between a hotfix and a feature branch? A hotfix is a branch created from <em class="italic">main/master</em>, with the code checked in, reviewed, updated, and immediately merged back into main/master. A feature branch is more of an organized or scheduled approach. The feature branch is created from the <em class="italic">develop branch</em>, with the code checked in, reviewed, and merged back into the feature branch. The feature branch is scheduled to be merged into a release branch.</p>
<p>So, where is the release branch? In each workflow, there is a release branch of some kind, which we’ll review as follows. The concept of this branch is to always have a version error-free, tested, and ready to deploy at any time. Some small start-up companies use this<a id="_idIndexMarker021"/> type of workflow when starting out. With GitFlow considered as a baseline in the industry, it’s easy to apply the GitFlow concepts when the team grows and is looking for a more structured workflow.</p>
<p>In GitHub flow, the long-running branch here is, again, main, where the short-lived branches are the features, hotfix, and bugfix branches.</p>
<p>After reviewing GitHub flow, let’s move on to the last commonly used branching strategy, called GitLab Flow.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>GitLab Flow</h2>
<p>The final workflow <a id="_idIndexMarker022"/>that we’ll cover is GitLab Flow. Created in 2014, GitLab Flow takes a different approach to the GitFlow workflow and combines feature branches with issue tracking using feature-driven development.</p>
<p>GitLab Flow takes release branches and turns them into stable environment branches, such as production and QA. Of course, you can create as many “environment branches” as necessary. If we had a QA environment branch, this may be used to test the final product. In <em class="italic">Figure 1</em><em class="italic">.5</em>, we see the standard <code>feature</code> branches created from the <code>main</code> branch along with two other environment branches (pre-production and production).</p>
<div><div><img alt="Figure 1.5: GitLab Flow" src="img/Figure_1.05_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: GitLab Flow</p>
<p>In GitLab Flow, main is considered a testing branch. Whether it’s QA or a manager, it’s a place to test the feature branches.</p>
<p>Similar to GitHub<a id="_idIndexMarker023"/> Flow, everything merges into the <code>main</code> branch. When the feature branch is committed, code reviews are conducted (these are mandatory), and <a id="_idIndexMarker024"/>merged to main, all tests (yes, <em class="italic">all</em>) run. If the tests run for longer than five minutes, configure them to run in parallel.</p>
<p>Once the testing is complete in main, <code>main</code> is pushed to <code>pre-production</code> for further testing and, finally, pushed to production. Since releases in GitLab Flow are based on tags, each tag should create a new release.</p>
<p>If a developer introduced a bug, it would have to be fixed in main first, then the environment branches second. The developer would have to create a bugfix branch, commit with a PR approval, conduct a code review, and merge the code along with running tests related to the bug before they could continue through the workflow.</p>
<p>Once tested in main, it’s tagged and automatically promoted to pre-production a<a id="_idTextAnchor022"/>nd then production. Long-running branches in this workflow include main and the environment branches. Short-lived branches are the features, hotfix, and bugfix branches.</p>
<p>With each strategy we discussed in this section, we’ve seen how each one evolved from the initial GitFlow <a id="_idIndexMarker025"/>and (excuse the pun) branched into a better <a id="_idIndexMarker026"/>workflow.</p>
<p>The next sections refer to common etiquette when using source control.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor023"/>Creating short-lived branches</h1>
<p>Once you <a id="_idIndexMarker027"/>have initialized your repository and created your first branch, you can start writing code for your feature.</p>
<p>While this is exciting, this guideline is meant more for teams as opposed to an individual building a side project. The larger the team, the more critical this becomes to your workflow.</p>
<p>Let’s look at an example using multiple feature branches in <em class="italic">Figure 1</em><em class="italic">.6</em>.</p>
<div><div><img alt="Figure 1.6: Long-lived feature branch (feature/settings)" src="img/Figure_1.06_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6: Long-lived feature branch (feature/settings)</p>
<p>Everyone is assigned their respective feature branches, which are created for them. As you can see, the developers are completing their features and checking them into <code>develop</code>.</p>
<p>However, the developer working on the settings feature (<code>feature/settings</code>) is behind. Their branch is<a id="_idIndexMarker028"/> becoming stale since they haven’t updated their code over the week. It only contains their feature from when they first created their branch.</p>
<p>What do you think will happen if they decide to commit their code to the repository without updating their branch? There will be a lot of unhappy developers. Why?</p>
<p>The <code>feature/settings</code> branch will be committed and overwrite everyone who merged into the <code>develop</code> branch’s changes. The shorter your branch’s life expectancy, the less likely you’ll experience merge conflicts.</p>
<p>It’s best to perform updates on a daily basis, if not twice a day, to keep your branch from becoming stale.</p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor024"/>Understanding Common Practices</h1>
<p>Technically, knowing how to use source control is only half the battle. The other half is working as a team player while using source control. The ability to keep your fellow teammates in mind will take you further in your career as you become a considerate and trusted developer.</p>
<p>The following sections are meant as guidelines to help you succeed in working in a team environment. If you work as an individual developer on an open source project, it doesn’t hurt to implement these practices as well.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Rebase when Private, Merge when Public</h2>
<p>When working on<a id="_idIndexMarker029"/> a feature branch privately, there may be times where multiple commits are necessary. These commits add unnecessary noise to the <code>main</code>/<code>master</code> branch.</p>
<p>Rebasing your <a id="_idIndexMarker030"/>code takes a number of local commits and updates another branch with a single commit. It essentially rewrites the commit history. Of course, this differs from a merge. Merging is the process of taking all of the commits from one branch and merging the entire progress into another branch. Merging maintains the entire history of commits.</p>
<p>Think of rebasing<a id="_idIndexMarker031"/> as cleaning up your house before showing it to a potential buyer. If you make a number of mistakes in your local branch, you want your main/master branch to provide clear and concise comments as to what was applied to the code when committed.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Always “Get Latest” Before Committing</h2>
<p>On the topic of keeping branches fresh, it’s a good habit to “Get Latest” before you commit your code.</p>
<p>“Get Latest” pertains to<a id="_idIndexMarker032"/> you retrieving any updates from a central repository and applying updates to your local repository of code.</p>
<p>Whether you’re using Git, <strong class="bold">Team Foundation Server</strong> (<strong class="bold">TFS</strong>), or another source control system, you need to keep<a id="_idIndexMarker033"/> your team in mind by always retrieving the latest code updates. Each source control tool has its own way of getting the latest version of the code. No matter what tool you use, it’s always a good habit to get the latest version.</p>
<p>Since Git is considered the standard in the industry because of its flexibility and granular approach to source control, most development environments provide an interface (graphical or command line) out of the box for interacting with Git.</p>
<p>With Git, there are a couple of ways to push and pull changes:</p>
<ul>
<li><strong class="bold">Fetch</strong>: Retrieves remote <a id="_idIndexMarker034"/>metadata to your local repository.</li>
<li><strong class="bold">Pull</strong>: Retrieves remote <a id="_idIndexMarker035"/>metadata <em class="italic">and</em> pulls a copy of those changes to the local repository.</li>
<li><strong class="bold">Push</strong>: Pushes commits to<a id="_idIndexMarker036"/> your remote branch.</li>
<li><strong class="bold">Sync</strong>: The process <a id="_idIndexMarker037"/>of performing a <em class="italic">pull</em> first, then a <em class="italic">push</em> second. Remember, get the latest changes and apply those changes to your own code, then push your committed changes to the server’s repository.</li>
</ul>
<p>Right before a commit, it’s best to issue a pull to retrieve everything before committing your code.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>Always Build and Test Before Committing</h2>
<p>While this may seem like a simple concept after mentioning our previous guideline, there are a number of developers who continue to miss this step when committing code. Once you’ve pulled the latest, the next step is to compile the code and run your local unit tests <a id="_idIndexMarker038"/>against it. Don’t assume the code you pulled is error-free.</p>
<p>It’s a common circumstance that on a Friday afternoon, Developer B performs a pull to update their code, commits their code without compiling, and runs for the door.</p>
<p>What they didn’t know is Developer-A committed code before Developer-B. It didn’t compile and Developer-A already left for the weekend. Now Developer-B pulled the code and he was unable to compile it.</p>
<p>On Monday, they find out their code didn’t build at all and the unit tests didn’t pass.</p>
<p>Or worse, they receive a call on Friday night with this news.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Avoid Committing Binaries</h2>
<p>Source control <a id="_idIndexMarker039"/>systems have been around for a while, and most are long in the tooth (SourceForge, anyone?), but all of them have been used as source code repositories.</p>
<p>Recently, there<a id="_idIndexMarker040"/> have been a number of <strong class="bold">Content Management Systems</strong> (<strong class="bold">CMSes</strong>) using source code systems as content repositories where they manage and version the assets of a website, such as images, MP3s, and videos.</p>
<p>However, in the case of developers, our content is our source code. Most developer repositories aren’t even as big as a Word document.</p>
<p>If developers want to keep a “snapshot” of the system by committing everything, this defeats the purpose of source control.</p>
<p>For .NET applications, compiling an application means the <code>\bin</code> and <code>\obj</code> folders will contain assemblies. These assemblies are automatically created when compiled and <em class="italic">do not</em> need to be committed to a repository.</p>
<p>In most source control systems, an ignore file of some kind exists to filter and remove bloat from your repository before checking in your code. For example, in Git, there is a <code>.gitignore</code> file, which should include these <code>\bin</code> and <code>\obj</code> directories along with other file types not necessary for building your solution or project.</p>
<p>As a general guideline, when you clone a repository and immediately build it on a new machine, no errors should appear whether it’s an internal corporate project or an open source framework on <a id="_idIndexMarker041"/>GitHub.</p>
<p>If committing assemblies to Git from either your own project or third-party projects is to keep it in a runnable state, you’re doing it wrong. It’s best not to commit any binaries into Git.</p>
<p>If you need a specific version of a third-party library, consider NuGet package management. When adding a NuGet package to your project, it automatically connects and retrieves the specific version and places it into the <code>\bin</code> folder, making the application compile, build, and successfully run every time.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Use tags for versioning</h2>
<p>Tags are extremely<a id="_idIndexMarker042"/> helpful when using source control. As a matter of fact, they’re what drives GitLab Flow. While tags are awesome for source control, they can be used for evil as well. For example, some companies use tags as comments throughout the entire workflow process, which is not recommended. Tags provide a way to place a flag in the ground to say, “This is version x.x.x.” They’re a marker of a code snapshot of a solid release. This signifies the code at this tag should build, compile, be tested, and run <em class="italic">with no changes made to the code and </em><em class="italic">no errors</em>.</p>
<p>It’s best to use tags strictly for versioning your releases throughout your workflow.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Summary</h1>
<p>In this chapter, you learned about the different types of branching workflows available, including GitFlow, GitHub Flow, and GitLab Flow, and how each one works. Along with the workflows, you learned the industry-standard branch names, such as main/trunk/master, develop, features, release, and hotfix branches, and how they work in each workflow. You also learned the proper way to work with source control, such as always getting the latest code, when to rebase your code versus merging, allowing your branches to have a short lifespan, compiling and testing your code before committing, never checking in assemblies, and the proper use of tagging.</p>
<p>In the next chapter, we’ll take the source code in our repository and create an automated build to create artifacts. We’ll also cover how to automatically deploy it to a server.</p>
</div>
</body></html>