- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building a Local Storage Service Using JavaScript Interoperability (JS Interop)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JavaScript 互操作性（JS Interop）构建本地存储服务
- en: The Blazor WebAssembly framework makes it possible for us to run C# code on
    the browser. However, there are some scenarios that C# simply cannot handle, and
    for those scenarios, we need to use JavaScript functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 框架使我们能够在浏览器上运行 C# 代码。然而，有一些场景 C# 简直无法处理，对于这些场景，我们需要使用 JavaScript
    函数。
- en: In this chapter, we will learn how to use JavaScript with Blazor WebAssembly.
    We will learn how to invoke a JavaScript function from a .NET method with and
    without a return value. Conversely, we will learn how to invoke a .NET method
    from a JavaScript function. We will accomplish both scenarios by using **JavaScript
    interop** (**JS interop**). Finally, we will learn how to store data on the browser
    by using the Web Storage API for JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 JavaScript 与 Blazor WebAssembly。我们将学习如何从 .NET 方法中调用 JavaScript
    函数，无论是否有返回值。相反，我们还将学习如何从 JavaScript 函数中调用 .NET 方法。我们将通过使用 **JavaScript 互操作性**（**JS
    Interop**）来完成这两种场景。最后，我们将学习如何通过使用 JavaScript 的 Web Storage API 在浏览器上存储数据。
- en: The project that we will create in this chapter will be a local storage service
    that will read and write to the application’s local storage. To access the application’s
    local storage, we will use JavaScript. We will also create a test component to
    test the local storage service. The test component will use JavaScript to display
    text in a JavaScript alert box.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将创建的项目将是一个本地存储服务，该服务将读取和写入应用程序的本地存储。为了访问应用程序的本地存储，我们将使用 JavaScript。我们还将创建一个测试组件来测试本地存储服务。测试组件将使用
    JavaScript 在 JavaScript 警告框中显示文本。
- en: It is sad, but true.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很遗憾，但这是真的。
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We may not like JavaScript,
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可能不喜欢 JavaScript，
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: but we still need it!
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但我们仍然需要它！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why use JavaScript?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 JavaScript？
- en: Exploring JS interop
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 JS 互操作性
- en: Using local storage
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地存储
- en: Creating the local storage service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建本地存储服务
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this project, you need to have Visual Studio 2022 installed on your
    PC. For instructions on how to install the free Community Edition of Visual Studio
    2022, refer to *Chapter 1*, *Introduction to Blazor WebAssembly*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此项目，您需要在您的 PC 上安装 Visual Studio 2022。有关如何安装 Visual Studio 2022 的免费社区版的说明，请参阅
    *第 1 章*，*Blazor WebAssembly 简介*。
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Blazor-WebAssembly-by-Example-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Blazor-WebAssembly-by-Example-Second-Edition/tree/main/Chapter05).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Blazor-WebAssembly-by-Example-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Blazor-WebAssembly-by-Example-Second-Edition/tree/main/Chapter05)。
- en: 'The Code in Action video is available here: [https://packt.link/Ch5](https://packt.link/Ch5).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在行动视频在此处可用：[https://packt.link/Ch5](https://packt.link/Ch5)。
- en: Why use JavaScript?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 JavaScript？
- en: With Blazor WebAssembly, we can create robust applications without writing any
    JavaScript. However, there are some scenarios that require the use of JavaScript.
    For example, we may have a favorite JavaScript library that we want to continue
    to use. Also, without JavaScript, we can’t manipulate the DOM or call any of the
    JavaScript APIs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blazor WebAssembly，我们可以创建无需编写任何 JavaScript 的健壮应用程序。然而，有一些场景需要使用 JavaScript。例如，我们可能有一个我们想要继续使用的喜欢的
    JavaScript 库。此外，没有 JavaScript，我们无法操作 DOM 或调用任何 JavaScript API。
- en: 'This is a partial list of things that we do not have access to directly from
    the Blazor WebAssembly framework:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们无法直接从 Blazor WebAssembly 框架访问的部分列表：
- en: '**DOM manipulation**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM 操作**'
- en: The **Media Capture and Streams API**
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体捕获和流 API**'
- en: The **WebGL API** (2D and 3D graphics for the web)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebGL API**（网页的 2D 和 3D 图形）'
- en: The **Web Storage API** (`localStorage` and `sessionStorage`)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web Storage API**（`localStorage` 和 `sessionStorage`）'
- en: The **Geolocation API**
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地理位置 API**'
- en: JavaScript pop-up boxes (an alert box, a confirm box, and a prompt box)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 弹出框（一个警告框、一个确认框和一个提示框）
- en: The online status of the browser
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器的在线状态
- en: The browser’s history
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器的历史记录
- en: '**Chart.js**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chart.js**'
- en: Other third-party JavaScript libraries
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他第三方 JavaScript 库
- en: The preceding list is not at all comprehensive since there are hundreds of JavaScript
    libraries that are currently available. However, the key point to remember is
    that we cannot manipulate the DOM without using JavaScript. Therefore, we will
    probably always need to use some JavaScript in our web apps. Luckily, by using
    JS interop, this is easy to do.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表并不全面，因为目前有数百个可用的 JavaScript 库。然而，需要记住的关键点是，我们不使用 JavaScript 就不能操作 DOM。因此，我们可能始终需要在我们的
    Web 应用程序中使用一些 JavaScript。幸运的是，通过使用 JS interop，这很容易做到。
- en: Exploring JS interop
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 JS interop
- en: To invoke a JavaScript function from .NET, we use the `IJSRuntime` abstraction.
    This abstraction represents an instance of a JavaScript runtime that the framework
    can call into. To use `IJSRuntime`, we must first inject it into our component
    using dependency injection. For more information on dependency injection, refer
    to *Chapter 7*, *Building a Shopping Cart Using Application State*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 .NET 调用 JavaScript 函数，我们使用 `IJSRuntime` 抽象。这个抽象表示框架可以调用的 JavaScript 运行时实例。要使用
    `IJSRuntime`，我们必须首先通过依赖注入将其注入到我们的组件中。有关依赖注入的更多信息，请参阅*第 7 章*，*使用应用程序状态构建购物车*。
- en: 'The `@inject` directive is used to inject a dependency into a component. The
    following code injects `IJSRuntime` into the current component:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`@inject` 指令用于将依赖项注入到组件中。以下代码将 `IJSRuntime` 注入到当前组件中：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `IJSRuntime` abstraction has two methods that we can use to invoke JavaScript
    functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`IJSRuntime` 抽象有两个我们可以用来调用 JavaScript 函数的方法：'
- en: '**InvokeAsync**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InvokeAsync**'
- en: '**InvokeVoidAsync**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InvokeVoidAsync**'
- en: Both methods are asynchronous. The difference between these two methods is that
    one of them returns a value and the other does not. We can downcast an instance
    of `IJSRuntime` to an instance of `IJSInProcessRuntime` to run the method synchronously.
    Finally, we can invoke a .NET method from JavaScript by decorating the method
    with `JsInvokable`. We will look at examples of each of these methods later in
    this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是异步的。这两种方法之间的区别在于，其中一种方法返回一个值，而另一种方法不返回。我们可以将 `IJSRuntime` 的实例向下转换为 `IJSInProcessRuntime`
    的实例，以同步运行该方法。最后，我们可以通过使用 `JsInvokable` 装饰器从 JavaScript 中调用 .NET 方法。我们将在本章后面查看这些方法的示例。
- en: However, before we can invoke a JavaScript method, we need to load the JavaScript
    into our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够调用 JavaScript 方法之前，我们需要将 JavaScript 加载到我们的应用程序中。
- en: Loading JavaScript code
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载 JavaScript 代码
- en: There are a few ways to load JavaScript code into a Blazor WebAssembly app.
    One way is to enter the JavaScript code directly into a `script` element in the
    `body` element of the `wwwroot/index.html` file. However, instead of entering
    the JavaScript code directly into the .`html` file, we recommend using an external
    JavaScript file for your JavaScript functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JavaScript 代码加载到 Blazor WebAssembly 应用程序中有几种方法。一种方法是将 JavaScript 代码直接输入到 `wwwroot/index.html`
    文件中的 `body` 元素的 `script` 元素中。然而，我们建议不要直接将 JavaScript 代码输入到 `.html` 文件中，而是使用外部
    JavaScript 文件来存放你的 JavaScript 函数。
- en: 'We can add an external file by referencing it in the `wwwroot./index.html`
    file. The following code references a file called `btwInterop.js` that is in the
    `wwwroot/scripts` folder:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `wwwroot./index.html` 文件中引用它来添加外部文件。以下代码引用了位于 `wwwroot/scripts` 文件夹中的名为
    `btwInterop.js` 的文件：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A better way to organize scripts is to collocate an external JavaScript file
    with a specific component. To add a JavaScript file that is collocated with a
    specific component, create a JavaScript file in the same folder as the component
    with the same name as the component, but with a JavaScript file extension. For
    example, the `MyComponent` component that is defined in the `MyComponent.razor`
    file would use `MyComponent.razor.js` as its collocated JavaScript file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 组织脚本的一个更好的方法是将与特定组件关联的外部 JavaScript 文件放置在一起。要添加与特定组件关联的 JavaScript 文件，请创建一个与组件同名的
    JavaScript 文件，但文件扩展名是 JavaScript。例如，定义在 `MyComponent.razor` 文件中的 `MyComponent`
    组件将使用 `MyComponent.razor.js` 作为其关联的 JavaScript 文件。
- en: 'For the component to reference the code in the JavaScript file, the file must
    be imported into the component during the `OnAfterRenderAsync` method of the component.
    In the following example, the `import` identifier is used to import a JavaScript
    file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使组件能够引用 JavaScript 文件中的代码，必须在组件的 `OnAfterRenderAsync` 方法中导入该文件。以下示例中使用了 `import`
    标识符来导入一个 JavaScript 文件：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the JavaScript file that is being imported is in the
    `Pages` folder and is named `MyComponent.razor.js`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，正在导入的 JavaScript 文件位于 `Pages` 文件夹中，文件名为 `MyComponent.razor.js`。
- en: '**IMPORTANT NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The collocated JavaScript files will be automatically moved to the `wwwroot`
    folder when the application is published. This approach is called JavaScript isolation
    and it makes downloading the JavaScript file lazy.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序发布时，同站 JavaScript 文件将被自动移动到 `wwwroot` 文件夹。这种方法称为 JavaScript 隔离，它使得下载 JavaScript
    文件变得延迟。
- en: The preceding code uses the `InvokeAsync` method of `IJSRuntime` to invoke the
    JavaScript `import` function from .NET.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用 `IJSRuntime` 的 `InvokeAsync` 方法从 .NET 调用 JavaScript 的 `import` 函数。
- en: Invoking a JavaScript function from a .NET method
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 .NET 方法调用 JavaScript 函数
- en: 'There are two different methods of `IJSRutime` that we can use to invoke JavaScript
    from .NET asynchronously:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种不同的 `IJSRutime` 方法从 .NET 异步调用 JavaScript：
- en: '`InvokeAsync`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvokeAsync`'
- en: '`InvokeVoidAsync`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvokeVoidAsync`'
- en: To invoke a JavaScript function from .NET synchronously, `IJSRutime` must be
    downcast to `IJSInProcessRuntime`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 .NET 同步调用 JavaScript 函数，`IJSRutime` 必须被转换为 `IJSInProcessRuntime`。
- en: InvokeAsync
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`InvokeAsync`'
- en: The `InvokeAsync` method is an asynchronous method that is used to invoke a
    JavaScript function that returns a value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvokeAsync` 方法是一个异步方法，用于调用返回值的 JavaScript 函数。'
- en: 'This is the `InvokeAsync` method of `IJSRuntime`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `IJSRuntime` 的 `InvokeAsync` 方法：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the first argument is the identifier for the JavaScript
    function, and the second argument is an array of JSON-serializable arguments.
    The second argument is optional. The `InvokeAsync` method returns a `ValueTask`
    of the `TValue` type. `TValue` is a JSON-deserialized instance of the JavaScript’s
    return value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个参数是 JavaScript 函数的标识符，第二个参数是一个 JSON-序列化参数的数组。第二个参数是可选的。`InvokeAsync`
    方法返回一个 `ValueTask`，其类型为 `TValue`。`TValue` 是 JavaScript 返回值的 JSON-反序列化实例。
- en: In JavaScript, the `Window` object represents the browser’s window. To determine
    the width and height of the current window, we use the `innerWidth` and `innerHeight`
    properties of the `Window` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`Window` 对象代表浏览器的窗口。为了确定当前窗口的宽度和高度，我们使用 `Window` 对象的 `innerWidth`
    和 `innerHeight` 属性。
- en: 'The following JavaScript code includes a method called `getWindowSize` that
    returns the width and height of the `Window` object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 JavaScript 代码包含一个名为 `getWindowSize` 的方法，该方法返回 `Window` 对象的宽度和高度：
- en: '**wwwroot/bweInterop.js**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**wwwroot/bweInterop.js**'
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**IMPORTANT NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In this book, we will use the `bweInterop` namespace for our JavaScript code
    to both structure our code and minimize the risk of naming conflicts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 `bweInterop` 命名空间来组织我们的 JavaScript 代码，并最小化命名冲突的风险。
- en: 'This is the definition of the `WindowSize` class that is used to store the
    size of the window in .NET:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于在 .NET 中存储窗口大小的 `WindowSize` 类的定义：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following `Index` component invokes the `GetWindowSize` method from the
    `bweInterop.js` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Index` 组件从 `bweInterop.js` 文件中调用 `GetWindowSize` 方法：
- en: '**Pages/Index.razor**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pages/Index.razor**'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, `IJSRuntime` is injected into the component. When the
    **Get Window Size** button is clicked, the `GetWindowSize` method uses the `InvokeAsync`
    method of `IJSRuntime` to invoke the `getWindowSize` JavaScript function. The
    `GetWindowSize` JavaScript function returns the width and height of the window
    to the `windowSize` property. Finally, the component regenerates its render tree
    and applies any changes to the browser’s DOM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`IJSRuntime` 被注入到组件中。当点击 **获取窗口大小** 按钮时，`GetWindowSize` 方法使用 `IJSRuntime`
    的 `InvokeAsync` 方法调用 `getWindowSize` JavaScript 函数。`GetWindowSize` JavaScript
    函数将窗口的宽度和高度返回到 `windowSize` 属性。最后，组件重新生成其渲染树并将任何更改应用到浏览器的 DOM 上。
- en: 'This is a screenshot of the page after the **Get Window Size** button has been
    clicked:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点击 **获取窗口大小** 按钮后页面的截图：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18471_05_01.png)'
- en: 'Figure 5.1: Window size example'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：窗口大小示例
- en: The `InvokeSync` method of `IJSRuntime` is used to call JavaScript functions
    that return a value. If we do not need to return a value, we can use the `InvokeAsync`
    method instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`IJSRuntime` 的 `InvokeSync` 方法用于调用返回值的 JavaScript 函数。如果我们不需要返回值，可以使用 `InvokeAsync`
    方法代替。'
- en: InvokeVoidAsync
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`InvokeVoidAsync`'
- en: The `InvokeVoidAsync` method is an asynchronous method that is used to invoke
    a JavaScript function that does not return a value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvokeVoidAsync` 方法是一个异步方法，用于调用不返回值的 JavaScript 函数。'
- en: 'This is the `InvokeVoidAsync` method of `IJSRuntime`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `IJSRuntime` 的 `InvokeVoidAsync` 方法：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like the `InvokeAsync` method, the first argument is the identifier for
    the JavaScript function that is being called, and the second argument is an array
    of JSON-serializable arguments. The second argument is optional.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `InvokeAsync` 方法一样，第一个参数是被调用的 JavaScript 函数的标识符，第二个参数是一个 JSON-serializable
    参数数组。第二个参数是可选的。
- en: In JavaScript, the `Document` object represents the root node of the HTML document.
    The `title` property of the `Document` object is used to specify the text that
    appears in the browser’s title bar. Assume that we want to update the browser’s
    title as we navigate between the components in our Blazor WebAssembly app. To
    do that, we need to use JavaScript to update the `title` property.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`Document` 对象代表 HTML 文档的根节点。`Document` 对象的 `title` 属性用于指定出现在浏览器标题栏中的文本。假设我们想在
    Blazor WebAssembly 应用程序中的组件之间导航时更新浏览器的标题。为此，我们需要使用 JavaScript 来更新 `title` 属性。
- en: 'The following JavaScript code exports a function called `setDocumentTitle`
    that sets the `title` property of the `Document` object to the value provided
    by the `title` argument:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 JavaScript 代码导出一个名为 `setDocumentTitle` 的函数，该函数将 `Document` 对象的 `title` 属性设置为
    `title` 参数提供的值：
- en: '**Shared/Document.razor.js**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shared/Document.razor.js**'
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code uses an `export` statement to export the `setDocumentTitle`
    function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `export` 语句导出 `setDocumentTitle` 函数。
- en: '**IMPORTANT NOTE**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `export` statement in JavaScript is used to export functions from JavaScript
    to be imported into other programs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的 `export` 语句用于从 JavaScript 导出函数，以便导入到其他程序中。
- en: 'The following `Document` component uses the `setDocumentTitle` JavaScript function
    to update the browser’s title bar:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `Document` 组件使用 `setDocumentTitle` JavaScript 函数来更新浏览器的标题栏：
- en: '**Shared/Document.razor**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shared/Document.razor**'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, `IJSRuntime` is injected into the component. Then, the
    `OnAfterRenderAsync` method uses the `InvokeAsync` method to import the JavaScript
    code and the `InvokeVoidAsync` method to invoke the `setDocumentTitle` JavaScript
    function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`IJSRuntime` 被注入到组件中。然后，`OnAfterRenderAsync` 方法使用 `InvokeAsync` 方法导入
    JavaScript 代码，并使用 `InvokeVoidAsync` 方法调用 `setDocumentTitle` JavaScript 函数。
- en: '**IMPORTANT NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: We are not using the `bweInterop` namespace in the collocated JavaScript code
    to emphasize that it is only referenced by one component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在并置的 JavaScript 代码中未使用 `bweInterop` 命名空间，以强调它只被一个组件引用。
- en: 'The following markup uses the `Document` component to update the browser’s
    title bar to `Home – My App`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的标记使用 `Document` 组件将浏览器的标题栏更新为 `Home – My App`：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the resulting document title:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了生成的文档标题：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18471_05_02.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  描述自动生成](img/B18471_05_02.png)'
- en: 'Figure 5.2: Updated document title'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：更新的文档标题
- en: '**TIP**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can use the built-in `PageTitle` component to set the title of the page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用内置的 `PageTitle` 组件来设置页面的标题。
- en: By default, JS interop calls are asynchronous. To make synchronous JS interop
    calls, we need to use `IJSInProcessRuntime`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JS 互操作调用是异步的。要执行同步 JS 互操作调用，我们需要使用 `IJSInProcessRuntime`。
- en: IJSInProcessRuntime
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IJSInProcessRuntime
- en: So far in this chapter, we have only looked at invoking JavaScript functions
    asynchronously. But we can also invoke JavaScript functions synchronously. We
    do that by downcasting `IJSRuntime` to `IJSInProcessRuntime`. `IJSInProcessRuntime`
    allows our .NET code to invoke JS interop calls synchronously. This can be advantageous
    because these calls have less overhead than their asynchronous counterparts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们只看了异步调用 JavaScript 函数。但我们也可以同步调用 JavaScript 函数。我们通过将 `IJSRuntime`
    降级为 `IJSInProcessRuntime` 来实现这一点。`IJSInProcessRuntime` 允许我们的 .NET 代码同步调用 JS 互操作调用。这可以是有益的，因为这些调用比它们的异步对应物开销更小。
- en: 'These are the synchronous methods of `IJsInProcessRuntime`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `IJsInProcessRuntime` 的同步方法：
- en: '`Invoke`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke`'
- en: '`InvokeVoid`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvokeVoid`'
- en: 'The following code uses `IJSInProcessRuntime` to invoke a JavaScript function
    synchronously:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `IJSInProcessRuntime` 来同步调用一个 JavaScript 函数：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the `IJsRuntime` instance has been downcast to an `IJSInProcessRuntime`
    instance. The `Invoke` method of the `IJSInProcessRuntime` instance is used to
    invoke the `getGuid` JavaScript method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`IJsRuntime` 实例已被降级为 `IJSInProcessRuntime` 实例。`IJSInProcessRuntime` 实例的
    `Invoke` 方法用于调用 `getGuid` JavaScript 方法。
- en: The `IJSRuntime` abstraction provides methods to invoke JavaScript functions
    directly from .NET methods. They can be invoked either asynchronously or synchronously.
    Invoking a .NET method directly from a JavaScript function requires a special
    attribute.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`IJSRuntime` 抽象提供了从 .NET 方法直接调用 JavaScript 函数的方法。它们可以是异步调用或同步调用。直接从 JavaScript
    函数调用 .NET 方法需要一个特殊的属性。'
- en: Invoking a .NET method from a JavaScript function
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 JavaScript 函数调用 .NET 方法
- en: We can invoke a public .NET method from JavaScript by decorating the method
    with the `JSInvokable` attribute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `JSInvokable` 属性装饰方法，从 JavaScript 调用公共 .NET 方法。
- en: 'The following .NET method is decorated with the `JSInvokable` attribute to
    enable it to be invoked from JavaScript:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 .NET 方法被 `JSInvokable` 属性装饰，以便可以从 JavaScript 调用：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the `windowSize` property is updated each time the `GetWindowSize`
    method is invoked from JavaScript. After the `windowSize` property is updated,
    the component’s `StateHasChanged` method is called to notify the component that
    its state has changed, and therefore, the component should be re-rendered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每次从 JavaScript 调用 `GetWindowSize` 方法时，都会更新 `windowSize` 属性。在 `windowSize`
    属性更新后，组件的 `StateHasChanged` 方法被调用，以通知组件其状态已更改，因此组件应该重新渲染。
- en: '**IMPORTANT NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `StateHasChanged` method of a component is only called automatically for
    `EventCallback` methods. In other cases, it must be called manually to notify
    the UI that it may need to be re-rendered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的 `StateHasChanged` 方法仅在 `EventCallback` 方法中自动调用。在其他情况下，必须手动调用以通知 UI 它可能需要重新渲染。
- en: To invoke a .NET method from JavaScript, we must create a `DotNetObjectReference`
    class for JavaScript to use to locate the .NET method. The `DotNetObjectReference`
    class wraps a JS interop argument, indicating that the value should not be serialized
    as JSON but instead, should be passed as a reference.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 JavaScript 调用 .NET 方法，我们必须为 JavaScript 创建一个 `DotNetObjectReference` 类，以便用于定位
    .NET 方法。`DotNetObjectReference` 类包装了一个 JS 互操作参数，表示该值不应序列化为 JSON，而应作为引用传递。
- en: '**IMPORTANT NOTE**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: To avoid memory leaks and allow garbage collection on a component that creates
    a `DotNetObjectReference` class, you must diligently dispose of each instance
    of `DotNetObjectReference`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免内存泄漏并允许对创建 `DotNetObjectReference` 类的组件进行垃圾回收，你必须勤奋地销毁每个 `DotNetObjectReference`
    实例。
- en: 'The following code creates a `DotNetObjectReference` instance that wraps the
    `Resize` component. The reference is then passed to the JavaScript method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个包装 `Resize` 组件的 `DotNetObjectReference` 实例。然后，该引用被传递到 JavaScript 方法中：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can invoke a method in a .NET component from JavaScript using a reference
    to the component created with `DotNetObjectReference`. In the following JavaScript,
    the `registerResizeHandler` function creates the `resizeHandler` function that
    is called at initialization, and every time the window is resized.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `DotNetObjectReference` 创建的组件引用从 JavaScript 调用 .NET 组件中的方法。在下面的 JavaScript
    中，`registerResizeHandler` 函数创建了一个在初始化时调用，并且每次窗口调整大小时都会被调用的 `resizeHandler` 函数。
- en: '**bweInterop.js**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**bweInterop.js**'
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, the `invokeMethodAsync` function is used to invoke
    the `GetWindowSize` .NET method that was decorated with the `JSInvokable` attribute.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用了 `invokeMethodAsync` 函数来调用被 `JSInvokable` 属性装饰的 `GetWindowSize` .NET
    方法。
- en: '**TIP**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can use either the `invokeMethod` function or the `invokeMethodAsync` function
    to invoke .NET instance methods from JavaScript.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `invokeMethod` 函数或 `invokeMethodAsync` 函数从 JavaScript 调用 .NET 实例方法。
- en: 'This is the complete .NET code for the `Resize` component:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Resize` 组件的完整 .NET 代码：
- en: '**Resize.razor**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Resize.razor**'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code for the `Resize` component displays the current width and
    height of the browser. As you resize the browser, the displayed values are automatically
    updated. Also, the `DotNetObjectReference` object is disposed of when the component
    is disposed. To test the `Resize` component, press *Ctrl*+*F5* to start the application
    without debugging. After the application starts, navigate to the `/resize` page
    and resize the window.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resize` 组件的前置代码显示了浏览器当前宽度和高度。当你调整浏览器大小时，显示的值会自动更新。此外，当组件被销毁时，`DotNetObjectReference`
    对象也会被销毁。要测试 `Resize` 组件，请按 *Ctrl*+*F5* 启动应用程序，不进行调试。应用程序启动后，导航到 `/resize` 页面并调整窗口大小。'
- en: The `IJSRuntime` abstraction provides us with a way to invoke JavaScript functions
    from .NET and to invoke .NET methods from JavaScript.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`IJSRuntime` 抽象为我们提供了一种从 .NET 调用 JavaScript 函数以及从 JavaScript 调用 .NET 方法的方式。'
- en: We will be using JavaScript’s Web Storage API to complete the project in this
    chapter. But before we can use it, we need to understand how it works.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JavaScript 的 Web Storage API 来完成本章的项目。但在我们能够使用它之前，我们需要了解它是如何工作的。
- en: Using local storage
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地存储
- en: The Web Storage API for JavaScript provides mechanisms for browsers to store
    key/value pairs. For each web browser, the size of data that can be stored in
    web storage is at least 5 MB per origin. The `localStorage` mechanism is defined
    in the Web Storage API for JavaScript. We need to use JS interop to access the
    application’s local storage because the Web Storage API requires the use of JavaScript.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的 Web Storage API 为浏览器提供了存储键/值对的机制。对于每个网络浏览器，可以在 Web Storage 中存储的数据大小至少为每个来源
    5 MB。`localStorage` 机制在 JavaScript 的 Web Storage API 中定义。我们需要使用 JS interop 来访问应用程序的本地存储，因为
    Web Storage API 需要使用 JavaScript。
- en: The application’s local storage is scoped to a particular URL. If the user reloads
    the page or closes and reopens the browser, the contents of local storage are
    retained. If the user opens multiple tabs, each tab shares the same local storage.
    The data in local storage is retained until it is explicitly cleared, since it
    does not have an expiration date.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的本地存储限于特定的 URL。如果用户重新加载页面或关闭并重新打开浏览器，本地存储的内容将保留。如果用户打开多个标签，每个标签共享相同的本地存储。本地存储中的数据在明确清除之前会保留，因为它没有过期日期。
- en: '**IMPORTANT NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Data in a `localStorage` object that is created when using an *InPrivate* window
    or *Incognito* window is cleared when the last tab is closed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *InPrivate* 窗口或 *Incognito* 窗口创建的 `localStorage` 对象中的数据，在最后一个标签关闭时会被清除。
- en: 'These are the methods of `localStorage`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `localStorage` 的方法：
- en: '**key**: This method returns the name of the indicated key based on its position
    in `localStorage`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**：此方法根据其在 `localStorage` 中的位置返回指定键的名称。'
- en: '**getItem**: This method returns the value for the indicated key from `localStorage`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getItem**：此方法从 `localStorage` 返回指定键的值。'
- en: '**setItem**: This method takes a key and value pair and adds them to `localStorage`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setItem**：此方法接受一个键和值对，并将它们添加到 `localStorage`。'
- en: '**removeItem**: This method removes the indicated key from `localStorage`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**removeItem**：此方法从 `localStorage` 中删除指定的键。'
- en: '**clear**: This method clears `localStorage`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clear**：此方法清除 `localStorage`。'
- en: '**IMPORTANT NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: '`sessionStorage` is also defined in the Web Storage API. Unlike `localStorage`,
    which shares its value between multiple browser tabs, `sesssionStorage` is scoped
    to an individual browser tab. Therefore, if the user reloads the page, the data
    persists, but if the user closes the tab (or the browser), the data is cleared.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionStorage` 也在 Web Storage API 中定义。与在多个浏览器标签间共享其值的 `localStorage` 不同，`sesssionStorage`
    仅限于单个浏览器标签。因此，如果用户重新加载页面，数据会持续存在，但如果用户关闭标签（或浏览器），数据将被清除。'
- en: 'To view the contents of the application’s local storage, open the browser’s
    developer tools by pressing *F12* and selecting the **Application** tab. Select
    **Local Storage** in the **Storage** section of the menu on the left. The following
    screenshot shows the **Application** tab of the **DevTools** dialog in Microsoft
    Edge:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序本地存储的内容，请按 *F12* 打开浏览器开发者工具，并选择 **Application** 选项卡。在左侧菜单的 **Storage**
    部分选择 **Local Storage**。以下截图显示了 Microsoft Edge 中 **DevTools** 对话框的 **Application**
    选项卡：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_03.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18471_05_03.png)'
- en: 'Figure 5.3: Local Storage'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：本地存储
- en: By using the Web Storage API, it is easy to store data in the browser and retrieve
    it. Now, let’s get a quick overview of the project that we are going to build
    in this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Web Storage API，在浏览器中存储数据并检索它非常容易。现在，让我们快速了解一下本章将要构建的项目。
- en: Creating the local storage service
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地存储服务
- en: In this chapter, we will build a local storage service. The service will both
    write to and read from the application’s local storage. We will use JS interop
    to accomplish this. We will use the `InvokeVoidAsync` method to write to local
    storage and the `InvokeAsync` method to read from local storage. Finally, we will
    create a component to test our service.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个本地存储服务。该服务将同时写入和读取应用程序的本地存储。我们将使用JS互操作来实现这一点。我们将使用`InvokeVoidAsync`方法写入本地存储，使用`InvokeAsync`方法从本地存储读取。最后，我们将创建一个组件来测试我们的服务。
- en: The test component will both read and write local storage. It will use JS interop
    to display the contents of local storage in a JavaScript alert box.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试组件将读取和写入本地存储。它将使用JS互操作在JavaScript警告框中显示本地存储的内容。
- en: The following screenshot shows both the test component and the application’s
    local storage. When the **Save to Local Storage** button is clicked, the value
    of the text in the **localStorageData** textbox is saved to local storage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试组件和应用程序的本地存储。当点击**保存到本地存储**按钮时，**localStorageData**文本框中的值将保存到本地存储。
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_04.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18471_05_04.png)'
- en: 'Figure 5.4: Local Storage Service test page'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：本地存储服务测试页面
- en: 'When the **Read from Local Storage** button is clicked, the value of **localStorageData**
    is displayed in a JavaScript alert box. The following screenshot shows a sample
    of an alert that is displaying the value in local storage:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**从本地存储读取**按钮时，**localStorageData**的值将在JavaScript警告框中显示。以下截图显示了显示本地存储值的警告示例：
- en: '![Text  Description automatically generated](img/B18471_05_05.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B18471_05_05.png)'
- en: 'Figure 5.5: Read from Local Storage'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：从本地存储读取
- en: The build time for this project is approximately 60 minutes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的构建时间大约为60分钟。
- en: Project overview
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目概述
- en: The `LocalStorage` project will be created by using Microsoft’s **Blazor WebAssembly
    App Empty** project template to create an empty Blazor WebAssembly project. First,
    we will add a JavaScript file with the JavaScript functions that our service will
    need to use to update the application’s local storage. Next, we will create the
    interface and class with the .NET methods that will invoke the JavaScript functions.
    Finally, we will test our service by adding a collocated JavaScript file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Microsoft的**Blazor WebAssembly App Empty**项目模板创建一个空的Blazor WebAssembly项目，将创建`LocalStorage`项目。首先，我们将添加一个JavaScript文件，其中包含我们的服务将需要使用的JavaScript函数来更新应用程序的本地存储。接下来，我们将创建接口和类，其中包含将调用JavaScript函数的.NET方法。最后，我们将通过添加一个本地JavaScript文件来测试我们的服务。
- en: Getting started with the project
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目入门
- en: 'We need to create a new Blazor WebAssembly app. We do this as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的Blazor WebAssembly应用程序。我们这样做如下：
- en: Open Visual Studio 2022.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio 2022。
- en: Click the **Create a new project** button.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新项目**按钮。
- en: Press *Alt*+*S* to enter the **Search for templates** textbox.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Alt*+*S*进入**搜索模板**文本框。
- en: Enter `Blazor` and press the *Enter* key.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Blazor`并按*Enter*键。
- en: 'The following screenshot shows the **Blazor WebAssembly App Empty** project
    template:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了**Blazor WebAssembly App Empty**项目模板：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18471_05_06.png)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息  自动生成的描述](img/B18471_05_06.png)'
- en: 'Figure 5.6: Blazor WebAssembly App Empty project template'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.6：Blazor WebAssembly App Empty项目模板
- en: Select the **Blazor WebAssembly App Empty** project template and click the **Next**
    button.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Blazor WebAssembly App Empty**项目模板并点击**下一步**按钮。
- en: Enter `LocalStorage` in the **Project name** textbox and click the **Next**
    button.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目名称**文本框中输入`LocalStorage`并点击**下一步**按钮。
- en: 'This is a screenshot of the dialog used to configure our new project:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们配置新项目所使用的对话框的截图：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_07.png)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18471_05_07.png)'
- en: 'Figure 5.7: Configure your new project dialog'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7：配置新项目对话框
- en: '**TIP**'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**'
- en: In the preceding example, we placed the `LocalStorage` project into the `E:/Blazor`
    folder. However, the location of this project is not important.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`LocalStorage`项目放置在`E:/Blazor`文件夹中。然而，此项目的位置并不重要。
- en: Select **.NET 7.0** as the **Framework** version to use.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**.NET 7.0**作为要使用的**框架**版本。
- en: Check the **Configure for HTTPS** checkbox.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**配置为HTTPS**复选框。
- en: Uncheck the **ASP.NET Core Hosted** checkbox.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**ASP.NET Core托管**复选框。
- en: Uncheck the **Progressive Web Application** checkbox.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**渐进式Web应用程序**复选框。
- en: 'This is a screenshot of the dialog used to collect additional information about
    our new project:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是用于收集有关我们新项目额外信息的对话框截图：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_08.png)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18471_05_08.png)'
- en: 'Figure 5.8: Additional information dialog'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.8：附加信息对话框
- en: Click the **Create** button.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: We have created an empty `LocalStorage` Blazor WebAssembly project. Let’s now
    start adding the JavaScript functions that we will need for reading and writing
    to local storage.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个空的`LocalStorage` Blazor WebAssembly项目。现在，让我们开始添加我们将需要的用于读取和写入本地存储的JavaScript函数。
- en: Writing JavaScript to access local storage
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写JavaScript以访问本地存储
- en: 'We need to write the JavaScript functions that will read to and write from
    the application’s local storage. We do this as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写将读取和写入应用程序本地存储的JavaScript函数。我们这样做如下：
- en: Right-click the `wwwroot` folder and select the **Add**, **New Folder** option
    from the menu.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`wwwroot`文件夹，从菜单中选择**添加**，**新建文件夹**选项。
- en: Name the new folder `scripts`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹命名为`scripts`。
- en: Right-click the `scripts` folder and select the **Add**, **New Item** option
    from the menu.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`scripts`文件夹，从菜单中选择**添加**，**新建项**选项。
- en: Enter `javascript` in the **Search** box.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入`javascript`。
- en: Select **JavaScript File**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**JavaScript文件**。
- en: Name the JavaScript file `bweInterop.js`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JavaScript文件命名为`bweInterop.js`。
- en: Click the **Add** button.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮。
- en: 'Enter the following JavaScript:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下JavaScript：
- en: '[PRE16]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding JavaScript includes a `setLocalStorage` function that writes to
    local storage, and the `getLocalStorage` function, which reads from local storage.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述JavaScript包含一个`setLocalStorage`函数，用于写入本地存储，以及一个`getLocalStorage`函数，用于从本地存储读取。
- en: Open the `wwwroot/index.html` file.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`wwwroot/index.html`文件。
- en: 'Add the following markup to the bottom of the `body` element:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`元素的底部添加以下标记：
- en: '[PRE17]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**IMPORTANT NOTE**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In the `wwwroot/index.html` file, the `script` tag that references your custom
    Java-Script should be after the Blazor script reference.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wwwroot/index.html`文件中，引用您自定义JavaScript的`script`标签应该位于Blazor脚本引用之后。
- en: Now we need to add the .NET code that will invoke these JavaScript functions.
    First, we will create the interface for our service.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加将调用这些JavaScript函数的.NET代码。首先，我们将为我们的服务创建接口。
- en: Adding the ILocalStorageService interface
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ILocalStorageService接口
- en: 'We need to create an interface for our service. We do this as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的服务创建一个接口。我们这样做如下：
- en: Right-click the `LocalStorage` project and select the **Add**, **New Folder**
    option from the menu.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`LocalStorage`项目，从菜单中选择**添加**，**新建文件夹**选项。
- en: Name the new folder `Services`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹命名为`Services`。
- en: Right-click the **Services** folder and then select the **Add**, **New Item**
    option from the menu.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**Services**文件夹，然后从菜单中选择**添加**，**新建项**选项。
- en: Enter `interface` in the **Search** box.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入`interface`。
- en: Select **Interface**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**接口**。
- en: Name the file `ILocalStorageService`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为`ILocalStorageService`。
- en: Click the **Add** button.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮。
- en: 'Add the following code to the `ILocalStorageService` interface:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ILocalStorageService`接口中：
- en: '[PRE18]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding methods will be used to set the value of local storage.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述方法将用于设置本地存储的值。
- en: Open the `Program.cs` file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件。
- en: 'Add the following `using` statement:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`using`语句：
- en: '[PRE19]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code after the code that registers `HttpClient`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册`HttpClient`的代码之后添加以下代码：
- en: '[PRE20]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code registers the `LocalStorageService` in the dependency injection
    container. For more information on dependency injection, refer to *Chapter 7*,
    *Building a Shopping Cart Using Application State.*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`LocalStorageService`注册到依赖注入容器中。有关依赖注入的更多信息，请参阅*第7章*，*使用应用程序状态构建购物车*。
- en: We have defined the abstract methods of the service and registered it with the
    application. Now it’s time to create the `LocalStorageService` class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了服务的抽象方法并将其注册到应用程序中。现在，是时候创建`LocalStorageService`类了。
- en: Creating the LocalStorageService class
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LocalStorageService类
- en: 'We need to create a new class based on the interface we just created. We do
    this as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要基于我们刚刚创建的接口创建一个新的类。我们这样做如下：
- en: Right-click the **Services** folder and select the **Add**, **Class** option
    from the menu.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**Services**文件夹，从菜单中选择**添加**，**类**选项。
- en: Name the new class `LocalStorageService`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`LocalStorageService`。
- en: 'Update the `LocalStorageService` class to inherit from `ILocalStorageService`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LocalStorageService`类更新为从`ILocalStorageService`继承：
- en: '[PRE21]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code to the `LocalStorageService` class:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`LocalStorageService`类中：
- en: '[PRE22]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code defines the constructor for the `LocalStorageService` class.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码定义了`LocalStorageService`类的构造函数。
- en: 'Add the `SetItemAsync` method to the `LocalStorageService` class:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SetItemAsync`方法添加到`LocalStorageService`类中：
- en: '[PRE23]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SetItemAsync` method invokes the `bweInterop.setLocalStorage` JavaScript
    function with a key and a serialized version of the item to be stored in `localStorage`.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SetItemAsync`方法使用键和要存储在`localStorage`中的项的序列化版本调用`bweInterop.setLocalStorage`
    JavaScript函数。'
- en: 'Update the `GetItemAsync` method to the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GetItemAsync`方法更新为以下内容：
- en: '[PRE24]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `GetItemAsync` method invokes the `bweInterop.getLocalStorage` JavaScript
    function with a key. If `bweInterop.getLocalStorage` returns a value, that value
    is deserialized and returned.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetItemAsync`方法使用键调用`bweInterop.getLocalStorage` JavaScript函数。如果`bweInterop.getLocalStorage`返回一个值，则该值将被反序列化并返回。'
- en: We have completed our service. Now we need to test it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的服务。现在我们需要对其进行测试。
- en: Creating the DataInfo class
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`DataInfo`类
- en: 'The `DataInfo` class will be used to hold the data that we read and write from
    the application’s local storage:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataInfo`类将用于存储我们从应用程序的本地存储中读取和写入的数据：'
- en: Right-click the `LocalStorage` project and select the **Add**, **New Folder**
    option from the menu.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`LocalStorage`项目，从菜单中选择**添加**，**新文件夹**选项。
- en: Name the new folder `Models`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹命名为`Models`。
- en: Right-click the **Models** folder and select the **Add**, **Class** option from
    the menu.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**Models**文件夹，从菜单中选择**添加**，**类**选项。
- en: Name the new class `DataInfo`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`DataInfo`。
- en: 'Add the following properties to the `DataInfo` class:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`DataInfo`类中：
- en: '[PRE25]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DataInfo` class includes the data, information about the length of the
    data, and the date and time the data was updated.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataInfo`类包括数据、关于数据长度的信息，以及数据更新的日期和时间。'
- en: Now that we have defined an object to hold our data, it’s time to test writing
    data to the application’s local storage.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个对象来存储我们的数据，是时候测试将数据写入应用程序的本地存储了。
- en: Writing to local storage
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入本地存储
- en: 'We need to test writing to the application’s local storage using our local
    storage service. We do this as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用我们的本地存储服务测试向应用程序的本地存储写入。我们这样做如下：
- en: Open the `Pages/Index.razor` file.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Pages/Index.razor`文件。
- en: Delete the `H1` element.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`H1`元素。
- en: 'Add the following directive:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下指令：
- en: '[PRE26]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following markup:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下标记：
- en: '[PRE27]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding markup adds a textbox to enter the data to be saved to the application’s
    local storage and a button to call the `SaveToLocalStorageAsync` method.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述标记添加了一个文本框，用于输入要保存到应用程序本地存储的数据，以及一个按钮来调用`SaveToLocalStorageAsync`方法。
- en: Right-click the **Pages** folder and select the **Add**, **Class** option from
    the menu.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**Pages**文件夹，从菜单中选择**添加**，**类**选项。
- en: Name the new class `Index.razor.cs`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`Index.razor.cs`。
- en: 'Change the class into a partial class by adding the `partial` keyword:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`partial`关键字将类转换为部分类：
- en: '[PRE28]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following to the code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到代码中：
- en: '[PRE29]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code injects the `LocalStorageService` into the component and
    defines the `SaveToLocalStorageAsync` method. The `SaveToLocalStorageAsync` method
    uses **localStorageData** as the key when saving the data to `localStorage`.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将`LocalStorageService`注入到组件中，并定义了`SaveToLocalStorageAsync`方法。`SaveToLocalStorageAsync`方法在将数据保存到`localStorage`时使用**localStorageData**作为键。
- en: Press *Ctrl*+*F5* to start the application without debugging.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*+*F5*以不带调试启动应用程序。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18471_05_09.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18471_05_09.png)'
- en: 'Figure 5.9: Local Storage Service test page'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：本地存储服务测试页面
- en: Enter the word `Test` into the **localStorageData** textbox.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**localStorageData**文本框中输入单词`Test`。
- en: Click the **Save to Local Storage** button.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存到本地存储**按钮。
- en: Press *F12* to open the browser’s developer tools.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F12*打开浏览器的开发者工具。
- en: Select the **Application** tab.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**应用程序**选项卡。
- en: Open `Local Storage`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Local Storage`。
- en: Enter a different word into the **localStorageData** textbox.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**localStorageData**文本框中输入不同的单词。
- en: Click the **Save to Local Storage** button.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存到本地存储**按钮。
- en: Verify that the application’s local storage has been updated.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the browser.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have used the Web Storage API to save data to the application’s local storage.
    Next, we need to learn how to read from the application’s local storage. Since
    we will be displaying the data in a JavaScript alert box, we need to add some
    JavaScript code to call the alert function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collocated JavaScript file
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add a collocated JavaScript file to contain the JavaScript code
    that will call the alert function. We do this as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Return to Visual Studio.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Pages** folder and select the **Add**, **New Item** option
    from the menu.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `javascript` in the **Search** box.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **JavaScript File**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the JavaScript file `Index.razor.js`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following JavaScript to the `Index.razor.js` file:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code exports the `showLocalStorage` function that opens an alert
    box, containing the text that is specified by the `data` parameter.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `Pages/Index.razor.cs` file.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject an instance of `IJSRuntime` into the `Index` component by adding the
    following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following property:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the `OnAfterRenderAsync` method:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The JavaScript functions that are in the `Pages/Index.razor.js` file can now
    be invoked from the `Index` component.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Reading from local storage
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to test reading from the application’s local storage using our local
    storage service. We do this as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Pages/Index.razor` file.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following button beneath the existing button:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding markup adds a button that calls the `ReadFromLocalStorageAsync`
    method.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the Pages/Index.razor.cs file.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ReadFromLocalStorageAsync` method:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ReadFromLocalStorageAsync` method uses the `localStorageData` key when
    accessing the application’s local storage.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Ctrl*+*F5* to start the application without debugging.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Read from Local Storage** button.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the contents of the alert box match the contents of the application’s
    local storage.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ReadFromLocalStorage` method invoked the `showLocalStorage` function in
    the collocated JavaScript file. We have now completed the testing of our local
    storage service.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be able to create a local storage service by using JS interop
    to invoke JavaScript functions from your Blazor WebAssembly application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explained why you may still need to use JavaScript and how
    to use the `IJSRuntime` abstraction to invoke JavaScript functions from .NET,
    both asynchronously and synchronously. Conversely, we explained how to invoke
    .NET methods from JavaScript functions. Finally, we explained how to store data
    in the browser by using the application’s local storage.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: After that, we used the `Blazor WebAssembly App Empty` project template to create
    a new project. We added a couple of JavaScript functions to read and write the
    application’s local storage. Then, we added a class to invoke those JavaScript
    functions. In the last part of the chapter, we tested our local storage service
    by adding a collocated JavaScript file that opened a JavaScript alert box.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用了`Blazor WebAssembly App Empty`项目模板来创建一个新的项目。我们添加了一些JavaScript函数来读取和写入应用程序的本地存储。然后，我们添加了一个类来调用这些JavaScript函数。在章节的最后部分，我们通过添加一个打开JavaScript警告框的JavaScript文件来测试我们的本地存储服务。
- en: One of the biggest benefits of using Blazor WebAssembly is that all the code
    runs on the browser. This means that a web app built using Blazor WebAssembly
    can run offline. In the next chapter, we will leverage this advantage to create
    a progressive web app.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blazor WebAssembly的最大好处之一是所有代码都在浏览器上运行。这意味着使用Blazor WebAssembly构建的Web应用可以离线运行。在下一章中，我们将利用这一优势来创建一个渐进式Web应用。
- en: Questions
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions are provided for your consideration:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题供您思考：
- en: Can `IJSRuntime` be used to render a UI?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IJSRuntime`能否用来渲染UI？'
- en: How would you add our local storage service to a Razor class library?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何将我们的本地存储服务添加到Razor类库中？
- en: What are the benefits of using a collocated JavaScript file?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本地化JavaScript文件有哪些好处？
- en: Do you think that you will still use JavaScript? If so, what will you use it
    for?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为你还会继续使用JavaScript吗？如果是的话，你打算用它来做什么？
- en: In what scenarios do you need to invoke JavaScript asynchronously rather than
    synchronously?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么场景下你需要异步调用JavaScript而不是同步调用？
- en: Further reading
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources provide more information regarding the topics covered
    in this chapter:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了关于本章涵盖主题的更多信息：
- en: For more information on using JavaScript, refer to [https://www.w3schools.com/js](https://www.w3schools.com/js).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于使用JavaScript的信息，请参考[https://www.w3schools.com/js](https://www.w3schools.com/js)。
- en: For more detailed information on JavaScript, refer to [https://developer.mozilla.org/en-US/docs/Web/javascript](https://developer.mozilla.org/en-US/docs/Web/javascript).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于JavaScript的详细信息，请参考[https://developer.mozilla.org/en-US/docs/Web/javascript](https://developer.mozilla.org/en-US/docs/Web/javascript)。
- en: For the JavaScript reference, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要查看JavaScript的参考信息，请参考[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)。
- en: For more information on `localStorage`, refer to [https://www.w3.org/TR/webstorage/#the-localstorage-attribute](https://www.w3.org/TR/webstorage/#the-localstorage-attribute).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于`localStorage`的信息，请参考[https://www.w3.org/TR/webstorage/#the-localstorage-attribute](https://www.w3.org/TR/webstorage/#the-localstorage-attribute)。
- en: For more information on Microsoft Edge (Chromium) Developer Tools, refer to
    [https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于Microsoft Edge (Chromium)开发者工具的信息，请参考[https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium)。
