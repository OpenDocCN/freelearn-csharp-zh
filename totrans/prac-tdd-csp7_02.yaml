- en: Setting Up the .NET Test Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore setting up your development environment. We'll
    be covering both C# and .NET. In the following chapter, we will focus on setting
    up a JavaScript and React environment. We'll delve into more examples, starting
    with the classic code kata entitled *FizzBuzz,* and then into more real-world
    samples from the *Speaker Meet* site.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing your IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up your testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first tests in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the .NET Core SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you get started with the development environments, you will want to install
    the .NET Core SDK. You'll need to navigate to the .NET Core download page on the
    Microsoft website ([https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)).
    Select the proper installer for your system. For Windows machines, the `.exe`
    download is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the onscreen instructions for the install wizard to install the .NET
    Core SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting set up with VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One benefit of choosing VS Code for your development is that it is an excellent
    IDE for both .NET and JavaScript. To get started using VS Code, you must first
    download the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the VS Code website ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    and choose the proper version for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installing the VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the instructions in the wizard to install the VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Be sure to read and accept the License Agreement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose a location on your hard drive to install VS Code. The default path is
    usually acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose to create a Start menu folder for the application, select a location,
    or choose to not create a Start menu folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select additional tasks. The default should be fine for our purposes, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Review your installation settings and click on Install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the install is finished, you''re OK to launch the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VS Code is a fairly lightweight and bare-bones IDE. You'll need to install C#
    to get started. When you launched VS Code for the first time, your browser should
    have opened to the Getting Started page on the VS Code website. If it didn't,
    go there now ([https://code.visualstudio.com/docs](https://code.visualstudio.com/docs)).
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of useful extensions that you can install from the marketplace.
    For now, all you will need is C#. At the time of writing, C# was listed near the
    top of the Top Extensions list. Click on the C# tile (or find it by searching
    in the marketplace) to learn more about this extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see that the installation instructions direct you to launch VS Code
    Quick Open (*Ctrl*-*P*) and paste the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From within VS Code, paste the command into the Quick Open section and press
    *Enter*. Find the C# version powered by OmniSharp and choose Install. Once the
    C# extension is installed, you will need to reload VS Code to activate the C#
    extension (choose reload).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your VS Code IDE is properly installed with the C# extension enabled,
    you are ready to create your first project.
  prefs: []
  type: TYPE_NORMAL
- en: With VS Code open, choose Open Folder from the File menu. Choose a location
    that is easily accessible. Many developers will create a `Development` folder
    on the root of their drive. Whatever convention you're used to will be fine. You
    now need to create an *MSTest* project.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `Sample`. Open the Integrated Terminal window from
    the View menu or by using the shortcut keys (*Ctrl* + *`*). From within the Terminal
    window, type `dotnet new mstest` and hit *Enter*. Now, you need to restore your
    packages by typing `dotnet restore` into the Terminal window and hitting *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see a file named `UnitTest1.cs` within the `Sample` folder.
    If you open the file, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the first test method to an `ItExists` test. Do this by changing the
    name to `ItExists` and trying to declare an instance to a class that does not
    yet exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see that your sample application will not compile and you will have
    received the error message, `The type or namespace 'SampleClass' could not be
    found (are you missing a using directive or an assembly reference?)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a test failure (remember, failing to compile counts as a
    failing test in this instance), it''s safe to move on to the *Green* step in our
    *red, green, refactor* cycle. Make the test pass by creating a definition for
    `SampleClas*s*`. Feel free to create the class in the same file as your unit tests,
    just to get you started. This can always be extracted and moved to a more appropriate
    location later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you''ve made the change, run the `test` command `dotnet test`and see
    the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Continue exploring VS Code and growing your new class through tests. The C#
    and .NET examples throughout the rest of the book will be using Visual Studio
    Community. If you prefer, you may choose to stick with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Visual Studio Community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most C# and .NET developers will be familiar with Visual Studio. There are a
    variety of versions available, ranging from free to many thousands of dollars
    annually. As of this writing, the Enterprise version was the most fully featured
    version, offering some of the best features for tests and testing. For our purposes,
    we'll be using Visual Studio Community. This is a free, fully featured development
    environment that should suit us well.
  prefs: []
  type: TYPE_NORMAL
- en: The Community edition does have some very important caveats. There are limitations
    to the software license and the use of the Community edition, based on the terms
    of the license agreement. Please make sure to read the terms before deciding to
    use Visual Studio Community edition to develop software that you intend to sell.
    The current terms can be found at [https://www.visualstudio.com/license-terms/mlt553321/](https://www.visualstudio.com/license-terms/mlt553321/).
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Visual Studio Community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, download Visual Studio Community ([https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)).
    Feel free to explore and compare the different versions of Visual Studio while
    you''re there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installing Visual Studio Community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wizard for installing Visual Studio Community is a little different from
    the install wizard for VS Code. Of course, to get started, you'll need to read
    and agree to the license agreement.
  prefs: []
  type: TYPE_NORMAL
- en: At a minimum, you'll want to choose ASP.NET and web development and .NET Core
    cross-platform development if you plan to follow along with the book. We've also
    chosen to include ASP.NET MVC 4, .NET Framework 4.6.2 development tools, and .NET
    Framework 4.7 development tools from the right pane, or from the *Individual components*
    tab*.* You might want to explore other components and/or language packs, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to xUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MSTest has long shipped with Visual Studio. There are a few other options when
    it comes to testing frameworks for C# and .NET. Many of these frameworks have
    feature parity and differ only slightly in their choices of attributes, assertions,
    and exception handling. Among the top contenders for testing frameworks is xUnit.
    Many developers actually prefer this to MSTest and would argue that it is more
    feature-rich and has stronger community support. Arguments aside, we'll be using
    xUnit for our C# and .NET tests from here on out.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to stick with MSTest if you prefer. Just know that you'll need to
    account for the semantic differences (such as *TestMethod* vs *Fact*) and slight
    differences in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Code katas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a code kata? Code katas are nothing more than repeatable exercises.
    Generally, these exercises are meant to take no more than 20 minutes to complete.
    Most code katas are directed at a specific classification of a problem to solve.
    We'll be utilizing the classic example, FizzBuzz, as a way to get you more comfortable
    with TDD using xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: FizzBuzz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rules of FizzBuzz are quite simple. If the number provided is divisible
    by 3, then you must return `Fizz`. If the number supplied is divisible by 5, then
    you must return `Buzz`. If the number is divisible by both 3 and 5, then you must
    return `FizzBuzz`. If it is divisible by neither 3 nor 5, then simply return the
    number itself.
  prefs: []
  type: TYPE_NORMAL
- en: There are a plethora of options in which to solve the problem. It can be solved
    in nearly every programming language, in a variety of different ways. What's important
    here is to practice the techniques of solving the problem simply and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within Visual Studio Community, create an xUnit test project by choosing New
    | Project from the File menu or by using the shortcut keys (*Ctrl *- *Shift *- *N*).
    Under .NET Core, choose xUnit Test Project. Give your project the name `CodeKata`
    and click on OK. You will see a filename `UnitTest1.cs`. This file is fine to
    get you started. Let's create our first test.
  prefs: []
  type: TYPE_NORMAL
- en: The Given3ThenFizz test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first test method in the `UnitTest1.cs` file is named `Test1`. Let''s change
    the name of this method to `Given3ThenFizz` and write our first test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `Fact` attribute and `Assert.Equal` assertion differ only slightly
    from our previous MSTest example. We're leaving the `Arrange`*,* `Act`*,* and
    `Assert` comments in place, and recommend you do the same. These comments will
    help you as you get started. They'll also serve to help describe the process to
    any developers that come behind you in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the test to see whether it passes by selecting Run | All Tests from
    the Test menu, or by using the shortcut keys (*Ctrl* + *R*, *A*). You should see
    a compilation error. Let''s resolve the error by creating a `FizzBuzz` method
    preceding our `test` class. Once you''ve created the `FizzBuzz` method, rerun
    your test to see it pass. Remember, based on the third law of TDD, you should
    only write enough code to make it pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Given5ThenBuzz test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next requirements state that we must return `Buzz` when 5 is supplied.
    Let''s write that test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'How might we make that test pass? Perhaps a simple ternary operator? Let''s
    take a look at what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You might see a problem with our algorithm already. That's OK! We're not done
    yet. We've only gotten as far as the tests have guided us, and so far we're passing
    all of our tests. Let’s move on to the next most interesting test.
  prefs: []
  type: TYPE_NORMAL
- en: The Given15ThenFizzBuzz test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might want to write a test method entitled `GivenDivisibleBy3and5ThenFizzBuzz`,
    but that may be too large of a leap at this point. We know that the first such
    number divisible by 3 and 5 is 15, so it might make more sense to start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How would you choose to make this test pass? Would you use an *if/else* statement?
    Perhaps a *switch* statement? We’ll leave this one as an exercise for the reader.
    Feel free to make this test pass in any way that you're comfortable with implementing.
    Remember to run your tests along the way to ensure you don't introduce a breaking
    change. If you do experience a test failure, feel free to ignore a test (*Ignore*
    attribute in MSTest, *Skip* parameter in xUnit), but only one test, while you
    fix your error(s).
  prefs: []
  type: TYPE_NORMAL
- en: The Given1Then1 test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered `Fizz`. We''ve covered `Buzz`. And, we''ve covered `FizzBuzz`.
    Now we must account for numbers that are divisible by neither 3 nor 5.  Remember,
    in the event that a number is divisible by neither 3 nor 5, we simply return the
    number supplied. Let''s take a look at this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Theories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is great! Things are going quite smoothly. Hopefully, you're starting to
    get the hang of Test-Driven Development. Now, let's look into a slightly more
    advanced test method using the `Theory` and `InlineData` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at our tests, we see that we have a `test` method named `Given15ThenFizzBuzz`.
    While this is fine, it''s a little too specific. Remember, our requirement was
    that, if the number is divisible by 3 and 5, then we should return `FizzBuzz`.
    Let''s ensure we didn''t take too big a leap in logic by writing a new test. This
    time, we’ll supply a number of values, expecting the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When you run the test suite, you should now see four new passed test results.
    If you do experience a failure, the results pane in the Test Explorer window should
    provide a detailed explanation as to which test failed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, do the same thing for `Fizz` and `Buzz` by creating two more test cases
    using `Theories` and `InlineData`. Go ahead and add `GivenDivisibleBy3ThenFizz`,
    `GivenDivisibleBy5ThenBuzz`, and `GivenNotDivisibleBy3or5ThenNumber`. Be sure
    to run your test suite after adding each test and `InlineData` value, fixing any
    failures along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the FizzBuzz Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we came up with looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if you chose to solve the problem a different way. The important
    thing is that you gained knowledge and understanding during this exercise. Additionally,
    you now have a comprehensive set of tests and you're comfortable refactoring and/or
    adding functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What is Speaker Meet?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're using the *Speaker Meet* application as a case study in Test-Driven Development.
    Speaker Meet is a website dedicated to connecting technology speakers, user groups,
    and conferences. Anyone who has helped organize a user group or tech conference
    knows it’s often difficult to find speakers. And as technology speakers, it's
    often difficult to coordinate speaking engagements outside your immediate area.
    Speaker Meet helps bring technology speakers and communities together.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the application is still in development, but it is a
    terrific platform to explore TDD concepts and principles as they relate to real-world
    applications. Speaker Meet consists of a RESTful API in .NET with a **Single Page
    Application** (**SPA**) in JavaScript, utilizing the React library.
  prefs: []
  type: TYPE_NORMAL
- en: Web API project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our first exercise, we'll be creating a new API endpoint. This new endpoint
    will return a list of speakers based on a supplied search term. We'll be utilizing
    this endpoint in our React examples in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Speakers (API)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list of Speakers will be returned from the database by accessing the back-end
    API. Before starting on writing the code, a set of requirements must first be
    established. It's difficult to know where to begin if an agreed upon set of functionality
    hasn't been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below are the requirements, you might expect to receive from a business analyst
    or product owner. These are often a good starting point for a broader conversation.
    If something is not clear, it's best to resolve any ambiguity before you begin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Upon speaking with our product owner, we determined that by the requirement
    of *matching*, what was truly desired was a *starts-with* match. If a conference
    organizer were to search for the string "Jos," the results for *Josh*, *Joshua*,
    *Joseph*, should be returned by the search routine.
  prefs: []
  type: TYPE_NORMAL
- en: A new test file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll start by creating a new test file. Let''s name this file `SpeakerControllerSearchTests.cs`.
    Now, create the first test, `ItExists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To make this compile, you'll need to create a Web API controller called `SpeakerMeetController`.
    Add a new ASP.NET Core Web Application project to your solution. Give your project
    a name of `SpeakerMeet.API` and choose the Web API template to get started. Add
    a reference to this project from your test project and add the appropriate using
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s ensure that there is a `Search` endpoint available. Let''s create
    another test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Make this test pass by creating a `Search` method that accepts a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s confirm that the `Search` action result returns an `OkObjectResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note the multiple `Asserts`. While we want to limit our tests to a single `Act`,
    sometimes it is acceptable, even necessary, to have multiple `Asserts`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `ItReturnsOkObjectResult` test passes, you should delete the `ItExists`
    and `ItHasSearch` tests. Remember, we want to finish the *red, green, refactor*
    cycle and keep our code neat and clean. This includes the test suite, so if you
    have tests that are no longer valid or add no value, then you should feel free
    to remove them. You don't want to have to maintain more code than is required.
    This will help your test suite stay relevant and run nice and fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test that the result is a collection of speakers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re starting to get a little redundant here. Now is a good time to refactor
    our tests to make them cleaner. Let''s extract the creation of the `SpeakerController`
    and initialize this value in the constructor. Be sure to remove the creation in
    your tests and use this new instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re ready to start testing the value of the results. Let''s write
    a test entitled `GivenExactMatchThenOneSpeakerInCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this test to work, we''ll need to hard-code some data. Don''t worry,
    we''re building this application slowly. The hard-coded data will be removed at
    a later point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that our search string is not case-sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to test to verify that, if the string provided does not match
    any of our data, then an empty collection is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we''ll test that any speaker that begins with our search string
    will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the code we came up with looks like. Your implementation may vary
    somewhat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now feel quite comfortable with your .NET development environment.
    The .NET Core SDK should now be installed and your IDE configured. You've had
    some exposure to unit tests and continuous test runners in Visual Studio and VS
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    Up the JavaScript Environment*, we'll focus on getting our JavaScript environment
    set up.
  prefs: []
  type: TYPE_NORMAL
