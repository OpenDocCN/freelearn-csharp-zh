<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Debugging WPF Applications</h1>
                </header>
            
            <article>
                
<p>When our WPF programs don't work as expected, we need to debug them, as we would with any other language. However, at first it can seem to be a daunting task, as WPF is very different from other languages. For example, when declaring a <span>Dependency Property</span>, we normally add a CLR property wrapper for convenience. However, the WPF Framework won't call it when the property value is changing, so we'd wait a long time for a break point in that setter to be hit</p>
<p>When we're testing our newly developed code, we need to be able to check the values of our data bound properties, and there are a number of ways to do that, although some are far from obvious. In this chapter, we'll investigate a number of important sources of information to help us to locate the mistakes in our code.</p>
<p>We'll discover a variety of tactics to help us when debugging the data bound values and find out how to track down the actual cause of a problem when faced with the dreaded <kbd>XamlParseException</kbd>. We'll cover all of these topics in detail shortly, but for now, let's first start with the absolute basics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing the output window</h1>
                </header>
            
            <article>
                
<p>When we've made changes to our XAML but don't see what we are expecting to see in the UI, the first place to look for errors is in the <span class="packt_screen">Output</span> window of Visual Studio. If this window is not already visible, then you can display it by selecting the <span class="packt_screen">Output</span> option from the <span class="packt_screen">View</span> menu or by pressing <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">W</span></em> and then <em><span class="KeyPACKT">O</span></em>.</p>
<p>However, if you have a binding error but don't see any reference to it in the <span class="packt_screen">Output</span> window, it could be because your Visual Studio is not currently set up to output debug information to it. You can turn this functionality on in the Visual Studio <span class="packt_screen">Options</span> dialog window. Navigate to <span class="packt_screen">Tools</span> | <span class="packt_screen">Options</span> | <span class="packt_screen">Debugging</span> | <span class="packt_screen">Output Window</span> | <span class="packt_screen">General Output Settings</span>.</p>
<p>The <span class="packt_screen">General Output Settings</span> section has several options that you can turn on and off. The most important ones are <span class="packt_screen">All debug output</span> and <span class="packt_screen">Exception Messages</span>, but it is generally a good practice to leave them all set to <span class="packt_screen">On</span>. When set, binding errors will be displayed in the <span class="packt_screen">Output</span> window in the following format:</p>
<pre><strong>System.Windows.Data Error: 40 : BindingExpression path error:
'ViewName' property not found on 'object' ''MainViewModel'
(HashCode=3910657)'. BindingExpression:Path=ViewName;
DataItem='MainViewModel' (HashCode=3910657); target element is 'TextBox'</strong><br/><strong>(Name='NameTextBox'); target property is 'Text' (type 'String')</strong></pre>
<p>Let's take a closer look at this error. The plain English translation for this would be as follows:</p>
<ul>
<li>There is no public property named <kbd>ViewName</kbd> in the object of <span>type </span><kbd>MainViewModel</kbd> with a <kbd>HashCode</kbd> value of <kbd>3910657</kbd>.</li>
<li>The error was raised from a <kbd>Binding.Path</kbd> value that was specified as <kbd>ViewName</kbd>, which was set on the <kbd>Text</kbd> property of a <kbd>TextBox</kbd> instance named <kbd>NameTextBox</kbd></li>
</ul>
<p>This could be rewritten with descriptive names rather than specific details, like this:</p>
<pre><strong>System.Windows.Data Error: 40 : BindingExpression path error: 'PropertyOfBindingSource' property not found on 'object' ''TypeOfBindingSource' (HashCode=HashCodeOfBindingSource)'. BindingExpression:Path=UsedBindingPath; DataItem='TypeOfBindingSource' (HashCode=HashCodeOfBindingSource); target element is 'TypeOfBindingTarget' (Name='NameOfBindingTarget'); target property is</strong><br/><strong>'PropertyOfBindingTarget' (type 'TypeOfBindingTargetProperty') </strong></pre>
<p>Now that we have our '<em>key</em>' to explain what these values represent, we can see that they are really very descriptive. Not only are we provided with the name of the data bound UI control, if it is set, and the used binding path, but also the type of the data source, along with the hash code of the actual instance of that type that is being used.</p>
<p>These errors highlight the mistakes that have been made in the XAML files. The type of errors displayed in this window will include incorrectly labeled binding paths, such as using non-existent property names, or otherwise invalid binding source paths. While it won't catch every problem, there is a way to make it output additional information that could help us to track down our more elusive problems. In order to do this, first display the <span class="packt_screen">Options</span> dialog window. Navigate to <span class="packt_screen">Tools</span> | <span class="packt_screen">Options</span> | <span class="packt_screen">Debugging</span> | <span class="packt_screen">Output Window</span> | <span class="packt_screen">WPF Trace Settings</span>.</p>
<p>Here, you can find a number of options, each with a variable level of output: <span class="packt_screen">Animation</span>, <span class="packt_screen">Data Binding</span>, <span class="packt_screen">Dependency Properties</span>, <span class="packt_screen">Documents</span>, <span class="packt_screen">Freezable</span>, <span class="packt_screen">HWND Hosting</span>, <span class="packt_screen">Markup</span>, <span class="packt_screen">Name Scope</span>, <span class="packt_screen">Resource Dictionaries</span>, and <span class="packt_screen">Routed Events</span>. The various levels of output and their meanings are as follows:</p>
<ul>
<li><span class="packt_screen">Critical</span>: Enables tracing of <span class="packt_screen">Critical</span> events only</li>
<li><span class="packt_screen">Error</span>: Enables tracing of <span class="packt_screen">Critical</span> and <span class="packt_screen">Error</span> events</li>
<li><span class="packt_screen">Warning</span>: Enables tracing of <span class="packt_screen">Critical</span>, <span class="packt_screen">Error</span>, and <span class="packt_screen">Warning</span> events</li>
<li><span class="packt_screen">Information</span>: Enables tracing of <span class="packt_screen">Critical</span>, <span class="packt_screen">Error</span>, <span class="packt_screen">Warning</span>, and <span class="packt_screen">Information</span> events</li>
<li><span class="packt_screen">Verbose</span>: Enables tracing of <span class="packt_screen">Critical</span>, <span class="packt_screen">Error</span>, <span class="packt_screen">Warning</span>, <span class="packt_screen">Information</span>, and <span class="packt_screen">Verbose</span> events</li>
<li><span class="packt_screen">ActivityTracing</span>: Enables tracing of <span class="packt_screen">Stop</span>, <span class="packt_screen">Start</span>, <span class="packt_screen">Suspend</span>, <span class="packt_screen">Transfer</span>, and <span class="packt_screen">Resume</span> events</li>
</ul>
<p>It is fairly common to permanently have the <span class="packt_screen">Data Binding</span> option set to <span class="packt_screen">Warning</span> or <span class="packt_screen">Error</span>, with the other options set to <span class="packt_screen">Off</span>. The general rule of thumb when using these options is to use the minimum level required, except when trying to find problems, because they will slow down the running of the application. It should be noted, however, that this extra debug trace output will not affect Release builds at all.</p>
<p>If you set the <span class="packt_screen">Data Binding</span> entry to an output of <span class="packt_screen">Verbose</span> or <span class="packt_screen">All</span> and look in the <span class="packt_screen">Output</span> window when running your application, you will understand why it will negatively affect performance. Even when not displaying this debug information in the <span class="packt_screen">Output</span> window, the WPF Framework will still be performing a great number of checks when there are binding errors. It is, therefore, very important to clear up all errors and warnings that are displayed, to minimize the amount of work that the Framework does when trying to resolve them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting Presentation Trace Sources to work</h1>
                </header>
            
            <article>
                
<p>As useful as it is, there are certain occasions when using the <span class="packt_screen">Output</span> window will not suffice. Perhaps we have far too much output to look through now and would like to view it on the way home from work, or maybe we need to see this kind of debug trace information after our application has been deployed. In these cases and others, it's time to enable the WPF Presentation Trace Sources.</p>
<p>There are a number of different trace sources that we can employ to output detailed tracing data for us. The choice is the same as that found in the <span class="packt_screen">WPF Trace Settings</span> options and, in fact, after setting the values there, the <span class="packt_screen">Output</span> window has already been showing us the debug trace output.</p>
<p>By default, WPF uses a <kbd>DefaultTraceListener</kbd> object to send the information to the <span class="packt_screen">Output</span> window, but we can override that and/or configure the output to be sent to a text and/or XML file instead or as well.</p>
<p>In order to do this, we need to alter our <kbd>app.config</kbd> file, which is found in the root folder of our startup project. We'll need to add a <kbd>system.diagnostics</kbd> section and within it, add <kbd>sources</kbd>, <kbd>switches</kbd>, and <kbd>sharedlisteners</kbd> elements. The <kbd>switches</kbd> element holds the switch that determines the output level, as specified in the previous section.</p>
<p>The <kbd>sharedlisteners</kbd> element specifies which kind of output we want to utilize. The three types are:</p>
<ul>
<li><kbd>System.Diagnostics.ConsoleTraceListener</kbd>: Sends the traces to the <span class="packt_screen">Output</span> window</li>
<li><kbd>System.Diagnostics.TextWriterTraceListener</kbd>: Outputs to a text file</li>
<li><kbd>System.Diagnostics.XmlWriterTraceListener</kbd>: Outputs to an XML file</li>
</ul>
<p>Finally, we need to add a <kbd>source</kbd> element for each trace source that we want to listen to, and specify which switch and listener we want to use with it. Therefore, we are able to output different trace sources to different media and with different levels of output. These trace sources are the same as those found in the <span class="packt_screen">WPF Trace Settings</span> options, although in the configuration file, we need to specify their full names.</p>
<p>The choices are as follows:</p>
<ul>
<li><kbd>System.Windows.Media.Animation</kbd></li>
<li><kbd>System.Windows.Data</kbd></li>
<li><kbd>System.Windows.DependencyProperty</kbd></li>
<li><kbd>System.Windows.Documents</kbd></li>
</ul>
<ul>
<li><kbd>System.Windows.Freezable</kbd></li>
<li><kbd>System.Windows.Interop.HwndHost</kbd></li>
<li><kbd>System.Windows.Markup</kbd></li>
<li><kbd>System.Windows.NameScope</kbd></li>
<li><kbd>System.Windows.ResourceDictionary</kbd></li>
<li><kbd>System.Windows.RoutedEvent</kbd></li>
<li><kbd>System.Windows.Shell</kbd></li>
</ul>
<p>Let's see an example configuration file:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;configuration&gt; 
  &lt;startup&gt;  
    &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" /&gt; 
  &lt;/startup&gt; 
  &lt;system.diagnostics&gt; 
    &lt;sources&gt; 
      &lt;source name="System.Windows.Data" switchName="Switch"&gt; 
        &lt;listeners&gt; 
          &lt;add name="TextListener" /&gt; 
        &lt;/listeners&gt; 
      &lt;/source&gt; 
    &lt;/sources&gt; 
    &lt;switches&gt; 
      &lt;add name="Switch" value="All" /&gt; 
    &lt;/switches&gt; 
    &lt;sharedListeners&gt; 
      &lt;add name="TextListener"  
        type="System.Diagnostics.TextWriterTraceListener"  
        initializeData="Trace.txt" /&gt; 
    &lt;/sharedListeners&gt; 
    &lt;trace indentsize="4" autoflush="true"&gt;&lt;/trace&gt; 
  &lt;/system.diagnostics&gt; 
&lt;/configuration&gt; </pre>
<p>Focusing on the <kbd>system.diagnostics</kbd> section from the example, we see that there is one source element that is specifying the <kbd>System.Windows.Data</kbd> source (for data binding information), the switch named <kbd>Switch</kbd>, and the <kbd>TextListener</kbd> listener. Looking first in the <kbd>switches</kbd> section, we find the switch named <kbd>Switch</kbd> and note that it is set with an output level of <kbd>All</kbd>.</p>
<p>Below this, in the <kbd>sharedlisteners</kbd> element, we see the listener named <kbd>TextListener</kbd>. This listener is of <span>type </span><kbd>System.Diagnostics.TextWriterTraceListener</kbd> and this outputs to a text file which is specified by the value of the <kbd>initializeData</kbd> attribute. We end with a <kbd>trace</kbd> element that sets the tab size of the text document to four spaces and ensures that data is flushed out of the buffer after each write to prevent trace data from being lost due to a crash.</p>
<p>To set a less verbose output, we can simply alter the switch to use one of the other levels of output, as follows:</p>
<pre>&lt;add name="Switch" value="Error" /&gt; </pre>
<p>As mentioned earlier, WPF can use a <kbd>DefaultTraceListener</kbd> object to send trace information to the <span class="packt_screen">Output</span> window when particular options are set in Visual Studio. The name of this listener is <kbd>Default</kbd>. In order to stop the default behavior of this <kbd>DefaultTraceListener</kbd>, we can remove it using our <kbd>source</kbd> element, as follows:</p>
<pre>&lt;source name="System.Windows.Data" switchName="Switch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
    &lt;remove name="Default" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; </pre>
<p>It's good to be aware of this fact, because if we also configured our own <kbd>ConsoleTraceListener</kbd> object, we could end up with our <span class="packt_screen">Output</span> window duplicating trace events. However, it is also possible to add multiple listeners into each <kbd>source</kbd> element if required:</p>
<pre>&lt;source name="System.Windows.Data" switchName="Switch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
    &lt;add name="OutputListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; </pre>
<p>We can also add different listeners for different sources:</p>
<pre>&lt;source name="System.Windows.Data" switchName="Switch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; 
&lt;source name="System.Windows.DependencyProperty" switchName="Switch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="OutputListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; 
... 
&lt;sharedListeners&gt; 
  &lt;add name="TextListener"  
    type="System.Diagnostics.TextWriterTraceListener"  
    initializeData="Trace.txt" /&gt; 
  &lt;add name="OutputListener"  
    type="System.Diagnostics.ConsoleTraceListener" /&gt; 
&lt;/sharedListeners&gt; </pre>
<p>Different output levels for different sources can be added as follows:</p>
<pre>&lt;source name="System.Windows.Data" switchName="ErrorSwitch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; 
&lt;source name="System.Windows.DependencyProperty" switchName="AllSwitch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="OutputListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; 
... 
&lt;switches&gt; 
  &lt;add name="AllSwitch" value="All" /&gt; 
  &lt;add name="ErrorSwitch" value="Error" /&gt; 
&lt;/switches&gt; </pre>
<p>One neat feature that WPF Presentation Trace Sources provide is the ability to create our own custom trace sources:</p>
<pre>&lt;source name="CompanyName.ApplicationName" switchName="Switch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; </pre>
<p>Note that the <kbd>DefaultTraceListener</kbd> was already configured to send information to the <span class="packt_screen">Output</span> window in the <span class="packt_screen">WPF Trace Settings</span> options mentioned in the previous section, so the traces from this source will also be sent to the <span class="packt_screen">Output</span> window automatically. If you have not set those options but want to view the trace output there, then you will need to manually add a reference to the <kbd>ConsoleTraceListener</kbd> to this source as shown in the preceding code snippets.</p>
<p>In the code, we are now able to output custom trace information to this source:</p>
<pre>TraceSource traceSource = new TraceSource("CompanyName.ApplicationName");<br/>traceSource.TraceEvent(TraceEventType.Information, eventId, "Data loaded"); 
// Alternative way to output information with an event id of 0 
traceSource.TraceInformation("Data loaded"); </pre>
<p>To specify different levels of importance, we use the <kbd>TraceEventType</kbd> enumeration:</p>
<pre>traceSource.TraceEvent(TraceEventType.Error, eventId, "Data not loaded"); </pre>
<p>After outputting the debug information, we can optionally flush the existing listeners to ensure that they receive the events in the buffers before continuing:</p>
<pre>traceSource.Flush(); </pre>
<p>Finally, we need to ensure that we close the <kbd>TraceSource</kbd> object to free resources when we have outputted the necessary information:</p>
<pre>traceSource.Close(); </pre>
<p>The best part of this tracing functionality is the fact that we can turn it on and off using the configuration file, either at design time, runtime, or even on production versions of the application. As the configuration file is basically a text file, we can manually edit it and then restart the application so that it reads the new configuration.</p>
<p>Imagine that we had two switches in our file and that our default configuration used the switch named <kbd>OffSwitch</kbd>, so that there was no tracing output:</p>
<pre>&lt;source name="CompanyName.ApplicationName" switchName="OffSwitch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; <br/>... <br/>&lt;switches&gt;
  &lt;add name="AllSwitch" value="All" /&gt; 
  &lt;add name="OffSwitch" value="Off" /&gt; 
&lt;/switches&gt; </pre>
<p>Now imagine that we have deployed our application and it is installed on a user's computer. It's worth noting at this point that the actual deployed configuration file that is created from the <kbd>app.config</kbd> file will have the same name as the executable file. In our case, it would be named <kbd>CompanyName.ApplicationName.exe.config</kbd> and would reside in the same folder as the executable file.</p>
<p>If this installed application was not behaving correctly, we could locate this configuration file, and simply change the switch to the one named <kbd>AllSwitch</kbd>:</p>
<pre>&lt;source name="CompanyName.ApplicationName" switchName="AllSwitch"&gt; 
  &lt;listeners&gt; 
    &lt;add name="TextListener" /&gt; 
  &lt;/listeners&gt; 
&lt;/source&gt; </pre>
<p>After restarting the application, the new configuration would be read and our custom traces would be written to the specified text file. One alternative to restarting the application would be to call the <kbd>Refresh</kbd> method of the <kbd>Trace</kbd> class, which has the same effect of initiating a new read of the configuration file:</p>
<pre>Trace.Refresh(); </pre>
<p>This method call can even be connected to a menu item or other UI control to enable tracing to be turned on and off without having to restart the application. Using either of these methods of refreshing the configuration file, we can attain important debug information from our software, even when it is in production. However, great care should be taken to ensure that text or XML file tracing is not permanently enabled on released software, as it will negatively affect performance.</p>
<p>While the WPF Presentation Trace Sources are typically available by default these days, in a few cases, we may need to manually enable this tracing functionality by adding the following registry key:</p>
<pre>HKEY_CURRENT_USER\Software\Microsoft\Tracing\WPF </pre>
<p>Once the <kbd>WPF</kbd> registry key has been added, we need to add a new <kbd>DWORD</kbd> value to it, name it <kbd>ManagedTracing</kbd>, and set its value to <kbd>1</kbd>. We should then have access to the WPF Presentation Trace Sources. We've now seen a number of ways of finding the information that we need at runtime, but what about if the application won't even run?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering inner exceptions</h1>
                </header>
            
            <article>
                
<p>When we are building the content of our Views, we often make the odd typographical mistake here and there. Perhaps, we mistype the name of one of our properties in a binding path, or copy and paste some code that references other code that we have not copied.</p>
<p class="CDPAlignLeft CDPAlign">At first, it may appear to be quite difficult to find the source of these types of errors, because when we run our application, the actual error that is raised by Visual Studio is usually of type <kbd>XamlParseException</kbd> and bares no direct relation to the actual error. The additional information provided is also of little help. Here is a typical example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2112 image-border" src="assets/d884d8a1-747a-4b93-861c-079504959e25.png" style="width:40.00em;height:38.42em;"/></p>
<p class="mce-root">Let's investigate this further. We can see that the additional information supplied here says:</p>
<p class="mce-root"><span class="packt_screen">'Provide value on 'System.Windows.Markup.StaticResourceHolder' threw an exception.' Line number '48' and line position '41'.</span></p>
<p class="mce-root">Now let's try to break this down to some meaningful information. Firstly, it is clear that the exception was thrown by the <kbd>System.Windows.Markup.StaticResourceHolder</kbd> class. By itself, this information is not very useful, but at least we know that the problem has something to do with a <kbd>StaticResource</kbd> that could not be resolved.</p>
<p>The next bit of information that we can gather from this message is that the problem occurred on line 48 and position 41. However, without informing us of which file this relates to, this information is also not very useful. The <span class="packt_screen">Exception</span> dialog window shown in the preceding screenshot will often have a line pointing to the line and position in the current file, which can also be another red herring. In this particular case, it was indeed false information as there was no error there, but at least that tells us that the problem has not arisen from the current file.</p>
<p class="CDPAlignLeft CDPAlign">The trick to finding out what caused the real problem that occurred is for us to click the <span class="packt_screen">View Detail...</span> link in the window. This will open the <span class="packt_screen">View Detail</span> window, where we can see all of the property values of <kbd>XamlParseException</kbd>. Looking at the <kbd>StackTrace</kbd> and <kbd>TargetSite</kbd> property values won't help in the way that they usually do with normal exceptions. However, if we open up and inspect the <kbd>InnerException</kbd> property value, we can finally find out what actually happened.</p>
<p class="CDPAlignLeft CDPAlign">Let's do that with our example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2114 image-border" src="assets/c7253db5-f62c-41f5-9f31-b8d094d27645.png" style="width:42.50em;height:37.25em;"/></p>
<p>At last, we have something that we can work with. The <kbd>InnerException.Message</kbd> property value states: <kbd>"Cannot find resource named 'BaseButtonStyle'. Resource names are case sensitive"</kbd>.</p>
<p>Therefore, our offending object references the <kbd>BaseButtonStyle</kbd> style. A quick search for '<kbd>BaseButtonStyle</kbd>' through the solution files in Visual Studio will locate the source of the problem. In this case, our problem lay in the <kbd>Application.Resources</kbd> section of the <kbd>App.xaml</kbd> file. Let's take a closer look:</p>
<pre>&lt;Style x:Key="SmallButtonStyle" TargetType="{x:Type Button}" 
  BasedOn="{StaticResource BaseButtonStyle}"&gt; 
  &lt;Setter Property="Height" Value="24" /&gt; 
  &lt;Setter Property="Width" Value="24" /&gt; 
&lt;/Style&gt; </pre>
<p>Here we can see a style that is based on another style, but the base style is apparently missing. It is this missing base style that is the <kbd>StaticResource</kbd> named <kbd>BaseButtonStyle</kbd> that caused this error. We can fix this problem easily by either creating the referenced base style in the <kbd>App.xml</kbd> file, or by removing the <kbd>BasedOn</kbd> property from the <kbd>SmallButtonStyle</kbd> style.</p>
<p>We should always bear in mind that errors like these will most likely reside in the code that we have just been editing, so that also helps us to narrow down the search. It is therefore beneficial to run the application often when implementing XAML that may contain errors, as the more code we write between checking our progress, the more code we need to look through to find the problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging data bound values</h1>
                </header>
            
            <article>
                
<p>So far, we have seen that we can utilize a number of sources of information to help with tracking down the causes of our problems. However, what about actual debugging? In other GUI languages, we can add breakpoints at various locations in our code and watch our values changing as we step through our code. While we can also do this with WPF applications, it is not always so obvious where to put our breakpoints to ensure that program execution will hit them.</p>
<p>If you remember from the previous chapter, the <kbd>CommandManager.RequerySuggested</kbd> event is raised when <kbd>CommandManager</kbd> detects a change in the UI that could reflect on whether a command could execute or not. Well, it turns out that two of the conditions that the <kbd>CommandManager</kbd> looks out for is when the application window is either activated or deactivated and we can take advantage of this to help us when debugging. Note that the application window is deactivated when the user moves focus from it and is reactivated when the user returns focus to it.</p>
<p>Therefore, while running the application side by side with Visual Studio, we can put a breakpoint in any method that is being used as a <kbd>canExecute</kbd> handler for our <kbd>ActionCommand</kbd> class, thereby removing focus from the application. Now, when we click back on the WPF application, the focus will be returned to it.</p>
<p>This will cause the <kbd>CommandManager.RequerySuggested</kbd> event to be raised and as a result, the <kbd>canExecute</kbd> handler will be called and our breakpoint will be hit. This basically means that we are able to get the program execution into our View Models to debug parameter values any and every time that we need to. Let's see what else we can do to help fix our data binding errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Outputting values to UI controls</h1>
                </header>
            
            <article>
                
<p>One of the simplest ways of working out what values our data bound properties have is to just data bind them to other UI controls that have a textual output. For example, if we have a collection of items and we want to do something with the selected item, but whatever that is isn't working, we need to verify that our binding to that selected item is correct.</p>
<p>To visualize the result of the binding, we can simply copy and paste the binding path to the <kbd>Text</kbd> property of a <kbd>TextBox</kbd> and run the application. If our binding path is correct, we'll see something output in the <kbd>TextBox</kbd> and if not, we'll know that the problem that we're having is, in fact, down to the binding path. We can, therefore, use this method to verify that objects that don't normally have a textual output are at least correctly data bound or not.</p>
<p>This simple technique can help in any situation where the faulty data binding is not already rendered in a text-based UI control. For example, we might need to debug a data bound value because a particular visual effect that is created with a <kbd>DataTrigger</kbd> instance is not working and we need to determine whether the problem is related to the UI control or the data binding path.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catching changing Dependency Property values</h1>
                </header>
            
            <article>
                
<p>As we saw at the beginning of this chapter, the WPF Framework won't call the CLR property wrappers of our Dependency Properties when the property values are changing. However, there is a way to accomplish this using callback handlers. In fact, we've already seen an example of this when we were looking at the creation of the <kbd>OnEnterKeyDown</kbd> Attached Property. Let's remind ourselves what that looked like:</p>
<pre>public static DependencyProperty OnEnterKeyDownProperty =  
  DependencyProperty.RegisterAttached("OnEnterKeyDown", <br/>  typeof(ICommand), typeof(TextBoxProperties), <br/>  new PropertyMetadata(OnOnEnterKeyDownChanged)); <br/><br/>...
<br/>public static void OnOnEnterKeyDownChanged(<br/>  DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e)
{ 
  TextBox textBox = (TextBox)dependencyObject; 
  if (e.OldValue == null &amp;&amp; e.NewValue != null)  
    textBox.PreviewKeyDown += TextBox_OnEnterKeyDown; 
  else if (e.OldValue != null &amp;&amp; e.NewValue == null)  
    textBox.PreviewKeyDown -= TextBox_OnEnterKeyDown; 
} </pre>
<p>For this Attached Property, we used a particular overload of the <kbd>DependencyProperty.RegisterAttached</kbd> method that accepts a <kbd>PropertyMetadata</kbd> object, which enabled us to assign a <kbd>PropertyChangedCallback</kbd> handler to the property. Note that there is an identical overload for the <kbd>DependencyProperty.Register</kbd> method for declaring Dependency Properties.</p>
<p>Program execution will enter these <kbd>PropertyChangedCallback</kbd> handlers each time their related Dependency Property changes, so that makes them perfect for debugging their values. While we don't often need to attach these handlers, it only takes a moment to add one when we need to and they enable us to find out what's going on with the Dependency Property values at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploiting converters</h1>
                </header>
            
            <article>
                
<p>If we're having a problem with a data binding that uses an <kbd>IValueConverter</kbd> to convert the data bound value from one type to another, then we can place a breakpoint into the <kbd>Convert</kbd> method of the converter. As long as we have correctly set up the converter, we can be sure that the breakpoint will be hit when the binding is evaluated at runtime. If it doesn't get hit, that will mean that we have not set it up correctly.</p>
<p>However, even when we are not already using a converter on a binding that is not displaying the value that we are expecting, we can still add one just for this purpose. We can either add an existing converter to the binding, if we have one of the relevant type, or we can create a simple converter specifically for the purpose of debugging and use that instead. Let's take a look at how we might do this:</p>
<pre>[ValueConversion(typeof(object), typeof(object))] 
public class DebugConverter : IValueConverter 
{ 
  public object Convert(object value, Type targetType, object parameter,<br/>    CultureInfo culture) 
  { 
    if (Debugger.IsAttached) Debugger.Break(); 
    return value; 
  } 
 
  public object ConvertBack(object value, Type targetType, <br/>    object parameter, CultureInfo culture) 
  { 
    if (Debugger.IsAttached) Debugger.Break(); 
    return value; 
  } 
}</pre>
<p>As you can see from the preceding code snippet, it's a very simple implementation of the <kbd>IValueConverter</kbd> interface. We start by specifying that we are converting from <kbd>object</kbd> to <kbd>object</kbd> in the <kbd>ValueConversion</kbd> attribute, thereby outlining that we are not actually converting any data bound values in this converter. The rest of the class represents a typical converter class, but without any conversion code.</p>
<p>The only real point of interest here are the two calls to the <kbd>Debugger.Break</kbd> method from the <kbd>System.Diagnostics</kbd> assembly. When the program execution reaches either of these method calls, it will automatically break, just as if there were breakpoints set on these lines. Therefore, when using this converter, we don't even need to set breakpoints; we can just plug it into the binding, run the program, and investigate the value of the <kbd>value</kbd> input parameter.</p>
<p>It can be attached like any other converter:</p>
<pre>xmlns:Converters="clr-namespace:CompanyName.ApplicationName.Converters; 
  assembly=CompanyName.ApplicationName.Converters" 
... 
&lt;UserControl.Resources&gt; 
  &lt;Converters:DebugConverter x:Key="Debug" /&gt; 
&lt;/UserControl.Resources&gt; 
... 
&lt;ListBox ItemsSource="{Binding Items, Converter={StaticResource Debug}}" /&gt;</pre>
<p>However, this method can be unsafe to use in a production environment and the converter should be removed when debugging is finished. If it is left connected in release code, an Exception will be thrown at runtime, complaining that Windows has encountered a user-defined breakpoint. Although I wouldn't recommend leaving a converter that is just used for debugging data bound values connected in a production environment, we can make a slight alteration to it to completely eliminate the danger of this occurring:</p>
<pre class="mce-root">[ValueConversion(typeof(object), typeof(object))] 
public class DebugConverter : IValueConverter 
{ 
  public object Convert(object value, Type targetType, object parameter,<br/>    CultureInfo culture)
  {
    Break(value); 
    return value; 
  } 

  public object ConvertBack(object value, Type targetType, <br/>    object parameter, CultureInfo culture) 
  { 
    Break(value); 
    return value; 
  } <br/><br/>  [Conditional("DEBUG")]<br/>  private void Break(object value)<br/>  {<br/>    Debugger.Break();<br/>  }<br/>} </pre>
<p><span>Now, the</span> <kbd>Debugger.Break</kbd> <span>method and the data bound value have been moved into a separate</span> <kbd>Break</kbd> <span>method, where the value of the <kbd>value</kbd> input parameter can be inspected. Note the use of the <kbd>ConditionalAttribute</kbd> attribute on this new method. It</span> <span>provides a way to include or exclude methods that it has been set on, depending on the current solution configuration. If the configuration is set to debug, this method can be called, but otherwise, all calls to it are removed from the compiled code. In this way, we can be assured that we will not run into problems with our release code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've investigated the best ways to track down our coding problems. We've looked at the various debug tracing outputs that we have access to and even discovered how to output our own custom trace information. We discovered that the exceptions that are thrown in WPF often hide their useful information in their <kbd>InnerException</kbd> properties. Finally, we found out a number of tips and tricks to use when trying to find errors with our data bound values.</p>
<p>The next chapter delves deeply into the subject of application frameworks and we get started on constructing our own. We find out about the benefit of base classes and discover alternative ways to implement our framework functionality. The chapter will finish off by investigating a variety of techniques to ensure that our applications maintain the essential Separation of Concerns that MVVM provides.</p>


            </article>

            
        </section>
    </body></html>