- en: Chapter 12. Editor Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An editor extension to add 100 randomly located copies of a prefab with one
    menu click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A progress bar to display proportion completed of Editor extension processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object location in scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect of game development in general (and inventories as our particular
    examples in this chapter) is the distinction about *when* we undertake an activity.
    **Run-time** is when the game is running (and when all our software and UI choices
    take affect). However, **design-time** is the time when different members of our
    game design team work on constructing a wide range of game components, including
    the scripts, audio and visual assets, and the process of constructing each game
    level (or "scene" in Unity-speak).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce several recipes that make use of Unity's
    Editor extensions; these are scripting and multimedia components that enable a
    game software engineer to make design-time work easier and less likely to introduce
    errors. Editor extensions allow workflow improvements, thus allowing designers
    to achieve their goals quicker and more easily; for example, removing the need
    for any scripting knowledge when generating many randomly located inventory pickups
    in a scene via a menu choice, or editing the type or properties of pickups being
    hand-placed in different locations in a level.
  prefs: []
  type: TYPE_NORMAL
- en: While Editor extensions are quite an advanced topic, having someone on your
    team who can write custom editor components, such as those we illustrate, can
    greatly increase the productivity of a small team with only one or two members
    who are confident at scripting.
  prefs: []
  type: TYPE_NORMAL
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of **enums** and corresponding drop-down menus in the Inspector panel
    to restrict changes to one of a limited set often works fine (for example, pickup
    types for a pickup object). However, the trouble with this approach is, when two
    or more properties are related and need to be changed together, there is a danger
    of changing one property, for example, pickup type from **Heart** to **Key**,
    but forgetting to change corresponding properties; for example, leaving the **Sprite
    Renderer** component still showing a **Heart sprite**. Such mismatches cause problems
    both in terms of messing up intended level design and, of course, the frustration
    for the player when they collide with something showing one pickup image, but
    a different kind of pickup type is added to the inventory!
  prefs: []
  type: TYPE_NORMAL
- en: If a class of GameObject has several related properties or components, which
    all need to be changed together, then a good strategy is to use Unity Editor extensions
    to do all the associated changes each time a different choice is made from a drop-down
    menu showing the defined set of enumerated choices.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we introduce an Editor extension for PickUp components of GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: '![An editor extension to allow pickup type (and parameters) to be changed at
    design time via a custom Inspector UI](img/1362OT_12_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with project `Simple2Dgame_SpaceGirl` setup
    from the first recipe in [Chapter 2](ch02.html "Chapter 2. Inventory GUIs"), *Inventory
    GUIs*. A copy of this Unity project is provided in a folder named `unityProject_spaceGirlMiniGame`
    in the `1362_12_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an editor extension to allow pickup type (and parameters) to be changed
    at design-time via a custom Inspector UI, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Project** panel, create a new folder named `EditorSprites`. Move the
    following images from folder `Sprites` into this new folder: `star`, `healthheart`,
    `icon_key_green_100`, `icon_key_green_32`, `icon_star_32`, and `icon_heart_32`.![How
    to do it...](img/1362OT_12_55.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, rename GameObject `star` to be named `pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the tags, changing tag **Star** to **Pickup**. Ensure the `pickup` GameObject
    now has the tag **Pickup**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script `PickUp` to GameObject `pickup` in the **Hierarchy**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Project** panel, create a new folder named `Editor`. Inside this new
    folder, create a new C# script class named `PickUpEditor`, with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **Inspector** panel, select GameObject `pickup` and choose different
    values of the drop-down menu **PickUp Type**. You should see corresponding changes
    in the image and icons in the **Inspector** for the **Pick Up (Script)** component
    (three icons with the name of the type in between). The **Sprite** property of
    the **Sprite Renderer** component for this GameObject should change. Also, in
    the **Scene** panel, you'll see the image in the scene change to the appropriate
    image for the pickup type you have chosen.![How to do it...](img/1362OT_12_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our script class `PickUp` has the enum `PickUpType` with the three values:
    `Star`, `Health`, and `Key`. Also, there is the variable `type`, storing the type
    of the parent GameObject. Finally, there is a `SetSprite(…)` method that sets
    the **Sprite Renderer** component of the parent GameObject to be set to the provided
    `Sprite` parameter. It is this method that is called from the editor script each
    time the pickup type is changed from the drop-down menu (with the corresponding
    sprite for the new type being passed).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vast majority of the work for this recipe is the responsibility of the
    script class `PickUpEditor`. While there is a lot in this script, its work is
    relatively straightforward: for each frame, via method `OnInspectorGUI()`, a dropdown
    list of `PickUpType` values is presented to the user. Based on the value selected
    from this drop-down list, one of three methods is executed: `InspectorGUI_HEALTH()`,
    `InspectorGUI_KEY()`, `InspectorGUI_STAR()`. Each of these methods displays three
    icons and the name of the type in the Inspector beneath the drop-down menu and
    ends by calling the `SetSprite(…)` method of the GameObject being edited in the
    Inspector to update the **Sprite Renderer** component of the parent GameObject
    with the appropriate sprite.'
  prefs: []
  type: TYPE_NORMAL
- en: The C# attribute `[CustomEditor(typeof(PickUp))]` appearing before our class
    is declared, tells Unity to use this special editor script to display component
    properties in the **Inspector** panel for **Pick Up (Script)** components of GameObjects,
    rather than Unity's default **Inspector** which displays public variables of such
    scripted components.
  prefs: []
  type: TYPE_NORMAL
- en: Before and after its main work, the `OnInspectorGUI()` method first ensures
    that any variables relating to the object being edited in the Inspector have been
    updated —`serializedObject.Update()`. The last statement of this method correspondingly
    ensures that any changes to variables in the editor script have been copied back
    to the GameObject being edited—`serializedObject.ApplyModifiedProperties()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnEnable()` method of script class `PickUpEditor` loads the three small
    icons (for display in the **Inspector**) and the three larger sprite images (to
    update the **Sprite Renderer** for display in the **Scene/Game** panels). The
    `pickupObject` variable is set to be a reference to the `PickUp` scripted component,
    allowing us to call the `SetSprite(…)` method. The `pickUpType` variable is set
    to be linked to the type variable of the `PickUp` scripted component whose special
    **Inspector** editor view makes this script possible—`serializedObject.FindProperty
    ("type")`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Offer the custom editing of pickup parameters via Inspector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many pickups have additional properties, rather than simply being an item being
    carried. For example, a health pickup may add health "points" to the player's
    character, a coin pickup may add money "points" to the characters bank balance,
    and so on. So, let's add an integer `points` variable to our `PickUp` class and
    offer the user the ability to easily edit this points value via a GUI slider in
    our customer Inspector editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Offer the custom editing of pickup parameters via Inspector](img/1362OT_12_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To add an editable points property to our `PickUp` objects, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extra line into C# script `PickUp` to create our new integer
    `points` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer `points` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following extra line into the `OnEnable()` method in C# script `PickUpEditor`
    to associate our new `points` variable with its corresponding value in the `PickUp`
    scripted component of the GameObject being edited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can add an extra line into each GUI method for the different PickUp
    types. For example, we can add a statement to display an **IntSlider** to the
    user to be able to see and modify the points value for a **Health PickUp** object.
    We add a new statement at the end of the `InspectorGUI_HEALTH()`method in C# script
    `PickUpEditor` to display a modifiable **IntSlider** representing our new `points`
    variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We provide four parameters to the `IntSlider(…)` method. The first is the text
    label the user will see next to the slider. The second is the initial value the
    slider displays. The last two are the maximum and minimum values. In our example,
    we are permitting values from 0 to 100, but if health pickups only offer one,
    two, or three health points, then we'd just call with `EditorGUILayout.IntSlider
    ("Health points", points.intValue, 1, 5)`. This method returns a new integer value
    based on where the slider has been positioned, and this new value is stored back
    into the integer value part of our `SerializedProperty` variable points.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the loading and saving of values from the scripted component in the
    GameObject and our editor script is all part of the work undertaken by our calls
    to the `Update()` method and the `ApplyModifiedProperties()` method on the serialized
    object in the `OnInspectorGUI()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that since points may not have any meaning for some pickups, for example,
    keys, then we simply would not display any slider for the GUI Inspector editor
    when the user is editing **PickUp** objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Offer a drop-down list of tags for key-pickup to fit via Inspector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the concept of "points" may have no meaning for a key pickup, the concept
    of the type of lock that a given key fits is certainly something we may wish to
    implement in a game. Since Unity offers us a defined (and editable) list of string
    tags for any GameObject, often it is sufficient, and straightforward, to represent
    the type of lock or door corresponding to a key via its tag. For example, a green
    key might fit all objects tagged **LockGreen** and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Offer a drop-down list of tags for key-pickup to fit via Inspector](img/1362OT_12_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, it is very useful to be able to offer a custom Inspector editor for
    a string property of key pickups that stores the tag of the lock(s) the key can
    open. This task combines several actions, including using C# to retrieve an array
    of tags from the Unity editor, then the building and offering of a drop-down list
    of these tags to the user, with the current value already selected in this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a selectable list of strings for the tag for lock(s) that a key fits,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extra line into C# Script `PickUp` to create our new integer
    `fitsLockTag` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer `fitsLockTag` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following extra line into the `OnEnable()`method in C# script `PickUpEditor`
    to associate our new `fitsLockTag` variable with its corresponding value in the
    PickUp scripted component of the GameObject being edited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to add some extra lines of code into the GUI method for key PickUps.
    We need to add several statements to the end of method `InspectorGUI_KEY()` in
    C# script `PickUpEditor` to set up and display a selectable popup drop-down list
    representing our new `fitsLockTag` variable as follows. Replace the `InspectorGUI_KEY()`
    method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've added several statements to the end of this method. First `tags`, an array
    of strings, is created (and sorted), containing the list of tags currently available
    in the Unity editor for the current game. We then attempt to find the location
    in this array of the current value of `fitsLockTag` — we can use the `BinarySearch(…)`
    method of built-in script class `Array` because we have alphabetically sorted
    our array (which also makes it easier for the user to navigate). If the string
    in `fitsLockTag` cannot be found in array `tags`, then the first item will be
    selected by default (index 0).
  prefs: []
  type: TYPE_NORMAL
- en: The user is then shown the drop-down list via the `GUILayout` method `EditorGUILayout.Popup(…)`,
    and this method returns the index of whichever item is selected. The selected
    index is stored into `selectedTagIndex`, and the last statement in the method
    extracts the corresponding string and stores that string into the `fitsLockTag`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Rather than displaying all possible tags, a further refinement might
    remove all items from array ''tags'' that do not have the prefix ''Lock''. So
    the user is only presented with tags such as ''LockBlue'' and ''LockGreen'', and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Logic to open doors with keys based on fitsLockTag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our player collision logic, we can now search through our inventory to see
    if any key items fit the lock we have collided with. For example, if a green door
    was collided with, and the player was carrying a key that could open such doors,
    then that item should be removed from the inventory `List<>` and the door should
    be opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, you would need to add an `if` test inside the `OnTriggerEnter()`
    method to detected collision with the item tagged `Door`, and then logic to attempt
    to open the door, and, if unsuccessful, do the appropriate action (for example,
    play sound) to inform the player they cannot open the door yet (we''ll assume
    we have written a door animation controller that plays the appropriate animation
    and sounds and when a door is to be opened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OpenDoor()` method would need to identify which item (if any) in the inventory
    can open such a door, and, if found, then that item should be removed from the
    `List<>` and the door should be opened by the appropriate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for a method to find the inventory list key item
    fitting a door tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The need to add [SerializeField] for private properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if we wished to create editor extensions to work with private variables,
    then we'd need to explicitly add `[SerializeField]` in the line immediately before
    the variable to be changed by the editor script. Public variables are serialized
    by default in Unity, so this was not required for our public `type` variable in
    script class `PickUp`, although it's good practice to flag ALL variables that
    are changeable via an Editor Extension in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more from the Unity documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity provides documentation pages about editor scripts at [http://docs.unity3d.com/ScriptReference/Editor.html](http://docs.unity3d.com/ScriptReference/Editor.html).
  prefs: []
  type: TYPE_NORMAL
- en: An editor extension to add 100 randomly located copies of a prefab with one
    menu click
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we want to create "lots" of pickups, randomly in our scene. Rather
    than doing this by hand, it is possible to add a custom menu and item to the Unity
    editor, which, when selected, will execute a script. In this recipe, we create
    a menu item that calls a script to create 100 randomly positioned star pickup
    prefabs in the Scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![An editor extension to add 100 randomly located copies of a prefab with one
    menu click](img/1362OT_12_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an editor extension to add 100 randomly located copies of a prefab
    with one menu click, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, create a new folder named `Prefabs`. Inside this new
    folder, create a new empty prefab named `prefab`_`star`. Populate this prefab
    by dragging GameObject `star` from the **Hierarchy** panel over `prefab`_`star`
    in the **Project** panel. The prefab should now turn blue and have a copy of all
    of GameObject star's properties and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete GameObject `star` from the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Project** panel, create a new folder named `Editor`. Inside this new
    folder, create a new C# script class named `MyGreatGameEditor`, with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After 20 to 30 seconds, depending on the speed of your computer, you should
    now see a new menu appear, **My Great Game**, with a single menu item, **Make
    100 stars**. Chose this menu item and, as if by magic, you should now see 100
    new **prefab_star(Clone)** GameObjects appear in the scene!![How to do it...](img/1362OT_12_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core aim of this recipe is to add a new menu, containing a single menu item
    that will execute the action we desire. C# attribute `[MenuItem("<menuName>/<menuItemName>")]`
    declares the menu name and the menu item name, and Unity will execute the static
    method that follows in the code listing, each time the menu item is selected by
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the `[MenuItem("My-Great-Game/Make 100 stars")]` statement declares
    the menu name as `My-Great-Game` and the menu item as `Make 100 stars`. The method
    immediately following this attribute is the `PlacePrefabs()` method. When this
    method is executed, it makes the `starPrefab` variable become a reference to the
    prefab found via the `Assets/Prefabs/prefab_star.prefab` path. Then, a `for` loop
    is executed 100 times, each time calling the `CreateRandomInstance()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateRandomInstance()` method creates a Vector3 `randomPosition` variable,
    making use of `X_MAX` and `Y_MAX` constants. The `Instantiate(...)` built-in method
    is then used to create a new GameObject in the scene, making a clone of the prefab
    and locating it at the position defined by `randomPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some details you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Child each new GameObject to a single parent, to avoid filling up the Hierarchy
    with 100s of new objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than having hundreds of new object clones fill up our **Hierarchy** panel,
    a good way to keep things tidy is to have an empty "parent" GameObject and child
    a collection of related GameObjects to it. Let's have a GameObject in the **Hierarchy**
    named **Star-container** and child all the new stars to this object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Child each new GameObject to a single parent, to avoid filling up the Hierarchy
    with 100s of new objects](img/1362OT_12_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need a variable that will be a reference to our container object, `starContainerGO`.
    We also need a new method, `CreateStarContainerGO()`, which will find a reference
    to GameObject **star-container**, if such an object already exists it is deleted,
    and then the method will create a new empty GameObject and give it this name.
    Add the following variable and method to our script class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create the prefab clones, we need to first ensure we have created
    our star container GameObject. So we need to call our new method as the first
    thing we do when the `PlacePrefabs()` method is executed, so add a statement to
    call this method at the beginning of the `PlacePrefabs()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to modify the `CreateRandomInstance()` method so that it gets a
    reference to the new GameObject it has just created and can then child this new
    object to our **star-container** GameObject variable `starContainerGO`. Modify
    the `CreateRandomInstance()` method so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A progress bar to display proportion completed of Editor extension processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an Editor task is going to take more than half a second or so, then we should
    indicate progress complete/remaining to the user via a progress bar so that they
    understand that something is actually happening and the application has not crashed
    and frozen.
  prefs: []
  type: TYPE_NORMAL
- en: '![A progress bar to display proportion completed of Editor extension processing](img/1362OT_12_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a progress bar during the loop (and then remove it after the loop is
    complete), replace the `PlacePrefabs()` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As can be seen, inside the `for` loop, we call the `EditorUtility.DisplayProgressBar(...)`
    method, passing three parameters. The first is a string title for the progress
    bar dialog window, the second is a string to show below the bar itself (usually
    a percentage is sufficient), and the final parameter is a value between 0.0 and
    1.0, indicating the percentage complete to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have loop variable `i` that is a number from 1 to 100, we can display
    this integer followed by a percentage sign for our second parameter and just divide
    this number by 100 to get the decimal value needed to specify how much of the
    progress bar should be shown as completed. If the loop were running for some other
    number, we'd just divide the loop counter by the loop total to get our decimal
    progress value. Finally, after the loop has finished, we remove the progress bar
    with statement `EditorUtility.ClearProgressBar()`.
  prefs: []
  type: TYPE_NORMAL
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object location in scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a level designer wishes to place each pickup carefully "by hand", we can
    still make this easier than having to drag copies of prefabs manually from the
    **Projects** panel. In this recipe, we provide a "cross-hairs" GameObject, with
    buttons in the Inspector allowing the game designer to create instances of three
    different kinds of prefab at precise locations by clicking the appropriate button
    when the center of the cross-hairs is at the desired location.
  prefs: []
  type: TYPE_NORMAL
- en: A Unity Editor extension is at the heart of this recipe and illustrates how
    such extensions can allow less technical members of a game development team to
    take an active role in level creation within the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![An editor extension to have an object-creator GameObject, with buttons to
    instantiate different pickups at cross-hair object location in scene](img/1362OT_12_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in [Chapter 2](ch02.html "Chapter 2. Inventory GUIs"),
    *Inventory GUIs*.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the cross-hairs image you need in a folder
    named `Sprites` in the `1362_12_04` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an object-creator GameObject, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, rename GameObject `star` as `pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, create a new folder named `Prefabs`. Inside this new
    folder, create three new empty prefabs named `star, heart`, and `key`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the `star` prefab by dragging GameObject `pickup` from the **Hierarchy**
    panel over `star` in the **Project** panel. The prefab should now turn blue and
    have a copy of all of the star GameObject's properties and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new tag `Heart` in the Inspector. Select GameObject `pickup` in the **Hierarchy**
    panel and assign it the tag `Heart`. Also, drag from the **Project** panel (folder
    `Sprites`) the **healthheart** image into the Sprite property of GameObject `pickup`
    so that the player sees the heart image on screen for this pickup item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the `heart` prefab by dragging GameObject `pickup` from the **Hierarchy**
    panel over `heart` in the `Prefabs` folder in the **Project** panel. The prefab
    should now turn blue and have a copy of all of the pickup GameObject's properties
    and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new tag `Key` in the Inspector. Select GameObject's `pickup` in the **Hierarchy**
    panel and assign it this tag `Key`. Also, drag from the **Project** panel (folder
    `Sprites`) image **icon_key_green_100** into the Sprite property of GameObject's
    `pickup` so that the player sees the key image on screen for this pickup item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the `key` prefab by dragging GameObject `pickup` from the **Hierarchy**
    panel over `key` in the `Prefabs` folder in the **Project** panel. The prefab
    should now turn blue and have a copy of all of the pickup GameObject's properties
    and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete GameObject's `pickup` from the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Project** panel, create a new folder named `Editor`. Inside this new
    folder, create a new C# script class named `ObjectBuilderEditor`, with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our Editor script is expecting to find the three icons in a folder named `EditorSprites`,
    so let's do this. First create a new folder named `EditorSprites`. Next drag the
    three 32 x 32 pixel icons from the `Sprites` folder into this new `EditorSprites`
    folder. Our Editor script should now be able to load these icons for image-based
    buttons that it will be drawing in the Inspector, from which the user chooses
    which pickup prefab object to clone into the scene.![How to do it...](img/1362OT_12_56.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** panel, drag sprite **cross_hairs.fw** into the **Scene**.
    Rename this gameObject `object-creator-cross-hairs,` and in its **Sprite Renderer**
    component in the **Inspector,** set **Sorting Layer** to **Foreground**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the following C# script to GameObject `object-creator-cross-hairs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the **Rect Tool** (shortcut key *T*), and as you drag gameObject `object-creator-cross-hairs`
    and click on the desired icon in the **Inspector**, new pickup GameObjects will
    be added to the scene's **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script class `ObjectBuilderScript` has just two methods, one of which has
    just one statement—the `Awake()` method simply makes this GameObject become inactive
    when the game is running (since we don't want the user to see our cross-hairs
    created tool during gameplay). The `AddObjectToScene(…)` method receives a reference
    to a prefab as a parameter and instantiates a new clone of the prefab in the scene
    at the location of GameObject `object-creator-cross-hairs` at that point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Script class `ObjectBuilderEditor` has a C# attribute `[CustomEditor(typeof(ObjectBuilderScript))]`
    immediately before the class is declared, telling Unity to use this class to control
    how `ObjectBuilderScript` GameObject properties and components are shown to the
    user in the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: There are six variables, three textures for the icons to form the buttons in
    the Inspector, and three GameObject references to the prefabs of which instances
    will be created. The `OnEnable()` method assigns values to these six variables
    using the built-in method `Resources.LoadAssetAtPath()`, retrieving the icons
    from the **Project** folder `EditorSprites` and getting references to the prefabs
    in the **Project** folder `Prefabs`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnInspectorGUI()` method has a variable `myScript`, which is set to be
    a reference to the instance of scripted component `ObjectBuilderScript` in GameObject
    `object-creator-cross-hairs` (so we can call its method when a prefab has been
    chosen). The method then displays a mixture of empty text `Labels` (to get some
    vertical spacing) and `FlexibleSpace` (to get some horizontal spacing and centering)
    and displays three buttons to the user, with icons of star, heart, and key. The
    scripted GUI technique for Unity custom **Inspector** GUIs wraps an `if` statement
    around each button, and on the frame the user clicks the button, the statement
    block of the `if` statement will be executed. When any of the three buttons is
    clicked, a call is made to `AddObjectToScene(…)` of scripted component `ObjectBuilderScript`,
    passing the prefab corresponding to the button that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced recipes demonstrating some Unity Editor extension
    scripts, illustrating how we can make things easier, less script based, and less
    prone to errors, by limiting and controlling the properties of objects and how
    they are selected or changed via the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of serialization was raised in the Editor extension recipes, whereby
    we need to remember that when we are editing item properties in the Inspector,
    each change needs to be saved to disk so that the updated property is correct
    when we next use or edit that item. This is achieved in the `OnInspectorGUI()`
    method by first calling the `serializedObject.Update()` method, and after all
    changes have been made in the Inspector, finally calling the `serializedObject.ApplyModifiedProperties()`
    method. Some sources for more information and examples about custom Editor extensions
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: For more about custom Unity Editors in Ryan Meier's blog, refer to [http://www.ryan-meier.com/blog/?p=72](http://www.ryan-meier.com/blog/?p=72)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more custom Unity Editor scripts/tutorials, including grids and color pickers,
    refer to [http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047](http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
