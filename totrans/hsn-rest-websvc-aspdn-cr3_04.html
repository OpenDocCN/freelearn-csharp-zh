<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Overview of ASP.NET Core</h1>
                </header>
            
            <article>
                
<p> In this chapter, we will explore some of the fundamental concepts of ASP.NET Core. <span>.NET Core is cross-platform</span><span>, but the IDEs and code editors that are used with it might vary depending on which OS they run on.</span> To avoid repetition and cover all OS variants, I always use the CLI in the examples presented in this book. Furthermore, the <kbd>dotnet</kbd> instruction is the unique entry point and is also used, under the hood, by code editors and IDEs.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Setting up a .NET Core 3.1 and ASP.NET Core project</li>
<li>The file structure of a .NET Core project template</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up our .NET Core project</h1>
                </header>
            
            <article>
                
<p><span>This chapter assumes that you have already installed .NET Core version 3.1 or higher on your machine. </span>First of all, let's start by launching the following command in our console:</p>
<pre><strong>dotnet new</strong></pre>
<p>The output will appear as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/26466f6e-c8ea-4210-8234-3187b3ea8d71.png"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">The result of the <em>dotnet new</em> instruction</div>
<p>The preceding output shows all the .NET Core project templates available on the local machine. Each of these has a user-friendly name, a short name, and tags. They are available in <span class="packt_screen">C#, </span> <span class="packt_screen">F# <strong>and</strong> VB</span>; the default is <span class="packt_screen">C#</span>.</p>
<p>To create a new template, we'll use the short name. For example, in order to create a console application, we should run the following instruction:</p>
<pre><strong>dotnet new console -n HelloWorld</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding instruction will create a new project in the current folder, with the following tree structure:</p>
<pre>.<br/>├── HelloWorld.csproj<br/>├── Program.cs<br/>└── obj<br/>    ├── ...</pre>
<p>The <kbd>HelloWorld.csproj</kbd> file contains all the meta-information about the project. <span>The .NET Core version of the <kbd>.csproj</kbd> file is more lightweight compared to the</span> <kbd>.csproj</kbd> file in<span> previous versions of the .NET Framework. W</span>e'll discuss the new structure of this project file next in this chapter. The <kbd>Program.cs</kbd> file is the entry point of the application. </p>
<p>To build and execute our project, we can run the following commands inside the project folder:</p>
<pre><strong>dotnet build</strong><br/><strong>dotnet run</strong></pre>
<p>As expected, we obtain the following result:</p>
<pre>Hello World!</pre>
<p>Unlike old .NET Framework projects, the build and run steps are <span>lightweight</span> processes, and they don't require any additional tools or configurations. In fact, .NET Core is not strictly chained to the development machine like the .NET Framework. Eventually, developers can write code without any other IDEs or code editors. However, for obvious reasons, it is always recommended that you use them to simplify the development process.</p>
<p>It is also essential to note that, once we execute the <kbd>dotnet build</kbd> command, the project files will change in the following way:</p>
<pre>.<br/>├── HelloWorld.csproj<br/>├── Program.cs<br/>├── bin<br/>│   └── Debug<br/>│       └── netcoreapp3.1<br/>│           ├── ...<br/>└── obj<br/>├── Debug<br/>│   └── netcoreapp3.1<br/>│       ├── ...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>The </span><kbd>bin/Debug/</kbd><span> folder contains all the app's DLLs. Below that, we can see the </span><kbd>netcoreapp3.1</kbd><span> folder, which refers to the current target framework. </span>Therefore, if you build your project using a multi-target approach, you will find a folder for each target framework you specified. Now that we are able to run a simple console app, let's have a closer look at the <em>csproj</em> present in the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of .csproj</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, in a plain console application template, there are two essential files: <kbd>ProjectName.csproj</kbd> and <kbd>Program.cs</kbd>. First of all, let's have a look at the <kbd>.csproj</kbd> file:</p>
<div>
<pre><span>&lt;</span><span>Project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;<br/></span><span>    &lt;</span><span>PropertyGroup</span><span>&gt;<br/></span><span>        &lt;</span><span>OutputType</span><span>&gt;</span><span>Exe</span><span>&lt;/</span><span>OutputType</span><span>&gt;<br/></span><span>        &lt;</span><span>TargetFramework</span><span>&gt;</span><span>netcoreapp3.0</span><span>&lt;/</span><span>TargetFramework</span><span>&gt;<br/></span><span>    &lt;/</span><span>PropertyGroup&gt;<br/></span><span>&lt;/</span><span>Project</span><span>&gt;<br/></span></pre>
<p>The format of the <kbd>.csproj</kbd> file is XML, just like earlier versions of the .NET Framework. The</p>
<p><kbd>Sdk="Microsoft.NET.Sdk"</kbd> namespace refers to the SDK we want to use to build our project. The <kbd>PropertyGroup</kbd> node contains a set of properties, and it can be associated with some conditional behaviors. <kbd>ItemGroup</kbd> is a node that usually contains package references. In .NET Core, it is possible to specify the <kbd>TargetFramework</kbd> property to assign a target framework to our project. To set up our application as a <em>multi-target application,</em> therefore, we can change our <kbd>TargetFramework</kbd> node as follows:</p>
<pre><span>&lt;</span><span>Project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;<br/></span><span>    &lt;</span><span>PropertyGroup</span><span>&gt;<br/></span><span>        &lt;</span><span>OutputType</span><span>&gt;</span><span>Exe</span><span>&lt;/</span><span>OutputType</span><span>&gt;<br/></span><strong><span>        </span></strong><strong><span>&lt;</span><span>TargetFrameworks</span><span>&gt;</span><span>netcoreapp3.1;netstandard2.0</span><span>&lt;/</span><span>TargetFrameworks</span></strong><span><strong>&gt;</strong></span><span><br/></span><span>    &lt;/</span><span>PropertyGroup&gt;<br/></span><span>&lt;/</span><span>Project</span><span>&gt;</span></pre>
<p>Note that the XML node has changed from <kbd>TargetFramework</kbd> to <kbd>TargetFrameworks</kbd>, furthermore our project will be built on both .NET Core 3.1 and .NET Standard 2.0.</p>
<p>According to the MSBuild documentation ( <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2019</a>), it is possible to define different packages for each target framework. For example, in a <span><span>double</span></span> target framework project such as the previous one, we may define various dependencies for each target, as follows:</p>
<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/><br/>  &lt;PropertyGroup&gt;<br/>    &lt;OutputType&gt;Exe&lt;/OutputType&gt;<br/>    &lt;TargetFrameworks&gt;netcoreapp3.1;netstandard2.0&lt;/TargetFrameworks&gt;<br/>  &lt;/PropertyGroup&gt; <br/> ...<br/><br/>  &lt;ItemGroup <strong>Condition=" '$(TargetFramework)' == 'netstandard2.0' "</strong>&gt;<br/>    &lt;PackageReference Include="Microsoft.AspNetCore.Server.Kestrel.Core" Version="2.2.0" /&gt;<br/>  &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;</pre>
<p>In this case, we'll have separate references for each target: at compile-time, the framework generates two target versions, the <kbd>netstandard2.0</kbd> generated output will refer the <kbd>Microsoft.AspNetCore.Server.Kestrel.Core</kbd> package. This is an unusual type of configuration, but it comes in handy if we have a high level of customization in our project or if your project is a library consumed by different versions of .NET. The <kbd>dotnet new</kbd> command also sets a specific <kbd>OutputType</kbd> property depending on the type of project you are creating: the <kbd>OutputType</kbd> property defines whether the project is executable (<kbd>Exe</kbd>) or a library (<kbd>Library</kbd>). The significant difference is that in the first case it can be executed, whereas in the latter it does not contain any entry points from which to run the application. Therefore, we will not be able to execute the <kbd>dotnet run</kbd> command on a <kbd>&lt;OutputType&gt;Library&lt;/OutputType&gt;</kbd> project type, on the other side, we do need to specify <kbd>static void Main</kbd> entry point method in case of a <span><kbd>&lt;OutputType&gt;Exe&lt;/OutputType&gt;</kbd> project</span> . Let's continue by discussing a bit the domain of the executable projects by walking through the <em>Program.cs</em> file of a standard console template.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program.cs file in detail</h1>
                </header>
            
            <article>
                
<p>The <kbd>Program.cs</kbd> file is the main entry point of the application. It <span>sets up </span><span>and </span><span>runs all the components we need. By default, the console application template executes a single statement:</span></p>
<div>
<pre><span>using</span><span> </span><span>System</span><span>;<br/><br/></span><span>namespace</span><span> </span><span>HelloWorld <br/></span><span>{<br/></span><span>    class</span><span> </span><span>Program<br/></span><span>    {<br/></span><span>        static </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[] args)<br/></span><span>        {<br/></span><strong><span>            Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Hello World!"</span></strong><span><strong>);</strong><br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre></div>
<p><span>The preceding snippet is a plain .NET Core application that runs <kbd>Console.WriteLine</kbd> to print a message in the console. In an ASP.NET Core application, the <kbd>Program.cs</kbd> file is usually utilized to initialize and run the web host.</span></p>
<p>C# version 7.1 introduced the <kbd>async void Main</kbd> method. This feature is implemented to avoid workarounds involved in running asynchronous code:</p>
<div>
<pre><span>using</span><span> </span><span>System</span><span>;<br/></span><span>using</span><span> </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;<br/><br/></span><span>namespace</span><span> </span><span>HelloWorld<br/></span><span>{<br/></span><span>    class</span><span> </span><span>Program<br/></span><span>    {<br/></span><span>         </span><span>static</span><span> </span><strong><span>async</span><span> </span><span>Task</span></strong><span> </span><span>Main</span><span>(</span><span>string</span><span>[] args)<br/></span><span>         {<br/>             </span><strong><span>await</span><span> </span><span>Task</span><span>.</span><span>Delay</span><span>(</span><span>10</span></strong><span><strong>);</strong><br/></span><span>             </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Hello World!"</span><span>);<br/></span><span>         }<br/></span><span>     }<br/></span><span>}</span></pre></div>
<p>In summary, the <kbd>Program.cs</kbd> file is the main <span><span>execution root</span></span> for applications built on .NET Core 3.1. It usually runs a set of statements in order to startup our application. In general, we should keep <kbd><span>Program.cs</span></kbd> as clean as possible to boost the reusability of our classes. In the next section, we will see how it is also possible to combine the <kbd>csproj</kbd> structure and the <kbd>Program.cs</kbd> file in order to build a simple API project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up an ASP.NET Core project</h1>
                </header>
            
            <article>
                
<p>As mentioned in <a href="b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml">Chapter 1</a>, <em>REST 101 and Getting Started with ASP.NET Core</em>, the MVC pattern is all about separating concerns. It aims to give developers some guidelines to ensure that the different components of the web application are not mixed up. The following is a refresher on the MVC pattern:</p>
<ul>
<li>The Model<em> </em>seeks to define the domain model of our application. It should also be noted that models don't contain any references to our data sources and databases. They describe the entities in our app.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li>The Views part<em> </em>presents the data in the form of HTML pages. In web services, views are not included because the model is serialized in JSON, HTML, or other similar formats. The critical point is that views should not contain logic. They are hard to test and hard to maintain. Over the past few years, views have become increasingly more powerful. The Razor engine, the default view rendering engine provided by ASP.NET Core, has recently made several new features available. It is easy for developers to implement logic in views, but this should be avoided at all costs.</li>
<li>The <span>Controllers part of MVC handles requests from users. They take information from the request and update the model. In real business applications, controllers are </span><span>usually</span><span> supported by service or repository classes, which add another level to the domain model layer.</span></li>
</ul>
<p>Let's have a detailed look at the default ASP.NET Core web API project template. The project uses the model and controller parts of the MVC pattern to serve a simple HTTP response with the content serialized in JSON.</p>
<p>First of all, let's create a new project using the following commands:</p>
<pre class="p1"><strong><span class="s1">dotnet new webapi -n SampleAPI</span></strong><span class="s1"><br/></span></pre>
<p>The execution of the preceding command creates the following folder structure:</p>
<pre>.<br/>├── Controllers<br/>│ └── WeatherForecastController.cs<br/>├── Program.cs<br/>├── Properties<br/>│ └── launchSettings.json<br/>├── SampleAPI.csproj<br/>├── Startup.cs<br/>├── WeatherForecast.cs<br/>├── appsettings.Development.json<br/>├── appsettings.json<br/>└── obj</pre>
<p>The execution of the <kbd>dotnet new webapi</kbd> command creates a new project file called <kbd><span><span>SampleAPI</span></span></kbd> inside a folder with the same name. The following is the resulting <kbd>SampleAPI.csproj</kbd> generated by the <kbd>dotnet new webapi</kbd> command:</p>
<pre><span>&lt;Project </span><span>Sdk</span><span>="<strong>Microsoft.NET.Sdk.Web</strong>"</span><span>&gt;</span><span><br/></span><span>    &lt;PropertyGroup&gt;<br/></span><strong><span>        &lt;TargetFramework&gt;</span>netcoreapp3.1</strong><span><strong>&lt;/TargetFramework&gt;</strong><br/></span><span>    &lt;/PropertyGroup&gt;</span><span><br/></span><span>&lt;/Project&gt;<br/></span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first thing to note is that this project uses the <kbd>Microsoft.NET.Sdk.Web</kbd> SDK, which refers to the web application SDK. Furthermore, the .NET Core framework provides different SDKs depending on the purpose of the project we are about to create. For example, in the case of a desktop application, the project will specify another SDK: <span><kbd>Microsoft.NET.Sdk.WindowsDesktop</kbd>. Choosing between different SDKs guarantees developers an excellent level of modularity. Secondly, the project file does not specify any particular dependency except the <kbd>netcoreapp</kbd> target framework used by the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The project structure</h1>
                </header>
            
            <article>
                
<p><span>All ASP.NET Core web templates have a similar structure. The main difference lies in the <kbd>views</kbd> folder, which is not present in web API projects. </span></p>
<p>Before proceeding, let's have a more detailed look at the resulting content of the <kbd>SampleAPI</kbd> folder:</p>
<ul>
<li><kbd>Program.cs</kbd> is the main entry point of the application, and it runs the default web server used by APIs.</li>
<li><kbd>Startup.cs</kbd><strong> </strong>defines and configures our application pipeline and services.</li>
<li>The <kbd>Controllers</kbd> folder<strong> </strong>contains all the controllers for our application. According to<span> the default naming convention, ASP.NET Core searches in this folder for the controllers of our app.</span></li>
<li><kbd>Properties/launchSettings.json</kbd> file represents the settings for our project. This file is created when you try to change any of your project's properties, and it usually stores the application URL for our services or apps. Furthermore, if we have a quick look at the content of the file we can notice two different profiles: one with the name of the project created, and another one with the <kbd>IISExpress</kbd> name. Every project can have multiple profiles associated with it. they can be used to specify some of the launch settings, and the environment variables used by the application. Therefore, it is possible to run the application using the <kbd>dotnet run</kbd> command by specifying a profile using the <span><kbd>--launch-profile</kbd> flag;</span></li>
<li><kbd>appsettings.json</kbd> and <kbd>appsettings.{Environment}.json</kbd><em> </em>contains the settings based on our environment. They are replacements for the settings section in the <kbd>web.config</kbd> file. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program.cs and Startup.cs files</h1>
                </header>
            
            <article>
                
<p>Let's continue by examining the <kbd>Program.cs</kbd> file of a web API project:</p>
<pre><span>using System;<br/></span><span>using System.Collections.Generic;<br/></span><span>using System.Linq;<br/></span><span>using System.Threading.Tasks;<br/></span><strong><span>using </span><span>Microsoft</span>.<span>AspNetCore</span>.<span>Hosting</span>;</strong><br/><span>using Microsoft.Extensions.Configuration;<br/></span><strong><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Hosting</span>;</strong><br/><span>using Microsoft.Extensions.Logging;<br/></span><span><br/></span><span>namespace </span><span>SampleAPI<br/></span><span>{</span><br/>    <span>public class </span><span>Program<br/></span><span>    </span>{<br/>        <span>public static void </span><span>Main</span>(<span>string</span>[] args)<br/>        {<br/>            <span>CreateHostBuilder</span>(args).<span>Build</span>().<span>Run</span>();<br/>        }<br/><br/>        <span>public static </span><span>IHostBuilder </span><strong><span>CreateHostBuilder</span></strong>(<span>string</span>[] <br/>        args) =&gt;<br/>            <strong><span>Host</span>.<span>CreateDefaultBuilder</span>(args)</strong><br/>                .<span>ConfigureWebHostDefaults</span>(webBuilder =&gt;<br/>                {<br/>                    webBuilder.<span>UseStartup</span>&lt;<span>Startup</span>&gt;();<br/>                });<br/>    }<br/><span>}</span></pre>
<p>The preceding code imports the <kbd>Microsoft.AspNetCore.Hosting</kbd> and <kbd>Microsoft.Extensions.Hosting</kbd> namespaces. They supply the necessary references for the initialization of a new <kbd>IHostBuilder</kbd> instance created in the <kbd>CreateHostBuilder</kbd> function. The <kbd>CreateHostBuilder</kbd> function executes the <kbd>Host.CreateDefaultBuilder</kbd> method, which initializes the web host of our APIs. Furthermore, we should note that the <kbd>IHostBuilder</kbd> instance returned by the <kbd>CreateDefaultBuilder</kbd> method refers to the <kbd>Startup</kbd> class of the project. The <kbd>Main</kbd> method invokes the <kbd>CreateHostBuilder</kbd> function and executes the <kbd>Build</kbd> and <kbd>Run</kbd> methods exposed by the <kbd>IHostBuilder</kbd> interface.</p>
<p class="mce-root"/>
<p>Let's examine the <kbd>Startup</kbd> class (defined in the <kbd>Startup.cs</kbd> file), which is used to configure the <span>application </span>stack:</p>
<pre><span>using </span><span>Microsoft</span>.<span>AspNetCore</span>.<span>Builder</span>;<br/><span>using </span><span>Microsoft</span>.<span>AspNetCore</span>.<span>Hosting</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Configuration</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>DependencyInjection</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Hosting</span>;<br/><br/><span>namespace </span><span>SampleAPI<br/></span>{<br/>    <span>public class </span><span>Startup<br/></span><span>    </span>{<br/>        <span>public </span><span>Startup</span>(<span>IConfiguration </span>configuration)<br/>        {<br/>            <span>Configuration </span>= configuration;<br/>        }<br/><br/>        <span>public </span><span>IConfiguration </span><span>Configuration </span>{ <span>get</span>; }<br/><br/>        <span>public void </span><strong><span>ConfigureServices</span></strong>(<span>IServiceCollection </span>services)<br/>        {<br/>            services.<span>AddControllers</span>();<br/>        }<br/><br/>        <span>public void </span><strong><span>Configure</span></strong>(<span>IApplicationBuilder </span>app, <br/><span>        IWebHostEnvironment </span>env)<br/>        {<br/>            <span>if </span>(env.<span>IsDevelopment</span>())<br/>            {<br/>                app.<span>UseDeveloperExceptionPage</span>();<br/>            }<br/><br/>            app.<span>UseHttpsRedirection</span>();<br/><br/>            app.<span>UseRouting</span>();<br/><br/>            app.<span>UseAuthorization</span>();<br/><br/>            app.<span>UseEndpoints</span>(endpoints =&gt;<br/>            {<br/>                endpoints.<span>MapControllers</span>();<br/>            });<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>Startup</kbd> class initializes the <kbd>IConfiguration</kbd> attribute through dependency injection. The <kbd>IConfiguration</kbd> object represents a key/value object which contains configurations for the app. By default, the <kbd>CreateDefaultBuilder</kbd> <span>method </span>declared in the <kbd>Program.cs</kbd> file sets <kbd>appsettings.json</kbd> as the default configuration file.</p>
<p>The <kbd>Startup</kbd> class has two different methods, which behave in the following ways:</p>
<ul>
<li>The <kbd>ConfigureServices</kbd><strong> </strong>method configures services in our application using dependency injection. By default, it adds controllers by executing the <kbd>.AddControllers</kbd> extension method. In ASP.NET Core, the term services usually refer to any component or class that provides our application with features and functionalities. As we'll see in the next few chapters, ASP.NET Core frequently uses dependency injection<em> </em>to maintain a good design and loosely-coupled classes.</li>
<li>The <kbd>Configure</kbd> method is used to configure the application's middleware pipeline. It accepts two arguments: <span><span><kbd>IApplicationBuilder</kbd> and <span><kbd>IWebHostEnvironment</kbd>. The first contains all the pipelines for our app and exposes extension methods to build our app with middleware. We'll have a look at middleware in detail in <a href="77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml">Chapter 3</a>, <em>Working with the Middleware Pipeline</em>. The <kbd>IWebHostEvironment</kbd> interface gives some information about the current hosting environment of the application, such as its type and its name. In a web API project, the <kbd>Configure</kbd> method executes a list of extensions methods. The most important are the <kbd>UseRouting</kbd> and <kbd>UseEndpoints</kbd> extension methods. The execution of the <kbd>UseRouting</kbd> method defines the point in the pipeline where routing decisions are taken. The <kbd>UseEndpoints</kbd> extension method defines the actual execution of the previously selected endpoint. In the case of a web API project, the only endpoints involved are the controllers. Therefore, the <kbd>UseEndpoints</kbd> method executes the <kbd>MapControllers</kbd> extension method to initialize the default routing convention for controller classes, provided in .NET Core.</span></span></span></li>
</ul>
<p>It should be noted that the ASP.NET Core <kbd>Startup</kbd> class provides a high-level, code-first way to configure the dependencies of your application through dependency injection, which means that it <span>only</span><span> initializes</span> <span>what you need. Furthermore, .NET Core is strongly modularity-oriented; this</span> <span>is one of the reasons why it performs better than the .NET Framework.</span></p>
<p><span>Since all pipelines and dependencies are initialized in the aforementioned class, you </span><span>know</span><span> </span><span>exactly where they can be changed. In large applications and services with a lot of different components, it is advisable to create custom extension methods that handle the initialization of specific parts of your app.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of controllers </h1>
                </header>
            
            <article>
                
<p>Controllers are a fundamental part of the web API in ASP.NET Core projects. They handle incoming requests and act as the entry point of our application. We'll look at controllers in more detail in <a href="54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml">Chapter 4</a>, <em>Dependency Injection</em>, but for now, let's examine the default <span><kbd>WeatherForecastController</kbd> </span>provided by the web API template:</p>
<pre><span>using </span><span>System</span>;<br/><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><span>using </span><span>System</span>.<span>Linq</span>;<br/><span>using </span><span>Microsoft</span>.<span>AspNetCore</span>.<span>Mvc</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Logging</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Controllers<br/></span>{<br/>    <strong>[<span>ApiController</span>]</strong><br/>    <strong>[<span>Route</span>(<span>"[controller]"</span>)]</strong><br/>    <span>public class </span><span>WeatherForecastController </span>: <span><strong>ControllerBase</strong><br/></span><span>    </span>{<br/>        <span>private static readonly string</span>[] <span>Summaries </span>= <span>new[]<br/></span><span>        </span><span>{</span><br/>            <span>"Freezing"</span>, <span>"Bracing"</span>, <span>"Chilly"</span>, <span>"Cool"</span>, <span>"Mild"</span>, <span>"Warm"</span>, <br/><span>            "Balmy"</span>, <span>"Hot"</span>, <span>"Sweltering"</span>, <span>"Scorching"<br/></span><span>        </span><span>}</span>;<br/><br/>        <span>private readonly </span><span>ILogger</span>&lt;<span>WeatherForecastController</span>&gt; <span>_logger</span>;<br/><br/>        <span>public </span><span>WeatherForecastController</span>(<span>ILogger</span>&lt;<span>WeatherForecastController</span>&gt; <br/>        logger)<br/>        {<br/>            <span>_logger </span>= logger;<br/>        }<br/><br/>        <strong>[<span>HttpGet</span>]</strong><br/>        <span>public </span><span>IEnumerable</span>&lt;<span>WeatherForecast</span>&gt; <span>Get</span>()<br/>        {<br/>            <span>var </span>rng = <span>new </span><span>Random</span>();<br/>            <span>return </span><span>Enumerable</span>.<span>Range</span>(<span>1</span>, <span>5</span>).<span>Select</span>(index =&gt; <br/><span>            new </span><span>WeatherForecast<br/></span><span>            </span>{<br/>                <span>Date </span>= <span>DateTime</span>.<span>Now</span>.<span>AddDays</span>(index),<br/>                <span>TemperatureC </span>= rng.<span>Next</span>(-<span>20</span>, <span>55</span>),<br/>                <span>Summary </span>= <span>Summaries</span>[rng.<span>Next</span>(<span>Summaries</span>.<span>Length</span>)]<br/>            })<br/>            .<span>ToArray</span>();<br/>        }<br/>    }<br/>}</pre>
<p><span><kbd>WeatherForecastController</kbd> </span>comes with basic methods. By default, it doesn't use any data source; it simply returns some mock values. Let's proceed by having a look at the main elements of the <kbd>WeatherForecastController</kbd> class:</p>
<ul>
<li>The<span> </span><kbd>ApiController</kbd><span> </span>attribute indicates that the controller and all extended controllers serve HTTP API responses. It was introduced in ASP.NET Core version 2.1, and it is usually combined with the<span> </span><kbd>ControllerBase</kbd><span> </span>class.</li>
<li>The <kbd>Route("api/[controller]")</kbd> attribute defines the route for our controller. For example, in this case the controller will respond to the following URI: <kbd>https://myhostname:myport/api/weatherforecast</kbd>. The <kbd>[controller]</kbd> placeholder is used to indicate the name of the controller. </li>
<li>The <kbd>ControllerBase</kbd> class is usually combined with the <kbd>ApiController</kbd> attribute, and it is defined in the <kbd>Microsoft.AspNetCore.Mvc</kbd> namespace. The <kbd>ControllerBase</kbd> class indicates a controller without support for the views part. It provides a few base methods, such as <kbd>Created</kbd>, <kbd>CreatedAtAction</kbd><em>,</em> and <kbd>NotFound</kbd><em>.</em> It also provides some properties, for example, <kbd>HttpContext</kbd>, which contains the requests and responses of our web service.</li>
<li>The <kbd>HttpGet</kbd> attribute is part of the <kbd>Microsoft.AspNetCore.Mvc</kbd> namespace. It identifies the type of HTTP method accepted by the action. It also accepts an additional parameter, such as <kbd>[HttpGet("{id}")]</kbd>, which defines the route template of the action. ASP.NET Core exposes an HTTP attribute for each HTTP verb, such as <kbd>HttpPost</kbd><em>,<span> </span></em><kbd>HttpPut</kbd><em>,</em> or<em><span> </span></em><kbd>HttpDelete</kbd><span>.</span></li>
</ul>
<p>Finally, we can take a brief look at the implementation of the <span><kbd>WeatherForecastController()</kbd> constructor method and the <kbd>Get()</kbd> method. The first initializes all dependencies of the controller class, and it is the dependency injection entry point for our class; all dependencies relating to the controllers are solved in the constructor. The <kbd>Get()</kbd> method implements the logic and returns a collection of elements that will be serialized and then passed to the HTTP response of the web API.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced some central concepts in <em>.</em>NET Core. We walked through the console application and web API templates as well as the ASP.NET Core web API structure<em>,</em> and the structure of a controller class.</p>
<p>The topics covered in this chapter provide the skills necessary to start with a console application project on .NET Core, and they also provides basic knowledge regarding the arrangement of an ASP.NET Core project. </p>
<p>In the next chapter, we will explore a core concept of ASP.NET Core, middleware, and how it can be used to<span> intercept requests and enhance our application stack.</span></p>


            </article>

            
        </section>
    </body></html>