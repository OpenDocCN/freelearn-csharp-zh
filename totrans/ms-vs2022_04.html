<html><head></head><body>
  <div id="_idContainer113">
   <h1 class="chapter-number" id="_idParaDest-73">
    <a id="_idTextAnchor073">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor074">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Performance Optimization and Profiling
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, we delve into the crucial aspect of ensuring that our code not only functions correctly but also runs efficiently.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     While writing code that works is essential, optimizing its performance is equally vital, especially in today’s fast-paced digital landscape where users expect swift and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      responsive applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In the preceding chapters, we laid the groundwork by mastering unit testing,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      test-driven development
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      TDD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     ), advanced debugging strategies, and code analysis.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     Now, we shift our focus to the optimization and profiling tools available within Visual Studio 2022, empowering ourselves to
    </span>
    <a id="_idIndexMarker257">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     fine-tune our applications for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      optimal performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     Throughout this chapter, we will explore various techniques and methodologies aimed at enhancing the speed, responsiveness, and resource efficiency of our software.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     We’ll begin by introducing the fundamentals of performance optimization and the importance of utilizing profiling tools to identify bottlenecks and areas
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      for improvement.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     Key topics covered in this chapter include
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Introduction to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       performance optimization
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Utilizing Visual Studio
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       profiling tools
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Analyzing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       CPU usage
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Memory profiling
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       and optimization
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Optimizing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       database interaction
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     By mastering these concepts and techniques, we’ll learn how to pinpoint performance issues, optimize critical sections of our code base, and ensure that our applications deliver a seamless user experience under various workloads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      and conditions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     Let’s begin our journey toward building faster, more efficient
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      software together.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-75">
    <a id="_idTextAnchor075">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     While writing this chapter, I used the following version of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      Visual Studio:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.33.1">
      Visual Studio Enterprise 2022
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       Version
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.35.1">
       17.12.0
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       Preview 1.0
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     The code files for this chapter can found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch04">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.39.1">
       https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch04
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor076">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     Introduction to performance optimization
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     Performance optimization
    </span>
    <a id="_idIndexMarker258">
    </a>
    <span class="koboSpan" id="kobo.43.1">
     in software development involves refining an application to operate with maximum efficiency, minimizing resource consumption such as memory, CPU, and bandwidth.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     This process includes analyzing performance at various development stages, often focusing on enhancing efficiency once a stable version of the product has
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      been established.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     The main step in our performance optimization process is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.46.1">
      identifying bottlenecks
     </span>
    </em>
    <span class="koboSpan" id="kobo.47.1">
     , as it allows us to pinpoint the specific areas of our code that are causing performance issues.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.48.1">
      Bottlenecks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     are
    </span>
    <a id="_idIndexMarker259">
    </a>
    <span class="koboSpan" id="kobo.50.1">
     points in our code where the execution slows down significantly, often due to resource constraints or inefficient algorithms.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     By identifying these bottlenecks, we can focus our optimization efforts on where they will have the most impact, leading to more efficient and faster applications.
    </span>
    <span class="koboSpan" id="kobo.50.3">
     This targeted approach not only improves the performance of our application but also enhances the overall user experience by reducing load times and improving responsiveness.
    </span>
    <span class="koboSpan" id="kobo.50.4">
     Furthermore, identifying bottlenecks early in the development process can prevent costly rework and delays, as it becomes more economical to address performance issues before they become entrenched in our application’s architecture.
    </span>
    <span class="koboSpan" id="kobo.50.5">
     In essence, the ability to identify and address bottlenecks is a key skill for us as developers aiming to create high-performance applications, ensuring that our software runs smoothly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.51.1">
      and efficiently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     Performance optimization could be performed at different levels and offers different paths
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      of exploration:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.54.1">
      At the design level, the architecture of the system plays a crucial role in its performance.
     </span>
     <span class="koboSpan" id="kobo.54.2">
      Designing with performance in mind involves making strategic decisions about how the system interacts with hardware and network resources.
     </span>
     <span class="koboSpan" id="kobo.54.3">
      For instance, reducing network latency can be achieved by minimizing network requests, ideally making a single request instead of multiple.
     </span>
     <span class="koboSpan" id="kobo.54.4">
      This approach not only reduces the load on the network but also simplifies the application’s architecture, making it easier to maintain
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.55.1">
       and scale.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.56.1">
      Implementation choices in the
     </span>
     <a id="_idIndexMarker260">
     </a>
     <span class="koboSpan" id="kobo.57.1">
      source code also have a significant impact on system optimization.
     </span>
     <span class="koboSpan" id="kobo.57.2">
      Employing efficient coding practices is crucial for achieving system optimization.
     </span>
     <span class="koboSpan" id="kobo.57.3">
      This includes avoiding unnecessary computations, which can significantly reduce the computational overhead of the application.
     </span>
     <span class="koboSpan" id="kobo.57.4">
      For example, using
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.58.1">
       Language-Integrated Query
      </span>
     </strong>
     <span class="koboSpan" id="kobo.59.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.60.1">
       LINQ
      </span>
     </strong>
     <span class="koboSpan" id="kobo.61.1">
      ) for
     </span>
     <a id="_idIndexMarker261">
     </a>
     <span class="koboSpan" id="kobo.62.1">
      data manipulation can lead to code that is more readable yet potentially more efficient than traditional loops.
     </span>
     <span class="koboSpan" id="kobo.62.2">
      Additionally, utilizing C#’s asynchronous programming features, such as async and await, can help to improve the responsiveness of applications by allowing them to perform other tasks while waiting for long-running operations
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.63.1">
       to complete.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.64.1">
      The choice of algorithms and data structures is a critical factor in system performance.
     </span>
     <span class="koboSpan" id="kobo.64.2">
      Efficient algorithms and data structures can significantly reduce the time complexity of operations, allowing the system to handle larger datasets and more complex tasks with ease.
     </span>
     <span class="koboSpan" id="kobo.64.3">
      Ideally, algorithms should operate at constant (O(1)), logarithmic (O(log n)), linear (O(n)), or log-linear (O(n log n)) time complexities.
     </span>
     <span class="koboSpan" id="kobo.64.4">
      Algorithms with quadratic complexity (O(n^2)) can struggle to scale efficiently, especially as the size of the dataset grows.
     </span>
     <span class="koboSpan" id="kobo.64.5">
      Similarly, abstract data types, which encapsulate data and operations in a single entity, can be more efficient for system optimization compared to more complex
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.65.1">
       data structures.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.66.1">
      Optimizing at the build level involves making decisions during the build process that can tailor the application for specific processor models or environments.
     </span>
     <span class="koboSpan" id="kobo.66.2">
      This can include disabling unnecessary software features, which can reduce the size of the executable and improve its performance.
     </span>
     <span class="koboSpan" id="kobo.66.3">
      Additionally, build-level optimizations can involve the use of compiler flags that enable specific optimizations, such as loop unrolling or function inlining, which can improve the efficiency of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.67.1">
       generated code.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     You may have noticed that I categorized the algorithm by complexity using Big O notation; let’s take a refresher about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      this notation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     Big O notation
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     serves as a mathematical representation utilized to characterize the performance or complexity of algorithms, particularly concerning their runtime behavior with increasing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      input size.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.73.1">
     Proficiency in
    </span>
    <a id="_idIndexMarker263">
    </a>
    <span class="koboSpan" id="kobo.74.1">
     understanding Big O notation holds significant importance for software engineers.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     It equips us with the ability to evaluate and contrast the efficiency of diverse algorithms.
    </span>
    <span class="koboSpan" id="kobo.74.3">
     Consequently, we can make well-informed decisions regarding the selection of algorithms suitable for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      specific scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.76.1">
     The following points outline the well-known Big
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.77.1">
      O notations:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.78.1">
       Constant time O(1)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.79.1">
      : Execution
     </span>
     <a id="_idIndexMarker264">
     </a>
     <span class="koboSpan" id="kobo.80.1">
      time remains unchanged irrespective of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.81.1">
       input data
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.82.1">
       Logarithmic time O(log n)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.83.1">
      : Complexity
     </span>
     <a id="_idIndexMarker265">
     </a>
     <span class="koboSpan" id="kobo.84.1">
      increases by one unit for each doubling of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.85.1">
       input data
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.86.1">
       Linear time O(n)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.87.1">
      : Execution
     </span>
     <a id="_idIndexMarker266">
     </a>
     <span class="koboSpan" id="kobo.88.1">
      time increases linearly with the size of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.89.1">
       input data
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.90.1">
       Log-linear time O(n log n)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.91.1">
      : Complexity
     </span>
     <a id="_idIndexMarker267">
     </a>
     <span class="koboSpan" id="kobo.92.1">
      grows as a combination of linear
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.93.1">
       and logarithmic
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.94.1">
       Quadratic time O(n^2)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.95.1">
      : Time taken
     </span>
     <a id="_idIndexMarker268">
     </a>
     <span class="koboSpan" id="kobo.96.1">
      is proportional to the square of the number
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.97.1">
       of elements
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.98.1">
       Cubic time O(n^3)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.99.1">
      : Execution
     </span>
     <a id="_idIndexMarker269">
     </a>
     <span class="koboSpan" id="kobo.100.1">
      time is proportional to the cube of the number
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.101.1">
       of elements
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.102.1">
       Exponential time O(2^n)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.103.1">
      : Time
     </span>
     <a id="_idIndexMarker270">
     </a>
     <span class="koboSpan" id="kobo.104.1">
      doubles for every new
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.105.1">
       element added
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.106.1">
       Factorial time O(n!)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.107.1">
      : Complexity
     </span>
     <a id="_idIndexMarker271">
     </a>
     <span class="koboSpan" id="kobo.108.1">
      grows factorially based on the size of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.109.1">
       the dataset
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     Now that we’ve explored the fundamental principles of performance optimization in software development, let’s delve into practical methods for identifying and addressing performance issues.
    </span>
    <span class="koboSpan" id="kobo.110.2">
     Some invaluable tools for our endeavor are Visual Studio profiling tools.
    </span>
    <span class="koboSpan" id="kobo.110.3">
     By leveraging the capabilities of these tools, we can gain deeper insights into our application’s performance and streamline the optimization process.
    </span>
    <span class="koboSpan" id="kobo.110.4">
     Let’s examine how Visual Studio profiling tools can be effectively utilized to enhance the performance of our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      software applications.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-77">
    <a id="_idTextAnchor077">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     Utilizing Visual Studio profiling tools
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     Visual Studio profiling tools
    </span>
    <a id="_idIndexMarker272">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     are a suite of performance measurement and diagnostic tools integrated into Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     In this section, we will explore how to use it and explore what tools are offered to explore and monitor
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      our applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     To open the
    </span>
    <a id="_idIndexMarker273">
    </a>
    <span class="koboSpan" id="kobo.117.1">
     Performance Profiler, we go to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.118.1">
      Debug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.120.1">
      Performance Profiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     or press
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.122.1">
      Alt
     </span>
    </em>
    <span class="koboSpan" id="kobo.123.1">
     +
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.124.1">
       F2
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer091">
     <span class="koboSpan" id="kobo.126.1">
      <img alt="Figure 4.1 – Performance Profiler" src="image/B22218_04_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.127.1">
     Figure 4.1 – Performance Profiler
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     Before clicking on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.129.1">
      Start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.130.1">
     button, let’s review the various options the Performance Analyzer feature offers us for profiling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      our applications.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-78">
    <a id="_idTextAnchor078">
    </a>
    <span class="koboSpan" id="kobo.132.1">
     Analyzing .NET asynchronous events
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     .NET’s async and await
    </span>
    <a id="_idIndexMarker274">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     features allow us to analyze the asynchronous
    </span>
    <a id="_idIndexMarker275">
    </a>
    <span class="koboSpan" id="kobo.135.1">
     events that are organized chronologically, displaying start time, end time, and duration, in a table of activities that occurred during our profiling session.
    </span>
    <span class="koboSpan" id="kobo.135.2">
     Tasks are labeled in the
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.136.1">
       Name
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      column.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer092">
     <span class="koboSpan" id="kobo.138.1">
      <img alt="Figure 4.2 – .NET Async" src="image/B22218_04_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.139.1">
     Figure 4.2 – .NET Async
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     If a task isn’t complete within the collection session, an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.141.1">
      Incomplete
     </span>
    </em>
    <span class="koboSpan" id="kobo.142.1">
     label appears in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.143.1">
      End
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.144.1">
       Time
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      column.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.146.1">
     To investigate a specific task or activity, we can right-click the row and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.147.1">
      Go To Source File
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     to see where in our code that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.149.1">
      activity happened.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.150.1">
     Understanding the characteristics of async performance is crucial.
    </span>
    <span class="koboSpan" id="kobo.150.2">
     While async methods are meant to enhance application responsiveness and scalability, they do introduce some overhead due to the state machine created by the compiler.
    </span>
    <span class="koboSpan" id="kobo.150.3">
     However, this overhead is generally minimal and efficient for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.151.1">
      high-throughput scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.152.1">
     When comparing the
    </span>
    <a id="_idIndexMarker276">
    </a>
    <span class="koboSpan" id="kobo.153.1">
     performance of async versus sync code, we need to consider the nature of the operations being performed.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     For operations inherently asynchronous (such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.154.1">
      input/output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.156.1">
      I/O
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     )-bound operations), async methods
    </span>
    <a id="_idIndexMarker277">
    </a>
    <span class="koboSpan" id="kobo.158.1">
     can provide significant performance
    </span>
    <a id="_idIndexMarker278">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     benefits by freeing up threads to handle other requests while waiting.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     However, for CPU-bound operations, the performance difference between async and sync methods may
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      be negligible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     For effective performance monitoring of our application using .NET’s async and await features, we can utilize the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.162.1">
      .NET Async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     tool in
    </span>
    <a id="_idIndexMarker279">
    </a>
    <span class="koboSpan" id="kobo.164.1">
     Visual Studio for detailed analysis of asynchronous code execution.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     Additionally, external tools such as Stackify Retrace offer comprehensive monitoring capabilities for .NET applications, including support for async/await.
    </span>
    <span class="koboSpan" id="kobo.164.3">
     Understanding the performance characteristics of async methods and the nature of the operations being performed is crucial for making informed decisions about when to employ async
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.165.1">
      programming patterns.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-79">
    <a id="_idTextAnchor079">
    </a>
    <span class="koboSpan" id="kobo.166.1">
     Monitoring with .NET Counters
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     Visual Studio 2022 integrates
    </span>
    <a id="_idIndexMarker280">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     the .
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.169.1">
      NET Counters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     tool, which is an advanced feature that allows
    </span>
    <a id="_idIndexMarker281">
    </a>
    <span class="koboSpan" id="kobo.171.1">
     developers like us to visualize performance counters over time directly within the Visual Studio profiler.
    </span>
    <span class="koboSpan" id="kobo.171.2">
     This tool proves to be particularly useful for monitoring and analyzing various metrics of .NET applications, such as CPU usage, garbage collector heap size, and any custom counters we might have implemented in our applications.
    </span>
    <span class="koboSpan" id="kobo.171.3">
     This integration enables us to leverage the power of .NET Counters directly from within the Visual Studio environment, providing a more seamless and integrated experience for performance monitoring
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      and analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     Visual Studio 2022 enhanced the .NET Counters tool to support two innovative metrics:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      UpDownCounter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      ObservableCounter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     .
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.178.1">
      UpDownCounter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     enables real-time tracking of values with both incremental and decremental changes, which is ideal for monitoring dynamic values such as user interactions in web applications.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     On the other hand,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      ObservableCounter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     autonomously manages aggregated totals, offering customizable callback delegates for precise control.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     This feature can be particularly useful for optimizing server resources
    </span>
    <a id="_idIndexMarker282">
    </a>
    <span class="koboSpan" id="kobo.182.1">
     by efficiently managing active
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      session totals.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.184.1">
     Additionally, a filter flyout feature in the tool allows us to conveniently filter data points based on tags.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     This dynamic adjustment feature significantly enhances the flexibility and streamlining of monitoring dynamic values in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      our projects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     While collecting data, we can see live values of .NET Counters and view graphs of multiple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      counters simultaneously.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer093">
     <span class="koboSpan" id="kobo.188.1">
      <img alt="Figure 4.3 – .NET Counters" src="image/B22218_04_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.189.1">
     Figure 4.3 – .NET Counters
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.190.1">
     Once we stop
    </span>
    <a id="_idIndexMarker283">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     collection, we get a detailed report showing minimum, maximum, and average values for each counter in the selected time range.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     This report provides
    </span>
    <a id="_idIndexMarker284">
    </a>
    <span class="koboSpan" id="kobo.192.1">
     us with a comprehensive overview of the performance metrics of our application, helping us identify and address performance bottlenecks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      more effectively.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor080">
    </a>
    <span class="koboSpan" id="kobo.194.1">
     Tracking .NET Object Allocation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.196.1">
      .NET Object Allocation Tracking
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     tool proves
    </span>
    <a id="_idIndexMarker285">
    </a>
    <span class="koboSpan" id="kobo.198.1">
     particularly valuable for understanding allocation patterns in .NET code and optimizing an application’s memory usage by
    </span>
    <a id="_idIndexMarker286">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     identifying the most memory-intensive methods.
    </span>
    <span class="koboSpan" id="kobo.199.2">
     However, it’s important to note that while this tool can reveal where objects are allocated, it does not elucidate why an object remains
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      in memory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.201.1">
     We initiate the tool by clicking on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.202.1">
      Start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     button, and the tool offers the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.204.1">
      Start with collection paused
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     option before starting the profiler if we prefer to commence with data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      collection paused.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer094">
     <span class="koboSpan" id="kobo.207.1">
      <img alt="Figure 4.4 – Start analysis" src="image/B22218_04_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.208.1">
     Figure 4.4 – Start analysis
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.209.1">
     This allows us to manually commence data collection by clicking the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.210.1">
      Record
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     button in the diagnostic
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      session view.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.213.1">
     After executing the tool, we can halt the collection or close our application to review the data.
    </span>
    <span class="koboSpan" id="kobo.213.2">
     The tool furnishes comprehensive memory allocation data, including the location of objects that are allocating memory and the amount of memory those objects are allocating.
    </span>
    <span class="koboSpan" id="kobo.213.3">
     It also displays the number of objects that occupy memory within a specific allocation type or function, as well as the amount of memory consumed instead of the number
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      of objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.215.1">
     Additionally, the tool
    </span>
    <a id="_idIndexMarker287">
    </a>
    <span class="koboSpan" id="kobo.216.1">
     presents a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.217.1">
      Collections
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     view, which illustrates how many
    </span>
    <a id="_idIndexMarker288">
    </a>
    <span class="koboSpan" id="kobo.219.1">
     objects were collected or retained during garbage collection, offering insights into garbage collection events such as the type of garbage collection, the reason for the event, and the size of
    </span>
    <a id="_idIndexMarker289">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.221.1">
      large object heap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.223.1">
      LOH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     ) and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.225.1">
      pinned object heap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.227.1">
      POH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     ) after
    </span>
    <a id="_idIndexMarker290">
    </a>
    <span class="koboSpan" id="kobo.229.1">
     the garbage collector
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      was executed.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor081">
    </a>
    <span class="koboSpan" id="kobo.231.1">
     Viewing the event
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.233.1">
      Events
     </span>
    </strong>
    <strong class="bold">
     <span class="koboSpan" id="kobo.234.1">
      Viewer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     tool allows us to
    </span>
    <a id="_idIndexMarker291">
    </a>
    <span class="koboSpan" id="kobo.236.1">
     examine the collected information after our application
    </span>
    <a id="_idIndexMarker292">
    </a>
    <span class="koboSpan" id="kobo.237.1">
     has stopped, like a post-mortem analysis.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     It displays a list of events such as module load, thread start, and system configuration, aiding in diagnosing our application’s performance within the Visual
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.238.1">
      Studio profiler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     To enable
    </span>
    <a id="_idIndexMarker293">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     custom
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.241.1">
      Event Tracing for Windows
     </span>
    </strong>
    <span class="koboSpan" id="kobo.242.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.243.1">
      ETW
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     ) events, we can instrument our code with custom events and configure them to appear in the Events Viewer.
    </span>
    <span class="koboSpan" id="kobo.244.2">
     This involves setting up the provider’s name and GUID for our custom event code.
    </span>
    <span class="koboSpan" id="kobo.244.3">
     For C# custom event code, we set the same provider’s name value that we used when declaring our event code, and for the native custom event code, we set the provider GUID based on the GUID for the custom event code.
    </span>
    <span class="koboSpan" id="kobo.244.4">
     Once configured, these custom events will appear in the Events Viewer when we collect a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      diagnostics trace.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     The Events Viewer
    </span>
    <a id="_idIndexMarker294">
    </a>
    <span class="koboSpan" id="kobo.247.1">
     can display up to 20,000 events at a time.
    </span>
    <span class="koboSpan" id="kobo.247.2">
     To focus on specific events, we can filter the display by selecting the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.248.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     filter.
    </span>
    <span class="koboSpan" id="kobo.249.2">
     Additionally, we can see the percentage of the total number of events that occurred for each provider, providing a breakdown of where our time is being spent.
    </span>
    <span class="koboSpan" id="kobo.249.3">
     This filtering and breakdown help in
    </span>
    <a id="_idIndexMarker295">
    </a>
    <span class="koboSpan" id="kobo.250.1">
     identifying the most relevant events for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      our analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.252.1">
     For example, to
    </span>
    <a id="_idIndexMarker296">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     enable custom
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      ETW events:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.255.1">
      First, build our custom
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.256.1">
       event code.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.257.1">
      Then, in the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.258.1">
       Performance Profiler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.259.1">
      window (accessed via
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.260.1">
       Alt
      </span>
     </em>
     <span class="koboSpan" id="kobo.261.1">
      +
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.262.1">
       F2
      </span>
     </em>
     <span class="koboSpan" id="kobo.263.1">
      ), enable
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.264.1">
       Events Viewer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.265.1">
      and select the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.266.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.267.1">
      icon next
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.268.1">
       to it.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.269.1">
      In the dialog box, enable the first row under
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.270.1">
       Additional Providers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.271.1">
      and configure it according to our custom
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.272.1">
       event code.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.273.1">
      For native custom event code, we set the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.274.1">
       Provider GUID
      </span>
     </strong>
     <span class="koboSpan" id="kobo.275.1">
      value and leave the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.276.1">
       Provider Name
      </span>
     </strong>
     <span class="koboSpan" id="kobo.277.1">
      value empty or use its
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.278.1">
       default value.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.279.1">
      For C# custom event code, we set the same
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.280.1">
       Provider Name
      </span>
     </strong>
     <span class="koboSpan" id="kobo.281.1">
      value that we used when declaring our event code, leaving the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.282.1">
       Provider GUID
      </span>
     </strong>
     <span class="koboSpan" id="kobo.283.1">
      empty.
     </span>
     <span class="koboSpan" id="kobo.283.2">
      After configuration, our custom events will appear in the Events Viewer when we collect a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.284.1">
       diagnostics trace.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.285.1">
     This tool is particularly useful
    </span>
    <a id="_idIndexMarker297">
    </a>
    <span class="koboSpan" id="kobo.286.1">
     for us as developers looking to diagnose performance issues or understand the behavior of our applications in
    </span>
    <a id="_idIndexMarker298">
    </a>
    <span class="koboSpan" id="kobo.287.1">
     detail.
    </span>
    <span class="koboSpan" id="kobo.287.2">
     It provides a comprehensive view of our application’s activity and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      performance metrics.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-82">
    <a id="_idTextAnchor082">
    </a>
    <span class="koboSpan" id="kobo.289.1">
     Analyzing File I/O
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.291.1">
      File IO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     tool in Visual
    </span>
    <a id="_idIndexMarker299">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     Studio is a powerful profiling tool designed to help us optimize our file
    </span>
    <a id="_idIndexMarker300">
    </a>
    <span class="koboSpan" id="kobo.294.1">
     I/O operations, thereby improving the performance of our applications.
    </span>
    <span class="koboSpan" id="kobo.294.2">
     This tool is particularly useful for diagnosing slow loading times and inefficient data read or write patterns.
    </span>
    <span class="koboSpan" id="kobo.294.3">
     It provides detailed information about file read and write operations during a profiling session, including the files accessed, the target process for each file, and aggregate information for each file.
    </span>
    <span class="koboSpan" id="kobo.294.4">
     The tool also offers features such as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.295.1">
      Duplication Factor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.296.1">
     , which
    </span>
    <a id="_idIndexMarker301">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     helps us identify whether more data is being read or written than necessary, indicating potential areas for optimization, such as caching results of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      file reads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     The File IO tool provides file read and write information with files read during the profiling session.
    </span>
    <span class="koboSpan" id="kobo.299.2">
     The files are autogenerated in a report after collection and arranged by their target process with aggregate information displayed.
    </span>
    <span class="koboSpan" id="kobo.299.3">
     If we right-click on one of the rows, we can go to the source in our code.
    </span>
    <span class="koboSpan" id="kobo.299.4">
     If an aggregate row was read multiple times, we can expand it to see the individual read operations for that file with its frequency, if they were read
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      multiple times.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor083">
    </a>
    <span class="koboSpan" id="kobo.301.1">
     Analyzing database performance
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.302.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.303.1">
      Database Profiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     tool in Visual
    </span>
    <a id="_idIndexMarker302">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     Studio is a feature designed to help us developers
    </span>
    <a id="_idIndexMarker303">
    </a>
    <span class="koboSpan" id="kobo.306.1">
     diagnose and optimize the performance of database operations within our applications.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     It proves particularly useful for applications that use .NET Core with either ADO.NET or Entity Framework Core, offering insights into database activities such as query execution times, the connection strings used, and where in the code these queries are being made.
    </span>
    <span class="koboSpan" id="kobo.306.3">
     This tool is part of the Performance Profiler in Visual Studio and has been available since Visual Studio 2019 version
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      16.3 onwards.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     Once we start the profiling session, we interact with our application as we would normally, performing actions that we suspect might be causing database performance issues.
    </span>
    <span class="koboSpan" id="kobo.308.2">
     After completing our actions, we stop the collection in Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.308.3">
     The tool then processes the collected data and displays a table of the queries that occurred during our profiling session, along with a graph showing the timing and frequency of these queries.
    </span>
    <span class="koboSpan" id="kobo.308.4">
     This information can help us identify long-running queries, inefficient connection strings, or other performance bottlenecks in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      database operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.310.1">
     Furthermore, the Database Profiler tool supports analyzing traces collected using dotnet trace, allowing us to collect data from anywhere .NET Core runs, including Linux, and analyze it in Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.310.2">
     This feature is particularly useful for diagnosing performance issues in environments where Visual Studio is not installed or for scripting the collection of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.311.1">
      performance traces.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.312.1">
     In summary, the Database Profiler tool
    </span>
    <a id="_idIndexMarker304">
    </a>
    <span class="koboSpan" id="kobo.313.1">
     in Visual Studio is a powerful diagnostic tool for us
    </span>
    <a id="_idIndexMarker305">
    </a>
    <span class="koboSpan" id="kobo.314.1">
     developers working with .NET Core applications that interact with databases.
    </span>
    <span class="koboSpan" id="kobo.314.2">
     It provides detailed insights into database operations, helping us identify and resolve performance issues
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      more effectively.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor084">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     Instrumenting our .NET applications
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     In Visual Studio, we utilize
    </span>
    <a id="_idIndexMarker306">
    </a>
    <span class="koboSpan" id="kobo.318.1">
     instrumentation tools for collecting precise call counts and call times, which are crucial for performance profiling and optimization.
    </span>
    <span class="koboSpan" id="kobo.318.2">
     There are two main types of instrumentation
    </span>
    <a id="_idIndexMarker307">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.319.1">
      methods available:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.320.1">
       Static instrumentation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.321.1">
      : This
     </span>
     <a id="_idIndexMarker308">
     </a>
     <span class="koboSpan" id="kobo.322.1">
      method involves modifying the program’s files before they run.
     </span>
     <span class="koboSpan" id="kobo.322.2">
      We use a tool called VSInstr to insert
     </span>
     <a id="_idIndexMarker309">
     </a>
     <span class="koboSpan" id="kobo.323.1">
      instrumentation code into the application’s binaries.
     </span>
     <span class="koboSpan" id="kobo.323.2">
      Static instrumentation is effective for collecting detailed timing data but can break strong name signing due to file modification.
     </span>
     <span class="koboSpan" id="kobo.323.3">
      It also requires files to be deployed in a specific order, which can be cumbersome for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.324.1">
       complex programs.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.325.1">
       Dynamic instrumentation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.326.1">
      : Introduced in
     </span>
     <a id="_idIndexMarker310">
     </a>
     <span class="koboSpan" id="kobo.327.1">
      Visual Studio 2022
     </span>
     <a id="_idIndexMarker311">
     </a>
     <span class="koboSpan" id="kobo.328.1">
      version 17.5, this method does not alter the program’s files.
     </span>
     <span class="koboSpan" id="kobo.328.2">
      Instead, it loads the files into memory and modifies them at runtime to collect instrumentation information.
     </span>
     <span class="koboSpan" id="kobo.328.3">
      Dynamic instrumentation provides more accurate information, especially for smaller parts of the program, and allows for the investigation of specific code sections.
     </span>
     <span class="koboSpan" id="kobo.328.4">
      It avoids the issue of breaking strong name signing since the instrumentation happens at runtime.
     </span>
     <span class="koboSpan" id="kobo.328.5">
      This approach simplifies the process of finding and
     </span>
     <a id="_idIndexMarker312">
     </a>
     <span class="koboSpan" id="kobo.329.1">
      instrumenting files, especially in
     </span>
     <a id="_idIndexMarker313">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.330.1">
       complex programs.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     This tool is like the CPU Usage tool but focuses on wall clock time instead of CPU utilization, making it suitable for scenarios where understanding the execution time of functions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      is critical.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     By using the
    </span>
    <a id="_idIndexMarker314">
    </a>
    <span class="koboSpan" id="kobo.334.1">
     aforementioned tools, we can gather valuable insights into our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.335.1">
      application’s performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.336.1">
     However, to ensure optimal accuracy in our performance measurements, it’s advisable to profile our applications in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.337.1">
      Release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     mode rather than the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.339.1">
      Debug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     mode.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     Debug builds can introduce additional overhead, potentially skewing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      our results.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     When we find ourselves needing to inspect variable values or use breakpoints during analysis, we should consider leveraging the debugger-integrated tools found in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.343.1">
      Diagnostic Tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.344.1">
     window.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     These tools are tailored for such tasks and may offer a more suitable environment for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      our analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.346.1">
     To gain a holistic understanding of our application’s performance, we can take advantage of Visual Studio’s capability to utilize multiple profiling tools simultaneously.
    </span>
    <span class="koboSpan" id="kobo.346.2">
     This approach allows us to examine our application’s performance from different perspectives, providing a more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      comprehensive analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     You may have noticed that I have missed three tools offered by the Profiler Performance tools.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     I will highlight them in the next sections, beginning with the CPU
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      Usage analyzer.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-85">
    <a id="_idTextAnchor085">
    </a>
    <span class="koboSpan" id="kobo.350.1">
     Analyzing CPU Usage
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.352.1">
      CPU Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     tool
    </span>
    <a id="_idIndexMarker315">
    </a>
    <span class="koboSpan" id="kobo.354.1">
     in Visual Studio is designed to help us identify high CPU utilization
    </span>
    <a id="_idIndexMarker316">
    </a>
    <span class="koboSpan" id="kobo.355.1">
     and other related performance issues in our applications.
    </span>
    <span class="koboSpan" id="kobo.355.2">
     It can be used for both local trace sessions and production environments, providing insights into where optimizations might be needed.
    </span>
    <span class="koboSpan" id="kobo.355.3">
     To use the CPU Usage tool without the debugger, we should set the solution configuration to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.356.1">
      Release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.358.1">
      Local Windows Debugger (or Local Machine)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     as the deployment target.
    </span>
    <span class="koboSpan" id="kobo.359.2">
     Under available tools, we select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.360.1">
      CPU Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     , and then we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.362.1">
      select
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.363.1">
       Start
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.364.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     If we enable the start with collection paused option, data collection will not begin until we select the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.366.1">
      Record
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     button in the diagnostic session view.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     After the app starts, the diagnostic session begins, displaying CPU usage data.
    </span>
    <span class="koboSpan" id="kobo.367.3">
     Once we’re finished collecting data, we select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.368.1">
      Stop Collection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     .
    </span>
    <span class="koboSpan" id="kobo.369.2">
     The tool then analyzes the data and displays a report, which can be filtered and searched for specific threads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      or nodes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.371.1">
     The CPU Usage tool is particularly useful for diagnosing performance issues in our code base, identifying bottlenecks, and understanding CPU usage patterns.
    </span>
    <span class="koboSpan" id="kobo.371.2">
     It provides automatic insights and various views of our data, enabling us to analyze and diagnose performance issues effectively.
    </span>
    <span class="koboSpan" id="kobo.371.3">
     This tool is beneficial in production and difficult to debug at the moment but can be captured and analyzed using this tool to understand potential causes and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      suggest fixes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.373.1">
     The CPU Usage tool is particularly useful for diagnosing slow-downs, process hangs, and identifying bottlenecks in your code base, making it an essential tool for optimizing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.374.1">
      application performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.375.1">
     When running this profiler tools spot the usage of CPU/second and collect traces generating a report with a graph to visualize the peak and valley of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.376.1">
      CPU usage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     When we first start the
    </span>
    <a id="_idIndexMarker317">
    </a>
    <span class="koboSpan" id="kobo.378.1">
     CPU Usage toll, it will collect a large amount of data per second
    </span>
    <a id="_idIndexMarker318">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     to analyze what is going on in our application, and by default, it’s set at
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.380.1">
       1000
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.381.1">
      samples/second.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.382.1">
     We can personalize the rate of the number of samples collected by second, by clicking on the gear at the right of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.383.1">
      CPU Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     label in the profile console (
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.385.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.386.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.387.1">
     ) before hitting the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.388.1">
      Start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     button.
    </span>
    <span class="koboSpan" id="kobo.389.2">
     Depending on our needs, we can adjust the accuracy of their results and the data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      collection time.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer095">
     <span class="koboSpan" id="kobo.391.1">
      <img alt="Figure 4.5 – The CPU Usage settings" src="image/B22218_04_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.392.1">
     Figure 4.5 – The CPU Usage settings
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.393.1">
     When we stop the collection
    </span>
    <a id="_idIndexMarker319">
    </a>
    <span class="koboSpan" id="kobo.394.1">
     or shut down our application, CPU usage tools generate
    </span>
    <a id="_idIndexMarker320">
    </a>
    <span class="koboSpan" id="kobo.395.1">
     reports.
    </span>
    <span class="koboSpan" id="kobo.395.2">
     Initially, we land on the summary page, which displays a swim lane graph, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.396.1">
      Top Functions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.397.1">
     section, and the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.398.1">
      Hot
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.399.1">
       Path
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      section.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer096">
     <span class="koboSpan" id="kobo.401.1">
      <img alt="Figure 4.6 – The Summary page" src="image/B22218_04_6.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.402.1">
     Figure 4.6 – The Summary page
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     Here, we can narrow down the potential bottleneck by right-clicking and dragging on the graph to surround the
    </span>
    <a id="_idIndexMarker321">
    </a>
    <span class="koboSpan" id="kobo.404.1">
     peak we want to focus on.
    </span>
    <span class="koboSpan" id="kobo.404.2">
     By doing that, we effectively filter the
    </span>
    <a id="_idIndexMarker322">
    </a>
    <span class="koboSpan" id="kobo.405.1">
     graph
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      by time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     By clicking on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.408.1">
      Open details…
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     link, we can digg deeper into the five
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      other views:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.411.1">
        Caller/Callee
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.412.1">
        Call Tree
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.413.1">
        Modules
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.414.1">
        Functions
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.415.1">
        Flame Graph
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.416.1">
     Let’s understand each of these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      in detail:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.418.1">
      In the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.419.1">
       Caller/Callee
      </span>
     </strong>
     <span class="koboSpan" id="kobo.420.1">
      view, we can observe the relationship between a selected function and the functions that called it (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.421.1">
       Calling Functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.422.1">
      ) as well as the functions it called (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.423.1">
       Called Functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.424.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.424.2">
      It offers insights into the total time taken by the selected function and its percentage of the overall app running time.
     </span>
     <span class="koboSpan" id="kobo.424.3">
      Additionally, it provides information on the time spent exclusively in the function body (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.425.1">
       Function Body
      </span>
     </strong>
     <span class="koboSpan" id="kobo.426.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.426.2">
      This view helps us understand the impact of a function on the application’s performance and identify
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.427.1">
       potential bottlenecks.
      </span>
     </span>
    </li>
   </ul>
   <div>
    <div class="IMG---Figure" id="_idContainer097">
     <span class="koboSpan" id="kobo.428.1">
      <img alt="Figure 4.7 – Caller/Callee" src="image/B22218_04_7.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.429.1">
     Figure 4.7 – Caller/Callee
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.430.1">
      The
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.431.1">
       Call Tree
      </span>
     </strong>
     <span class="koboSpan" id="kobo.432.1">
      view
     </span>
     <a id="_idIndexMarker323">
     </a>
     <span class="koboSpan" id="kobo.433.1">
      presents a hierarchical representation of the function
     </span>
     <a id="_idIndexMarker324">
     </a>
     <span class="koboSpan" id="kobo.434.1">
      calls in our application, starting from the top-level pseudo-node.
     </span>
     <span class="koboSpan" id="kobo.434.2">
      It includes system and framework code (under an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       [External Code]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.436.1">
      node) as well as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.437.1">
       user-code methods.
      </span>
     </span>
    </li>
   </ul>
   <div>
    <div class="IMG---Figure" id="_idContainer098">
     <span class="koboSpan" id="kobo.438.1">
      <img alt="Figure 4.8 – The Call Tree view" src="image/B22218_04_8.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.439.1">
     Figure 4.8 – The Call Tree view
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.440.1">
     This view is useful for understanding the sequence and nesting of function calls, aiding in the identification of the most CPU-intensive paths in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.441.1">
      our application.
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.442.1">
      In the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.443.1">
       Modules
      </span>
     </strong>
     <span class="koboSpan" id="kobo.444.1">
      view, we
     </span>
     <a id="_idIndexMarker325">
     </a>
     <span class="koboSpan" id="kobo.445.1">
      can see a list of modules containing functions, which
     </span>
     <a id="_idIndexMarker326">
     </a>
     <span class="koboSpan" id="kobo.446.1">
      can be particularly useful when analyzing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.447.1">
       external code.
      </span>
     </span>
    </li>
   </ul>
   <div>
    <div class="IMG---Figure" id="_idContainer099">
     <span class="koboSpan" id="kobo.448.1">
      <img alt="Figure 4.9 – The Modules view" src="image/B22218_04_9.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.449.1">
     Figure 4.9 – The Modules view
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.450.1">
     It helps us understand which modules are contributing the most to CPU usage, assisting in the identification of third-party libraries or system components that might be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      impacting performance.
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.452.1">
      The
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.453.1">
       Functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.454.1">
      view lists
     </span>
     <a id="_idIndexMarker327">
     </a>
     <span class="koboSpan" id="kobo.455.1">
      all the functions in our application, sorted by their
     </span>
     <a id="_idIndexMarker328">
     </a>
     <span class="koboSpan" id="kobo.456.1">
      CPU usage.
     </span>
     <span class="koboSpan" id="kobo.456.2">
      It provides detailed information such as
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.457.1">
       Total CPU
      </span>
     </strong>
     <span class="koboSpan" id="kobo.458.1">
      (the time spent by the function and any functions it called) and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.459.1">
       Self CPU
      </span>
     </strong>
     <span class="koboSpan" id="kobo.460.1">
      (the time spent exclusively in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.461.1">
       function body).
      </span>
     </span>
    </li>
   </ul>
   <div>
    <div class="IMG---Figure" id="_idContainer100">
     <span class="koboSpan" id="kobo.462.1">
      <img alt="Figure 4.10 – The Functions view" src="image/B22218_04_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.463.1">
     Figure 4.10 – The Functions view
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.464.1">
     This view is essential for identifying the most resource-intensive functions in our application and focusing on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      optimization efforts.
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.466.1">
      A
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.467.1">
       flame graph
      </span>
     </strong>
     <span class="koboSpan" id="kobo.468.1">
      is a
     </span>
     <a id="_idIndexMarker329">
     </a>
     <span class="koboSpan" id="kobo.469.1">
      visualization that represents the call stack of our
     </span>
     <a id="_idIndexMarker330">
     </a>
     <span class="koboSpan" id="kobo.470.1">
      application over time.
     </span>
     <span class="koboSpan" id="kobo.470.2">
      It helps in identifying hot paths, that is sequences of function calls that consume a significant amount of
     </span>
     <a id="_idIndexMarker331">
     </a>
     <span class="koboSpan" id="kobo.471.1">
      CPU time.
     </span>
     <span class="koboSpan" id="kobo.471.2">
      The width of each function in the graph corresponds to the amount of CPU time it consumes, making it easier to spot performance bottlenecks.
     </span>
     <span class="koboSpan" id="kobo.471.3">
      The
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.472.1">
       Flame Graph
      </span>
     </strong>
     <span class="koboSpan" id="kobo.473.1">
      view is particularly useful for understanding the overall CPU usage patterns of our application and pinpointing specific areas
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.474.1">
       for optimization.
      </span>
     </span>
    </li>
   </ul>
   <div>
    <div class="IMG---Figure" id="_idContainer101">
     <span class="koboSpan" id="kobo.475.1">
      <img alt="Figure 4.11 – Flame Graph" src="image/B22218_04_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.476.1">
     Figure 4.11 – Flame Graph
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.477.1">
     We can flip the view according to our preferences by using the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.478.1">
      Flip Flame Graph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.479.1">
     option and zooming in on our point
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.480.1">
      of interest.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.481.1">
     For debugging sessions, the
    </span>
    <a id="_idIndexMarker332">
    </a>
    <span class="koboSpan" id="kobo.482.1">
     CPU Usage tool can be accessed through the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.483.1">
      Diagnostic Tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.484.1">
     window, which appears automatically unless turned off.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     We can select whether to see
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.485.1">
      CPU Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.487.1">
      Memory Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     , or both, with the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.489.1">
      Select Tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     setting on the toolbar.
    </span>
    <span class="koboSpan" id="kobo.490.2">
     The tool is enabled by default for CPU
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.491.1">
      utilization analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.492.1">
     When the debugger pauses, the
    </span>
    <a id="_idIndexMarker333">
    </a>
    <span class="koboSpan" id="kobo.493.1">
     CPU Usage tool in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.494.1">
      Diagnostic Tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     window collects information about the functions executing in our application, listing the functions performing work and providing a timeline graph for focusing on specific segments of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      sampling session.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     While CPU usage and memory usage are related, they do not have a direct correlation.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     The impact of one on the other depends on the specific tasks being performed by the applications running on the system.
    </span>
    <span class="koboSpan" id="kobo.497.3">
     Monitoring both metrics is crucial for optimizing system performance and effectively managing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      energy consumption.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     Now that we’ve explored how to analyze CPU usage, let’s continue our journey by monitoring
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      memory allocation.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-86">
    <a id="_idTextAnchor086">
    </a>
    <span class="koboSpan" id="kobo.501.1">
     Memory profiling and optimization
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.502.1">
     Just as a reminder, a memory leak
    </span>
    <a id="_idIndexMarker334">
    </a>
    <span class="koboSpan" id="kobo.503.1">
     occurs when a computer program mishandles memory allocations, leading to unreleased memory that is no longer needed.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     .NET applications are generally less vulnerable to memory leaks due to automatic garbage collection and the fact that .NET applications are written in managed code.
    </span>
    <span class="koboSpan" id="kobo.503.3">
     This means that the runtime has control over memory allocation and deallocation.
    </span>
    <span class="koboSpan" id="kobo.503.4">
     However, if we produce code with smells or misuse the disposable pattern, memory leaks can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      still occur.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.505.1">
     In this section, we will explore how we can leverage Visual Studio to resolve memory leaks using the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.506.1">
      Memory Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.507.1">
     profiling tools and then the diagnostic tools available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.508.1">
      while debugging.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor087">
    </a>
    <span class="koboSpan" id="kobo.509.1">
     Using the Memory Usage tools
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     To find and resolve a memory leak, we
    </span>
    <a id="_idIndexMarker335">
    </a>
    <span class="koboSpan" id="kobo.511.1">
     can use the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.512.1">
      Memory Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.513.1">
     tool in Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.513.2">
     It is a robust profiling feature designed to monitor and analyze our application’s memory usage effectively.
    </span>
    <span class="koboSpan" id="kobo.513.3">
     It supports various application types, including .NET, ASP.NET, C++, and mixed-mode applications.
    </span>
    <span class="koboSpan" id="kobo.513.4">
     This versatile tool can be utilized both with and without the debugger, catering to different development scenarios.
    </span>
    <span class="koboSpan" id="kobo.513.5">
     One of its key strengths lies in its ability to identify memory leaks and inefficient memory
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      usage patterns.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.515.1">
     During our diagnostic sessions, the Memory Usage tool provides a timeline graph illustrating memory fluctuations as our application runs.
    </span>
    <span class="koboSpan" id="kobo.515.2">
     This graphical representation aids in pinpointing areas of our code that may be collecting or generating data inefficiently, potentially leading to memory leaks or excessive
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.516.1">
      memory usage.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer102">
     <span class="koboSpan" id="kobo.517.1">
      <img alt="Figure 4.12 – Memory usage graph" src="image/B22218_04_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.518.1">
     Figure 4.12 – Memory usage graph
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.519.1">
     We can take detailed snapshots of our application’s memory state at different intervals using this tool.
    </span>
    <span class="koboSpan" id="kobo.519.2">
     These snapshots can then be compared to pinpoint the root causes of memory issues.
    </span>
    <span class="koboSpan" id="kobo.519.3">
     They showcase critical metrics such as the total number of objects and bytes in memory, along with the differences between
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.520.1">
      consecutive snapshots.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer103">
     <span class="koboSpan" id="kobo.521.1">
      <img alt="Figure 4.13 – The Memory Usage report types" src="image/B22218_04_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.522.1">
     Figure 4.13 – The Memory Usage report types
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     We can delve deeper into
    </span>
    <a id="_idIndexMarker336">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     these snapshots through detailed Memory Usage report views, gaining insights into the types and instances present in each snapshot or the variances between
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      two snapshots.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     Once data collection is stopped, the Memory Usage tool presents an overview page containing memory usage data.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     This overview helps us grasp the memory impact of our application and spot areas that could benefit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      from optimization.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.528.1">
     For more advanced analysis, the Memory Usage tool provides insights into various memory issues such as duplicate strings, sparse arrays, and event handler leaks, particularly beneficial for managed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.529.1">
      memory analysis.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer104">
     <span class="koboSpan" id="kobo.530.1">
      <img alt="Figure 4.14 – The Memory Usage report insights" src="image/B22218_04_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.531.1">
     Figure 4.14 – The Memory Usage report insights
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.532.1">
     Leveraging these insights allows us to identify and resolve common memory problems
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.533.1">
      more efficiently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.534.1">
     Some scenarios could need to focus and dig deeper into some specific part of our code base, and for that, we can use the diagnostic tools available in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.535.1">
      debugging mode.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-88">
    <a id="_idTextAnchor088">
    </a>
    <span class="koboSpan" id="kobo.536.1">
     Exploring Memory Usage while debugging
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.537.1">
     For this part, I
    </span>
    <a id="_idIndexMarker337">
    </a>
    <span class="koboSpan" id="kobo.538.1">
     will create a small console app that you can retrieve on GitHub.
    </span>
    <span class="koboSpan" id="kobo.538.2">
     The following code includes a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.539.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.540.1">
     loop that fills a List of string with a large
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.541.1">
      random string:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.542.1">
List&lt;string&gt; list = new();
while (true)
{
    list.Add(GenRandomStr(10000));
    Thread.Sleep(1);
}
static string GenRandomStr(int length)
{
    Random rnd = new();
    var chars = new List&lt;char&gt;();
    for (var i = 0; i &lt; length; i++)
    {
        var a = (char)rnd.Next(65, 122);
        chars.Add(a);
    }
    return string.Concat(chars);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.543.1">
     In the preceding
    </span>
    <a id="_idIndexMarker338">
    </a>
    <span class="koboSpan" id="kobo.544.1">
     code block, we begin by setting breakpoints in our application where we suspect the memory leak might be occurring.
    </span>
    <span class="koboSpan" id="kobo.544.2">
     This could be at the start of a function or a region of code that we suspect is causing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.545.1">
      memory leak.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.546.1">
     For this example, since the code is straightforward, we will set breakpoints at the closing bracket of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.547.1">
      the loop.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.548.1">
     Additionally, in more complex scenarios, we can utilize other profiler tools to identify suspect locations in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.549.1">
      code base.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.550.1">
     Next, we will use the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.551.1">
      diagnostic tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.552.1">
     , and by
    </span>
    <a id="_idIndexMarker339">
    </a>
    <span class="koboSpan" id="kobo.553.1">
     default, it opens at the launch of the debugger.
    </span>
    <span class="koboSpan" id="kobo.553.2">
     If not, you
    </span>
    <a id="_idIndexMarker340">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     can reach it by navigating to the top bar menu and clicking
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.555.1">
      Debug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.556.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.557.1">
      Windows
     </span>
    </strong>
    <span class="koboSpan" id="kobo.558.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.559.1">
      Show
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.560.1">
       Diagnostic Tools
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer105">
     <span class="koboSpan" id="kobo.562.1">
      <img alt="Figure 4.15 – Diagnostic Tools" src="image/B22218_04_15.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.563.1">
     Figure 4.15 – Diagnostic Tools
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.564.1">
     In the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.565.1">
      Diagnostic Tools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.566.1">
     window, we retrieve the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.567.1">
      Events
     </span>
    </strong>
    <span class="koboSpan" id="kobo.568.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.569.1">
      Process Memory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.570.1">
     , and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.571.1">
      CPU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.572.1">
     usage graph.
    </span>
    <span class="koboSpan" id="kobo.572.2">
     For our example, we will observe the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.573.1">
      Process Memory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.574.1">
     section, where memory usage increases
    </span>
    <a id="_idIndexMarker341">
    </a>
    <span class="koboSpan" id="kobo.575.1">
     as the loop iterates.
    </span>
    <span class="koboSpan" id="kobo.575.2">
     Additionally, we can monitor the work of the garbage collector to assess its impact on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.576.1">
      memory allocation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.577.1">
     To analyze the heap stack, we can take a snapshot with the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.578.1">
      Take Snapshot
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.579.2">
     This action will generate a report of the memory state at different intervals, as we observed in the profiler tools
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.580.1">
      description previously.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer106">
     <span class="koboSpan" id="kobo.581.1">
      <img alt="Figure 4.16 – A Memory Usage snapshot" src="image/B22218_04_16.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.582.1">
     Figure 4.16 – A Memory Usage snapshot
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     In
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.584.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.585.1">
      .16
     </span>
    </em>
    <span class="koboSpan" id="kobo.586.1">
     , we can observe that the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.587.1">
      Heap Size
     </span>
    </strong>
    <span class="koboSpan" id="kobo.588.1">
     and number of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.589.1">
      Objects
     </span>
    </strong>
    <span class="koboSpan" id="kobo.590.1">
     dangerously increase between our snapshots.
    </span>
    <span class="koboSpan" id="kobo.590.2">
     This indicates poor deallocation, or in other words, a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.591.1">
      memory leak.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.592.1">
     We can dig deeper by clicking on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.593.1">
      View Heap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.594.1">
     option to explore
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.595.1">
      Object Type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     by size
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      and number.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer107">
     <span class="koboSpan" id="kobo.598.1">
      <img alt="Figure 4.17 – Memory Usage" src="image/B22218_04_17.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.599.1">
     Figure 4.17 – Memory Usage
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     Here, we can see that the cause of our memory leak is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      List&lt;String&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     , which will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.603.1">
      never deallocate.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.604.1">
     While CPU and memory can provide insight into the performance of our application, most of the latency observed in software comes from the database interactions and in the next section, we will see how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.605.1">
      optimize them.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-89">
    <a id="_idTextAnchor089">
    </a>
    <span class="koboSpan" id="kobo.606.1">
     Optimizing database interactions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     Visual Studio 2022 introduces a new analyzer tool
    </span>
    <a id="_idIndexMarker342">
    </a>
    <span class="koboSpan" id="kobo.608.1">
     named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.609.1">
      Database Profiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.610.1">
     .
    </span>
    <span class="koboSpan" id="kobo.610.2">
     It allows us to explore the database
    </span>
    <a id="_idIndexMarker343">
    </a>
    <span class="koboSpan" id="kobo.611.1">
     interactions in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.612.1">
      our application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.613.1">
     In this section, we will explore how to use the Database Profiler tools and how they can help us identify query optimization opportunities in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.614.1">
      code base.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.615.1">
     To open it, we go through
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.616.1">
      Performance Profiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.617.1">
     and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.618.1">
      Database
     </span>
    </strong>
    <span class="koboSpan" id="kobo.619.1">
     , where we can combine it with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.620.1">
      CPU Usage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.621.1">
     for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      more insight.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer108">
     <span class="koboSpan" id="kobo.623.1">
      <img alt="Figure 4.18 – Selecting the Database and CPU Usage tools" src="image/B22218_04_18.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.624.1">
     Figure 4.18 – Selecting the Database and CPU Usage tools
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.625.1">
     When we click on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.626.1">
      Start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.627.1">
     button, the profiler will launch our application and start collecting data.
    </span>
    <span class="koboSpan" id="kobo.627.2">
     During this time, we can perform long-running actions on our application to identify the root cause
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.628.1">
      of latency.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     After clicking on
    </span>
    <a id="_idIndexMarker344">
    </a>
    <span class="koboSpan" id="kobo.630.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.631.1">
      Stop Collection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.632.1">
     button, we launch the generation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      the report.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer109">
     <span class="koboSpan" id="kobo.634.1">
      <img alt="Figure 4.19 – Database report" src="image/B22218_04_19.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.635.1">
     Figure 4.19 – Database report
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     The database report will show us a table with information about queries executed; by default, it shows columns with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      following information:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.638.1">
      The start time of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.639.1">
       the query
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.640.1">
      The SQL code of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.641.1">
       the query
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.642.1">
      The duration
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.643.1">
       of execution
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.644.1">
      The number of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.645.1">
       records affected
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.646.1">
      The number of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.647.1">
       records reads
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.648.1">
     In larger applications, we can incorporate multiple databases, such as when utilizing the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.649.1">
      Command-Query Responsibility Segregation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.650.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.651.1">
      CQRS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.652.1">
     ) pattern
    </span>
    <a id="_idIndexMarker345">
    </a>
    <span class="koboSpan" id="kobo.653.1">
     alongside database replication, for example.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     To help us in our investigation, we can display three more columns by right-clicking on the display one and checking which one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.654.1">
      we need.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer110">
     <span class="koboSpan" id="kobo.655.1">
      <img alt="Figure 4.20 – Database report managing column" src="image/B22218_04_20.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.656.1">
     Figure 4.20 – Database report managing column
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.657.1">
     The additional
    </span>
    <a id="_idIndexMarker346">
    </a>
    <span class="koboSpan" id="kobo.658.1">
     columns are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.659.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.660.1">
        Database
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.661.1">
        Connection String
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.662.1">
       Query Source
      </span>
     </strong>
     <span class="koboSpan" id="kobo.663.1">
      displaying the data provider used (EFCore, Dapper, ADO.NET,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.664.1">
       or Others)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.665.1">
     Coupling with the CPU Usage tools, we can easily zoom on the consuming period to examine query launch in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.666.1">
      this time.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer111">
     <span class="koboSpan" id="kobo.667.1">
      <img alt="Figure 4.21 – Database report time filtered" src="image/B22218_04_21.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.668.1">
     Figure 4.21 – Database report time filtered
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.669.1">
     When we identify a
    </span>
    <a id="_idIndexMarker347">
    </a>
    <span class="koboSpan" id="kobo.670.1">
     query that might catch our attention due to its long transaction duration or large number of associated queries, we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.671.1">
      could investigate.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.672.1">
     Finally, in the list of queries, we can easily jump into the code source for further investigations or even refactoring, by right-clicking on the row we are interested in and selecting
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.673.1">
      Go To
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.674.1">
       Source File
      </span>
     </strong>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer112">
     <span class="koboSpan" id="kobo.675.1">
      <img alt="Figure 4.22 – Go To Source File" src="image/B22218_04_22.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.676.1">
     Figure 4.22 – Go To Source File
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.677.1">
     The power of
    </span>
    <a id="_idIndexMarker348">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     Visual Studio profiling tools lies in the ability to combine some of its tools for a comprehensive investigation.
    </span>
    <span class="koboSpan" id="kobo.678.2">
     My advice is to utilize the three tools highlighted in this chapter: the Memory Usage, CPU Usage, and Database tools.
    </span>
    <span class="koboSpan" id="kobo.678.3">
     This will help in quickly identifying issues such as queries that generate excessive memory allocation and CPU utilization, especially
    </span>
    <a id="_idIndexMarker349">
    </a>
    <span class="koboSpan" id="kobo.679.1">
     when working with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.680.1">
      Object Relational Mapping
     </span>
    </strong>
    <span class="koboSpan" id="kobo.681.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.682.1">
      ORMs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.683.1">
     ), such as EF Core or Dapper, that need to instantiate objects to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.684.1">
      run queries.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-90">
    <a id="_idTextAnchor090">
    </a>
    <span class="koboSpan" id="kobo.685.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     This chapter provided key insights to leverage Visual Studio profiling tools to aid in our investigation and optimization of performance bottlenecks, resulting in improved
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.687.1">
      application performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.688.1">
     Throughout this chapter, we’ve covered a range of topics, from understanding the fundamentals of performance optimization to utilizing Visual Studio’s profiling tools effectively.
    </span>
    <span class="koboSpan" id="kobo.688.2">
     We’ve learned how to analyze CPU usage and identify memory and database bottlenecks to identify and optimize critical sections and our code base for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.689.1">
      improved performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.690.1">
     As we conclude this chapter, we mark the end of the first part of our journey in mastering core development skills.
    </span>
    <span class="koboSpan" id="kobo.690.2">
     From unit testing and TDD to advanced debugging strategies, code analysis, and now performance optimization and profiling, you have laid a solid foundation for your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.691.1">
      development journey.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.692.1">
     In the upcoming chapters, we’ll continue to expand our horizons, delving into advanced topics such as multi-platform app UI development, advanced web development tools, machine learning integration, and advanced cloud integration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.693.1">
      and services.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.694.1">
     To start the second part, we will dive into the world of cross-platform development by exploring tools offered by Visual Studio
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.695.1">
      for MAUI.
     </span>
    </span>
   </p>
  </div>
 

  <div class="Content" id="_idContainer114">
   <h1 id="_idParaDest-91" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor091">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 2: Advancing Development Horizons
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In this second part, we focus on expanding your development expertise with advanced techniques for building versatile applications leveraging Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     From multi-platform app UI development and advanced web tools to machine learning integration and cloud services, these chapters equip you with the skills to build modern, scalable, and intelligent applications, pushing the boundaries of your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.3.1">
      development capabilities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22218_05.xhtml#_idTextAnchor092">
      <em class="italic">
       <span class="koboSpan" id="kobo.6.1">
        Chapter 5
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.7.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.8.1">
       Multi-Platform App UI Development
      </span>
     </em>
    </li>
    <li>
     <a href="B22218_06.xhtml#_idTextAnchor112">
      <em class="italic">
       <span class="koboSpan" id="kobo.9.1">
        Chapter 6
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.10.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.11.1">
       Advanced Web Development Tools
      </span>
     </em>
    </li>
    <li>
     <a href="B22218_07.xhtml#_idTextAnchor124">
      <em class="italic">
       <span class="koboSpan" id="kobo.12.1">
        Chapter 7
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.13.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.14.1">
       Machine Learning Integration
      </span>
     </em>
    </li>
    <li>
     <a href="B22218_08.xhtml#_idTextAnchor132">
      <em class="italic">
       <span class="koboSpan" id="kobo.15.1">
        Chapter 8
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.16.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.17.1">
       Advanced Cloud Integration and Services
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer115">
   </div>
  </div>
 </body></html>