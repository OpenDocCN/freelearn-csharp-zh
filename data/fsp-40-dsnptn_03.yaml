- en: Chapter 3.  Basic Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 基本函数
- en: 'In this chapter, I''ll cover the core element of the program code built with
    the functional paradigm, that is, **function** . The notion of a function is ubiquitous
    indeed. In the world around us, it may mean plenty of things, from purpose of
    something to dependency and to work in a certain manner. But here, I will consider
    it through the prism of computer programming, where a function generally means
    a method of computing results based on inputs. This examination is going to include
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍使用函数范式构建的程序代码的核心元素，即**函数**。函数的概念确实无处不在。在我们周围的世界中，它可能意味着很多事物，从某物的目的到依赖关系，以及以某种方式工作。但在这里，我将通过计算机编程的棱镜来考虑它，其中函数通常意味着基于输入计算结果的方法。这次考察将包括以下内容：
- en: The notion of a function, the function definition and type signature, pure functions,
    referential transparency, and side effects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的概念、函数定义和类型签名、纯函数、引用透明性以及副作用
- en: 'Function parameters and arguments: a special type `unit` , the parameter number
    and type, the return value and type, currying, partial function application'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数和参数：特殊类型`unit`、参数数量和类型、返回值和类型、柯里化、部分函数应用
- en: Higher-order functions, functions as arguments and return values, anonymous
    functions, functions as data type constituents, and functions as interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数、函数作为参数和返回值、匿名函数、函数作为数据类型组成部分以及函数作为接口
- en: Closures, mutable values, and reference cells
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包、可变值和引用单元格
- en: Type inference and inferred versus explicit types of function components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断和函数组件的推断类型与显式类型
- en: Recursive function basics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数基础
- en: Operators as functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符作为函数
- en: Composing functions and combinators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合和组合子
- en: As my ultimate goal is to make you embrace the REPL-based development style
    and spirit inherent to idiomatic F#, I'm going to run each and every mentioned
    feature through FSI in order to demonstrate the cause and effect.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的最终目标是让你接受与REPL开发风格和F#惯用语的内在精神，我将通过FSI运行每个提到的功能，以展示原因和结果。
- en: The notion of function in F#
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#中函数的概念
- en: 'Let''s begin with an intuitive definition of a function that many of us heard
    in school algebra class: function is a relationship that for each valid input
    yields a single consistent result. Such definition is a good enough to reflect
    both the commonality and the difference of functions and relations. In mathematics,
    a function is a relation, although not each relation is a function, as a relation
    may represent multiple results for the same single input. In the following figure,
    relation **Rij** on the left side is just fine for the representation of a function,
    as any item from set **I** maps to the one and only one item of set **J** . However,
    relation **Rxy** on the right side of the same figure cannot represent a function
    as at least one item of **X** exists, which maps to more than one item of **Y**
    , which is indicated by red mapping arrows.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们在学校代数课上听到的函数的直观定义开始：函数是一种关系，对于每个有效输入都产生一个单一一致的结果。这样的定义足以反映函数和关系的共性和差异。在数学中，函数是一种关系，尽管并非每个关系都是函数，因为关系可能代表相同单个输入的多个结果。在下面的图中，左侧的关系**Rij**非常适合表示函数，因为集合**I**中的任何元素都映射到集合**J**中的唯一一个元素。然而，同一图右侧的关系**Rxy**不能表示函数，因为至少存在一个**X**中的元素，它映射到**Y**中的多个元素，这由红色的映射箭头所示。
- en: '![The notion of function in F#](img/Image00006.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![F#中函数的概念](img/Image00006.jpg)'
- en: Relations and functions
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关系和函数
- en: Another very important matter is the mapping consistency. Any function, when
    being repeatedly given the same input must yield the same result.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的问题是映射的一致性。任何函数，当被反复给出相同的输入时，必须产生相同的结果。
- en: Following our intuition, a function in programming languages, including F#,
    represents a computation where the result is determined by performing a transformation
    of a valid input. As with any concrete computation, it consumes some memory and
    certain time to complete and carries some kind of behavior. And the behavior,
    the way of the computation, and the manner of the transformation in turn is determined
    by the function definition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循我们的直觉，在编程语言中，包括F#，一个函数代表一种计算，其结果是通过对有效输入进行转换来确定的。与任何具体的计算一样，它消耗一些内存和一定的时间来完成，并携带某种行为。而这种行为，计算的方式，以及转换的方式，反过来是由函数定义决定的。
- en: The function definition
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数定义
- en: 'In general, the F# function carries a name, has a parameter(s), returns a result
    of some type, and has a body. The following figure illustrates the coupling of
    these components. A function resembles an opaque box performing some transformation
    of the input to the output. It hides the specific details of how the transformation
    is exactly performed, declaring only the purpose and the signature to the world,
    in other words, types of input and output. The function may be turned to a white
    transparent box if its definition is available, ripping the opaque box apart and
    revealing the details of implementation. However the definition may or may not
    be available; the latter case is typical for libraries and modules (remember the
    hiding of moving parts). I intentionally used input in place of parameter(s);
    I''ll later show that functions of multiple parameters can be presented with functions
    of just a single parameter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，F# 函数具有一个名称，有参数（s），返回某种类型的结果，并且有一个主体。以下图展示了这些组件的耦合。函数类似于一个不透明的盒子，对输入进行某种转换以产生输出。它隐藏了转换是如何具体执行的细节，只向世界声明了目的和签名，换句话说，输入和输出的类型。如果函数的定义可用，函数可以被转换成一个白色透明的盒子，拆开不透明的盒子，揭示实现的细节。然而，定义可能可用也可能不可用；后一种情况对于库和模块来说是典型的（记住移动部件的隐藏）。我故意使用了输入而不是参数（s）；我稍后会展示多参数的函数可以用单参数的函数来表示：
- en: '![The function definition](img/Image00007.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![函数定义](img/Image00007.jpg)'
- en: Function components and the purpose
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件及其目的
- en: 'These function components are fastened together in a language syntax by binding
    a function value as shown in the following pseudocode:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数组件通过绑定函数值的方式，由语言语法连接在一起，如下面的伪代码所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding binding is not the only way of defining functions in F#; it may
    carry a few additional elements for special cases. I'll cover these missing details
    later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的绑定并不是在 F# 中定义函数的唯一方式；它可能为特殊情况携带一些额外的元素。我将在稍后介绍这些缺失的细节。
- en: 'Using the preceding syntax, we may, for example, define the F# function for
    the computing of the area of a circle of the given radius, as shown in the following
    code (`Ch3_1.fsx` ):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的语法，例如，我们可以定义 F# 函数来计算给定半径的圆的面积，如下面的代码所示（`Ch3_1.fsx`）：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `System.Math.PI` is a field of the .NET `System.Math` class representing
    the ratio of the circumference of a circle to its diameter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`System.Math.PI` 是 .NET `System.Math` 类的一个字段，表示圆的周长与其直径的比值。
- en: 'Executing the function defined as such with the argument value `5.0` for the
    radius parameter in FSI yields the following result:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FSI 以半径参数的 `5.0` 作为参数值执行这样定义的函数，得到以下结果：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is worth noting that F# does not introduce any keyword to return the function
    result. The result is just the value of the last expression calculated within
    the function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，F# 没有引入任何关键字来返回函数结果。结果只是函数内部计算出的最后一个表达式的值。
- en: The function type signature
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型签名
- en: 'Let''s enter the sole name of the `circleArea` function into FSI, as shown
    in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 FSI 中输入 `circleArea` 函数的唯一名称，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The FSI response represents the `circleArea` type signature, (`float -> float`
    ), which means that it is a function that takes the argument of type `float` and
    returns the result of type `float` . This function type signature is very simple.
    As we dive deeper , we'll examine more complex examples of function signatures.
    I'll show you that reading and understanding them is an absolutely essential skill
    for a functional programmer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: FSI 的响应表示 `circleArea` 函数的类型签名（`float -> float`），这意味着它是一个接受类型为 `float` 的参数并返回类型为
    `float` 的结果的函数。这个函数类型签名非常简单。随着我们深入探讨，我们将检查更复杂的函数签名示例。我会向你展示阅读和理解它们对于函数式程序员来说是一项绝对必要的技能。
- en: 'Another detail that an attentive reader may have already spotted is this: how
    did the F# compiler jump to the conclusion that the type of `radius` is `float`
    ? For now, just take my word that the compiler derived this following a deterministic
    procedure named `type inference` . It plays an outstanding role in decreasing
    the amount of bugs in the F# code and also attributes to code succinctness. F#
    implements a very specific manner of statically inferring types called **Hindley-Milner
    type inference algorithm** ([https://en.wikipedia.org/wiki/Type_inference](https://en.wikipedia.org/wiki/Type_inference)
    ). I will devote substantial attention to the inferring of types later in the
    chapter.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细心的读者可能已经注意到的细节是：F# 编译器是如何得出`radius`的类型是`float`的结论的？目前，请相信我，编译器是根据名为`类型推断`的确定性过程推断出以下内容的。它在减少
    F# 代码中的错误数量以及代码简洁性方面发挥着重要作用。F# 实现了一种非常具体的静态类型推断方式，称为**Hindley-Milner 类型推断算法**([https://en.wikipedia.org/wiki/Type_inference](https://en.wikipedia.org/wiki/Type_inference)
    )。我将在本章的后面部分对类型推断给予充分的关注。
- en: Pure functions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'A computer function implementation may or may not have this key property of
    the more abstract function notion: the consistency of repeatedly returning the
    same result when being given the same argument(s). The `circleArea` function defined
    previously, apparently carries this property. It does not depend on anything beyond
    its arguments and definition and does not change anything around beyond simply
    returning an idempotent result. Functions that have these useful properties are
    considered **pure** , or **referentially transparent** ([https://en.wikipedia.org/wiki/Referential_transparency](https://en.wikipedia.org/wiki/Referential_transparency)
    ); otherwise, they depend on something or have side effects and are hence **impure**
    .'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机函数实现可能具有或不具有更抽象函数概念的关键属性：在给出相同的参数（s）时重复返回相同的结果的一致性。之前定义的`circleArea`函数显然具有这种属性。它不依赖于其参数和定义之外的任何东西，并且不会改变任何东西，只是简单地返回一个幂等结果。具有这些有用属性的函数被认为是**纯函数**，或**引用透明**([https://en.wikipedia.org/wiki/Referential_transparency](https://en.wikipedia.org/wiki/Referential_transparency)
    )；否则，它们依赖于某些东西或具有副作用，因此是**非纯函数**。
- en: 'Let me demonstrate a simple impure function, in the following code (`Ch3_1.fsx`
    ):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我演示一个简单的非纯函数，以下代码（`Ch3_1.fsx`）中：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the preceding code in FSI yields the following result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FSI 中运行上一行代码会得到以下结果：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, the `opaque` impurity gets apparent from simply observing its subsequent
    calls with repeated arguments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过简单地观察其后续使用重复参数的调用，`opaque` 杂质变得明显。
- en: Function parameters and arguments
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数和参数
- en: 'In our sample function definition given by the following code (`Ch3_1.fsx`
    ):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码（`Ch3_1.fsx`）给出的示例函数定义中：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `radius` identifier represents the function **parameter** , that is, the
    name for a value that is expected to be transformed by the function. The value
    supplied for the parameter upon the function use represents the function **argument**
    , as shown when we apply our function in the following code line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`radius` 标识符代表函数**参数**，即函数期望转换的值的名称。在函数使用时提供的参数值代表函数**参数**，如下所示，当我们应用以下代码行中的函数时：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`15.0` is the function''s argument in the preceding line.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`15.0` 是上一行函数的参数。'
- en: The tuples preview
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组预览
- en: At this point, in order to reveal the further details about function parameters,
    a certain notion would be required, which logically belongs to a completely different
    language facility, specifically to data types. I'm talking about **tuples** .
    As it doesn't seem feasible to build an ideally straight storyline, I will provide
    a necessary preview here and then revisit the subject of tuples in later chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，为了揭示关于函数参数的更多细节，需要某种概念，这在逻辑上属于完全不同的语言功能，具体来说是数据类型。我正在谈论**元组**。由于似乎不可能构建一个理想的直线故事线，我将在这里提供必要的预览，然后在后续章节中重新探讨元组的问题。
- en: A **tuple** ([https://msdn.microsoft.com/en-us/library/dd233200.aspx](https://msdn.microsoft.com/en-us/library/dd233200.aspx)
    ) is an immutable F# data type that represents a parenthesis enclosed, comma separated,
    ordered grouping of arbitrary values. That is, grouping assumes at least a pair
    of values. Types of these values are completely arbitrary, and it does not matter
    whether they are the same or not.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组**（[https://msdn.microsoft.com/en-us/library/dd233200.aspx](https://msdn.microsoft.com/en-us/library/dd233200.aspx)）是一种不可变的F#数据类型，它表示一个括号内、逗号分隔的、有序的任意值组合。也就是说，组合至少包含一对值。这些值的类型完全任意，它们是否相同无关紧要。'
- en: 'An example of a tuple is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元组的例子如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constituent value of a tuple can be represented by an expression as well,
    as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的构成值也可以用表达式表示，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I will wrap up this brief preview by covering what the tuple type signature
    looks like. It is built from types of constituents following the established order
    and separated by the `*` symbol. So following this arrangement, the type of tuple
    `dateParts` shown in the preceding code is `int*string*int` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过介绍元组类型签名来结束这个简短的预览。它是由按照既定顺序排列的构成类型组成的，并由`*`符号分隔。因此，按照这种安排，前面代码中显示的`dateParts`元组的类型是`int*string*int`。
- en: Special type unit
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊类型unit
- en: 'There is just another component of the functions realm, which comes from the
    distinction between computer programming functions and functions of mathematics.
    This is the special type with the sole purpose of denoting the absence of a parameter
    and/or result, namely `unit` . This type is the simplest imaginable and has just
    a single value, represented by just a pair of brackets that have nothing in between.
    The following is the representation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数领域还有一个组成部分，它来自计算机编程函数和数学函数之间的区别。这是唯一目的在于表示参数和/或结果缺失的特殊类型，即`unit`。这种类型是最简单可以想象的，只有一个值，由一对没有任何内容的括号表示。以下是其表示形式：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Nevertheless, `unit` plays the important role of the absence indicator. This
    absence may manifest itself as shown in the following function definition, which
    can be a poor man''s generator of random numbers between 0 and 1000 (`Ch3_1.fsx`
    ):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`unit`在表示缺失指示符方面发挥着重要作用。这种缺失可能表现为以下函数定义，它可以是一个生成0到1000之间随机数的穷举法（`Ch3_1.fsx`）：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you consider the preceding binding, then having `()` after `getNextRandom`
    is the only way to disambiguate the function binding that denotes the calculation
    process from just a value binding denoting the result of a single calculation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑前面的绑定，那么在`getNextRandom`后面有`()`是唯一区分表示计算过程的函数绑定和表示单个计算结果的值绑定的方法。
- en: 'Indeed, if I run both binding variants using FSI, the difference should be
    memorable: without a `unit` parameter, `getNextRandom` is bound to just an immutable
    `int64` value; otherwise, it is bound to a function that has the (`unit -> int64`
    ) signature, and after being repeatedly called, it returns a different result
    each time. The following screenshot captures this distinction:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我用FSI运行这两个绑定变体，差异应该是值得记忆的：没有`unit`参数时，`getNextRandom`绑定到一个不可变的`int64`值；否则，它绑定到一个具有（`unit
    -> int64`）签名的函数，并且每次被反复调用后，它都会返回不同的结果。以下截图捕捉了这个区别：
- en: '![Special type unit](img/Image00008.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![特殊类型unit](img/Image00008.jpg)'
- en: The argument unit differentiates between the value and function bindings
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单位参数区分了值绑定和函数绑定
- en: 'The similarly interesting case has place when `unit` is a value of expression
    returned from a function. Intuition should prompt you that if a function returns
    nothing, or rather `()` , then its purpose could be to induce a side effect. Let''s
    slightly change the definition of `getNextRandom` as shown in the following code
    (`Ch3_1.fsx` ):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当`unit`是函数返回的表达式的值时，也有一个类似有趣的案例。直观上应该会提示你，如果一个函数返回空值，或者说`()`，那么它的目的可能是引起副作用。让我们稍微改变`getNextRandom`的定义，如下面的代码（`Ch3_1.fsx`）所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, the function signature turns to (`unit -> unit` ), and calling it, just
    outputs a random number between 0 and 999, returning the result of type `unit`
    .
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数签名变为（`unit -> unit`），调用它，仅输出0到999之间的随机数，返回类型为`unit`。
- en: Currying and partial function application
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柔性函数和部分函数应用
- en: 'Let''s define a simple function, `myPrintFunC` , which takes a `string` and
    an `int` as parameters and returns `unit` as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的函数，`myPrintFunC`，它接受一个`string`和一个`int`作为参数，并返回`unit`，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The type of `myPrintFunC` is (`string -> int -> unit` ).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`myPrintFunC` 的类型是 (`string -> int -> unit` )。'
- en: 'Another, almost similar, simple function is `myPrintFunT` , which also takes
    a `string` and an `int` as parameters and returns `unit` , but the parameters
    are tupled as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个几乎相同且简单的函数是 `myPrintFunT`，它也接受一个 `string` 和一个 `int` 作为参数，并返回 `unit`，但参数的打包方式如下所示：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The type of `myPrintFunT` is (`string*int -> unit` ).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`myPrintFunT` 的类型是 (`string*int -> unit` )。'
- en: Applying `myPrintFunC` `"The Answer is" 42` outputs `The Answer is 42` . Similarly,
    applying `myPrintFunT ("The Answer is", 42)` outputs `The Answer is 42` too. So
    what's the fuss about?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 `myPrintFunC` `"The Answer is" 42` 输出 `The Answer is 42`。同样，应用 `myPrintFunT
    ("The Answer is", 42)` 也输出 `The Answer is 42`。那么，为什么会有这么大的争议呢？
- en: 'The fundamental distinction is in the manner in which these functions accept
    their arguments: arguments of `myPrintFunC` are curried, but arguments of `myPrintFunT`
    are tupled.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的区别在于这些函数接受参数的方式：`myPrintFunC` 的参数是柯里化的，但 `myPrintFunT` 的参数是打包的。
- en: 'Because of being familiar with tuples, you should not be surprised that `let
    t = ("The Answer is", 42)` in `myPrintFunT` outputs the same result: `The Answer
    is 42` . The signature of `myPrintFunT` prompted us of the single function parameter
    of the type `string*int` tuple.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于熟悉元组，你不会对 `myPrintFunT` 中的 `let t = ("The Answer is", 42)` 输出相同的结果：`The Answer
    is 42` 感到惊讶。`myPrintFunT` 的签名让我们想起了类型为 `string*int` 的单一函数参数。
- en: 'The case of `myPrintFunC` is more interesting. The arrow `->` in its signature
    is the right associative operation, so I can rewrite its signature as (`string
    -> (int -> unit)` ), correct? But wait a minute; isn''t (`int -> unit` ) representing
    a function that takes the `int` parameter and returns `unit` ? Yes, it does. So,
    getting back to `myPrintFunC` , why can''t I consider it as a function that takes
    the `string` parameter and returns a new interim function, in turn taking the
    `int` parameter and returning `unit` ? In the end, functions are first-class entities
    in F#, so a returned value can be of the function type. Now let''s turn back to
    the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`myPrintFunC` 的情况更有趣。其签名中的箭头 `->` 是右结合操作，因此我可以将其签名重写为 (`string -> (int -> unit)`
    )，对吗？但是等等；(`int -> unit` ) 不不正是表示一个接受 `int` 参数并返回 `unit` 的函数吗？是的，它确实如此。所以，回到 `myPrintFunC`，为什么我不能将其视为一个接受
    `string` 参数并返回一个新的中间函数的函数，该中间函数再接受 `int` 参数并返回 `unit` 呢？最后，函数在 F# 中是一等公民，所以返回值可以是函数类型。现在让我们回到以下代码：'
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This still returns `The Answer is 42` . And in order to make the mechanics
    fully transparent, let''s play the preceding transformation step by step in FSI:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然返回 `The Answer is 42`。为了使机制完全透明，让我们在 FSI 中逐步执行前面的转换步骤：
- en: '![Currying and partial function application](img/Image00009.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Currying and partial function application](img/Image00009.jpg)'
- en: Partial function application
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数应用
- en: As the preceding screenshot illustrates, the `myPrintFunC` function is originally
    defined as having two parameters. When it is applied just to the first argument,
    it returns another function, `interimFun` , which has just one parameter that,
    if in turn is applied to the second argument, returns exactly the same result
    as the original function applied to both arguments. As may be expected, the result
    is `The Answer is 42` ; the fans of Douglas Adams already knew this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，`myPrintFunC` 函数最初定义为具有两个参数。当它仅应用于第一个参数时，它返回另一个函数，`interimFun`，它只有一个参数，如果将其应用于第二个参数，将返回与原始函数应用于两个参数时完全相同的结果。正如预期的那样，结果是
    `The Answer is 42`；道格拉斯·亚当斯的粉丝已经知道了这一点。
- en: My congratulations to you; you just grasped one of the utterly important techniques
    of functional programming, namely,  **partial function application** . Partial
    application is achieved by simply omitting one or more trailing function arguments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 向你表示祝贺；你刚刚掌握了函数式编程中极其重要的技术之一，即 **部分函数应用**。部分应用通过简单地省略一个或多个后续函数参数来实现。
- en: So, **currying** is built on the principle of partial function application.
    Any function definition of multiple parameters in a curried form is just a syntactic
    sugar for the process of currying, implicitly transforming the original definition
    to a composition of functions, each comprising one parameter. Currying is the
    default feature of F#; it makes partial function application available anytime.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**柯里化**建立在部分函数应用的原则之上。任何以柯里化形式定义的多参数函数定义只是柯里化过程的语法糖，隐式地将原始定义转换为函数的组合，每个函数包含一个参数。柯里化是
    F# 的默认特性；它使得部分函数应用随时可用。
- en: The number and the type of function parameters and return values
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数的数量和类型以及返回值
- en: 'I want to reiterate the earlier findings in relation to the F# functions parameters
    and return value in order to leave you with a very simple mental model, that is:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要重申之前关于F#函数参数和返回值的发现，以便给你留下一个非常简单的心理模型，那就是：
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All F# functions have a single parameter and return a single result.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有F#函数都有一个单一参数并返回一个单一结果。
- en: Functions without parameters and/or without a return value fit this model using
    a `unit` value in place of the omitted entities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数和/或没有返回值的函数使用`unit`值代替省略的实体。
- en: Functions with multiple parameters and multiple return values may fit the preceding
    model by making the parameters and return values into a single tuple each.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个参数和多个返回值的函数可以通过将参数和返回值合并成一个元组来适应前面的模型。
- en: Functions that have multiple parameters in a curried form fit the singular parameter
    model via a recurrent transformation into a function, taking the first argument
    and returning the new function that has this argument partially applied.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以柯里化形式具有多个参数的函数通过将第一个参数作为输入并返回一个新函数，该函数具有部分应用的这个参数，从而通过重复转换适应单个参数模型。
- en: Further fine grain details to the preceding principle come from the .NET side,
    when we deal with not only pristine F# functions, but also with static and instance
    methods of .NET libraries and our custom types. These will be covered in later
    chapters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面原则的更细致的细节来自.NET方面，当我们不仅处理原始的F#函数，还处理.NET库和我们的自定义类型的静态和实例方法时。这些内容将在后面的章节中介绍。
- en: Higher-order functions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: I've mentioned on many occasions that functions are first-class entities in
    F# because they can be used as arguments for other functions or can be returned
    from other functions as results. This is exactly the indication of higher-order
    functions. A higher-order function may have another function as a parameter, it
    may return another function as a result, or it may perform both these things.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我在很多场合提到过，函数在F#中是一等实体，因为它们可以用作其他函数的参数，或者可以从其他函数作为结果返回。这正是高阶函数的指示。一个高阶函数可能有一个函数作为参数，它可能返回另一个函数作为结果，或者它可能同时执行这两件事。
- en: All functions are considered function values in F#; this treatment allows you
    to not make any distinction between functions and other kinds of values in any
    context where values are used. I will cover some such contexts here, namely an
    argument to another function, a value returned from a function, and a part of
    a data structure.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，所有函数都被视为函数值；这种处理方式允许你在任何使用值的环境中不区分函数和其他类型的值。我将在这里介绍一些这样的环境，即作为另一个函数的参数、从函数返回的值以及数据结构的一部分。
- en: Anonymous functions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: In some situations, it makes sense to have the ability of defining a function
    that does not carry the explicit name. Typically, such an ability is nice to have
    for functions that are the subject of manipulation by higher-order functions.
    A concise way to set arguments or results that does not involve a full blown function
    definition is required. Why is that? The first consideration that comes to my
    head is that the name may be needed for the future reference. If a function is
    defined by the name and then this name is referred multiple times from other locations
    of the program code, then this function that has a name makes perfect sense. On
    the contrary, if the function is defined as an argument of a higher-order function
    and is never used outside this single occurrence, then the name is redundant.
    Another consideration is the use of function values; for example, using a function
    as an argument to another function may not require any name for the former.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，定义一个没有显式名称的函数是有意义的。通常，这种能力对于被高阶函数操作的函数来说是非常有用的。需要一种简洁的方式来设置参数或结果，而不涉及完整的函数定义。为什么需要这样呢？首先考虑的是，名称可能需要用于未来的引用。如果一个函数通过名称定义，并且这个名称在程序代码的其他位置被多次引用，那么这个有名称的函数就非常有意义。相反，如果一个函数作为高阶函数的参数定义，并且从未在这个单一出现之外使用，那么这个名称就是多余的。另一个考虑因素是函数值的用法；例如，将一个函数作为另一个函数的参数使用可能不需要为前者命名。
- en: 'The syntax to define an anonymous function is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 定义匿名函数的语法如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `parameter-list` represents tupled or curried parameter names, optionally
    carrying explicit parameter types. Note that anonymous functions defined with
    the `fun` keyword represent a **lambda expression** ([https://msdn.microsoft.com/en-us/library/dd233201.aspx](https://msdn.microsoft.com/en-us/library/dd233201.aspx)
    ). A lambda expression has the value represented by the anonymous function. Realizing
    this tidbit is important in order to understand the first-class treatment of functions
    in F#.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`parameter-list` 代表成对或柯里化的参数名称，可选地带有显式的参数类型。请注意，使用 `fun` 关键字定义的匿名函数代表一个
    **lambda 表达式** ([https://msdn.microsoft.com/en-us/library/dd233201.aspx](https://msdn.microsoft.com/en-us/library/dd233201.aspx)
    )。lambda 表达式具有匿名函数表示的值。理解这一点对于理解 F# 中函数的一等公民待遇非常重要。
- en: Functions as arguments
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为参数
- en: 'Functions as arguments is perhaps the most common use of functions in functional
    programs. Typical F# libraries are implemented as highly optimized sets of higher-order
    functions that can be tuned for any concrete task by providing specific functions
    as arguments. For example, a square scalar matrix 5 x 5 with main diagonal elements
    of 1s may be created using the `Array2D.init` library function. **Array2D.init**
    ([https://msdn.microsoft.com/en-us/library/ee353720.aspx](https://msdn.microsoft.com/en-us/library/ee353720.aspx)
    ) is a higher-order function that has a signature of (`int->int->(int->int->''T)->''T[,]`
    ), where the inner part of the signature represents the so-called **initializer**
    or the function that sets the individual elements of the matrix based on their
    indices. The following anonymous function for initializing the elements of a diagonal
    matrix according to their indices can be used:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为参数可能是函数式程序中最常见的用法。典型的 F# 库实现为高度优化的高阶函数集合，可以通过提供特定的函数作为参数来针对任何具体任务进行调整。例如，可以使用
    `Array2D.init` 库函数创建一个 5x5 的平方标量矩阵，其对角线元素为 1。**Array2D.init** ([https://msdn.microsoft.com/en-us/library/ee353720.aspx](https://msdn.microsoft.com/en-us/library/ee353720.aspx)
    ) 是一个高阶函数，其签名是 (`int->int->(int->int->'T)->'T[,]` )，其中签名的内部部分代表所谓的 **初始化器** 或根据索引设置矩阵各个元素的函数。以下匿名函数可以用来根据索引初始化对角矩阵的元素：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following screenshot demonstrates the achievement of this task in FSI by
    plugging the preceding function into the expression (`Ch3_2.fsx` ) as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图展示了在 FSI 中通过将前面的函数插入到表达式 (`Ch3_2.fsx` ) 中来完成此任务，如下所示：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Observe the sought-for matrix being built and shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 观察正在构建并显示的所求矩阵：
- en: '![Functions as arguments](img/Image00010.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![函数作为参数](img/Image00010.jpg)'
- en: Using an anonymous function as an argument to a higher-order function
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名函数作为高阶函数的参数
- en: Functions as return values
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为返回值
- en: 'As I mentioned in the function definition section, the function return value
    is just the value of the last expression. In order to return a function, we may
    use as the last expression of the host function: either an anonymous function
    definition, or a partial function application.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在函数定义部分提到的，函数的返回值只是最后一个表达式的值。为了返回一个函数，我们可以在宿主函数的最后一个表达式中使用：要么是一个匿名函数定义，要么是部分函数应用。
- en: Let's look into this matter by performing a harder exercise. Quite frequently,
    it helps to have a function that allows you to accurately measure the duration
    of the execution of an arbitrary calculation wrapped into some other function.
    Furthermore, it is also helpful to have the information about the environment
    baked into measurement results.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进行更难的练习来探讨这个问题。通常，有一个函数可以让你精确测量被其他函数包裹的任意计算的执行时间是非常有帮助的。此外，将环境信息嵌入到测量结果中也是非常有用的。
- en: So, I'm going to implement a higher-order function, `stopWatchGenerator` , which
    takes another function, `f` , with parameter, `x` , as its own arguments and returns
    a function value represented by an anonymous function with exactly the same signature.
    This anonymous function just wraps the calculation (`f x` ) with this calculation
    duration measurement taken with millisecond precision. It communicates the measured
    duration to the output device, accompanying it with the name of the main executable
    file. So, for 32-bit FSI, it would be just [`fsi` ]; for 64-bit FSI, it would
    be [`fsiAnyCPU` ]; and for a custom executable, it would be the name of the executable
    file. Sometimes, such utility can be pretty helpful, right?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将实现一个高阶函数`stopWatchGenerator`，它接受另一个函数`f`作为自己的参数，该函数具有参数`x`，并返回一个由匿名函数表示的函数值，该匿名函数具有完全相同的签名。这个匿名函数只是用这个以毫秒精度测量的计算持续时间包装了计算(`f
    x`)。它将测量的持续时间传达给输出设备，并附带主可执行文件的名字。所以，对于32位FSI，它将是`[fsi]`；对于64位FSI，它将是`[fsiAnyCPU]`；对于自定义可执行文件，它将是可执行文件的名字。有时，这样的实用工具可以非常有帮助，对吧？
- en: 'The implementation is given in the following code (`Ch3_3.fsx` ):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下面的代码所示(`Ch3_3.fsx`)：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Please note that I intentionally put explicit types for `stopWatchGenerator`
    arguments `f` , which is the function taking the argument of generic type `'a`
    and returning the result of generic type `'b` , and `x` , which is the value of
    type `'a` , and for the `stopWatchGenerator` return type, which is the function
    taking two curried arguments of types `('a->'b)` and `'a` and returning the result
    of type `'b` .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我故意为`stopWatchGenerator`的参数`f`（这是一个接受泛型类型`'a`的参数并返回泛型类型`'b`的结果的函数）和`x`（它是类型`'a`的值），以及`stopWatchGenerator`的返回类型（它是一个接受类型`('a->'b)`和`'a`的两个柯里化参数的函数，并返回类型`'b`的结果的函数）指定了显式类型。
- en: Does your head begin spinning yet? This is fine, please stay assured that you
    will get accustomed to these seemingly complicated manipulations and will soon
    find them as easy as apple pie.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你的头开始转了吗？这是正常的，请放心，你会逐渐习惯这些看似复杂的操作，并且很快会发现它们就像苹果派一样简单。
- en: The function `stopWatchGenerator` returns the sought anonymous function using
    the `fun` lambda expression, which creates the instance of .NET `System.Diagnostics.Stopwatch()`
    and wraps its start and take readings around the evaluation of the target expression
    (`f x` ).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`stopWatchGenerator`使用`fun` lambda表达式返回所需的匿名函数，该表达式创建.NET `System.Diagnostics.Stopwatch()`的实例，并在评估目标表达式(`f
    x`)的周围包装其开始和读取。
- en: The function `whatItTakes` is just a convenient abbreviation for the arrangement
    with function evaluation shadow timing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`whatItTakes`只是函数评估阴影计时安排的一个方便缩写。
- en: 'The following screenshot shows two examples of using the generated function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了使用生成的函数的两个示例：
- en: '![Functions as return values](img/Image00011.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![函数作为返回值](img/Image00011.jpg)'
- en: A function returning another function in action
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 返回另一个函数的函数的实际应用
- en: 'The first use case checks how much time is required in order to produce and
    add together the first 10 million positive numbers as shown in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用例检查了生成并累加前1000万个正数所需的时间，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second use case demonstrates a way of calculating the pi with certain precision
    by applying the ****Gregory series**** ([http://mathworld.wolfram.com/GregorySeries.html](http://mathworld.wolfram.com/GregorySeries.html)
    ) method, using an arbitrary series length as shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用例演示了通过应用**Gregory级数**([http://mathworld.wolfram.com/GregorySeries.html](http://mathworld.wolfram.com/GregorySeries.html))方法，使用任意系列长度来计算一定精度的π的方法，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the results indicate, the Gregory series is not the greatest formula for
    the calculation of pi; nevertheless, it can serve the purpose of demonstrating
    the power of function values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如结果所示，Gregory级数并不是计算π的最佳公式；然而，它可以用来展示函数值的强大功能。
- en: Functions as data type constituents
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为数据类型组成部分
- en: 'Now, you may come up with a crafty question: "Values of primitive types may
    be combined into more complex types; for example, a handful of `int` values can
    be stored in an `int` array. If functions are really first-class values, they
    should allow a similar kind of composition as well. How about constructing an
    array of functions?"'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会有一个狡猾的问题：“原始类型值可以组合成更复杂类型；例如，一些`int`值可以存储在一个`int`数组中。如果函数真的是一等值，它们应该允许类似的组合。那么，构建一个函数数组怎么样？”
- en: 'My answer is: "Sure, why not?" Let''s consider the following function definition
    (`Ch3_4.fsx` ):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我的回答是：“当然，为什么不呢？”让我们考虑以下函数定义（`Ch3_4.fsx`）：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function `apply` takes two arguments, and if the first one, `case` , is
    in the range of `0` to `3` , it applies the corresponding math library trigonometry
    function to the second argument, `arg` . Otherwise, it just returns the `arg`
    value unchanged, just a dull no-brainer implementation. Let''s spice it up by
    arranging the functions into the array as shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数接受两个参数，如果第一个参数`case`在`0`到`3`的范围内，它将对第二个参数`arg`应用相应的数学库三角函数。否则，它只返回未更改的`arg`值，这是一个平淡无奇的实现。让我们通过以下代码将函数排列成数组来增加一些趣味：'
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I've used the F# `try...with` construction in order to sift instances of case
    values that require the specific function application from those that return just
    the `arg` echo.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了F#的`try...with`结构来筛选出需要特定函数应用的情况值实例，以及那些只返回`arg`回声的实例。
- en: This is achieved with the `[|sin; cos; asin; acos|]` construction that has the
    (`float -> float` ) `[]` signature. This means exactly what was expected, or an
    array of functions of the same type (taking the single argument of type `float`
    and returning a result of type `float` ). Each array element position is tied
    with the specific function instance with the help of the `[case]` indexer, or
    `[|sin; cos; asin; acos|]` `.[0]` yields `sin` , `[|sin; cos; asin; acos|]` `.[1]`
    yields `cos` , and so on. The value of the `[|sin; cos; asin; acos|].[case]` expression
    is a function where the case value is in the valid range of `0` to `3` . As such,
    it can be applied to `arg` , yielding the corresponding result. The `case` value
    out of the valid range entails the `System.IndexOutOfRangeException` exception
    and is caught and processed by simply returning the echoed value of `arg` . I
    must admit that abusing the exception mechanism the way it is done above is awful
    coding practice, but please forgive me for using it within the toy example while
    demonstrating some totally unrelated feature.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`[|sin; cos; asin; acos|]`结构实现的，它具有（`float -> float`）`[]`签名。这意味着正好符合预期，或者是一个相同类型的函数数组（接受类型为`float`的单个参数并返回类型为`float`的结果）。每个数组元素位置都与特定的函数实例相关联，通过`[case]`索引器，或者`[|sin;
    cos; asin; acos|]``.[0]`返回`sin`，`[|sin; cos; asin; acos|]``.[1]`返回`cos`，依此类推。`[|sin;
    cos; asin; acos|].[case]`表达式的值是一个函数，其中情况值在`0`到`3`的有效范围内。因此，它可以应用于`arg`，得到相应的结果。超出有效范围的情况值将引发`System.IndexOutOfRangeException`异常，并通过简单地返回`arg`的回声值来捕获和处理。我必须承认，像上面那样滥用异常机制是糟糕的编码实践，但请原谅我在演示一些完全无关的功能时在玩具示例中使用它。
- en: Functions are interfaces
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是接口
- en: 'In the light of the dual nature of F# being a functional-first language and
    at the same time supporting an object-oriented type system of .NET, it is worth
    taking a look at the relationship between functions and interfaces. The original
    **Gang of Four book** ([http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)
    ) points to the following principle of reusable object-oriented design in its
    introduction:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到F#作为以函数优先的语言，同时支持.NET的面向对象类型系统，值得探讨函数与接口之间的关系。原版的《设计模式：可复用面向对象软件的基础》（[http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)）在其引言中指出了以下可复用面向对象设计的原则：
- en: '*Program to an interface, not an implementation.*'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*针对接口编程，而不是针对实现。*'
- en: From this standpoint, a function is the quintessence of an interface. While
    in the object-oriented world, an interface must be explicitly declared prior to
    one of its implementations may be substituted by another, in the functional programming
    realm, this declaration is excessive. As long as two or more functions have the
    same signatures, they may be used interchangeably in the code. Function signature
    is the equivalent of the interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，函数是接口的精髓。在面向对象的世界里，接口必须在其实施之前被显式声明，以便另一个实现可以被替换，而在函数式编程领域，这种声明是多余的。只要两个或多个函数具有相同的签名，它们就可以在代码中互换使用。函数签名相当于接口。
- en: My previous example with the array of functions clearly demonstrates how the
    change of implementation can be achieved as simply as through changing the array
    element index value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前的函数数组示例清楚地展示了如何通过更改数组元素索引值来实现实现的更改。
- en: Closures
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'As I already mentioned, the function result depends on parameters. Is this
    dependency exhaustive? Certainly not. The function definition exists in a lexical
    context and is free to use some entities from this context in the course of the
    transformation of arguments into the result. Let''s consider the following code
    example (`Ch3_5.fsx` ):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，函数的结果取决于参数。这种依赖是否详尽？当然不是。函数定义存在于一个词法上下文中，并且可以在将参数转换为结果的过程中自由使用该上下文中的某些实体。让我们考虑以下代码示例
    (`Ch3_5.fsx` )：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding `enclose()` function does not have any parameters except `unit`
    . However, the result that''s returned depends on the free value `scope` that
    was in the lexical scope at the time of the function definition. Let `scope` value
    be bound to the `"old lexical scope"` value. This value gets captured, "closed"
    by the `enclose()` definition. Together, the contextual part and the definition
    form the special entity named **closure** . This process is schematically presented
    in the following figure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `enclose()` 函数除了 `unit` 没有任何参数。然而，返回的结果取决于在函数定义时词法作用域中的自由值 `scope`。将 `scope`
    值绑定到 `"old lexical scope"`。这个值被捕获，由 `enclose()` 定义“封闭”。这两个部分一起构成了一个名为 **闭包** 的特殊实体。这个过程在以下图中以示意图的形式展示：
- en: '![Closures](img/Image00012.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![闭包](img/Image00012.jpg)'
- en: A sample of a closure
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的一个示例
- en: 'Because they''re closed, the free values do not change. In the following sample,
    the value `scope` is later shadowed by the new value, `"new lexical scope"` .
    However, this does not change the value captured within the closure. This is reflected
    in the following figure, which shows the running of the last example in FSI, where
    both old and new scopes coexist:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是封闭的，所以自由值不会改变。在以下示例中，值 `scope` 在后来被新的值 `"new lexical scope"` 覆盖。然而，这并不会改变闭包中捕获的值。这反映在以下图中，显示了在
    FSI 中运行最后一个示例，其中旧的和新的作用域共存：
- en: '![Closures](img/Image00013.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![闭包](img/Image00013.jpg)'
- en: A simple closure in action
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简单闭包的实际应用
- en: 'Here, I provide another example of closure, demonstrating this time the capturing
    and updating of the state in the closure created by the anonymous function definition
    (`Ch3_5.fsx` ):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我提供了另一个闭包的示例，这次演示了匿名函数定义创建的闭包中状态的捕获和更新 (`Ch3_5.fsx` )：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this snippet, the `trackState` function captures its own argument into a
    closure accompanied by the anonymous function, which increments the local counter
    hidden in this closure on each invocation. The upcoming figure illustrates two
    independent closures, `counter1()` and `counter2()` , created off separate `trackState`
    invocations with different seeds tracking their own state:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`trackState` 函数将其自己的参数捕获到一个闭包中，并伴随着匿名函数，每次调用时都会增加这个闭包中隐藏的局部计数器。接下来的图示展示了两个独立的闭包，`counter1()`
    和 `counter2()`，它们分别由不同的 `trackState` 调用创建，使用不同的种子跟踪它们自己的状态：
- en: '![Closures](img/Image00014.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![闭包](img/Image00014.jpg)'
- en: Closures representing objects
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代表对象的闭包
- en: This sample highlights how closures can be used to represent inner fields even
    if the language does not really support objects. In this respect, as one of programming
    fables goes, **closures are a poor man's objects** ([http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent](http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent)
    ) indeed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例突出了闭包如何被用来表示内部字段，即使语言实际上并不支持对象。在这方面，正如一个编程寓言所说，**闭包是穷人的对象** ([http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent](http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent)
    ) 确实。
- en: Mutable values
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变值
- en: In the spirit of the functional-first language, F# values are immutable by default.
    However, the language offers facilities for the use of mutable values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式优先语言的精神下，F# 的值默认是不可变的。然而，该语言提供了使用可变值的设施。
- en: Mutable variables can be created using the `let mutable` syntax of value binding
    and the `<-` assignment operator to mutate the earlier bound values. Mutable values
    bound with `let mutable` are stored on the stack.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可变变量可以使用值绑定的 `let mutable` 语法和 `<-` 赋值运算符来创建，以改变之前绑定的值。使用 `let mutable` 绑定的可变值存储在栈上。
- en: Until F# v4.0, it was not allowed to write code capturing mutable values in
    closures, but beginning with the  v4.0 version of the language, this limitation
    has been lifted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 F# v4.0，不允许在闭包中捕获可变值编写代码，但从语言的 v4.0 版本开始，这种限制已经被取消。
- en: Reference cells
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用单元格
- en: An alternative facility for mutable values is reference cells inherited from
    OCaml. These values are allocated on the heap using the `let` binding with the
    special `ref` function. The underlying value of a reference cell is accessed with
    the help of dereference operator `!` . The referenced value can be mutated by
    the special assignment operator `:=` .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变值，有一个来自 OCaml 的引用单元格的替代设施。这些值使用特殊的 `ref` 函数和 `let` 绑定在堆上分配。引用单元格的底层值可以通过解引用运算符
    `!` 来访问。引用的值可以通过特殊的赋值运算符 `:=` 来修改。
- en: 'There is a subtle difference between mutable values and reference cells: mutable
    values are copied *by value* while reference cells are copied *by reference* .
    Let me offer you the code snippet illuminating this matter (`Ch3_6.fsx` ):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可变值和引用单元格之间存在细微的区别：可变值是通过值复制的，而引用单元格是通过引用复制的。让我提供一个代码片段来说明这个问题 (`Ch3_6.fsx`)：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following figure demonstrates by running the preceding code snippet in
    FSI how this difference manifests itself: mutable values `x` and `y` are independent,
    so changing `y` value from being identical to `x` value to something different
    does not anyhow affect `x` ; their values stay different.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下图通过在 FSI 中运行前面的代码片段来演示这种差异：可变值 `x` 和 `y` 是独立的，因此改变 `y` 的值从与 `x` 的值相同到不同的值并不会以任何方式影响
    `x`；它们的值保持不同。
- en: 'However, `rx` and `ry` reference the same object, so changing the underlying
    object via the `ry` reference simultaneously changes the previous object referenced
    by `rx` to the same one that `ry` references:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`rx` 和 `ry` 引用了同一个对象，所以通过 `ry` 引用更改底层对象时，同时也会将 `rx` 引用的先前对象更改为 `ry` 引用的同一个对象：
- en: '![Reference cells](img/Image00015.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![引用单元格](img/Image00015.jpg)'
- en: The difference between mutable and ref values
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可变值和 ref 值之间的区别
- en: Type inference
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'I have already outlined type inference earlier in the chapter. It is a feature
    of F# (as well as many other languages: C#, to begin with) that stems from its
    property of being statically typed. By following the natural code flow direction
    from top to bottom and from left to right, the F# compiler is capable of deriving
    types of values present in the code, including function types. This ability, in
    turn, allows you to omit explicit type declarations from the F# code. In the end,
    the code can be written faster, is quite succinct, and if it compiles, is consistent
    type-wise.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在本章前面概述了类型推断。这是 F#（以及许多其他语言：首先是 C#）的一个特性，源于其静态类型属性。通过遵循从上到下、从左到右的自然代码流方向，F#
    编译器能够推导出代码中存在的值的类型，包括函数类型。这种能力反过来又允许你从 F# 代码中省略显式类型声明。最终，代码可以更快地编写，相当简洁，如果编译成功，在类型上是一致的。
- en: 'Relying on type inference is not mandatory when writing the F# code. Adding
    an explicit declaration to the code may be especially meaningful in the following
    scenarios:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 F# 代码时，依赖类型推断不是强制性的。在以下场景中添加显式声明可能特别有意义：
- en: When the types cannot be inferred and the compiler prompts for the explicit
    declaration
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类型无法推断且编译器提示显式声明时
- en: If the code's author believes that providing explicit type declaration in some
    cases may simplify the code understanding and improve its readability
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码的作者认为在某些情况下提供显式类型声明可以简化代码理解并提高其可读性
- en: 'The most obvious way of inferring the value type is during binding based on
    the type of the expression to the right of the `=` sign as shown in the following
    code (`Ch3_7.fsx` ):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 推断值类型的最明显方式是在绑定期间，根据等号右侧表达式的类型进行推断，如下面的代码所示 (`Ch3_7.fsx`)：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For `s` , this is the type of literal on the right-hand side, or `string` .
    For `dict` , this is the `Dictionary<string, string list>` type of instance constructed
    on the right-hand side of the binding. In cases like the preceding one, adding
    explicit declarations of `s` and `dict` would just be adding unnecessary noise
    to the code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `s`，这是右侧字面量的类型，或 `string`。对于 `dict`，这是在绑定右侧构建的 `Dictionary<string, string
    list>` 类型的实例。在前面提到的类似情况下，添加 `s` 和 `dict` 的显式声明只会给代码添加不必要的噪音。
- en: 'Another rather obvious case is inferring a function signature based on its
    body definition in certain situations as shown in the following code (`Ch3_7.fsx`
    ):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当明显的情况是在某些情况下根据函数体的定义推断函数签名，如下面的代码所示 (`Ch3_7.fsx`)：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, as `isWin` is used after `if` this fact allows the F# compiler to deduce
    its type as `bool` ; the return type is apparently `string` , so the signature
    of the `gameOutcome` function can be inferred as (`bool->string` ). Simple, right?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于 `isWin` 在 `if` 之后使用，这一事实允许 F# 编译器推断其类型为 `bool`；返回类型显然是 `string`，因此 `gameOutcome`
    函数的签名可以推断为 (`bool->string`)。简单，对吧？
- en: 'Not that simple case when type inference fails may be illustrated by the following
    (quite naive) snippet (`Ch3_7.fsx` ):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断失败的情况可能并不简单，以下（相当天真）的片段（`Ch3_7.fsx` ）可以说明：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the F# compiler complains about `s.Length` and `s.Substring` with the
    following message:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，F# 编译器对 `s.Length` 和 `s.Substring` 抱怨，如下所示：
- en: '*Lookup on object of indeterminate type based on information prior to this
    program point. A type annotation may be needed prior to this program point to
    constrain the type of the object. This may allow the lookup to be resolved.*'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*基于程序点之前的信息在不确定类型的对象上进行查找。在程序点之前可能需要一个类型注解来约束对象的类型。这可能允许查找被解决。*'
- en: 'Changing the function definition to `let truncator limit (s: string) =` makes
    the F# compiler happy again.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '将函数定义更改为 `let truncator limit (s: string) =` 会使 F# 编译器再次满意。'
- en: 'Besides, if I would not be that naive and take at least some effort to check
    arguments for corner cases, as shown in the slightly enhanced definition in the
    following code (`Ch3_7.fsx` ):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我不那么天真，至少对边界情况进行一些检查，就像在以下代码的略微增强定义中所示（`Ch3_7.fsx` ）：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, the compiler can infer a type of `s` as `string` from its use as the argument
    of the `System.String.IsNullOrEmpty` library function; the explicit type declaration
    is not required again.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器可以从 `System.String.IsNullOrEmpty` 库函数的参数使用中推断出 `s` 的类型为 `string`；不再需要显式类型声明。
- en: 'Type inference gains more importance in the area of statically constrained
    generic types. Let''s consider a slightly more loaded example of the `logAndTrash`
    function, which takes an `ss` disposable collection, scribbles each `s` item as
    a separate text line into .NET `StringBuilder` , disposes the collection, and
    returns the eventual `StringBuilder` value for later consumption elsewhere as
    shown in the following code (`Ch3_7.fsx` ):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态约束泛型类型的领域中，类型推断变得更加重要。让我们考虑一个 `logAndTrash` 函数的略微复杂示例，它接受一个可丢弃的 `ss` 集合，将每个
    `s` 项作为单独的文本行写入 .NET `StringBuilder`，丢弃集合，并返回最终的 `StringBuilder` 值，以便在其他地方稍后使用，如下所示代码（`Ch3_7.fsx`
    ）：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is very nice of the F# compiler to infer a rather complicated signature
    of `logAndTrash` function that literally reads as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: F# 编译器非常体贴，能够推断出 `logAndTrash` 函数相当复杂的签名，其字面意思是如下所示：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Or, in plain words, this is a function taking a value of generic type `'a` and
    returning an instance of `StringBuilder` , where `'a` must be a sequence of any
    generic type `'b` and at the same time be disposable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者用简单的话来说，这是一个接受泛型类型 `'a` 的值的函数，并返回一个 `StringBuilder` 实例的函数，其中 `'a` 必须是任何泛型类型
    `'b` 的序列，并且同时是可丢弃的。
- en: Summing up the cases of type inference illustrated by the code examples given
    earlier I offer you the following take-away tip.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码示例中展示的类型推断案例总结如下。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Types of values, functions, and generics with constraints in F# may be unambiguously
    inferred in many code contexts, including-but not limited to-literals, constructed
    instances, usage in certain expression parts, signatures of library or custom
    functions or methods.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，值、函数和具有约束的泛型的类型可以在许多代码上下文中明确推断，包括但不限于-字面量、构造实例、在特定表达式部分的使用、库或自定义函数或方法的签名。
- en: Recursive function basics
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数基础知识
- en: In this chapter, I want to introduce you to the basics of recursive functions,
    leaving more detailed consideration for the more advanced contexts. At this point,
    I want to show how the F# default treatment of functions as non-recursive differs
    from a forced one when the function is explicitly declared recursive using the
    `let` binding modifier, `rec` .
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我想向您介绍递归函数的基础知识，并将更详细的考虑留给更高级的上下文。在此阶段，我想展示 F# 默认将函数视为非递归处理与使用 `let` 绑定修饰符
    `rec` 显式声明递归函数时的强制递归处理有何不同。
- en: 'Take a look at the following far-fetched snippet (`Ch3_8.fsx` ):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '看一下以下这个有些牵强的片段 (`Ch3_8.fsx` ):'
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `cutter` function here provides a non-empty string that's supposed to cut
    it from the left-hand side, symbol by symbol, until the argument is gone. Within
    the `cutter` body, there are two definitions of the `cut` internal function, of
    which the second definition apparently shadows the first. Also, it's important
    that within the second `cut` definition, it calls itself with the argument shortened
    from the left-hand side by one character, which is a clear case of **recursion**
    ([https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion)
    ).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的 `cutter` 函数返回一个非空字符串，其目的是从左侧开始，逐个符号地切割，直到参数消失。在 `cutter` 函数体内，有两个 `cut`
    内部函数的定义，其中第二个定义显然覆盖了第一个定义。此外，在第二个 `cut` 定义中，它通过将参数从左侧缩短一个字符来自身调用，这是一个明显的**递归**案例（[https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion)）。
- en: 'The following screenshot shows the preceding code being fed to FSI and executed
    yielding some output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了将前面的代码输入到 FSI 中并执行，产生了一些输出：
- en: '![Recursive function basics](img/Image00016.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![递归函数基础](img/Image00016.jpg)'
- en: Default non-recursive scoping of function definition
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的默认非递归作用域
- en: However, apparently, this code did not work as intended, as for the purpose
    of self-reference, the second instance of the `cut` definition is not lexically
    complete when `cut s.[1..]` occurs. The second `cut` definition did not shadow
    the first imitator instance of the `cut` definition, so the single output from
    the second (real) `cut` is followed by the single output from the imitator `cut`
    , and the computation is complete at this point. Oops, this is quite far from
    the intended output!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显然，这段代码并没有按预期工作，因为为了自引用，当出现 `cut s.[1..]` 时，第二个 `cut` 定义在词法上并不完整。第二个 `cut`
    定义没有覆盖第一个 `cut` 定义模仿的实例，因此第二个（真实）`cut` 的单个输出后面跟着模仿 `cut` 的单个输出，计算在这里完成。哎呀，这离预期的输出相差甚远！
- en: 'Things have changed dramatically in the following screenshot, where the second
    definition of `cut` is peppered with the `rec` modifier:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，`cut` 的第二个定义被 `rec` 修饰符点缀：
- en: '![Recursive function basics](img/Image00017.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![递归函数基础](img/Image00017.jpg)'
- en: Forced recursive scoping of the function definition
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的强制递归作用域
- en: 'Now, the second definition of `cut` immediately shadows the first one, allowing
    the second inner `cut` function to really call itself, which reflects the changed
    output; now, the implementation behaves as conceived: all performed cutting is
    real.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`cut` 的第二个定义立即覆盖了第一个定义，允许第二个内部 `cut` 函数真正地调用自身，这反映了输出变化；现在，实现的行为正如预期：所有执行过的切割都是真实的。
- en: So, for now, you should be able to grasp that the `rec` modifier makes a function
    value available for referral immediately, without waiting until the function definition
    is lexically complete, thus enabling functions refer to themselves.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，你应该能够理解 `rec` 修饰符使函数值立即可用以供引用，无需等待函数定义在词法上完整，从而使得函数能够引用自身。
- en: Operators as functions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符作为函数
- en: 'What is an operator, thinking abstractly? It can be seen as a function of one
    or two arguments that just have a concise name represented by a single symbol
    or a very few symbols. F# heartily supports this abstraction. For example, take
    a look at the following expression:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象地思考，什么是运算符？它可以被视为一个或两个参数的函数，这些参数只有一个简洁的名称，由一个或非常少数量的符号表示。F# 热切地支持这种抽象。例如，看看以下表达式：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, on the left-hand side of the equality sign (`=` ), the `(%)` function
    is called with the arguments `10` and `3` . On the right-hand side of the equality
    sign (`=` ) just a `10 % 3` expression is present. Evaluating the whole expression
    in FSI shows its value as `true` because sub expressions on the left and right
    of the equality sign (`=)` are indeed identical.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号（`=`）的左侧，调用 `(%)` 函数，参数为 `10` 和 `3`。在等号（`=`）的右侧，仅存在一个 `10 % 3` 表达式。在 FSI
    中评估整个表达式，其值为 `true`，因为等号（`=`）左右两侧的子表达式确实相同。
- en: 'Furthermore, the equality sign (`=` ) itself is also an operator. Evaluating
    the equality sign (`=` ) itself in FSI with the following expression `(=);;` will
    reveal the following function signature:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，等号（`=`）本身也是一个运算符。在 FSI 中使用以下表达式评估等号（`=`）本身 `=(=);;` 将揭示以下函数签名：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding signature means that (`=` ) is simply a function that takes two
    arguments of generic type `'a` supporting equality and returns a `bool` value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的签名意味着（`=`）是一个接受两个泛型类型 `'a` 支持相等性的参数并返回 `bool` 值的函数。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the description of F# core operators, refer to **Core.Operators Module (F#)**
    ([https://msdn.microsoft.com/en-us/library/ee353754.aspx](https://msdn.microsoft.com/en-us/library/ee353754.aspx)
    ). Those of you who want to define your own operators, which is not a bad thing
    if done in moderation, I recommend ****Operator Overloading (F#)**** ([https://msdn.microsoft.com/en-us/library/dd233204.aspx](https://msdn.microsoft.com/en-us/library/dd233204.aspx)
    ).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 F# 核心运算符的描述，请参阅**核心.运算符模块 (F#)** ([https://msdn.microsoft.com/en-us/library/ee353754.aspx](https://msdn.microsoft.com/en-us/library/ee353754.aspx))。那些想要定义自己的运算符的人，如果适度进行，这不是一件坏事，我推荐阅读**运算符重载
    (F#)** ([https://msdn.microsoft.com/en-us/library/dd233204.aspx](https://msdn.microsoft.com/en-us/library/dd233204.aspx))。
- en: Function composition
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: Function composition is perhaps the most fundamental skill to be mastered by
    a functional programmer. However simple it may sound, this is about combining
    some functions into a more powerful combination. This may sound close to the higher-order
    functions I have covered earlier, and it is close indeed. Function composition
    is just concentrating upon building chains of function applications that allow
    more powerful data transformations from the bunch of less complicated ones.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合可能是函数程序员需要掌握的最基本技能。尽管这可能听起来很简单，但这实际上是关于将一些函数组合成一个更强大的组合。这听起来可能接近我之前提到的更高阶函数，确实如此。函数组合就是专注于构建函数应用链，从而从更简单的一组中实现更强大的数据转换。
- en: Combinators
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合子
- en: How exactly does the function composition take place if, by definition, the
    functions considered the basis for composition are just sort of black boxes that
    can only consume arguments and produce results? This is correct; functions, arguments,
    and the single operation of an application are all that's required for composition
    (remember minimizing the moving parts). Still, composition is performed by functions
    as well. The function that somehow applies just its parameters or values (some
    of them may be function values) in order to produce results without involving
    any external context is named **combinator** . There is an entire branch of applied
    math, that is, **Combinatory logic** ([https://en.wikipedia.org/wiki/Combinatory_logic](https://en.wikipedia.org/wiki/Combinatory_logic)
    ) that is concerned, in particular, with the learning of combinators. This may
    take very capricious forms; those of you who want to delve deeper, I recommend
    that you Google the *idiot bird combinator* string and follow the links.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照定义，用于组合的函数只是某种黑盒，只能消耗参数并产生结果，那么函数组合究竟是如何进行的呢？这是正确的；函数、参数和应用的单一操作都是组合所需的所有内容（记住最小化移动部件）。尽管如此，组合仍然是由函数执行的。那些仅通过其参数或值（其中一些可能是函数值）来产生结果，而不涉及任何外部上下文的函数被称为**组合子**。在应用数学中有一个完整的分支，即**组合逻辑**([https://en.wikipedia.org/wiki/Combinatory_logic](https://en.wikipedia.org/wiki/Combinatory_logic))，它特别关注组合子的学习。这可能采取非常任性的形式；那些想要深入研究的人，我建议你们在
    Google 中搜索“idiot bird combinator”字符串并跟随链接。
- en: The id combinator
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`id` 组合子'
- en: The simplest representative of combinators is `id` . Entering `(id);;` into
    FSI reveals this function signature `('a -> 'a)` . In other words, this combinator
    takes any value and simply returns it without any transformation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子的最简单代表是 `id`。在 FSI 中输入 `(id);;` 可以揭示这个函数签名 `('a -> 'a)`。换句话说，这个组合子接受任何值，并简单地返回它，没有任何转换。
- en: Forward pipe |>
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前向管道 |>
- en: This combinator is the workhorse of idiomatic F#. Entering `(|>);` ; into FSI
    reveals this function signature `('a -> ('a -> 'b) ->'b)` . In other words, this
    combinator applies its second argument, which is a function `('a -> 'b)` , to
    its first argument `'a` , yielding the result `'b` .
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合子是惯用 F# 的主要工作马。在 FSI 中输入 `(|>);` 可以揭示这个函数签名 `('a -> ('a -> 'b) -> 'b)`。换句话说，这个组合子将其第二个参数，即函数
    `('a -> 'b)`，应用于其第一个参数 `'a`，从而得到结果 `'b`。
- en: Also, it may seem that the order cannot be that important; however, it is important
    indeed. One of the factors involved is type inference, which works better for
    the piped function composition (remember left to right).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能看起来顺序并不那么重要；然而，实际上它确实很重要。涉及的一个因素是类型推断，它在管道函数组合（记住从左到右）中工作得更好。
- en: Backward pipe <|
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后向管道 <|
- en: 'Entering `(<|);` ; into FSI reveals this function signature: `((''a -> ''b)
    -> ''a -> ''b)` . In other words, this combinator applies its first argument `(''a
    -> ''b)` to the second `''a` , yielding the result `''b` . At first glance, this
    combinator may seem excessive. However, an important case when it becomes useful
    is in eliminating the need for parentheses around the argument and improving the
    readability of the code in the end.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在FSI中输入`(<|);` ;可以揭示这个函数签名：`(('a -> 'b) -> 'a -> 'b)`。换句话说，这个组合器将其第一个参数`('a
    -> 'b)`应用于第二个`'a`，得到结果`'b`。乍一看，这个组合器可能显得有些多余。然而，当它变得有用的重要情况之一是消除参数周围的括号，并最终提高代码的可读性。
- en: Forward composition >>
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前向组合 >>
- en: This combinator composes functions together. Entering `(>>);;` into FSI reveals
    this function signature `(('a -> 'b) -> ('b -> 'c) -> 'a -> 'c)` . In other words,
    having two functions and an argument, it applies the first function to the argument
    and the second function to the result of the first application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合器将函数组合在一起。在FSI中输入`(>>);;`可以揭示这个函数签名`(('a -> 'b) -> ('b -> 'c) -> 'a -> 'c)`。换句话说，拥有两个函数和一个参数，它将第一个函数应用于参数，然后将第二个函数应用于第一个应用的结果。
- en: Backward composition
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后向组合
- en: This combinator composes functions together as well, but it does that differently.
    Entering `(<<);` ; into FSI reveals this function signature `(('a -> 'b) -> ('c
    -> 'a) -> 'c -> 'b)` . In other words, having two functions and an argument, it
    applies the second function to the argument and then the first function to the
    result of the first application. Sometimes, such an application order can be convenient
    for improved readability or other reasons.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合器也将函数组合在一起，但它以不同的方式做这件事。在FSI中输入`(<<);` ;可以揭示这个函数签名`(('a -> 'b) -> ('c ->
    'a) -> 'c -> 'b)`。换句话说，拥有两个函数和一个参数，它将第二个函数应用于参数，然后第一个函数应用于第一个应用的结果。有时，这样的应用顺序可能对提高可读性或其他原因来说很方便。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I expect that this chapter moved your intuition in the direction of a handful
    of notions the functional-first nature of F# is based upon.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这一章已经将你的直觉引向了F#函数式第一性质所基于的一些概念。
- en: Recognizing and distilling these cornerstones from any relevant code context,
    you are now ready to absorb the main contents. In the next chapter, I'll turn
    to the cornerstone of F# programming techniques that is present in literally every
    data transformation, that is, *Pattern Matching* .
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何相关的代码上下文中识别和提炼这些基石，你现在已经准备好吸收主要内容。在下一章中，我将转向存在于每一个数据转换中的F#编程技术的基石，即*模式匹配*。
