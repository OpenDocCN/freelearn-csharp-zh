<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>4 REST APIs</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="5">4 REST APIs</h1>

<h2 data-number="5.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file19.png" style="width:10em"/></p>
<p>This chapter delves into the heart of web application communication–REST APIs. In today's connected digital world, effective communication between different applications is paramount, and RESTful APIs play a pivotal role in facilitating this interaction.We start by exploring the basic fabric of the web: the HTTP protocol. We touch on the core HTTP methods such as GET, POST, PUT, and DELETE to see how they carry out CRUD (Create, Read, Update, Delete) operations in a RESTful context. We then turn our attention to HTTP status codes–the system's way of informing clients about the status of their requests–and HTTP headers.Since APIs evolve and managing these changes without disrupting existing clients is a significant challenge, we look at different strategies for API versioning and the trade-offs involved with each.Then we learn about the Data-Transfer Object (DTO) pattern. Packaging data into DTOs can provide many benefits, from reducing the number of calls to better encapsulation and improved performance when sending data over the network.Finally, we also explore the importance of defining clear and robust API contracts, which ensures API stability. We discuss techniques for designing and documenting these contracts, ensuring they serve as practical guides for API consumers.By the end of this chapter, you'll know how REST APIs work and will be ready to start building some using ASP.NET Core as we move further into our architectural journey in the next few chapters.In this chapter, we cover the following topics:</p>
<ul>
<li>REST &amp; HTTP</li>
<li>Data Transfer Object (DTO)</li>
<li>API contracts</li>
</ul>
<p>Let’s begin with REST.</p>


<h2 data-number="5.2">REST &amp; HTTP</h2>
<p><strong>REST</strong>, or <strong>Representational State Transfer</strong>, is a way to create internet-based services, known as web services, web APIs, REST APIs, or RESTful APIs. Those services commonly use HTTP as their transport protocol. REST reuses well-known HTTP specifications instead of recreating new ways of exchanging data. For example, returning an HTTP status code <code>200 OK</code> indicates success, while <code>400 Bad Request</code> indicates failure.Here are some defining characteristics:</p>
<ul>
<li><strong>Statelessness:</strong> In a RESTful system, every client-to-server request should contain all the details necessary for the server to comprehend and execute it. The server retains no information about the client's most recent HTTP request. This enhances both reliability and scalability.</li>
<li><strong>Caching capabilities:</strong> Clients should be able to cache responses to enhance performance.</li>
<li><strong>Simplicity and lose coupling:</strong> REST uses HTTP to ensure a simplified, decoupled architecture. This makes the development, maintenance, and scaling of REST APIs easier and facilitates their usage.</li>
<li><strong>Resource identifiability:</strong> Each REST API endpoint is a distinct resource, enabling us to secure each piece of the system separately.</li>
<li><strong>Interface as a contract:</strong> The REST API layer serves as an exchange contract or an abstraction. It effectively conceals the backend system's underlying implementation, fostering streamlined interactions.</li>
</ul>
<p>While we could delve much deeper into the intricacies of REST APIs, the preceding characteristics serve as foundational knowledge, providing good enough knowledge to get started with RESTful services. Having navigated through these essentials, let's shift our focus toward understanding how REST APIs harness the power of HTTP.</p>

<h3 data-number="5.2.1">HTTP methods</h3>
<p>HTTP methods, also known as verbs, define the type of action a client can perform on a resource in a RESTful API. Each method represents a specific operation that defines the endpoint's intent on a resource. Here is a list of the most frequently used methods, what they are for, and their expected success status code:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Typical role</strong></td>
<td><strong>Success status code</strong></td>
</tr>
<tr class="even">
<td><code>GET</code></td>
<td>Retrieve a resource (read data).</td>
<td>200 OK</td>
</tr>
<tr class="odd">
<td><code>POST</code></td>
<td>Create a new resource.</td>
<td>201 CREATED</td>
</tr>
<tr class="even">
<td><code>PUT</code></td>
<td>Replace a resource.</td>
<td>200 OK or 204 No Content</td>
</tr>
<tr class="odd">
<td><code>DELETE</code></td>
<td>Delete a resource.</td>
<td>200 OK or 204 No Content</td>
</tr>
<tr class="even">
<td><code>PATCH</code></td>
<td>Partially update a resource.</td>
<td>200 OK</td>
</tr>
</tbody>
</table>
<p>Next, we explore the commonly used status codes.</p>


<h3 data-number="5.2.2">HTTP Status code</h3>
<p>HTTP status codes are part of the HTTP response and provide the client with information about the success or failure of their request; the status of the request.Status codes touching similar subjects are grouped under the same broad “hundredth” categories:</p>
<ul>
<li><code>1XX</code> (informational) codes indicate that the request was received and the process is continuing, such as <strong>100 Continue</strong> and <strong>101 Switching Protocols</strong>.</li>
<li><code>2XX</code> (successful) codes indicate that the request was received successfully.</li>
<li><code>3XX</code> (redirection) codes indicate that the client must take further action to complete the redirection request.</li>
<li><code>4XX</code> (client error) codes indicate an error on the client's part, such as validation errors. The client sent an empty required field, for example.</li>
<li><code>5XX</code> (server error) codes indicate that the server failed to fulfill an apparently valid request and that the client cannot do anything about it (retrying the request is not an option).</li>
</ul>
<p>The following table explains some of the most common ones:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Status code</strong></td>
<td><strong>Role</strong></td>
</tr>
<tr class="even">
<td><strong>200 OK</strong></td>
<td>Indicates the request has succeeded. It usually includes data related to the resource in the response body.</td>
</tr>
<tr class="odd">
<td><strong>201 CREATED</strong></td>
<td>Indicates the has succeeded and the system created a resource. It should also include a <code>Location</code> HTTP header pointing to the newly created resource and can include the new entity in the response body.</td>
</tr>
<tr class="even">
<td><strong>202 ACCEPTED</strong></td>
<td><p>Indicates the request has been accepted for processing but is not processed yet. We use this code for asynchronous operations.</p>
<p>In an event-driven system (see <em>Chapter 17</em>, <em>Introduction to Microservices Architecture</em>), this could mean that an event has been published, the current resource has completed its job (published the event), but to know more, the client needs to contact another resource, wait for a notification, just wait, or can’t know.</p></td>
</tr>
<tr class="odd">
<td><strong>204 NO CONTENT</strong></td>
<td>Indicates the request has succeeded with no content in the response body.</td>
</tr>
<tr class="even">
<td><strong>302 FOUND</strong></td>
<td>Indicates that the requested resource resides temporarily under a different URL specified in the <code>Location</code> header. We commonly use this status code for redirection.</td>
</tr>
<tr class="odd">
<td><strong>400 BAD REQUEST</strong></td>
<td>Indicates that the server could not understand or process the request. This usually relates to a validation error like a bad input or a missing field.</td>
</tr>
<tr class="even">
<td><strong>401 UNAUTHORIZED</strong></td>
<td>Indicates that the request requires user authentication to access the resource.</td>
</tr>
<tr class="odd">
<td><strong>403 FORBIDDEN</strong></td>
<td>Indicates that the server understood the request but refused to authorize it. This usually means the client lacks the access rights for the resource (authorization).</td>
</tr>
<tr class="even">
<td><strong>404 NOT FOUND</strong></td>
<td>Indicates the resource does not exist or was not found. REST APIs often return this from valid endpoints.</td>
</tr>
<tr class="odd">
<td><strong>409 CONFLICT</strong></td>
<td>Indicates that the server cannot complete the request due to a conflict with the current state of the resource. A typical scenario would be that the entity has changed between its read operation ( <code>GET</code> ) and the current update ( <code>PUT</code> ) operation.</td>
</tr>
<tr class="even">
<td><strong>500 INTERNAL SERVER ERROR</strong></td>
<td>Indicates that an unhandled error occurred on the server side and prevented it from fulfilling the request.</td>
</tr>
</tbody>
</table>
<p>Now that we covered the HTTP methods and status codes, we look at how to pass more metadata between the client and the server.</p>


<h3 data-number="5.2.3">HTTP headers</h3>
<p>REST APIs leverage HTTP headers to transmit clients’ information and describe their options and capabilities. Headers are part of both the request and the response.One well-known header is the <code>Location</code> header, that we use for different purposes. For example:</p>
<ul>
<li>After creating an entity (<code>201 Created</code>), the <code>Location</code> header should point to the <code>GET</code> endpoint where the client can access that new entity.</li>
<li>After starting an asynchronous operation (<code>202 Accepted</code>), the <code>Location</code> header could point to the status endpoint where you can poll for the state of the operation (has it completed, failed, or is it still ongoing).</li>
<li>When a server wants to instruct a client to load another page (a redirection), the <code>Location</code> header contains the destination URL. The following status codes are the most common for redirections: <code>301 Moved Permanently</code>, <code>302 Found</code>, <code>303 See Other</code>, <code>307 Temporary Redirect</code>, and <code>308 Permanent Redirect</code>.</li>
</ul>
<p>The <code>Retry-After</code> header can also come in handy when mixed with <code>202</code> <code>Accepted</code>, <code>301 Moved Permanently</code>, <code>429 Too Many Requests</code>, or <code>503 Service Unavailable</code>. The <code>ETag</code> header identifies the version of the entity and can be used in conjunction with <code>If-Match</code> to avoid <em>mid-air collisions</em>. The <code>ETag</code> and <code>If-Match</code> headers form a sort of <em>optimistic concurrency</em> method that prevents <em>request two</em> from overwriting changes made by <em>request one</em> when changes are happening simultaneously or not in the expected order; a.k.a. a way to manage conflicts. We can also add the following to the mix as an example of HTTP headers that describe a REST endpoint: <code>Allow</code>, <code>Authorization</code>, and <code>Cache-Control</code>. The list is very long, and it would help no one to enumerate all HTTP headers here.</p>
<blockquote>
<p>This information should be enough theory to get you started with HTTP and REST. In case you want to know more, I left links to the MDN web docs about HTTP in the Further Reading section at the end of the chapter.</p>
</blockquote>
<p>Next, we look at versioning because nothing stays the same forever; business needs change, and APIs must evolve with them.</p>


<h3 data-number="5.2.4">Versioning</h3>
<p>Versioning is a crucial aspect of a REST API. Whether the version of the API is long-lived or transitory (during the decommissioning cycle of an old endpoint, for example), both ends of the pipe must know what to expect; what API contract to respect. Unless you are your only consumer, you’ll need a way for the API clients to query specific API versions when the contract changes.This section explores a few ways to think about our versioning strategy.</p>

<h4 data-number="5.2.4.1">Default versioning strategy</h4>
<p>The default strategy is the first thing to consider when versioning an API. What happens when no version is specified? Will the endpoint return an error, the first or the latest version?If the API returns an error, you should implement that versioning strategy from day one so clients know a version is required. In this case, there is no real drawback. On the other hand, putting this strategy in place after the fact will break all clients that do not specify a version number, which might not be the best way to keep your consumers happy.The second way is always to return the first version. This method is an excellent way to preserve backward compatibility. You can add more endpoint versions without breaking your consumers.The opposite way is always to return the latest version. For consumers, this means specifying a version to consume or be up to date or break, and this might not be the best user experience to provide to your consumers. Nonetheless, many have opted for this default strategy.Another way to go is to pick any version as the default baseline for the API (like version 3.2, for example) or even choose a different version per endpoint. Say you default to 3.2, then deploy 4.0. Since the clients must opt-in to access the new API, they won’t break automatically and will have the time to update from 3.2 to 4.0 following their own roadmap. This is a good strategy to default to a well-known and stable API version before moving forward with breaking changes.</p>
<blockquote>
<p>No matter what you choose, always think it through by weighing the pros and cons.</p>
</blockquote>
<p>Next, we explore ways to define those versions.</p>


<h4 data-number="5.2.4.2">Versioning strategy</h4>
<p>Of course, there are multiple ways to think this through. You can leverage URL patterns to define and include the API version, like <code>https://localhost/v2/some-entities</code>. This strategy is easier to query from a browser, making it simple to know the version at a glance, but the endpoint is not pointing to a unique resource anymore (a key principle of REST), as each resource has one endpoint for each version. Nonetheless, this way of versioning an API is used extensively and is one of the most popular, if not <em>the</em> most popular way of doing REST versioning, even if it violates one of its core principles (debatably).The other way is to use HTTP headers. You can use a custom header like <code>api-version</code> or <code>Accept-version</code>, for example, or the standard <code>Accept</code> header. This way allows resources to have unique endpoints (URI) while enabling multiple versions of each entity (multiple versions of each API contract describing the same entity).For example, a client could specify an HTTP header while calling the endpoint like this (custom header):</p>
<div><pre><code>GET https://localhost/some-entities
Accept-version: v2</code></pre>
</div>
<p>Or like the following, by leveraging the <code>Accept</code> header for <em>content negotiation</em>:</p>
<div><pre><code>GET https://localhost/some-entities
Accept: application/vnd.api.v2+json</code></pre>
</div>
<blockquote>
<p>Different people are using different values for the <code>Accept</code> headers, for example:</p>
</blockquote>
<ul>
<li><code>application/vnd.myapplication.v2+json</code></li>
<li><code>application/vnd.myapplication.entity.v2+json</code></li>
<li><code>application/vnd.myapplication.api+json; version=2</code></li>
<li><code>application/json; version=2</code></li>
</ul>
<p>Whether you are using one way or another, you’ll most likely need to version your APIs at some point. Some people are strong advocates of one way or the other, but ultimately, you should decide on a case-by-case basis what best covers your needs and capacities: simplicity, formality, or a mix of both.</p>



<h3 data-number="5.2.5">Wrapping up</h3>
<p>With a method (verb), the client (and the endpoint) can express the intent to create, update, read, or delete an entity. With a status code, the endpoint can tell the client the state of the operation. Adding HTTP headers, clients, and servers can add more metadata to the request or response. Finally, by adding versioning, the REST API can evolve without breaking existing clients while giving them options to consume specific versions.With what we just covered, you should have more than what’s needed to follow along with the examples in this book and build a few REST APIs along the way. Next, we explore how those HTTP pieces create API contracts.</p>



<h2 data-number="5.3">Data Transfer Object (DTO)</h2>
<p>The Data Transfer Object (DTO) design pattern is a robust approach to managing and transferring data in a service-oriented architecture like REST APIs. The DTO pattern is about organizing the data to deliver it to API clients optimally. DTOs are an integral part of the API contract, that we explore next.</p>

<h3 data-number="5.3.1">Goal</h3>
<p>A DTO's objective is to <em>control an endpoint's inputs and outputs</em> by loosely coupling the exposed API surface from the application’s inner workings. DTOs empower us to craft our web services the way we want the consumers to interact with them. So, no matter the underlying system, we can use DTOs to design endpoints that are easier to consume, maintain, and evolve.</p>


<h3 data-number="5.3.2">Design</h3>
<p>Each DTO represents an entity with all the necessary properties. That entity is either an input or an output and allows crafting the interaction between the clients and the API.DTOs serve to loosely couple our domain from the data exposed over the API by adding a level of abstraction. This allows us to change the underlying domain model without affecting the data exposed to the API consumers and vice versa.Another way to use a DTO is by packaging related pieces of information together, allowing a client to make a single call to fetch all necessary data, thereby eliminating the need for multiple requests.Based on REST and HTTP, the flow of a request goes like the following: an HTTP request comes in, some code is executed (domain logic), and an HTTP response goes back to the client. The following diagram represents this flow:</p>
<figure>
<img alt="Figure 4.1: An HTTP request getting in and out of a REST API endpoint." src="img/file20.png"/><figcaption aria-hidden="true">Figure 4.1: An HTTP request getting in and out of a REST API endpoint.</figcaption>
</figure>
<p>Now, if we take that flow and change HTTP with DTO, we can see that a DTO can be part of the data contract as an input or an output:</p>
<figure>
<img alt="Figure 4.2: An input DTO hitting some domain logic, then the endpoint returning an output DTO" src="img/file21.png"/><figcaption aria-hidden="true">Figure 4.2: An input DTO hitting some domain logic, then the endpoint returning an output DTO</figcaption>
</figure>
<p>How can the HTTP request become an object? Most of the time:</p>
<ul>
<li>We use deserialization or data binding for inputs.</li>
<li>We use serialization for outputs.</li>
</ul>
<p>Let’s look at a few examples.</p>


<h3 data-number="5.3.3">Conceptual examples</h3>
<p>Conceptually, say that we are building a web application allowing people to register for events. We explore two use cases next.</p>

<h4 data-number="5.3.3.1">Registering for an activity</h4>
<p>The first scenario we are exploring is a user registering for an activity. An activity is a sort of event in the system. We use an external payment gateway, so our application never handles financial data. Nevertheless, we must send transaction data to our backend to associate and complete the payment. The following diagram depicts the workflow:</p>
<figure>
<img alt="Figure 4.3: The DTOs implicated in an activity registration flow." src="img/file22.png"/><figcaption aria-hidden="true">Figure 4.3: The DTOs implicated in an activity registration flow.</figcaption>
</figure>
<p>The body of the request could look like the following JSON snippet:</p>
<div><pre><code>{
    "registrant": {
        "firstname": "John",
        "lastname": "Doe"
    },
    "activity": {
        "id": 123,
        "seats": 2
    },
    "payment": {
        "nonce": "abc123"
    }
}</code></pre>
</div>
<p>Next, the following JSON snippet could represent the body of the response:</p>
<div><pre><code>{
    "status": "Success",
    "numberOfSeats": 2,
    "activityId": 123,
    "activityDate": "2023-06-03T20:00:00"
}</code></pre>
</div>
<p>Of course, this is a very lightweight version of a registration system. The objective is to show that:</p>
<ol>
<li>Three entities came in as an HTTP POST request (a registrant, an activity, and payment information).</li>
<li>The system executed some business logic to register the person to the activity and to complete the financial transaction.</li>
<li>The API returned mixed information to the client.</li>
</ol>
<blockquote>
<p>This pattern is handy to input and output only what you need. If you are designing the user interface that consumes the API, outputting a well-thought DTO can ensure that the UI renders the next screen just by reading the response from the server, saving your UI to fetch more data, speeding up the process, and improving the user experience.</p>
</blockquote>
<p>We explore fetching information about an activity registration next.</p>


<h4 data-number="5.3.3.2">Fetching activity registration details</h4>
<p>In the same system, the user wants to review the details of an activity he registered using the preceding process. In this case, the flow goes like this:</p>
<ol>
<li>The client sends the registration identifier over a <code>GET</code> request.</li>
<li>The system fetches the registrant information, the activity information, and the number of seats the user reserved for that activity.</li>
<li>The server returns the data to the client.</li>
</ol>
<p>The following diagram visually represents the use case:</p>
<figure>
<img alt="Figure 4.4: The DTOs implicated in fetching the info related to a registered activity." src="img/file23.png"/><figcaption aria-hidden="true">Figure 4.4: The DTOs implicated in fetching the info related to a registered activity.</figcaption>
</figure>
<p>In this case, the input would be part of the URL, like <code>/registrations/123</code>. The output would be part of the response body, and could look like the following:</p>
<div><pre><code>{
    "registrant": {
        "firstname": "John",
        "lastname": "Doe"
    },
    "activity": {
        "id": 123,
        "name": "Super Cool Show",
        "date": "2023-06-03T20:00:00"
    },
    "numberOfSeats": 2
}</code></pre>
</div>
<p>By creating that endpoint using a well-crafted output DTO, we condensed three HTTP requests into one: the registrant, the activity, and the registration (number of seats). This powerful technique applies to any technology, not just ASP.NET Core, and allows us to design APIs without connecting clients directly to our data (loose coupling).</p>



<h3 data-number="5.3.4">Conclusion</h3>
<p>A data transfer object (DTO) allows us to design an API endpoint with specialized input and output instead of exposing the domain or data model. Those DTOs shield our internal business logic, which improves our ability to design our APIs and also helps us make them more secure.</p>
<blockquote>
<p>By defining DTOs, we can avoid a malicious actor trying to bind data that he should not have access to. For example, when using an input “Login DTO” that only contains a <code>username</code> and <code>password</code> properties, a malicious user could not try to bind the <code>IsAdmin</code> field available in our domain and database. There are other ways to mitigate this, but they are out of the scope of this chapter, yet, a DTO is a great candidate to mitigate this attack vector.</p>
</blockquote>
<p>This separation between the presentation and the domain is a crucial element that leads to having multiple independent components instead of a bigger, more fragile one or leaking the internal data structure to the clients consuming the API.We explore building APIs in the next few chapters and explore some topics more in-depth in <em>Section 4</em>, <em>Designing at Application Scale</em>.Using the DTO pattern helps us follow the SOLID principles in the following ways:</p>
<ul>
<li><strong>S</strong>: A DTO adds clear boundaries between the domain logic or the data and the API contract, dividing one model into several distinct responsibilities to help keep things isolated.</li>
<li><strong>O</strong>: N/A</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: A DTO is a smaller, specifically crafted model that serves a clear purpose. With a DTO, we now have two models (domain and API contract) and several classes (input DTO, output DTO, and domain or data entities) instead of a generic one (only the domain or data entity).</li>
<li><strong>D</strong>: N/A</li>
</ul>
<p>Next, we look at how we can glue the pieces that we explored so far into API contracts.</p>



<h2 data-number="5.4">API contracts</h2>
<p>API Contracts serve as an essential blueprint, outlining the rules of engagement between your API and its consumers. This includes available endpoints, HTTP methods they support, expected request formats, and potential response structures, including HTTP status codes.These contracts provide clarity, robustness, consistency, and interoperability, facilitating seamless system interactions, no matter the language they are built with. Moreover, well-documented API contracts are a reliable reference guide, helping developers understand and utilize your API effectively. Thus, designing comprehensive and clear API contracts is critical in building high-quality, maintainable, and user-friendly APIs.An API contract describes a REST API, so a consumer should know how to call an endpoint and what to expect from it in return. What an endpoint does or the capability it provides should be clear just by reading its contract.Each endpoint in a REST API should provide at least the following signature:</p>
<ul>
<li>A Uniform Resource Identifier (URI) that indicates where to access it.</li>
<li>An HTTP method that describes the type of operation it does.</li>
<li>An input that defines what is needed for the operation to happen. For example, the input can be the HTTP body, URL parameters, query parameters, HTTP headers, or even a combination.</li>
<li>An output that defines what the client should expect. A client should expect multiple output definitions since an endpoint will not return the same information if the request succeeds or fails.</li>
</ul>
<blockquote>
<p>The input and output of an endpoint are often DTOs, making DTOs even more important.</p>
</blockquote>
<p>There are multiple ways to define API contracts. For example, to define an API contract, we could do the following:</p>
<ul>
<li>Open any text editor, such as MS Word or Notepad, and start writing a document describing our web APIs; this is probably the most tedious and least flexible way. I do not recommend this for many reasons.</li>
<li>Writing specifications in Markdown files and saving those files within your project Git repository for easy discoverability. Very similar to MS Word, but more accessible for all team members to consume. This approach is better than Word, yet not optimal since you need to manually update those files when the API changes.</li>
<li>Use an existing standard, such as the OpenAPI specification (formerly Swagger). This technique implies a learning curve, but the result should be easier to consume. Moreover, many tools allow us to create automation using the OpenAPI specs. This approach is starting to remove the need for manual intervention.</li>
<li>Use a code-first approach and ASP.NET Core tooling to extract the OpenAPI specs from your code.</li>
<li>Use any other tools that fit our requirements.</li>
</ul>
<blockquote>
<p><strong>Tip</strong></p>
<blockquote>
<p>Postman is a fantastic tool for building web APIs documentation, test suites, and experimenting with your APIs. It supports OpenAPI specifications, allows you to create mock servers, supports environments, and more.</p>
</blockquote>
</blockquote>
<p>No matter the tools, there are two major trends in how to design the API contract of a REST API:</p>
<ul>
<li>Design the contract first, then build the API (contract-first).</li>
<li>Build the API, then extract the contract for the code (code-first).</li>
</ul>
<p>To design the contract-first, one must adopt a tool to write the specifications, then code the API according to the specs.</p>
<blockquote>
<p>I left a link in the <em>Further Reading</em> section below about Open API.</p>
</blockquote>
<p>On the other hand, to use a code-first approach and automatically extract the OpenAPI specifications from the API, we must ensure our endpoints are discoverable by the .NET <code>ApiExplorer</code>.No matter how you do it, in ASP.NET Core, we use classes and struct to represent the data contract of our REST APIs; whether it happens before or after you write the API contract does not matter. Since I prefer to write C# to YAML or JSON, we explore how to leverage Swagger to generate a data contract in a code-first manner next.</p>

<h3 data-number="5.4.1">Code-first API Contract</h3>
<p>In this example, we have a tiny API with two endpoints:</p>
<ul>
<li>Read the specified entity.</li>
<li>Create a new entity.</li>
</ul>
<p>The code doesn’t do much and returns fake data, but it is enough to explore its data contract.</p>
<blockquote>
<p>Remember that code is like playing LEGO® blocks, but we connect many tiny patterns used together to create our software and create value. Understanding and learning that skill will lead you beyond just being able to use some canned magic recipe, which limits you to what people share with you.</p>
</blockquote>
<p>In this sample, we use the OpenAPI specification to describe our API. To save ourselves from writing JSON and go code-first instead, we leverage the SwagerGen package.</p>
<blockquote>
<p>To use SwaggerGen, we must install the <code>Swashbuckle.AspNetCore.SwaggerGen</code> NuGet package.</p>
</blockquote>
<p>Here’s the <code>Program.cs</code> file, without the endpoints, showing how to leverage SwaggerGen:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
app.UseSwagger();
// Omitted endpoints
app.Run();</code></pre>
</div>
<p>The highlighted lines are the only things we must do to use SwaggerGen in a project, which will generate the API contract in the OpenAPI specification for us. The JSON file is very long (113 lines), so I only pasted some snippets in the book for clarity. However, you can navigate to the <code>/swagger/v1/swagger.json</code> URL to access the complete JSON code or open the <code>swagger.json</code> file in the project.</p>
<blockquote>
<p>I created the <code>swagger.json</code> file in the project for convenience. The tool does not generate a physical file.</p>
</blockquote>
<p>Let’s have a look at those endpoints.</p>

<h4 data-number="5.4.1.1">The first endpoint</h4>
<p>The code of the first endpoint that allows a client to read an entity looks like this:</p>
<div><pre><code>app.MapGet(
    "/{id:int}",
    (int id) =&gt; new ReadOneDto(
        id,
        "John Doe"
    )
);
public record class ReadOneDto(int Id, string Name);</code></pre>
</div>
<p>Here’s the API contract we can extract from the preceding code:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Contract segment</strong></td>
<td><strong>Value</strong></td>
</tr>
<tr class="even">
<td>HTTP Method</td>
<td>GET</td>
</tr>
<tr class="odd">
<td>URI</td>
<td><code>/{id}</code> (for example, <code>/123</code> )</td>
</tr>
<tr class="even">
<td>Input</td>
<td>The <code>id</code> parameter</td>
</tr>
<tr class="odd">
<td>Output</td>
<td>An instance of the <code>ReadOneDto</code> class.</td>
</tr>
</tbody>
</table>
<p>Sending the following HTTP request (you can use the <code>ReadOneEntity.http</code> file) results in the output that follows:</p>
<div><pre><code>GET /123 HTTP/1.1
Accept: application/json
Host: localhost:7000
Connection: keep-alive</code></pre>
</div>
<p>The trimmed-down response is:</p>
<div><pre><code>HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 03 Jun 2023 17:41:42 GMT
Server: Kestrel
Alt-Svc: h3=":7000"; ma=86400
Transfer-Encoding: chunked
 
{"id":123,"name":"John Doe"}</code></pre>
</div>
<p>As we can see, when we query the API for the entity <code>id=123</code>, the endpoint returns that entity with a <code>200 OK</code> status code, and the response body is a serialized instance of the <code>ReadOneDto</code> class.</p>
<blockquote>
<p>The <code>.http</code> files are new to VS 2022 and allow us to write and execute HTTP requests from VS itself. I left a link in the <em>Further Reading</em> section if you want to know more.</p>
</blockquote>
<p>SwaggerGen generated the following OpenAPI specs for the first endpoint:</p>
<div><pre><code>"/{id}": {
  "get": {
    "parameters": [
      {
        "name": "id",
        "in": "path",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int32"
        }
      }
    ],
    "responses": {
      "200": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ReadOneDto"
            }
          }
        }
      }
    }
  }
},</code></pre>
</div>
<p>That snippet describes the endpoint and references our output model (highlighted line). The schemas are at the bottom of the JSON file. Here’s the schema that represents the <code>ReadOneDto</code>:</p>
<div><pre><code>"ReadOneDto": {
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int32"
    },
    "name": {
      "type": "string",
      "nullable": true
    }
  },
  "additionalProperties": false
}</code></pre>
</div>
<p>As we can see from the highlighted lines, that schema has a property <code>name</code> of type <code>string</code> and a property <code>id</code> of type <code>integer</code>, the same as our <code>ReadOneDto</code> class. Fortunately, we don’t need to write that JSON since the tool generates it based on our code. Next, we look at the second endpoint.</p>


<h4 data-number="5.4.1.2">The second endpoint</h4>
<p>The code of the second endpoint that allows a client to create an entity looks like this:</p>
<div><pre><code>app.MapPost(
    "/",
    (CreateDto input) =&gt; new CreatedDto(
        Random.Shared.Next(int.MaxValue),
        input.Name
    )
);
public record class CreateDto(string Name);
public record class CreatedDto(int Id, string Name);</code></pre>
</div>
<p>Here’s the API contract we can extract from the preceding code:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Contract segment</strong></td>
<td><strong>Value</strong></td>
</tr>
<tr class="even">
<td>HTTP Method</td>
<td>POST</td>
</tr>
<tr class="odd">
<td>URI</td>
<td><code>/</code></td>
</tr>
<tr class="even">
<td>Input</td>
<td>An instance of the <code>CreateDto</code> class.</td>
</tr>
<tr class="odd">
<td>Output</td>
<td>An instance of the <code>CreatedDto</code> class.</td>
</tr>
</tbody>
</table>
<p>Sending the following HTTP request (you can use the <code>CreateEntity.http</code> file) results in the output that follows:</p>
<div><pre><code>POST / HTTP/1.1
Content-Type: application/json
Host: localhost:7000
Accept: application/json
Connection: keep-alive
Content-Length: 28
 
{
    "name": "Jane Doe"
}</code></pre>
</div>
<p>The trimmed-down response is:</p>
<div><pre><code>HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 03 Jun 2023 17:59:25 GMT
Server: Kestrel
Alt-Svc: h3=":7000"; ma=86400
Transfer-Encoding: chunked
 
{"id":1624444431,"name":"Jane Doe"}</code></pre>
</div>
<p>As we can see from the preceding request, the client sent a serialized instance of the <code>CreateDto</code> class, set the name to Jane Doe, and received that same entity back but with a numeric <code>id</code> property (an instance of the <code>CreatedDto</code> class).The OpenAPI specs of our endpoint look like the following:</p>
<div><pre><code>"/": {
  "post": {
    "requestBody": {
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/CreateDto"
          }
        }
      },
      "required": true
    },
    "responses": {
      "200": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/CreatedDto"
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
<p>The input and output schemas are:</p>
<div><pre><code>"CreateDto": {
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "nullable": true
    }
  },
  "additionalProperties": false
},
"CreatedDto": {
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int32"
    },
    "name": {
      "type": "string",
      "nullable": true
    }
  },
  "additionalProperties": false
},</code></pre>
</div>
<p>Similar to the first endpoint, SwaggerGen translates our C# classes into OpenAPI specs. Let’s wrap this up.</p>



<h3 data-number="5.4.2">Wrapping up</h3>
<p>Some ASP.NET Core templates come with SwaggerGen preconfigured. It also comes with the Swagger UI that lets you visually explore the API contract from your application and even query it. NSwag is another tool that offers similar features. Plenty of online documentation shows how to take advantage of those tools.Besides exploring tooling, we defined that an API contract is fundamental and promotes robustness and reliability. Each endpoint has the following pieces as part of the overall API contract:</p>
<ul>
<li>The URI it is accessible from.</li>
<li>The HTTP method that best defines the operation.</li>
<li>An input.</li>
<li>One or more outputs.</li>
</ul>
<blockquote>
<p>A single URI can lead to multiple endpoints by combining different HTTP methods and inputs. For example, <code>GET /api/entities</code> may return a list of entities, while <code>POST /api/entities</code> may create a new entity. Using the entity's name in its plural form is a convention used by many.</p>
</blockquote>
<p>We explore data transfer objects next to add more clarity to that pattern.</p>



<h2 data-number="5.5">Summary</h2>
<p>REST APIs facilitate communication between applications in today's interconnected digital world. We explored the HTTP protocol, HTTP methods, HTTP status codes, and HTTP headers. We then explored API versioning, the Data Transfer Objects (DTOs), and the importance of API contracts. Here are a few Key Takeaways:</p>
<ul>
<li><strong>REST &amp; HTTP</strong>: REST APIs are integral to web application communication. They use HTTP as their transport protocol, leveraging its methods, status codes, and headers to facilitate interaction between different applications.</li>
<li><strong>HTTP Methods</strong>: HTTP methods or verbs (GET, POST, PUT, DELETE, PATCH) define the type of action a client can perform on a resource in a RESTful API. Understanding these methods is crucial for carrying out CRUD operations.</li>
<li><strong>HTTP Status Codes and Headers</strong>: HTTP status codes inform clients about the success or failure of their requests. HTTP headers transmit additional information and describe clients' options and capabilities. Both are essential components of HTTP communication.</li>
<li><strong>Versioning</strong>: Managing changes in APIs without disrupting existing clients is a significant challenge. Different strategies for API versioning can help address this issue, but each comes with its own trade-offs.</li>
<li><strong>Data Transfer Object (DTO)</strong>: DTOs package data into a format that can provide many benefits, including reducing the number of HTTP calls, improving encapsulation, and enhancing performance when sending data over the network.</li>
<li><strong>API Contracts</strong>: Clear and robust API contracts ensure API stability. They serve as a blueprint for interaction between an API and its consumers, outlining available endpoints, supported HTTP methods, expected request formats, and potential response structures.</li>
<li><strong>Practical Application</strong>: Understanding these concepts is not only theoretically important but also practically helpful in building and working with REST APIs using ASP.NET Core or any other similar technology.</li>
</ul>
<p>By now, you should have a solid understanding of REST APIs and be ready to explore how to implement one using ASP.NET Core. ASP.NET Core makes writing REST APIs using MVC or minimal APIs a breeze. MVC is a well-used pattern that is almost impossible to avoid. However, the new minimal API model makes the process leaner. Moreover, with application patterns like Request-EndPoint-Response (REPR) or Vertical Slice Architecture, we can organize our API per feature instead of by layer, leading to an improved organization. We cover those topics in <em>Section 4</em>: <em>Application patterns</em>.Next, we explore designing with ASP.NET Core, starting with Minimal APIs.</p>


<h2 data-number="5.6">Questions</h2>
<p>Let’s look at a few practice questions:</p>
<ol>
<li>What is the most common status code sent in a REST API after creating an entity?</li>
<li>If you introduce a default strategy that returns the lowest possible version when no version is specified, would it break existing clients?</li>
<li>If you want to read data from the server, what HTTP method would you use?</li>
<li>Can DTOs add flexibility and robustness to a system?</li>
<li>Are DTOs part of an API contract?</li>
</ol>


<h2 data-number="5.7">Further reading</h2>
<p>Here are some links to build on what we have learned in the chapter:</p>
<ul>
<li>HTTP request methods (MDN): <a href="https://adpg.link/MFWb">https://adpg.link/MFWb</a></li>
<li>HTTP response status codes (MDN): <a href="https://adpg.link/34Jq">https://adpg.link/34Jq</a></li>
<li>HTTP headers (MDN): <a href="https://adpg.link/Hx55">https://adpg.link/Hx55</a></li>
<li>Use .http files in Visual Studio 2022: <a href="https://adpg.link/cbhv">https://adpg.link/cbhv</a></li>
<li>OpenAPI specification: <a href="https://adpg.link/M4Uz">https://adpg.link/M4Uz</a></li>
</ul>


<h2 data-number="5.8">Answers</h2>
<ol>
<li>An API usually returns the status code <code>201 Created</code> after creating a new entity.</li>
<li>No, it will not break clients because they will either be using the lowest API version or have already specified a specific version.</li>
<li>We typically use the HTTP GET method to read data from a REST API.</li>
<li>Yes, Data Transfer Objects (DTOs) can add flexibility and robustness to a system. They allow you to control exactly what data you expose to the client and can reduce the amount of unnecessary data that needs to be sent over the network.</li>
<li>Yes, DTOs are part of an API contract. They define the data format exchanged between the client and server, ensuring both sides understand the data being sent and received.</li>
</ol>


</body>
</html>
