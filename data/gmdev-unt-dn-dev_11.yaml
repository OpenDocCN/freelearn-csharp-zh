- en: '*Chapter 8*: The Scriptable Render Pipeline in Unity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：Unity中的可脚本化渲染管线'
- en: In the [*Chapter 7*](B17146_07_Final_ASB_ePub.xhtml#_idTextAnchor121), *Understanding
    the Mathematics of Computer Graphics in Unity*, we learned about the mathematics
    used in computer graphics. This knowledge is general computer graphics knowledge,
    and all 3D software and game engines use those mathematical concepts. For a game
    engine, rendering is one of the most important functions. In this chapter, we
    will specifically explore the rendering functions provided by Unity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B17146_07_Final_ASB_ePub.xhtml#_idTextAnchor121)“理解Unity中计算机图形学的数学”，我们学习了在计算机图形学中使用的数学知识。这些知识是通用的计算机图形学知识，所有3D软件和游戏引擎都使用这些数学概念。对于游戏引擎来说，渲染是其最重要的功能之一。在本章中，我们将具体探讨Unity提供的渲染功能。
- en: 'The following key topics will be explored in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨以下关键主题：
- en: An introduction to the Scriptable Render Pipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可脚本化渲染管线的介绍
- en: Working with Unity's Universal Render Pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Unity的通用渲染管线一起工作
- en: The Universal Render Pipeline shaders and materials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用渲染管线着色器和材质
- en: Increasing performance of the Universal Render Pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高通用渲染管线的性能
- en: By the end of this chapter, you will understand what the **Scriptable Render
    Pipeline** is and how to enable the Scriptable Render Pipeline-based **Universal
    Render Pipeline** and **High Definition Render Pipeline** in your project. You
    will also know how to use the **Universal Render Pipeline Asset** to configure
    your render pipeline and how to use the **Volume framework** to apply post-processing
    effects to your game. You will also know how to create a custom shader and material
    that can be used in the Universal Render Pipeline, how to use Unity's **Frame
    Debugger** tool to view the information of the rendering process, and how to use
    the **SRP Batcher** to reduce the number of draw calls in your project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解**可脚本化渲染管线**是什么，以及如何在你的项目中启用基于可脚本化渲染管线的**通用渲染管线**和**高清晰度渲染管线**。你还将知道如何使用**通用渲染管线资产**来配置你的渲染管线，以及如何使用**体积框架**将后处理效果应用到你的游戏中。你还将了解如何创建可以在通用渲染管线中使用的自定义着色器和材质，如何使用Unity的**帧调试器**工具查看渲染过程的信息，以及如何使用**SRP批处理器**减少你项目中的绘制调用次数。
- en: It sounds exciting! Now, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很令人兴奋！现在，让我们开始吧！
- en: An introduction to the Scriptable Render Pipeline
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可脚本化渲染管线的介绍
- en: Since its first release in 2004, the Unity game engine has grown into the world's
    most widely used real-time content creation platform. A large number of games
    are developed using the Unity game engine. At the same time, Unity is being rapidly
    applied to the content design and production process of traditional industries,
    including VR, AR, and MR simulation applications, architectural design display,
    automobile design and manufacturing, and even film and television animation production.
    The development of real-time rendering technology based on computer graphics is
    an important reason for the rapid growth and widespread use of the Unity engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自2004年首次发布以来，Unity游戏引擎已发展成为世界上使用最广泛的实时内容创作平台。大量游戏都是使用Unity游戏引擎开发的。同时，Unity正在迅速应用于传统产业的
    内容设计和生产过程，包括VR、AR和MR模拟应用、建筑设计展示、汽车设计和制造，甚至电影和电视动画制作。基于计算机图形学的实时渲染技术的发展是Unity引擎快速增长和广泛应用的重要原因。
- en: Before the Unity 2018 version, developers could only use the **built-in render
    pipeline** provided by Unity. Since the Unity engine itself is a closed source
    engine, the built-in render pipeline in Unity is like a black box for developers,
    and developers cannot know the specific logic implementation of rendering inside
    the Unity engine. Furthermore, games developed using Unity's built-in render pipeline
    will use the same set of rendering logic on different platforms. It is very difficult
    for developers to customize the render pipeline for different platforms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 2018版本之前，开发者只能使用Unity提供的**内置渲染管线**。由于Unity引擎本身是一个封闭源代码引擎，Unity中的内置渲染管线对开发者来说就像一个黑盒，开发者无法了解Unity引擎内部渲染的具体逻辑实现。此外，使用Unity内置渲染管线开发的游戏将在不同平台上使用相同的渲染逻辑。对于开发者来说，为不同平台定制渲染管线非常困难。
- en: With the release of the Scriptable Render Pipeline, developers can view its
    code directly on GitHub and use C# code to control the rendering process, customizing
    a unique rendering pipeline for their games or applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着可脚本渲染管线的发布，开发者可以直接在GitHub上查看其代码，并使用C#代码控制渲染过程，为他们的游戏或应用程序定制独特的渲染管线。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code of the Scriptable Render Pipeline on GitHub: [https://github.com/Unity-Technologies/Graphics](https://github.com/Unity-Technologies/Graphics).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到可脚本渲染管线的代码：[https://github.com/Unity-Technologies/Graphics](https://github.com/Unity-Technologies/Graphics)。
- en: The Scriptable Render Pipeline is a toolbox provided by Unity for developers,
    through which developers can freely implement specific rendering functions in
    Unity. For the convenience of developers, there are two pre-build render pipelines
    based on the Scriptable Render Pipeline available, namely the Universal Render
    Pipeline and the High Definition Render Pipeline.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可脚本渲染管线是Unity为开发者提供的一个工具箱，通过它开发者可以在Unity中自由实现特定的渲染功能。为了方便开发者，基于可脚本渲染管线提供了两个预构建的渲染管线，即通用渲染管线和高清渲染管线。
- en: 'By using Scriptable Render Pipeline-based pre-built render pipelines, we can
    directly modify a specific function in the render pipelines without having to
    implement a new pipeline from scratch, simultaneously obtaining excellent rendering
    results and continuous updates. Therefore, when using Unity to develop games,
    there are three ready-made render pipelines to choose from:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用基于可脚本渲染管线的预构建渲染管线，我们可以直接修改渲染管线中的特定功能，而无需从头开始实现一个新的管线，同时获得优秀的渲染效果和持续更新。因此，当使用Unity开发游戏时，有三个现成的渲染管线可供选择：
- en: The legacy built-in render pipeline
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的内置渲染管线
- en: The Universal Render Pipeline
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用渲染管线
- en: The High Definition Render Pipeline
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高清渲染管线
- en: Of course, you can also choose to develop your own render pipeline based on
    the Scriptable Render Pipeline.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以选择基于可脚本渲染管线开发自己的渲染管线。
- en: The following are some open source projects on GitHub made using the Universal
    Render Pipeline or the High Definition Render Pipeline, which you can download
    and use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用通用渲染管线或高清渲染管线在GitHub上制作的开源项目，你可以下载并使用。
- en: The Fontainebleau Demo
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fontainebleau 示例
- en: 'The first one is the **Fontainebleau Demo** project, made with the High Definition
    Render Pipeline:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目是使用高清渲染管线制作的**Fontainebleau 示例**项目：
- en: '![Figure 8.1 – The Fontainebleau Demo'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Fontainebleau 示例'
- en: '](img/Figure_8.01_B17146.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B17146.jpg)'
- en: Figure 8.1 – The Fontainebleau Demo
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Fontainebleau 示例
- en: 'As shown in *Figure 8.1*, this project allows you to walk in a forest in first-person
    mode. You can find the project here: [https://github.com/Unity-Technologies/FontainebleauDemo](https://github.com/Unity-Technologies/FontainebleauDemo).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 8.1 所示，这个项目允许你以第一人称模式在森林中行走。你可以在这里找到项目：[https://github.com/Unity-Technologies/FontainebleauDemo](https://github.com/Unity-Technologies/FontainebleauDemo)。
- en: The Spaceship Demo
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spaceship 示例
- en: 'The second project I want to introduce is the **Spaceship Demo** project. This
    is a playable AAA first-person mode demo, as shown in *Figure 8.2*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我要介绍的第二个项目是**Spaceship 示例**项目。这是一个可玩的高质量AAA第一人称模式演示，如图 8.2 所示：
- en: '![Figure 8.2 – The Spaceship Demo'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – Spaceship 示例'
- en: '](img/Figure_8.02_B17146.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B17146.jpg)'
- en: Figure 8.2 – The Spaceship Demo
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Spaceship 示例
- en: 'In this open source project, you can see how to implement GPU-accelerated particle
    effects, such as realistic flames, smoke, and electrical spark visual effects.
    You can find the project here: [https://github.com/Unity-Technologies/SpaceshipDemo](https://github.com/Unity-Technologies/SpaceshipDemo).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个开源项目中，你可以看到如何实现GPU加速的粒子效果，例如逼真的火焰、烟雾和电火花视觉效果。你可以在这里找到项目：[https://github.com/Unity-Technologies/SpaceshipDemo](https://github.com/Unity-Technologies/SpaceshipDemo)。
- en: The BoatAttack Demo
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BoatAttack 示例
- en: 'If you choose to use the Universal Render Pipeline as the render pipeline of
    your game, then this open source project is worth checking out:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择将通用渲染管线作为你游戏的渲染管线，那么这个开源项目值得一看：
- en: '![Figure 8.3 – The BoatAttack Demo'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – BoatAttack 示例'
- en: '](img/Figure_8.03_B17146.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B17146.jpg)'
- en: Figure 8.3 – The BoatAttack Demo
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – BoatAttack 示例
- en: 'As shown in *Figure 8.3*, this is a boat racing game, made using the Universal
    Render Pipeline. You can find the project here: [https://github.com/Unity-Technologies/BoatAttack](https://github.com/Unity-Technologies/BoatAttack).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.3*所示，这是一款使用通用渲染管线制作的赛船游戏。您可以在以下链接找到该项目：[https://github.com/Unity-Technologies/BoatAttack](https://github.com/Unity-Technologies/BoatAttack)。
- en: In addition to open source projects on GitHub, Unity also provides developers
    with free resources on Unity's **Asset Store** for developers to learn and use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了GitHub上的开源项目外，Unity还为开发者提供了Unity的**资产商店**上的免费资源，供开发者学习和使用。
- en: Here are some samples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些样本。
- en: 'The Heretic: Digital Human'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异教徒：数字人
- en: 'The first one I want to share is the **The Heretic: Digital Human** project
    on the Asset Store:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先想分享的是资产商店上的**异教徒：数字人**项目：
- en: '![Figure 8.4 – The Heretic: Digital Human on the Asset Store'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 资产商店中的异教徒：数字人'
- en: '](img/Figure_8.04_B17146.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B17146.jpg)'
- en: 'Figure 8.4 – The Heretic: Digital Human on the Asset Store'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 异教徒：资产商店中的数字人
- en: 'As shown in *Figure 8.4*, this is a free project that shows how to make a digital
    human with real skin, eyes, eyebrows, and so on. You can find the project here:
    [https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-digital-human-168620](https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-digital-human-168620).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.4*所示，这是一个免费项目，展示了如何制作具有真实皮肤、眼睛、眉毛等的数字人。您可以在以下链接找到该项目：[https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-digital-human-168620](https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-digital-human-168620)。
- en: 'The Heretic: VFX Character'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异教徒：VFX角色
- en: 'The second project is from **The Heretic** on the Asset Store as well, and
    it''s free to download:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目也来自资产商店上的**异教徒**，并且可以免费下载：
- en: '![Figure 8.5 – The Heretic: VFX Character'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 异教徒：VFX角色'
- en: '](img/Figure_8.05_B17146.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.05_B17146.jpg)'
- en: 'Figure 8.5 – The Heretic: VFX Character'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 异教徒：VFX角色
- en: 'As shown in *Figure 8.5*, this project demonstrates how to create a VFX-based
    character with the High Definition Render Pipeline in Unity. You can find the
    project here: [https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-vfx-character-168622](https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-vfx-character-168622).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.5*所示，该项目展示了如何在Unity中使用高清渲染管线创建基于VFX的角色。您可以在以下链接找到该项目：[https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-vfx-character-168622](https://assetstore.unity.com/packages/essentials/tutorial-projects/the-heretic-vfx-character-168622)。
- en: Well, after introducing a lot of projects based on Scriptable Render Pipeline,
    which are open source and free, are you more interested in this render pipeline
    now? If so, then we will briefly introduce the two pre-built render pipelines
    based on the Scriptable Render Pipeline, namely the Universal Render Pipeline
    and the High Definition Render Pipeline.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在介绍了许多基于Scriptable Render Pipeline的开源免费项目之后，您现在对这种渲染管线更感兴趣了吗？如果是这样，那么我们将简要介绍基于Scriptable
    Render Pipeline的两个预构建渲染管线，即通用渲染管线和高清渲染管线。
- en: Universal Render Pipeline
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用渲染管线
- en: The Universal Render Pipeline is a pre-built render pipeline based on the Scriptable
    Render Pipeline in Unity. As its name implies, this render pipeline can be used
    on all platforms supported by Unity. Different pipelines cannot be mixed, so once
    you choose to use the Universal Render Pipeline, the built-in render pipeline
    and the High Definition Render Pipeline will not be enabled.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通用渲染管线是Unity中基于Scriptable Render Pipeline的预构建渲染管线。正如其名称所暗示的，这个渲染管线可以在Unity支持的所有平台上使用。不同的管线不能混合，所以一旦您选择使用通用渲染管线，内置渲染管线和高清渲染管线将不会启用。
- en: Unity uses the legacy built-in render pipeline by default, but you can enable
    the Universal Render Pipeline in your project in different ways.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Unity默认使用传统的内置渲染管线，但您可以在项目中以不同的方式启用通用渲染管线。
- en: 'If you want to develop a new project, then you can use the **3D Sample Scene
    (URP)** project template provided by **Unity Hub** to create a new Universal Render
    Pipeline project:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想开发一个新项目，那么您可以使用**Unity Hub**提供的**3D示例场景（URP）**项目模板来创建一个新的通用渲染管线项目：
- en: '![Figure 8.6 – The 3D Sample Scene (URP) project template'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 3D示例场景（URP）项目模板'
- en: '](img/Figure_8.06_B17146.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.06_B17146.jpg)'
- en: Figure 8.6 – The 3D Sample Scene (URP) project template
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 3D示例场景（URP）项目模板
- en: 'As shown in *Figure 8.6*, the **3D Sample Scene (URP)** project template configures
    project settings to use the Universal Render Pipeline in the project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.6*所示，**3D示例场景（URP）**项目模板配置了项目设置以在项目中使用通用渲染管线：
- en: '![Figure 8.7 – A new URP project'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 新的URP项目'
- en: '](img/Figure_8.07_B17146.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.07_B17146.jpg)'
- en: Figure 8.7 – A new URP project
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 新的URP项目
- en: After waiting for the new project to be created, you can view the sample scene
    rendered using the Universal Render Pipeline, as shown in *Figure 8.7*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目创建完成后，您可以看到使用通用渲染管线渲染的示例场景，如图8.7所示。
- en: 'However, if you want to switch an existing project from the built-in render
    pipeline to the Universal Render Pipeline, recreating a new project using the
    Universal Render Pipeline is not suitable for your project. At this point, choosing
    to use Unity''s Package Manager to install the Universal Render Pipeline is a
    more suitable option:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想将现有项目从内置渲染管线切换到通用渲染管线，使用通用渲染管线重新创建一个新项目并不适合您的项目。在这种情况下，选择使用Unity的包管理器安装通用渲染管线是一个更合适的选择：
- en: '![Figure 8.8 – Opening the Package Manager window'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 打开包管理器窗口'
- en: '](img/Figure_8.08_B17146.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.08_B17146.jpg)'
- en: Figure 8.8 – Opening the Package Manager window
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 打开包管理器窗口
- en: 'The Package Manager window can be opened by clicking on **Window** | **Package
    Manager** in the Unity Editor toolbar, as shown in the previous figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在Unity编辑器的工具栏中点击**窗口** | **包管理器**来打开包管理器窗口，如图中所示：
- en: '![Figure 8.9 – Package Manager'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 包管理器'
- en: '](img/Figure_8.09_B17146.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.09_B17146.jpg)'
- en: Figure 8.9 – Package Manager
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 包管理器
- en: As shown in *Figure 8.9*, you can find the **Universal RP** package in the packages
    list and install it in your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8.9*所示，您可以在包列表中找到**通用RP**包并将其安装到您的项目中。
- en: In this section, we briefly introduced the Universal Render Pipeline and how
    to install it in your project. A more detailed introduction on how to use it will
    be covered in the *Working with Unity's Universal Render Pipeline* section. Next,
    let's continue our journey to briefly explore the High Definition Render Pipeline
    and how to install it in your project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了通用渲染管线及其在项目中的安装方法。更详细的介绍将在*使用Unity的通用渲染管线*部分进行。接下来，让我们继续简要探索高清渲染管线及其在项目中的安装方法。
- en: The High Definition Render Pipeline
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高清渲染管线
- en: 'The High Definition Render Pipeline is another pre-built render pipeline based
    on the Scriptable Render Pipeline in Unity. Unlike the Universal Render Pipeline,
    it does not support all platforms supported by Unity, only supporting high-end
    platforms. The following table shows the platforms supported by the High Definition
    Render Pipeline:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 高清渲染管线是基于Unity中的可脚本渲染管线构建的另一个预构建渲染管线。与通用渲染管线不同，它不支持Unity支持的所有平台，仅支持高端平台。以下表格显示了高清渲染管线支持的平台：
- en: '![](img/Figure_8.10_B17146.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10](img/Figure_8.10_B17146.jpg)'
- en: Figure 8.10 – The platforms supported by the High Definition Render Pipeline
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 高清渲染管线支持的平台
- en: As shown in the previous table, the High Definition Render Pipeline is currently
    mainly used for platforms such as consoles or desktop computers. If you are developing
    a mobile-oriented project, then the High Definition Render Pipeline is not a suitable
    choice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，高清渲染管线目前主要用于如游戏机或桌面电脑等平台。如果您正在开发面向移动设备的项目，那么高清渲染管线不是一个合适的选择。
- en: Since we want to cover as many usage scenarios as possible, this chapter will
    mainly focus on the use of the Universal Render Pipeline – hence the brief introduction
    to the High Definition Render Pipeline. However, if you want to try it or really
    need to use the High Definition Render Pipeline, installing it is very similar
    to installing the Universal Render Pipeline, as described earlier.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望涵盖尽可能多的使用场景，本章将主要关注通用渲染管线的使用——因此对高清渲染管线的简要介绍。然而，如果您想尝试它或确实需要使用高清渲染管线，安装过程与之前描述的安装通用渲染管线非常相似。
- en: Firstly, if you are starting a new project, you can use the **3D Sample Scene
    (HDRP)** project template provided by Unity Hub to create a new High Definition
    Render Pipeline project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您正在启动一个新项目，您可以使用Unity Hub提供的**3D示例场景（HDRP）**项目模板来创建一个新的高清渲染管线项目。
- en: 'As shown in *Figure 8.11*, the **3D Sample Scene (HDRP)** project template
    configures project settings to use the High Definition Render Pipeline in the
    project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 8.11* 所示，**3D 示例场景 (HDRP**) 项目模板配置了项目设置以在项目中使用高清渲染管道：
- en: '![Figure 8.11 – The 3D Sample Scene (HDRP) template'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – 3D 示例场景 (HDRP) 模板'
- en: '](img/Figure_8.11_B17146.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.11_B17146.jpg)'
- en: Figure 8.11 – The 3D Sample Scene (HDRP) template
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 3D 示例场景 (HDRP) 模板
- en: 'After waiting for the new project to be created, you can view the sample scene
    rendered using the High Definition Render Pipeline, as shown in *Figure 8.12*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待新项目创建完成后，你可以查看使用高清渲染管道渲染的示例场景，如图 *图 8.12* 所示：
- en: '![Figure 8.12 – A new HDRP project'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – 新的 HDRP 项目'
- en: '](img/Figure_8.12_B17146.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.12_B17146.jpg)'
- en: Figure 8.12 – A new HDRP project
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 新的 HDRP 项目
- en: 'Of course, you can also install the **High Definition RP** package from the
    Package Manager in Unity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还可以从 Unity 的包管理器中安装 **高清渲染管道** 包：
- en: '![Figure 8.13 – Installing High Definition RP via Package Manager'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13 – 通过包管理器安装高清渲染管道'
- en: '](img/Figure_8.13_B17146.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.13_B17146.jpg)'
- en: Figure 8.13 – Installing High Definition RP via Package Manager
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 通过包管理器安装高清渲染管道
- en: As shown in *Figure 8.13*, you can find the **High Definition RP** package in
    the packages list and install it to your project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 8.13* 所示，你可以在包列表中找到 **高清渲染管道** 包并将其安装到你的项目中。
- en: In this section, we briefly introduced the High Definition Render Pipeline and
    how to install it in your project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了高清渲染管道以及如何在你的项目中安装它。
- en: By reading this section, *An Introduction to the Scriptable Render Pipeline*,
    you should now have an understanding of what the Scriptable Render Pipeline is
    and how to install a Scriptable Render Pipeline-based Universal Render Pipeline
    and High Definition Render Pipeline in your project. Next, we will discuss in
    detail how to use the Universal Render Pipeline correctly in your project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本节，*脚本渲染管道简介*，你现在应该已经了解了脚本渲染管道是什么以及如何在你的项目中安装基于脚本渲染管道的通用渲染管道和高清渲染管道。接下来，我们将详细讨论如何在你的项目中正确使用通用渲染管道。
- en: Let's get started!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Working with Unity's Universal Render Pipeline
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 的通用渲染管道
- en: The Universal Render Pipeline is widely used by Unity developers. It is not
    only used to develop games for PC or video game consoles; you can also use it
    to develop mobile games.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通用渲染管道被 Unity 开发者广泛使用。它不仅用于开发 PC 或游戏机游戏；你还可以用它来开发移动游戏。
- en: 'We can create a new Universal Render Pipeline project through the Unity Hub
    project template. Through the project template, Unity will automatically set up
    all the render pipeline resources for us. The project also contains a sample scene,
    as shown in *Figure 8.14*. You can find a camera, a directional light, a spot
    light, a post-process volume, reflection probes, and some models in this scene:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Unity Hub 项目模板创建一个新的通用渲染管道项目。通过项目模板，Unity 将自动为我们设置所有渲染管道资源。该项目还包含一个示例场景，如图
    *图 8.14* 所示。你可以在该场景中找到一个摄像机、一个方向光、一个聚光灯、一个后处理体积、反射探针和一些模型：
- en: '![Figure 8.14 – The sample scene of the Universal Render Pipeline'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – 通用渲染管道的示例场景'
- en: '](img/Figure_8.14_B17146.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.14_B17146.jpg)'
- en: Figure 8.14 – The sample scene of the Universal Render Pipeline
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 通用渲染管道的示例场景
- en: For starters, this sample scene is a good starting point. We will use it to
    explain how to use the Universal Render Pipeline.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个示例场景是一个很好的起点。我们将用它来解释如何使用通用渲染管道。
- en: Exploring the sample scene
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索示例场景
- en: Let's first explore this sample scene. As you can see in *Figure 8.14*, this
    scene is not complicated, but it contains most of the functions of the Universal
    Render Pipeline. We will introduce these components in the scene separately.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索这个示例场景。如图 *图 8.14* 所示，这个场景并不复杂，但它包含了通用渲染管道的大部分功能。我们将分别介绍场景中的这些组件。
- en: The main camera
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主摄像机
- en: 'Let''s start with the main camera in the scene. We can select the **Main Camera**
    in the **Hierarchy** window to open the **Inspector** window of it, as shown in
    the following figure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从场景中的主摄像机开始。我们可以在 **层次结构** 窗口中选择 **Main Camera** 以打开其 **检查器** 窗口，如图下所示：
- en: '![Figure 8.15 – The Main Camera object'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.15 – 主摄像机对象'
- en: '](img/Figure_8.15_B17146.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.15_B17146.jpg)'
- en: Figure 8.15 – The Main Camera object
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 主摄像机对象
- en: There is a **Camera** component attached to the **Main Camera** object, which
    provides all the functions related to the camera object. You can set the background,
    culling mask, anti-aliasing setting, perspective settings of the camera, and so
    on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main Camera**对象上附加了一个**Camera**组件，它提供了与相机对象相关的所有功能。你可以设置背景、剔除遮罩、抗锯齿设置、相机的透视设置等。'
- en: Another component that you need to be aware of is the **Universal Additional
    Camera Data** component, which you can find at the bottom of *Figure 8.15*. If
    you are using the Universal Render Pipeline, Unity does not allow you to remove
    it from the camera because this component is used to store data internally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要注意的一个组件是**通用附加相机数据**组件，你可以在图8.15的底部找到它。如果你使用的是通用渲染管线，Unity不允许你从相机中移除它，因为这个组件用于内部存储数据。
- en: The directional light
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方向光
- en: There is only one directional light in this sample project, which is used to
    simulate the sunlight. You can modify the color, intensity, and shadow effect
    of the light by modifying the settings of the **Light** component attached to
    the light object in the scene. You can also modify the rotation property of the
    **Transform** component of the light object to adjust the direction of the directional
    light, as shown in *Figure 8.16*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例项目中只有一个方向光，用于模拟阳光。你可以通过修改场景中光对象上附加的**Light**组件的设置来修改光的颜色、强度和阴影效果。你还可以修改光对象的**Transform**组件的旋转属性来调整方向光的指向，如图8.16所示。
- en: '![Figure 8.16 – The Directional Light object'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 – 方向光对象'
- en: '](img/Figure_8.16_B17146.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B17146.jpg)'
- en: Figure 8.16 – The Directional Light object
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 方向光对象
- en: In this example, the intensity value of this light is **2**, and soft shadows
    are used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，这个光的强度值为**2**，并且使用了柔和的阴影。
- en: The Spot Light
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚光灯
- en: 'There are four types of lights in Unity, which are **Directional Light**, **Point
    Light**, **Spot Light**, and **Area Light**. In this sample scene, in addition
    to a directional light used to simulate the sunlight, there is also a spot light
    used to simulate a spotlight:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中有四种类型的灯光，分别是**方向光**、**点光**、**聚光灯**和**区域光**。在这个示例场景中，除了用于模拟阳光的方向光外，还有一个聚光灯用于模拟聚光灯：
- en: '![Figure 8.17 – The Spot Light object'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 – 聚光灯对象'
- en: '](img/Figure_8.17_B17146.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B17146.jpg)'
- en: Figure 8.17 – The Spot Light object
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 聚光灯对象
- en: 'As shown in the preceding figure, the effect of the spotlight object in Unity
    is like spotlights in the real world. The settings of a spot light are similar
    to the settings of a directional light in Unity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Unity中聚光灯对象的效果类似于现实世界中的聚光灯。聚光灯的设置与Unity中方向光的设置类似：
- en: '![Figure 8.18 – The Spot Light settings'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 – 聚光灯设置'
- en: '](img/Figure_8.18_B17146.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B17146.jpg)'
- en: Figure 8.18 – The Spot Light settings
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 聚光灯设置
- en: You still can modify the color, intensity, and shadow effect of the spot light
    by modifying the settings of the **Light** component attached to the **Spot Light**
    object, and you can also modify the range and the inner/outer spot angle of this
    spot light, as shown in *Figure 8.18*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以通过修改**Spot Light**对象上附加的**Light**组件的设置来修改聚光灯的颜色、强度和阴影效果，并且你也可以修改这个聚光灯的范围和内/外聚光角度，如图8.18所示。
- en: The Post-process Volume
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后处理体积
- en: 'Now, let''s take a look at the Post-process Volume object in the sample scene.
    In game development, post-processing is a technique that is often used to add
    various effects to a rendered image, common effects such as tone mapping, depth
    of field, bloom, anti-aliasing, and motion blur:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看示例场景中的后处理体积对象。在游戏开发中，后处理是一种常用于向渲染图像添加各种效果的技巧，常见的效果如色调映射、景深、光晕、抗锯齿和运动模糊：
- en: '![Figure 8.19 – Post-process Volume'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 后处理体积'
- en: '](img/Figure_8.19_B17146.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B17146.jpg)'
- en: Figure 8.19 – Post-process Volume
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 后处理体积
- en: The Universal Render Pipeline provides the **Volume** component and the **Volume
    Profile** object to manage different post-processing effects applied to rendered
    images, as shown in *Figure 8.19*. One advantage of using the **Volume** component
    is that component and specific settings can be decoupled. All settings on the
    **Volume** component come from the associated **Volume Profile** object. We will
    discuss the **Volume Profile** object in detail later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通用渲染管道提供了**体积**组件和**体积配置文件**对象来管理应用于渲染图像的不同后期处理效果，如图*图8.19*所示。使用**体积**组件的一个优点是组件和特定设置可以解耦。**体积**组件上的所有设置都来自相关的**体积配置文件**对象。我们将在稍后详细讨论**体积配置文件**对象。
- en: 'In this sample scene, the **Tonemapping**, **Bloom**, and **Vignette** effects
    are applied. If you''re curious about the original rendered image without post-processing,
    let''s see what happens when we disable this post-process volume:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例场景中，应用了**色调映射**、**光晕**和**晕影**效果。如果你对未经后期处理的原始渲染图像感兴趣，让我们看看当我们禁用这个后期处理体积时会发生什么：
- en: '![Figure 8.20 – The original image (top) versus the post-processed image (bottom)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 – 原始图像（顶部）与后期处理图像（底部）'
- en: '](img/Figure_8.20_B17146.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B17146.jpg)'
- en: Figure 8.20 – The original image (top) versus the post-processed image (bottom)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 原始图像（顶部）与后期处理图像（底部）
- en: '*Figure 8.20* shows a comparison of the original image and the post-processed
    image of the sample scene.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.20*显示了示例场景的原始图像和后期处理图像的比较。'
- en: The reflection probes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射探头
- en: 'A **reflection probe** can provide efficient reflection information for related
    models in a scene by sampling the scene around itself so that the surface of the
    model in the scene has a realistic reflection effect:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射探头**可以通过对其周围场景进行采样，为场景中相关的模型提供高效的反射信息，从而使场景中模型的表面具有逼真的反射效果：'
- en: '![Figure 8.21 – Reflection probes in the scene'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 场景中的反射探头'
- en: '](img/Figure_8.21_B17146.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.21_B17146.jpg)'
- en: Figure 8.21 – Reflection probes in the scene
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 场景中的反射探头
- en: In this sample scene, we can see there are three reflection probes as child
    objects of the GameObject named **Reflection Probes**, as shown in the preceding
    figure.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例场景中，我们可以看到有三个反射探头作为名为**Reflection Probes**的GameObject的子对象，如图所示。
- en: 'If we select one of these reflection probes, then the corresponding reflection
    probe will be displayed in the scene view and show the reflection information,
    as shown in *Figure 8.22*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择这些反射探头中的一个，那么相应的反射探头将在场景视图中显示，并显示反射信息，如图*图8.22*所示：
- en: '![Figure 8.22 – Viewing the reflection information in the scene'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – 查看场景中的反射信息'
- en: '](img/Figure_8.22_B17146.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.22_B17146.jpg)'
- en: Figure 8.22 – Viewing the reflection information in the scene
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 查看场景中的反射信息
- en: Since the reflection probes in different positions will obtain different reflection
    information, in order to use the reflection information correctly, they need to
    be placed in the proper place. While the definition of "proper place" varies from
    scene to scene, a general guideline is that you should place reflection probes
    near any large objects in the scene that will be significantly reflected. For
    example, place reflection probes in the areas around the center and corners of
    walls in the scene. Of course, this doesn't mean ignoring all the smaller objects
    in the scene. For example, a campfire in a scene may be a small object compared
    to a wall, but reflecting the fire from the campfire is just as important to create
    a realistic rendering of the scene.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同位置的反射探头会获得不同的反射信息，为了正确使用反射信息，它们需要放置在适当的位置。虽然“适当的位置”的定义因场景而异，但一个一般的指导原则是，你应该将反射探头放置在场景中任何将被显著反射的大物体附近。例如，将反射探头放置在场景中墙壁中心和角落的周围。当然，这并不意味着可以忽略场景中的所有小物体。例如，与墙壁相比，场景中的篝火可能是一个小物体，但反射篝火的光线对于创建场景的真实渲染同样重要。
- en: The Universal Render Pipeline asset
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用渲染管道资产
- en: Since this new sample project is created using the Universal Render Pipeline
    template, Unity has automatically set everything up for us to make the Universal
    Render Pipeline work properly. However, if your project is using the built-in
    render pipeline for development and you want to switch to using the Universal
    Render Pipeline, or if your project has been developed using the Universal Render
    Pipeline but you want to use another render pipeline, it is necessary to know
    how to set up it in Unity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个新的示例项目是使用通用渲染管道模板创建的，Unity 已经自动为我们设置好了一切，以便使通用渲染管道正常工作。然而，如果你的项目正在使用内置渲染管道进行开发，并且你想切换到使用通用渲染管道，或者如果你的项目已经使用通用渲染管道开发，但你想使用另一个渲染管道，那么了解如何在
    Unity 中设置它是非常必要的。
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we are using the **forward rendering path** in the Universal
    Render Pipeline. The so-called **rendering path** refers to a series of operations
    related to lighting and shading. Unity's built-in render pipeline provides different
    rendering paths, such as the forward rendering path and the **deferred rendering
    path**. After version 12.0.0 of the Universal Render Pipeline, developers can
    also use the deferred rendering path in the pipeline, but that is beyond the scope
    of this chapter. If you are interested in this topic, you can find out more at
    [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html)
    and [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/urp-universal-renderer.html#rendering-path-comparison](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/urp-universal-renderer.html#rendering-path-comparison).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们正在使用通用渲染管道中的 **前向渲染路径**。所谓的 **渲染路径** 指的是与光照和着色相关的一系列操作。Unity 的内置渲染管道提供了不同的渲染路径，例如前向渲染路径和
    **延迟渲染路径**。从通用渲染管道的 12.0.0 版本开始，开发者也可以在管道中使用延迟渲染路径，但这超出了本章的范围。如果你对这个主题感兴趣，你可以在
    [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html)
    和 [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/urp-universal-renderer.html#rendering-path-comparison](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/urp-universal-renderer.html#rendering-path-comparison)
    找到更多信息。
- en: 'We will walk you through the following steps to learn how to set up a render
    pipeline for your project in Unity:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引导你完成以下步骤，学习如何在 Unity 中为你的项目设置渲染管道：
- en: Let's start with the **Project Settings** window. You can open this window through
    **Edit** | **Project Settings** in the Unity Editor toolbar.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 **项目设置** 窗口开始。你可以在 Unity 编辑器的工具栏中通过 **编辑** | **项目设置** 打开这个窗口。
- en: 'Next, click the **Graphics** item in the category list on the left to open
    the **Graphics** Settings panel, as shown in *Figure 8.23*:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击左侧分类列表中的 **图形** 项以打开 **图形** 设置面板，如图 8.23 所示：
- en: '![Figure 8.23 – The Graphics settings'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.23 – 图形设置'
- en: '](img/Figure_8.23_B17146.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.23_B17146.jpg)'
- en: Figure 8.23 – The Graphics settings
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – 图形设置
- en: 'Let''s take a look at the **Scriptable Render Pipeline Settings** property
    in detail:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看 **可脚本渲染管道设置** 属性：
- en: The **Scriptable Render Pipeline Settings** property of the **Graphics** settings
    is associated with an object of the **Universal Render Pipeline Asset** type named
    **UniversalRP-HighQuality**, which is automatically created when this project
    is created using the template.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形** 设置的 **可脚本渲染管道设置** 属性与一个名为 **UniversalRP-HighQuality** 的 **通用渲染管道资产**
    类型的对象相关联，该对象在项目使用模板创建时自动创建。'
- en: If the **Scriptable Render Pipeline Settings** property of the **Graphics**
    settings is set to none, then Unity will use the default built-in render pipeline.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 **图形** 设置的 **可脚本渲染管道设置** 属性设置为无，那么 Unity 将使用默认的内置渲染管道。
- en: 'You can find this **Universal Render Pipeline Asset** object in the **Assets**
    > **Settings** folder of the project:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在项目的 **Assets** > **Settings** 文件夹中找到这个 **通用渲染管道资产** 对象：
- en: '![Figure 8.24 – The Universal Render Pipeline Asset objects'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.24 – 通用渲染管道资产对象'
- en: '](img/Figure_8.24_B17146.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.24_B17146.jpg)'
- en: Figure 8.24 – The Universal Render Pipeline Asset objects
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 – 通用渲染管道资产对象
- en: 'Then, select the **UniversalRP-HighQuality** object to open the **Inspector**
    window so that we can check the detailed information of this **Universal Render
    Pipeline Asset** object. As shown in *Figure 8.25*, a **Universal Render Pipeline
    Asset** object provides various settings for the current Universal Render Pipeline,
    such as rendering functions and rendering quality:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**UniversalRP-HighQuality**对象以打开**检查器**窗口，这样我们就可以检查该**通用渲染管线资产**对象的详细信息。如图*图
    8.25*所示，一个**通用渲染管线资产**对象为当前的通用渲染管线提供各种设置，例如渲染功能和渲染质量：
- en: '![Figure 8.25 – The Inspector window of this Universal Render Pipeline Asset
    object'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.25 – 该通用渲染管线资产对象的检查器窗口'
- en: '](img/Figure_8.25_B17146.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.25_B17146.jpg)'
- en: Figure 8.25 – The Inspector window of this Universal Render Pipeline Asset object
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25 – 该通用渲染管线资产对象的检查器窗口
- en: 'Next, let''s walk through these settings. We can configure the general settings
    of the render pipeline in the **General** section, as shown in *Figure 8.26*.
    For example, if the **Depth Texture** option is enabled, you can access the depth
    map generated by the render pipeline from your shader code:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，让我们逐一查看这些设置。我们可以在**通用**部分配置渲染管线的通用设置，如图*图 8.26*所示。例如，如果启用了**深度纹理**选项，你可以在着色器代码中访问渲染管线生成的深度图：
- en: '![Figure 8.26 – The General settings'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.26 – 通用设置'
- en: '](img/Figure_8.26_B17146.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.26_B17146.jpg)'
- en: Figure 8.26 – The General settings
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26 – 通用设置
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In game development, **depth textures** are used to represent the depth information
    of objects in 3D space from the camera's perspective.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，**深度纹理**用于表示从摄像机视角看 3D 空间中对象的深度信息。
- en: 'We can also control the global rendering quality:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以控制全局渲染质量：
- en: '![Figure 8.27 – The Quality settings'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.27 – 质量设置'
- en: '](img/Figure_8.27_B17146.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.27_B17146.jpg)'
- en: Figure 8.27 – The Quality settings
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 质量设置
- en: In *Figure 8.27*, we enable the global **HDR** option, and the global **Anti
    Aliasing** setting is **2x**. We can also modify the rendering resolution by adjusting
    the **Render Scale** slider.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 8.27*中，我们启用了全局**HDR**选项，全局**抗锯齿**设置为**2x**。我们还可以通过调整**渲染缩放**滑块来修改渲染分辨率。
- en: 'As a very important factor for real-time rendering, the lighting of the Universal
    Render Pipeline can also be configured in the **Lighting** section, as shown in
    *Figure 8.28*:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为实时渲染的一个重要因素，通用渲染管线的灯光也可以在**灯光**部分进行配置，如图*图 8.28*所示：
- en: '![Figure 8.28 – The Lighting settings'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.28 – 灯光设置'
- en: '](img/Figure_8.28_B17146.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.28_B17146.jpg)'
- en: Figure 8.28 – The Lighting settings
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 – 灯光设置
- en: The main light in the settings panel is the brightest directional light in the
    game scene. You can decide whether to enable it and whether to allow it to cast
    shadows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 设置面板中的主光源是游戏场景中最亮的方向性光源。你可以决定是否启用它以及是否允许它投射阴影。
- en: 'In *Figure 8.29*, you can find the **Shadows** settings under the **Lighting**
    settings. You can modify the parameters here to adjust what the shadows look like
    in Unity:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*图 8.29*中，你可以在**灯光**设置下找到**阴影**设置。你可以在此处修改参数以调整 Unity 中的阴影外观：
- en: '![Figure 8.29 – The Shadows settings'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.29 – 阴影设置'
- en: '](img/Figure_8.29_B17146.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.29_B17146.jpg)'
- en: Figure 8.29 – The Shadows settings
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 – 阴影设置
- en: 'Finally, let''s explore the **Advanced** settings:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，让我们探索**高级**设置：
- en: '![Figure 8.30 – The Advanced settings'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.30 – 高级设置'
- en: '](img/Figure_8.30_B17146.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.30_B17146.jpg)'
- en: Figure 8.30 – The Advanced settings
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.30 – 高级设置
- en: Here, we can check the **SRP Batcher** option to enable the SRP Batcher function
    to improve the performance of the Universal Render Pipeline, which we will explain
    in detail in the *Increasing performance of the Universal Render Pipeline* section.
    We can also modify the level of the **Debug** log output, as shown in *Figure
    8.30*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以检查**SRP 批处理器**选项以启用 SRP 批处理器功能，从而提高通用渲染管线的性能，我们将在*提高通用渲染管线性能*部分详细解释。我们还可以修改**调试**日志输出的级别，如图*图
    8.30*所示。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If there is no Universal Render Pipeline Asset in your project, you can create
    a new one by clicking **Assets** > **Create** > **Rendering** > **Universal Render
    Pipeline** > **Pipeline Asset** in the Unity Editor toolbar.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目中没有通用渲染管线资产，你可以在 Unity 编辑器的工具栏中点击**资产** > **创建** > **渲染** > **通用渲染管线**
    > **管线资产**来创建一个新的：
- en: In this section, we introduced the Universal Render Pipeline Asset in Unity
    and how to switch between different render pipelines by changing the **Scriptable
    Render Pipeline Settings** property of the **Graphics** settings. Next, we will
    explore another important asset in the Universal Render Pipeline, namely the Volume
    Profile.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Unity中的通用渲染管线资产以及如何通过更改**图形**设置的**脚本渲染管线设置**属性在不同的渲染管线之间切换。接下来，我们将探讨通用渲染管线中的另一个重要资产，即体积配置文件。
- en: The Volume framework and post-processing
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 体积框架和后处理
- en: The **Volume** framework is provided to game developers by the Scriptable Render
    Pipeline. By using this framework, developers can decouple a component from the
    specific settings of the component. Those render pipelines based on the Scriptable
    Render Pipeline, such as the Universal Render Pipeline and the High Definition
    Render Pipeline, use this framework.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**体积**框架由脚本渲染管线为游戏开发者提供。通过使用此框架，开发者可以将组件与其特定设置解耦。基于脚本渲染管线的渲染管线，如通用渲染管线和高清渲染管线，使用此框架。'
- en: 'As we mentioned before, the Universal Render Pipeline uses the **Volume** component
    and the **Volume Profile** object to manage different post-processing effects
    applied to rendered images. The following steps demonstrate how to enable the
    Volume framework and apply some post-processing effects to the sample project:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，通用渲染管线使用**体积**组件和**体积配置文件**对象来管理应用于渲染图像的不同后处理效果。以下步骤演示了如何启用体积框架并应用一些后处理效果到示例项目中：
- en: 'First of all, we need to add a **Volume** component to a GameObject in the
    scene to enable the Volume framework, as shown in the following figure:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在场景中的GameObject上添加一个**体积**组件来启用体积框架，如图所示：
- en: '![Figure 8.31 – Adding a Volume component'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.31 – Adding a Volume component](Figure 8.31 – 添加体积组件)'
- en: '](img/Figure_8.31_B17146.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.31_B17146.jpg](img/Figure_8.31_B17146.jpg)'
- en: Figure 8.31 – Adding a Volume component
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 – 添加体积组件
- en: 'In *Figure 8.31*, the **Profile** property of this **Volume** component is
    **0**, so we can either create a new **Volume Profile** file by clicking the **New**
    button below it or assign an existing **Volume Profile** file to it. Here, we
    will create a new **Volume Profile** file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*图8.31*中，该**体积**组件的**配置文件**属性为**0**，因此我们可以通过点击其下方的**新建**按钮创建一个新的**体积配置文件**，或者分配一个现有的**体积配置文件**给它。在这里，我们将创建一个新的**体积配置文件**：
- en: '![Figure 8.32 – Creating a new Volume Profile file'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.32 – Creating a new Volume Profile file](Figure 8.32 – 创建新的体积配置文件)'
- en: '](img/Figure_8.32_B17146.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.32_B17146.jpg](img/Figure_8.32_B17146.jpg)'
- en: Figure 8.32 – Creating a new Volume Profile file
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32 – 创建新的体积配置文件
- en: 'Click the **Add Override** button to open the **Volume Overrides** panel, and
    click the **Post-processing** item to open the **Post-processing** overrides list:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加覆盖**按钮打开**体积覆盖**面板，然后点击**后处理**项打开**后处理**覆盖列表：
- en: '![Figure 8.33 – Add Override'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.33 – Add Override](Figure 8.33 – 添加覆盖)'
- en: '](img/Figure_8.33_B17146.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.33_B17146.jpg](img/Figure_8.33_B17146.jpg)'
- en: Figure 8.33 – Add Override
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33 – 添加覆盖
- en: 'In *Figure 8.34*, you can see lots of post-processing effects in the **Post-processing**
    overrides list. You can choose the effects that you want to apply to the rendered
    image, such as **Bloom**:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*图8.34*中，您可以在**后处理**覆盖列表中看到许多后处理效果。您可以选择要应用于渲染图像的效果，例如**辉光**：
- en: '![Figure 8.34 – Post-processing effects'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.34 – Post-processing effects](Figure 8.34 – 后处理效果)'
- en: '](img/Figure_8.34_B17146.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.34_B17146.jpg](img/Figure_8.34_B17146.jpg)'
- en: Figure 8.34 – Post-processing effects
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34 – 后处理效果
- en: 'Finally, let''s modify the configuration of the **Bloom** effect; check the
    **Threshold** and **Intensity** options and set their values to **0.9** and **4**
    respectively, as shown in the following figure:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们修改**辉光**效果配置；检查**阈值**和**强度**选项，并将它们的值分别设置为**0.9**和**4**，如图所示：
- en: '![Figure 8.35 – Setting up the Bloom effect'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.35 – Setting up the Bloom effect](Figure 8.35 – 设置辉光效果)'
- en: '](img/Figure_8.35_B17146.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.35_B17146.jpg](img/Figure_8.35_B17146.jpg)'
- en: Figure 8.35 – Setting up the Bloom effect
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35 – 设置辉光效果
- en: 'After completing the preceding steps, switch to the game view. We can see the
    game scene in *Figure 8.36* after applying the **Bloom** effect:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的步骤后，切换到游戏视图。应用**辉光**效果后，我们可以在*图8.36*中看到游戏场景：
- en: '![Figure 8.36 – The applied Bloom effect image (top) versus the original image
    (bottom)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.36 – The applied Bloom effect image (top) versus the original image
    (bottom)](Figure 8.36 – 应用辉光效果后的图像（顶部）与原始图像（底部）对比)'
- en: '](img/Figure_8.36_B17146.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.36_B17146.jpg](img/Figure_8.36_B17146.jpg)'
- en: Figure 8.36 – The applied Bloom effect image (top) versus the original image
    (bottom)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36 – 应用辉光效果后的图像（顶部）与原始图像（底部）对比
- en: In this section, we started by exploring the sample scene that is included in
    the template to learn the functions of the Universal Render Pipeline. Then, we
    introduced how to switch between different render pipelines and the Universal
    Render Pipeline Assets. Finally, we demonstrated how to use the Volume framework
    to implement post-processing in the Universal Render Pipeline. The next stop of
    our journey is to explore the shaders and materials that are important for rendering
    in Unity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先通过探索模板中包含的示例场景来学习通用渲染管道的功能。然后，我们介绍了如何在不同的渲染管道和通用渲染管道资产之间切换。最后，我们演示了如何使用体积框架在通用渲染管道中实现后处理。我们旅程的下一站是探索对Unity中的渲染至关重要的着色器和材质。
- en: The Universal Render Pipeline shaders and materials
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用渲染管道着色器和材质
- en: '**Shaders** and **materials** are essential for rendering models in Unity.
    Shaders are used to provide algorithms to calculate the color of each pixel. A
    material provides various parameters for the shader associated with it to determine
    how to render the model, such as providing texture as the input of the shader
    and defining how the shader samples the texture:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**和**材质**对于在Unity中渲染模型至关重要。着色器用于提供算法来计算每个像素的颜色。材质为与其关联的着色器提供各种参数，以确定如何渲染模型，例如提供纹理作为着色器的输入并定义着色器如何采样纹理：'
- en: '![Figure 8.37 – Materials and shaders'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.37 – 材质和着色器'
- en: '](img/Figure_8.37_B17146.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.37_B17146.jpg)'
- en: Figure 8.37 – Materials and shaders
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37 – 材质和着色器
- en: If we select a model in the scene, such as the safety hat model, the material
    settings will be displayed in the **Inspector** window, as shown in *Figure 8.37*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在场景中选择一个模型，例如安全帽模型，材质设置将在**检查器**窗口中显示，如图*图8.37*所示。
- en: Commonly used shaders
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用着色器
- en: Each material can be associated with a specified shader, and the parameters
    required by this shader are displayed in the **Inspector** window. The commonly
    used shader when using the Universal Render Pipeline is **Universal Render Pipeline/Lit**,
    and this safety hat model is rendered using this shader as well. By adjusting
    various parameters, the **Universal Render Pipeline/Lit** shader can be used to
    render different material surfaces, such as metal, glass, and wood.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每种材质都可以与指定的着色器相关联，并且该着色器所需的参数将在**检查器**窗口中显示。在使用通用渲染管道时，常用的着色器是**通用渲染管道/Lit**，并且这个安全帽模型也是使用这个着色器渲染的。通过调整各种参数，**通用渲染管道/Lit**着色器可以用于渲染不同的材质表面，如金属、玻璃和木材。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The shader with **Lit** in its name implies that this shader will perform lighting
    calculations. The shader with **Unlit** in the name means that the shader does
    not consider the lighting factor when calculating the color of a pixel.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为**Lit**的着色器意味着这个着色器将执行光照计算。命名为**Unlit**的着色器表示该着色器在计算像素颜色时不会考虑光照因素。
- en: 'We can change the shader associated with a material by selecting a different
    one through the **Shader** drop-down window, as shown in *Figure 8.38*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择不同的着色器通过**着色器**下拉窗口来更改材质相关的着色器，如图*图8.38*所示：
- en: '![Figure 8.38 – Shaders'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.38 – 着色器'
- en: '](img/Figure_8.38_B17146.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.38_B17146.jpg)'
- en: Figure 8.38 – Shaders
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38 – 着色器
- en: 'Once we have determined the shader associated with the material, we can then
    provide various parameters for this specific shader through this material:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了与材质关联的着色器，我们就可以通过这个材质提供各种特定着色器的参数：
- en: '![Figure 8.39 – The parameters of the shader'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.39 – 着色器的参数'
- en: '](img/Figure_8.39_B17146.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.39_B17146.jpg)'
- en: Figure 8.39 – The parameters of the shader
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39 – 着色器的参数
- en: 'In *Figure 8.39*, developers can specify various maps in the **Surface Inputs**
    section for the **Universal Render Pipeline/Lit** shader. The textures associated
    with these map parameters are used to provide different information for the shader.
    We will explain in detail as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.39*中，开发者可以在**表面输入**部分为**通用渲染管道/Lit**着色器指定各种贴图。与这些贴图参数相关的纹理用于为着色器提供不同的信息。以下将详细解释：
- en: '**Base Map** is used to provide the base color of the surface to the shader.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础贴图**用于向着色器提供表面的基础颜色。'
- en: '**Metallic Map** is used to provide metallic workflow information to the shader
    to determine how "metal-like" the surface is.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金属贴图**用于向着色器提供金属工作流程信息，以确定表面“金属”程度。'
- en: '**Normal Map** is used to add more details to the surface of the model that
    do not exist on the original model.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线贴图**用于向模型表面添加原始模型上不存在的更多细节。'
- en: '**Occlusion Map** is used to provide information to the shader to simulate
    shadows from ambient lighting.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡贴图**用于向着色器提供信息，以模拟环境光照产生的阴影。'
- en: 'The parameters required by different shaders may be different, and due to different
    shader algorithms, the final rendering results are also different:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不同着色器所需的参数可能不同，由于着色器算法的不同，最终的渲染结果也有所不同：
- en: '![Figure 8.40 – The Unlit shader'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Unity还为开发者提供了一个功能，可以自动将现有材质升级到通用渲染管线材质。您可以在Unity编辑器工具栏中通过点击**编辑** > **渲染管线**
    > **通用渲染管线** > **将项目材质升级到通用RP材质**来找到它，如前图所示。
- en: '](img/Figure_8.40_B17146.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.43_B17146.jpg)'
- en: Figure 8.40 – The Unlit shader
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.40 – 无光照着色器
- en: 'For example, if we change the shader associated with this material to **Universal
    Render Pipeline/Unlit**, then only **Base Map** remains in the **Surface Inputs**
    section to provide the base color for the surface:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当将正在使用内置渲染管线开发的项目更改为使用通用渲染管线时，开发者经常会遇到一个称为“材质错误”的问题：
- en: '![Figure 8.41 – The safety hat model'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.41 – 安全帽模型'
- en: '](img/Figure_8.41_B17146.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.41 – 安全帽模型'
- en: Figure 8.41 – The safety hat model
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.41 – 安全帽模型
- en: The safety hat model rendered with this material will only display the basic
    color and will no longer be affected by any lighting. You can see the difference
    between the safety hat model and the surrounding models in the preceding screenshot.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此材料渲染的安全帽模型将只显示基本颜色，并且将不再受任何光照的影响。您可以在前面的屏幕截图中看到安全帽模型与周围模型之间的差异。
- en: Upgrading project materials to Universal Render Pipeline materials
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![图 8.40 – 无光照着色器'
- en: As we mentioned at the beginning of this chapter, if you choose to use the Universal
    Render Pipeline, the built-in render pipeline will no longer be available. This
    includes not only the built-in render pipeline itself but also the shaders used
    with the built-in render pipeline.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，如果您选择使用通用渲染管线，内置渲染管线将不再可用。这不仅包括内置渲染管线本身，还包括与内置渲染管线一起使用的着色器。
- en: 'Therefore, when changing an existing project that is being developed using
    the built-in render pipeline to use the Universal Render Pipeline, developers
    often encounter a problem known as "material errors":'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.40 – 无光照着色器'
- en: '![Figure 8.42 – The built-in Standard shader cannot be used in the Universal
    Render Pipeline'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.42 – 内置标准着色器不能在通用渲染管线中使用'
- en: '](img/Figure_8.42_B17146.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将与此材质关联的着色器更改为**通用渲染管线/无光照**，那么在**表面输入**部分中只剩下**基础贴图**以提供表面的基础颜色：
- en: Figure 8.42 – The built-in Standard shader cannot be used in the Universal Render
    Pipeline
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.42 – 内置标准着色器不能在通用渲染管线中使用
- en: For example, we can change the shader used to render the safety hat model from
    **Universal Render Pipeline/Unlit** to the built-in **Standard** shader. Then,
    you can see that the safety hat model displays a pink color, which means that
    there is an error in the material, as shown in the preceding figure.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.42 – 无光照着色器'
- en: Therefore, if your project is developing using the built-in render pipeline
    but you need to switch to using the Universal Render Pipeline, then in order to
    ensure that the Universal Render Pipeline can work correctly, you need to upgrade
    the existing materials to Universal Render Pipeline materials.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您的项目正在使用内置渲染管线进行开发，但需要切换到使用通用渲染管线，那么为了确保通用渲染管线可以正确工作，您需要将现有的材质升级到通用渲染管线材质。
- en: 'You can manually modify the shaders associated with the existing materials,
    such as replacing the built-in **Standard** shader with the **Universal Render
    Pipeline/Lit** shader:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动修改与现有材质关联的着色器，例如将内置的**标准**着色器替换为**通用渲染管线/Lit**着色器：
- en: '![Figure 8.43 – Upgrading the project materials'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.43 – 升级项目材质'
- en: '](img/Figure_8.43_B17146.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将渲染安全帽模型所使用的着色器从**通用渲染管线/无光照**更改为内置的**标准**着色器。然后，您可以看到安全帽模型显示为粉红色，这意味着材质中存在错误，如前图所示。
- en: Figure 8.43 – Upgrading the project materials
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.43 – 升级项目材质
- en: On the other hand, Unity also provides a function for developers to upgrade
    existing materials to Universal Render Pipeline materials automatically. You can
    find it by clicking **Edit** > **Render Pipeline** > **Universal Render Pipeline**
    > **Upgrade Project Materials to UniversalRP Materials** in the Unity Editor toolbar,
    as shown in the preceding screenshot.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 升级项目材质到通用渲染管线材质
- en: '![Figure 8.44 – Material Upgrader'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.44 – 材质升级器'
- en: '](img/Figure_8.44_B17146.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.44_B17146.jpg)'
- en: Figure 8.44 – Material Upgrader
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.44 – 材质升级器
- en: Then, the **Material Upgrader** window will pop up. As shown in *Figure 8.44*,
    the changes cannot be undone, so if you want to upgrade all of the materials in
    your project to Universal Render Pipeline materials and have backed up the project,
    click the **Proceed** button.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将弹出**材质升级器**窗口。如图8.44所示，更改是不可逆的，因此如果你想要将项目中所有的材质升级到通用渲染管线材质，并且已经备份了项目，请点击**继续**按钮。
- en: Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This **Material Upgrader** tool can only upgrade the built-in shaders to Universal
    Render Pipeline shaders but not the custom shaders created by developers. Therefore,
    the custom shaders still need to be modified manually.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**材质升级器**工具只能将内置着色器升级到通用渲染管线着色器，但不能升级开发者创建的自定义着色器。因此，自定义着色器仍然需要手动修改。
- en: Creating a shader and a Shader Graph
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建着色器和着色器图
- en: Sometimes, you may want to create a new shader to implement some custom features
    that can be used with the Universal Render Pipeline. There are two ways to do
    it – you can either create a new shader file or a Shader Graph file.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要创建一个新的着色器来实现一些可以与通用渲染管线一起使用的自定义功能。有两种方法可以实现这一点——你可以创建一个新的着色器文件或着色器图文件。
- en: Creating a new shader file
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的着色器文件
- en: 'First of all, even if our project uses the Universal Render Pipeline, we can
    still use the legacy way to create custom shader files using shader templates
    in the built-in render pipeline in Unity. As shown in *Figure 8.45*, we can click
    **Assets** > **Create** > **Shader** to create a new shader:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，即使我们的项目使用通用渲染管线，我们仍然可以使用传统的办法，在Unity内置的渲染管线中使用着色器模板来创建自定义着色器文件。如图8.45所示，我们可以点击**资产**
    > **创建** > **着色器**来创建一个新的着色器：
- en: '![Figure 8.45 – Create a shader file'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.45 – 创建着色器文件'
- en: '](img/Figure_8.45_B17146.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.45_B17146.jpg)'
- en: Figure 8.45 – Create a shader file
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.45 – 创建着色器文件
- en: 'Some built-in shader templates are listed, such as `CustomShader`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了一些内置的着色器模板，例如`CustomShader`：
- en: '![Figure 8.46 – CustomShader'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.46 – 自定义着色器'
- en: '](img/Figure_8.46_B17146.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.46_B17146.jpg)'
- en: Figure 8.46 – CustomShader
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.46 – 自定义着色器
- en: Then, a shader file is created in our project, as shown in the preceding figure.
    You can open a shader source file in your IDE by double-clicking it, and then
    you can use Unity's **ShaderLab language** to write shader code that defines how
    Unity calculates the color rendered for each pixel.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的项目中创建了一个着色器文件，如图中所示。你可以通过双击它来在你的IDE中打开着色器源文件，然后你可以使用Unity的**ShaderLab语言**来编写着色器代码，该代码定义了Unity如何计算每个像素的渲染颜色。
- en: Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: How to write shaders in Unity's ShaderLab language is beyond the scope of this
    chapter, but if you're interested, you can find more information at [https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@7.7/manual/writing-custom-shaders-urp.html](mailto:https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@7.7/manual/writing-custom-shaders-urp.html).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的ShaderLab语言中如何编写着色器超出了本章的范围，但如果你感兴趣，可以在[https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@7.7/manual/writing-custom-shaders-urp.html](mailto:https://docs.unity.cn/Packages/com.unity.render-pipelines.universal@7.7/manual/writing-custom-shaders-urp.html)找到更多信息。
- en: In addition to creating a shader file, we can also create a new custom Shader
    Graph file to render these models in the scene. Let's continue.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建着色器文件，我们还可以创建一个新的自定义着色器图文件来渲染场景中的这些模型。让我们继续。
- en: Creating a new Shader Graph file
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的着色器图文件
- en: Compared with the legacy way of creating a shader file, creating a new **Shader
    Graph** file is easier. The Shader Graph feature was introduced to Unity for the
    first time in Unity 2018\. When developing a Shader Graph file, you don't need
    to write shader code but use the visualization node to develop directly.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建着色器文件的传统方法相比，创建一个新的**着色器图**文件更容易。着色器图功能首次在Unity 2018中引入。在开发着色器图文件时，你不需要编写着色器代码，而是直接使用可视化节点进行开发。
- en: 'We can still create a new unlit shader, but this time, we will use Shader Graph
    instead of a shader file, as shown in the following steps below:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以创建一个新的无光照着色器，但这次，我们将使用着色器图而不是着色器文件，如下面的步骤所示：
- en: 'As shown in *Figure 8.47*, click `CustomShaderGraph`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如图8.47所示，点击`CustomShaderGraph`：
- en: '![Figure 8.47 – Creating a new Shader Graph file'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.47 – 创建新的着色器图文件'
- en: '](img/Figure_8.47_B17146.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.47_B17146.jpg)'
- en: Figure 8.47 – Creating a new Shader Graph file
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.47 – 创建新的着色器图文件
- en: 'A new Shader Graph file is created, and its suffix is `.shadergraph`, as shown
    in the following figure:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个新的着色器图文件，其扩展名为`.shadergraph`，如图所示：
- en: '![Figure 8.48 – A Shader Graph file'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.48 – Shader 图文件'
- en: '](img/Figure_8.48_B17146.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.48_B17146.jpg)'
- en: Figure 8.48 – A Shader Graph file
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.48 – Shader 图文件
- en: 'Double-click this file, and this time, the Shader Graph file will not be opened
    in an IDE but a visual node editor, displayed directly in the Unity Editor, as
    shown in *Figure 8.49*:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击此文件，这次 Shader 图文件将不会在 IDE 中打开，而是在 Unity 编辑器中直接显示一个视觉节点编辑器，如图 *图 8.49* 所示：
- en: '![Figure 8.49 – The Shader Graph editor'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.49 – Shader 图编辑器'
- en: '](img/Figure_8.49_B17146.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.49_B17146.jpg)'
- en: Figure 8.49 – The Shader Graph editor
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.49 – Shader 图编辑器
- en: 'This visual node editor is a lot to take in, so let''s walk through it in more
    detail:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视觉节点编辑器有很多内容需要理解，所以让我们更详细地了解一下：
- en: In Unity, a shader usually consists of two parts, namely the **Vertex** program
    and the **Fragment** program.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unity 中，一个着色器通常由两部分组成，即**顶点**程序和**片段**程序。
- en: The **Vertex** program is usually used to convert the 3D coordinates of the
    vertices of the model into 2D coordinates in the screen space. We already introduced
    the knowledge of coordinate systems in the previous chapter. In this example,
    there are three nodes in the vertex program, namely **Position**, **Normal**,
    and **Tangent**.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点**程序通常用于将模型的顶点在屏幕空间中的 3D 坐标转换为 2D 坐标。我们在上一章中已经介绍了坐标系的知识。在这个例子中，顶点程序中有三个节点，即**位置**、**法线**和**切线**。'
- en: Alternatively, the **Fragment** program determines the color of the pixels,
    and in this example, the **Fragment** program only has one node, named **Base
    Color**.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，**片段**程序确定像素的颜色，在这个例子中，**片段**程序只有一个节点，名为**基础颜色**。
- en: You can also preview the result of this shader in the **Main Preview** window
    in the lower-right corner, as shown in *Figure 8.49*. This shader we just created
    here will render pixels in blue.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以在右下角的**主预览**窗口中预览此着色器的结果，如图 *图 8.49* 所示。我们刚刚创建的着色器将用蓝色渲染像素。
- en: Now that we've created a new Shader Graph file and opened it in the Shader Graph
    editor, which allows us to edit, add, and delete nodes, we will next take a look
    at how to edit a node in a Shader Graph file. Let's go!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个新的 Shader 图文件，并在 Shader 图编辑器中打开它，这允许我们编辑、添加和删除节点，接下来我们将看看如何在 Shader
    图文件中编辑一个节点。让我们开始吧！
- en: Editing the properties of a node in Shader Graph
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Shader 图中编辑节点的属性
- en: 'We can edit the properties of an existing node in the Shader Graph file. As
    we mentioned earlier, there is a node named **Base Color**, so let''s edit this
    node as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Shader 图文件中编辑现有节点的属性。如我们之前提到的，有一个名为**基础颜色**的节点，所以让我们按照以下方式编辑此节点：
- en: '![Figure 8.50 – Edit the Base Color node'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.50 – 编辑基础颜色节点'
- en: '](img/Figure_8.50_B17146.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.50_B17146.jpg)'
- en: Figure 8.50 – Edit the Base Color node
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.50 – 编辑基础颜色节点
- en: In the Shader Graph editor, select the **Base Color** node in the **Fragment**
    section.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Shader 图编辑器中，选择**片段**部分中的**基础颜色**节点。
- en: Click the color input of this node to open the color picker window.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此节点的颜色输入以打开颜色选择器窗口。
- en: Select the color you want to use in the color picker window – in this case,
    we chose yellow for the **Base Color** node. The **Main Preview** window shows
    us what's happening to the shader, as shown in *Figure 8.50*.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在颜色选择器窗口中选择您想要使用的颜色 – 在这种情况下，我们为**基础颜色**节点选择了黄色。**主预览**窗口显示了着色器正在发生的情况，如图 *图
    8.50* 所示。
- en: As you can see, it is very easy to modify an existing node; in addition to modifying
    a node, we can also create a new one to provide more data to the shader. Let's
    continue.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，修改现有节点非常简单；除了修改节点外，我们还可以创建一个新的节点，为着色器提供更多数据。让我们继续。
- en: Adding a new node in Shader Graph
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Shader 图中添加新节点
- en: 'Developing a shader usually involves sampling a texture and returning a color
    value for the shader to use. Let''s perform the following steps to add a new node
    to add the ability to sample textures to our example shader:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 开发着色器通常涉及采样纹理并返回一个颜色值供着色器使用。让我们执行以下步骤，向我们的示例着色器添加一个新节点，以添加采样纹理的能力：
- en: 'Right-click in the Shader Graph editor and select **Create Node** from the
    pop-up menu:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Shader 图编辑器中右键单击，并从弹出菜单中选择**创建节点**：
- en: '![Figure 8.51 – Creating a node'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.51 – 创建节点'
- en: '](img/Figure_8.51_B17146.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.51_B17146.jpg)'
- en: Figure 8.51 – Creating a node
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.51 – 创建节点
- en: 'Enter `texture` in the search bar in the top-left corner of the **Create Node**
    window, and then select **Sample Texture 2D** item in the results list:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建节点**窗口的右上角搜索栏中输入`texture`，然后在结果列表中选择**采样纹理 2D**项：
- en: '![Figure 8.52 – Selecting the Sample Texture 2D node'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.52 – 选择Sample Texture 2D节点'
- en: '](img/Figure_8.52_B17146.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.52_B17146.jpg)'
- en: Figure 8.52 – Selecting the Sample Texture 2D node
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.52 – 选择Sample Texture 2D节点
- en: 'As shown in *Figure 8.53*, a new **Sample Texture 2D** node is created. Click
    the **Texture** slot of this node to provide the texture asset:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图8.53*所示，创建了一个新的**Sample Texture 2D**节点。点击此节点的**Texture**插槽以提供纹理资产：
- en: '![Figure 8.53 – Clicking the Texture slot of the node'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.53 – 点击节点的Texture插槽'
- en: '](img/Figure_8.53_B17146.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.53_B17146.jpg)'
- en: Figure 8.53 – Clicking the Texture slot of the node
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.53 – 点击节点的Texture插槽
- en: 'Select a texture from the pop-up **Select Texture** window:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的**选择纹理**窗口中选择一个纹理：
- en: '![Figure 8.54 – Selecting a texture'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.54 – 选择纹理'
- en: '](img/Figure_8.54_B17146.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.54_B17146.jpg)'
- en: Figure 8.54 – Selecting a texture
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.54 – 选择纹理
- en: 'Then, as shown in *Figure 8.55*, the **Sample Texture 2D** node samples the
    texture from its **Texture** input and gets the texture''s color:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如*图8.55*所示，**Sample Texture 2D**节点从其**Texture**输入采样纹理并获取纹理的颜色：
- en: '![Figure 8.55 – Loading data from a texture asset'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.55 – 从纹理资产加载数据'
- en: '](img/Figure_8.55_B17146.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.55_B17146.jpg)'
- en: Figure 8.55 – Loading data from a texture asset
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.55 – 从纹理资产加载数据
- en: Now, we have added a new node to the Shader Graph file, but the color obtained
    from texture sampling is still stored in the **Sample Texture 2D** node. Next,
    we need to connect it with the **Base Color** node in the **Fragment** section
    so that the shader can render the pixels with the colors obtained from this texture.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在Shader Graph文件中添加了一个新的节点，但从纹理采样得到的颜色仍然存储在**Sample Texture 2D**节点中。接下来，我们需要将其与**Fragment**部分的**Base
    Color**节点连接起来，以便着色器可以使用从该纹理获取的颜色渲染像素。
- en: Connect two nodes in Shader Graph
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Shader Graph中连接两个节点
- en: 'We can pass data such as color from one node to another by connecting two nodes
    in a Shader Graph file, so let''s connect the **Sample Texture 2D** node with
    the **Base Color** node using the following steps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在Shader Graph文件中连接两个节点，将数据（如颜色）从一个节点传递到另一个节点，因此让我们按照以下步骤将**Sample Texture
    2D**节点与**Base Color**节点连接起来：
- en: 'Click the radio button next to the **RGBA(4)** output, as shown in *Figure
    8.56*:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图8.56*所示，点击**RGBA(4)**输出的旁边的单选按钮：
- en: '![Figure 8.56 – Clicking the radio button'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.56 – 点击单选按钮'
- en: '](img/Figure_8.56_B17146.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.56_B17146.jpg)'
- en: Figure 8.56 – Clicking the radio button
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.56 – 点击单选按钮
- en: 'After that, a line that can be dragged freely will appear:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将出现一条可以自由拖动的线：
- en: '![Figure 8.57 – A line will appear'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.57 – 出现一条线'
- en: '](img/Figure_8.57_B17146.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.57_B17146.jpg)'
- en: Figure 8.57 – A line will appear
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.57 – 出现一条线
- en: 'Drag this line to the color input of the **Base Color** node. As shown in *Figure
    8.58*, we connected these two nodes, and the **Main Preview** window shows us
    that the shader has rendered the pixel using the color obtained from the texture:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此线拖动到**Base Color**节点的颜色输入。如*图8.58*所示，我们连接了这两个节点，**主预览**窗口显示着色器已使用从纹理获取的颜色渲染了像素：
- en: '![Figure 8.58 – Connecting two nodes'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.58 – 连接两个节点'
- en: '](img/Figure_8.58_B17146.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.58_B17146.jpg)'
- en: Figure 8.58 – Connecting two nodes
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.58 – 连接两个节点
- en: Now you should know how to create a Shader Graph file and how to modify, add,
    and connect nodes in it. As developers, we do not need to write shader code when
    using Shader Graph, but Unity will automatically generate shader code based on
    the content of the Shader Graph file.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该知道如何创建Shader Graph文件以及如何修改、添加和连接其中的节点。作为开发者，在使用Shader Graph时，我们不需要编写着色器代码，Unity将根据Shader
    Graph文件的内容自动生成着色器代码。
- en: In this section, we introduced knowledge related to Universal Render Pipeline
    shaders and materials, then demonstrated how to upgrade a built-in material to
    Universal Render Pipeline material, and finally, explored how to create a custom
    shader that can be used in the Universal Render Pipeline. Next, we will continue
    to discuss how to find performance issues and improve performance of the Universal
    Render Pipeline.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了与通用渲染管道着色器和材质相关的知识，然后演示了如何将内置材质升级为通用渲染管道材质，最后探讨了如何创建一个可以在通用渲染管道中使用的自定义着色器。接下来，我们将继续讨论如何查找性能问题并提高通用渲染管道的性能。
- en: Increasing performance of the Universal Render Pipeline
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高通用渲染管道的性能
- en: Rendering is a major function of a game engine. Therefore, it is very important
    to understand how to use Unity's render pipeline efficiently. In this section,
    the topic we will discuss is performance.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染是游戏引擎的主要功能之一。因此，了解如何有效地使用Unity的渲染管线非常重要。在本节中，我们将讨论的主题是性能。
- en: The Frame Debugger
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧调试器
- en: First, we should learn how to use tools to view and locate performance bottlenecks
    caused by rendering in Unity.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该学习如何使用工具来查看和定位由Unity中的渲染引起的性能瓶颈。
- en: The **Frame Debugger** tool in the Unity Editor is our recommended tool, which
    allows us to easily view the entire process of rendering a frame in Unity.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器中的**帧调试器**工具是我们推荐的工具，它允许我们轻松查看Unity中渲染一帧的整个过程。
- en: 'Let''s follow the following steps to see how Unity''s render pipeline renders
    a frame of your game:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来了解Unity的渲染管线是如何渲染您游戏的一帧的：
- en: 'Start the game in the editor by clicking the **Play** button:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**播放**按钮在编辑器中启动游戏：
- en: '![Figure 8.59 – Playing the game in the editor'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.59 – 在编辑器中播放游戏'
- en: '](img/Figure_8.59_B17146.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.59_B17146.jpg]'
- en: Figure 8.59 – Playing the game in the editor
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.59 – 在编辑器中播放游戏
- en: 'Click **Window** > **Analysis** > **Frame Debugger** in the Unity Editor toolbar
    to open the **Frame Debugger** window, as shown in *Figure 8.60*:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的工具栏中点击**窗口** > **分析** > **帧调试器**以打开**帧调试器**窗口，如图*图8.60*所示：
- en: '![Figure 8.60 – Opening the Frame Debugger'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.60 – 打开帧调试器'
- en: '](img/Figure_8.60_B17146.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.60_B17146.jpg]'
- en: Figure 8.60 – Opening the Frame Debugger
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.60 – 打开帧调试器
- en: In the **Frame Debug** window, click the **Enable** button to take a snapshot
    of the current frame of your game, as shown in *Figure 8.61*:![Figure 8.61 – The
    Frame Debugger
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**帧调试器**窗口中，点击**启用**按钮来捕捉您游戏当前帧的快照，如图*图8.61*所示：![Figure 8.61 – 帧调试器
- en: '](img/Figure_8.61_B17146.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.61_B17146.jpg]'
- en: Figure 8.61 – The Frame Debugger
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.61 – 帧调试器
- en: 'In *Figure 8.62*, we can see there are **109** draw calls, which call to the
    graphics APIs, such as **OpenGL**, **Direct3D**, and **Vulkan**, to draw objects.
    We can also select a specific draw call to view the detailed information of it:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*图8.62*中，我们可以看到有**109**个绘制调用，这些调用调用图形API，如**OpenGL**、**Direct3D**和**Vulkan**来绘制对象。我们还可以选择一个特定的绘制调用来查看其详细信息：
- en: '![Figure 8.62 – Viewing the draw call information'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.62 – 查看绘制调用信息'
- en: '](img/Figure_8.62_B17146.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.62_B17146.jpg]'
- en: Figure 8.62 – Viewing the draw call information
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.62 – 查看绘制调用信息
- en: Through the Frame Debugger tool, we can understand the entire rendering process
    and view the information of a specific draw call, which provides us with insight
    to determine what should be done to improve rendering performance. For example,
    in *Figure 8.62*, we can see that **33** draw calls are used to render opaque
    objects. Therefore, reducing the count of draw calls here is what we should do.
    Next, we will introduce how to use the SRP Batcher to do it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过帧调试器工具，我们可以理解整个渲染过程并查看特定绘制调用的信息，这为我们提供了确定如何提高渲染性能的见解。例如，在*图8.62*中，我们可以看到使用了**33**个绘制调用来渲染不透明对象。因此，减少这里的绘制调用数量是我们应该做的事情。接下来，我们将介绍如何使用SRP
    Batcher来实现这一点。
- en: The SRP Batcher
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SRP Batcher
- en: The **SRP Batcher** is a feature provided by the Scriptable Render Pipeline,
    so every render pipeline based on the Scriptable Render Pipeline can use this
    feature to reduce the number of draw calls and improve rendering performance.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRP Batcher**是Scriptable Render Pipeline提供的一项功能，因此每个基于Scriptable Render Pipeline的渲染管线都可以使用此功能来减少绘制调用次数并提高渲染性能。'
- en: In order to ensure that the SRP Batcher can work correctly in your project,
    you need to ensure two things. The first is to enable the **SRP Batcher** function
    of the Universal Render Pipeline, and the second is to ensure that the shaders
    in your project are compatible with the SRP Batcher.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保SRP Batcher可以在您的项目中正确工作，您需要确保两件事。第一是启用通用渲染管线的**SRP Batcher**功能，第二是确保您项目中的着色器与SRP
    Batcher兼容。
- en: 'Let''s first make sure that the SRP Batcher is enabled in the render pipeline.
    As we mentioned in *The Universal Render Pipeline Asset* subsection, we can enable
    it by checking the **SRP Batcher** option in the **Advanced** settings of the
    Universal Render Pipeline Asset file that our project is using, as shown in *Figure
    8.63*:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保渲染管线中启用了SRP Batcher。正如我们在*《通用渲染管线资产》子节*中提到的，我们可以通过检查我们项目使用的通用渲染管线资产文件的**高级**设置中的**SRP
    Batcher**选项来启用它，如图*图8.63*所示：
- en: '![Figure 8.63 – Enabling the SRP Batcher'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.63 – 启用SRP Batcher'
- en: '](img/Figure_8.63_B17146.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.63_B17146.jpg)'
- en: Figure 8.63 – Enabling the SRP Batcher
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.63 – 启用SRP Batcher
- en: 'Next, let''s check whether the shaders we are using to render these opaque
    objects are compatible with the SRP Batcher:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查我们用于渲染这些不透明对象的着色器是否与SRP Batcher兼容：
- en: '![Figure 8.64 – The SRP Batcher compatibility status of the shader'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.64 – 着色器的SRP Batcher兼容性状态'
- en: '](img/Figure_8.64_B17146.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.64_B17146.jpg)'
- en: Figure 8.64 – The SRP Batcher compatibility status of the shader
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.64 – 着色器的SRP Batcher兼容性状态
- en: We can find the SRP Batcher compatibility status of the shader in the **Inspector**
    window, as shown in the preceding figure. Here, the **Universal Render Pipeline/Lit**
    shader is used, which is compatible with the SRP Batcher.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**检查器**窗口中找到着色器的SRP Batcher兼容性状态，如图中所示。在这里，使用的是**通用渲染管线/Lit**着色器，它与SRP
    Batcher兼容。
- en: 'Now, let''s run the game and check the Frame Debugger again:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行游戏并再次检查帧调试器：
- en: '![Figure 8.65 – The number of draw calls is reduced'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.65 – 绘制调用次数减少'
- en: '](img/Figure_8.65_B17146.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.65_B17146.jpg)'
- en: Figure 8.65 – The number of draw calls is reduced
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.65 – 绘制调用次数减少
- en: As you can see in *Figure 8.65*, the total number of draw calls has been reduced
    from **109** to **91**, the number of draw calls used to render opaque objects
    has been reduced from **33** to **20**, and each draw call is marked as **SRP
    Batch**.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*图8.65*中可以看到的，总的绘制调用次数已经从**109**减少到**91**，用于渲染不透明对象的绘制调用次数已经从**33**减少到**20**，并且每个绘制调用都被标记为**SRP
    Batch**。
- en: In this section, we started by introducing how to use Unity's Frame Debugger
    tool to view the entire rendering process and the information of a specific draw
    call. Then, we also explored how to reduce the number of draw calls and improve
    rendering performance by using the SRP Batcher.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先介绍了如何使用Unity的帧调试器工具来查看整个渲染过程和特定绘制调用的信息。然后，我们还探讨了如何通过使用SRP Batcher来减少绘制调用次数并提高渲染性能。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduces three ready-made render pipelines to choose from in
    Unity, namely the legacy built-in render pipeline and two pre-made render pipelines
    based on the Scriptable Render Pipeline – the Universal Render Pipeline and the
    High Definition Render Pipeline. At the same time, we also introduced some open
    source projects that use these render pipelines for you to learn and use.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Unity中可以选择的三个现成的渲染管线，即传统的内置渲染管线和基于可脚本渲染管线（Scriptable Render Pipeline）的两个预制渲染管线——通用渲染管线和高清渲染管线。同时，我们还介绍了一些使用这些渲染管线的开源项目，供你学习和使用。
- en: Then, we discussed how to use the Universal Render Pipeline in Unity by first
    exploring a sample scene, and then we explained how to use the Universal Render
    Pipeline Asset to configure your render pipeline and the Volume framework to apply
    post-processing effects to your game.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何在Unity中使用通用渲染管线，首先通过探索一个示例场景，然后解释了如何使用通用渲染管线资产来配置你的渲染管线以及如何使用体积框架来对你的游戏应用后处理效果。
- en: We also introduced the concept of shaders and materials, demonstrated how to
    upgrade a built-in material to Universal Render Pipeline material, and explored
    how to create a custom shader that can be used in the Universal Render Pipeline.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了着色器和材质的概念，演示了如何将内置材质升级为通用渲染管线材质，并探讨了如何创建一个可以在通用渲染管线中使用的自定义着色器。
- en: Finally, we explored how to use Unity's Frame Debugger tool to view the information
    of the rendering process and how to use the SRP Batcher to reduce the number of
    draw calls.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何使用Unity的帧调试器工具来查看渲染过程的信息以及如何使用SRP Batcher来减少绘制调用次数。
- en: By reading this chapter, you should now understand how to work with the Universal
    Render Pipeline correctly in Unity. In the next chapter, we will introduce how
    to use the **Data-Oriented Technology Stack** (**DOTS**) in Unity.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你现在应该已经理解了如何在Unity中正确地使用通用渲染管线。在下一章中，我们将介绍如何在Unity中使用**面向数据的技术堆栈**（**DOTS**）。
