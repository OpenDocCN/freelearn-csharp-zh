- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have the knowledge and skills of an intermediate .NET MAUI programmer.
    You’ve seen how to lay out controls and manage and manipulate those controls.
    You then learned about the MVVM design pattern. These are the fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you advanced to Shell navigation, using SQLite for data persistence
    and the all-important skill of writing unit tests with mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This final chapter will take you beyond that level into the realm of expert
    .NET MAUI knowledge. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting data templates at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing visual state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Community Toolkit behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking action with triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics).
    If you wish to follow along, be sure to use the code from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting data templates at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You saw data templates in use with collection views in [*Chapter 5*](B19723_05.xhtml#_idTextAnchor092).
    Let’s revisit that code and expand upon it to allow us to modify the display of
    each object at runtime, based on the data in the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we started with `PreferenceService`, where we mocked getting a list
    of `Preference` objects. Now, we can get that from the API, with just a little
    work. Modify `IPreferenceService` to remove `GetPreferencesMock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to significantly rework `PreferenceService` to interact with
    the client. Delete what you have and use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s nothing new here; it is directly parallel to what we saw in [*Chapter
    10*](B19723_10.xhtml#_idTextAnchor187) when obtaining the *Buddies*. Now that
    we have a collection of `Preference` objects, we can display them in a `CollectionView`,
    just as we did in [*Chapter 5*](B19723_05.xhtml#_idTextAnchor092) (as shown here
    in `PreferencesPage`, as seen in the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the CollectionView’s `ItemTemplate` is declared *inline*, in the
    declaration of `CollectionView` itself. That is not the only way to declare an
    `ItemTemplate`, however. Let’s see how to do it another way.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring ItemTemplates as resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can take `ItemTemplate` out of the definition of `CollectionView` and move
    it up into a `ResourceDictionary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what we’ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: At the top of the file, we declared a `Resources` section with a `ResourceDictionary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2]`: We created `DataTemplate` and gave it a key so that we can refer to
    it later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3]`: The rest of `DataTemplate` is just as it was inside `CollectionView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollectionView` is now much simpler – it simply declares its `ItemTemplate`
    property to be our created `StaticResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is valuable but is hardly all that exciting except that it opens up a new
    possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Where to put the DataTemplate
  prefs: []
  type: TYPE_NORMAL
- en: Here, we show `DataTemplate` in the resources section, but you can put it in
    a different file as well.
  prefs: []
  type: TYPE_NORMAL
- en: The DataTemplate selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create two or more additional DataTemplates in the same `ResourceDictionary`.
    This allows you to have .NET MAUI examine each *item* as it is about to display
    it and choose among the available DataTemplates based on a condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that when we get the preferences, some will have values and some will
    not. Let’s say we want to tell the user to enter a value by turning the prompt
    red when the value is empty. We can create two DataTemplates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: The first data template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2]`: The normal text colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3]`: The second data template (with its own key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[4]`: The *empty* text colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the obvious question is, how does .NET MAUI know which to display? For
    that, we need a `DataTemplateSelector`.
  prefs: []
  type: TYPE_NORMAL
- en: The DataTemplateSelector class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you must do is create a class that will contain the logic as
    to which template to display. I’ve named that class `PreferenceDataTemplateSelector`.
    Since I only intend to have one, I put it in the `Services` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: Your class must derive from `DataTemplateSelector`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[2]`: You need a public property for each of your DataTemplates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3]`: Override the `OnSelectTemplate` virtual method.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[4]`: Add the logic as to which template to display.'
  prefs: []
  type: TYPE_NORMAL
- en: With the class in place, we need to have a corresponding resource.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the template selector to the page’s resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Return to `PreferencesPage.xaml`. In the page declaration, add `Xmlns:services="clr-namespace:ForgetMeNotDemo.Services"`.
    Then, in `ResourceDictionary`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This provides the link to the names in the class we just created. We now have
    the logic, but how do we hook it up to `CollectionView`?
  prefs: []
  type: TYPE_NORMAL
- en: Adding DataTemplateSelector to CollectionView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hooking all this into `CollectionView` is as simple as setting an `ItemTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And it all comes together. `CollectionView` looks to `PreferenceDataTemplateSelector`
    in the resources, which is tied to the class we created that holds the logic as
    to which `DataTemplate` to show. The result is shown in *Figure 11**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – DataTemplate selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – DataTemplate selection
  prefs: []
  type: TYPE_NORMAL
- en: '`DataTemplateSelector` is a very powerful way to control what is displayed
    at runtime. A similar mechanism is encapsulated in the concept of Visual State.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Visual State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every `VisualElement` has a *Visual State* at any given moment (for example,
    does `VisualElement` have *focus*? Is it *selected*?). You can imagine responding
    to that state programmatically in C#, but there are advantages to responding to
    changes in visual state declaratively, in the XAML. Doing so puts more of the
    UI management in one place – your view (for example, `MainPage.xaml`).
  prefs: []
  type: TYPE_NORMAL
- en: VisualElement
  prefs: []
  type: TYPE_NORMAL
- en: '`VisualElement` is the base class of all controls (and pages).'
  prefs: []
  type: TYPE_NORMAL
- en: The object that sets visual properties on `VisualElement` based on its state
    is the `VisualStates` and displays a `VisualElement` according to the properties
    set in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This forces the question: what are visual states?'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the common visual states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET MAUI defines a set of common visual states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Normal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Has focus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Is selected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mouse over` (for Windows and macOS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET MAUI also allows you to define your own visual states, though that is less
    common.
  prefs: []
  type: TYPE_NORMAL
- en: You use these visual states to set properties on `VisualElement`. For example,
    you might change the appearance of a button based on its `VisualState`. An example
    will make this much clearer.
  prefs: []
  type: TYPE_NORMAL
- en: A button VisualState example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you first go to the **Login** page, you will see that the **Submit** button
    is disabled. We’d like it to be gray. Once you fill in the **Your Email** and
    **Password** fields, the button should turn light green. If you tab to the button,
    it should signify that it has the focus by turning fully green. You can do all
    this declaratively by creating visual states, as shown in *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Visual states of buttons
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the visual state on an individual button, or, as we will do here,
    you can put the visual state’s XAML into a style and apply it to all the buttons.
    Here is the complete `Style` for buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: We start by declaring a normal `Style` – in this case, it’s implicit
    for every button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2]`: You may have one or more groups of visual states (we have one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3]`: The first group (and in this case, the only one) is `CommonStates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[4]`: We declare each `VisualState` in turn (here, we’re starting with `Normal`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[5]`: For each state, we can declare a set of Setters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[6]`: Our first (and in this case, only) `Setter` sets the `BackgroundColor`
    property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then go on to set the Setters for all the other states. Notice that we did
    not set a `Setter` for `PointerOver`, which means that, on Windows and macOS,
    if you hover the mouse over the button, there will be no change.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI defines specialized visual states for controls. For example, `Button`
    adds the *Pressed* state, while `CheckBox` adds the *IsChecked* state and `CollectionViews`
    adds *Selected*.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET MAUI Community Toolkit provides further help for managing the appearance
    and behavior of your app with a large collection of behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Community Toolkit behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already seen one *behavior* from the *Community Toolkit* that turns an
    event into a command (`EventToCommandBehavior`), allowing us to respond to these
    events in our `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: The Community Toolkit is open source
  prefs: []
  type: TYPE_NORMAL
- en: The Community Toolkit is not officially part of .NET MAUI and consists of code
    supplied by (surprise!) the community – that is, developers independent of Microsoft.
    That said, the Microsoft documentation includes and increasingly integrates the
    Community Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: '`CommunityToolkit` provides a suite of behaviors to handle many other common
    programming needs. Many of these behaviors assist with validating input. For example,
    the `CommunityToolkit` includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Character validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required string validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You attach behaviors to controls. For example, let’s add a rule to the **Login**
    page stating that the username must be a valid email address. First, in the header,
    add the needed namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You are then ready to test for a valid email using the Community Toolkit behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: Begin the `Behaviors` section of the `Entry` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[2]`: Choose which behavior you want (in this case, email validation).'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3]`: Identify the style for an invalid email address.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[4]`: Identify the style for a valid email address.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[5]`: Add validation behaviors. They have flags to indicate when to do the
    validation (in this case, when the value changes), as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Validation flags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Validation flags
  prefs: []
  type: TYPE_NORMAL
- en: There are several other non-validating behaviors as well. These include behaviors
    to assist with animating views, progress bar animation, a behavior to assist with
    customizing the color and style of your device’s status bar, and a behavior to
    trigger an action when the user stops typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last of these can be very helpful when allowing the user to search a large
    set of data. Rather than having the search be incremental as the user types, or
    forcing the user to tap a **Search** button, you can have the search begin when
    the user stops typing for a specified period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: When the user stops typing, call this command in your `ViewModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2]`: Pass this parameter (the text of `Entry`) to the command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3]`: Don’t execute the command unless at least this many characters have
    been entered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[4]`: When you execute the command, put away the keyboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[5]`: Wait this long (half a second) to indicate the user has stopped typing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you add this to your XAML, and the user enters `Shoe` in the entry, the
    command is fired and the parameter is sent. *Figure 11**.4* shows the parameter
    being passed into the command handler in `PreferencesPageViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Passing in the search string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Passing in the search string
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors are a way to declare how the system should perform in XAML. Another
    powerful mechanism for moving responsive actions into the XAML triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Taking action with triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Triggers* allow you to declare how a control should appear in your XAML based
    on data changes. You can also use *state triggers* to change a control’s *Visual
    State*, as shown earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we may want to enforce that the `DataTrigger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1]`: This starts the `Triggers` collection of `Button`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2]`: This creates a `DataTrigger` and sets it to bind to the length of the
    text in the entry control whose name is `passwordEntry`. Set `TargetType` to `Button`
    (required) and the value for it to trigger on (that is, if the length of the password
    entry text is `0`, then fire the trigger).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3]`: This code uses a setter to declare what happens when the trigger fires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, when the **Password** field is empty, the **Create** button should
    be disabled and as soon as it is not empty, the button should be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected behavior
  prefs: []
  type: TYPE_NORMAL
- en: 'The field you are checking (`Password`) must have its text initialized to `""`
    for this to work. Otherwise, it will be null and the trigger may not act as expected.
    To solve this, initialize the property in `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[``observableproperty]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public string password =` `string.Empty;`'
  prefs: []
  type: TYPE_NORMAL
- en: The result of this trigger is shown in *Figure 11**.5* and *Figure 11**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Trigger when the Password field is empty
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11**.5*, the **Password** field is empty, while in *Figure 11**.6*,
    a character has been typed into the **Password** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Trigger when the Password field is not empty
  prefs: []
  type: TYPE_NORMAL
- en: For fun, change `Property` from `IsEnabled` to `IsVisible`. Now, the button
    is not there when you enter the page, but will appear when you put a character
    into the **Password** field.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we reviewed four key advanced topics that allow you to manage
    the behavior of your app declaratively:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting data templates allows you to change the display of your data based
    on the specific content of each element in a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the view state allows you to modify the appearance of a control based
    on the *state* of that control (for example, does it have focus?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behaviors allow, among other things, data validation and otherwise assist in
    providing actions that you declare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers change the appearance of controls based on data values in other controls
    or based on the state of other controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This brings us to the end of `.Net MAUI for C# Developers`. You are now fully
    equipped to create real-world professional .NET MAUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: The key to success with .NET MAUI, as with so many programming skills, is hands-on
    experience. If you are not currently working on a .NET MAUI project, you will
    want to assign one to yourself while this information is front and center in your
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an application idea I’ve had for years, which you are free to write
    (and sell if you want). I’ll give it to you without restriction:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a nice-looking application that gathers all the books on an online bookstore
    (using their public API) that you rated with five stars. Next, gather all the
    people who have also rated a large percentage of those books five stars. Exclude
    anyone who gave any of those books less than five stars. Now, take those people
    who seem to agree with you, and find any books they rated as five stars that you’ve
    not read yet. Those are books you’ll want to read.
  prefs: []
  type: TYPE_NORMAL
- en: Enjoy the project! I hope you have enjoyed this book.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why would you use the Visual State Manager?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does .NET MAUI decide which data template to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a behavior that is not used for validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a trigger fires, how does it know what to do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify the **Login** page so that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Disables the **Login** button unless the username is a valid email address and
    the password has at least one character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifies the **Forgot Password** button to double in size and turn pink when
    you tab onto it (giving it the focus), and returns to its normal size and color
    when it loses focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains answers to questions from all chapters.
  prefs: []
  type: TYPE_NORMAL
- en: "Chapter 1, Assembling Your Tools and Creating Your \LFirst App"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create a new project from the launch dialog by choosing **Create a new
    project**. If you’ve been brought directly into Visual Studio, by clicking on
    **File** | **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **View** | **Solution Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.xaml` extension indicates that the file contains XAML markup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code-behind file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MauiProgram.cs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3, XAML and Fluent C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XAML is a markup language based on XML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: XAML is used in .NET MAUI for declaring layouts and controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than writing in XAML, you can create your layouts and controls in C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We nest a layout or a control inside a layout by using the `Children` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An event handler is a method that is registered to an event in the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The event handler is in the code-behind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4, MVVM and Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVVM has two main advantages. First, it is nearly impossible to unit test a
    .NET MAUI application if your logic is in the code-behind file – putting the logic
    in `ViewModel` is essential, as we’ll see in the upcoming chapter on unit testing.
    Second, MVVM nicely decouples the UI from your logic, allowing you to change one
    without breaking the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The all-important `BindingContext`. You typically assign `ViewModel` as the
    binding context for `View`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Entry` control and the `Editor` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Label` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SnackBar` is a highly configurable `Toast` – a popup that comes up from the
    bottom of the page and then can disappear either by its timer running out or by
    a user clicking on it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5, Advanced Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ActivityIndicator` shows that *something* is happening, while `ProgressBar`
    tells the user what fraction of the task is complete.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The essential difference as far as we are concerned is that events are typically
    handled in the code-behind, while commands are handled in `ViewModel`. Handling
    commands in `ViewModel` is preferable because it makes creating unit tests easier
    or possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WeakReferenceManager` is the primary object used in messaging, allowing `ViewModel`
    to send notifications to `View` or another `ViewModel` without a reference to
    that object, thus supporting loose coupling.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Styles allow you to create a uniform appearance across instances of controls,
    centralizing the properties and providing all the advantages of well-factored
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One way to refactor styles is to create a base style and then use `BasedOn`
    to create derived types, adding or overriding properties as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6, Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stars, `auto`, and the value in dpi
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate 100 dpi to the last column, the needed size for the second column,
    and then divide the first and third columns proportionally as 2:1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The row and column offsets are defined by enumerated constants
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Grid` allows for more precise alignment and placement of controls'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BindableLayout` does not allow you to make selections'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7, Understanding Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AppShell.xaml`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Title`, `ContentTemplate`, and `Icon`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AppShell.xaml.cs`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Shell.Current.GoToAsync`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL syntax or using a dictionary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8, Storing and Retrieving Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Preferences` (not to be confused with `UserPreferences`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key and a default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SQLite-net-pcl** and possibly **SQLitePCLRaw.bundle_green**, if not included
    with **SQLite-net-pcl**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SQLiteAsyncConnection`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9, Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are critical for ensuring the quality of your code and allow you
    to add to and change your code with the confidence of knowing that if you break
    something, you’ll find out about it right away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of the testable code in a .NET MAUI application will be in the ViewModel
    or, possibly, the services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you need a slower service to test a method in your code, a mock can stand
    in for that service and give you immediate responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to provide a mock to your test, you must be able to inject it into
    the code in lieu of the runtime object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10, Consuming REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DTO is responsible for holding data that will be sent to and/or from the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The database is now in the cloud and managed through the API. As the client,
    we don’t know, nor need to know, what kind of database is in use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It wraps all the API calls so that a client can interact with the API as if
    it were a **Plain Old CLR** **Object** (**POCO**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Account creation is accomplished in the cloud via the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication is accomplished in the cloud via the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11, Exploring Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To modify the appearance of a control based on its *state*, such as whether
    or not it has the focus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the XAML, add a `DataTemplateSelector` to indicate the potential templates
    and then add a class that derives from `DataTemplateSelector` that overrides `OnSelectTemplate`
    and returns `DataTemplate` to be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have seen the `EventToCommand` behavior, which allows you to add commands
    to controls that only have events, allowing you to handle the event/command in
    `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You add setters with the property to change and the value to set it to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
