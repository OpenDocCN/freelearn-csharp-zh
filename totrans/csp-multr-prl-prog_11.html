<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. The Asynchronous Programming Model</h1></div></div></div><p>In this chapter, we will be learning about the new <code class="literal">async</code> and <code class="literal">await</code> keywords provided in .NET 4.5, along with the<a id="id622" class="indexterm"/> <strong>Asynchronous Programming Model</strong> (<strong>APM</strong>). The <code class="literal">async</code> and <code class="literal">await</code> keywords are .NET's latest method for making asynchronous and multithreaded programming simple for the developer. These new keywords make using the <code class="literal">BackgroundWorker</code> component harder to justify. The <code class="literal">async</code> keyword makes it seamless to turn an ordinary method into an asynchronous method that runs on a separate thread. Then you can continue processing in the main thread. When you are ready to wait for the results of the asynchronous method, you can then use the <code class="literal">await</code> keyword in your main thread to block until the method returns.</p><p>The Asynchronous Programming Model uses the <code class="literal">IAsyncResult</code> interface to accomplish the same type of design. In this design pattern, you create a delegate and then use the <code class="literal">BeginInvoke</code> and <code class="literal">EndInvoke</code> methods of the delegate to start the method and wait on it to complete. You can also use the <code class="literal">IAsyncResult</code> interface that is returned by the <code class="literal">BeginInvoke</code> method to poll to see if the asynchronous method has completed, or set a <code class="literal">wait</code> handle for the asynchronous method to complete.</p><p>These two methods give us easy ways to implement functionality similar to the <code class="literal">BackgroundWorker</code> component that is used so heavily in Windows Forms applications and earlier versions of .NET. This functionality is especially useful in desktop applications when we do not want the main thread of the application to block. There are few things worse in desktop application design than having a user click on a button and the whole user interface freezes while some function is being performed.</p><p>Let's start by looking at the Asynchronous Programming Model and how to use this design pattern to run a method in a thread separate from the main thread. Then we will have the main thread wait on its results.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Asynchronous Programming Model</li><li class="listitem" style="list-style-type: disc">Using an <code class="literal">AsyncCallback</code> delegate method</li><li class="listitem" style="list-style-type: disc">The <code class="literal">async</code> and <code class="literal">await</code> keywords</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Introduction to the Asynchronous Programming Model</h1></div></div></div><p>The Asynchronous<a id="id623" class="indexterm"/> Programming Model is used by .NET classes to implement asynchronous designs. One example is the <code class="literal">BeginRead</code> and <code class="literal">EndRead</code> methods of <code class="literal">FileStream</code>. This allows the <code class="literal">FileStream</code> class to implement an asynchronous file read. The <code class="literal">StreamReader</code> and <code class="literal">StreamWriter</code> classes also have asynchronous methods. They implement this functionality using the <code class="literal">IAsyncResult</code> interface. In your customer classes, you can also implement this interface to allow you to have asynchronous functionality.</p><p>The naming convention when using this interface is to prefix your method names with <code class="literal">Begin</code> and <code class="literal">End</code>. So, you would name one <code class="literal">BeginMyMethod</code> and the other <code class="literal">EndMyMethod</code>. The first method is the one you execute asynchronously. The second method is what you call to block your main thread when you want to wait on the <code class="literal">Begin</code> method to end and have it also return the results.</p><p>Now, let's look at an example using the <code class="literal">BeginRead</code> and <code class="literal">EndRead</code> methods of the <code class="literal">FileStream</code> class. This same technique can be implemented using your own classes and implementing the <code class="literal">IAsyncResult</code> interface. You do not have to prefix your method names with <code class="literal">Begin</code> and <code class="literal">End</code>, but it is a good programming practice to follow the naming convention so that future developers using your classes will intuitively understand how they operate.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec95"/>How to do it</h2></div></div></div><p>First, let's open up Visual Studio and create a new console project called <code class="literal">FileReadAsync</code>. Then, let's perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two <code class="literal">using</code> statements for the <code class="literal">IO</code> and <code class="literal">Threading</code> classes, as shown here:<div><pre class="programlisting">    using System.Threading;
    using System.IO;</pre></div></li><li class="listitem">Now, let's add the following code to the <code class="literal">Main</code> method:<div><pre class="programlisting">public static void Main()
        {
            byte[] FileData = new byte[1000];

            FileStream FS = new FileStream("c:\\projects\\InputData.txt", FileMode.Open, FileAccess.Read,  FileShare.Read, 1024, FileOptions.Asynchronous);

            Console.WriteLine("To start async read press return.");
            Console.ReadLine();

            IAsyncResult result = FS.BeginRead(FileData, 0, FileData.Length, null, null);


            // Work being done while we wait on the async //read.
            Console.WriteLine("\r\n");
            Console.WriteLine("Doing Some other work here. \r\n");
            Console.WriteLine("\r\n");

            //Calling EndRead will block the main thread //until the async work has finished.
            int num = FS.EndRead(result);


            FS.Close();



            Console.WriteLine("Read {0}  bytes from the file. \r\n", num);
            Console.WriteLine("Is the async read completed - {0}. \r\n", result.IsCompleted.ToString());
            Console.WriteLine(BitConverter.ToString(FileData));

            Console.ReadLine();
   }</pre></div></li><li class="listitem">Then, finally, we <a id="id624" class="indexterm"/>need to add a file called <code class="literal">InputData.txt</code> to <code class="literal">C:\projects</code>. This will be the file that we read asynchronously. It can contain any text that you would like; for our example, the <code class="literal">InputData.txt</code> file looks like the following screenshot:<div><img src="img/8321EN_11_01.jpg" alt="How to do it"/></div></li></ol></div><p>Now, let's build and run our<a id="id625" class="indexterm"/> application. You should see a screen like this:</p><div><img src="img/8321EN_11_02.jpg" alt="How to do it"/></div><p>The program is waiting on the user to click on the return button; once the button is clicked, it will execute the asynchronous read of the data file. Once you click on return, you should see the following results:</p><div><img src="img/8321EN_11_03.jpg" alt="How to do it"/></div><p>If you click return again, the application will finish and exit. So, let's look at how this works.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec96"/>How it works</h2></div></div></div><p>This is a very simple <a id="id626" class="indexterm"/>example of an existing .NET class, <code class="literal">FileStream</code>, that implements the Asynchronous Programming Model with the two methods, <code class="literal">BeginRead</code> and <code class="literal">EndRead</code>. If you look at the method definition for the <code class="literal">BeginRead</code> method, you will see that it implements the <code class="literal">IAsyncResult</code> interface:</p><div><pre class="programlisting">public override IAsyncResult BeginRead(
   byte[] array,
   int offset,
   int numBytes,
   AsyncCallback userCallback,
   Object stateObject
)</pre></div><p>You can also view the method definition for the <code class="literal">EndRead</code> method as follows:</p><div><pre class="programlisting">public override int EndRead(
   IAsyncResult asyncResult
)</pre></div><p>Now, let's look at your example project. In the following lines of code, we set up the <code class="literal">FileStream</code> object called <code class="literal">FS</code>:</p><div><pre class="programlisting">FileStream FS = new FileStream("c:\\projects\\InputData.txt", FileMode.Open, FileAccess.Read,
            FileShare.Read, 1024, FileOptions.Asynchronous);</pre></div><p>Here we are declaring <a id="id627" class="indexterm"/>a new <code class="literal">FileStream</code> object with parameters that define the file to stream, the mode to open, the access to read, and the option to read asynchronously.</p><p>Then we initiate the read operation asynchronously with the following code:</p><div><pre class="programlisting">            IAsyncResult result = FS.BeginRead(FileData, 0, FileData.Length, null, null);</pre></div><p>We then do some other work while the read operation is happening asynchronously on another thread. This "other" work is represented by the following three <code class="literal">Console.WriteLine</code> statements:</p><div><pre class="programlisting">            // Work being done while we wait on the async read.
            Console.WriteLine("\r\n");
            Console.WriteLine("Doing Some other work here. \r\n");
            Console.WriteLine("\r\n");</pre></div><p>Now, we block the main thread and wait on the <code class="literal">async</code> write to complete using this statement:</p><div><pre class="programlisting">            //Calling EndRead will block the main thread until the async work has finished.
            int num = FS.EndRead(result);</pre></div><p>This statement will complete when the read is complete and return the <code class="literal">IAsyncResult</code> object and the number of bytes read. We then write these results to the console using the following statements:</p><div><pre class="programlisting">            Console.WriteLine("Read {0}  bytes from the file. \r\n", num);
            Console.WriteLine("Is the async read completed - {0}. \r\n", result.IsCompleted.ToString());</pre></div><p>We examine the <code class="literal">IsCompleted</code> method of <code class="literal">IAsyncResult</code> to make sure the read has completed even though we know it has because we blocked waiting on the <code class="literal">EndRead</code> method. We did this to preview another design pattern for the Asynchronous Programming Model, which we will not demonstrate in this chapter—the polling method. Instead of calling the <code class="literal">EndRead</code> method to block the main thread waiting on the <code class="literal">Main</code> method to complete, we can create a loop and periodically check the <code class="literal">IsCompleted</code> property of the <code class="literal">IAsyncResult</code> object returned by the <code class="literal">BeginRead</code> method. This is handy if we want to show a progress update throughout the read operation.</p><p>A third way to<a id="id628" class="indexterm"/> implement the Asynchronous Programming Model involves using a delegate method for processing when the read operation has completed.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Using an AsyncCallback delegate method</h1></div></div></div><p>We have seen how we can use the <a id="id629" class="indexterm"/>APM design pattern that is implemented in the <code class="literal">FileStream</code> class to perform an asynchronous read and then wait on the results. We also mentioned how we can poll to see if the asynchronous read has completed instead of blocking the main thread. Now, we will see how we can execute a delegate method when the asynchronous read has completed.</p><p>Using this method, we do not have to block the main thread waiting or perform the work of polling the <code class="literal">IsCompleted</code> property to see when the read has completed. We simply execute the <code class="literal">BeginRead</code> method and pass it a delegate method. We then go on our way and, when the read completes, the delegate method will be executed.</p><p>Let's look at the method header for the <code class="literal">BeginRead</code> method of the <code class="literal">FileStream</code> class. The following is the method definition:</p><div><pre class="programlisting">public override IAsyncResult BeginRead(
   byte[] array,
   int offset,
   int numBytes,
   AsyncCallback userCallback,
   Object stateObject
)</pre></div><p>You will see that the fourth parameter passed to this method is an <code class="literal">AsyncCallback</code> delegate. In our previous example, we passed a null value for this parameter when we called this method. This time let's use a delegate method.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec97"/>How to do it</h2></div></div></div><p>Let's open Visual Studio <a id="id630" class="indexterm"/>and create a new console application called <code class="literal">FileReadAsyncWithDelegate</code>. Once this has been created, we will perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two <code class="literal">using</code> statements for the <code class="literal">IO</code> and <code class="literal">Threading</code> classes, as shown:<div><pre class="programlisting">          using System.Threading;
          using System.IO;</pre></div></li><li class="listitem">Next, let's add the following code to the <code class="literal">Main</code> method of our application:<div><pre class="programlisting">public static void Main()
        {

            FileStream FS = new FileStream("c:\\projects\\InputData.txt", FileMode.Open, FileAccess.Read,
            FileShare.Read, 1024, FileOptions.Asynchronous);

            Console.WriteLine("To start async read press return.");
            Console.ReadLine();

            IAsyncResult result = FS.BeginRead(FileData, 0, FileData.Length, ReadComplete, FS);


            // Work being done while we wait on the async //read.
            Console.WriteLine("\r\n");
            Console.WriteLine("Doing Some other work here. \r\n");
            Console.WriteLine("\r\n");


            Console.ReadLine();
        }</pre></div></li><li class="listitem">Before the <code class="literal">Main</code> method, we need to declare a static byte array so that it is available to both the <code class="literal">Main</code> method and our new delegate method. Add the following statement before the <code class="literal">Main</code> method.<div><pre class="programlisting">         private static byte[] FileData = new byte[1000];</pre></div></li><li class="listitem">Then, we need to add our delegate method. Add the following code for our delegate method:<div><pre class="programlisting">private static void ReadComplete(IAsyncResult AResult)
        {
            // Write out the id of the thread that is //performing the read.
            Console.WriteLine("The read operation is being done on thread id: {0}.",
               Thread.CurrentThread.ManagedThreadId);

            // Get the FileStream out of the IAsyncResult object.
            FileStream FS = (FileStream)AResult.AsyncState;

            // Get the results from the read operation.
            int num = FS.EndRead(AResult);

            // Make sure to close the FileStream.
            FS.Close();

            //Now, write out the results.
            Console.WriteLine("Read {0}  bytes from the file. \r\n", num);
            Console.WriteLine("Is the async read completed - {0}. \r\n", AResult.IsCompleted.ToString());
            Console.WriteLine(BitConverter.ToString(FileData));
       }</pre></div></li></ol></div><p>That is all the code we will <a id="id631" class="indexterm"/>need for this example. We do still need our <code class="literal">InputData.txt</code> file in <code class="literal">C:\projects</code>. It should still be there from when we created it in the last exercise.</p><p>Now, build and run the application and you should see the following:</p><div><img src="img/8321EN_11_04.jpg" alt="How to do it"/></div><p>Then press return and the application should display the following results:</p><div><img src="img/8321EN_11_05.jpg" alt="How to do it"/></div><p>You will see that the results<a id="id632" class="indexterm"/> look almost identical to the results from the previous exercise. This is true. But how we achieve them is very different. This time, instead of blocking the main thread that is waiting on the read to complete, we initiated a delegate method on a separate thread and waited there for the read to complete and then display the results. Let's look at how we did it.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec98"/>How it works</h2></div></div></div><p>First, let's look at our <code class="literal">Main</code> method. This time it is more streamlined and does less work. It essentially just creates the <code class="literal">FileStream</code> object and calls the <code class="literal">BeginRead</code> method and passes it a delegate method. That is it. Then it goes about its business. It does not wait on the read to complete, does not process the results, and does not close the <code class="literal">FileStream</code> object. The following code shows this:</p><div><pre class="programlisting">        public static void Main()
        {

            FileStream FS = new FileStream("c:\\projects\\InputData.txt", FileMode.Open, FileAccess.Read,
            FileShare.Read, 1024, FileOptions.Asynchronous);

            Console.WriteLine("To start async read press return.");
            Console.ReadLine();

            IAsyncResult result = FS.BeginRead(FileData, 0, FileData.Length, ReadComplete, FS);


            // Work being done while we wait on the async read.
            Console.WriteLine("\r\n");
            Console.WriteLine("Doing Some other work here. \r\n");
            Console.WriteLine("\r\n");


            Console.ReadLine();
        }</pre></div><p>The key here is the<a id="id633" class="indexterm"/> following statement:</p><div><pre class="programlisting">IAsyncResult result = FS.BeginRead(FileData, 0, FileData.Length, ReadComplete, FS);</pre></div><p>Now, instead of the fourth and fifth parameters being <code class="literal">null</code>, we pass a delegate method and the <code class="literal">FileStream</code> object to this method. This allows the <code class="literal">Main</code> method to then go about its business.</p><p>Now, let's look at where the work is now being done—the delegate method, <code class="literal">ReadComplete</code>:</p><div><pre class="programlisting">        private static void ReadComplete(IAsyncResult AResult)
        {
            // Write out the id of the thread that is performing the read.
            Console.WriteLine("The read operation is being done on thread id: {0}.",
               Thread.CurrentThread.ManagedThreadId);

            // Get the FileStream out of the IAsyncResult object.
            FileStream FS = (FileStream)AResult.AsyncState;

            // Get the results from the read operation.
            int num = FS.EndRead(AResult);

            // Make sure to close the FileStream.
            FS.Close();

            //Now, write out the results.
            Console.WriteLine("Read {0}  bytes from the file. \r\n", num);
            Console.WriteLine("Is the async read completed - {0}. \r\n", AResult.IsCompleted.ToString());
            Console.WriteLine(BitConverter.ToString(FileData));
        }</pre></div><p>The first thing you will notice is that the <code class="literal">AsyncCallback</code> delegate definition requires a method that returns no <a id="id634" class="indexterm"/>value and receives an <code class="literal">IAsyncResult</code> parameter as input.</p><p>We then get the <code class="literal">FileStream</code> object state using the following statement:</p><div><pre class="programlisting">FileStream FS = (FileStream)AResult.AsyncState;</pre></div><p>Then, we wait on the read to complete and get the results using this statement:</p><div><pre class="programlisting">int num = FS.EndRead(AResult);</pre></div><p>And finally, we process the results using these statements:</p><div><pre class="programlisting">            Console.WriteLine("Read {0}  bytes from the file. \r\n", num);
            Console.WriteLine("Is the async read completed - {0}. \r\n", AResult.IsCompleted.ToString());
            Console.WriteLine(BitConverter.ToString(FileData));</pre></div><p>That is all there is to it. We have spent the last two sections of this chapter looking at three ways to implement the APM:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call the <code class="literal">Begin</code> method name, perform some action, and then block using the <code class="literal">End</code> method name until the asynchronous action is finished</li><li class="listitem" style="list-style-type: disc">Call the <code class="literal">Begin</code> method name, continue processing, and periodically check the <code class="literal">IsCompleted</code> property of the <code class="literal">IAsyncResult</code> object to know when the asynchronous operation is completed</li><li class="listitem" style="list-style-type: disc">Call the <code class="literal">Begin</code> method name to initiate the asynchronous operation and then implement a delegate method on a separate thread to wait on the asynchronous operation and process the results</li></ul></div><p>For the rest of the <a id="id635" class="indexterm"/>chapter, we will explore the new <code class="literal">async</code> and <code class="literal">await</code> keywords that were introduced in .NET Version 4.5.1.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec80"/>The async and await keywords</h1></div></div></div><p>In .NET 4.5, Microsoft<a id="id636" class="indexterm"/> introduced the <code class="literal">async</code> and <code class="literal">await</code> keywords that made it very<a id="id637" class="indexterm"/> easy for developers to implement asynchronous functionality in their methods. Adding the <code class="literal">async</code> keyword to the method header tells .NET's CLR to run this method in a separate thread in the threadpool if it determines that the following two conditions are met: first, that running it in a separate thread will increase performance, and second, the <code class="literal">await</code> keyword is used in the method. An <code class="literal">async</code> method will either return void, <code class="literal">Task</code>, or <code class="literal">Task&lt;TResult&gt;</code>. Also, the naming convention is to postfix any methods that use the <code class="literal">async</code> keyword with <code class="literal">Async</code>. So, the method name should be <code class="literal">MyMethodAsync</code>. That is all there is to it. The implementation is similar to the APM but does not use the <code class="literal">IAsyncResult</code> interface or implement it.</p><p>The design pattern for using this method is for your program to run a method that uses the <code class="literal">async</code> keyword by running it in a separate task. It is then free to continue on. If the <code class="literal">async</code> method does not have a return value, then the main thread can just continue on. If there is a return value that the <code class="literal">Main</code> method cares about or wants to know when the asynchronous operation has completed, it can wait on the asynchronous task to complete and view the results. In the asynchronous task, the method will perform functions on its own thread and then call the <code class="literal">await</code> keyword when it wants to wait on some action to complete.</p><p>To demonstrate the use of these two new keywords, we will rewrite our previous application to read a file asynchronously using the <code class="literal">async</code> and <code class="literal">await</code> keywords. Let's get started.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec99"/>How to do it</h2></div></div></div><p>First, let's open Visual Studio and create a new console application called <code class="literal">FileReadUsingAsync</code>. Once we have this project created, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two <code class="literal">using</code> statements for the <code class="literal">IO</code> and <code class="literal">Threading</code> classes, as follows:<div><pre class="programlisting">          using System.Threading;
          using System.IO;</pre></div></li><li class="listitem">Next, let's add the following statements to the <code class="literal">Main</code> method:<div><pre class="programlisting">static void Main()
        {
            Console.WriteLine("The ID of the Main method: {0}. \r\n",
                Thread.CurrentThread.ManagedThreadId);

            //Wait on the user to begin the reading of the //file.
            Console.ReadLine();

            // Create task, start it, and wait for it to //finish.
            Task task = new Task(ProcessFileAsync);
            task.Start();
            task.Wait();

            //Wait for a return before exiting.
            Console.ReadLine();
       }</pre></div></li><li class="listitem">Next, we will<a id="id638" class="indexterm"/> create the <code class="literal">ProcessFileAsync</code> method<a id="id639" class="indexterm"/> that will run inside the task we created in the <code class="literal">Main</code> method. This method will implement the <code class="literal">async</code> keyword and run asynchronously. Add the following code to create this method:<div><pre class="programlisting">static async void ProcessFileAsync()
        {
            // Write out the id of the thread of the task //that will call the async method to read the file.
            Console.WriteLine("The thread id of the ProcessFileAsync method: {0}. \r\n",
               Thread.CurrentThread.ManagedThreadId);

            // Start the HandleFile method.
            Task&lt;String&gt; task = ReadFileAsync("C:\\projects\\InputData.txt");

            // Perform some other work.
            Console.WriteLine("Do some other work. \r\n");

            Console.WriteLine("Proceed with waiting on the read to complete. \r\n");
            Console.ReadLine();

            // Wait for the task to finish reading the //file.
            String results = await task;
            Console.WriteLine("Number of characters read are: {0}. \r\n", results.Length);

            Console.WriteLine("The file contents are: {0}. \r\n", results);
      }</pre></div></li><li class="listitem">Now, this method will<a id="id640" class="indexterm"/> call another <code class="literal">async</code> method that will <a id="id641" class="indexterm"/>actually open the file and read the contents. This method, <code class="literal">ReadFileAsync</code>, will have the following code:<div><pre class="programlisting">static async Task&lt;String&gt; ReadFileAsync(string file)
        {
            // Write out the id of the thread that is //performing the read.
            Console.WriteLine("The thread id of the ReadFileAsync method: {0}. \r\n",
               Thread.CurrentThread.ManagedThreadId);

            Console.WriteLine("Begin Reading file asynchronously. \r\n");

            // Read the specified file.
            String DataRead = "";
            using (StreamReader reader = new StreamReader(file))
            {
                string character = await reader.ReadToEndAsync();

                //Build string of data read.
                DataRead = DataRead + character;

                //Slow down the process.
                System.Threading.Thread.Sleep(10000);
                
            }


            Console.WriteLine("Done Reading File asynchronously. \r\n");
            return DataRead;
      }</pre></div></li></ol></div><p>That is all there is to it. Let's build our application and run it. We should see the following output:</p><div><img src="img/8321EN_11_06.jpg" alt="How to do it"/></div><p>At this point, the <a id="id642" class="indexterm"/>application is waiting for us, so we need to press return. Then <a id="id643" class="indexterm"/>we will see the following output:</p><div><img src="img/8321EN_11_07.jpg" alt="How to do it"/></div><p>Now, we have initiated the asynchronous reading of the file, performed some other work, and are waiting on the file reading to complete. Once it has completed, we should see the following output:</p><div><img src="img/8321EN_11_08.jpg" alt="How to do it"/></div><p>Now, if we press return <a id="id644" class="indexterm"/>again we will see the results of the read<a id="id645" class="indexterm"/> operation:</p><div><img src="img/8321EN_11_09.jpg" alt="How to do it"/></div><p>Finally, if we press return one last time, the application will finish and exit. So, how did this all work?</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec100"/>How it works</h2></div></div></div><p>Now, let's examine how this <a id="id646" class="indexterm"/>program works. First, take a look at the <code class="literal">Main</code> <a id="id647" class="indexterm"/>method:</p><div><pre class="programlisting">        static void Main()
        {
            Console.WriteLine("The of ID the Main method: {0}. \r\n",
                Thread.CurrentThread.ManagedThreadId);

            //Wait on the user to begin the reading of the file.
            Console.ReadLine();

            // Create task, start it, and wait for it to finish.
            Task task = new Task(ProcessFileAsync);
            task.Start();
            task.Wait();

            //Wait for a return before exiting.
            Console.ReadLine();
        }</pre></div><p>This is a simple method that creates a new task that executes an <code class="literal">async</code> method called <code class="literal">ProcessFileAsync</code>. It then starts the task and waits for it to finish. That is all. So, the <code class="literal">Main</code> method just spawns a task to do the work.</p><p>Now, the <code class="literal">async</code> method <code class="literal">ProcessFileAsync</code> is executed in a separate thread from the <code class="literal">Main</code> method. This is shown by displaying the thread ID number. You will notice from the console output that the <code class="literal">Main</code> thread ID is different from the thread ID of the task running the <code class="literal">ProcessFileAsync</code> method. Let's examine this method. The following is the code for us to dissect:</p><div><pre class="programlisting">        static async void ProcessFileAsync()
        {
            // Write out the id of the thread of the task that will call the async method to read the file.
            Console.WriteLine("The thread id of the ProcessFileAsync method: {0}. \r\n",
               Thread.CurrentThread.ManagedThreadId);

            // Start the HandleFile method.
            Task&lt;String&gt; task = ReadFileAsync("C:\\projects\\InputData.txt");

            // Perform some other work.
            Console.WriteLine("Do some other work. \r\n");

            Console.WriteLine("Proceed with waiting on the read to complete. \r\n");
            Console.ReadLine();

            // Wait for the task to finish reading the file.
            String results = await task;
            Console.WriteLine("Number of characters read are: {0}. \r\n", results.Length);

            Console.WriteLine("The file contents are: {0}. \r\n", results);
        }</pre></div><p>This method's main <a id="id648" class="indexterm"/>objective is to run the <code class="literal">async</code> method, <code class="literal">ReadFileAsync</code>. This is <a id="id649" class="indexterm"/>done with the following statement:</p><div><pre class="programlisting">Task&lt;String&gt; task = ReadFileAsync("C:\\projects\\InputData.txt");</pre></div><p>We then await this task with the following statement:</p><div><pre class="programlisting">String results = await task;</pre></div><p>The preceding statement tells the method to start an <code class="literal">async</code> task and then wait on it to complete. Since the method it is calling has a return value of <code class="literal">Task&lt;String&gt;</code>, the <code class="literal">await task</code> statement returns a string value. The <code class="literal">ReadFileAsync</code> method takes a filename as the input and then returns a string that contains the contents of the file as a string. This method reads the file asynchronously on a separate thread from the main thread.</p><p>The heart of the work is done in the <code class="literal">ReadFileAsync</code> method. Let's look at this method:</p><div><pre class="programlisting">        static async Task&lt;String&gt; ReadFileAsync(string file)
        {
            // Write out the id of the thread that is performing the read.
            Console.WriteLine("The thread id of the ReadFileAsync method: {0}. \r\n",
               Thread.CurrentThread.ManagedThreadId);

            Console.WriteLine("Begin Reading file asynchronously. \r\n");

            // Read the specified file.
            String DataRead = "";
            using (StreamReader reader = new StreamReader(file))
            {
                string character = await reader.ReadToEndAsync();

                //Build string of data read.
                DataRead = DataRead + character;

                //Slow down the process.
                System.Threading.Thread.Sleep(10000);
                
            }


            Console.WriteLine("Done Reading File asynchronously. \r\n");
            return DataRead;
        }</pre></div><p>Here, we use the <code class="literal">async</code> keyword to <a id="id650" class="indexterm"/>designate this as an asynchronous method. This<a id="id651" class="indexterm"/> method creates a <code class="literal">FileStream</code> for the filename passed in and then calls the <code class="literal">StreamReader.ReadToEndAsync</code> method to asynchronously read the file. It uses the <code class="literal">await</code> keyword in this statement to signal .NET that this is an asynchronous operation:</p><div><pre class="programlisting">string character = await reader.ReadToEndAsync();</pre></div><p>By putting in the <code class="literal">wait</code> statement to slow down the processing a little, you can see the delay in execution between the following write statements:</p><div><pre class="programlisting">            Console.WriteLine("Proceed with waiting on the read to complete. \r\n");
            Console.ReadLine();
Console.WriteLine("Done Reading File asynchronously. \r\n");</pre></div><p>This allows you to see that the main thread is available while the file is being read on a separate thread.</p><p>Another point to note is that by using the <code class="literal">async</code>/<code class="literal">await</code> programming method or the APM design pattern, we do not have to deal with the underlying code of starting, stopping, and managing threads. This is handled for us by .NET. We just have to write the logic and use the appropriate design pattern.</p><p>This is a generic way to easily implement any asynchronous operation that can benefit an application's performance without having to design the entire application for parallelism or concurrency like we did with the producer-consumer or Pipelining design patterns. We can simply code a single task to run asynchronously.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Summary</h1></div></div></div><p>In this chapter, you have learned two very important ways to make a particular piece of functionality in an application run asynchronously from the main thread of the application. These two ways are the Application Programming Model and the <code class="literal">async</code>/<code class="literal">await</code> keywords. These two design techniques allow you to take advantage of the asynchronous execution of a task without designing an application around concurrency. This is especially useful for long-running tasks or tasks that access outside resources. In this way, we do not tie up the main thread of an application while we are waiting for something like a file read, an HTTP GET request, or a database read. These are all tasks whose duration is outside our control and not predictable. It therefore makes sense to perform these kinds of functions asynchronously so that our application's main thread can continue running.</p><p>These techniques are very useful when we do not have enough concurrent functionality to design a complete parallel application but have a particular task that can take a long time. These two methods are used in much the way the <code class="literal">BackgroundWorker</code> component is used and continues to make it obsolete.</p><p>The Application Programming Model is a design technique used when you create a class. You can create two methods and name them <code class="literal">BeginMethodName</code> and <code class="literal">EndMethodName</code> that implement the <code class="literal">IAsyncResult</code> interface. Then you can use them to start an asynchronous operation and, if needed, block the main thread waiting on the asynchronous operation to complete. This technique is used in many .NET classes such as the <code class="literal">FileStream</code>, <code class="literal">StreamReader</code>, and <code class="literal">StreamWriter</code>. But it can also be used by you when designing your classes.</p><p>The <code class="literal">async</code> and <code class="literal">await</code> keywords are a simple way to designate in a method's signature that it is meant to be performed as an asynchronous operation. The <code class="literal">async</code> keyword designates the method as an asynchronous method and the <code class="literal">await</code> keyword is used within the method to wait on a statement to complete before its method completes. This technique can be implemented within a class or as static methods within an application or helper class. These two techniques give the .NET developer two more tools in their toolbox to implement concurrent functionality.</p><p>Throughout this book, we have explored many ways to implement concurrent and asynchronous functionality in .NET. This includes techniques that have been around from .NET 1.0 to techniques introduced in the latest .NET 4.5. They range from simple asynchronous methods that do not allow blocking a main UI thread to objects for designing complete concurrent applications, to objects for processing sets of data concurrently. There are many ways and techniques to perform multithreaded functionality in .NET depending on the requirements of your specific application or task.</p><p>Now that you know all of what .NET has to offer, never waste an opportunity in your development to maximize the use of your computing hardware or its responsiveness by sticking to a single-threaded approach.</p></div></body></html>