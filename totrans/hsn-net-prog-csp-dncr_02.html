<html><head></head><body>
        

                            
                    <h1 class="header-title">Networks in a Nutshell</h1>
                
            
            
                
<p> It's hard to imagine that anyone reading this book doesn't have some intuitive idea of what a network actually is<em>.</em> As I write this introduction, I'm surrounded by no fewer than six distinct, network-connected devices within arm's reach. Even before I began a career in software engineering, I could have given a reasonably accurate description of what constitutes a network. However, no amount of intuition about what networks are or what might run on them, nor the use of software running on distributed systems, can account for the impact of a distributed architecture on your code. It's that impact on your software design and implementation decisions that we'll cover in this chapter.</p>
<p>We'll try to nail down a concrete definition of a network, and we'll consider the new problems you'll need to solve when writing software for them. This book assumes a fair amount of general programming skills within the C# language from its readers. I won't take any time to explain the use of native language structures, types, or keywords, nor will I discuss or explain the common general algorithms used throughout. However, I will stop short of making any assumptions of the reader's knowledge of networks, inter-device communication, or how those problems are solved in .NET Core. As such, this chapter will start from the most basic first principles and seek to provide a stable foundation from which anyone with at least some programming skill can proceed competently through the rest of the book.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The unique challenges of distributing computational or data resources over a network, and how those challenges manifest in software</li>
<li>The different components of a network, and how those components can be arranged to achieve different goals</li>
<li>The impact of the variability of devices, latency, instability, and standardization of networks on the complexity of applications written for network use</li>
</ul>
<ul>
<li>Common concepts, terms, and data structures used for network programming, and how those concepts are exposed by .NET Core</li>
</ul>
<ul>
<li>Understanding the scope of applications that are made possible by networked architectures, and the importance of developing skills in network programming to enable those kinds of applications</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This being an introductory chapter, there will be no meaningful code samples, as we'll be covering the high-level concepts and vocabulary of networks to establish a clear foundation for the rest of the book. However, in this chapter, we'll be discussing the <kbd>System.Net</kbd> class library provided by .NET Core. While this discussion will be happening at a very high level, it would be a good opportunity to familiarize yourself with the development tools made available to you by Microsoft Visual Studio Community edition. This is free to use, and provides a rich feature suite out of the box, with broad support for .NET Core project management and administration provided out of the box. As we discuss some of the libraries provided within the .NET Core tools, I encourage you to investigate using the Visual Studio IDE to include those libraries into your project and begin exploring them through the IDE's IntelliSense.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Expanding the scope of software – distributed systems and the challenges they introduce</h1>
                
            
            
                
<p>The first step to understanding programming for networks is, of course, understanding networks. Defining what they are, clarifying the aspects of networks we are concerned with, addressing how network architecture impacts the programs we write, and what kinds of software solutions networks need to be effective.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a network?</h1>
                
            
            
                
<p>At its most basic, a network is nothing more than a physical implementation of an undirected graph; a series of nodes and edges, or connections, between those nodes, as demonstrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-73 image-border" src="img/564485cf-f5a8-4ebd-9334-0fadeb8fa45c.png" style="width:19.33em;height:11.75em;"/></p>
<p class="CDPAlignCenter CDPAlign"><sub>A basic, undirected graph</sub></p>
<p>However, the preceding diagram doesn't quite capture the full picture. What constitutes a node, and what is sufficient for a connection are all very pertinent details to clarify. An individual node should probably be able to meaningfully interact with other nodes on the network, or else you might have to concern yourself with programming for a potato connected by two wires to a network of routers and servers. It's safe enough to say that potatoes very obviously aren't nodes, and that an active and stable Azure server very obviously <em>is</em>, so the line delineating nodes from non-nodes on a network falls somewhere between those two poles. Likewise, we can easily identify that the cables from the power supply of a computer to the outlet in a wall don't constitute a network connection, but that a CAT-5 cable from our computer to a router obviously does. The dividing line probably falls somewhere between those two, and it is important that we take care to draw that line accurately.</p>
<p>We'll start with a workable definition of networks for the purposes of this book, unpack the definition, and examine why we chose to make the specific distinctions we have, and finally, consider what each essential property of a network means to us as programmers. So, without further ado, the definition of a computer network is as follows:</p>
<div><q>A computer network is, for our purposes, an arbitrarily large set of computational or navigational devices, connected by channels of communication across which computational resources can be reliably sent, received, forwarded, or processed.</q></div>
<p>On the surface, that might seem basic, but there is a lot of nuance in that definition that deserves our consideration. So, let's take a deeper dive.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An arbitrarily large set</h1>
                
            
            
                
<p>What do we mean when we say arbitrarily large? Well when you're writing software for a router (accepting that you would realistically be bound by the maximum size of physically-addressable space), you would not (and should not) care about how many devices are actually connected to your hardware, or how many routes you need to reliably pass resources or requests along. Suppose you are writing the system software for a wireless router. While doing so, you tell your product owner that their marketing copy should specify that this router can only connect a maximum of four computers to the internet. Can you imagine any product owner would take that news kindly? You would be looking for a new job in no time! Networks must be able to scale with the needs of their users.</p>
<p>A basic property of almost all computer networks is device-agnosticism, which is to say that any device on a network should assume no knowledge of the number or kind of other devices on that network at any given moment. Indeed, a program or device might need to discern whether or not a specific device or piece of software exists on the network, but nothing about the network connection it obtains will convey that information. Instead, it should be equipped to send and receive messages in a format that is typically standardized for the communication protocol over which the messages are sent. Then, using these standardized messages, a device can request information about the availability, configuration, or capabilities of other devices on the network, without actually knowing whether or not the devices it expects to be available on the network are, in fact, available on the network.</p>
<p>Ensuring that the receiving end of any given outgoing connection from a device is properly connected, or that the receiving devices are configured accordingly, is the concern of the network engineers who support your software. Supporting and responding to requests sent by your software is the responsibility of the authors of the receiving software. Obviously, if you're working in a sufficiently small software shop, both of those roles may well also be filled by you; but in a sufficiently mature working environment, you can likely rely on others to handle these tasks for you. However, when the time comes to deploy your software to a networked device, no information about whether or not those responsibilities were handled properly is available to you simply by virtue of being connected to a network.</p>
<p>Device-agnosticism means that a network has no idea what has connected to it, and, accordingly, cannot tell you as much. A corollary attribute of networks is that other devices on the network cannot and will not be notified that your device or software has connected and been made a resource.</p>
<p>Ultimately, this is what is meant by an arbitrarily large set of devices. Technically, a single computer constitutes a network of one node, and zero connections (though, for the purposes of this book, we'll only be considering networks with at least two nodes, and at least one connection between any given node and any other node on the network), but there is no fixed maximum value of nodes beyond which a network ceases to be a network. Any arbitrary number of nodes, from one to infinity (or whatever the maximum number of physically possible nodes may be), constitutes a valid network, so long as those nodes have some valid connection between themselves and the rest of the network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Computational devices</h1>
                
            
            
                
<p>Now that we know we can have an arbitrarily large number<em> </em>of computational devices as nodes in our network, it bears further scrutiny to discern what exactly a computational device is. While this may seem obvious, at least initially, we can quickly identify where it becomes unclear by way of an example.</p>
<p>As per our definition of a network, the device I'm using to draft this book right now might well qualify as a self-contained network. I have a keyboard, mouse, monitors, and computer, all connected by standardized channels of communication. This looks awfully network-like at a conceptual level, but intuitively, we would be inclined to say that it is a network of one, and so, not really<em> </em>a network at all. However, while the what of the non-network status of my computer seems obvious, the why might be less clear.</p>
<p>This is where we benefit from clearly explicating what constitutes a computational device for the purposes of our definition of a network. Simply being able to perform computation is insufficient for a network node. In my example, I can tell you that my mouse (a relatively high-end gaming mouse) certainly performs a number of complex calculations transforming a laser-sensor signal into directional inputs to pass to my computer. My monitors certainly have to do a fair amount of computation to transform the raw binary data of pixel color values into the rendered screens I see 60 or 120 times per second. Both of these devices are connected by way of reliable, standardized communication protocols to my machine, but I wouldn't necessarily be inclined to consider them nodes on a network. My computer, when connected to the internet, or my local home network, surely constitutes a node, but its individual peripherals? I'm inclined to say no.</p>
<p>So, if peripherals aren't network devices, then what essential property is it that they're missing? Open communication. While a monitor and a keyboard can communicate over a connection with a wide variety of other devices, the manner in which they can communicate is restricted to a very specific and limited range of possible signals. This highlights an important distinction to be made between distributed systems and networks<strong>.</strong> While a network is always a distributed system, a distributed system may not necessarily always constitute a network.</p>
<p>My computer is a distributed system; its components can function independently of one another, but they operate in a coordinated fashion to perform the responsibilities of a computer. However, my computer is very obviously not<em> </em>a network. It lacks device-agnosticism, as each component is explicitly configured to communicate its presence to the next node in the graph, so that it can be used to service the needs of the end user. It is also not arbitrarily scalable. I can only have, at most, three monitors connected to my machine at any given time, and only under very specific conditions of connection interfaces and organization. While being connected to a network, my computer and each of its peripherals can instead be conceptually considered a single, atomic computational device. Thus, on a network, we can specify that a computational device is something that can facilitate the requirements of the network. It accepts and communicates openly over device-agnostic channels of communication to provide or leverage computational resources on that network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigational devices</h1>
                
            
            
                
<p>In our definition of a network, I specify computational or navigational devices. For the sake of this book, a navigational device is a valid network device, and constitutes a node on our network. The meaningful difference between a computational and navigational device (or resource) is that a navigational device provides no resources of its own, and instead exists only to facilitate the successful communication of other devices on the network. A simple switch or router would fall under this category. These devices are still programmed to operate successfully on a network, but are typically done at the system level in C or C++, with on-board firmware. The concerns of programming these intermediary devices will generally fall outside the purview of this book, but I wanted to note the distinction for the sake of clarity and completeness.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Channels of communication</h1>
                
            
            
                
<p>Within the context of networks, what constitutes a channel of communication is merely a shared interface for data transmission between any two devices on a network. There are no constraints on the physical implementation of a channel of communication, or the format in which data must be transmitted over a channel, simply that at least two devices can communicate across that channel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The software impact</h1>
                
            
            
                
<p>When writing software meant to leverage or be leveraged by other devices on a network, there are a number of new considerations and constraints that developers are shielded from when only writing code for local systems. How these issues are best dealt with will be addressed more thoroughly in subsequent chapters, but for now it is worth considering what the impact these aspects of general computer networks might have on the software we write.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The impact of device-agnosticism</h1>
                
            
            
                
<p>When we talk about device-agnosticism, we assume our software is not given information about which resources we expect to be available are<em> </em>actually available. So, going back to the example of my computer as a distributed system that is not a network, I can reliably write local programs that print or draw information to a screen. Because the program is executed locally, I can trust that my operating system will take responsibility for acquiring the connection to my monitor and transmitting the data from my program's stack frame to the monitor's display port connection.</p>
<p>The monitors are resources that are not inherent to the distributed system; I can technically execute any series of commands on my computer without a monitor. It's not essential for the system to function, even if it is essential for the system to function in a way that is decipherable to me. However, I can reliably assume that if the monitors are present on the system, my software will have access to them, because my operating system acts as an intelligent broker of requests between those peripherals. It will always have, and be capable of delivering, information about the status of any peripherals that my software needs to use.</p>
<p>As soon as my software needs to access resources distributed on a network<em>,</em> however, I can no longer make assumptions about the availability of those resources. That's the crux of device-agnosticism and how it impacts networked programs. Where the operating system of my computer served as an intelligent broker, we cannot assume the same of a network. So, verifying the presence of resources, and our ability to access them, becomes a key component in the design of our software. And I'll note that this task becomes more challenging when we have multiple devices on our network that could provide the resources we're looking for.</p>
<p>In that case, it's the responsibility of some software on the network to determine which specific device ultimately services our software's request for that resource. Whether that work is done by our own program as part of its communication algorithm, or handled by some other intelligent broker deployed to the network to facilitate this situation, the work needs to be done for our software to behave reliably on such a network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing for open communication</h1>
                
            
            
                
<p>When we talk about open communication on networks, we're talking about collaboration between different devices or software components. This collaboration puts some responsibility on every developer who intends to leverage the resources of another; the responsibility to agree upon some standard for communication, and to respond according to that agreed upon standard. There may be a functionally infinite number of ways to format data to send and receive over a pipe, but unless someone else on the network has agreed to receive your data in the format you've decided to send it, none of it can be considered valid<em>.</em> You are, essentially, screaming into the void.</p>
<p>The broad range of possibility creates a need for standardization that is met by an equally broad number of organizations, including the <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) and the <strong>International Standards Organization</strong> (<strong>ISO</strong>). What this means for you is that you will ultimately be responsible for understanding what standards your software should adhere to in order to meet the functional requirements of your projects, and to provide the most value to other users of your product. Common standards you'll learn about in this book include communication protocols, such as TCP, UDP, and HTTP, as well as addressing and naming standards such as the IP addressing standard and the domain naming system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Topologies and physical infrastructure</h1>
                
            
            
                
<p>Having spent a sufficient amount of time discussing what a network is, we should now consider how networks are actually implemented. This section will consider the various solutions that the engineers have arrived at to build systems that meet the definition of a network. We'll discuss the distinction between a logical and a physical topology for a network, and then examine the most common examples of the former.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Physical and logical topologies</h1>
                
            
            
                
<p class="mce-root">In the same way that the topology of a geographic region describes how the features of that region are arranged over the area of the region, the topology of a network describes how the components of that network are arranged relative to one another. There are two ways to think about the organization of networks. As should be obvious, having read the header for this subsection, they are the physical topology and the logical topology<strong>.</strong></p>
<p class="mce-root">The physical topology describes how a network is physically connected and organized in real space. It describes the medium by which connections are established, the medium of the connections themselves, the location of devices in physical space, and the layout of the connections between nodes. It is determined, in part, by the specific networking devices of the network and the connections those devices allow (I can't use coaxial cabling to connect to a router with only Ethernet ports). Separately, the physical topology itself determines the maximum capabilities of the network in terms of performance, resilience, and, in some cases, even security. Imagine that all incoming network traffic trying to access a <strong>local area network</strong> (<strong>LAN</strong>) I own must be funneled through a firewall for security purposes. If I only expose one physical device to act as that firewall, my network won't be very fault tolerant. However, if I expose multiple firewall devices, with each servicing requests from different regions, I can increase my fault tolerance considerably. Especially if each is capable of serving as a backup in the event that one of the others is taken offline for any reason. The physical topology of one firewall provides less fault tolerance than the physical topology of several.</p>
<p>The physical topology also describes the variety of network devices I use on the network at any point in time. This is where our high-level abstractions of communication channel and node or computational device is brought down into concretions. Instead of a link or connection, a physical topology characterizes a connection as wired or wireless. A robust topology may even specify the type of wire used as coaxial or fiber optic cables, as is typical of most high-speed home internet connections, or as twisted-pair copper wire, like what's used for telecom networks.</p>
<p>This is also where our network nodes get nailed down to a concrete, specific device. Instead of a computational device, we have switches, routers, bridges, and <strong>network-interface controllers</strong> (<strong>NIC</strong>). Each of these devices is responsible for a different task or service on a network, and some, or all, of them may be present on any given implementation. For example, I have no need for a bridge on my home wireless network, but it would be impossible to imagine how the entire internet could exist without the use of each and every device I listed, and dozens more that I haven't.</p>
<p class="mce-root">Meanwhile, the logical topology of a network explains the conceptual organization of relevant actors on the network, and the connective paths over which they can, or must, communicate with any other actors on that network. One important consideration to make, though, is that physical topologies do not necessarily map directly to the logical topology. Looking back at our earlier example of a physical topology with one firewall as compared to a physical topology of multiple firewalls, we can illustrate the distinction between physical and logical. First, let's take a look at the initial, naive implementation of an internal network with a single physical firewall device to restrict access to our server resources: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-887 image-border" src="img/e1a34020-234c-433e-a8ed-f9f75a42dd03.png" style="width:18.58em;height:18.42em;"/></p>
<p>Initial, single-firewall physical topology</p>
<p class="CDPAlignLeft CDPAlign">While a complete physical topology would define and describe the type of connection supported, and perhaps even define the model of the physical devices represented in the preceding diagram, this will be sufficient for our purposes. Next, let's look at the more resilient physical topology with multiple firewalls and a failover strategy for unresponsive firewalls:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-888 image-border" src="img/00c0380a-fa01-4cd8-a9a0-1edbe78f27b1.png" style="width:20.83em;height:17.08em;"/></p>
<p>It's easy to see why the physical topology diagram would be different, because there are different physical components in play. What's more, for as simple a difference as it is between them, the physical difference between the two is non-trivial, as the second topology has a meaningful impact on the owner of the network in terms of cost, reliability, and performance.</p>
<p>The point we want to make with this, however, is that in both physical implementations, the logical topology remains the same. If we think of the single firewall (in the case of the first physical topology) and the multi-firewall along with requesting the brokering router (in the case of the second physical topology) as being, conceptually, a single secure access point into our internal network, then we can easily see how both physical topologies map to the following logical topology:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-889 image-border" src="img/87c248bf-016f-4675-b5d4-383bbf73fb68.png" style="width:17.00em;height:17.25em;"/></p>
<p>Looking at this diagram, you might also notice that it bears a striking resemblance to the physical layout of the first diagram, but looks wholly different from the second. This serves to illustrate the fact that a logical topology might map one-to-one to its physical counterpart, but does not necessarily<em> </em>map one-to-one with its physical implementation.</p>
<p>For the remainder of this book, we'll exclusively be concerned with the logical<em> </em>topology of a network, as this abstraction defines the interactions we'll be processing in the software we build. Device manufacturers can deal with the hardware components, and network engineers can work to meet the physical performance constraints. We'll just think about what resources we need, or need to provide, and how we can meet those needs. The logical topology will be sufficient for that.</p>
<p>The specific organization of the logical topology of our network may well have an impact on our software implementation, however, and there is a variety of common topologies with their own strengths and disadvantages we'll want to consider, so we should take some time to do so now. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Point-to-point topology</h1>
                
            
            
                
<p>Let's start with the most basic. A point-to-point topology is exactly what it sounds like. A single logical connection between two nodes on a network. This topology is how we would define a minimum complete network, which is to say, at least one connection between at least two nodes. It is the lowest cost in terms of implementation, and has the lowest impact on the engineering considerations for software meant to be deployed to such a network. Point-to-point networks can maintain a dedicated connection between the two relevant nodes, or establish that connection dynamically as needed. Any direct peer-to-peer communication is an instance of a point-to-point network on your system, even if that peer-to-peer connection is established over a more complicated logical network topology, the communication session itself is an instance of a logical point-to-point topology.</p>
<p>While the cost of a point-to-point connection might be exceptionally low, the benefits you can possibly reap from those costs are also extremely low. The kinds of problems solved by a point-to-point network design are limited in scope, and are usually specific to an immediate problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Linear topology (daisy-chaining)</h1>
                
            
            
                
<p>A linear topology is exactly what it sounds like – a line! It is the most primitive extension of the point-to-point topology, one of the simplest logical topologies conceptually, and often one of the cheapest in terms of a corresponding physical implementation. In a linear network topology, we extend our point-to-point model in such a way as to only ever have one node connected to at most two other nodes at a given time. The benefit here is obviously in the physical implementation cost (even with high resiliency, this configuration can only ever get so complicated). The drawback, however, should be similarly obvious. Communication from one node to any node other than one of its nearest neighbors will require the intermediary nodes to do some work investigating the target of the inbound request and determine if they are suitable to process the request, and if not, know to pass the request along to the neighbor that didn't originate the request.</p>
<p>Note that specification to not return the request to the neighbor that originated the request in the first place. If the nodes responded by simply submitting the request back out to both of your neighbors blindly, you would end up in an infinite loop of submitting and re-submitting the request between the two nodes. At least one of the nodes in any pair has to be aware enough to not re-submit a request to its originator. This highlights the most important drawback of this topology. Specifically, that it requires a tight coupling of nodes to their conceptual position in the network structure. </p>
<p>While none of this is particularly complicated, you can already see how the logical organization of your network can impact the design of your networking code. That will only become more apparent as the complexity of the topology increases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bus topology</h1>
                
            
            
                
<p>A bus topology is one in which every single node on the network is connected to every other node on the network by way of a single channel of communication, as seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-890 image-border" src="img/8274a2f7-9a0e-456d-b23f-98ec4c290bc2.png" style="width:19.58em;height:11.92em;"/></p>
<p>Each connection coming off of a node is joined to a shared connection between all nodes by way of a simple connection interface. Any packets sent by a node on a bus topology will be transmitted on the same bus as every other packet transmitted over the network, and each node on the bus is responsible for identifying whether or not it is the most suitable node to service the request carried by that packet. Similar to the linear network previously described, packets on a bus topology must contain information about the target node for the request.</p>
<p>As is the case with each of the topologies of lesser complexity, the bus topology has the obvious benefit of a low upfront cost of implementation, and relatively low overheads for orchestration. Hopefully, however, the previous description I provided helps to characterize the particular challenges associated with this particular network topology. Because all network communication happens over a single channel, all traffic, even under ideal circumstances, is limited by the bandwidth of that channel. Especially chatty software doesn't do well on a bus topology, as it tends to monopolize the link between nodes.</p>
<p>Additionally, because there is only a single channel of communication across the whole of the network, that channel serves as a single point of failure for the network. If the central bus comes offline, then each node is isolated simultaneously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Star topology</h1>
                
            
            
                
<p>Finally, we begin to consider network topologies more common in enterprise networks. The star topology is arranged in such a way as to produce an asterisk-like star shape, with each peripheral node connected by a single channel to a central hub-node, as demonstrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-891 image-border" src="img/44b58274-dd79-4b7c-a914-83fc3edd9596.png" style="width:16.33em;height:14.17em;"/></p>
<p>The <strong>hub</strong> of a star topology serves as a broker of communication between all peripheral nodes. It receives and forwards requests from each of its peripheral nodes by way of a direct, point-to-point connection.</p>
<p>This topology provides the benefit of isolating the failures of peripheral nodes or their connections to the hub to those nodes specifically. Each of the other nodes can maintain their connections to all the other nodes in the network with any one of them going down. It is also, at least conceptually if not physically, infinitely scalable. The only task necessary to add a node to the network is to add a link between the new node and the hub node.</p>
<p>Hopefully, by this point in the discussion of network topology, you'll already have identified the obvious downside to this approach. If the hub-node goes offline, the entire network is eliminated. From the perspective of any one peripheral node, loss of the hub means a loss of the entire network, since everything can only ever communicate with the hub.</p>
<p>In reading my description, you may have also realized that some network topologies can be decomposed into sub-networks of completely different topologies. A network defined by any given peripheral node and the hub node of a star topology is itself a single instance of a point-to-point network. Likewise, a network defined by any two<em> </em>peripheral nodes and the hub node of a star topology is technically a linear topology (which is itself a specialized implementation of the bus topology). By logically extending these simple diagrams into larger compositional topologies, we can describe any kind of network you could possibly write software for.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ring topology</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">A ring topology is very similar to a linear topology (which, as I noted before, is technically an implementation of the bus topology) except that, in the case of a ring topology, the endpoints are ultimately connected, and communication is unidirectional, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-892 image-border" src="img/196aa31f-9d9d-45c3-8b6e-2faadbcb99ab.png" style="width:9.67em;height:8.83em;"/></p>
<p>The benefit of this particular network topology might not be immediately apparent, but with each node in the network serving as a peer of the previous node in the chain, there's no need for any request broker, or communication specific software or hardware. This can lower your network management costs substantially.</p>
<p>The drawbacks are similar to each of the previous implementations in that, once a link in the chain is broken, the network is essentially rendered useless. Technically, because of the unidirectional communication pattern of a ring topology, the node residing immediately after the broken link in the chain can still communicate with every other node in the network, and maintain some degree of operation. However, since any responding device would be incapable of transmitting their response back to the originating node, communication would be one-way for all nodes on the chain. I'm having an extremely hard time imagining a scenario in which a device on a network can meaningfully interact with a distributed system via strict one-way communication.</p>
<p>Another less obvious downside to this is that the maximum performance of the whole network would be limited by the lowest performing link between any two nodes in the network. This is the case because any round-trip communication of request-response between two nodes would necessarily traverse the whole chain.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mesh topology</h1>
                
            
            
                
<p>The mesh topology is one of the most resilient and common network topologies in use today. And the reason for that is that it is almost entirely arbitrary in how it is organized. A mesh topology simply describes any non-formal topology of connectivity in which some nodes are connected by way of a single point-to-point connection to some other nodes, and some may have multiple connections to multiple nodes. The original graph diagram from the beginning of this chapter, shown as follows, is technically a mesh network topology:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-893 image-border" src="img/9057649e-d8a6-4b6d-bcda-3870d05f9b1b.png" style="width:17.08em;height:10.33em;"/></p>
<p>In case you forgot.</p>
<p>You'll note that the nodes in the preceding diagram have anywhere from one to three direct connections to other nodes in the network. This can provide some of the resilience of other network topologies where necessary, without incurring their costs. Since there is no obvious specification for a mesh network other than that it does not fully implement any of the other network topologies we discussed, it can include networks with an arbitrary degree of connectivity between nodes up to, and including, a fully-connected mesh network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fully connected mesh network</h1>
                
            
            
                
<p>A fully connected mesh network is one in which every node has a direct connection to every other node in the network, as demonstrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-894 image-border" src="img/2429ea22-6539-483c-81e6-e7ddfa851e9d.png" style="width:13.92em;height:13.33em;"/></p>
<p>If this diagram looks a bit crowded to you, you've already noticed the single biggest drawback of a fully-connected mesh network. It's nearly impossible to scale beyond a certain point, because each new node on the network requires a connection for each previously connected node on the network. The math works out to a quadratic increase in connections for each new node to be added. Moving past a few nodes on the network becomes physically impossible very quickly.</p>
<p>The incredibly high cost of a fully connected mesh network, however, brings with it the most stable and resilient topology possible. No node has to be responsible for packet-forwarding or request switching, because there should be no context in which two nodes are communicating with each other indirectly. Any one node or connection between nodes can go down, and every other node on the network has full connectivity with no loss of performance. A single weak connection between two nodes has zero impact on the performance of any other two nodes. As topologies go, a fully connected mesh is bulletproof. It's also often prohibitively expensive, and so not common in anything but the smallest and most trivial contexts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hybrid and specialized topologies</h1>
                
            
            
                
<p>As I mentioned before, most larger networks over which you might need to access resources are composed of multiple topologies joined together into what are typically called <strong>hybrids</strong>. A star topology, in which one of the peripheral nodes is also a link in a linear topology, would be an example of such a hybrid.</p>
<p>Other kinds of topologies are actually variants of the topologies we've discussed here. For example, a scenario where a node of a linear network topology is also the access point to a secondary linear topology constitutes a tree topology, simply a hierarchical linear topology. The specifics of these structures are less important than knowing that they exist and that, depending on the nature of the software you intend to deploy onto a network, you know that there are costs and considerations to be made for them. And speaking of those costs...</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The software impact of distributing resources on a network</h1>
                
            
            
                
<p class="mce-root">All this talk of device-agnosticism and open communication might sound extremely abstract up to this point. You may well be reading this and wondering yeah, so what? I don't have to code a network switch, which is probably true. It is certainly true that you won't have to code a network switch in C# using .NET Core, since that is quite a bit beyond the scope and capabilities of the framework, and thus, this book. The impact of the unpredictability of a network on your software, however, will be pretty substantial, and that will be true no matter what part of the network stack you're programming for. So, let's look at some of the ways your code should be prepared for distributed systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Security</h1>
                
            
            
                
<p>I've gone to the most obvious and complicated issue first,<em> </em>because I personally find it to be the most interesting. Writing software in a professional context will, across the board, require you to code your applications to be secure. Even if your job doesn't explicitly require it, I would argue until I'm blue in the face that, as an engineer, you have an ethical obligation to write secure software regardless. That can be a daunting task. Especially since having secured software is always a moving target. It's important that you keep this in mind, though, because making your software useful as a resource to a wide variety of benevolent consumers inherently opens you up to malicious intent.</p>
<p>This is where device-agnosticism and open communication become hugely important. Device-agnosticism means you can't reasonably be sure that a malicious actor hasn't gained access to a network that you may have assumed was secured upstream from your hosting environment. You will only ever see and process requests on the access points to your software. And open communication means you may end up getting a number of requests that are malformed that you'll attempt to parse initially, before determining that you can't, and disposing of them. This need to first read the messages you're given, in order to know, if they're something you care about, as that ultimately exposes you to malicious commands or code.</p>
<p>Thankfully, as we'll explore later, the .NET Core libraries provide a wide array of strong security components right out of the box, and the leg-work of getting and leveraging the encryption libraries and request sanitizing algorithms is just a matter of knowing what <kbd>using</kbd> statements to include at the top of your source files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication overhead</h1>
                
            
            
                
<p>The other, most obvious concern you face with networked programming is dealing with the openness of open communication. That property means that you'll have to spend a substantial amount of time familiarizing yourself with the specific messaging standards of different communication protocols (which I'll cover in depth in this book). There's an immense amount of organization necessary to cram data into well-formed packets, with appropriate header information to tell your software when to start and when to stop reading from your connection to get the full, uninterrupted binary stream and convert that back into meaningful data structures in your code. It's a headache just describing the process.</p>
<p>In locally hosted code, you have the benefit of sharing DLLs of your libraries among consumer applications to facilitate a shared contract for data structures. You could communicate with other software on your system through the filesystem itself. You could just use the systems, file-access APIs to expose all the nuts and bolts of how much data exists in your message, what the encoding of that data is, and expose it through random access into the file.</p>
<p>With a network, you have to give enough context for someone else to make sense of your message with the message itself. And you have to communicate that context in a way that a consumer could understand it before they have that context. Once again, the .NET libraries will come to your rescue here, providing easy-to-use classes exposing standardized headers and message formats to keep your code clear of that overhead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Resilience</h1>
                
            
            
                
<p>I mentioned this concept a few times talking about network topologies, but it bears special mention here, because you'll be responsible for maintaining resiliency of your application on a network from both ends of a connection. If your application leverages any resources on a network, you'll have to account for the very likely possibility that there will be times at which those resources aren't actually available<em> </em>on that network. You'll need to write your code so that it still responds to its users in a reliable and stable manner in the event of such an outage.</p>
<p>Likewise, if your software is a dependency for other systems on your network, and it goes down, the best thing for you to do is have a strategy in place for rebounding from such an outage. There are a number of viable solutions in place for notifying your downstream consumers that you've recovered from an outage, each with their own strengths and costs in terms of resource usage or development time, and we'll discuss several of them later in this book. For now though, it is sufficient to consider this as you design your solutions and adjust those designs accordingly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchrony</h1>
                
            
            
                
<p>Tying in somewhat closely with the notion of resiliency and open communication is the concept of asynchronous communication. This is a hugely important concept for maintaining any semblance of reliable performance on a networked program. Put simply, it's the concept of processing the result of a request that is not<em> </em>provided by the code internal to your system when<em> </em>that result becomes available.</p>
<p>When your program needs to request some resources from another node on its network, there is a round-trip time associated with sending your initial request and then receiving some meaningful response. During that time, you program technically could<em> </em>lock and wait for the response to come back, but realistically, there is no reason why it should<em> </em>lock and wait. However, even after our program may have moved on, deciding not to wait on the response to our initial request, we typically want to take a step back and handle the response whenever it does<em> </em>come back over the network. This process is asynchronous programming, and it's a major key to developing reasonably performing network software.</p>
<p>One obvious case of asynchronous programming you may have encountered separately from the context of network programming is in programming responsive user interfaces (UI). Typically, a UI component needs to actively listen and respond to user inputs whenever that user chooses to engage with it. Since the programmer can't ever know precisely when<em> </em>a user might want to press a button they've been presented with, they must respond to the input at the earliest moment that resources that can respond to the input without<em> </em>keeping those resources on hold while they wait to respond.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Network objects and data structures in .NET Core</h1>
                
            
            
                
<p>It may sound like a daunting task to start writing network code from scratch, and in some cases, it absolutely is. There is help, however, in the form of the .NET Core class libraries. With these libraries, you'll be well positioned to start working with clean abstractions for complicated, and often frustrating, network protocols and standards to start producing valuable components on a distributed network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using System.Net</h1>
                
            
            
                
<p>The <kbd>using</kbd> statement might be one of the most important statements you can include in source files containing any sort of networking code. The <kbd>System.Net</kbd> namespace is a suite of general-purpose .NET Core classes and utilities for programming most protocols and networked system behaviors. It is the root namespace for the most common networking classes you'll use as we move through this book.</p>
<p>The namespace includes classes for the following:</p>
<ul>
<li>Domain name resolution and DNS access</li>
<li>The abstract base <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes, as well as common implementations of those classes, including <kbd>FtpWebRequest</kbd>, and <kbd>HttpWebRequest</kbd></li>
<li><strong>Internet Protocol</strong> (<strong>IP</strong>) resolution and definition</li>
<li>Socket utility class definitions</li>
<li>Many others</li>
</ul>
<p>The classes in this namespace will be your bread and butter as you begin to develop more complex and powerful software, and you should spend a fair amount of time familiarizing yourself with the features and functionality the System.Net namespace encapsulates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting specific with sub-namespaces</h1>
                
            
            
                
<p>While the System.Net namespace encapsulates a wealth of useful classes for network programming, there are a number of useful sub-namespaces under the System.Net package hierarchy that you should also be familiar with, as follows.</p>
<ul>
<li><kbd>System.Net.Http</kbd>: A utility class used to provide HTTP standards-compliant messages and interactions within your .NET Core app</li>
<li><kbd>System.Net.NetworkInformation</kbd>: Provides traffic data, address information, and other details about the host node on the network</li>
<li><kbd>System.Net.Security</kbd>: Provides reliably secure networked communication and resource sharing and accessing</li>
<li><kbd>System.Net.Sockets</kbd>:  Exposes netcore managed access to the WinSock interface</li>
</ul>
<p>Each of these namespaces and the classes they expose will be explored in much greater detail over the course of this book, but for now, I wanted to expose you to some of the most commonly used, and most broadly valuable, network classes provided out of the box by .NET Core.</p>
<p>Their software is open source and described by robust and reliable documentation here:</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1">https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1</a></p>
<p>It would certainly be worth the time of anyone considering a career in network web development to examine the classes in their fullest.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A whole new computing world</h1>
                
            
            
                
<p>The maximum value a piece of software can deliver is limited by the number of downstream consumers of that software who have the ability to leverage it. Deploying your software on a widely available network can increase the overall impact it has on your organization or community of consumers. This last section takes a look at the kinds of applications opened up by this transition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Long – distance communication</h1>
                
            
            
                
<p>Thanks to communication protocols such as <strong>File Transfer Protocol</strong> (<strong>FTP</strong>) and <strong>Simple Mail Transfer Protocol </strong>(<strong>SMTP</strong>), it is possible to write to, or receive a letter from, someone on the entire other side of the globe within a few seconds of them having sent it. This feat of engineering is made possible by a robust, resilient physical infrastructure supporting the internet as a whole, and by the end of this book, the target is for you to have the skills necessary to develop these kinds of applications.</p>
<p>With peer-to-peer communication protocols, we can build systems of networked multiplayers for real-time, high-intensity, high-action games.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Share functionality, not code</h1>
                
            
            
                
<p>With well-defined standards such as the RESTful API design and the messaging format of HTTP, you can write stable, clean, well-isolated web API projects that allow a variety of consumers to request functionality you've written on demand. Instead of sharing code directly, you can keep your abstractions abstract and allow only conceptual access to the business process you own through well-documented channels of communication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter took a very<em> </em>deep dive on a small handful of subjects. We delivered a carefully considered definition of a network, and then considered how the key components of that definition impact our development strategies for network programs. We considered the distinction between a physical and logical network topology, and then explored the most common logical topologies we'll be working with. Lastly, we considered what kinds of new design decisions and strategies we'll have to make as we start to write our first network programs, as well as the .NET classes that will help us implement those strategies easily and cleanly.</p>
<p>In the next chapter, we'll take the first steps into programming for networks, as we look into resource location and addressing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the definition of a network?</li>
<li>What is the difference between a physical and logical topology?</li>
<li>Which was the only network topology discussed in this chapter that is not exposed to a potential single point of failure?</li>
<li>What are some of the physical devices that implement channels of communication on a network? What physical devices serve as nodes?</li>
<li>What is the root namespace for the most common networking libraries and classes provided by .NET Core?</li>
<li>Name at least four classes exposed by the System.Net namespace.</li>
<li>What are the four other most commonly used namespaces provided by .NET Core for reliable and stable network programming?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>For additional general information on networks, check out <em>Building Modern Networks</em> by <em>Steven Noble</em>, which is available through Packt Publishing. It's a great resource for understanding the challenges facing modern network engineers, and a good, deep dive into the applications of the concepts discussed in this chapter.</p>


            

            
        
    </body></html>