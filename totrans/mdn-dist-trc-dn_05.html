<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor083"/>5</h1>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Configuration and Control Plane</h1>
<p>In the previous chapters, we learned how to enable auto-instrumentation with a few lines of code and leverage collected telemetry to debug issues and monitor performance. Auto-collected traces and metrics provide the basis for your observability solution, but they are rarely sufficient without an application context. In this chapter, we’ll learn how to customize telemetry collection – enrich, adjust, or control its volume. We will dive into the following topics:</p>
<ul>
<li>Controlling costs with sampling</li>
<li>Enriching and filtering telemetry</li>
<li>Customizing context propagation</li>
<li>Building a processing pipeline with the OpenTelemetry Collector</li>
</ul>
<p>By the end of this chapter, you will be able to choose a sampling strategy and configure it in your system, efficiently enrich auto-generated traces with custom attributes, and propagate your context between services. We’ll see also how to suppress noisy spans and metrics.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Technical requirements</h1>
<p>The code for this chapter is available in the book’s repository on GitHub at <a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5</a>, which has the following structure:</p>
<ul>
<li>The <code>sampling</code> application contains sampling code snippets</li>
<li>The <code>memes</code> application is an improved version of the meme service from <a href="B19423_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Native Monitoring in .NET</em>, which contains enrichment and context propagation examples</li>
</ul>
<p>To run samples and perform analysis, we’ll need the following tools:</p>
<ul>
<li>.NET SDK 7.0 or later</li>
<li>Docker and <code>docker-compose</code></li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Controlling costs with sampling</h1>
<p>Tracing all operations gives us the ability<a id="_idIndexMarker286"/> to debug individual issues<a id="_idIndexMarker287"/> in the system, even very rare ones, but it could be impractical from a performance and telemetry storage perspective.</p>
<p>The performance impact of optimized and succinct instrumentation is usually low, but telemetry ingestion, processing, storage, queries, and other observability experiences could be very costly.</p>
<p>Observability vendors’ pricing models vary – some charge for the volume of ingested traces, others for the number of events, traces, or hosts reporting data. The ingestion cost usually includes retaining telemetry for 1 to 3 months. Data retrieval and scanning are also billed by some vendors. Essentially, costs associated with sending and retrieving telemetry grow along with telemetry volume.</p>
<p>Realistically, we’re going to be interested in a very small fraction of traces – ones that record failures, long requests, and other rare cases. We may also query a subset of traces for analytics purposes.</p>
<p>So, collecting all traces comes at a relatively small performance hit and could be reasonable, but storing all of them on an observability backend is rarely justified.</p>
<p class="callout-heading">Note</p>
<p class="callout">You might consider using traces as audit logs<a id="_idIndexMarker288"/> and then need every operation to be recorded. However, we need traces to debug and resolve incidents in production, which implies a fast query time, potentially short retention, and traces being accessible by every on-call person. Audit logs usually need a different privacy and retention policy. They also don’t necessarily require fast and random access.</p>
<p><strong class="bold">Sampling</strong> is a technique that allows recording<a id="_idIndexMarker289"/> a subset of traces, thus reducing storage costs. There are two main approaches to sampling: <strong class="bold">head-based</strong> and <strong class="bold">tail-based</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Both head-based and tail-based sampling rely on trace context propagation that needs to happen regardless of the sampling decision.</p>
<p>Let’s take a closer look at different sampling approaches and see how and when to apply them.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Head-based sampling</h2>
<p>With head-based sampling, the decision to record<a id="_idIndexMarker290"/> or not record a trace is done when the trace is started by the application process and is usually random (or based on information available beforehand). The assumption here is that under high-scale problems that need attention happen frequently enough to record at least some occurrences. In other words, problems that are never recorded are too rare and are likely less important. “Too rare” and “frequently enough” here totally depend on application requirements.</p>
<p>Head-based sampling algorithms try to be consistent so that we can capture all spans or none of them in any trace. It’s achieved by either following upstream sampling decisions or making independent, but consistent, decisions on each service. Let’s learn more about these approaches and also check how we can implement custom sampling solutions.</p>
<h3>Parent-based sampling</h3>
<p>With the <code>traceparent</code>. For example, as we saw in <a href="B19423_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Observability Needs of Modern Applications</em>, <code>traceparent</code> with <code>00-trace1-span1-01</code> indicates that upstream services recorded this span, and <code>00-trace2-span2-00</code> indicates that the span was not recorded. To enable this behavior in OpenTelemetry, you can use <code>ParentBasedSampler</code>. When all services follow the parent decision, the sampling probability (or percentage or recorded traces) configured on the first component applies to all downstream services.</p>
<p class="callout-heading">Note</p>
<p class="callout">With using parent-based sampling, the component that makes decision needs to be fully trusted – if it starts to record all traces, it might overload your telemetry collection pipeline and could cause your observability backend costs to skyrocket. You would normally make sampling decisions on your API gateway or frontend and would never trust sampling decisions coming from an external client.</p>
<p>The root component still needs to make independent sampling decision. Even though this decision can be random and other services would follow, it’s a good idea to stick to OpenTelemetry (or your observability vendor) sampling algorithms<a id="_idIndexMarker293"/> and keep them consistent<a id="_idIndexMarker294"/> across the system.</p>
<h3>Probability sampling</h3>
<p>Another approach<a id="_idIndexMarker295"/> involves making a sampling decision on every service<a id="_idIndexMarker296"/> but doing it consistently, so <code>trace</code> that’s recorded on one service would be recorded on another if they have the same sampling rate configured.</p>
<p>To achieve this, the <code>trace-id</code>. If the score is smaller<a id="_idIndexMarker297"/> than the probability, the span is recorded, otherwise, it’s dropped.</p>
<p class="callout-heading">Note</p>
<p class="callout">Probability sampling reduces your costs by only recording a fraction of the traces. Unexpected loads or bursts of traffic result in prorated growth in the volume of recorded traces. OpenTelemetry for .NET does not support a fixed-rate sampler out of the box, but you can configure the collector to do it or your observability vendor may provide one.</p>
<p>Probability sampling is implemented in OpenTelemetry with <code>TraceIdRatioBasedSampler</code> and can be configured with the <code>SetSampler</code> method on <code>TracerProviderBuilder</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
builder.Services.AddOpenTelemetry()
  .WithTracing(tp =&gt; tp
<strong class="bold">    .SetSampler(new TraceIdRatioBasedSampler(0.1))</strong>
    .AddOtlpExporter());</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs</a></p>
<p>We set the probability to <code>0.1</code> in this example, which means that 10% of all traces will be recorded.</p>
<p>And if we want to configure parent-based sampling on downstream components, we should set an instance of <code>ParentBasedSampler</code> instead, as shown in the following example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
tp.SetSampler(
   new ParentBasedSampler(new AlwaysOffSampler()))</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs</a></p>
<p>We need to provide a sampler that’s used when there is no parent trace context – in this example, we’re sampling out all the requests that come without <code>traceparent</code>. We could customize parent-based samplers<a id="_idIndexMarker298"/> further – set samplers to handle different<a id="_idIndexMarker299"/> cases: when the parent is remote or local, and whether the parent is recorded or not.</p>
<h3>Consistent sampling</h3>
<p>Assuming all services<a id="_idIndexMarker300"/> have the same sampling probability<a id="_idIndexMarker301"/> configured, all spans in a trace will be recorded or dropped consistently – there will be no partial traces. However, using the same rate for all services is not always practical. You might want to configure higher sampling probability on a new service, or for one that has a small load. We can do it using a probability sampler by configuring it to different rates on different services.</p>
<p>As a result, we should expect that some tracers will be recorded partially. <em class="italic">Figure 5</em><em class="italic">.1</em> shows an example of a partial trace:</p>
<div><div><img alt="Figure 5.1 – Services with different sampling probabilities" src="img/B19423_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Services with different sampling probabilities</p>
<p>Service A starts a trace – it generates trace-id and makes a sampling decision by calculating the score and comparing it to the sampling probability configured on the service.</p>
<p>Let’s say the score is <code>0.1</code> – it’s smaller than the probability (<code>0.2</code>), so the request is sampled in, and we should record the corresponding span and its local children. Then <code>0.01</code>. <strong class="bold">Service B</strong> calculates the score – it’s the same, so the decision is to not record the span or its local children. But then <strong class="bold">Service B</strong> calls <strong class="bold">Service C</strong>, which records corresponding spans.</p>
<p>As a result, for this trace, we’ll have spans from <code>trace-id</code> had a different score, for example, <code>0.005</code>, all services would record corresponding spans and we’d have a complete trace.</p>
<p>Probability sampling relies on <code>trace-id</code> being random and that the same hash function is used to calculate the score for each span. This is the case if you use vanilla OpenTelemetry in the same language on all your services and don’t customize ID generation or configure vendor-specific samplers. If your <code>trace-id</code> is not random or if you have to use different sampling algorithms, we need a slightly different approach called <strong class="bold">consistent sampling</strong>. It’s experimental and not implemented in .NET at the moment.</p>
<p>The approach relies<a id="_idIndexMarker302"/> on sampling score<a id="_idIndexMarker303"/> propagation: the component that starts the trace calculates the sampling score using any algorithm and propagates it to downstream services via <code>tracestate</code>. Downstream services don’t need to calculate the score again – they read it from <code>tracestate</code> and make a sampling decision by comparing this score to their configured probability.</p>
<h3>Custom sampler</h3>
<p>You can implement<a id="_idIndexMarker304"/> your own samplers. For example, <code>DebugSampler</code> records all activities<a id="_idIndexMarker305"/> that have a <code>debug</code> flag in a <code>tracestate</code> header and uses the probability sampler for all other activities. With this sampler, you can force the trace to be recorded, by sending a request with valid <code>traceparent</code> and <code>tracestate: myapp=debug:1</code> headers, which can be useful when testing or reproducing problems:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">DebugSampler.cs</p>
<pre class="source-code">
class DebugSampler : Sampler
{
    private readonly static Sampler On
      = new AlwaysOnSampler();
    private readonly static Regex DebugFlag
      = new Regex("(^|,)myapp=debug:1($|,)",
                  RegexOptions.Compiled);
    private readonly Sampler _default;
    public DebugSampler(double probability)
    {
        _default =
           new TraceIdRatioBasedSampler(probability);
    }
    public override SamplingResult ShouldSample(
      in SamplingParameters parameters)
    {
        var tracestate =
           parameters.ParentContext.TraceState;
        if (tracestate != null &amp;&amp;
             DebugFlag.IsMatch(tracestate))
           return On.ShouldSample(parameters);
        return _default.ShouldSample(parameters);
    }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs</a></p>
<p>The sampler implements a <code>ShouldSample</code> method, which takes <code>SamplingParameters</code> in and returns <code>SamplingResult</code>.</p>
<p>Sampling parameters<a id="_idIndexMarker306"/> include parent<a id="_idIndexMarker307"/> trace context and additional details such as creation-time attributes, the <code>Activity</code> name, kind, <code>tracestate</code>, and links.</p>
<p><code>SamplingResult</code> is a struct that contains a <code>SamplingDecision</code> enum that takes one of three possible values:</p>
<ul>
<li><code>Drop</code>: Create <code>Activity</code>, but don’t record it.</li>
<li><code>RecordAndSample</code>: Create <code>Activity</code>, record it, and set the sampling flag on trace context.</li>
<li><code>RecordOnly</code>: Create <code>Activity</code> and record it, but don’t set a sampling flag on trace context. Built-in samplers never return a <code>RecordOnly</code> decision, but you can implement a custom sampler and return such a decision to a trace request locally without forcing downstream services to follow it (if they respect parent decisions).</li>
</ul>
<p><code>SamplingResult</code> also contains updated <code>tracestate</code> values and attributes – samplers can set them, and they will be used on the activity-to-be-created. We can configure this sampler<a id="_idIndexMarker308"/> in the same way<a id="_idIndexMarker309"/> as before, by calling the <code>SetSampler</code> method on the <code>TracerProviderBuilder</code> instance.</p>
<p class="callout-heading">Note</p>
<p class="callout">With OpenTelemetry, an activity is created for every sampling decision. But in .NET, it’s possible to prevent a sampled-out <code>Activity</code> from being created altogether.</p>
<p>We’ll learn more about sampling in vanilla .NET in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing Your Code</em>, and will see some examples of how instrumentations can suppress activity creation later in this chapter.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Tail-based sampling</h2>
<p>With tail-based sampling, the decision is made after the trace<a id="_idIndexMarker310"/> ends and could consider trace duration, presence of errors, or any other information available on spans. As you can imagine, we should first buffer all spans in the trace and then send all of them to the observability provider or drop all of them. Tail-based sampling must happen across different services and can only be done by an external component such as the OpenTelemetry Collector. The tail-sampling processor in the Collector is highly configurable and supports multiple sampling policies, including rate-limiting, latency, and status-code-based policies. You can combine multiple policies together. It’s not really possible to know when a trace ends, so the Collector starts buffering spans after the first span in that trace is received for a configurable time period and then makes a decision based on the available data.</p>
<p>The tail-based sampling processor in collector allows the creation of composite sampling strategies. For example, you can configure probability sampling on your .NET services to minimize performance impact and then apply rate limiting on the collector to control telemetry volume and observability backend costs.</p>
<p>You could also configure a higher sampling probability to collect more traces with bigger latency, errors, or specific attributes. Buffering is currently limited to a single instance of the Collector, so if spans from the same trace end up on different collectors, tail-based sampling may produce partial traces, but still would capture parts corresponding to failure or increased latency. Since tail-based sampling has to buffer spans, it is memory-consuming and requires additional compute resources, and works well for short traces. As usual, it makes sense to compare the costs of managing the Collector setup with the savings it brings.</p>
<p class="callout-heading">Note</p>
<p class="callout">With non-probabilistic sampling, usage analysis based on traces is skewed and could be misleading. Metrics collected inside the application independently of traces could still be your source of truth.</p>
<p>Depending on your needs, you may combine different approaches – for example, collect all data but keep it in a cold(ish) storage, only using a more expensive<a id="_idIndexMarker311"/> backend for a small subset of traces.</p>
<p>Now you’re ready to choose a sampling strategy and implement it in your system! Let’s move and explore how to enrich spans with additional context.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Enriching and filtering telemetry</h1>
<p>Traces and metrics coming<a id="_idIndexMarker312"/> from auto-instrumentation<a id="_idIndexMarker313"/> describe the technical side of an operation. While we can always add more spans with custom context (and we’ll learn how to do it in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing Your Code</em>), it could be more practical to add custom context to auto-collected telemetry.</p>
<p>Application-specific context is necessary to track usage and contains essential information that helps to detect and investigate issues.</p>
<p>For example, if we take our meme service, it would be very helpful to have the meme name and size on spans. With this, we’d be able to find the most popular memes, correlate meme upload and download requests, plan capacity, make cache optimizations, or reason about partitioning.</p>
<p>The easiest way to add a meme name is via the <code>Activity.SetTag</code> method. For example, we can the following code on the <code>Meme</code> page:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Meme.cshtml.cs</p>
<pre class="source-code">
public async Task&lt;IActionResult&gt; OnGet([FromQuery] string
  name)
{
  <strong class="bold">Activity.Current?.SetTag("meme_name", name);</strong>
    ...
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs</a></p>
<p><code>Activity.Current</code> here is created<a id="_idIndexMarker314"/> by ASP.NET Core. It was enabled with OpenTelemetry ASP.NET Core<a id="_idIndexMarker315"/> instrumentation – if tracing was disabled, <code>Activity.Current</code> would be <code>null</code> here, so we should always guard <code>Activity.Current</code> with a <code>null</code> check or use null coalescence.</p>
<p>We also check whether the activity is recorded – if the <code>IsAllDataRequested</code> flag is <code>true</code>. There is no point in recording attributes on a sampled-out activity, so it’s an optimization. While it’s very small in this case, it’s a good practice to use it to avoid any unnecessary string allocations or prevent heavier operations needed to retrieve the attribute value.</p>
<p>Finally, we call <code>SetTag</code> – a method that takes the string tag name and nullable object value. We’ll talk more about the Activity API and tags in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing </em><em class="italic">Your Code</em>.</p>
<p class="callout-heading">Note</p>
<p class="callout">A tag<a id="_idIndexMarker316"/> in the .NET Activity API is the same as the OpenTelemetry <code>span</code> attribute. Tags came from OpenTracing and were not renamed for backward-compatibility reasons. This book uses <em class="italic">tag</em> and <em class="italic">attribute</em> interchangeably.</p>
<p>With this approach, we can add meme names to all ASP.NET Core activities. But what about HTTP client and MySQL activities? Having meme names on them would be handy.</p>
<p>In the general case, it can be done<a id="_idIndexMarker317"/> with a span processor, but some instrumentations<a id="_idIndexMarker318"/> provide extensibility hooks allowing them to enrich their activities.</p>
<p>Let’s look at each of these approaches.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Span processors</h2>
<p>The span processor<a id="_idIndexMarker319"/> is a component of the OpenTelemetry export pipeline. When OpenTelemetry is notified about activity start or stop events, it synchronously calls the corresponding method on the processor. By implementing our own processor and adding it to the tracer provider, we can intercept all activities and add attributes from <code>AsyncLocal</code>, <code>ThreadLocal</code>, or another context available globally. We could also overwrite or remove attributes or filter out activities.</p>
<h3>Enriching</h3>
<p>Before we do this for the meme<a id="_idIndexMarker320"/> name, we need to decide how to pass it to the processor. Since we want meme names to be on all spans from all services, it would be a good case for baggage. Baggage, as we saw in <a href="B19423_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Observability Needs of Modern Applications</em>, represents application-specific context propagated between services.</p>
<p>So, let’s go ahead and add the meme name to the baggage on the frontend <code>Meme</code> and <code>Upload</code> pages:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Meme.cshtml.cs</p>
<pre class="source-code">
Activity.Current.SetTag("meme_name", name);
<strong class="bold">Baggage.SetBaggage("meme_name", name);</strong></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs</a></p>
<p>Setting <code>Baggage</code> does not always affect an activity that has started beforehand and is current now – it’s a side effect of <code>AsyncLocal</code>, and we’ll dig into this in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing Your Code</em>. So, we’re going to keep setting meme name tags on activities on the frontend pages. <code>Baggage</code> uses <code>AsyncLocal</code> underneath, so we can now reliably use it in the processor:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">MemeNameEnrichingProcessor.cs</p>
<pre class="source-code">
class MemeNameEnrichingProcessor : BaseProcessor&lt;Activity&gt;
{
    public override void OnEnd(Activity activity)
    {
        var name = GetName(activity);
        if (name != null)
            activity.SetTag("meme_name", name);
    }
    private string? GetName(Activity activity)
    {
<strong class="bold">        if (Baggage.Current.GetBaggage()</strong>
<strong class="bold">             .TryGetValue("meme_name", out var name))</strong>
<strong class="bold">            </strong><strong class="bold">return name;</strong>
<strong class="bold">        return activity.GetBaggageItem("meme_name");</strong>
    }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs</a></p>
<p>We’re overriding the <code>OnEnd</code> method here – we first get the meme name<a id="_idIndexMarker321"/> from the baggage and add it as a tag to the activity. We don’t need to check whether the activity is <code>null</code> since the processor won’t be called in such a case, but we might still need to check whether it’s sampled in because, as we’ll see soon, sampled-out activities can still sometimes reach your processor.</p>
<p class="callout-heading">Note</p>
<p class="callout">We get a name from <code>Baggage.Current</code>, but if it’s not there, we also check <code>Activity.Baggage</code>. The reason is that the <code>Baggage</code> type lives in the <code>OpenTelemetry</code> namespace and can be used beyond tracing. But ASP.NET Core is not aware of it and populates <code>Baggage</code> on <code>Activity</code>. As a rule of thumb, always set <code>Baggage</code> with <code>Baggage.SetBaggage</code>, but read it from <code>Baggage</code> and <code>Activity</code>.</p>
<p>The last step is to register this processor on <code>TracerProvider</code> on the frontend and storage services:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
Builder.Services.AddOpenTelemetry()
  .WithTracing(builder =&gt; builder
<strong class="bold">    .AddProcessor&lt;MemeNameEnrichingProcessor&gt;()</strong>
    …);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</a></p>
<p>That’s it – the frontend adds a meme name to <code>Baggage</code>, then <code>Baggage</code> is automatically propagated to <strong class="bold">storage</strong>. Whenever any activity ends, the enriching processor stamps the meme name on it.</p>
<p>By the way, we can also use the processor<a id="_idIndexMarker322"/> to remove unwanted tags by calling <code>SetTag</code> with a <code>null</code> value.</p>
<h3>Filtering</h3>
<p>Sometimes you want to drop<a id="_idIndexMarker323"/> some activities – for example, those that represent retrieving static files on a frontend or requests from web crawlers.</p>
<p>Dropping an activity after it has started in the middle of a trace breaks causation. It should be only done for activities that don’t have any children.</p>
<p>Some instrumentations provide a hook to suppress activities so they are never even created – we’ll see some examples of it later in this section.</p>
<p>But instrumentations don’t always<a id="_idIndexMarker324"/> support suppression, and filtering out already started activities might be the only option. Let’s see how to do it with a processor:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">StaticFilesFilteringProcessor.cs</p>
<pre class="source-code">
public class StaticFilesFilteringProcessor :
    BaseProcessor&lt;Activity&gt;
{
    public override void OnEnd(Activity activity)
    {
        if (activity.Kind == ActivityKind.Server &amp;&amp;
            activity.GetTagItem("http.method") as string
                                              == "GET" &amp;&amp;
            activity.GetTagItem("http.route") == null)
            <strong class="bold">activity.ActivityTraceFlags &amp;=</strong>
<strong class="bold">              ~ActivityTraceFlags.Recorded;</strong>
     }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs</a></p>
<p>In this processor, we check whether the activity has a <code>Server</code> kind (describes an incoming request), a <code>GET</code> method, and does not have a route. We can only check route presence in the <code>OnEnd</code> callback as the route is calculated after the activity starts.</p>
<p>Hence, we unset the recording flag on <code>Activity</code> so it will be dropped later in the exporting pipeline.</p>
<p>You may come up with a better heuristic to identify static files, and if it doesn’t require a route, you could suppress such activities using ASP.NET Core instrumentation options, as we’ll see a bit later.</p>
<p>To register this processor, add it to <code>TracerProviderBuilder</code> with the <code>AddProcessor</code> method. Make sure to add processors in the order you want them to run:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
Builder.Services.AddOpenTelemetry()
  .WithTracing(builder =&gt; builder
<strong class="bold">    .AddProcessor&lt;StaticFilesFilteringProcessor&gt;()</strong>
    .AddProcessor&lt;MemeNameEnrichingProcessor&gt;()
    …
);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs</a></p>
<p>We just learned how to filter<a id="_idIndexMarker325"/> and enrich activities with processors; let’s now see what we can do with instrumentation options.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Customizing instrumentations</h2>
<p>Instrumentations<a id="_idIndexMarker326"/> may provide configuration options allowing to customize telemetry collection. For example, you can configure recording exception events with HTTP client and ASP.NET Core instrumentations through the <code>RecordException</code> flag on the corresponding configuration options:</p>
<pre class="source-code">
AddHttpClientInstrumentation(o =&gt; o.RecordException = true)</pre>
<p>Instrumentations can also provide callbacks allowing to populate attributes from instrumentation-specific contexts such as <code>request</code> or <code>response</code> objects.</p>
<p>Let’s use it to set a request size on incoming HTTP requests on storage, so we can analyze meme sizes using ASP.NET Core instrumentation enrichments hooks:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
AddAspNetCoreInstrumentation(o =&gt;
{
    o.EnrichWithHttpRequest = (activity, request) =&gt;
        activity.SetTag("http.request_content_length",
                       request.ContentLength);
    o.EnrichWithHttpResponse = (activity, response) =&gt;
        activity.SetTag("http.response_content_length",
                        response.ContentLength);
    o.RecordException = true;
})</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs</a></p>
<p>In addition to ASP.NET Core, you can find similar hooks for HTTP, gRPC, and SQL client instrumentations available in the <code>opentelemetry-dotnet</code> repo.</p>
<p>The same instrumentations<a id="_idIndexMarker327"/> also provide hooks that prevent <code>Activity</code> from being created. For example, if we wanted to suppress activities created for static files instead of dropping them in the processor, we could write something like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
<strong class="bold">AddAspNetCoreInstrumentation(o =&gt; o.Filter =</strong>
<strong class="bold">    ctx =&gt; !IsStaticFile(ctx.Request.Path))</strong>
...
static bool IsStaticFile(PathString requestPath)
{
    return requestPath.HasValue &amp;&amp;
        (requestPath.Value.EndsWith(".js") ||
         requestPath.Value.EndsWith(".css"));
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</a></p>
<p>If you consider suppressing or enriching individual activities based on dynamic context, instrumentation hooks, when available, are the best option. If you want to enrich all activities with ambient context, processors would be the right choice. Let’s now see how to populate static context<a id="_idIndexMarker328"/> on all activities with resources.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Resources</h2>
<p>An OpenTelemetry resource describes<a id="_idIndexMarker329"/> a service instance – it’s a set of static attributes describing the service name, version, namespace, instance, or any other static property. OpenTelemetry defines semantic conventions for Kubernetes, generic containers, clouds, processes, OS, devices, and other common resource kinds.</p>
<p>You can configure resources explicitly or through environment variables. For example, we already used the <code>OTEL_SERVICE_NAME</code> environment variable to configure the service name. We can set <code>OTEL_RESOURCE_ATTRIBUTES</code> to a list of comma-separated key-value pairs (for example, <code>region=westus,tag=foo</code>) to specify any custom resources.</p>
<p>Explicit configuration can be done with <code>ResourceBuilder</code>, which we should register on <code>TraceProviderBuilder</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
var env = new KeyValuePair&lt;string, object&gt;("env",
  builder.Environment.EnvironmentName);
var resourceBuilder = ResourceBuilder.CreateDefault()
    .AddService("frontend", "memes", "1.0.0")
    .AddAttributes(new[] { env });
...
Builder.Services.AddOpenTelemetry()
  .WithTracing(builder =&gt; builder
    .SetResourceBuilder(resourceBuilder)
  ...
);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</a></p>
<p>Note that environment variable detection is done by default, but you can turn it off by using <code>ResourceBuilder.CreateEmpty</code> instead of the <code>CreateDefault</code> factory method. Resources are populated on each of the signals, and we can configure different resources for traces, metrics, and logs if needed.</p>
<p>We’re ready to run the meme service<a id="_idIndexMarker330"/> and check out the result. Go ahead and run it with <code>compose up --build</code>. After the application starts, hit the frontend at <code>http://locahost:5051</code> and upload and download some memes. Now, you should be able to see new attributes – meme names on all spans and content size on incoming requests on storage. <em class="italic">Figure 5</em><em class="italic">.2</em> shows an example of a <code>GET</code> request:</p>
<div><div><img alt="Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes" src="img/B19423_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes</p>
<p>We also get new resource attributes<a id="_idIndexMarker331"/> on every exported span, as well as exception events on incoming and outgoing HTTP spans, as shown in <em class="italic">Figure 5</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 5.3 – Resource attributes and exception events" src="img/B19423_05_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Resource attributes and exception events</p>
<p>Here, we can see <code>service.version</code>, <code>service.namespace</code>, <code>service.instance.id</code>, <code>env</code>, <code>region</code>, and <code>tag</code> attributes coming from our application, while <code>host.name</code> and <code>os.type</code> are added later on by the OpenTelemetry Collector resource detector.</p>
<p>With resource attributes, processors and baggage, instrumentation hooks, and flags, you can customize telemetry<a id="_idIndexMarker332"/> auto-collection, enrich activities with custom attributes, add events, and record exceptions. You can also change or remove attributes and suppress or filter out activities. But what about metrics, can we customize them?</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Metrics</h2>
<p>Auto-collected metrics<a id="_idIndexMarker333"/> are not as customizable as traces. With OpenTelemetry SDK, we can only enrich them using static resource attributes, but OpenTelemetry Collector provides processors that can add, remove, or rename attribute names and values, aggregate across attributes, change data types, or massage metrics in other ways.</p>
<p>Still, you can filter out specific instruments or their attributes using the <code>MeterProviderBuilder.AddView</code> method. For example, you can drop an instrument with a specific name using the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
WithMetrics(builder =&gt; builder.AddView(
  "process.runtime.dotnet.jit.il_compiled.size",
  <strong class="bold">MetricStreamConfiguration.Drop</strong>));</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</a></p>
<p>Prometheus replaces the dot with an underscore and the corresponding instrument appears as <code>process_runtime_dotnet_jit_il_compiled_size</code> there. Check the corresponding OpenTelemetry instrumentation documentation to find the original name of the instrument. For example, .NET runtime instrumentation documentation can be found here:  git<a href="http://hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md">hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md</a>.</p>
<p>You can also specify attributes<a id="_idIndexMarker334"/> you want on the instrument – OpenTelemetry will use only those specified and will drop other attributes. It can be done to save costs on unused attributes or to remove high-cardinality attributes added by mistake.</p>
<p>For example, this code removes <code>http.scheme</code> and <code>http.flavor</code> from the ASP.NET Core request duration metric:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
AddView("http.server.duration",
    new MetricStreamConfiguration(){
    TagKeys = new [" {"http.host", "http.method",
       "http.scheme", "http.target", "http.status_code" }
})</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</a></p>
<p>We just saw how to enrich traces<a id="_idIndexMarker335"/> and metrics with application-specific context, and update or remove attributes using different mechanisms available in OpenTelemetry. Let’s continue exploring OpenTelemetry configuration and learn how to configure context propagation.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Customizing context propagation</h1>
<p>When instrumenting<a id="_idIndexMarker336"/> new systems, using W3C trace context propagation is the default and the easiest option – it does not need any explicit configuration since .NET and OpenTelemetry use it by default. However, existing systems may employ legacy context propagation conventions.</p>
<p>To support them, we can configure a custom global propagator on OpenTelemetry using <code>Sdk.SetDefaultTextMapPropagator</code>. For example, if one of your old client applications still uses some variation of custom correlation ID, you can still read it from request headers and convert it to a <code>trace-id</code>-compatible format (or move it to baggage).</p>
<p>You can use a composite propagator and support multiple standards at once as shown in this example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">XCorrelationIdPropagator.cs</p>
<pre class="source-code">
Sdk.SetDefaultTextMapPropagator(
  new CompositeTextMapPropagator(new TextMapPropagator[] {
    new B3Propagator(true),
    new XCorrelationIdPropagator(),
    new BaggagePropagator()}));
DistributedContextPropagator.Current =
  DistributedContextPropagator.CreateNoOutputPropagator();</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs</a></p>
<p>Here, we configured the B3 propagator from the <code>OpenTelemetry.Extensions.Propagators</code> package, a custom one for the <code>x-correlation-id</code> support, and also one for baggage. Note that we also disabled native ASP.NET Core and HTTP client propagation by setting <code>DistributedContextPropagator.Current</code> to the no-output propagator. If we don’t do it, they will keep extracting and injecting <code>Trace-Context</code> headers.</p>
<p>When using composite<a id="_idIndexMarker337"/> context propagators, make sure to resolve collisions and define priority in case you get multiple conflicting combinations of trace context in the same request – we’ll talk more about it in <em class="italic">Chapter 16</em>, <em class="italic">Instrumenting </em><em class="italic">Brownfield Applications</em>.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Processing a pipeline with the OpenTelemetry Collector</h1>
<p>As we’ve seen before, the OpenTelemetry Collector<a id="_idIndexMarker338"/> is another component<a id="_idIndexMarker339"/> that’s capable of controlling, enriching, filtering, converting, routing, aggregating, sampling, and processing telemetry in any other possible way. <em class="italic">Figure 5</em><em class="italic">.4</em> shows the main Collector components:</p>
<div><div><img alt="Figure 5.4 – OpenTelemetry Collector pipeline" src="img/B19423_05_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – OpenTelemetry Collector pipeline</p>
<p>Receivers get telemetry from different sources, and processors massage data and pass it over to exporters.</p>
<p>Since the collector<a id="_idIndexMarker340"/> is a separate process, potentially running<a id="_idIndexMarker341"/> on a different machine, it does not have a dynamic context, such as a specific HTTP request header, which you might want to stamp on spans. Such context can only be added inside your application.</p>
<p>But the collector could have more context about the environment the application runs in – for example, it can enrich telemetry with Kubernetes or cloud provider context. It can also receive telemetry in any format and convert it into OpenTelemetry signals.</p>
<p>The Collector supports a variety of receivers including Docker stats, statsd, or containerd for metrics, Kubernetes events, syslog, or journald for logs, and many others. Collector processors can enrich, filter, or change attribute names and values on any signal. One of the common use cases is sensitive data redaction.</p>
<p>You can find available Collector components<a id="_idIndexMarker342"/> in the OpenTelemetry Registry, <a href="https://opentelemetry.io/registry">https://opentelemetry.io/registry</a>; just make sure to check the stability level for each component you consider using.</p>
<p>In many cases, it’s not a question of whether to configure and customize your telemetry pipeline in-process or with Collector – it’s both. Collector can help you migrate from one observability stack to another, provide safety<a id="_idIndexMarker343"/> belts on telemetry<a id="_idIndexMarker344"/> collection, and offload some work from your application.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Summary</h1>
<p>In previous chapters, we explored telemetry auto-collection, and now we have learned how to customize this telemetry. We learned about different sampling approaches – head-based and tail-based. Head-based sampling makes the decision to record a trace (or span) when it starts with a certain probability. Children can follow parent decisions and then traces are always complete, but it’s not possible to control the volume of traces on individual services. To overcome this, downstream services can configure different rates and use consistent sampling to maximize the number of complete traces. Some traces become partial but are still useful for monitoring individual services or groups of them.</p>
<p>Probability sampling captures a percentage of all traces and is great to mitigate performance overhead. If you need predictable costs, you should consider rate-based sampling. It’s implemented in the OpenTelemetry Collector or by observability vendors. The OpenTelemetry Collector can also do tail-based sampling and record failures and long traces with higher probability.</p>
<p>Auto-instrumentations collect generic information, so we need to add application-specific context to gain a much deeper level of observability. Enrichment can be done inside the process with resources – static attributes describing your service instance, or with span processors, instrumentation hooks, or configuration options that can capture dynamic context. We can add, remove, or change attributes, and we can use baggage to propagate application-specific context within our system.</p>
<p>We can sometimes suppress activities with instrumentation hooks or flags or filter them out using processors. Filtering activities that have already started should be done with caution as it will break the correlation between dropped activity’s ancestors and successors. It should only be done for activities that don’t have children.</p>
<p>Metrics allow some customization too – we can enrich them with resource attributes, drop specific instruments, or limit attributes populated by instrumentations.</p>
<p>We also looked at context propagation customization, which can provide interoperability with custom and legacy correlation solutions you might have.</p>
<p>Finally, we talked about Collector features that can be used in addition to in-process configuration – environment resource detection or filtering and massaging telemetry. It can also provide rate-limiting sampling and protect your telemetry pipeline from overloading.</p>
<p>In this chapter, you learned to choose a sampling strategy and implement it, enrich traces with application context, and customize context propagation. It concludes our auto-instrumentation journey; from now on, we’re going to explore instrumentation internals and learn how to write our own. In the next chapter, we’ll focus on creating activities.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Questions</h1>
<ol>
<li>How would you build a general-purpose sampling solution that also captures failures and long-running traces in a distributed application?</li>
<li>How would you record retries on the HTTP client spans?</li>
<li>Configure rate-limiting sampling on the OpenTelemetry Collector.</li>
</ol>
</div>
</body></html>