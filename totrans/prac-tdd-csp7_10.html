<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exploring Integrations</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we'll explore integration-testing the Speaker Meet application. The React front-end application will be tested and configured to hit the real back-end API, and the .NET application will be tested to ensure that it functions properly from controller to database.</p>
<p class="calibre2">In this chapter, we cover:</p>
<ul class="calibre7">
<li class="calibre8">Implementing a real API service</li>
<li class="calibre8">Removing mocked API calls</li>
<li class="calibre8">End-to-end integration</li>
<li class="calibre8">Integration tests</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a real API service</h1>
                
            
            <article>
                
<p class="calibre2">The time has come to actually receive data from the server. Our current data model is still not 100% correct, but the groundwork is there. When we receive the correct data structure from the server, we will need to update our views accordingly. We will leave that part as an exercise for you.</p>
<p class="calibre2">In this section, we will look at pulling our mocked API out of the factory that we created and replacing it with a real API. In our existing tests, we will use Sinon to override the default functionality of our Ajax component with the functionality from our mock API.</p>
<p class="calibre2">Lastly, we will need to create an application configuration object to manage the base path for the API to determine the correct path in both dev and prod.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Replacing the mock API with the real API service</h1>
                
            
            <article>
                
<p class="calibre2">To keep things as simple as possible, we will be using the fetch API to get data from the server. We will begin by breaking all the tests that are currently using the mock API. That is because we are going to create a stub class that implements the same interface as the mock API, but it will not be doing anything:</p>
<p class="calibre2"><kbd class="calibre11">src/services/fetchSpeakerService.js</kbd></p>
<pre class="calibre19">import * as errorTypes from '../reducers/errorTypes';<br class="title-page-name"/> <br class="title-page-name"/> export default class FetchSpeakerService {<br class="title-page-name"/>   constructor() { }<br class="title-page-name"/> <br class="title-page-name"/>   create(speaker) {<br class="title-page-name"/>     return;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   getAll() {<br class="title-page-name"/>     return;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   getById(id) {<br class="title-page-name"/>     return;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">Now, replace the mock service that is created by the factory with the creation of the fetch based service:</p>
<pre class="calibre19">import FetchSpeakerService from './fetchSpeakerService';<br class="title-page-name"/> <br class="title-page-name"/> export default class ServiceFactory {<br class="title-page-name"/>   constructor() {<br class="title-page-name"/>     this._speakerService = null;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   static createSpeakerService() {<br class="title-page-name"/>     return this._speakerService = <br class="title-page-name"/>       this._speakerService || new FetchSpeakerService();<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">Thankfully, only four tests are failing because of that change. Looking at the failed tests, three of them are failing because we did not return a promise. One test, however, is failing because we are no longer returning the mock API. We are going to ignore the failing tests caused by missing promises by excluding them temporarily. Then, we will focus on test checking for a specific instance.</p>
<p class="calibre2">The test that is failing is in the service factory tests. We don't actually want the service factory to return a <kbd class="calibre11">MockSpeakerService</kbd>. We want it to return a <kbd class="calibre11">FetchSpeakerService</kbd>. Even more accurately, we want any implementation of a <kbd class="calibre11">SpeakerService</kbd>. Let's create a base class that will behave like an interface or abstract class from C#:</p>
<p class="calibre2"><kbd class="calibre11">/src/services/speakerService.js</kbd></p>
<pre class="calibre19">export default class SpeakerService {<br class="title-page-name"/>   create(speaker) {<br class="title-page-name"/>     throw new Error("Not Implemented!")<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   getAll() {<br class="title-page-name"/>     throw new Error("Not Implemented!")<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   getById(id) {<br class="title-page-name"/>     throw new Error("Not Implemented!")<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">Now we have an abstract base class, we need to inherit from that base class in both our existing service classes:</p>
<pre class="calibre19">import SpeakerService from './speakerService';<br class="title-page-name"/> <br class="title-page-name"/> export default class MockSpeakerService extends SpeakerService {<br class="title-page-name"/>   constructor() {<br class="title-page-name"/>     super();<br class="title-page-name"/> <br class="title-page-name"/>     this._speakers = [];<br class="title-page-name"/>  }<br class="title-page-name"/> …</pre>
<pre class="calibre19">import SpeakerService from './speakerService';<br class="title-page-name"/> <br class="title-page-name"/> export default class FetchSpeakerService extends SpeakerService {<br class="title-page-name"/>   constructor() {<br class="title-page-name"/>     super();<br class="title-page-name"/>   }<br class="title-page-name"/> …</pre>
<p class="calibre2">And then we need to modify the factory tests to expect an instance of the base class instead of the derived class:</p>
<pre class="calibre19">it('returns a speaker service', () =&gt; {<br class="title-page-name"/>   // act<br class="title-page-name"/>   let result = factory.createSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(result).to.be.an.instanceOf(SpeakerService);<br class="title-page-name"/> });</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Sinon to mock Ajax responses</h1>
                
            
            <article>
                
<p class="calibre2">Now, it is time to tackle the three tests that we have ignored. They are expecting actual responses from our service. Right now, our service is completely empty. Keep in mind, those tests were written to be unit tests and we need to protect them from the changes in the response that the real endpoint will experience over time. For that reason, we are going to, finally, introduce Sinon.</p>
<p class="calibre2">We will use Sinon to return the results from our mock API instead of the real API. This will allow us to continue to use the work we have already put into the mock API.</p>
<p class="calibre2">After we have our existing tests covered, we are going to introduce integration tests by using Sinon to mock the back-end server. Using Sinon in that way will allow us to test-drive our fetch based speaker service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing existing tests</h1>
                
            
            <article>
                
<p class="calibre2">First things first; we must make our existing tests pass. In the <kbd class="calibre11">speakerActions.spec.js</kbd> file, find the first test that we skipped and remove the skip. This will cause that test to fail with:</p>
<p class="calibre2"><kbd class="calibre11">Cannot read property 'then' of undefined</kbd></p>
<p class="calibre2">Back in the <kbd class="calibre11">beforeEach</kbd> method, where we are creating the speaker service, we need to create a new Sinon stub for a service method. Looking at the test, we can see that the first service call we make is to get all speakers. So, let's start there:</p>
<pre class="calibre19">beforeEach(() =&gt; {<br class="title-page-name"/>   let service = factory.createSpeakerService();<br class="title-page-name"/>   let mockService = new MockSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>   getAll = sinon.stub(service, "getAll");<br class="title-page-name"/>   getAll.callsFake(mockService.getAll.bind(mockService));<br class="title-page-name"/> <br class="title-page-name"/>   mockStore = configureMockStore(middleware);<br class="title-page-name"/> });</pre>
<p class="calibre2">Looking at this code, what we have done is to create a new Sinon stub and redirect calls to the service <kbd class="calibre11">getAll</kbd> method to the <kbd class="calibre11">mockService getAll</kbd> method. Lastly, we bind the <kbd class="calibre11">mockService</kbd> call to the <kbd class="calibre11">mockService</kbd> to preserve access to private variables in the <kbd class="calibre11">mockService</kbd>.</p>
<p class="calibre2">Running the tests again, we get a new error:</p>
<p class="calibre2"><kbd class="calibre11">Attempted to wrap getAll which is already wrapped</kbd></p>
<p class="calibre2">What this error is telling us is that we have already created a stub for the method we are trying to stub. At first, this error may not make any sense. But, if you look we are doing this in a <kbd class="calibre11">beforeEach</kbd>. Sinon is a singleton and we are running our mocking commands inside a <kbd class="calibre11">beforeEach</kbd>, so it already has a <kbd class="calibre11">getAll</kbd> stub registered by the time the second test is preparing to run. What we must do is remove that registration before we try to register it again. Another way to say this is that we must remove the registration after each test run. Let’s add an <kbd class="calibre11">afterEach</kbd> method and remove the registration there:</p>
<pre class="calibre19">afterEach(() =&gt; {<br class="title-page-name"/>   getAll.restore();<br class="title-page-name"/> });</pre>
<p class="calibre2">That fixes the first failing test that we had, now to fix the other two. The process will be largely the same, so let's get started.</p>
<p class="calibre2">Remove the skip from the next test. The test fails. We are calling the <kbd class="calibre11">getSpeaker</kbd> action in this test and if we look at the speaker actions, we can see that it uses the <kbd class="calibre11">getById</kbd> service method. As before we will need to stub this method in the <kbd class="calibre11">beforeEach</kbd>.</p>
<p class="calibre2"><kbd class="calibre11">getById = sinon.stub(service, "getById");</kbd><br class="title-page-name"/>
<kbd class="calibre11">getById.callsFake(mockService.getById.bind(mockService));</kbd></p>
<p class="calibre2">As before, we are now getting the already wrapped message:</p>
<p class="calibre2"><kbd class="calibre11">Attempted to wrap getById which is already wrapped</kbd></p>
<p class="calibre2">We can fix this one the same way we fixed the last one, by removing the stub in the <kbd class="calibre11">afterEach</kbd> function.</p>
<p class="calibre2"><kbd class="calibre11">getById.restore();</kbd></p>
<p class="calibre2">We are back to all passing tests with one skipped. The last test is the exact same process. Here are the full <kbd class="calibre11">beforeEach</kbd> and <kbd class="calibre11">afterEach</kbd> functions when we are done:</p>
<pre class="calibre19">beforeEach(() =&gt; {<br class="title-page-name"/>   let service = factory.createSpeakerService();<br class="title-page-name"/>   let mockService = new MockSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>   getAll = sinon.stub(service, "getAll");<br class="title-page-name"/>   getAll.callsFake(mockService.getAll.bind(mockService));<br class="title-page-name"/> <br class="title-page-name"/>   getById = sinon.stub(service, "getById");<br class="title-page-name"/>   getById.callsFake(mockService.getById.bind(mockService));<br class="title-page-name"/> <br class="title-page-name"/>   create = sinon.stub(service, "create");<br class="title-page-name"/>   create.callsFake(mockService.create.bind(mockService));<br class="title-page-name"/> <br class="title-page-name"/>   mockStore = configureMockStore(middleware);<br class="title-page-name"/> });<br class="title-page-name"/> <br class="title-page-name"/> afterEach(() =&gt; {<br class="title-page-name"/>   create.restore();<br class="title-page-name"/>   getAll.restore();<br class="title-page-name"/>   getById.restore();<br class="title-page-name"/> });</pre>
<p class="calibre2">Don't forget to remove the skip from the last test. When all is said and done you should have 42 passing tests and 0 skipped tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking the server</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have fixed our existing tests, we are ready to start writing tests for our real service, the <kbd class="calibre11">fetchSpeakerService</kbd>. Let's get started by looking at the test we used for our mock service. The tests will largely be the same as we are trying to achieve the same pattern of functionality.</p>
<p class="calibre2">First, we will want to create the test file <kbd class="calibre11">fetchSpeakerService.spec.js.</kbd> Once the file is created, we can add the standard existence test:</p>
<pre class="calibre19">describe('Fetch Speaker Service', () =&gt; {<br class="title-page-name"/>   it('exits', () =&gt; {<br class="title-page-name"/>     expect(FetchSpeakerService).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Because we stubbed out the fetch speaker service earlier, this test should just pass after we add the appropriate import.</p>
<p class="calibre2">Following the mock speaker service tests, the next test is a construction and type verification test:</p>
<pre class="calibre19">it('can be constructed', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   let service = new FetchSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(service).to.be.an.instanceof(FetchSpeakerService);<br class="title-page-name"/> });</pre>
<p class="calibre2">This test, too, should pass right away, because when we stubbed the fetch service we created it as a class. Continuing to follow the progression of the mock service tests, we have an <kbd class="calibre11">After Initialization</kbd> section with a <kbd class="calibre11">Create</kbd> section inside it. The only test in the <em class="calibre12">Create</em> section is an exists test for the <kbd class="calibre11">Create</kbd> method. Writing this test, it should pass:</p>
<pre class="calibre19">describe('After Initialization', () =&gt; {<br class="title-page-name"/>   let service = null;<br class="title-page-name"/> <br class="title-page-name"/>   beforeEach(() =&gt; {<br class="title-page-name"/>     service = new FetchSpeakerService();<br class="title-page-name"/>   });<br class="title-page-name"/> <br class="title-page-name"/>   describe('Create', () =&gt; {<br class="title-page-name"/>     it('exists', () =&gt; {<br class="title-page-name"/>       expect(service.create).to.exist;<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Because we are copying the flow from the mock service tests, we have already extracted the service to a <kbd class="calibre11">beforeEach</kbd> instantiation.</p>
<p class="calibre2">In the next section, our tests will start to get interesting and won't just pass right away. Before we move on, to verify that the tests are doing what they should be doing, it is a good idea to comment out parts of the fetch service and see the appropriate tests pass.</p>
<p class="calibre2">Moving on to the <kbd class="calibre11">Get All</kbd> section, still inside the <kbd class="calibre11">After Initialization</kbd> section, we have an existence test checking the <kbd class="calibre11">getAll method</kbd>:</p>
<pre class="calibre19">describe('Get All', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     // assert<br class="title-page-name"/>     expect(service.getAll).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">As with the other tests so far, to fail this test you will have to comment out the <kbd class="calibre11">getAll</kbd> method in the fetch service to see it fail. Immediately following this test are two more sections: <kbd class="calibre11">No Speakers Exist</kbd> and <kbd class="calibre11">Speaker Listing</kbd>. We will add them one at a time starting with <kbd class="calibre11">No Speakers Exist</kbd>:</p>
<pre class="calibre19">describe.skip('No Speakers Exist', () =&gt; {<br class="title-page-name"/>   it('returns an empty array', () =&gt; {<br class="title-page-name"/>     // act<br class="title-page-name"/>     let promise = service.getAll();<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     return promise.then((result) =&gt; {<br class="title-page-name"/>       expect(result).to.have.lengthOf(0);<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Finally, we have a failing test. The failure is complaining because it doesn't look like we returned a promise. Let's begin the proper implementation of the fetch service and we will use Sinon in the tests to mock the back-end. In the fetch service, add the following:</p>
<pre class="calibre19">constructor(baseUrl) {<br class="title-page-name"/>   super();<br class="title-page-name"/> <br class="title-page-name"/>   this.baseUrl = baseUrl;<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> getAll() {<br class="title-page-name"/>   return fetch(`${this.baseUrl}/speakers`).then(r =&gt; {<br class="title-page-name"/>     return r.json();<br class="title-page-name"/>   });<br class="title-page-name"/> }</pre>
<p class="calibre2">This is a very basic fetch call. We are use the HTTP verb, <kbd class="calibre11">GET,</kbd> so there is no reason to call a method on fetch; by default it will use <kbd class="calibre11">GET</kbd>.</p>
<p class="calibre2">In our tests, we are now getting a meaningful result. <kbd class="calibre11">fetch is not defined</kbd>. This result is because fetch does not exist as part of our testing setup yet. We will need to import a new NPM package to handle fetch calls in testing. The package we want to import is <kbd class="calibre11">fetch-ponyfill</kbd>.</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install fetch-ponyfill</strong></pre>
<p class="calibre2">After installing the <kbd class="calibre11">ponyfill</kbd> library, we must modify our test setup file <kbd class="calibre11">scripts/test.js</kbd>:</p>
<pre class="calibre19">import { JSDOM } from'jsdom';<br class="title-page-name"/>import Enzyme from 'enzyme';<br class="title-page-name"/>import Adapter from 'enzyme-adapter-react-16';<br class="title-page-name"/><strong class="calibre1">import fetchPonyfill from 'fetch-ponyfill';<br class="title-page-name"/>const { fetch } = fetchPonyfill();<br class="title-page-name"/></strong><br class="title-page-name"/>const jsdom = new JSDOM('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;');<br class="title-page-name"/>const { window } = jsdom;<br class="title-page-name"/><strong class="calibre1">window.fetch = window.fetch || fetch;<br class="title-page-name"/></strong><br class="title-page-name"/>…<br class="title-page-name"/><br class="title-page-name"/>global.window = window;<br class="title-page-name"/>global.document = window.document;<br class="title-page-name"/><strong class="calibre1">global.fetch = window.fetch;</strong></pre>
<p class="calibre2">After those modifications, we must restart our tests for the changes to take effect. We are now getting a test failure telling us that only absolute URLs are supported. We are getting this message because when we instantiate our fetch service we aren't passing a baseURL. For the tests it doesn't matter what the URL is so let's just use localhost:</p>
<pre class="calibre19">beforeEach(() =&gt; {<br class="title-page-name"/>   service = new FetchSpeakerService('http://localhost');<br class="title-page-name"/> });</pre>
<p class="calibre2">After making this change we have moved the error forward and now we are getting a fetch error to the effect that localhost refused a connection. We are now ready to replace the back-end with Sinon.  We will start in the <kbd class="calibre11">beforeEach</kbd> and <kbd class="calibre11">afterEach</kbd>:</p>
<pre class="calibre19">let fetch = null;<br class="title-page-name"/> <br class="title-page-name"/> beforeEach(() =&gt; {<br class="title-page-name"/>   fetch = sinon.stub(global, 'fetch');<br class="title-page-name"/>   service = new FetchSpeakerService('http://localhost');<br class="title-page-name"/> });<br class="title-page-name"/> <br class="title-page-name"/> afterEach(() =&gt; {<br class="title-page-name"/>   fetch.restore();<br class="title-page-name"/> });</pre>
<p class="calibre2">In the test, we will need some items from the <kbd class="calibre11">fetch-ponyfill</kbd> package so let's add the import statements while we are close to the top of the file.</p>
<pre class="calibre19">import fetchPonyfill from 'fetch-ponyfill';<br class="title-page-name"/> const {<br class="title-page-name"/>   Response,<br class="title-page-name"/>   Headers<br class="title-page-name"/> } = fetchPonyfill();</pre>
<p class="calibre2">And now in the test, we need to configure the response from the server:</p>
<pre class="calibre19">it('returns an empty array', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   fetch.returns(new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     let response = new Response();<br class="title-page-name"/>     response.headers = new Headers({<br class="title-page-name"/>       'Content-Type': 'application/json'<br class="title-page-name"/>     });<br class="title-page-name"/>     response.ok = true;<br class="title-page-name"/>     response.status = 200;<br class="title-page-name"/>     response.statusText = 'OK';<br class="title-page-name"/>     response.body = JSON.stringify([]);<br class="title-page-name"/> <br class="title-page-name"/>     resolve(response);<br class="title-page-name"/>   }));<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   let promise = service.getAll();<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   return promise.then((result) =&gt; {<br class="title-page-name"/>     expect(result).to.have.lengthOf(0);<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">That finishes the <kbd class="calibre11">No Speakers Exist</kbd> scenario. We will refactor the server response once we have a better idea about what data will be changing.</p>
<p class="calibre2">We are now ready for the speaker listing scenario. As before, we start by copying the test from the mock service tests. Remove the arrange from the mock service test and copy the arrange from our previous test.</p>
<p class="calibre2">After adding the arrange from the no speakers test, we get a message expecting a length of 1 instead of 0. This is an easy fix and for the purposes of this test we can simply add an empty object to the body array of the response. Here is what the test should look like, once it is passing:</p>
<pre class="calibre19">describe('Speaker Listing', () =&gt; {<br class="title-page-name"/>     it('returns speakers', () =&gt; {<br class="title-page-name"/>       // arrange<br class="title-page-name"/>       fetch.returns(new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>         let response = new Response();<br class="title-page-name"/>         response.headers = new Headers({<br class="title-page-name"/>           'Content-Type': 'application/json'<br class="title-page-name"/>         });<br class="title-page-name"/>         response.ok = true;<br class="title-page-name"/>         response.status = 200;<br class="title-page-name"/>         response.statusText = 'OK';<br class="title-page-name"/>         response.body = JSON.stringify([{}]);<br class="title-page-name"/> <br class="title-page-name"/>         resolve(response);<br class="title-page-name"/>       }));<br class="title-page-name"/> <br class="title-page-name"/>       // act<br class="title-page-name"/>       let promise = service.getAll();<br class="title-page-name"/> <br class="title-page-name"/>       // assert<br class="title-page-name"/>       return promise.then((result) =&gt; {<br class="title-page-name"/>         expect(result).to.have.lengthOf(1);<br class="title-page-name"/>       });<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Now that we are using basically the same arrange twice, it's time to refactor our tests. The only thing that has really changed is the body. Let's extract an <kbd class="calibre11">okResponse</kbd> function to use:</p>
<pre class="calibre19">function okResponse(body) {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     let response = new Response();<br class="title-page-name"/>     response.headers = new Headers({<br class="title-page-name"/>       'Content-Type': 'application/json'<br class="title-page-name"/>     });<br class="title-page-name"/>     response.ok = true;<br class="title-page-name"/>     response.status = 200;<br class="title-page-name"/>     response.statusText = 'OK';<br class="title-page-name"/>     response.body = JSON.stringify(body);<br class="title-page-name"/> <br class="title-page-name"/>     resolve(response);<br class="title-page-name"/>   });<br class="title-page-name"/> }</pre>
<p class="calibre2">We have placed this helper function at the top of the <kbd class="calibre11">After Initialization</kbd> <kbd class="calibre11">describe</kbd>. Now in each test, replace the arrange with a call to the function, passing in the body that is specific to that test.</p>
<p class="calibre2">The get all speakers functionality is now covered by the tests. Let's move on to getting a specific speaker by ID. Copy the tests for <kbd class="calibre11">getById</kbd> from the mock service tests and apply a skip to the describes. Now, remove the skip from the outer-most describe. This should enable the existence test, which should pass.</p>
<p class="calibre2">The next test is for when a speaker is not found; removing skip from that test results in a message indicating that we are not returning a promise. Let's go into the body of the <kbd class="calibre11">getById</kbd> function and use fetch to get a speaker<span>:</span></p>
<pre class="calibre19">getById(id) {<br class="title-page-name"/>   return fetch(`${this.baseUrl}/speakers/${id}`);<br class="title-page-name"/> }</pre>
<p class="calibre2">Adding fetch to our function should have fixed the error but hasn't. Remember we are mocking the response from fetch so if we don't set a response then fetch won't return anything at all. Let's configure the mock response. In this case we are expecting a 404 from the server so let’s configure that response<span>:</span></p>
<pre class="calibre19">// arrange<br class="title-page-name"/> fetch.returns(new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>   let response = new Response();<br class="title-page-name"/>   response.headers = new Headers({<br class="title-page-name"/>     'Content-Type': 'application/json'<br class="title-page-name"/>   });<br class="title-page-name"/>   response.ok = false;<br class="title-page-name"/>   response.status = 404;<br class="title-page-name"/>   response.statusText = 'NOT FOUND';<br class="title-page-name"/> <br class="title-page-name"/>   resolve(response);<br class="title-page-name"/> }));</pre>
<p class="calibre2">That makes our test pass, but it's not for the right reason. Let’s add a <kbd class="calibre11">then</kbd> clause to the assertion to prove the false positive<span>:</span></p>
<pre class="calibre19">// assert<br class="title-page-name"/> return promise}).then(() =&gt; {<br class="title-page-name"/>   throw { type: 'Error not returned' };<br class="title-page-name"/> }).catch((error) =&gt; {<br class="title-page-name"/>   expect(error.type).to.equal(errorTypes.SPEAKER_NOT_FOUND);<br class="title-page-name"/> });</pre>
<p class="calibre2">Now our test will fail with expected <kbd class="calibre11">'Error not returned'</kbd> to equal <kbd class="calibre11">'SPEAKER_NOT_FOUND'</kbd>. Why is this? Shouldn't a 404 cause a rejection of the promise? With fetch, the only thing that will cause a rejected promise is a network connection error. For that reason, we didn't reject when we mocked the server response. What we need to do is check for that condition in the service and cause a promise rejection on that side. The easiest way to accomplish this is to wrap the fetch call with a promise of our own. Once wrapped, we can check for the appropriate condition and reject our promise<span>:</span></p>
<pre class="calibre19">getById(id) {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     fetch(`${this.baseUrl}/speakers/${id}`).then((response) =&gt; {<br class="title-page-name"/>       if (!response.ok) {<br class="title-page-name"/>         reject({<br class="title-page-name"/>           type: errorTypes.SPEAKER_NOT_FOUND<br class="title-page-name"/>         });<br class="title-page-name"/>       }<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> }</pre>
<p class="calibre2">That should do it for this test. We are now ready for our last test. Before we move on, let's do a quick refactoring of the arrange in this test to shorten the test and have it make a bit more sense to future readers. While we are doing that, we will refactor the existing response function to reduce duplication and enforce some default values<span>:</span></p>
<pre class="calibre19">function baseResponse() {<br class="title-page-name"/>   let response = new Response();<br class="title-page-name"/>   response.headers = new Headers({<br class="title-page-name"/>     'Content-Type': 'application/json'<br class="title-page-name"/>   });<br class="title-page-name"/>   response.ok = true;<br class="title-page-name"/>   response.status = 200;<br class="title-page-name"/>   response.statusText = 'OK';<br class="title-page-name"/> <br class="title-page-name"/>   return response;<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> function okResponse(body) {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     let response = baseResponse();       <br class="title-page-name"/>     response.body = JSON.stringify(body);<br class="title-page-name"/> <br class="title-page-name"/>     resolve(response);<br class="title-page-name"/>   });<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> function notFoundResponse() {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     let response = baseResponse();<br class="title-page-name"/>     response.ok = false;<br class="title-page-name"/>     response.status = 404;<br class="title-page-name"/>     response.statusText = 'NOT FOUND';<br class="title-page-name"/> <br class="title-page-name"/>     resolve(response);<br class="title-page-name"/>   })<br class="title-page-name"/> }</pre>
<p class="calibre2">Use the <kbd class="calibre11">notFoundResponse</kbd> function in the test just like we used the <kbd class="calibre11">okResponse</kbd> function. Moving on to our last test for the current functionality of the fetch service, remove the skip from the next describe and we will begin looking at the errors generated and make the necessary changes to make the test pass.</p>
<p class="calibre2">This last test is fairly simple after the work we have already done to make mock responses easier. We need the fetch call to return an <kbd class="calibre11">ok</kbd> response with the speaker as the body<span>:</span></p>
<pre class="calibre19">describe('Speaker Exists', () =&gt; {<br class="title-page-name"/>   it('returns the speaker', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     const speaker = {<br class="title-page-name"/>       id: 'test-speaker'<br class="title-page-name"/>     };<br class="title-page-name"/>     fetch.returns(okResponse(speaker));<br class="title-page-name"/> <br class="title-page-name"/>     // act<br class="title-page-name"/>     let promise = service.getById('test-speaker');<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     return promise.then((speaker) =&gt; {<br class="title-page-name"/>       expect(speaker).to.not.be.null;<br class="title-page-name"/>       expect(speaker.id).to.equal('test-speaker');<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Now, we are getting a timeout error. That is because our service isn't actually handling the case where the speaker exists. Let's add that now<span>:</span></p>
<pre class="calibre19">getById(id) {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     fetch(`${this.baseUrl}/speakers/${id}`).then((response) =&gt; {<br class="title-page-name"/>       if (response.ok) {<br class="title-page-name"/>         resolve(response.json());<br class="title-page-name"/>       } else {<br class="title-page-name"/>         reject({<br class="title-page-name"/>           type: errorTypes.SPEAKER_NOT_FOUND<br class="title-page-name"/>         });<br class="title-page-name"/>       }<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> }</pre>
<p class="calibre2">Now all our tests are passing and we have verified all the expected behavior of the system. There are a few more things we could do and some developers will choose to do them. We will discuss some of them but will not be providing examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Application configuration</h1>
                
            
            <article>
                
<p class="calibre2">Now that all the tests are passing there is still some application configuration that must be taken care of before the application can be used.</p>
<p class="calibre2">In the service factory, we must set a base URL for the fetch service to use when the application is running. This can be done many different ways and which way exactly is up to you. The simplest but least flexible way is to just hard-code a string value as the base URL used to construct the service. However, you could get as fancy as having a dynamic class that sets the value based on the applications, running environment. Again this decision is left to you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">End-to-end integration tests</h1>
                
            
            <article>
                
<p class="calibre2">The last subject we will discuss in this chapter is end-to-end integration tests. These tests involve actually calling the server and checking the real responses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Benefits</h1>
                
            
            <article>
                
<p class="calibre2">So, what are the benefits from testing the actual client server connection? The most valuable benefit is that you know your application will work in the deployed environment. Sometimes an application will get deployed and not work because a network or database connection was incorrectly configured and that will wreak havoc on a deployment.</p>
<p class="calibre2"><span>Additionally, this will help to verify the system is working properly. A series of smoke tests could be employed after a deployment to ensure the deployment was successful.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Detriments</h1>
                
            
            <article>
                
<p class="calibre2">E2E tests are usually skipped for one of two reasons. The first reason is that they are difficult to write. You have a lot of extra setup to get these tests to run, including a completely different test runner than what you normally use for unit testing. If not a different runner, they at least need to be a separate test run and not included in your normal unit tests.</p>
<p class="calibre2">The second issue is that E2E tests are fragile. Any change to the system and these tests break. They are not commonly run all the time like a unit test is and so the broken code will not be noticed until they are run in the production environment.</p>
<p class="calibre2">For these reasons we generally do not write that many E2E tests, if any at all.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How much end-to-end testing should you do?</h1>
                
            
            <article>
                
<p class="calibre2"><span>If you choose to do end-to-end testing, you will want to do as little as possible. These are the top tier of tests and should be the least numerous type of test in your system. A recommendation is to only write as many tests as you have third-party connections to your application, that is, one test for each back-end server that you must communicate with. Additionally, </span><span>use the simplest and most basic case which is not anticipated to change.</span></p>
<p class="calibre2">That completes integration testing from the front-end. There are still some things that can be done. We will leave them as an exercise for you. You might have noticed that the front-end and back-end are not fully in agreement for the model that is being passed back and forth. As an exercise, add or remove and refine the model that is being used by both systems so that they agree on the format.</p>
<p class="calibre2">Another task would be to set the base URL for the fetch service and run both applications locally to verify interconnectability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the API project</h1>
                
            
            <article>
                
<p class="calibre2">With the React project now configured to hit the real API, it's time to turn our attention to the .NET solution. In order to verify that everything is wired up correctly, you'll want to write a series of integration tests to ensure that the whole system is working properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integration test project</h1>
                
            
            <article>
                
<p class="calibre2">Create a new xUnit Project called <kbd class="calibre11">SpeakerMeet.Api.IntegrationTest</kbd> within the existing solution. This will be where the .NET integration tests will be created. You may want to explore separating these out according to your preferences and/or team coding standards, but that can wait. For now, a single integration test project will do.</p>
<p class="calibre2">For our purposes, we'll be testing whether the system functions from API entry all the way to the database, and back. However, it's best to start small test individual integration points, and grow from there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Where to begin?</h1>
                
            
            <article>
                
<p class="calibre2">You could certainly start by creating a test that will call an API endpoint. In order to achieve this, an HTTP Request will need to be made to a controller. The controller will then call into a service within the business layer, which in turn will make a call to the repository, and finally a command is sent to the database. That feels like a lot of moving parts. Perhaps there's a better place to start.</p>
<p class="calibre2">In order to break down the problem into smaller, more manageable pieces, perhaps it's best to start testing closer to the persistence layer of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Verifying the repository calls into the DB context</h1>
                
            
            <article>
                
<p class="calibre2">A good place to start is verifying that the system is fully integrated; let's first test that the repository can access the database. Create a folder within the integration test project called <kbd class="calibre11">RepositoryTests</kbd> and create a new test file called <kbd class="calibre11">GetAll</kbd>. This will be where the integration tests for the <kbd class="calibre11">GetAll</kbd> method of the repository will be created.</p>
<p class="calibre2">You could create a test that verifies that the repository can be created, like so:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  var options = new DbContextOptions&lt;SpeakerMeetContext&gt;();<br class="title-page-name"/>  var context = new SpeakerMeetContext(options);<br class="title-page-name"/><br class="title-page-name"/>  var repository = new Repository.Repository&lt;Speaker&gt;(context);<br class="title-page-name"/>}</pre>
<p class="calibre2">However, that's not going to pass. If you run the test you will receive the following error:</p>
<p class="calibre2"><kbd class="calibre11">System.InvalidOperationException: No database provider has been configured for this DbContext</kbd>.</p>
<p class="calibre2">This is easily fixed by configuring an appropriate provider.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">InMemory database</h1>
                
            
            <article>
                
<p class="calibre2">Running tests against a SQL Server is time-consuming, error-prone, and potentially costly. Establishing a connection to a database takes time, and remember, you want your test suite to be lightning-fast. It might also be a problem to rely on data if the database is used by others, whether in a development environment, by quality assurance engineers, and so on. You certainly wouldn't want to run your integration tests against a production database. Additionally, running tests against a database hosted in the cloud (for example, AWS, Azure, and so on) could potentially incur a dollar cost in terms of bandwidth and processing.</p>
<p class="calibre2">Luckily, it's quite trivial to configure a solution that uses Entity Framework to use an <kbd class="calibre11">InMemory</kbd> database.</p>
<p class="calibre2">First, install a <kbd class="calibre11">NuGet</kbd> package for the <kbd class="calibre11">InMemory</kbd> database.</p>
<p class="calibre2"><kbd class="calibre11">Microsoft.EntityFrameworkCore.InMemory</kbd></p>
<p class="calibre2">Now, modify the test you created before so that the database context is created <kbd class="calibre11">InMemory</kbd><span>:</span></p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  var options = new DbContextOptionsBuilder&lt;SpeakerMeetContext&gt;()<br class="title-page-name"/>      .UseInMemoryDatabase("SpeakerMeetInMemory")<br class="title-page-name"/>      .Options;<br class="title-page-name"/><br class="title-page-name"/>  var context = new SpeakerMeetContext(options);<br class="title-page-name"/><br class="title-page-name"/>  var repository = new Repository.Repository&lt;Speaker&gt;(context);<br class="title-page-name"/>}</pre>
<p class="calibre2">The test should now pass because the context is now being created <kbd class="calibre11">InMemory</kbd>.</p>
<p class="calibre2">Next, create a test to verify that a collection of Speaker entities is returned when the <kbd class="calibre11">GetAll</kbd> method is called<span>:</span></p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakersThenQueryableSpeakersReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  using (var context = new SpeakerMeetContext(_options))<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new Repository.Repository&lt;Speaker&gt;(context);<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var speakers = repository.GetAll();<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(speakers);<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;IQueryable&lt;Speaker&gt;&gt;(speakers);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, turn your attention to the <kbd class="calibre11">Get</kbd> method in the repository. Create a new test method to verify that a null Speaker entity is returned when a speaker with the given ID is not found<span>:</span></p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerNotFoundThenSpeakerNull()<br class="title-page-name"/>{<br class="title-page-name"/>  using (var context = new SpeakerMeetContext(_options))<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new Repository.Repository&lt;Speaker&gt;(context);<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var speaker = repository.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Null(speaker);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">This should pass right away. Now, create a test to verify that a Speaker entity is returned when a speaker with the supplied ID exists<span>:</span></p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerFoundThenSpeakerReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  using (var context = new SpeakerMeetContext(_options))<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repository = new Repository.Repository&lt;Speaker&gt;(context);<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var speaker = repository.Get(1);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(speaker);<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;Speaker&gt;(speaker);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">This test will not pass quite yet. Regardless of whether or not a Speaker with the ID of 1 exists in your development database, the speakers table in the <kbd class="calibre11">InMemory</kbd> database is currently empty. Adding data to the <kbd class="calibre11">InMemory</kbd> database is quite simple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding speakers to the InMemory database</h1>
                
            
            <article>
                
<p class="calibre2">In order to test that the repository will return specific Speaker entities when querying the database, you first must add Speakers to the database. In order to do this, add a few lines of code to your test file:</p>
<pre class="calibre19">using (var context = new SpeakerMeetContext(_options))<br class="title-page-name"/>{<br class="title-page-name"/>  context.Speakers.Add(new Speaker { Id = 1, Name = "Test"... });<br class="title-page-name"/>  context.SaveChanges();<br class="title-page-name"/>}</pre>
<p class="calibre2">Feel free to add as many speakers as you want, with as much detail as you feel necessary. Your test should now pass. More tests can be created, and should continue to be added as the system grows in functionality and complexity. The bulk of the logic should be tested already in the unit tests, but verifying that the system functions as a whole is equally important.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Verify that the service calls the DB through the repository</h1>
                
            
            <article>
                
<p class="calibre2">Moving on to the business layer, you should verify that each service can retrieve data from the <kbd class="calibre11">InMemory</kbd> database through the repository.</p>
<p class="calibre2">First, create a new folder in the integration test project called <kbd class="calibre11">ServiceTests.</kbd> Within that folder, create a folder named <kbd class="calibre11">SpeakerServiceTests</kbd>. This folder is where the tests specific to the <kbd class="calibre11">SpeakerService</kbd> will be created.</p>
<p class="calibre2">Create a new test file named <kbd class="calibre11">GetAll</kbd>. Add a test method to verify that the service can be created:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  var options = new DbContextOptionsBuilder&lt;SpeakerMeetContext&gt;()<br class="title-page-name"/>      .UseInMemoryDatabase("SpeakerMeetInMemory")<br class="title-page-name"/>      .Options;<br class="title-page-name"/><br class="title-page-name"/>  var context = new SpeakerMeetContext(options);<br class="title-page-name"/><br class="title-page-name"/>  var repository = new Repository&lt;Speaker&gt;(context);<br class="title-page-name"/>  var gravatarService = new GravatarService();<br class="title-page-name"/><br class="title-page-name"/>  var speakerService = new SpeakerService(repository, gravatarService);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ContextFixture</h1>
                
            
            <article>
                
<p class="calibre2">There's a lot of setup code here and quite a bit of duplication from our previous tests. Luckily, you can use what's known as a <em class="calibre12">Test Fixture</em>.</p>
<p class="calibre2">A Test Fixture is simply some code that is run to configure the system under test. For our purposes, create a <em class="calibre12">ContextFixture</em> to set up an <kbd class="calibre11">InMemory</kbd> database.</p>
<p class="calibre2">Create a new class named <kbd class="calibre11">ContextFixture</kbd>, which is where all the <kbd class="calibre11">InMemory</kbd> database creation will happen:</p>
<pre class="calibre19">public class ContextFixture : IDisposable<br class="title-page-name"/>{<br class="title-page-name"/>  public SpeakerMeetContext Context { get; }<br class="title-page-name"/><br class="title-page-name"/>  public ContextFixture()<br class="title-page-name"/>  {<br class="title-page-name"/>    var options = new DbContextOptionsBuilder&lt;SpeakerMeetContext&gt;()<br class="title-page-name"/>        .UseInMemoryDatabase("SpeakerMeetContext")<br class="title-page-name"/>        .Options;<br class="title-page-name"/><br class="title-page-name"/>    Context = new SpeakerMeetContext(options);<br class="title-page-name"/><br class="title-page-name"/>    if (!Context.Speakers.Any())<br class="title-page-name"/>    {<br class="title-page-name"/>      Context.Speakers.Add(new Speaker {Id = 1, Name = "Test"...});<br class="title-page-name"/>      Context.SaveChanges();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public void Dispose()<br class="title-page-name"/>  {<br class="title-page-name"/>    Context.Dispose();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, modify the test class to use the new <kbd class="calibre11">ContextFixture</kbd> class:</p>
<pre class="calibre19">[Collection("Service")]<br class="title-page-name"/>[Trait("Category", "Integration")]<br class="title-page-name"/>public class GetAll : IClassFixture&lt;ContextFixture&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly IRepository&lt;Speaker&gt; _repository;<br class="title-page-name"/>  private readonly IGravatarService _gravatarService;<br class="title-page-name"/><br class="title-page-name"/>  public GetAll(ContextFixture fixture)<br class="title-page-name"/>  {<br class="title-page-name"/>    _repository = new Repository&lt;Speaker&gt;(fixture.Context);<br class="title-page-name"/>    _gravatarService = new GravatarService();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var speakerService = new SpeakerService(_repository, _gravatarService);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"> </p>
<p class="calibre2">That's quite a bit cleaner. Now, create a new test to ensure a collection of <kbd class="calibre11">SpeakerSummary</kbd> objects is returned when the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> is called:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsCollectionOfSpeakerSummary()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerService = new SpeakerService(_repository, _gravatarService);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = speakerService.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, create a new test class for the <kbd class="calibre11">Get</kbd> method of the <kbd class="calibre11">SpeakerService</kbd>. The first test should validate that an exception is thrown when a speaker does not exist with the supplied ID:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerNotFoundThenSpeakerNotFoundException()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerService = new SpeakerService(_repository, _gravatarService);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var exception = Record.Exception(() =&gt; speakerService.Get(-1));<br class="title-page-name"/> <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;SpeakerNotFoundException&gt;(exception);<br class="title-page-name"/>}</pre>
<p class="calibre2">You can reuse the <kbd class="calibre11">ContextFixture</kbd> that you created earlier:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerFoundThenSpeakerDetailReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerService = new SpeakerService(_repository, _gravatarService);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker = speakerService.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speaker);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;SpeakerDetail&gt;(speaker);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Verify the API calls into the service</h1>
                
            
            <article>
                
<p class="calibre2">Now, turn your attention to the web API controllers. As covered in a previous chapter, you could simply create a new instance of the controller and call the method under test. However, that would not exercise the entire system.</p>
<p class="calibre2">It would be far better to call the method with an HTTP request. Deploying to a web server would be prohibitively time-consuming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TestServer</h1>
                
            
            <article>
                
<p class="calibre2">ASP.NET Core has the ability to configure a host for testing purposes. Install the <kbd class="calibre11">TestServer</kbd> from <kbd class="calibre11">NuGet</kbd>:</p>
<p class="calibre2"><kbd class="calibre11">Microsoft.AspNetCore.TestHost</kbd></p>
<p class="calibre2">There's a little setup involved. First, you’ll add an instance of the <kbd class="calibre11">TestServer</kbd>. Create a new <kbd class="calibre11">WebHostBuilder</kbd> and use the existing <kbd class="calibre11">Startup</kbd> class of the web API project. This will wire up the Dependency Injection container that was set up previously. Now, configure the services to set up a new <kbd class="calibre11">InMemory</kbd> database.</p>
<p class="calibre2">Take a look at the test here to see the setup required:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldCallGetSpeakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var server = new TestServer(new WebHostBuilder()<br class="title-page-name"/>      .UseStartup&lt;Startup&gt;()<br class="title-page-name"/>      .ConfigureServices(services =&gt;<br class="title-page-name"/>      {<br class="title-page-name"/>        services.AddDbContext&lt;SpeakerMeetContext&gt;(o =&gt;<br class="title-page-name"/>          o.UseInMemoryDatabase("SpeakerMeetInMemory"));<br class="title-page-name"/>      }));<br class="title-page-name"/><br class="title-page-name"/>  var client = server.CreateClient();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await client.GetAsync("/api/speaker");<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(response);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ServerFixture</h1>
                
            
            <article>
                
<p class="calibre2">In order to move the setup out of the controller tests, again use a test fixture. This time, create a new class named <kbd class="calibre11">ServerFixture</kbd>. This will be where the setup will live for the controller tests:</p>
<pre class="calibre19">public class ServerFixture : IDisposable<br class="title-page-name"/>{<br class="title-page-name"/>  public TestServer Server { get; }<br class="title-page-name"/>  public HttpClient Client { get; }<br class="title-page-name"/><br class="title-page-name"/>  public ServerFixture()<br class="title-page-name"/>  {<br class="title-page-name"/>    Server = new TestServer(new WebHostBuilder()<br class="title-page-name"/>             .UseStartup&lt;Startup&gt;()<br class="title-page-name"/>             .ConfigureServices(services =&gt;<br class="title-page-name"/>             {<br class="title-page-name"/>               services.AddDbContext&lt;SpeakerMeetContext&gt;(o =&gt;<br class="title-page-name"/>                 o.UseInMemoryDatabase("SpeakerMeetContext"));<br class="title-page-name"/>             }));<br class="title-page-name"/><br class="title-page-name"/>    if (Server.Host.Services.GetService(typeof(SpeakerMeetContext)) is SpeakerMeetContext context)<br class="title-page-name"/>    {<br class="title-page-name"/>      context.Speakers.Add(new Speaker {Id = 1, Name = "Test"...});<br class="title-page-name"/>      context.SaveChanges();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    Client = Server.CreateClient();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public void Dispose()<br class="title-page-name"/>  {</pre>
<pre class="calibre19">    Server.Dispose();<br class="title-page-name"/>    Client.Dispose();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, return to the previous test. Modify the test class to use the <kbd class="calibre11">ServerFixture</kbd>:</p>
<pre class="calibre19">[Collection("Controllers")]<br class="title-page-name"/>[Trait("Category", "Integration")]<br class="title-page-name"/>public class GetAll : IClassFixture&lt;ServerFixture&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly HttpClient _client;<br class="title-page-name"/><br class="title-page-name"/>  public GetAll(ServerFixture fixture)<br class="title-page-name"/>  {<br class="title-page-name"/>    _client = fixture.Client;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public async void ItShouldCallGetSpeakers()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var response = await _client.GetAsync("/api/speaker");<br class="title-page-name"/><br class="title-page-name"/>    Assert.NotNull(response);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, verify that the response returns an <kbd class="calibre11">OK</kbd> status code by creating a new test:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldReturnSuccess()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker/");<br class="title-page-name"/>  response.EnsureSuccessStatusCode();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(HttpStatusCode.OK, response.StatusCode);<br class="title-page-name"/>}</pre>
<p class="calibre2">And finally, ensure that the proper speaker is returned:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldReturnSpeakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker");<br class="title-page-name"/>  response.EnsureSuccessStatusCode();<br class="title-page-name"/><br class="title-page-name"/>  var responseString = await response.Content.ReadAsStringAsync();<br class="title-page-name"/>  var speakers = JsonConvert.DeserializeObject&lt;List&lt;SpeakerSummary&gt;&gt;(responseString);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, speakers[0].Id);<br class="title-page-name"/>}</pre>
<p class="calibre2">Remember, you want to make sure your test suite is clean and well maintained. To clean this test up a bit, you might want to consider creating a <kbd class="calibre11">ReadAsJsonAsync</kbd> extension. Here's what that might look like:</p>
<pre class="calibre19">public static class Extensions<br class="title-page-name"/>{<br class="title-page-name"/>  public static async Task&lt;T&gt; ReadAsJsonAsync&lt;T&gt;(this HttpContent content)<br class="title-page-name"/>  {<br class="title-page-name"/>    var json = await content.ReadAsStringAsync();<br class="title-page-name"/><br class="title-page-name"/>    return JsonConvert.DeserializeObject&lt;T&gt;(json);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">And now, modify the test to use the new extension method:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldReturnSpeakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker");<br class="title-page-name"/>  response.EnsureSuccessStatusCode();<br class="title-page-name"/><br class="title-page-name"/>  var speakers = await response.Content.ReadAsJsonAsync&lt;List&lt;SpeakerSummary&gt;&gt;();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, speakers[0].Id);<br class="title-page-name"/>}</pre>
<p class="calibre2">That's much better. Now this extension can be used and reused over and over, and its first use has now been documented in the <kbd class="calibre11">ItShouldReturnSpeakers</kbd> test.</p>
<p class="calibre2">Now, move on to testing that the single speaker endpoint can be called. Create a test named <kbd class="calibre11">ItShouldCallGetSpeaker</kbd> and ensure that a response is returned:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldCallGetSpeaker()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker/-1");<br class="title-page-name"/><br class="title-page-name"/>  Assert.NotNull(response);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, test that the proper response code is returned if a Speaker with the given ID does not exist:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldReturnError()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker/-1");<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now validate that an <kbd class="calibre11">OK</kbd> status code is returned when a speaker with the supplied ID exists:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldReturnSuccess()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker/1");<br class="title-page-name"/>  response.EnsureSuccessStatusCode();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(HttpStatusCode.OK, response.StatusCode);<br class="title-page-name"/>}</pre>
<p class="calibre2">And finally, confirm that the speaker returned is the one that is expected. Note that the <kbd class="calibre11">ReadAsJsonAsync</kbd> can be used here:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public async void ItShouldReturnSpeaker()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var response = await _client.GetAsync("/api/speaker/1");<br class="title-page-name"/>  response.EnsureSuccessStatusCode();<br class="title-page-name"/><br class="title-page-name"/>  var speakerSummary = await response.Content.ReadAsJsonAsync&lt;SpeakerDetail&gt;();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, speakerSummary.Id);<br class="title-page-name"/>}</pre>
<p class="calibre2">Only the <kbd class="calibre11">Get</kbd> and <kbd class="calibre11">GetAll</kbd> methods for speakers have been tested in the preceding pages. Feel free to add tests for the <kbd class="calibre11">Search</kbd> methods to grow your integration test suite.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">You should now have a firm grasp of integration testing, its benefits, and detriments. The mock API calls have been removed and the real API service has been implemented. Integration tests have been created and now ensure separate parts of the application are working well together.</p>
<p class="calibre2"><span>Change is inevitable, especially in software development. </span>In the next chapter, we'll be discussing how to handle a change in requirements. Whether these changes include new features, resolve defects, or change existing logic, through TDD these can be easily managed.</p>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>