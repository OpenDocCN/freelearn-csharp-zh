- en: '22'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Case Study Extension: Developing .NET Microservices for Kubernetes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we bridge the insights from *Chapter 21, Case Study*, where
    we explored the practical implementation of .NET microservices, with the foundational
    knowledge of Kubernetes presented in *Chapter 20, Kubernetes*. Our focus here
    is on preparing .NET code for seamless integration with Kubernetes, encompassing
    the complete development cycle—from coding to debugging, and even troubleshooting
    post-deployment challenges.
  prefs: []
  type: TYPE_NORMAL
- en: We will guide you through the process of setting up a development workstation
    optimized for Kubernetes, learn the intricacies of packaging code with Docker,
    and understand how to organize your codebase for flawless execution across varied
    environments, such as Docker Desktop, local minikube installations, and production
    or staging Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this chapter delves into the nuances of remote debugging, providing you
    with the necessary skills to efficiently troubleshoot and debug your application.
    Here, you will learn how to prepare each developer workstation, how to package
    the code with Docker, and how to organize the code so that it can immediately
    run both on the developer Docker Desktop, on the developer’s local Minikube installation,
    and on the production/staging Kubernetes clusters, without modifications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have mastered remote debugging techniques
    for applications in production or staging environments, enabling swift issue resolution
    and system reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The tools needed for .NET Kubernetes development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your application in Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote debugging of a Kubernetes application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All concepts will be explained with the help of a previous example taken from
    *Chapter 21*, *Case Study*, which we will adapt for Kubernetes execution.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll adapt the `GrpcMicroService` microservice from *Chapter 21*, *Case Study*,
    seeing firsthand how a real-world application transitions to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: To fully leverage this chapter, fortify your understanding of Docker and Kubernetes
    as laid out in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise
    Application*, and *Chapter 20*, *Kubernetes*, which form the foundation for the
    advanced practices discussed herein.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2022 free Community Edition or better, with
    all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WSL** (**Windows Subsystem for Linux**) and *Docker Desktop for Windows*.
    Detailed instructions on how to install both of them are given in the *Technical
    requirements* section of *Chapter 11, Applying a Microservice Architecture to
    Your Enterprise Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Minikube installation that specifies Docker as a virtualization tool. Minikube
    installation is described in the *Using Minikube* section of *Chapter 20*, *Kubernetes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SQL Server database that allows TCP/IP connections. You can’t use *SQL Server
    Express LocalDB*, which comes with Visual Studio installation, since it doesn’t
    allow TCP/IP connections. So you need either a full SQL Express installation or
    an Azure SQL Server database. More details on how to fulfill this requirement
    will be given in the *Tools needed for .NET Kubernetes development* section of
    this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the code of this chapter can be found in the GitHub repository associated
    with this book: [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).'
  prefs: []
  type: TYPE_NORMAL
- en: The Tools needed for .NET Kubernetes development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each single microservice can be unit-tested and debugged independently from
    the remainder of its application, with the technique you learned *Chapter 9*,
    *Testing Your Enterprise Application*. You don’t need to package it inside a Docker
    image to do this.
  prefs: []
  type: TYPE_NORMAL
- en: However, debugging and performing integration tests on the whole application
    or parts of it requires that all involved microservices interact and are packaged
    as in the final application.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a staging environment to beta-test your application. Prior to staging
    deployment, ensure your application’s stability in the development environment
    to prevent time-consuming troubleshooting, because the staging environment doesn’t
    have all the facilities that are available in a development environment. Otherwise,
    troubleshooting all frequent bugs and crashes discovered in the staging environment
    might imply an unacceptable time cost.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is preferable to reach good application stability before deploying
    the application in a staging environment. Moreover, for easier and more efficient
    debug-fix cycles, it is desirable that all microservices run on each single developer
    machine. That’s why each developer workstation must be equipped with both Docker
    and Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the developer machine must be able to simulate all communications
    between microservices and between services and other storage media, like databases.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that, Minikube can run and simulate all communications that occur
    in an actual Kubernetes cluster, including when it runs on a single development
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: We can also let all involved Docker images communicate among them before loading
    them on Minikube because Docker Desktop allows the creation of virtual networks
    that are accessible by the local Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, both Docker and Minikube virtual networks automatically include the
    development machine that hosts them, so we can place storage services like disk
    volumes and databases on the development machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.1: Minikube and Docker network structure'
  prefs: []
  type: TYPE_NORMAL
- en: However, the sophisticated virtual network facilities of both Docker and Kubernetes
    are not enough to ensure an efficient development and debugging environment, and
    further tools are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below are all the issues we need to fix to configure an efficacious development-debugging
    environment and how to solve them:'
  prefs: []
  type: TYPE_NORMAL
- en: As a default, Visual Studio installs *SQL Server Express LocalDB* instead of
    *SQL Server Express*, and SQL Server Express LocalDB is not able to communicate
    via actual or virtual networks. Therefore, we need either an SQL Server Express
    installation or an external database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Kubernetes nodes have just virtual addresses that are handled by the Kubernetes
    engine itself, a Visual Studio debugger can be attached to a running microservice
    just through the REST API of the Kubernetes engine. At the time of writing, the
    best tool available for Visual Studio is *Bridge to Kubernetes,* which, in turn,
    uses *kubectl* to interact with the API of any Kubernetes cluster, Minikube included.
    Unluckily, we can’t use the Kubectl installation that runs on the virtual machine
    that hosts Minikube as we did in *Chapter 20*, *Kubernetes*, but we need an installation
    that runs directly in the development machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We describe how to install and configure all tools mentioned in the above points
    in two dedicated subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring SQL Server Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have access to an SQL Server instance running in your development machine,
    you can use that one. Otherwise, you can choose between creating an SQL Server
    database in Azure following the instructions containedin *Chapter 12*, *Choosing
    Your Data Storage in the Cloud*, or installing a local instance of SQL Server
    Express:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by downloading the SQL Server installer from [https://www.microsoft.com/en-US/download/details.aspx?id=104781](https://www.microsoft.com/en-US/download/details.aspx?id=104781).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can freely choose between SQL Server Express and SQL Server Express Advanced,
    but please select a complete installation that includes both **SQL Server Management
    Studio** and the **SQL Server Management console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select to install SQL Server as the default instance on your machine (the default
    in the installation procedure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately after the installation, you must run SQL Server Management Console
    (just write this name in the Windows search box) to enable TCP/IP-based connections.
    In order to configure SQL Server properly, follow all the steps below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once in the SQL Server Management Console, expand the **SQL Server Network Configuration**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Protocols for <your instance name>**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right detail pane, you should see all the available communication protocols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **TCP**/**IP** and select **Enable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, TCP/IP is enabled but on a dynamic port. In order to impose a fixed port,
    right-click on the same TCP/IP node and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_22_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.2: Forcing a static IP address'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **IP Addresses** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see several IP addresses. These are all IP addresses that are associated
    with your computer, and each of them executes the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the **0** that is in **TCP Dynamic Port** and keep this field empty,
    and then write `1433` in the **TCP Port** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once finished, click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you need to restart the SQL Server service. Select **SQL Server Services**
    in the left pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the right detail pane, right-click on **SQL Server <your instance
    name>** and select **Restart**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, the SQL Server only has Windows authentication enabled. In order
    to use the instance on a non-Windows network, you must enable username-based authentication
    and define at least one administrative user. This is a necessary step because
    Windows authentication will not work on Docker networks and Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can do this in SQL Server Management Studio. Once SQL Server Management
    Studio opens, it prompts you for an instance to connect with and for authentication
    information. The instance name of the database you just installed should be something
    like `<computer name>\SQLEXPRESS`; select it and also select **Windows Authentication**,
    as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_22_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.3: Connecting with SQL Server Management Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once connected with the database, you can enable username-based authentication
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your server icon in Object Explorer and choose **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, select **Security** in the left pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **SQL Server and Windows Authentication mode**, as shown in the screenshot
    below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_22_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.4: Enabling SQL Server authentication'
  prefs: []
  type: TYPE_NORMAL
- en: In order to make your changes effective, you must restart SQL Server. You can
    do it by right-clicking on your server icon in Object Explorer and by selecting
    **Restart**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to define at least one user by following the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `Security` folder under your server icon in Object Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Logins** folder and select **New Login**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, insert a username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **SQL Server authentication**, insert a password, and confirm it by
    retyping the same password in the **Confirm password** field, as shown in the
    screenshot below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_22_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.5: Defining user name and password'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, right-click on **Server Roles** and enable the **sysadmin** role to
    give all rights to the new user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there you have it! Now, your SQL Server instance can be used by both Docker
    and Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how to configure Visual Studio for debugging applications
    running on Minikube or any other Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Kubernetes application debugging with Bridge to Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since microservices running on Kubernetes have no fixed IP address and ports
    attached to them, only virtual addresses that are solved at runtime by Kubernetes,
    we can’t attach the Visual Studio debugger directly to any running microservice.
    That’s why we need software like Bridge to Kubernetes, which interacts with the
    Kubernetes API to enable debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge to Kubernetes is a Visual Studio extension that’s easy to install, but
    it requires Kubectl to be installed on your development machine, which presents
    a challenge, as there is no direct Windows installer for Kubectl. In this subsection,
    we’ll guide you through the process of installing both Bridge to Kubernetes and
    Kubectl, overcoming the lack of a direct Windows installer for the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge to Kubernetes enables Kubernetes application debugging by interacting
    with the Kubernetes API via Kubectl. However, it is not a debugger driver or a
    debugger extension. It does a completely different job; it asks you to select
    a service running in a Kubernetes cluster and reroute all communication with this
    service to a locally running Visual Studio POD replica instead of the actual cluster
    POD.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.6: How Bridge to Kubernetes works'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the developer debugs a local copy of the POD code but in exactly
    the same dynamic Kubernetes environment as the original POD. This way, you have
    all the facilities offered by a usual local debugging session, but while you are
    debugging it, your code interacts with the actual Kubernetes cluster you need
    to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge to Kubernetes doesn’t work just with Minikube; it works with any Kubernetes
    cluster. Thus, you can use it for debugging the whole application on your development
    machine, and also for debugging the staging application or the production application.
  prefs: []
  type: TYPE_NORMAL
- en: Since you debug just the local code and not the deployed code, you are not forced
    to compile an application in debug mode in order to debug it. You can deploy the
    application with all compilation optimizations you want without caring about possible
    debugging needs; it is enough to have local copies of the PODs you would like
    to debug compiled in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to use Bridge to Kubernetes in practice in the *Remote debugging
    of a Kubernetes application* section. The remainder of this section will explain
    all the steps needed to install Bridge to Kubernetes on a development machine.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you need to install Kubectl. The simplest way to do it is by using
    the Chocolatey package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Chocolatey is a package manager like NuGet. Similarly, it consists of a public
    repository containing all packages and a client you must install on your machine,
    in order to interact with the public repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t have Chocolatey already installed, you can install it from a PowerShell
    prompt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Search **PowerShell** in the Windows search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the PowerShell link and select to execute it as an administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, execute the PowerShell command suggested on the official Chocolatey
    page: [https://chocolatey.org/install#individual](https://chocolatey.org/install#individual).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The PowerShell command to execute is repeated below for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once installation is complete, run `choco -?` to verify that the installation
    was successful and that the Chocolatey user interface works properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Chocolatey installed, installing Kubectl is super easy; just open a Windows
    Command Prompt as an administrator and type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can check whether everything works properly by typing `kubectl version –client`.
  prefs: []
  type: TYPE_NORMAL
- en: Kubectl should be configured to access a specific cluster, but when you start
    Minikube with `minikube start`, Minikube automatically configures it to access
    the local Minikube cluster, so you don’t need to worry about Kubectl configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are ready to install Bridge to Kubernetes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and select **Extensions -> Manage Extensions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search `Bridge to Kubernetes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select it and install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there you have it! Now, your development machine is ready for .NET Kubernetes
    development. The next section details the development process and explains how
    to modify an existing project to run with both the local Docker installation and
    any Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Visual Studio and other IDEs offer good support for Docker and a good
    integration with Docker Desktop, the best option for most of the development time
    is working with just Dockerized images without running them inside of Minicube.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, as we will see shortly, once we have added Docker support to our projects,
    it is enough to click the Run Visual Studio button to start all our Dockerized
    microservices and to enable them to communicate through a Docker network. Conversely,
    running our application in Minikube requires several manual steps, and it takes
    some time to load the Docker images on Minikube and to create all the necessary
    Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this in Visual Studio is super easy. It is enough to add Docker support
    for all microservice projects in your solution and to select the option of launching
    several projects simultaneously when the solution is run. Then, Visual Studio
    will automatically perform all the necessary tasks when your solution is run,
    namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile and link all code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build all microservice Docker images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the Docker images into the Docker Desktop local repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch all Docker images simultaneously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the debugger to all launched Docker images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You just need to take care of microservice communication by defining a virtual
    network with Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: We will explain all the details of the development process with a simple example
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC worker microservices revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the code associated with *Chapter 14*, *Implementing Microservices with .NET*,
    and described in *Chapter 21*, *Case study,* there is a solution called `GrpcMicroService`.
    The solution is composed of two microservices. The first microservice simulates
    purchases by generating random data, while the second one uses this data to compute
    statistics that it stores in a database. The whole code is available in the `ch15->GrpcMicroService`
    folder of the GitHub repository associated with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a copy of the whole `GrpcMicroService` folder and call it `GrpcMicroServiceDocker`.
  prefs: []
  type: TYPE_NORMAL
- en: The steps below describe all the modifications that need to be made to Docker
    to enable all microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker support to GrpcMicroServiceDocker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the `GrpcMicroServiceDocker` solution in Visual Studio. The solution contains
    two microservices, called `FakeSource` and `GrpcMicroservice`. The last project
    is just the data layer of the `GrpcMicroservice` project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.7: GrpcMicroServiceDocker solution'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is already configured to launch the two microservices when it is
    run. In other cases, you might need to configure multiple project launches by
    right-clicking on the solution node and selecting **Set Startup Projects….**
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker support to both microservices is super easy. Right-click on each
    microservice project within Visual Studio. Navigate to **Add**, and then select
    **Docker Support**. If prompted, choose the operating system for your Docker environment.
    If you are using Minikube, you must select **Linux**.
  prefs: []
  type: TYPE_NORMAL
- en: All the necessary Docker files are automatically created and configured by Visual
    Studio. And that’s it!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to move the database to the newly installed SQL Server instance.
  prefs: []
  type: TYPE_NORMAL
- en: Moving GrpcMicroServiceDocker to SQL Server Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to change all connection strings and configure the string that will
    be used at runtime so that it can be used from inside a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s change the connection string that is inside `GrpcMicroServiceStore->
    LibraryDesignTimeDbContextFactory.cs`. The new string should be something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'where the instance name should be `SQLEXPRESS`. You can take the above connection
    string directly from Visual Studio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **SQL Server Object Explorer** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **SQL Server** node and select **Add SQL Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, Visual Studio should enumerate all available SQL Server
    instances. Choose the newly installed SQL Server instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Windows authentication** and connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new server icon should appear below the **SQL Server** node. Select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Visual Studio Properties** tab, you should see all database connection
    properties. Take the value of **General-> Connection string**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have to run all migrations to recreate the database in the new SQL
    Server instance. As usual, right-click on the library project and define it as
    a startup project. Then, in the Visual Studio Package Manager Console **Default
    Project**, select `GrpcMicroServiceStore` and issue the `Update-Database` command.
  prefs: []
  type: TYPE_NORMAL
- en: After the new database has been created, restore the two microservices as simultaneous
    startup projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the runtime connection string in `GrpcMicroService -> appsettings.json`.
    If the newly installed SQL Server instance has been defined as the default instance
    on your machine, the connection string below should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: where `host. Docker.internal` is the URL used by Docker Desktop images to communicate
    with the host machine. If your SQL Server is not the machine’s default instance,
    you must replace `host.docker.internal` with `host.docker.internal\<your instance
    name>`.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, you are using an external database, you can use its standard connection
    string with no modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling communication among microservices with a Docker virtual network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a Docker virtual network in Docker Desktop is easy; just open a Windows
    console and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'where `test-net` is the virtual network name. Once the network has been defined
    when we create a container instance from an image, we can specify that the launched
    container must be connected to our network and its hostname, with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `rm` option specifies that the container must be destroyed when it
    stops running, `--net test-net` specifies the network where to connect the created
    container, and -`-name grpcmicroservice` is the name of the created container
    that will also act as its hostname in the network.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add to our `test-net` just the containers that must act as servers—in
    our case, the `GrpcMicroService` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Visual Studio automatically issues all necessary `run` Docker commands
    when the solution is launched, we need just to specify the command options to
    add to Visual Studio’s original command. They must be specified in each microservice
    project file with the `DockerfileRunArguments` parameter. Below is how to modify
    the `GrpcMicroService` microservice project file, which is the only microservice
    acting as a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: No modification is required to the `FakeSource` project, since it must not act
    as a server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `grpcmicroservice` hostname must be used by `FakeSource` to communicate
    with the `GrpcMicroService` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we must replace the URL in the `FakeSource->Worker.cs` file with
    `http://grpcmicroservice:8080`, as shown in the code snippet below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'where we use the `8080` default Kestrel `http` port to communicate with the
    microservice. Therefore, we need to the Kestrel options in `GrpcMicroService ->Program.cs`
    that force Kestrel to listen to the `5000` port by replacing the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to run our project. To be sure that both microservices are
    started with Docker, please select each of them as a single startup project, and
    then select **Docker** in the select box next to the run solution Visual Studio
    button, as shown in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.8: Selecting Docker execution'
  prefs: []
  type: TYPE_NORMAL
- en: After that, you can restore the simultaneous launch of both microservices. Visual
    Studio will launch both of them with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can launch the solution. In order to verify that the server is properly
    receiving purchase information, place a breakpoint in the `GrpcMicroService->HostedServices->
    ProcessPurchases.cs` file inside of the `if` block below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `GrpcMicroService` enters that block only if it finds something in
    the input queue.
  prefs: []
  type: TYPE_NORMAL
- en: You can also inspect the content of the `dbo.Purchases` database table to verify
    that it is filled with statistics on purchases. You can do it from within **SQL
    Server Object Explorer** by right-clicking on the table and choosing **View Data**.
  prefs: []
  type: TYPE_NORMAL
- en: Having understood how to test our application with a Docker network, we must
    now understand when and how to test it with Minikube also.
  prefs: []
  type: TYPE_NORMAL
- en: When to test the application with Minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the debug-fix cycle involved in the application development can be done
    with the Docker virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networks usually work well without creating issues. So, if you experience
    communication problems, they are probably due to misspelled service URLs. Therefore,
    please double-check the URLs in all calls to the microservice that does not receive
    communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'From time to time, we need to test an application with Minikube for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Both ReplicaSets and StatefulSets can be tested with Docker and Visual Studio,
    but we are limited to a single POD for each of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must also test the `.yaml` Kubernetes configuration file, which might contain
    more complex objects like ingresses, permanent storage, secrets, and other complex
    configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might need to integrate your microservices with other modules developed
    by other teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, each developer should spend most of their time testing a few microservices
    that strongly interact among them with the Docker virtual network, but from time
    to time, they should try a wider integration with Minikube. This can be done before
    committing their code at the end of the working day, or just before closing a
    development iteration of the agile application development process.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned when and how to test the application with Minikube, we must learn
    how to load and run our application on Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Running your application in Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Visual Studio runs your microservices with Docker, it creates special images
    that also contain information needed by the Visual Studio debugger and have a
    `dev` version name. These special images can be run just from Visual Studio, and
    if you try to launch them manually, you will get an error. For the same reason,
    you can’t use them in Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first step for running your microservice in Minikube is to create
    different “standard” images. You can do this by right-clicking both the `FakeSource`
    and `GrpcMicroService` Docker files in Visual Studio Solution Explorer and by
    selecting **Build Docker Image**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, you will create a `grpcmicroservice` and a `fakesource` image, both
    with the `latest` version name, as shown in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.9: Creating Minikube-ready Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, you must start Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you must load your Docker images inside of the Minikube images cache with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that your images have been correctly loaded by listing all the
    images loaded in Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to define a .`yaml` Kubernetes configuration file with two deployments
    and a service that forwards communications to `grpcmicroservice`, which is the
    only microservice acting as a server. Let’s call it `minikubedeploy.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `grpcmicroservice` deployment is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code above requires just one replica, but you can experiment with two or
    three replicas. The `ASPNETCORE_HTTP_PORTS` environment variable is a standard
    ASP.NET setting that informs Kestrel on the HTTP port where to listen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `imagePullPolicy: Never` setting specifies the image caching policy within
    the Kubernetes cluster. It prevents Minikube from trying to download a fresher
    version of the image from the original source into its cache. We need this setting,
    since there is no “original source” containing our image because we uploaded the
    image directly to the Minikube cache with the `minikube image load` command.'
  prefs: []
  type: TYPE_NORMAL
- en: You must always specify this setting when images are not available in a shared
    image repository but are uploaded directly to the Minikube cache from the Docker
    Desktop local repository. Shared images, instead, do not need to be uploaded manually
    in the Minikube cache but can be simply referenced with their full URL in the
    Kubernetes `.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: All other settings are quite standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `fakesource` deployment is completely analogous but doesn’t
    contain information about the container ports, since this microservice doesn’t
    act as a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the service that forwards communications to `grpcmicroservice`
    is quite standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You must pay attention only to the port numbers that must be coherent in all
    settings and to the service name, since they will be used in the URLs of all communication
    to the `grpcmicroservice`.
  prefs: []
  type: TYPE_NORMAL
- en: If the service names match the hostnames in the Docker virtual network, the
    URLs will work both in Kubernetes and the Docker virtual network. So, you don’t
    need to modify any code or configuration to adapt the code that runs in the Docker
    virtual network to Minikube or any other Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The whole `minkubedeploy.yaml` file is available in the `ch22` folder of the
    GitHub repository associated with the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open a Windows prompt in the folder that contains the `minkubedeploy.yaml`
    file, issuing the command below that will load the application configuration in
    the Minikube cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then, issue the `kubectl get deployment` command to verify that all deployments
    have been correctly defined and are running.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify that the application is properly running by inspecting the data
    in the `dbo.Purchases` database table, by right-clicking on the `dbo.Purchases`
    table in **SQL Server Object Explorer**and choosing **View Data**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.10: dbo.Purchases table'
  prefs: []
  type: TYPE_NORMAL
- en: Each time you click the table refresh button, you should see new rows added
    to the database table. If new rows do not appear after several refreshes, your
    microservice is probably experiencing some communication problem, or some exception
    was thrown before data was computed.
  prefs: []
  type: TYPE_NORMAL
- en: You can discover what the problem is just by debugging the application. The
    next section explains how to verify in detail what is happening in the application,
    with the help of Bridge to Kubernetes. Please do not delete all Kubernetes objects
    created with `minkubedeploy.yaml` because we need the running application to attach
    Bridge to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Remote debugging a Kubernetes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a final step, we will debug `GrpcMicroService` with Bridge to Kubernetes.
    Let’s set `GrpcMicroService` as a starting project and change the project start
    from **Docker** to **Bridge** **to Kubernetes**, as shown in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.11: Debugging GrpcMicroService with Bridge to Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s place a breakpoint in the `GrpcMicroService->HostedServices-> ProcessPurchases.cs`
    file inside of the `if` block, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start debugging. As soon as you click the **run** button, a window appears
    that prompts you to configure Bridge to Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_22_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.12: Configuring Bridge to Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: If the window above doesn’t open, or you can’t see any Minikube node, `Kubectl`
    is probably not working or configured for Minikube. Try issuing a `Kubectl` command
    like `kubectl get all`. If you face any issues, try stopping and restarting Minikube
    with `minikube stop`, followed by `minikube start`.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge to Kubernetes prompts us to select a namespace—in our case, `default`—and
    then choose a specific service within that namespace—in our case, `grpmicroservice`.
    All communications to that service will be forwarded to the `GrpcMicroService`
    code running on our development machine. Let’s set up the configuration window,
    as shown in the screenshot above. As soon as you submit your Bridge to Kubernetes
    configuration, debugging will automatically start. In a short time, the breakpoint
    will be hit, and our local copy of the microservice will start interacting with
    the remainder of the code that is running in Minikube!
  prefs: []
  type: TYPE_NORMAL
- en: After you finish debugging, please restore the project start to **Docker**,
    and restore the simultaneous start of both microservices so that you can continue
    working with the Docker virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having finished working with Minikube, you need to remove all objects
    created by `minkubedeploy.yaml` with the command below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is important to free up resources as soon as you don’t need them anymore;
    otherwise, they will continue wasting CPU time and memory, and if you constantly
    add more and more applications, sooner or later, you will experience performance
    problems on your development machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to free up Minikube disk space, you can also remove the microservices
    images previously loaded in the Minikube cache with the commands below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to stop Minikube with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how to prepare a developer workstation for .NET
    Kubernetes development and how to organize code testing and bug-fix cycles.
  prefs: []
  type: TYPE_NORMAL
- en: We also explained how to define a Docker virtual network to ensure microservices
    communication during development and name conventions for hostnames and Kubernetes
    services, enabling the same code to run both on the Docker virtual network, Minikube,
    and any other Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explained all the steps needed to run an application in Minikube
    and how to test it with Bridge to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached the end of our journey through this book, and what a journey
    it has been!
  prefs: []
  type: TYPE_NORMAL
- en: Packed with numerous new and challenging ideas, this book is sure to be your
    good friend on your journey as a software architect.
  prefs: []
  type: TYPE_NORMAL
- en: These learnings will not only empower you to craft innovative solutions but
    also support your growth in the dynamic world of software projects. We sincerely
    hope you’ve enjoyed the adventure as much as we have creating this latest edition
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why can’t the SQL Server installation that comes with Visual Studio be used
    for Kubernetes development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Bridge to Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that Bridge to Kubernetes works just with Minikube?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you load the Minikube images cache?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we define Minikube as the Kubectl default cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the references in this chapter are the same as those previously listed
    in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    and *Chapter 14*, *Implementing Microservices with .NET*. Here, it is worth adding
    the link to the official documentation about Bridge to Kubernetes: [https://learn.microsoft.com/en-us/visualstudio/bridge/](https://learn.microsoft.com/en-us/visualstudio/bridge/    )'
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
