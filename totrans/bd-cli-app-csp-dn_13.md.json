["```cs\ndotnet list package --vulnerable\n```", "```cs\ndotnet list package --outdated\n```", "```cs\nbookmarkr sync --pat YOUR_PAT\n```", "```cs\napp.MapPost(\"/sync\", async ([FromHeader(Name = \"X-PAT\")] string pat, List<Bookmark> bookmarks, ITokenValidator tokenValidator, HttpContext context) =>\n{\n     …\n}\n```", "```cs\n// Ensure the Personal Access Token (PAT) is valid\nif (!tokenValidator.IsValid(pat))\n{\n    context!.Response.Headers[\"X-Invalid-PAT\"] = pat;\n    return Results.Unauthorized();\n}\n// Ensure the Personal Access Token (PAT) is not expired\nif (tokenValidator.IsExpired(pat))\n{\n    context!.Response.Headers[\"X-Expired-PAT\"] = pat;\n    return Results.Unauthorized();\n}\n```", "```cs\nbuilder.Services.AddScoped<ITokenValidator, TokenValidator>();\n```", "```cs\npublic class TokenValidator : ITokenValidator\n{\n    private readonly List<PatToken> _tokens = new();\n    public TokenValidator()\n    {\n        // we are simulating a token store here...\n        _tokens.Add(new PatToken { Value = \"4de3b2b9-afaf-406c-ab0d-\n        d59ac534411d\", IsExpired = false });\n        _tokens.Add(new PatToken { Value = \"16652977-c654-431e-8f84-\n        bd53b4ccd47d\", IsExpired = true });\n    }\n    public bool IsExpired(string token)\n    {\n        var retrievedToken = _tokens.FirstOrDefault(t => t.Value.\n        Equals(token, StringComparison.OrdinalIgnoreCase));\n        if(retrievedToken == null) return false;\n        return retrievedToken.IsExpired;\n    }\n    public bool IsValid(string token)\n    {\n        var retrievedToken = _tokens.FirstOrDefault(t => t.Value.\n        Equals(token, StringComparison.OrdinalIgnoreCase));\n        return retrievedToken != null;\n    }\n}\n```", "```cs\nprivate Option<string> patOption = new Option<string>(\n    [\"--pat\", \"-p\"],\n    \"The PAT used to authenticate to BookmarkrSyncr\"\n);\n```", "```cs\nAddOption(patOption);\n```", "```cs\nprivate async Task OnSyncCommand(string patValue)\n{\n    ...\n}\n```", "```cs\nthis.SetHandler(OnSyncCommand, patOption);\n```", "```cs\nvar mergedBookmarks = await _serviceAgent.Sync(patValue, retrievedBookmarks);\n```", "```cs\npublic async Task<List<Bookmark>> Sync(string pat, List<Bookmark> localBookmarks)\n```", "```cs\n// ensure that the pat is present\nif(string.IsNullOrWhiteSpace(pat))\n{\n    string? value = Environment.GetEnvironmentVariable(\"BOOKMARKR_\n    PAT\");\n    if(value == null) throw new PatNotFoundException(pat);\n    pat = value;\n}\n```", "```cs\nvar client = _clientFactory.CreateClient(\"bookmarkrSyncr\");\n// Add the PAT to the request header\nclient.DefaultRequestHeaders.Add(\"X-PAT\", pat);\nvar response = await client.PostAsync(\"sync\", content);\n```", "```cs\nif (response.IsSuccessStatusCode)\n{\n    // saving the PAT to the environment variable, if not already\n    string? value = Environment.GetEnvironmentVariable(\"BOOKMARKR_\n    PAT\");\n    if(value == null || !value.Equals(pat)) Environment.\n    SetEnvironmentVariable(\"BOOKMARKR_PAT\", pat);\n    // remaining of the code\n}\n```", "```cs\nswitch(response.StatusCode)\n{\n    case HttpStatusCode.Unauthorized:\n        if (response.Headers.TryGetValues(\"X-Invalid-PAT\", out var \n        headerValues))\n            throw new PatInvalidException(pat);\n        if (response.Headers.TryGetValues(\"X-Expired-PAT\", out var \n        headerValues2))\n            throw new PatExpiredException(pat);\n        throw new HttpRequestException($\"Unauthorized access: \n        {response.StatusCode}\");\n    // remaining of the code\n}\n```", "```cs\ncatch(PatNotFoundException ex)\n{\n    Helper.ShowErrorMessage([$\"The provided PAT value ({ex.Pat}) was \n    not found.\"]);\n}\ncatch(PatInvalidException ex)\n{\n    Helper.ShowErrorMessage([$\"The provided PAT value ({ex.Pat}) is \n    invalid.\"]);\n}\ncatch(PatExpiredException ex)\n{\n    Helper.ShowErrorMessage([$\"The provided PAT value ({ex.Pat}) is \n    expired.\"]);\n}\n```"]