- en: Chapter 8. Xamarin.Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. Xamarin.Forms
- en: 'Xamarin.Forms is an extension module to Xamarin compiler technologies; an abstraction
    layer on top of the native UI components on target platforms. This chapter will
    focus on the various features and extensibility options of Xamarin.Forms that
    help developers create cross-platform application user interfaces that can then
    be compiled into Xamarin projects, increasing the code-sharing quality markers,
    and making cross-platform application development projects more manageable and
    unified. This chapter is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms是Xamarin编译器技术的扩展模块；在目标平台原生UI组件之上的抽象层。本章将重点介绍Xamarin.Forms的各种功能和扩展选项，这些功能和选项帮助开发者创建可以编译成Xamarin项目的跨平台应用程序用户界面，从而提高代码共享的质量标准，并使跨平台应用程序开发项目更加易于管理和统一。本章分为以下几部分：
- en: Under the hood
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部机制
- en: Components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Extending forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展表单
- en: Patterns and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Under the hood
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部机制
- en: As previously mentioned, Xamarin, being a cross-platform development framework,
    provides developers the toolset to create applications that depend on and use
    the same code base. The shared amount of code is directly proportional to the
    manageability in these types of implementation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Xamarin作为一个跨平台开发框架，为开发者提供了创建依赖于并使用相同代码库的应用程序的工具集。在这些类型的实现中，共享的代码量与可管理性成正比。
- en: Xamarin.Forms adds an abstraction layer on top of the mono runtime on Android
    and the pre-compiler .NET stack on iOS platforms. This abstraction layer's sole
    responsibility is to provide the Xamarin compilers with the necessary instructions
    to normalize the code or markup for GUI elements to render native controls in
    Xamarin apps. Since the platform language for Xamarin is C#, **Extensible Application
    Markup Language** (**XAML**) is the design markup language of choice. Xamarin.Forms
    provides the same abstraction as a runtime library for Windows Store applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android和iOS平台上，Xamarin.Forms在Mono运行时之上和预编译.NET堆栈之上添加了一个抽象层。这个抽象层的唯一责任是向Xamarin编译器提供必要的指令，以标准化GUI元素的代码或标记，以便在Xamarin应用程序中渲染原生控件。由于Xamarin的平台语言是C#，**可扩展应用程序标记语言**（**XAML**）是首选的设计标记语言。Xamarin.Forms为Windows
    Store应用程序提供了相同的抽象作为运行时库。
- en: The abstraction layer provided by Xamarin.Forms makes use of the similar UI
    elements and layout patterns which were illustrated in the previous chapter (see
    [Chapter 7](ch07.html "Chapter 7. View Elements"), *View Elements*). In this context,
    Xamarin.Forms only provides controls and views that are common to all three platforms
    and omits platform-specific UI elements. It is important to understand that Xamarin.Forms
    is not a replacement for a native user interface implementation, but more of a
    foundation to build upon while creating cross-platform applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms提供的抽象层利用了之前章节中（见[第7章](ch07.html "第7章. 视图元素")，*视图元素*）所展示的类似UI元素和布局模式。在这种情况下，Xamarin.Forms只为所有三个平台提供通用的控件和视图，并省略了特定平台的UI元素。重要的是要理解，Xamarin.Forms不是原生用户界面实现的替代品，而更多是在创建跨平台应用程序时构建的基础。
- en: '![Under the hood](img/B04693_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![内部机制](img/B04693_08_01.jpg)'
- en: 'Figure 1: Xamarin.Forms abstraction layer'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：Xamarin.Forms抽象层
- en: Xamarin.Forms not only provides a uniform native UI development framework, but
    also additional features that are generally associated with loosely-coupled UI
    development, such as data binding, dependency injection, and messenger infrastructure.
    To a certain extent, these features render third-party MVVM libraries used in
    various mobile application projects obsolete.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms不仅提供了一个统一的本地UI开发框架，还提供了与松散耦合UI开发相关的一些附加功能，例如数据绑定、依赖注入和信使基础设施。在某种程度上，这些功能使得在各个移动应用程序项目中使用的第三方MVVM库变得过时。
- en: Anatomy of Xamarin.Forms
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin.Forms结构
- en: Xamarin.Forms libraries are distributed through NuGet packages and can be freely
    included in cross-platform development projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms库通过NuGet包进行分发，可以自由地包含在跨平台开发项目中。
- en: Whilst the NuGet package for iOS does not present any dependencies, the Android
    and Windows Phone versions depend on several support libraries (that is, WPToolKit
    for Windows Phone; and several design and compatibility packages for Android).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iOS的NuGet包没有显示任何依赖项，但Android和Windows Phone版本依赖于几个支持库（即Windows Phone的WPToolKit；以及Android的几个设计和兼容性包）。
- en: The Xamarin.Forms.Core library contains the UI elements and the necessary XAML
    declarations together with additional features related to data binding and similar
    operations. This assembly can be included in portable class library projects that
    provide the view implementation to platform-specific projects. Native client projects,
    in return, should reference Xamarin.Forms.Core and the platform-specific assemblies
    of Xamarin.Forms (for example, Xamarin.Forms.Platform.iOS). Xamarin.Forms platform
    libraries contain the so-called renderer implementations that are responsible
    for rendering Xamarin.Form elements using native controls. In other words, these
    platform assemblies provide the mapping between native elements and their Xamarin.
    Forms counterparts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms.Core 库包含 UI 元素和必要的 XAML 声明，以及与数据绑定和类似操作相关的附加功能。此程序集可以包含在提供视图实现的平台特定项目中可移植类库项目中。作为回报，原生客户端项目应引用
    Xamarin.Forms.Core 和 Xamarin.Forms 的平台特定程序集（例如，Xamarin.Forms.Platform.iOS）。Xamarin.Forms
    平台库包含所谓的渲染器实现，负责使用原生控件渲染 Xamarin.Forms 元素。换句话说，这些平台程序集提供了原生元素与其 Xamarin.Forms
    对应元素之间的映射。
- en: Project structure
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: In order to create a Xamarin.Forms application project targeting iOS, Android,
    and/or Windows Phone 8, it is sufficient to use one of the project templates located
    in the **Cross-Platform** section. While the portable library project template
    makes use of a PCL to create the Xamarin.Forms application boilerplate, the shared
    project template creates a shared project with file references linked to the native
    client app projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个针对 iOS、Android 和/或 Windows Phone 8 的 Xamarin.Forms 应用程序项目，可以使用 **跨平台**
    部分中的任何一个项目模板。虽然可移植库项目模板使用 PCL 创建 Xamarin.Forms 应用程序样板，但共享项目模板创建了一个共享项目，其中文件引用链接到原生客户端应用程序项目。
- en: '![Project structure](img/B04693_08_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/B04693_08_02.jpg)'
- en: 'Figure 2: Xamarin.Forms project templates'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：Xamarin.Forms 项目模板
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Project templates can be found in the **Mobile Apps** section in older versions
    of Xamarin.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的 Xamarin 中，项目模板可以在 **移动应用** 部分找到。
- en: Once the project is initialized, by selecting the **Blank App (Xamarin.Forms
    Portable)** project template, the created solution will include four projects,
    one project carrying the same name as the entered project name and three platform-specific
    projects with the platform suffixes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目初始化，通过选择 **Blank App (Xamarin.Forms Portable**) 项目模板，创建的解决方案将包括四个项目，一个项目与输入的项目名称相同，另外三个具有平台后缀的平台特定项目。
- en: '![Project structure](img/B04693_08_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/B04693_08_03.jpg)'
- en: 'Figure 3: Xamarin.Forms solution main view and project scopes'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：Xamarin.Forms 解决方案主视图和项目范围
- en: One caveat of using this project template for Xamarin.Forms is the fact that
    other platforms that are actually supported by this framework (for example, Windows
    Phone 8.1 and Windows 10) are not included in this multi-project template. These
    projects can be created manually, and the NuGet package for Xamarin.Forms can
    be added using the NuGet package manager. It is also important to mention that
    the NuGet package referenced in the project template might not be the latest version
    of Xamarin.Forms and therefore can be updated using the NuGet package manager.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此项目模板的 Xamarin.Forms 的一项注意事项是，实际上由该框架支持的其他平台（例如，Windows Phone 8.1 和 Windows
    10）并未包含在此多项目模板中。这些项目可以手动创建，并且可以使用 NuGet 包管理器添加 Xamarin.Forms 的 NuGet 包。还重要的是要提到，项目模板中引用的
    NuGet 包可能不是 Xamarin.Forms 的最新版本，因此可以使用 NuGet 包管理器进行更新。
- en: '![Project structure](img/B04693_08_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/B04693_08_04.jpg)'
- en: 'Figure 4: The latest NuGet package for Xamarin.Forms'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：Xamarin.Forms 的最新 NuGet 包
- en: If you take a look at the generated code in the portable library, `App.cs`,
    and the platform-specific projects, the implementation pattern immediately becomes
    apparent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看可移植库中生成的代码 `App.cs` 和平台特定项目，实现模式立即变得明显。
- en: 'The Xamarin.Forms implementation contains the application class implementation
    as the root node. This application is initialized and invoked by the generated
    code in the app delegates in platform-specific projects (similar to the following
    code excerpt from the Xamarin.Forms iOS application sample):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms 的实现包含作为根节点的应用程序类实现。此应用程序由平台特定项目中生成的代码初始化和调用（类似于以下从 Xamarin.Forms
    iOS 应用程序示例中摘录的代码）：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The initialization code for the app in the template boilerplate creates a content
    page with a single label in a `StackLayout` element and designates this view as
    the main page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 模板样板中的应用程序初始化代码创建了一个包含单个标签的`StackLayout`元素的页面，并将此视图指定为主要页面：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the Xamarin.Forms application structure is made up of controls
    wrapped in different layout configurations that are presented through various
    page types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Xamarin.Forms应用程序结构由不同布局配置中的控件组成，这些配置通过各种页面类型呈现。
- en: Components
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Xamarin.Forms components can be categorized into three main groups according
    to their position in the view hierarchy and their usage.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们在视图层次结构中的位置和它们的用途，Xamarin.Forms组件可以分为三个主要组。
- en: Pages
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面
- en: Conceptually, pages are navigational elements. They provide a general hierarchical
    organization of the view elements whilst also acting as a container for the layouts.
    There are various page types that can be inherited and implemented or designed
    using XAML markups.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，页面是导航元素。它们提供了视图元素的通用层次组织，同时充当布局的容器。有各种可以继承和实现或使用XAML标记设计的页面类型。
- en: Tabbed page
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签页
- en: When discussing the top-level navigation pages in the previous chapter, we mentioned
    several controls that can provide horizontal navigation throughout top-level pages.
    Using Xamarin.Forms, `TabbedPage` allows developers to create these horizontal
    navigational view elements. `TabbedPage` generates a tabbed action bar and associated
    activities on Android. On Windows Phone, the generated view contains a pivot control.
    Finally on iOS, generated view contains a tab bar and associated views.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论顶级导航页面时，我们提到了几个可以在顶级页面中提供水平导航的控件。使用Xamarin.Forms，`TabbedPage`允许开发人员创建这些水平导航视图元素。`TabbedPage`在Android上生成标签操作栏和相关活动。在Windows
    Phone上，生成的视图包含枢轴控件。最后，在iOS上，生成的视图包含标签栏和相关视图。
- en: '`TabbedPage` contains the navigation pages as its children (that is, the `Children`
    property accepts different page implementations), and the page titles of the child
    elements are used as navigation links.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabbedPage`包含其子导航页面（即，`Children`属性接受不同的页面实现），并且子元素的页面标题用作导航链接。'
- en: 'Implementing the tabbed view example from the previous chapter for our TravelTrace
    application would look similar to the following snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一章中的标签视图示例实现到我们的TravelTrace应用程序中看起来会类似于以下片段：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The same implementation can be done using XAML and creating a `TabbedPage`
    implementation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的实现可以使用XAML和创建`TabbedPage`实现来完成：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Assigning the newly created `MainTabView` class instance to `MainPage` in `App.cs`
    would result in the same view as the code implementation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将新创建的`MainTabView`类实例分配给`App.cs`中的`MainPage`会导致与代码实现相同的视图。
- en: '![Tabbed page](img/B04693_08_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![标签页](img/B04693_08_05.jpg)'
- en: 'Figure 5: TabbedPage view'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：TabbedPage视图
- en: It is important here to mention that the `Icon` property provided for individual
    peers in a `TabbedPage` implementation only applies to the iOS platform. Icons
    in tab and pivot views are not supported by Xamarin and it is not an accepted
    design approach for Android and Windows Phone.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提到这一点很重要，为`TabbedPage`实现中单个对等项提供的`Icon`属性仅适用于iOS平台。Xamarin不支持标签和枢轴视图中的图标，并且这不是Android和Windows
    Phone接受的设计方法。
- en: The MasterDetail page
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主详细页面
- en: The example with the tabbed view satisfies the horizontal navigation requirements
    of our design, but we also need a navigation drawer and associated main menu navigation
    items for our Android applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 具有标签视图的示例满足我们设计的水平导航要求，但我们也需要为我们的Android应用程序提供一个导航抽屉和相关的菜单导航项。
- en: '`MasterDetailPage` provides a structure in which the master page selection
    menu can initiate a navigation request on the detail page. Moreover, if the content
    of the `Detail` page is encapsulated in a `NavigationPage`, the generated view
    is added to the navigation stack so that the previously displayed pages can easily
    be pulled into the master view using the event methods. In order to include an
    additional layer of navigation and a global menu, we can now use the `MasterDetailPage`
    class to create the desired navigation structure.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`MasterDetailPage`提供了一个结构，其中主页面选择菜单可以在详细页面中发起导航请求。此外，如果`Detail`页面的内容封装在`NavigationPage`中，生成的视图将被添加到导航堆栈中，这样以前显示的页面就可以通过事件方法轻松地拉入主视图。为了包含一个额外的导航层和全局菜单，我们现在可以使用`MasterDetailPage`类来创建所需的导航结构。'
- en: The first step of the implementation is to create our master view. The master
    view in this case will include a simple list view with menu and a profile display
    as the list header. When the list view content items are selected, we can either
    bubble up the event to the `MasterDetailPage` or pass the parent page as a parameter
    to the menu page we are implementing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的第一步是创建我们的主视图。在这种情况下，主视图将包括一个简单的列表视图，其中包含菜单和一个作为列表标题的配置文件显示。当列表视图内容项被选中时，我们可以将事件冒泡到
    `MasterDetailPage`，或者将父页面作为参数传递给我们正在实现的菜单页面。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this implementation, we are using a `Tuple` with three parameters for the
    label, tag, and icon of the menu item. It would, of course, be better to implement
    a class to contain these data values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们使用一个包含标签、标记和菜单项图标的三个参数的 `Tuple`。当然，实现一个包含这些数据值的类会更好。
- en: 'Now we can construct our `MasterDetailPage` by setting the `Master` and `Detail`
    properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过设置 `Master` 和 `Detail` 属性来构建我们的 `MasterDetailPage`：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`MasterBehavior` can be adjusted according to the platform. In this example,
    we will be using the popover behavior, which displays a flyout and a toggle button
    in the main app bar on Android and creates a navigation command icon to open the
    flyout on other platforms.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`MasterBehavior` 可以根据平台进行调整。在这个例子中，我们将使用弹出行为，该行为在 Android 上显示一个弹出窗口和一个切换按钮在主应用栏中，并在其他平台上创建一个导航命令图标以打开弹出窗口。'
- en: '![The MasterDetail page](img/B04693_08_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![MasterDetail 页面](img/B04693_08_06.jpg)'
- en: 'Figure 6: Navigation flyout on Android and Windows Phone'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：Android 和 Windows Phone 上的导航弹出窗口
- en: When using `MasterDetailPage`, it is important to anticipate the outcome of
    the design decisions made in Xamarin.Forms markups so that final applications
    for the target platforms still follow the design guidelines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `MasterDetailPage` 时，重要的是要预测在 Xamarin.Forms 标记中做出的设计决策的结果，以确保针对目标平台的最终应用程序仍然遵循设计指南。
- en: NavigationPage
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NavigationPage
- en: '`NavigationPage` is the most abstract implementation of the `Page` class. The
    main purpose of using NavigationPage is to create a navigational stack in the
    application context. This navigational context is supported natively on Windows
    Phone. However, other platforms do not create a stack for previously viewed pages.
    Using `NavigationPage`, one can utilize the items in the navigational history
    and manipulate the stack using push and pop methods.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigationPage` 是 `Page` 类的最抽象实现。使用 `NavigationPage` 的主要目的是在应用程序上下文中创建一个导航堆栈。这种导航上下文在
    Windows Phone 上是原生支持的。然而，其他平台不会为之前查看的页面创建堆栈。使用 `NavigationPage`，可以利用导航历史记录中的项目，并使用推送和弹出方法来操作堆栈。'
- en: CarouselPage
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CarouselPage
- en: '`CarouselPage` is another horizontal navigation implementation that the user
    can use to navigate through the peer pages using swipe or flick gestures. `CarouselPage`
    is very similar to the panorama view and pivot controls from the Windows Phone
    7 platform, except for the fact that `CarouselPage` has strict snap points (that
    is, when the free scrolling view snaps to the borders of a control or a page)
    and it does not have an endless loop of items, in contrast with pivot control,
    but instead has more linear navigation. Behaviorally, it resembles and uses a
    similar navigation strategy as the `FlipView` control from Windows Runtime.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarouselPage` 是另一种用户可以使用滑动或轻扫手势在同级页面之间导航的水平导航实现。`CarouselPage` 与 Windows Phone
    7 平台上的全景视图和枢轴控件非常相似，除了 `CarouselPage` 有严格的快照点（即，当自由滚动视图快照到控件或页面的边缘时）并且它没有无限循环的项目，与枢轴控件相比，而是有更线性的导航。在行为上，它类似于并使用与
    Windows Runtime 中的 `FlipView` 控件相似的导航策略。'
- en: 'In order to initiate a carousel-type navigation structure, either XAML or code-behind
    can be used. A simple carousel view with three content page implementations would
    look as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动一个轮播式导航结构，可以使用 XAML 或代码隐藏。一个简单的包含三个内容页面实现的轮播视图如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The resulting view would be a container for touch-initiated horizontal navigation
    between peers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果视图将是一个容器，用于在同级之间通过触摸启动的水平导航。
- en: '![CarouselPage](img/B04693_08_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![CarouselPage](img/B04693_08_07.jpg)'
- en: 'Figure 7: Carousel view'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7：轮播视图
- en: ContentPage
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ContentPage
- en: '`ContentPage` is a simple page implementation used generally in cooperation
    with previously described page structures. It can be described as the actual content
    presenter. Child views in other navigation implementations are generally made
    up of `ContentPage` implementations.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage` 是一种简单的页面实现，通常与之前描述的页面结构一起使用。它可以描述为实际的内容呈现器。在其他导航实现中的子视图通常由 `ContentPage`
    实现。'
- en: In order to set the content to be visualized on the user interface, you can
    use the `Content` property, which accepts a list of view objects. Layout elements
    are generally used as the direct children of `ContentPage` and other user controls
    are appended to this visual tree.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置用户界面中要可视化的内容，您可以使用`Content`属性，该属性接受一个视图对象的列表。布局元素通常用作`ContentPage`和其他用户控制的直接子元素，其他用户控制附加到这个视觉树中。
- en: Layouts
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: 'Layouts are structural design elements that allow developers to organize the
    UI controls using various strategies. We can classify layouts into two groups
    according to their class inheritance hierarchy: single view and multiple view.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是结构化设计元素，允许开发者使用各种策略组织UI控件。我们可以根据它们的类继承层次结构将布局分为两组：单视图和多视图。
- en: '![Layouts](img/B04693_08_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/B04693_08_08.jpg)'
- en: 'Figure 8: Layout classes'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：布局类
- en: Single view layouts are direct descendants of the base layout implementation
    and they are capable of displaying only a single view item (they can also be a
    branch of a visual tree). Examples of this category are `ContentView`, `Frame`,
    and `ScrollView`. `ContentView` and `Frame` elements are rarely used and can be
    helpful while dealing with fewer content elements and/or an application with an
    active screen pattern (for example, a drawing application would use a single canvas
    implementation with absolute positioning; drawn geometry items would be the children
    of the canvas).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单视图布局是基本布局实现的直接后代，并且它们只能显示单个视图项（它们也可以是视觉树的一个分支）。这个类别的例子包括`ContentView`、`Frame`和`ScrollView`。`ContentView`和`Frame`元素很少使用，在处理较少的内容元素和/或具有活动屏幕模式的应用程序（例如，绘图应用程序会使用一个带有绝对定位的单个画布实现；绘制的几何项将是画布的子项）时可能很有帮助。
- en: '`ScrollView`, on the other hand, is one of the most popular controls and can
    be used together with another layout element, such as `StackLayout`. When used
    with `StackLayout`, if the calculated height of `StackLayout` is greater than
    the client area, the parent control, `ScrollView`, makes it possible to change
    the viewport of the child control. Even though it is not very common, `ScrollView`
    can still be used with simple controls such as `Label` or `Image`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ScrollView`是最受欢迎的控件之一，可以与另一个布局元素（如`StackLayout`）一起使用。当与`StackLayout`一起使用时，如果`StackLayout`的计算高度大于客户端区域，父控件`ScrollView`使子控件能够改变视口。尽管这并不常见，但`ScrollView`仍然可以与简单的控件（如`Label`或`Image`）一起使用。
- en: 'For instance, if we were to implement the primary content of the `TabbedPage`
    created in the previous section, we can use a `ScrollView` to display the `StackLayout`
    that is displaying the recently uploaded items from the TravelTrace server. The
    markup for this implementation would look similar to the following snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要在上一节创建的`TabbedPage`中实现主要内容，我们可以使用`ScrollView`来显示显示从TravelTrace服务器最近上传的项目。这个实现的标记将类似于以下片段：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It would be displayed almost like a scrolling `ListView`:.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它几乎会像滚动`ListView`一样显示：
- en: '![Layouts](img/B04693_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/B04693_08_09.jpg)'
- en: 'Figure 9: ScrollView visualizations'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：ScrollView可视化
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Under normal circumstances, when dealing with a long list of data items, `ListView`
    should be the main control to be used. This implementation is only for demonstration
    purposes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，处理大量数据项的长列表时，`ListView`应该是要使用的主要控件。此实现仅用于演示目的。
- en: The multi-page layouts category consists of `AbsoluteLayout`, `Grid`, `RelativeLayout`,
    and, as seen in the previous example, `StackLayout`. Each layout is used for a
    specific scenario for various design-related requirements.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 多页面布局类别包括`AbsoluteLayout`、`Grid`、`RelativeLayout`以及，如前例所示，`StackLayout`。每个布局都用于满足各种设计相关要求的具体场景。
- en: '`Grid`, similar to the `Grid` in Windows Presentation Foundation, is used to
    organize child elements in a grid structure. The initial step of creating a grid
    is to define `ColumnDefinitions` and `RowDefinitions`, which describe the cells
    that are going to be used to render the elements. After this step, view elements
    can be added to the grid using the attached properties of `Grid`, such as `Grid.Row`,
    `Grid.Column`, `Grid.RowSpan`, and `Grid.ColumnSpan`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`类似于Windows Presentation Foundation中的`Grid`，用于在网格结构中组织子元素。创建网格的第一步是定义`ColumnDefinitions`和`RowDefinitions`，它们描述了将要用于渲染元素的单元格。在此步骤之后，可以使用`Grid`的附加属性（如`Grid.Row`、`Grid.Column`、`Grid.RowSpan`和`Grid.ColumnSpan`）将视图元素添加到网格中。'
- en: 'Using the example cells from the previous implementation, we could have a classic
    cell view with two lines of text and an image on the right-most section of the
    cell:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个实现中的示例单元格，我们可以有一个经典的单元格视图，其中有两行文本和位于单元格最右侧部分的图像：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`AbsoluteLayout` provides a rendering mechanism in which the child elements
    are organized in floating rectangles. Placement geometry (that is, the `LayoutBounds`
    property) defines the X and Y coordinates of the element and the size of the bounding
    rectangle. The `LayoutBounds` property can accept device units or proportional
    units. The notion used for proportional units is similar to the "%" system used
    in HTML layouts. These values have to be in the range of 0-1 to designate an element
    on the screen area. The `AbsoluteLayoutFlags` enumeration can be used to define
    the bounding rectangle values that follow the proportional unit system or otherwise
    (for example, `PositionProportional`, `HeightProportional`, `SizeProportional`,
    or `All`).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbsoluteLayout`提供了一种渲染机制，其中子元素以浮动矩形的形式组织。放置几何形状（即`LayoutBounds`属性）定义了元素的X和Y坐标以及边界矩形的尺寸。`LayoutBounds`属性可以接受设备单位或比例单位。用于比例单位的观念类似于HTML布局中使用的"%"系统。这些值必须在0-1的范围内，以指定屏幕区域上的元素。`AbsoluteLayoutFlags`枚举可以用来定义遵循比例单位系统或其他方式（例如，`PositionProportional`、`HeightProportional`、`SizeProportional`或`All`）的边界矩形值。'
- en: '`RelativeLayout` is conceptually similar to relative layouts on the Android
    and Windows 10 platforms. It also uses a similar constraint mechanism as iOS auto-layout
    implementation. In a relative layout, elements can be positioned in a bounding
    rectangle similar to an absolute layout. However, values for this bounding rectangle
    are defined in reference to the parent element (`RelativeToParent`) or another
    control in the visual tree (`RelativeToView`). Developers are also allowed to
    use constant values without referencing another control.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`在概念上类似于Android和Windows 10平台上的相对布局。它也使用与iOS自动布局实现类似的约束机制。在相对布局中，元素可以定位在一个类似于绝对布局的边界矩形内。然而，这个边界矩形的值是以父元素（`RelativeToParent`）或视觉树中的另一个控件（`RelativeToView`）为参考定义的。开发者还被允许使用常数而不参考另一个控件。'
- en: 'In relative layouts, if the arrangement is being created in code-behind, constraints
    are defined using a lambda expression or anonymous functions. For instance, in
    order to add an image element to the center of the page of size (100,100), we
    would use the `RelativeToParent` constraint:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在相对布局中，如果布局是在代码背后创建的，则使用lambda表达式或匿名函数定义约束。例如，为了将一个图像元素添加到页面中心，大小为（100,100），我们会使用`RelativeToParent`约束：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we were to insert a label 10 units underneath the image in the center, it
    would look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在图片下方10个单位处插入一个标签，它看起来将如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The outcome would be as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![Layouts](img/B04693_08_10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/B04693_08_10.jpg)'
- en: 'Figure 10: Relative layouts'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：相对布局
- en: A similar implementation using the markup extensions in XAML can be employed.
    Even though the constraint expression options are limited by factor and constant
    values (that is, using relative layout, factor multiplies the value of the selected
    property and constant is used for offset values), it can prove useful in data-bound
    scenarios.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用XAML中的标记扩展进行类似的实现。尽管约束表达式选项受因子和常数值的限制（即使用相对布局，因子乘以所选属性的值，常量用于偏移值），但在数据绑定场景中它可能非常有用。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, `StackLayout`, similar to `StackPanel` on the Windows platform and
    `LinearLayout` on the Android platform, provides a flow layout where child views
    (that is, controls) are arranged automatically according to the orientation set
    and the calculated or requested dimensions of elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`StackLayout`与Windows平台上的`StackPanel`和Android平台上的`LinearLayout`类似，提供了一种流式布局，其中子视图（即控件）会根据设置的朝向和元素的计算或请求的尺寸自动排列。
- en: Views
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: User interface controls in Xamarin.Forms are referred to as views. Views are
    abstractions of controls or widgets in Xamarin target platforms, and each of them
    is rendered with a native control on the respective platform.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中，用户界面控件被称为视图。视图是Xamarin目标平台上的控件或小部件的抽象，每个视图都在相应的平台上使用本地控件进行渲染。
- en: 'For text-related scenarios, there are three controls: `Editor`, `Entry`, and
    `Label`. The `Editor` and `Entry` views provide multi-line and single-line editing
    capabilities to the user interface respectively. On the other hand, the label
    view can be used in either scenario as a read-only control.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本相关场景，有三个控件：`Editor`、`Entry` 和 `Label`。`Editor` 和 `Entry` 视图分别向用户界面提供多行和单行编辑功能。另一方面，标签视图可以用作只读控件，适用于任何场景。
- en: For dropdown-related scenarios, the `Picker` view can be used. More specialized
    implementations of pickers are `TimePicker` and `DatePicker`. `Stepper` and `Slider`
    are other views that can provide a constraint value, such as an integer within
    a certain range. For option scenarios, the only available control is the `Switch`
    view. The `Switch` view renders a `Switch` control on Android and iOS and a `ToggleButton`
    on Windows.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下拉相关场景，可以使用 `Picker` 视图。更专业的拾取器实现包括 `TimePicker` 和 `DatePicker`。`Stepper`
    和 `Slider` 是其他可以提供约束值的视图，例如一定范围内的整数。对于选项场景，唯一可用的控件是 `Switch` 视图。`Switch` 视图在 Android
    和 iOS 上渲染为 `Switch` 控件，在 Windows 上渲染为 `ToggleButton`。
- en: For process feedback implementation, there are two views available, namely `ProgressBar`
    and `ActivityIndicator`. `ProgressBar` provides a determinate progress indicator,
    and `ActivityIndicator` is rendered as an indeterminate progress ring on target
    platforms.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进程反馈实现，有两个视图可供选择，即 `ProgressBar` 和 `ActivityIndicator`。`ProgressBar` 提供一个确定性的进度指示器，而
    `ActivityIndicator` 在目标平台上渲染为一个不确定性的进度环。
- en: For web resource-related scenarios, `WebView` can be utilized. In a similar
    fashion to embedded web view native controls on target platforms, `WebView` can
    be used to display either a local (that is, a web element constructed from application
    resources or a text value) or a remote web page. It provides access to the navigation
    stack and navigation events of the displayed web document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与网络资源相关的场景，可以使用 `WebView`。与目标平台上的嵌入式网页原生控件类似，`WebView` 可以用来显示本地（即，由应用程序资源或文本值构建的网页元素）或远程网页。它提供了对显示的网页文档的导航堆栈和导航事件的访问。
- en: 'For collection views, there are two main controls in Xamarin.Forms: `ListView`
    and `TableView`. `ListView`, undoubtedly, is the most specialized control to display
    a collection of content items. It supports data binding scenarios together with
    more specialized actions such as pull-to-refresh, context-related commands, and
    selections. `TableView`, on the other hand, is used for scenarios where the content
    items are more heterogeneous and instead of a data-bound source, fixed UI element
    declarations are required. It can be used for a menu display of selections, configuration
    values, or as an input form.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集合视图，Xamarin.Forms 中有两个主要控件：`ListView` 和 `TableView`。`ListView` 无疑是最专业的控件，用于显示内容项的集合。它支持数据绑定场景以及更专业的操作，如下拉刷新、上下文相关命令和选择。另一方面，`TableView`
    用于内容项更异质化的场景，而不是数据绑定源，需要固定 UI 元素声明。它可以用于选择菜单显示、配置值或作为输入表单。
- en: Both `ListView` and `TableView` consist of cells. Cells are visual templates
    used to render content elements in these collection views. While `TableView` is
    generally associated with default templates such as `SwitchCell` and `EntryCell`,
    which are used to create form elements in a table, `ListView` generally uses a
    templated implementation of `ViewCell`. For simpler implementation scenarios,
    built-in cell implementations, such as `TextCell` and `ImageCell`, can also be
    used with the `ListView` control.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 和 `TableView` 都由单元格组成。单元格是用于在这些集合视图中渲染内容元素的视觉模板。虽然 `TableView` 通常与默认模板（如
    `SwitchCell` 和 `EntryCell`）相关联，这些模板用于在表格中创建表单元素，但 `ListView` 通常使用 `ViewCell` 的模板实现。对于更简单的实现场景，也可以使用内置的单元格实现，如
    `TextCell` 和 `ImageCell`，与 `ListView` 控件一起使用。'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For `TableView` collection control, the iOS platform currently does not support
    the `HasUnevenRows` property and automatic layout of the cells. This is a known
    platform limitation that was recently fixed for the `ListView` control. Developers
    are expected to either define a fixed `RowHeight` for `TableView` or define a
    `Height` value for each cell.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `TableView` 集合控件，iOS 平台目前不支持 `HasUnevenRows` 属性和单元格的自动布局。这是一个已知的平台限制，最近已针对
    `ListView` 控件进行了修复。开发者可以选择为 `TableView` 定义一个固定的 `RowHeight`，或者为每个单元格定义一个 `Height`
    值。
- en: 'In order to demonstrate the `ListView` utilization, we can make use of the
    previous implementation in which we used `StackLayout` together with `ScrollView`.
    In the previous scenario, we created hard-coded UI elements that were defined
    as `Grid` items. In this implementation, let us assume that we have a data source
    that can be set as the data provider for the `ListView`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`ListView`的使用，我们可以利用之前的实现，其中我们使用了`StackLayout`和`ScrollView`。在前一个场景中，我们创建了硬编码的UI元素，这些元素被定义为`Grid`项。在这个实现中，让我们假设我们有一个可以设置为`ListView`数据提供者的数据源：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this provider, we are using a three value `Tuple` that provides the display
    name, description, and image values for the content entries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此提供者中，我们使用一个包含三个值的`Tuple`，为内容条目提供显示名称、描述和图像值。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Tuple` values are accessed using Item1, Item2… properties.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tuple`值通过Item1、Item2…属性进行访问。'
- en: '`ListView` can contain three visual templates defining the respective sections
    of the collection view: `HeaderTemplate`, `FooterTemplate`, and `ItemTemplate`.
    A header and footer can also be set directly using a view element:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`可以包含三个视觉模板，分别定义集合视图的相应部分：`HeaderTemplate`、`FooterTemplate`和`ItemTemplate`。也可以直接使用视图元素来设置标题和页脚：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`ItemTemplate` defines how the content elements are to be rendered in the collection
    view. If `ItemTemplate` is not defined, the list renderer will try to convert
    the content elements to a string and display them as `TextCells`. Re-using the
    grid implementation from the previous example(s), we can define `DataTemplate`
    for the `ItemTemplate` property of `ListView`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemTemplate`定义了内容元素在集合视图中如何渲染。如果未定义`ItemTemplate`，列表渲染器将尝试将内容元素转换为字符串，并以`TextCells`的形式显示它们。从先前的示例中重用网格实现，我们可以为`ListView`的`ItemTemplate`属性定义`DataTemplate`：'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This implementation will be displayed in a scroll-enabled list container similar
    to the following screenshots:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现将在一个可滚动的列表容器中显示，类似于以下截图：
- en: '![Views](img/B04693_08_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![视图](img/B04693_08_11.jpg)'
- en: 'Figure 11: ListView with item source'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：具有项目源的`ListView`
- en: In order to implement context-related functions, the item data template, view
    cell, can be edited to include context menu elements. It is also possible to modify
    view cell in the code-behind file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现与上下文相关的功能，可以编辑项目数据模板、视图单元格，以包含上下文菜单元素。也可以在代码隐藏文件中修改视图单元格。
- en: 'The following XAML snippet can be used to create two context menu actions:
    `Favourite` and `Remove`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下XAML代码片段可以用来创建两个上下文菜单操作：`Favourite`和`Remove`：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the `Remove` command is marked as destructive. The `IsDestructive`
    flag is used to create the slide-to-delete behavior on iOS. On other platforms,
    destructive actions are rendered similar to other commands.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Remove`命令被标记为破坏性操作。`IsDestructive`标志用于在iOS上创建滑动删除行为。在其他平台上，破坏性行为的表现与其他命令类似。
- en: '![Views](img/B04693_08_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![视图](img/B04693_08_12.jpg)'
- en: 'Figure 12: Context menu actions'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：上下文菜单操作
- en: '`ListView` also has a flag called `IsPullToRefreshEnabled`. This property can
    be used to support the pull-to-refresh behavior. `RefreshCommand` can be used
    to bind the action required to refresh the list.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`还有一个名为`IsPullToRefreshEnabled`的标志。此属性可用于支持下拉刷新行为。`RefreshCommand`可用于绑定刷新列表所需的操作。'
- en: Extending forms
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展形式
- en: Even though the Xamarin.Forms framework provides an extensive set of customizable
    UI elements, in certain scenarios you might want to change how a certain control
    looks or behaves. Moreover, at times, providing an application-wide customization
    scheme can provide consistency and decrease redundancy. XAML markup infrastructure
    used in Xamarin.Forms provides various custom implementation scenarios.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Xamarin.Forms框架提供了一套广泛的可自定义UI元素，但在某些场景中，您可能希望更改某些控件的外观或行为。此外，有时提供跨应用的自定义方案可以提供一致性并减少冗余。Xamarin.Forms中使用的XAML标记基础设施提供了各种自定义实现场景。
- en: Styles
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式
- en: When implementing certain UI patterns, view elements have to be declared independent
    of each other, and yet they have to carry the same design attributes, such as
    typography, layout properties, colors, and so on. Styles can be used in this situation
    to organize and re-use the element attributes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现某些UI模式时，视图元素必须相互独立声明，同时它们必须携带相同的设计属性，如字体、布局属性、颜色等。在这种情况下，可以使用样式来组织和重用元素属性。
- en: Using `ListView`, the only view container defined would be the item data template,
    and the content items loaded from the data source will be rendered using the same
    template. However, if the view requirement is to use `Grid`, `StackLayout`, or
    `TableView`, each view item would have to be defined separately.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ListView`，唯一定义的视图容器将是项目数据模板，从数据源加载的内容项将使用相同的模板进行渲染。然而，如果视图需求是使用 `Grid`、`StackLayout`
    或 `TableView`，则每个视图项都必须单独定义。
- en: For instance, it might become quite cumbersome to create a settings view for
    Xamarin.Forms applications using the `TableView` control. In this implementation,
    if we cannot use the standard cell views, such as `EntryCell` or `SwitchCell`,
    because of requirements, the markup becomes even more redundant with each control
    having to declare similar fonts and colors that make up the theme of the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `TableView` 控件为 Xamarin.Forms 应用程序创建设置视图可能会变得相当繁琐。在此实现中，如果我们不能使用标准单元格视图，如
    `EntryCell` 或 `SwitchCell`，因为要求，由于要求，标记变得更加冗余，每个控件都必须声明类似的字体和颜色，这些字体和颜色构成了应用程序的主题。
- en: '![Styles](img/B04693_08_13.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![样式](img/B04693_08_13.jpg)'
- en: 'Figure 13: TableView used for a settings view'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13：TableView 用于设置视图
- en: 'Custom cell views in this implementation were used to create a description
    element for each setting. If we look at the markup file, you can see the repeating
    styles for each text element:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，自定义单元格视图被用来为每个设置创建描述元素。如果我们查看标记文件，我们可以看到每个文本元素的重复样式：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, each label is defining at least `TextColor`, `FontSize`, `VerticalTextAlignment`,
    and `HorizontalOptions`. There is one pattern for setting labels and another one
    for description elements. Vertical and horizontal alignment options, however,
    apply to all text elements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个标签至少定义了 `TextColor`、`FontSize`、`VerticalTextAlignment` 和 `HorizontalOptions`。设置标签和描述元素有一个模式，然而，垂直和水平对齐选项适用于所有文本元素。
- en: 'Initially, we can simplify the markup by creating an implicit style that will
    apply to all `Label` elements. Implicit styles do not define a resource key, hence
    they apply to all targeted controls, such as `TargetType`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们可以通过创建一个将应用于所有 `Label` 元素的隐式样式来简化标记。隐式样式不定义资源键，因此它们应用于所有目标控件，例如 `TargetType`：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now create additional styles to set item labels and descriptions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建额外的样式来设置项目标签和描述：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, this does not work as we expected it to. The outcome demonstrates that
    the implicit styles were overridden by more specific style descriptions. It is
    important to realize that there is no implicit cascading between the styles defined
    for the same target controls. XAML is not HTML/CSS.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有像我们预期的那样工作。结果表明，隐式样式被更具体的样式描述覆盖了。重要的是要认识到，为同一目标控件定义的样式之间没有隐式级联。XAML 不是
    HTML/CSS。
- en: '![Styles](img/B04693_08_14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![样式](img/B04693_08_14.jpg)'
- en: 'Figure 14: Implicit style is overridden with assigned styles'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14：隐式样式被指定的样式覆盖
- en: 'In order to create a cascading scheme, we need to base the `SettingLabel` and
    `SettingDescription` styles on the initial implicit style. For this purpose, we
    need to define a key for our base style and reference this base in the derived
    style declarations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建级联方案，我们需要将 `SettingLabel` 和 `SettingDescription` 样式基于初始隐式样式。为此，我们需要为我们的基本样式定义一个键，并在派生样式声明中引用此基本样式：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the `SettingDescription` style uses the `BasedOn` declaration (similar
    to the WPF implementation), while `SettingLabel` uses the `BaseResourceKey` property.
    Both of these references can be used in Xamarin.Forms implementations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`SettingDescription` 样式使用 `BasedOn` 声明（类似于 WPF 实现），而 `SettingLabel` 使用 `BaseResourceKey`
    属性。这两个引用都可以在 Xamarin.Forms 实现中使用。
- en: Triggers and behaviors
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发器和行为
- en: At times, implementation requires style-related or behavioral changes of controls
    in accordance with changes of the same or any other control's properties or data,
    as well as certain events (for example, disabling a certain control according
    to the data input value changes). Under normal circumstances, implementations
    utilize data bindings where the data change event is routed to the presenter and
    the presenter changes the view, providing a trivial solution. However, if the
    UI event should trigger another UI change, the cost of data binding would be an
    overhead. Instead, the Xamarin.Forms markup offers triggers and behaviors that
    add complexity to intrinsic controls.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，实现需要根据相同或任何其他控件属性或数据的变化，以及某些事件（例如，根据数据输入值的变化禁用某个控件）来更改控件的风格或行为。在正常情况下，实现利用数据绑定，其中数据更改事件被路由到表示者，表示者更改视图，提供了一个简单的解决方案。然而，如果UI事件应该触发另一个UI更改，数据绑定的成本将是一个开销。相反，Xamarin.Forms标记提供了触发器和行为，这些触发器和行为为内置控件增加了复杂性。
- en: 'For instance, the settings view that we previously created for our application
    requires certain business rules. The first setting value, UserLocation, is a dependency
    of the UseGeofences setting. In other words, technically it is not possible to
    create geofences without using location services. For this specific scenario,
    we could create a data binding from the `IsToggled` value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们为我们的应用程序之前创建的设置视图需要某些业务规则。第一个设置值，UserLocation，是UseGeofences设置的依赖项。换句话说，在技术上，不使用位置服务就无法创建地理围栏。对于这个特定场景，我们可以从`IsToggled`值创建一个数据绑定：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding implementation works as expected since the `IsToggled` and `IsEnabled`
    values are both using `Boolean` as the value type. If we were to change any other
    property of the target UI element, we would have to implement a value converter.
    Moreover, multiple property changes would require multiple bindings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现按预期工作，因为`IsToggled`和`IsEnabled`的值都使用`Boolean`作为值类型。如果我们需要更改目标UI元素的任何其他属性，我们就必须实现一个值转换器。此外，多个属性更改需要多个绑定。
- en: Triggers provide an easy solution for this type of scenario. There are four
    types of trigger that can be used to initiate either a setter action or a custom
    implementation of a trigger action. Property triggers are used to create a visual
    state on a user control according to the value of a property of the same control.
    Data triggers are used in a similar fashion but in this case, the cause for the
    trigger is defined by data binding. Event triggers are bound to user control events
    and multi triggers can encompass and invoke an action that is dependent on multiple
    conditions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器为这类场景提供了一个简单的解决方案。有四种类型的触发器可以用来启动设置器动作或自定义触发器动作的实现。属性触发器用于根据相同控件属性的值在用户控件上创建一个视觉状态。数据触发器以类似的方式使用，但在这个情况下，触发的原因由数据绑定定义。事件触发器绑定到用户控件事件，多触发器可以包含并调用依赖于多个条件的动作。
- en: 'The same scenario from the previous example can, in this case, be implemented
    with a `DataTrigger`. Iterating on the scenario, the implementation can set the
    enabled and text color properties on the associated description label:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，可以从上一个示例中的相同场景使用`DataTrigger`来实现。在迭代场景时，实现可以设置关联描述标签的启用和文本颜色属性：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let us also implement a notification when the main control is disabled, warning
    the user about other settings being disabled. For this implementation, we will
    need an event trigger and a trigger action implementation. A trigger action implementation
    consists of implementing the `TriggerAction<T>` class and the virtual `Invoke`
    method: (see the *Dependency injection* section for the implementation of `INotificationService`)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再实现一个当主控件禁用时触发的通知，警告用户其他设置已被禁用。为此实现，我们需要一个事件触发器和触发器动作实现。触发器动作实现包括实现`TriggerAction<T>`类和虚拟的`Invoke`方法：（请参阅*依赖注入*部分以了解`INotificationService`的实现）
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we will need to declare the namespace containing the implementation in
    the root node of the page''s markup:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在页面标记的根节点中声明包含实现的命名空间：
- en: 'And finally, we can add the event trigger to the main setting control:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在主设置控件上添加事件触发器：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Triggers and behaviors](img/B04693_08_15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![触发器和行为](img/B04693_08_15.jpg)'
- en: 'Figure 15: Notification triggered using EventTrigger'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：使用EventTrigger触发的通知
- en: 'If we want this trigger to be applied to multiple controls (for example, the
    notification settings section in the example), we can create a new style for the
    main setting values and add the trigger to the style declaration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望这个触发器应用于多个控件（例如，示例中的通知设置部分），我们可以为主要的设置值创建一个新的样式，并将触发器添加到样式声明中：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The same type of result could have been achieved with a behavior implementation
    for the `Switch` control. Behaviors are a more generic type of extension mechanism
    that allow developers to extend existing user controls without having to create
    derivatives of these controls.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Switch`控件的实现同样可以达到相同的结果。行为是一种更通用的扩展机制，允许开发者扩展现有的用户控件，而无需创建这些控件的派生类。
- en: 'For instance, if we were to use the same scenario (that is, when the switch
    control is toggled off, a notification window should be shown to the user), we
    would need to implement the base class, `Behavior`, with a type argument for `Switch`
    view:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用相同的场景（即，当开关控制被切换关闭时，应向用户显示一个通知窗口），我们需要为`Switch`视图实现一个带有类型参数的基类`Behavior`：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In a custom behavior implementation class, an `OnAttachedTo` method is used
    as the initialization function where the control can be customized. Similarly,
    `OnDetachingFrom` is used to clean up the customizations and any existing event
    handlers that might have been attached to the control. Even though it's technically
    possible, it is not advisable to modify the binding context using behaviors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义行为实现类中，`OnAttachedTo`方法用作初始化函数，其中可以自定义控件。同样，`OnDetachingFrom`用于清理自定义设置以及可能附加到控件上的任何现有事件处理器。尽管技术上可行，但使用行为修改绑定上下文并不建议。
- en: 'The custom behavior can be included either in styles targeting the same type
    of control or with in-place markup elements added to the specific control:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义行为可以包含在针对同一类型控件的样式中，或者通过在特定控件中添加内联标记元素来实现：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Custom renderers
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义渲染器
- en: Xamarin.Forms provides the developers with a uniform markup and implementation
    framework to create native UI views for all Xamarin target platforms. The abstractions
    of provided UI elements are then used by the framework to render native controls.
    Similar to the Xamarin.Forms solution anatomy, each view/control in the Xamarin.Forms
    platform is a composite implementation. While the behaviors for the abstracted
    control logic are implemented and can be derived in portable class libraries,
    the renderers associated with each control for various platforms are implemented
    by platform-specific libraries.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms为开发者提供了一个统一的标记和实现框架，用于创建所有Xamarin目标平台的本地UI视图。提供的UI元素的抽象被框架用来渲染本地控件。类似于Xamarin.Forms解决方案的解剖结构，Xamarin.Forms平台中的每个视图/控件都是一个复合实现。虽然抽象的控制逻辑的行为可以在便携式类库中实现和派生，但与各个平台相关的控件渲染器是由特定平台库实现的。
- en: '![Custom renderers](img/B04693_08_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![自定义渲染器](img/B04693_08_16.jpg)'
- en: 'Figure 16: Custom renderer implementation'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：自定义渲染器实现
- en: In order to customize a control, one must first create a derived class for the
    abstracted control. After this implementation, the custom control can be referenced
    with a `clr-namespace` declaration (similar to `TriggerAction` and `Behaviors`)
    and can be used in the view markup.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自定义一个控件，必须首先为抽象控件创建一个派生类。在此实现之后，自定义控件可以通过`clr-namespace`声明（类似于`TriggerAction`和`Behaviors`）进行引用，并在视图标记中使用。
- en: At this stage, the custom implementation of the control would use the default
    renderer for the base class. In order to change the way that native controls are
    rendered on a specific platform, we would need to provide a custom renderer implementation
    and register it using the `ExportRenderer` attribute on the same platform.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，控件的自定义实现将使用基类的默认渲染器。为了改变特定平台上本地控件渲染的方式，我们需要提供一个自定义渲染器实现，并使用同一平台的`ExportRenderer`属性进行注册。
- en: Custom renderers provide a powerful way to customize how the common view implementations
    with Xamarin.Forms should look on platform-specific views.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义渲染器提供了一种强大的方式，可以自定义Xamarin.Forms中常见视图实现如何在特定平台视图中呈现。
- en: Patterns and best practices
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: In this section, we will discuss several implementation patterns and tools that
    developers generally resort to while developing Xamarin.Forms applications. Messaging
    and dependency injection features will be discussed further in [Chapter 9](ch09.html
    "Chapter 9. Reusable UI Patterns"), *Reusable UI Patterns*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论开发者在开发Xamarin.Forms应用程序时通常会采用的几种实现模式和工具。消息和依赖注入功能将在[第9章](ch09.html
    "第9章。可重用UI模式")*可重用UI模式*中进一步讨论。
- en: Messaging infrastructure
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息基础设施
- en: In an ideal implementation of the **Model-View-ViewModel** (**MVVM**) or **Model-View-Presenter**
    (**MVP**) pattern, each screen is self-contained; the screen modules for the view,
    model, and the mitigation components communicate with each other using various
    communication channels.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在**模型-视图-视图模型**（**MVVM**）或**模型-视图-演示者**（**MVP**）模式的理想实现中，每个屏幕都是自包含的；视图、模型和缓解组件的屏幕模块通过各种通信渠道相互通信。
- en: However, in complex applications, there is sometimes the need for a communication
    channel between these self-contained elements, since the result of an action on
    one of the screens should be propagated to other unrelated section(s) of the application
    with a shared interest in the result of this very action. As a solution to this
    problem, in MVVM frameworks such as MVVMCross, Prism, or MVVM Light, it is common
    to see an implementation of the Event Aggregator pattern providing a loosely coupled,
    multicast-enabled publisher/subscriber messaging infrastructure. Event Aggregator
    can be described as the eventing hub, which receives multiple types of strongly
    typed messages and delivers these messages to multiple subscribers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在复杂的应用程序中，有时需要在这些自包含元素之间建立通信渠道，因为某个屏幕上的操作结果应该传播到应用程序的其他无关部分，这些部分对这一操作的结果有共同兴趣。作为解决这个问题的一种方法，在MVVM框架如MVVMCross、Prism或MVVM
    Light中，通常可以看到事件聚合器模式的实现，提供了一种松散耦合、多播启用发布者/订阅者消息基础设施。事件聚合器可以描述为事件中心，它接收多种类型的强类型消息并将这些消息传递给多个订阅者。
- en: 'In Xamarin.Forms, the Event Aggregator is called the `MessagingCenter`. It
    exposes three groups of methods: `Subscribe`, `Unsubscribe`, and `Send`. The `Subscribe`
    and `Unsubscribe` methods are used by the event observers, and the `Send` method
    is used by the publisher.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中，事件聚合器被称为`MessagingCenter`。它公开了三组方法：`Subscribe`、`Unsubscribe`和`Send`。`Subscribe`和`Unsubscribe`方法由事件观察者使用，而`Send`方法由发布者使用。
- en: 'In this paradigm, the subscriber is responsible for providing the instance
    and/or the type of the sender together with the expected type of the message (that
    is, a simple text parameter defining the message). The message type or name is
    an identifier for the message and together with the message signature (the sender
    type and the arguments type), it makes up the decision criteria for the subscribers.
    Finally, the last provided parameter is the callback delegate, which can have
    the sender, and possibly the event arguments, as parameters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个范例中，订阅者负责提供发送者的实例和/或类型以及预期的消息类型（即定义消息的简单文本参数）。消息类型或名称是消息的标识符，与消息签名（发送者类型和参数类型）一起，构成了订阅者的决策标准。最后，提供的最后一个参数是回调委托，它可以有发送者，以及可能的事件参数：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The publisher is responsible for providing the message with the same message
    name and signature. On the publisher''s side, the message signature is made up
    of the message name and the message argument parameter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者负责提供具有相同消息名称和签名的消息。在发布者一侧，消息签名由消息名称和消息参数组成：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: MessagingCenter can prove to be very utile, providing simple solutions/workarounds
    for architectural problems (especially scenarios where a Separation of Concerns
    is in question) in Xamarin.Forms applications, and creating a decoupled communication
    channel between components.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: MessagingCenter可以证明是非常有用的，为Xamarin.Forms应用程序中的架构问题（特别是涉及关注点分离的场景）提供简单的解决方案/折衷方案，并在组件之间创建解耦的通信渠道。
- en: Dependency injection
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: As previously mentioned, one of the biggest drawbacks of using **Portable Class
    Libraries** (**PCLs**) to implement common cross-platform libraries is the fact
    that the platform-specific features cannot be accessed directly since the platform-dependent
    modules cannot be referenced by these libraries.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用**可移植类库**（**PCLs**）实现通用跨平台库的最大缺点之一是平台特定功能无法直接访问，因为这些平台依赖的模块无法由这些库引用。
- en: One of the most effective and elegant solutions to this problem is using dependency
    injection (aka IoC - Inversion of Control). Using dependency injection, platform-specific
    functionality should be abstracted into segregated interfaces, and these interfaces
    can later be used to access the implementation modules injected with the provided
    dependency containers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最有效和优雅的解决方案之一是使用依赖注入（也称为IoC - 控制反转）。使用依赖注入，特定平台的函数应该被抽象到隔离的接口中，这些接口可以后来用于访问通过提供的依赖容器注入的实现模块。
- en: '`DependencyService` in Xamarin.Forms allows applications to use platform-specific
    implementation through the abstraction interfaces.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyService`在Xamarin.Forms中允许应用程序通过抽象接口使用特定平台的实现。'
- en: In a common scenario, the first step would be to define the abstraction (in
    the common portable forms library) that is going to be used by the common application
    layer.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个常见的场景中，第一步是定义将要被通用应用程序层使用的抽象（在通用可移植表单库中）。
- en: 'For a demonstration, let us implement a module that uses the native messaging
    methods to display a notification for the user:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们实现一个模块，该模块使用原生消息方法来显示用户的通知：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can implement this interface in platform-specific projects. In the Xamarin.Android
    project, we can implement this using a toast notification:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在特定平台的项目中实现这个接口。在Xamarin.Android项目中，我们可以使用toast通知来实现：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the iOS platform, we can create a local notification message and present
    it using the shared application infrastructure. However, local notifications for
    foreground applications are automatically dismissed (only at the UI level can
    one still implement an event delegate for a notification received event and display
    an alert instead). Hence, we will use the `UIAlertController` class and present
    it using the current window:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS平台，我们可以创建一个本地通知消息，并使用共享应用程序基础设施来展示它。然而，前台应用程序的本地通知会自动消失（只有UI级别还可以实现一个事件代理来处理接收到的通知事件并显示一个警告）。因此，我们将使用`UIAlertController`类，并通过当前窗口来展示：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And finally, for the Windows Phone platform, we can only use the local toast
    notifications with the currently running applications on Windows Phone 8.1 and
    Windows 10 mobile. For other versions, similar to the iOS scenario, local toast
    notifications are not allowed for foreground applications. For this reason, we
    can implement a simpler notification dialog using the `MessageBox` class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于Windows Phone平台，我们只能使用本地toast通知与Windows Phone 8.1和Windows 10移动设备上当前运行的应用程序。对于其他版本，类似于iOS场景，前台应用程序不允许使用本地toast通知。因此，我们可以使用`MessageBox`类实现一个更简单的通知对话框：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to use the `INotificationService` interface in the portable class
    library that implements the Xamarin.Forms application, we need to resolve the
    interface to create an instance of one of the platform-appropriate implementations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实现Xamarin.Forms应用程序的可移植类库中使用`INotificationService`接口，我们需要解析接口以创建一个平台适当实现实例：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is important to note that in this sample implementation, the `Dependency`
    assembly attribute was used to register the platform-dependent implementation
    classes. It is also possible to use the `Register` method of `DependencyService`
    to create dependency containers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在这个示例实现中，使用了`Dependency`程序集属性来注册平台相关的实现类。也可以使用`DependencyService`的`Register`方法来创建依赖容器：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Register` method has to be invoked after the initialization of Xamarin.Forms
    (that is, the `Forms.Init` method) and before any dependent module is loaded.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`方法必须在Xamarin.Forms初始化（即`Forms.Init`方法）之后以及任何依赖模块加载之前调用。'
- en: Shared project versus portable project
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享项目与可移植项目
- en: Xamarin.Forms extensions introduce two types of multi-project solution templates.
    Each template contains platform-specific projects as well as a common project
    to implement platform-agnostic components for these native applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms扩展引入了两种类型的跨项目解决方案模板。每个模板都包含特定平台的项目以及一个通用项目，用于实现这些原生应用程序的平台无关组件。
- en: In the previous examples we were using the PCL project template, which creates
    three platform-specific projects, each referencing a cross-platform portable class
    library. Platform-specific projects delegate the application initialization to
    the portable class library that initializes Xamarin.Forms and renders the pages
    implemented using Xamarin.Forms.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用了PCL项目模板，该模板创建三个特定平台的项目，每个项目都引用一个跨平台的便携式类库。特定平台的项目将应用程序初始化委托给便携式类库，该类库初始化Xamarin.Forms并渲染使用Xamarin.Forms实现的页面。
- en: The second project template creates a shared project that is included and compiled
    into the platform-specific projects. In this scenario, since we are technically
    not dealing with a platform-agnostic implementation (that is, implementations
    in the shared project are directly compiled into the referencing projects), developers
    are free to use platform-specific features, given that the compilation conditions
    are used for appropriate platforms.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目模板创建一个共享项目，该项目被包含并编译到特定平台的项目中。在这种情况下，由于我们实际上并没有处理一个无平台实现（即，共享项目中的实现直接编译到引用的项目中），因此开发者可以自由使用平台特定功能，前提是编译条件用于适当的平台。
- en: 'The easiest way to demonstrate the difference between the two approaches would
    be to re-implement the notification service from the previous section without
    dependency injection. In the previous example, we needed to create an abstraction
    of the notification feature to be used in common views and inject the implementation
    from platform-specific projects in the runtime. In the case of a shared project,
    we can implement the same feature using conditional compilation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 展示两种方法之间差异的最简单方法是将上一节中的通知服务重新实现，不使用依赖注入。在之前的例子中，我们需要创建一个用于在常见视图中使用的通知功能抽象，并在运行时从特定平台的项目中注入实现。在共享项目的情况下，我们可以使用条件编译来实现相同的功能：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, each platform compilation uses a specific section of the function.
    We can also use other types of abstraction and partial classes or methods to create
    elegant implementations according to the requirements of the scenario.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个平台编译都使用函数的特定部分。我们还可以使用其他类型的抽象和部分类或方法，根据场景需求创建优雅的实现。
- en: Platform-specific fine-tuning
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台特定微调
- en: In spite of, or even because of, the fact that Xamarin.Forms tries to provide
    a uniform implementation layer and then translates this layer into native controls,
    at times developers are faced with the challenge of implementing retouches for
    specific platforms. These modifications vary from small changes, such as font
    size (because of device- and platform-dependent pixel measures) or background
    color, to more systematic problems, such as not having the auto-layout implementation
    for `TableViews` on the iOS platform. There are various ways to deal with this
    type of situation, and the `Device` class is generally the access point to these
    solutions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，或者正因为Xamarin.Forms试图提供一个统一的实现层并将其转换为原生控件，有时开发者会面临为特定平台实现修改的挑战。这些修改从小到字体大小（因为设备和平台依赖的像素度量）或背景颜色等小改动，到更系统性的问题，如iOS平台上`TableViews`没有自动布局实现。处理这类情况有各种方法，而`Device`类通常是这些解决方案的访问点。
- en: When dealing with common typographic controls, such as a `Label` or an `Entry`
    field, the simplest way to comply with the design or accessibility requirements
    of a specific device is to use the built-in styles available in the `Device.Styles`
    class. There are several style elements, such as `BodyStyle`, `SubtitleStyle`,
    and `CaptionStyle`, that can be used to solve common implementation problems.
    The style elements in this class are calculated for the current platform/device
    in the runtime, hence they have to be referenced by a `DynamicResource` XAML markup
    extension when dealing with markup rather than code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理常见的排版控件，如`Label`或`Entry`字段时，最简单的方法是使用`Device.Styles`类中可用的内置样式来符合特定设备的布局或无障碍性要求。有几个样式元素，如`BodyStyle`、`SubtitleStyle`和`CaptionStyle`，可以用来解决常见的实现问题。这个类中的样式元素在运行时为当前平台/设备计算，因此当处理标记而不是代码时，必须通过`DynamicResource`
    XAML标记扩展来引用。
- en: 'A simple label using the `TitleStyle` can be implemented as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TitleStyle`实现的简单标签如下：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It can also be declared in the markup file as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在标记文件中声明如下：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another useful platform-specific typography-related utility is the `NamedSize`
    enumeration. The `NamedSize` enumeration can be used with the `Device.GetNamedSize`
    method to choose the most suitable font size in the target platform for a text
    field. The enumeration provides four built-in options for different scenarios:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的特定平台字体相关实用工具是 `NamedSize` 枚举。`NamedSize` 枚举可以与 `Device.GetNamedSize` 方法一起使用，以在目标平台中选择文本字段最合适的字体大小。枚举提供了四种内置选项，适用于不同场景：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A built-in converter can also be used to include the font size in XAML markup:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 内置转换器也可以用于在 XAML 标记中包含字体大小：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For more general implementation requirements, `Device.Idiom` and `Device.OS`
    provide valuable target platform information related to the type of device (desktop,
    phone, tablet, and so on) and the operating system of the device (Android, iOS,
    Windows, or Windows Phone) respectively.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更通用的实现需求，`Device.Idiom` 和 `Device.OS` 分别提供了有关设备类型（桌面、手机、平板电脑等）和设备操作系统（Android、iOS、Windows
    或 Windows Phone）的有价值的目标平台信息。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, Windows Phone 8.1 and Windows Phone Silverlight versions cannot be
    differentiated using the `Device.OS` property. Conditional compilation can be
    used as a replacement for this distinction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，无法使用 `Device.OS` 属性区分 Windows Phone 8.1 和 Windows Phone Silverlight 版本。可以使用条件编译作为这种区分的替代方案。
- en: Additionally, the `Device.OnPlatform` function and its XAML extension counterpart
    can help developers implement platform-specific styles. The `OnPlatform` function
    uses three values for each platform and returns the appropriate value according
    to the `Device.OS` property.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Device.OnPlatform` 函数及其 XAML 扩展对应函数可以帮助开发者实现特定平台样式。`OnPlatform` 函数为每个平台使用三个值，并根据
    `Device.OS` 属性返回适当的值。
- en: 'Visualizing a label using the `OnPlatform` function would look similar to the
    following snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OnPlatform` 函数可视化标签将类似于以下代码片段：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or, using the XAML markup extension, it would look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 XAML 标记扩展，它将看起来像这样：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Device.OnPlatform` function has another overload that can be used to execute
    certain actions according to current operating system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Device.OnPlatform` 函数还有一个重载，可以根据当前操作系统执行某些操作。'
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Briefly, Xamarin.Forms provides the toolset to increase code-sharing between
    platform-specific projects and provide developers with a uniform experience when
    developing UI components for these projects. The Xamarin.Forms framework, in general,
    proves to be indispensable, especially for cross-platform implementation where
    platform-dependent feature requirements are minimal.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Xamarin.Forms 提供了一套工具集，用于增加特定平台项目之间的代码共享，并为开发者提供在为这些项目开发 UI 组件时的统一体验。总的来说，Xamarin.Forms
    框架证明是不可或缺的，尤其是在跨平台实现中，平台依赖性功能需求最小。
- en: This uniform abstraction layer is responsible for rendering the platform-specific
    UI controls and creating native experience for the users. This layer can also
    be extended using various features and patterns, some of which were discussed
    in this chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个统一的抽象层负责渲染特定平台的 UI 控件，并为用户提供原生体验。此层还可以通过各种功能和模式进行扩展，其中一些在本章中已讨论。
- en: We will be focusing on more re-usable view elements and implementation patterns
    in the next chapter. Xamarin.Forms will again be referenced in this context.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注更多可重用视图元素和实现模式。Xamarin.Forms 将再次在此背景下被引用。
