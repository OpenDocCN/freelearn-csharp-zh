["```cs\nusing System.Collections;\nHashtable hashtable = new()\n{\n    { \"Key #1\", \"Value #1\" },\n    { \"Key #2\", \"Value #2\" }\n};\nhashtable.Add(\"Key #3\", \"Value #3\");\nhashtableKey #1 and Key #2), by using the Add method (Key #3) or by using the indexer (Key #4).\nWhen you use the indexer to set a value for an already existing key, the value of this element is updated. A different behavior occurs while using the `Add` method because it throws an exception when an item with the same key already exists in the collection. You can handle this situation by using the `try-catch` statement, but there is a much better approach to check whether such an entry already exists – using the `ContainsKey` method. This will be shown a bit later.\nIt is worth mentioning that the `null` value is incorrect for the key of an element, but it is acceptable as a value of an element.\nYou can easily gain access to a particular element using the indexer. As the `Hashtable` class is a non-generic variant of hash table-related classes, you need to cast the returned result to the proper type (for example, `string`), as shown here:\n\n```", "```cs\nforeach (DictionaryEntry entry in hashtable)\n{\n    Console.WriteLine($\"{entry.Key}: {entry.Value}\");\n}\n```", "```cs\nNAME ---> PHONE\nMarcin -> 101-202-303\nJohn ---> 202-303-404\nAline --> 303-404-505\n```", "```cs\nHashtable phoneBook = new()\n{\n    { \"Marcin\", \"101-202-303\" },\n    { \"John\", \"202-303-404\" }\n};\nphoneBookCount property and comparing its value with 0, as presented here:\n\n```", "```cs\n\n Then, you can iterate through all the pairs:\n\n```", "```cs\n\n Finally, let’s see how we can check whether a specific key exists in the collection, as well as how to get its value. The first task can be accomplished just by calling the `ContainsKey` method, which returns a value indicating whether a suitable element exists (`true`) or not (`false`). To get a value, you can use the indexer. Please keep in mind that you must cast the returned value to a suitable type, such as `string` in this example. This requirement is caused by the non-generic version of the hash table-related class. This code is as follows:\n\n```", "```cs\n\n Your first program using the hash table is ready! After launching it, you should receive a result similar to the following:\n\n```", "```cs\n\n It is worth noting that the order of the pairs stored using the `Hashtable` class is not consistent with the order of their addition or keys. For this reason, if you need to present the sorted results, you need to sort the elements on your own or use another data structure, namely `SortedDictionary`, which is described later in this book.\nNow, let’s take a look at one of the most common classes used while developing in C#, namely `Dictionary`, which is a generic version of hash table-related classes.\nDictionaries\nIn the previous section, you learned about the `Hashtable` class, a non-generic variant of the hash table-related classes. However, it has a significant limitation, because it does not allow you to specify a type of a key and a value. Both the `Key` and `Value` properties of the `DictionaryEntry` class are of the `object` type. Therefore, you need to perform boxing and unboxing operations, even if all the keys and values are of the same type. If you want to benefit from the `Dictionary` generic class, which is the main subject of this section.\nFirst of all, you should specify two types, namely a type of a key and a value, while creating an instance of the `Dictionary` class. Moreover, it is possible to define the initial content of the dictionary using the following code:\n\n```", "```cs\n\n In the preceding code, a new instance of the `Dictionary` class is created. It stores `string`-based keys and values. Here, two entries exist in the dictionary, namely `Key #1` and `Key #2`. Their values are `Value #1` and `Value #2`.\nSimilar to the `Hashtable` class, you can also use the indexer to get access to a particular element within the collection, as shown in the following line of code:\n\n```", "```cs\ndictionarykey cannot be equal to null, but value can be if it is allowed by the type of values stored in the collection.\nWhere can you find more information?\nYou can find content regarding a dictionary at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2).\nThe `Dictionary` class is equipped with a few properties:\n\n*   `Count`, which gets the number of stored elements\n*   `Keys`, which returns the collection of keys\n*   `Values`, which returns the collection of values\n\nYou can also use some available methods:\n\n*   `Add`, which adds a new element to the dictionary\n*   `Remove`, which removes an element from the dictionary\n*   `Clear`, which removes all the elements from the dictionary\n*   `ContainsKey`, which checks whether the dictionary contains a key\n*   `ContainsValue`, which checks whether the dictionary contains a given value\n*   `TryGetValue`, which tries to get a value for a given key from the dictionary\n\nAs you can see, many properties and methods are almost the same as in the case of the `Hashtable` class. The consistency of naming allows you to easily use various classes without the necessity of learning everything from scratch.\nWhat about performance?\nYou should remember that the performance of getting a value of an element (using an indexer or `TryGetValue`), updating an existing one (using an indexer), and checking whether the given key exists in the dictionary (`ContainsKey`) approaches the *O(1)* operation. However, the process of checking whether the collection contains a given value (`ContainsValue`) is the *O(n)* operation and requires you to search the entire collection for the particular value.\nIf you want to iterate through all pairs stored in the collection, you can use a `foreach` loop. However, the variable that’s used in the loop is an instance of the `KeyValuePair` generic class with `Key` and `Value` properties, allowing you to access the key and the value. This `foreach` loop is shown in the following code snippet:\n\n```", "```cs\n\n Here, you can also apply what you’ve learned about value tuples and the deconstruct operation. Thus, the preceding `foreach` loop can be simplified, as shown here:\n\n```", "```cs\n\n As you can see, the C# language is being equipped with more and more useful features that make your code shorter, simpler, and easier to understand. You should keep an eye on the updates to the language. Good work, C# team – I am looking forward to more!\nThread-safe version\nDo you remember a thread-safe queue-related class from the previous chapter? If so, the situation looks quite similar in the case of `Dictionary` because the `ConcurrentDictionary` class (from the `System.Collections.Concurrent` namespace) is available.\nWith this short introduction, let’s start coding! In the following sections, you will find two real-world examples that use dictionaries for storing data.\nExample – product location\nThe first example we’ll look at is an application that helps employees of a shop to find a product’s location. Let’s imagine that each employee has a phone with your application on it, which is used to scan a barcode of the product, and the application tells them that the product should be located in area `A1` or `C9`. Sounds interesting, doesn’t it?\nAs the number of products in the shop is often very high, it is necessary to find results very quickly. For this reason, the data of products, together with their locations, is stored in the hash table, using the generic `Dictionary` class. The key is the barcode (`string`), while the value is the area code (also `string`), as shown here:\n\n```", "```cs\n\n First, you create a new collection and add some data:\n\n```", "```cs\n\n The code shows two ways of adding elements to the collection, namely by passing their data while creating a new instance of the class and by using the indexer. A third solution also exists and uses the `Add` method, as shown in the following part of the code:\n\n```", "```cs\n\n Another solution uses the `TryAdd` method, as presented here:\n\n```", "```cs\n\n In the following part of the code, you present data of all the products that are available in the system. To do so, you use the `foreach` loop. Before that, you check whether there are any elements in the dictionary. If not, the proper message is presented to the user. Otherwise, keys and values from all pairs are presented in the console:\n\n```", "```cs\n\n Now, let’s take a look at the part of the code that makes it possible to find the location of the product by its barcode. To do so, you can use `TryGetValue` to check whether the element exists. If so, a message with the target location is presented in the console. Otherwise, other information is shown. The code is presented here:\n\n```", "```cs\n\n When you run the program, you see a list of all the products in the shop and the program asks you to enter the barcode. After typing it, you receive a message containing the area code. The result that’s shown in the console should be similar to the following:\n\n```", "```cs\n\n You’ve just completed the first example! Let’s proceed to the next one.\nExample – user details\nThis second example shows you how to store more complex data in the dictionary. In this scenario, you’ll create an application that shows details of a user based on their identifier, as shown here:\n\n```", "```cs\n\n The program starts with the data of three users. You should be able to enter an identifier and see details of the found user. Of course, the situation of the non-existence of a given user should be handled by presenting the proper information in the console.\nFirst, let’s add the `Employee` record, which stores data of an employee, namely first name, last name, and phone number. The code is as follows:\n\n```", "```cs\n\n Then, create a new instance of the `Dictionary` class and add data to it:\n\n```", "```cs\n\n The most interesting operations are performed in the following `do-while` loop:\n\n```", "```cs\n\n First, the user is asked to enter an identifier of the employee, which is then parsed to the integer value. The loop is stopped when the provided identifier cannot be parsed to the integer value. Otherwise, the `TryGetValue` method is used to try to get details of the user. If the user is found (`TryGetValue` returns `true`), the details are presented in the console. Otherwise, an error message is shown.\nWhen you run the application and enter some data, you will receive the following result:\n\n```", "```cs\n\n That’s all! You’ve completed two examples showing how to use dictionaries while developing applications in the C# language. Do you remember that another kind of dictionary was already mentioned, namely a sorted dictionary? Are you interested in finding out what it is and how you can use it in your programs? If so, move on to the next section.\nSorted dictionaries\nBoth non-generic and generic variants of the hash table-related classes do not keep the order of the elements. For this reason, if you need to present data from the collection sorted by keys, you need to sort them before presenting them. However, you can use another data structure, known as a **sorted dictionary**, to solve this problem and **keep keys sorted all the time**. Therefore, you can easily get the sorted collection if necessary.\nImagine a sorted dictionary\nIf you want to better imagine a sorted dictionary, remember the times from a dozen or so years ago, when the internet was not as popular and widespread as it is today, and at home there was a book on your shelf that allowed you to learn the meaning of a word in another language. How does it work? Let’s assume that you have a Polish-English dictionary, thanks to which you can find out how to translate a specific word from Polish to English, such as *cześć* to *hello*. You open this book and look for words that start with the letter *c*. Found! Now, you are browsing through words starting with *c* to find the one you are interested in, namely *cześć*. Fortunately, it’s not that complicated because all the words are listed in the dictionary in alphabetical order. And that’s how a sorted dictionary works! You can easily view all the items in the dictionary in alphabetical order. You can also quickly check if the dictionary contains a specific key and what its value is. Today, you just enter a foreign word in a search engine and you instantly know what it means in your language, as well as in probably any other language in the world. You like this kind of technological progress, don’t you?\nThe sorted dictionary is implemented as the `SortedDictionary` generic class, available in the `System.Collections.Generic` namespace. You can specify types for keys and values while creating a new instance of `SortedDictionary`. An item key cannot be equal to `null`, but its value can be if it is allowed by the type of values stored in the collection. Moreover, the class contains similar properties and methods to `Dictionary`.\nWhere can you find more information?\nYou can find content regarding a sorted dictionary at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2).\n The exemplary application is as follows:\n\n```", "```cs\nNAME     -> EXPLANATION\nLancut   -> A city located near Rzeszow, with a castle.\nRzeszow  -> A capital of the Subcarpathian voivodeship.\nWarszawa -> A capital city of Poland.\nZakopane -> A city located in Tatra mountains in Poland.\n```", "```cs\nConsole.WriteLine(\"Welcome to your encyclopedia!\\n\");\nSortedDictionary<string, string> definitions = [];\ndo\n{\n    Console.WriteLine(\"\\nChoose option ([A]dd, [L]ist): \");\n    ConsoleKeyInfo keyInfo = Console.ReadKey(true);\n    if (keyInfo.Key == ConsoleKey.A)\n    {\n        Console.Write(\"Enter the key: \");\n        string key = Console.ReadLine() ?? string.Empty;\n        Console.Write(\"Enter the explanation: \");\n        string explanation = Console.ReadLine()\n            ?? string.Empty;\n        definitions[key] = explanation;\n    }\n    else if (keyInfo.Key == ConsoleKey.L)\n    {\n        foreach ((string k, string e) in definitions)\n        {\n            Console.WriteLine($\"{k}: {e}\");\n        }\n    }\n    else\n    {\n        Console.WriteLine(\"Do you want to exit? Y or N.\");\n        if (Console.ReadKey().Key == ConsoleKey.Y)\n        {\n            break;\n        }\n    }\n}\nwhile (true);\n```", "```cs\nWelcome to your encyclopedia!\nChoose option ([A]dd, [L]ist):\nEnter the key: Zakopane\nEnter the explanation: A city located in Tatra mountains in Poland.\nChoose option ([A]dd, [L]ist):\nEnter the key: Rzeszow\nEnter the explanation: A capital of the Subcarpathian voivodeship.\nChoose option ([A]dd, [L]ist):\nRzeszow: A capital of the Subcarpathian voivodeship.\nZakopane: A city located in Tatra mountains in Poland.\nChoose option ([A]dd, [L]ist):\nDo you want to exit? Y or N.\n```", "```cs\nHashSet<int> usedCoupons = [];\ndo\n{\n    Console.Write(\"Enter the number: \");\n    string number = Console.ReadLine() ?? string.Empty;\n    if (!int.TryParse(number, out int coupon)) { break; }\n    if (usedCoupons.Contains(coupon))\n    {\n        Console.WriteLine(\"Already used.\");\n    }\n    else\n    {\n        usedCoupons.Add(coupon);\n        Console.WriteLine(\"Thank you!\");\n    }\n}\nwhile (true);\n```", "```cs\nConsole.WriteLine(\"\\nUsed coupons:\");\nforeach (int coupon in usedCoupons)\n{\n    Console.WriteLine(coupon);\n}\n```", "```cs\nEnter the number: 100\nThank you!\nEnter the number: 101\nThank you! (...)\nEnter the number: 101\nAlready used.\nEnter the number:\nUsed coupons:\n100\n101\n500\n345\n```", "```cs\nenum PoolTypeEnum\n{\n    Recreation,\n    Competition,\n    Thermal,\n    Kids\n};\n```", "```cs\nRandom random = new();\n```", "```cs\nDictionary<PoolTypeEnum, HashSet<int>> tickets = new()\n{\n    { PoolTypeEnum.Recreation, new() },\n    { PoolTypeEnum.Competition, new() },\n    { PoolTypeEnum.Thermal, new() },\n    { PoolTypeEnum.Kids, new() }\n};\n```", "```cs\nfor (int i = 1; i < 100; i++)\n{\n    foreach ((PoolTypeEnum p, HashSet<int> t) in tickets)\n    {\n        if (random.Next(2) == 1) { t.Add(i); }\n    }\n}\n```", "```cs\nConsole.WriteLine(\"Number of visitors by a pool type:\");\nforeach ((PoolTypeEnum p, HashSet<int> t) in tickets)\n{\n    Console.WriteLine($\"- {p}: {t.Count}\");\n}\n```", "```cs\nPoolTypeEnum maxVisitors = tickets\n    .OrderByDescending(t => t.Value.Count)\n    .Select(t => t.Key)\n    .FirstOrDefault();\nConsole.WriteLine($\"{maxVisitors} - the most popular.\");\n```", "```cs\nHashSet<int> any = new(tickets[PoolTypeEnum.Recreation]);\nany.UnionWith(tickets[PoolTypeEnum.Competition]);\nany.UnionWith(tickets[PoolTypeEnum.Thermal]);\nany.UnionWith(tickets[PoolTypeEnum.Kids]);\nConsole.WriteLine($\"{any.Count} people visited\n    at least one pool.\");\n```", "```cs\nHashSet<int> all = new(tickets[PoolTypeEnum.Recreation]);\nall.IntersectWith(tickets[PoolTypeEnum.Competition]);\nall.IntersectWith(tickets[PoolTypeEnum.Thermal]);\nall.IntersectWith(tickets[PoolTypeEnum.Kids]);\nConsole.WriteLine($\"{all.Count} people visited all pools.\");\n```", "```cs\nNumber of visitors by a pool type:\n- Recreation: 60\n- Competition: 40\n- Thermal: 47\n- Kids: 45\nRecreation - the most popular.\n91 people visited at least one pool.\n10 people visited all pools.\n```", "```cs\nList<string> names =\n[\n    \"Marcin\", \"Mary\", \"James\", \"Albert\", \"Lily\",\n    \"Emily\", \"marcin\", \"James\", \"Jane\"\n];\nSortedSet<string> sorted = new(\n    names,\n    Comparer<string>.Create((a, b) =>\n        a.ToLower().CompareTo(b.ToLower())));\nforeach (string name in sorted)\n{\n    Console.WriteLine(name);\n}\n```", "```cs\nAlbert\nEmily\nJames\nJane\nLily\nMarcin\nMary\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```"]