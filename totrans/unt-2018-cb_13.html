<html><head></head><body>
        

                            
                    <h1 class="header-title">Navigation Meshes and Agents</h1>
                
            
            
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>NPC to travel to destination while avoiding obstacles</li>
<li>NPC to seek or flee from a moving object</li>
<li>Point-and-click move to object</li>
<li>Point-and-click move to tile</li>
<li>Point-and-click raycast with user-defined higher-cost Navigation Areas</li>
<li>NPC to follow waypoints in sequence</li>
<li>Controlling object group movement through flocking</li>
<li>Creating a movable NavMesh Obstacle</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Unity provides <strong>Navigation Meshes</strong> and Artificial Intelligence (AI) Agents that can plan pathways and move objects along those calculated paths. <strong>Pathfinding</strong> is a classic AI task, and Unity has provided game developers with fast and efficient <strong>Pathfinding</strong> components that work out of the box.</p>
<p>Having objects that can automatically plot and follow paths from their current location to a desired destination point (or a moving object) provides the components to many different kinds of interactive game characters and mechanics. For example, we can create point-and-click games by clicking on a location or object, towards which we wish one or more characters to travel. Or, we can have enemies that "wake up" when our player's character is nearby, and move towards (seek) our player, perhaps then going into combat or dialogue mode once they are within a short distance of our player's character.</p>
<p class="mce-root"/>
<p>Or, objects can collectively flock together, moving as a swarm towards a common destination.</p>
<p>This chapter explores ways to exploit Unity's navigation-based AI components to control game character <strong>Pathfinding</strong> and movement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>At the core of Unity's navigation system are two concepts/components:</p>
<ul>
<li><strong>Navigation Meshes</strong></li>
<li><strong>Navigation Mesh Agents</strong></li>
</ul>
<p>A Navigation <strong>Mesh</strong> defines the areas of the world that are navigable. It is usually represented as a set of polygons (2D shapes), so that a path to a destination is plotted as the most efficient sequence of adjacent polygons to follow, taking into account the need to avoid non-navigable obstacles.</p>
<p>The <strong>Agent</strong> is the object that needs to calculate (plot) a path through the mesh from its current position to its desired destination position. <strong>NavMesh Agents</strong> have properties such as a stopping distance, so they aim to arrive at a point a certain distance from the target coordinates, and auto braking, so they gradually slow down as they get close to their destination.</p>
<p>A <strong>Navigation Mesh</strong> can be made up of <strong>Areas</strong> that have different "costs." The default cost for an area is 1. However, to make a more realistic path calculation by AI Agent controlled characters, we might want to model the additional effort it takes to travel through water, or mud, or up a steep slope. Therefore, Unity allows us to define custom Areas, with names that we choose (such as Water or Mud), and associated costs, such as 2 (that is, water is twice as tiring to travel through).</p>
<p>Different navigable areas can be connected via <strong>NavMesh Links:</strong></p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/class-NavMeshLink.html">https://docs.unity3d.com/Manual/class-NavMeshLink.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Run-Time Nav Mesh Obstacles</h1>
                
            
            
                
<p>The most efficient way for games to work with <strong>Navigation Meshes</strong> is to pre-calculate the costs of polygons in the game world; this is known as <strong>Baking</strong> and is performed at <strong>Design-Time</strong>, before we run the game.</p>
<p class="mce-root"/>
<p>However, sometimes there will be features in the game that we wish to use to influence navigation decisions and route planning differently at different times in the game, that is, dynamic Run-Time navigation obstacles. Unity provides a <strong>NavMesh Obstacle</strong> component, which can be added to GameObjects, and has features such as "carving out" (temporarily removing) areas of a <strong>NavMesh</strong> to force AI-Agents to recalculate paths that avoid areas blocked by GameObjects with <strong>NavMesh Obstacle</strong> components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Source of further information about Unity and AI navigation</h1>
                
            
            
                
<p>Some <strong>NavMesh</strong> features (such as <strong>NavMesh Links</strong> and dynamic mesh baking at <strong>Run-Time</strong>) are not part of the standard Unity installation and require additional installation. Learn more about these components, their APIs, and how to install them here:</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html" target="_blank">https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html" target="_blank">https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html</a></li>
</ul>
<p>Learn more about Unity <strong>NavMeshes</strong> from the Unity Technologies tutorial, which is available here:</p>
<ul>
<li><a href="http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes" target="_blank">http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes</a></li>
</ul>
<p>Learn lots about computer-controlled moving GameObjects from the classic paper entitled <strong>Steering Behaviors For Autonomous Characters</strong> by Craig W. Reynolds, presented at the GDC-99 (Game Developer's Conference):</p>
<ul>
<li><a href="http://www.red3d.com/cwr/steer/gdc99/" target="_blank">http://www.red3d.com/cwr/steer/gdc99/</a></li>
</ul>
<p>While the Unity development community have been asking for 2D <strong>NavMeshes</strong> for some years now, they've not yet been released as a core feature. There is a lot of online information about how to write your own <strong>Pathfinding</strong> system that would work in 2D. A good thread with plenty of links can be found at <strong>TIGForums</strong>:</p>
<ul>
<li><a href="https://forums.tigsource.com/index.php?topic=46325.0" target="_blank">https://forums.tigsource.com/index.php?topic=46325.0</a></li>
</ul>
<p class="mce-root"/>
<p>In this chapter, you'll learn how to add <strong>NavMesh Agents</strong> to control characters and how to work with your game environment to specify and bake <strong>Navigation Meshes</strong> for a scene. Some recipes explore how to create point-and-click style games, where you indicate where you want a character to navigate to by clicking on an object or point in the game world.</p>
<p>You'll create "swarms" of objects that move and flock together, and you'll also learn to add <strong>NavMesh Obstacle</strong> components to moving GameObjects, forcing AI agents to dynamically recalculate their paths at <strong>Run-Time</strong> due to objects moving in their way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NPC to travel to destination while avoiding obstacles</h1>
                
            
            
                
<p>The introduction of Unity's <strong>NavMeshAgent</strong> has greatly simplified the coding for NPC (Non-Player Character) and enemy agent behaviors. In this recipe, we'll add some wall obstacles (scaled cubes), and generate a <strong>NavMesh</strong> so that Unity knows not to try to walk through walls. We'll then add a <strong>NavMeshAgent</strong> component to our NPC GameObject, and tell it to head to a stated destination location by intelligently planning and following a path, while avoiding the wall obstacles.</p>
<p>When the Navigation panel is visible, then the Scene panel displays the blue-shaded walkable areas, as well as unshaded, non-walkable areas at the edge of the terrain and around each of the two wall objects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/048040cc-d5f7-4f63-a674-d305ba4c62e6.png" style="width:31.42em;height:11.75em;"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The required Terrain TextureSandAlbedo can be found in the 15_01 folder. Alternatively, you can go to Assets |Import Package | Environments, deselect everything, and then locate and tick this asset: Assets/Environment/TerrainAssets/SurfaceTextures/SandAlbedo.psd</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To make an NPC to travel to a destination while avoiding obstacles, follow these steps:</p>
<ol>
<li>Create a new, empty 3D project.</li>
<li>Create a new 3D Terrain, choose menu: Create | 3D Object | Terrain. With this new Terrain GameObject selected in the Hierarchy, in its Inspector properties set its size to 30 x 20, and its position to (-15, 0, -10) so we have this GameObject centered at (0,0,0).</li>
<li>Texture paint this terrain with the SandAlbedo texture.</li>
<li>Create a 3D Capsule named Capsule-destination at (-12, 0, 8). This will be the target destination for our NPC self-navigating GameObject.</li>
<li>Create a sphere named Sphere-arrow that is positioned at (2, 0.5, 2). Scale it to (1,1,1).</li>
<li>Create a second sphere named Sphere-small. Scale it to (0.5, 0.5, 0.5).</li>
<li>In the Hierarchy, child Sphere-small to Sphere-arrow and position it at (0, 0, 0.5):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5fbaa0f-cc6c-4038-b19c-0245d10cd029.png" style="width:26.42em;height:11.58em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="8">
<li>In the Inspector panel, add a new NavMeshAgent to Sphere-arrow. Do this by choosing menu: Add Component | Navigation | Nav Mesh Agent.</li>
<li>Set the Stopping Distance property of the NavMeshAgent component to 2:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/fce3dcbe-0bba-4392-9583-b76fd15ba6dc.png" style="width:28.83em;height:14.67em;"/></p>
<ol start="10">
<li>Create the <kbd>ArrowNPCMovement</kbd> C# script-class, and add an instance-object to the Sphere-arrow GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class ArrowNPCMovement : MonoBehaviour {<br/> public GameObject targetGo;<br/> private NavMeshAgent navMeshAgent;<br/><br/>void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> HeadForDestintation();<br/> }<br/><br/>private void HeadForDestintation () {<br/> Vector3 destination = targetGo.transform.position;<br/> navMeshAgent.SetDestination (destination);<br/> }<br/> }</pre>
<ol start="11">
<li>Ensure that Sphere-arrow is selected in the Inspector panel. For the ArrowNPCMovement scripted component, drag Capsule-destination over the Target Go variable.</li>
<li>Create a 3D Cube named Cube-wall at (-6, 0, 0), and scale it to (1, 2, 10).</li>
<li>Create another 3D Cube named Cube-wall2 at (-2, 0, 6), and scale it to (1, 2, 7).</li>
<li>Display the Navigation panel by choosing menu: Window | Navigation.</li>
</ol>
<p>A great place to dock the Navigation panel is next to the Inspector panel since you will never be using the Inspector and Navigation panels at the same time.</p>
<ol start="15">
<li>In the Hierarchy panel, select both of the Cube-wall objects (we select the objects that are not supposed to be a part of the walkable parts of our scene), and then in the Navigation panel, click the <strong>Object</strong> button and check the Navigation Static checkbox:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a6c23855-9001-4ce4-a621-e9d37cc79a66.png" style="width:42.25em;height:13.42em;"/></p>
<ol start="16">
<li>In the Inspector, click on the Bake button at the top for baking options. Then, click on the Bake button at the bottom-right to create your Navigation Mesh asset:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c2537923-7f65-4e30-a5ef-9379e266c76a.png" style="width:42.25em;height:12.50em;"/></p>
<ol start="17">
<li>When the Navigation panel is displayed, you'll see a blue tint on the parts of the Scene that are areas for a NavMeshAgent to consider for its navigation paths.</li>
<li>Now, run your game. You will see the Sphere-arrow GameObject automatically move towards the Capsule-destination GameObject, following a path that avoids the two wall objects.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The NavMeshAgent component that we added to Sphere-arrow GameObject does most of the work for us. NavMeshAgents need two things:</p>
<ul>
<li>A destination location to head towards</li>
<li>ANavMesh component of the terrain with walkable/non-walkable areas, so that it can plan a path by avoiding obstacles</li>
</ul>
<p>We created two obstacles (the Cube-wall objects), and these were selected when we created the NavMesh for this scene in the Navigation panel. When the Navigation panel is displayed, at the same time in the Scene panel (and the Game panel with Gizmos enabled), we see walkable areas forming a blue navigation mesh.</p>
<p>Note: The blue areas are the default NavMesh Area. See, later in this chapter, a recipe for different, custom named, costed, color-coded NavMesh Areas.</p>
<p>The location for our NPC object to travel towards is the position of the Capsule-destination GameObject at (-12, 0, 8); but, of course we could just move this object in the Scene panel at Design-Time, and its new position would be the destination when we run the game.</p>
<p>The <kbd>ArrowNPCMovement</kbd> C# script class has two variables: one is a reference to the destination GameObject, and the second is a reference to the NavMeshAgent component of the GameObject, in which our instance of the <kbd>ArrowNPCMovement</kbd> class is also a component. When the scene starts, the NavMeshAgent sibling component is found via the <kbd>Start()</kbd> method, and the <kbd>HeadForDestination()</kbd> method is called, which sets the destination of the NavMeshAgent to the position of the destination GameObject.</p>
<p>Once the NavMeshAgent has a target to head towards, it will plan a path there and will keep moving until it arrives (or gets within the Stopping Distance if that parameter has been set to a distance greater than zero).</p>
<p>In the Scene panel, if you select the GameObject that contains the NavMeshAgent and choose the Show Avoidance Gizmo, then you can see the candidate local target positions the agent is considering. The lighter the squares are, the better a position ranks.</p>
<p class="mce-root"/>
<p>The darker red the squares are, the less desirable the position; so, dark red squares indicate positions to avoid, since they might, for instance, cause the agent to collide with a NavMesh Static obstacle:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0e9d87d2-7baf-448c-afca-5c874029bf90.png" style="width:26.25em;height:17.50em;"/></p>
<p>Ensure that the object with the NavMeshAgent component is selected in the Hierarchy panel at <strong>Run-Time</strong> to be able to see this navigation data in the Scene panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NPC to seek or flee from a moving object</h1>
                
            
            
                
<p>Rather than a destination that is fixed when the scene starts, let's allow the Capsule-destination object to be moved by the player while the scene is running. In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination to wherever Capsule-destination has been moved to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To make an NPC seek or flee from a moving object, follow these steps:</p>
<ol>
<li>In the Inspector, add a Rigid Body Physics component to GameObject Capsule-destination.</li>
<li>In the Inspector, for the Capsule-destination GameObject, check the Freeze Position constraint for the Y axis in the Constraints options of the RigidBody component. This will prevent the object moving in the Y-axis due to collisions when being moved.</li>
<li>Create the <kbd>SimplePlayerControl</kbd> C# script-class, and add an instance-object as a component to the Capsule-destination GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/> public class SimplePlayerControl : MonoBehaviour {<br/> public float speed = 1000;<br/> private Rigidbody rigidBody;<br/> private Vector3 newVelocity;<br/><br/> private void Start() {<br/> rigidBody = GetComponent&lt;Rigidbody&gt;();<br/> }<br/><br/> void Update() {<br/>   float xMove = Input.GetAxis("Horizontal") * speed * Time.deltaTime;<br/>   float zMove = Input.GetAxis("Vertical") * speed * Time.deltaTime;<br/>   newVelocity = new Vector3(xMove, 0, zMove);<br/> }<br/><br/> void FixedUpdate() {<br/>   rigidBody.velocity = newVelocity;<br/> }<br/>}</pre>
<ol start="4">
<li>Update the <kbd>ArrowNPCMovement</kbd> C# script-class so that we call the <kbd>HeadForDestintation()</kbd> method every frame, that is, from <kbd>Update()</kbd>, rather than just once in <kbd>Start()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void Start() {<br/>     navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> }<br/><br/> private void Update() {<br/>     HeadForDestintation();<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>SimplePlayerControl</kbd> script-class detects arrow key presses and translates them into a force to apply to move the Capsule-destination GameObject in the desired direction.</p>
<p>The <kbd>Update()</kbd> method of the <kbd>ArrowNPCMovement</kbd> script-class makes the NavMeshAgent update its path <strong>every</strong> frame, based on the current position of the Capsule-destination GameObject. As the user moves Capsule-destination, so the NavMeshAgent calculates a new path to the object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>Here are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a Debug Ray to show a source-to-destination line</h1>
                
            
            
                
<p>It's useful to use a visual Debug Ray to show us the straight line from the NPC with the NavMeshAgent to the current destination it is trying to navigate towards. Since this is a common thing we may wish to do for many games, it's useful to create a static method in a general-purpose class, and then the ray can be drawn with a single statement.</p>
<p>To use a Debug Ray to draw a source-to-destination line, follow these steps:</p>
<ol>
<li>Create a <kbd>UsefulFunctions.cs</kbd> C# script-class, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class UsefulFunctions : MonoBehaviour {<br/> public static void DebugRay(Vector3 origin, Vector3 destination, Color c) {<br/> Vector3 direction = destination - origin;<br/> Debug.DrawRay(origin, direction, c);<br/> }<br/> }</pre>
<ol start="2">
<li>Now, add a statement at the end of the <kbd>HeadForDestination()</kbd> method in the <kbd>NPCMovement</kbd> C# script-class:</li>
</ol>
<pre style="padding-left: 60px">private void HeadForDestintation () {<br/>Vector3 destination = targetGo.transform.position;<br/>navMeshAgent.SetDestination (destination);<br/>// show yellow line from source to target<br/> UsefulFunctions.DebugRay(transform.position, destination, Color.yellow);<br/> }</pre>
<p>We can now see a yellow line in the Scene panel when the scene is running. We can also see this in the Game panel if the Gizmos option is selected (top-right of the Game panel title bar):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/37bd623b-435e-468e-9e93-6040dfc9c966.png" style="width:29.92em;height:12.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constantly updating NavMeshAgent destination to flee from Player's current location</h1>
                
            
            
                
<p>There are times when we want an AI-controlled NPC character to move <strong>away</strong> from another character, rather than go towards it. For example, an enemy with very low health might run away, and so gain time to regain its health before fighting again. Or, a wild animal might flee from any other character moving near it.</p>
<p>To instruct our NavMeshAgent to flee from the player's location, we need to replace the <kbd>ArrowNPCMovement</kbd> C# script class with the following:</p>
<pre> using UnityEngine;<br/> using UnityEngine.AI;<br/><br/> public class ArrowNPCMovement : MonoBehaviour {<br/> public float runAwayDistance = 10;<br/> public GameObject targetGO;<br/> private NavMeshAgent navMeshAgent;<br/><br/>void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> }<br/><br/>void Update() {<br/> Vector3 targetPosition = targetGO.transform.position;<br/> float distanceToTarget = Vector3.Distance(transform.position, targetPosition);<br/> if (distanceToTarget &lt; runAwayDistance)<br/> FleeFromTarget(targetPosition);<br/> }<br/><br/>private void FleeFromTarget(Vector3 targetPosition) {<br/> Vector3 destination = PositionToFleeTowards(targetPosition);<br/> HeadForDestintation(destination);<br/> }<br/><br/>private void HeadForDestintation (Vector3 destinationPosition) {<br/> navMeshAgent.SetDestination (destinationPosition);<br/> }<br/><br/>private Vector3 PositionToFleeTowards(Vector3 targetPosition) {<br/> transform.rotation = Quaternion.LookRotation(transform.position - targetPosition);<br/> Vector3 runToPosition = targetPosition + (transform.forward * runAwayDistance);<br/> return runToPosition;<br/> }<br/> }</pre>
<p>There is a public variable, <kbd>runAwayDistance</kbd>. When the distance to the enemy is less than the value of this <kbd>runAwayDistance</kbd> variable, then we'll instruct the computer-controlled object to flee in the opposite direction.</p>
<p>The <kbd>Start()</kbd> method caches a reference to the NavMeshAgent component.</p>
<p>The <kbd>Update()</kbd> method calculates whether the distance to the enemy is within <kbd>runAwayDistance</kbd>, and if so, it calls the <kbd>FleeFromTarget(...)</kbd> method, which passes the location of the enemy as a parameter.</p>
<p>The <kbd>FleeFromTarget(...)</kbd> method calculates a point that is the <kbd>runAwayDistance</kbd> in Unity units away from the Player's cube, in a direction that is directly away from the computer-controlled object. This is achieved by subtracting the enemy position vector from the current transform's position.</p>
<p class="mce-root"/>
<p>Finally, the <kbd>HeadForDestintation(...)</kbd> method is called, passing the flee-to position, which results in the NavMeshAgent being told to set the location as its new destination.</p>
<p>Unity units are arbitrary, since they are just numbers on a computer. However, in most cases, it simplifies things to think of distances in terms of meters (1 Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit = 1 kilogram). Of course, if your game is based on a microscopic world, or pan-galactic space travel, then you need to decide what each Unity unit corresponds to for your game context. For further discussion of units in Unity, check out this post about Unity measurements: <a href="http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487" target="_blank">http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487</a>.</p>
<p>The Debug Ray shows the point the NPC is aiming for, whether it be to flee away from the player's character, or to catch up and maintain a constant distance from it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/875ba89b-7b33-43f8-a4d6-0eae3ae64f5a.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maintain constant distance from target ("lurking" mode!)</h1>
                
            
            
                
<p>It is simple to adapt the previous code to have an NPC try to maintain a constant distance from a target object. It involves always moving towards a point that is <kbd>runAwayDistance</kbd> away from the target, regardless of whether this point is towards or away from the target.</p>
<p>Just remove the <kbd>If</kbd> statement in the <kbd>Update()</kbd> method:</p>
<pre>void Update() {<br/> Vector3 targetPosition = targetGO.transform.position;<br/> float distanceToTarget = Vector3.Distance(transform.position, targetPosition);<br/> FleeFromTarget(targetPosition);<br/> }</pre>
<p>However, with this variation, it might be better to have the method named something like <kbd>MoveTowardsConstantDistancePoint()</kbd> rather than <kbd>FleeFromTarget()</kbd>, since our NPC is sometimes fleeing and sometimes following.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Point-and-click move to object</h1>
                
            
            
                
<p>Another way to choose the destination for our Sphere-arrow GameObject is by the user clicking on an object on the screen, and then the Sphere-arrow GameObject moving to the location of the clicked object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e088434d-ad3e-48e6-a2aa-1f47e15c30ea.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the first recipe in this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create an object-based point-and-click mini-game, do the following:</p>
<ol>
<li>In the Inspector, add the Player Tag to the Sphere-arrow GameObject.</li>
<li>Delete the two 3D Cubes and the 3D Capsule-destination from the scene.</li>
<li>Create a <kbd>ClickMeToSetDestination</kbd> C# script-class containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class ClickMeToSetDestination : MonoBehaviour<br/> {<br/> private UnityEngine.AI.NavMeshAgent playerNavMeshAgent;<br/><br/>void Start() {<br/> GameObject playerGO = GameObject.FindGameObjectWithTag("Player");<br/> playerNavMeshAgent = playerGO.GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();<br/> }<br/><br/>private void OnMouseDown() {<br/> playerNavMeshAgent.SetDestination(transform.position);<br/> }<br/> }</pre>
<ol start="4">
<li>Add instance-objects of the <kbd>ClickMeToSetDestination</kbd> C# script-class as components to your 3D Cube, Sphere, and Cylinder.</li>
<li>Run the Scene. When you click on one of the 3D objects, the Sphere-arrow GameObject should navigate towards the clicked object.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>OnMouseDown()</kbd> method of the <kbd>ClickMeToSetDestination</kbd> C# script-class changes the destination of the NavMeshAgent in the Sphere-arrow GameObject to be the position of the clicked 3D object.</p>
<p>The <kbd>Start()</kbd> method of the <kbd>ClickMeToSetDestination</kbd> C# script-class gets a reference to the NavMeshAgent component of the GameObject tagged Player (that is, the Sphere-arrow GameObject).</p>
<p>Each time a different object is clicked, the NavMeshAgent inside the Sphere-arrow GameObject is updated to make the GameObject move towards the position of the clicked object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a mouse-over yellow highlight</h1>
                
            
            
                
<p>A good UX (<strong>User Experience</strong>) feedback technique is to visually indicate to the user when an object can be interacted with via the mouse. A common way to do this is to present an audio or visual effect when the mouse is moved over an interactable object.</p>
<p>We can create a Material with a yellow color, which can make an object appear yellow while the mouse is over it, and then return to its original material when the mouse is moved away.</p>
<p>Create the <kbd>MouseOverHighlighter</kbd> C# <kbd>script-class</kbd> with the following contents. Then, add an instance-object as a component to each of the three 3D GameObjects:</p>
<pre>using UnityEngine;<br/><br/>public class MouseOverHighlighter : MonoBehaviour<br/> {<br/> private MeshRenderer meshRenderer;<br/> private Material originalMaterial;<br/><br/>void Start() {<br/> meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br/> originalMaterial = meshRenderer.sharedMaterial;<br/> }<br/><br/>void OnMouseOver() {<br/> meshRenderer.sharedMaterial = NewMaterialWithColor(Color.yellow);<br/> }<br/><br/>void OnMouseExit() {<br/> meshRenderer.sharedMaterial = originalMaterial;<br/> }<br/><br/>private Material NewMaterialWithColor(Color newColor) {<br/> Shader shaderSpecular = Shader.Find("Specular");<br/> Material material = new Material(shaderSpecular);<br/> material.color = newColor;<br/><br/>return material;<br/> }<br/> }</pre>
<p>Now, when running the game, when your mouse is over one of the three objects, that object will be highlighted yellow. If you click on the mouse button when the object is highlighted, the Sphere-arrow GameObject will make its way up to (but stop just before) the clicked object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Point-and-click move to tile</h1>
                
            
            
                
<p>Rather than clicking specific objects to indicate the target for our AI-controlled agent, we can create a grid of 3D Plane (tile) objects to allow the player to click any tile to indicate a destination for the AI-controller character. So, any location can be clicked, rather than only one of a few specific objects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/75c0c4bd-eb2c-4547-bf06-7f611705fb5d.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>For this recipe, we have prepared a red-outlined black square Texture image named square_outline.png in a folder named Textures in the <kbd>15_04</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a point-and-click game making GameObjects to a selected tile, do the following:</p>
<ol>
<li>Delete your 3D Cube, Sphere, and Cylinder GameObjects from the scene.</li>
<li>Create a new 3D Plane object, scaled to (0.1, 0.1, 0.1).</li>
<li>Create a new Material with the Texture image square_outline.png provided (black square with a red outline). Apply this Material to your 3D Plane.</li>
<li>Add an instance-object of the <kbd>ClickMeToSetDestination</kbd> script-class as a component to your 3D Plane.</li>
<li>In the Project panel, create a new empty Prefab named tile.</li>
</ol>
<ol start="6">
<li>Populate your Prefab tile with the properties of your 3D Plane GameObject by dragging the plane GameObject over your Prefab tile (it should change from white to blue to indicate the Prefab now has the properties of your GameObject).</li>
<li>Delete your 3D Plane GameObject from the scene.</li>
<li>Create a new <kbd>TileManager</kbd> C# script-class containing the following, and add an instance-object as a component to the Main Camera GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class TileManager : MonoBehaviour {<br/> public int rows = 50;<br/> public int cols = 50;<br/> public GameObject prefabClickableTile;<br/><br/>void Start () {<br/> for (int r = 0; r &lt; rows; r++) {<br/> for (int c = 0; c &lt; cols; c++) {<br/> float y = 0.01f;<br/> Vector3 pos = new Vector3(r - rows/2, y, c - cols/2);<br/> Instantiate(prefabClickableTile, pos, Quaternion.identity);<br/> }<br/> }<br/> }<br/> }</pre>
<ol start="9">
<li>Select the Main Camera in the Hierarchy, and in the Inspector for the Tile Manager (Script) component, populate the Prefab Clickable Tile public property with your Prefab tile from the Project panel.</li>
<li>Run the scene. You should now be able to click on any of the small square tiles to set the destination of the NavMeshAgent controlled Sphere-arrow GameObject.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a Prefab, containing the properties of a 3D Plane named tile, which contained a component instance-object of the <kbd>ClickMeToSetDestination</kbd> C# script-class.</p>
<p>The <kbd>TileManager</kbd> script class loops to create 50 x 50 instances of this tile Gameobject in the Scene.</p>
<p>When you run the game, if you click on the mouse button when the mouse pointer is over a tile, the NavMeshAgent inside the Sphere-arrow GameObject is set to that tile's position. So, the Sphere-arrow GameObject will move towards, but stop just before reaching, the clicked tile position.</p>
<p>The <strong>Y</strong> value of 0.01 means the plane will be just above the Terrain, so we avoid any kind of Moire interference pattern due to meshes at the same location. By subtracting <kbd>rows/2</kbd> and <kbd>cols/2</kbd> for the <strong>X</strong> and <strong>Z</strong> positions, we center our grid of tiles at (0, Y, 0).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Yellow debug-ray to show destination of AI-agent</h1>
                
            
            
                
<p>We can show a debug ray from a moving object to its destination tile by creating the <kbd>MouseOverHighlighter</kbd> C# script-class with the following contents. We then add an instance-object as a component to the NavMeshAgent controlled Sphere-arrow GameObject:</p>
<pre>using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class DebugRaySourceDestination : MonoBehaviour {<br/> void Update() {<br/> Vector3 origin = transform.position;<br/> Vector3 destination = GetComponent&lt;NavMeshAgent&gt;().destination;<br/> Vector3 direction = destination - origin;<br/> Debug.DrawRay(origin, direction, Color.yellow);<br/> }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Point-and-click Raycast with user-defined higher-cost Navigation Areas</h1>
                
            
            
                
<p>Rather than indicating a desired destination by clicking an object or tile, we can use Unity's built-in <kbd>Physics.Raycast(...)</kbd> method to identify which Vector3 (x,y,z) position relates to the object surface in the game.</p>
<p>This involves translating from the 2D (x,y) screen position to an imagined 3D "ray" from the user's point of view, through the screen, into the game world, and identifying which object (polygon) it <strong>hits</strong> first.</p>
<p>This recipe uses <kbd>Physics.Raycast</kbd> to set the position of the location clicked on as the new destination for a NavMeshAgent controller object. The actual route followed can be influenced by defining Navigation Mesh Areas of different costs. For example, walking through mud or swimming through water can have a higher cost, since they would take longer, so the AI NavMeshAgent can calculate the lowest-cost route, which may not be the shortest distance route in the scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/baf3c66d-d516-42c3-aff4-84fb0eb05523.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a point-and-click game using a Raycast, do the following:</p>
<ol>
<li>Remove the Tile Manager (Script) component from the Main Camera GameObject.</li>
<li>Create a new 3D Sphere, named Sphere-destination, scaled to (0.5, 0.5, 0.5).</li>
<li>Create a new Material that is red in color, and assign this material to the Sphere-destination GameObject.</li>
</ol>
<ol start="4">
<li>Create a new <kbd>MoveToClickPoint</kbd> C# script-class containing the following, and add an instance-object as a component to the Sphere-arrow GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class MoveToClickPoint : MonoBehaviour {<br/> public GameObject sphereDestination;<br/> private NavMeshAgent navMeshAgent;<br/> private RaycastHit hit;<br/><br/>void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> sphereDestination.transform.position = transform.position;<br/> }<br/><br/>void Update() {<br/> Ray rayFromMouseClick = Camera.main.ScreenPointToRay(Input.mousePosition);<br/><br/>if (FireRayCast(rayFromMouseClick)){<br/> Vector3 rayPoint = hit.point;<br/> ProcessRayHit(rayPoint);<br/> }<br/> }<br/><br/>private void ProcessRayHit(Vector3 rayPoint) {<br/> if(Input.GetMouseButtonDown(0)) {<br/> navMeshAgent.destination = rayPoint;<br/> sphereDestination.transform.position = rayPoint;<br/> }<br/> }<br/><br/>private bool FireRayCast(Ray rayFromMouseClick) {<br/> return Physics.Raycast(rayFromMouseClick, out hit, 100);<br/> }<br/> }</pre>
<ol start="5">
<li>Select the Sphere-arrow GameObject in the Hierarchy, and in the Inspector for the MoveToClickPoint (Script) component, populate the Sphere Destination public property with your red Sphere-destination GameObject.</li>
</ol>
<ol start="6">
<li>Run the scene. You should now be able to click anywhere on the Terrain to set the destination of the NavMeshAgent controlled Sphere-arrow GameObject. As you click, the red Sphere-destination GameObject should be positioned at this new destination point, towards which the Sphere-arrow GameObject will navigate.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a small red 3D Sphere named Sphere-destination.</p>
<p>There is one public variable for the <kbd>MoveToClickPoint</kbd> scripted component of the Sphere-arrow GameObject. This public <kbd>sphereDestination</kbd> variable has been linked to the red Sphere-destination GameObject in the scene.</p>
<p>There are two private variables:</p>
<ul>
<li><kbd>navMeshAgent</kbd>: This will be set to refer to the NavMeshAgent component of the Sphere-arrow GameObject, so its destination can be reset when appropriate.</li>
<li><kbd>hit</kbd>: This is a <kbd>RaycastHit</kbd> object, which is passed in as the object to be set by <kbd>Physics.Raycast(...)</kbd>. Various properties of this object are set after a Raycast has been created, including the position in the scene where the Raycast hit the surface of an object.</li>
</ul>
<p>The <kbd>Start()</kbd> method caches a reference to the NavMesh component of the Sphere-arrow GameObject, and also moves the Sphere-destination GameObject to the current object's location.</p>
<p>Each frame, in the <kbd>Update()</kbd> method, a Ray is created based on the Main Camera and the (2,y) point clicked on the screen. This Ray is passed as a parameter to the <kbd>FireRayCast(...)</kbd> method. If that method returns true, then the position of the object hit is extracted and passed to the <kbd>ProcessRayHit(...)</kbd> method.</p>
<p>The <kbd>FireRayCast(...)</kbd> method receives a Ray object. It uses <kbd>Phyics.Raycast(...)</kbd> to determine whether the Raycast collides with part of an object in the scene. If the Raycast hits something, the properties of the <kbd>RaycastHit hit</kbd> object are updated. A true/false for whether <kbd>Physics.Raycast(...)</kbd> hit a surface is returned by this method.</p>
<p class="mce-root"/>
<p>Each time the user clicks on the screen, the corresponding object in the scene is identified with the Raycast, the red sphere is moved there, and the NavMeshAgent begins to navigate towards that location.</p>
<p>Learn more about the Unity Raycast C# script-class at <a href="https://docs.unity3d.com/ScriptReference/RaycastHit.html." target="_blank">https://docs.unity3d.com/ScriptReference/RaycastHit.html.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more</h1>
                
            
            
                
<p>Here are some details that you won't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">More intelligent pathfinding by setting different costs for custom-defined navigation areas such as Mud and Water</h1>
                
            
            
                
<p>We can create objects whose meshes are defined as more expensive for NavMeshAgents to travel across, helping AI-agent behavior be more realistic in terms of choosing faster paths that avoid Water, Mud, and so on.</p>
<p>To create a custom NavMesh Area (we'll pretend it's mud) with a higher travelling cost, do the following:</p>
<ol>
<li>In the Navigation panel, reveal the areas by clicking the Areas button. Then, define a new area named Mud with a cost of 2:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0d0a0568-05f0-4116-aff1-f59577632589.png" style="width:19.50em;height:9.58em;"/></p>
<ol start="2">
<li>Create a new 3D Cylinder named Cylinder-mud, positioned at (0, -4.9, 0) and scaled to (5,5,5).</li>
<li>Ensure the Cylinder-mud GameObject is selected in the Hierarchy, and that the Navigation panel is displayed.</li>
</ol>
<ol start="4">
<li>In the Navigation panel, click the Object button, check Navigation Static, and choose Mud from the Navigation Area drop-down list:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c68362d4-149c-45df-9624-ac853d490a85.png" style="width:27.92em;height:12.00em;"/></p>
<ol start="5">
<li>Now, click the Bake button to show the NavigationBake sub-panel, and then in this sub-panel click the Bake button to regenerate the Navigation Mesh with the new object.</li>
</ol>
<p>Now, if you click to move the Sphere-arrow GameObject near the edge of the Cylinder-mud area, then, say, click on the opposite side, you'll see the NavMeshAgent make the Sphere-arrow GameObject follow a semi-circular (lowest cost) path around the edge of the Cylinder-mud area, rather than follow a direct line (as the crow flies) path <em>through</em> the higher cost mud area:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3c20833a-cb82-4d40-9e15-d446f2ce068a.png" style="width:47.17em;height:13.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving UX by updating a "gaze" cursor each frame</h1>
                
            
            
                
<p>It's nice to know where our destination will be set to <strong>before</strong> we click the mouse. So, let's add a yellow sphere to show the 'candidate' destination for where our Raycast is hitting a surface, updated each frame as we move the mouse.</p>
<p>So, we need to create a second, yellow sphere. We also need to create a Layer to ignore; otherwise, if we move the yellow sphere to the point where a Raycast hits a surface, then in the next frame our Raycast will hit the surface of our yellow sphere - moving it closer and closer to us each frame!</p>
<p>To improve UX by updating a "gaze" cursor each frame, do the following:</p>
<ol>
<li>Create a new yellow Material named m_yellow.</li>
<li>Create a second 3D Sphere, named Sphere-destination-candidate and textured with m_yellow.</li>
<li>Create a new Layer, UISpheres.</li>
<li>Set the Layer for both Sphere-destination and Sphere-destination-candidate GameObjects to LayerUISpheres.</li>
<li>Modify the <kbd>MoveToClickPoint</kbd> C# script-class as follows to add a new public variable, <kbd>sphereDestinationCandidate</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class MoveToClickPoint : MonoBehaviour {<br/>public GameObject sphereDestination;<br/>public GameObject sphereDestinationCandidate;</pre>
<ol start="6">
<li>Modify the <kbd>MoveToClickPoint</kbd> C# script-class as follows to add an Else-clause <strong>to the logic in the</strong> <kbd>ProcessRayHit(...)</kbd><strong> method, so that if the mouse is</strong> not clicked, then the yellow sphereDestinationCandidate object is moved to where the Raycast hit a surface:</li>
</ol>
<pre style="padding-left: 60px">private void ProcessRayHit(Vector3 rayPoint) {<br/> if(Input.GetMouseButtonDown(0)) {<br/> navMeshAgent.destination = rayPoint;<br/> sphereDestination.transform.position = rayPoint;<br/> } else {<br/> sphereDestinationCandidate.transform.position = rayPoint;<br/> }<br/> }</pre>
<ol start="7">
<li>Modify the <kbd>MoveToClickPoint</kbd> C# script-class as follows, so that a <kbd>LayerMask</kbd> is created to ignore Layer UISpheres, and passed as a parameter when <kbd>Physics.Raycast(...)</kbd> is invoked:</li>
</ol>
<pre style="padding-left: 60px">private bool FireRayCast(Ray rayFromMouseClick) {<br/> LayerMask layerMask = ~LayerMask.GetMask("UISpheres");<br/> return Physics.Raycast(rayFromMouseClick, out hit, 100, layerMask.value);<br/> }</pre>
<ol start="8">
<li>Select the Sphere-arrow GameObject in the Hierarchy, and in the Inspector for the MoveToClickPoint (Script) component, populate the Sphere Destination Candidate public property with your yellow Sphere-destination-candidate GameObject.</li>
<li>Run the scene. You should now be able to click anywhere on the Terrain to set the destination of the NavMeshAgent controlled Sphere-arrow GameObject. As you click, the red Sphere-destination GameObject should be positioned at this new destination point, towards which the Sphere-arrow GameObject will navigate.</li>
</ol>
<p>We have set a <kbd>LayerMask</kbd> using the <kbd>~LayerMask.GetMask("UISpheres") </kbd>statement, which means every layer apart from the named one. This is passed to the <kbd>Raycast(...)</kbd> method, so that our red and yellow Spheres are ignored when casting the ray and looking to see which surface the ray hits first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NPC NavMeshAgent to follow waypoints in a sequence</h1>
                
            
            
                
<p>Waypoints are often used as a guide to make autonomously moving NPCs and enemies follow a path in a general way, but be able to respond with other directional behaviors, such as flee or seek, if friends/predators/prey are sensed nearby. The waypoints are arranged in a sequence, so that when the character reaches or gets close to a waypoint, it will then select the next waypoint in the sequence as the target location to move towards. This recipe demonstrates an arrow object moving towards a waypoint, and then when it gets close enough, it will choose the next waypoint in the sequence as the new target destination. When the last waypoint has been reached, it again starts heading towards the first waypoint.</p>
<p>Since Unity's NavMeshAgent has simplified coding NPC behavior, our work in this recipe basically becomes finding the position of the next waypoint and then telling the NavMeshAgent that this waypoint is its new destination:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b2a12d87-0083-436f-9144-ade4dbd9850d.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the first recipe in this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>For this recipe, we have prepared the yellow brick texture image that you need in a folder named Textures in the <kbd>1362_08_06</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To instruct an object to follow a sequence of waypoints, follow these steps:</p>
<ol>
<li>Replace the contents of the <kbd>ArrowNPCMovement</kbd> C# script class with the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.AI;<br/><br/>public class ArrowNPCMovement : MonoBehaviour {<br/> private GameObject targetGo = null;<br/> private WaypointManager waypointManager;<br/> private NavMeshAgent navMeshAgent;<br/><br/>void Start () {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> waypointManager = GetComponent&lt;WaypointManager&gt;();<br/> HeadForNextWayPoint();<br/> }<br/><br/>void Update () {<br/> float closeToDestinaton = navMeshAgent.stoppingDistance * 2;<br/> if (navMeshAgent.remainingDistance &lt; closeToDestinaton) {<br/> HeadForNextWayPoint ();<br/> }<br/> }<br/><br/>private void HeadForNextWayPoint () {<br/> targetGo = waypointManager.NextWaypoint (targetGo);<br/> navMeshAgent.SetDestination (targetGo.transform.position);<br/> }<br/> }</pre>
<ol start="2">
<li>Create a new 3D Capsule object named Capsule-waypoint-0 at (-12, 0, 8).</li>
<li>Copy Capsule-waypoint-0, name the copy Capsule-waypoint-3, and position this copy at (8, 0, -8).</li>
</ol>
<p>We are going to add some intermediate waypoints numbered 1 and 2 later on. This is why our second waypoint here is numbered 3, in case you were wondering.</p>
<ol start="4">
<li>Create the <kbd>WaypointManager</kbd> C# script class with the following contents, and add an instance-object as a component to the Sphere-arrow GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/> public class WaypointManager : MonoBehaviour {<br/> public GameObject wayPoint0;<br/> public GameObject wayPoint3;<br/><br/>public GameObject NextWaypoint(GameObject current) {<br/> if(current == wayPoint0)<br/> return wayPoint3;<br/><br/>return wayPoint0;<br/> }<br/> }</pre>
<ol start="5">
<li>Ensure that Sphere-arrow is selected in the Inspector for the <kbd>WaypointManager</kbd> scripted component. Drag Capsule-waypoint-0 and Capsule-waypoint-3 over the public variable projectiles called Way Point 0 and Way Point 3, respectively.</li>
<li>Now, run your game. The arrow object will first move towards one of the waypoint capsules, then when it gets close to it, it will slow down, turn around, head towards the other waypoint capsule, and keep doing that continuously.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The NavMeshAgent component that we added to the Sphere-arrow GameObject does most of the work for us. NavMeshAgent needs two things:</p>
<ul>
<li>A destination location to head towards</li>
<li>A NavMesh, so that it can plan a path and avoid obstacles</li>
</ul>
<p>We created two possible waypoints as the locations for our NPC to move towards: Capsule-waypoint-0 and Capsule-waypoint-3.</p>
<p>The C# script class called <kbd>WaypointManager</kbd> has one job: to return a reference to the next waypoint that our NPC should head towards. There are two variables, <kbd>wayPoint0</kbd> and <kbd>wayPoint3</kbd>, which reference the two waypoint GameObjects in our scene. The <kbd>NextWaypoint(...)</kbd> method takes a single parameter named current, which is a reference to the current waypoint that the object is moving towards (or <kbd>null</kbd>). This method's task is to return a reference to the next waypoint that the NPC should travel towards. The logic for this method is simple: if current refers to waypoint0, then we'll return <kbd>waypoint3</kbd>; otherwise, we'll return <kbd>waypoint0</kbd>. Note that if we pass this method <kbd>null</kbd>, then we'll get <kbd>waypoint0</kbd> back (so, it is our default first waypoint).</p>
<p>The <kbd>ArrowNPCMovement</kbd> C# script class has three variables. One is a reference to the destination GameObject named <kbd>targetGo</kbd>. The second is a reference to the <kbd>NavMeshAgent</kbd> component of the GameObject in which our instance of the class called <kbd>ArrowNPCMovement</kbd> is also a component. The third variable, called <kbd>waypointManager</kbd>, is a reference to the sibling scripted component, an instance of our <kbd>WaypointManager</kbd> script class.</p>
<p>When the scene starts via the <kbd>Start()</kbd> method, the NavMeshAgent and WaypointManager sibling components are found, and the <kbd>HeadForDestination()</kbd> method is called.</p>
<p>The <kbd>HeadForDestination()</kbd> method first sets the variable called <kbd>targetGO</kbd> to refer to the GameObject that is returned by a call to the <kbd>NextWaypoint(...)</kbd> of the scripted component called WaypointManager (that is, <kbd>targetGo</kbd> is set to refer to either Capsule-waypoint-0 or Capsule-waypoint-3). Next, it instructs the <kbd>NavMeshAgent</kbd> to make its destination the position of the <kbd>targetGO</kbd> GameObject.</p>
<p>Each frame method called <kbd>Update()</kbd> is called. A test is made to see whether the distance from the NPC arrow object is close to the destination waypoint. If the distance is smaller than twice the stopping distance set in our NavMeshAgent, then a call is made to <kbd>WaypointManager.NextWaypoint(...)</kbd> to update our target destination to be the next waypoint in the sequence.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some details that you won't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with arrays of waypoints</h1>
                
            
            
                
<p>Having a separate <kbd>WaypointManager</kbd> C# script-class to simply swap between Capsule-waypoint-0 and Capsule-waypoint-3 may have seemed to be a bit heavy duty and a case of over-engineering, but this was actually a very good move. An instance-object of the <kbd>WaypointManager</kbd> script-class has the job of returning the next waypoint. It is now very straightforward to add the more sophisticated approach of having an array of waypoints, without us having to change any code in the <kbd>ArrowNPCMovement</kbd> C# script-class. We can choose a random waypoint to be the next destination; for example, see the <em>Choosing destinations - find nearest (or a random) spawnpoint </em>recipe in <a href="eb0ea442-6350-4a86-9e16-708b80d8762f.xhtml" target="_blank">Chapter 14</a>, <em>Choosing and Controlling Positions</em>. Or, we can have an array of waypoints and choose the next one in the sequence.</p>
<p>To improve our game so that it works with an array of waypoints to be followed in sequence, we need to do the following:</p>
<ol>
<li>Copy Capsule-waypoint-0, name the copy Capsule-waypoint-1, and position this copy at (0, 0, 8).</li>
<li>Make four more copies (named Capsule-waypoint-1, 2, 4, 5), and position them as follows:
<ul>
<li>Capsule-waypoint-1: Position = (-2, 0, 8)</li>
<li>Capsule-waypoint-2: Position = (8, 0, 8)</li>
<li>Capsule-waypoint-4: Position = (-2, 0, -8)</li>
<li>Capsule-waypoint-5: Position = (-12, 0, -8)</li>
</ul>
</li>
<li>Replace the <kbd>WaypointManager</kbd> C# script-class with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System;<br/><br/>public class WaypointManager : MonoBehaviour {<br/> public GameObject[] waypoints;<br/><br/>public GameObject NextWaypoint (GameObject current) {<br/> if( waypoints.Length &lt; 1)<br/> Debug.LogError ("WaypointManager:: ERROR - no waypoints have been added to array!");<br/><br/>int currentIndex = Array.IndexOf(waypoints, current);<br/> int nextIndex = (currentIndex + 1) % waypoints.Length;<br/><br/>return waypoints[nextIndex];<br/> }<br/> }</pre>
<ol start="4">
<li>Ensure that Sphere-arrow is selected. In the Inspector panel for the <kbd>WaypointManager</kbd> scripted component, set the size of the Waypoints array to 6. Now, drag in all six capsule waypoint objects called Capsule-waypoint-0/1/2/3/4/5.</li>
<li>Run the game. Now, the Sphere-arrow GameObject will first move towards waypoint 0 (top left), and then follow the sequence around the terrain.</li>
<li>Finally, you can make it look as if the Sphere is following a yellow brick road. Import the provided yellow brick texture, add this to your terrain, and paint the texture to create an oval-shaped path between the waypoints. You may also uncheck the Mesh Renderer component for each waypoint capsule, so that the user does not see any of the waypoints, just the arrow object following the yellow brick road.</li>
</ol>
<p>In the <kbd>NextWaypoint(...)</kbd> method, first we check in case the array is empty, in which case an error is logged. Next, the array index for the current <kbd>waypoint</kbd> GameObject is found (if present in the array). Finally, the array index for the next waypoint is calculated using a modulus operator to support a cyclic sequence, returning to the beginning of the array after the last element has been visited.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Increased flexibility with a WayPoint class</h1>
                
            
            
                
<p>Rather than forcing a GameObject to follow a single rigid sequence of locations, we can make things more flexible by defining a <kbd>WayPoint</kbd> class where each waypoint GameObject has an array of possible destinations, and each of these has its own array. In this way, a digraph (directed graph) can be implemented, of which a linear sequence is just one possible instance.</p>
<p>To improve our game and make it work with a digraph of waypoints, do the following:</p>
<ol>
<li>Remove the scripted <kbd>WayPointManager</kbd> component from the Sphere-arrow GameObject.</li>
<li>Replace the <kbd>ArrowNPCMovement</kbd> C# script-class with the following code:</li>
</ol>
<pre style="padding-left: 60px"> using UnityEngine;<br/> using System.Collections;<br/><br/> public class ArrowNPCMovement : MonoBehaviour {<br/> public Waypoint waypoint;<br/> private bool firstWayPoint = true;<br/> private NavMeshAgent navMeshAgent;<br/><br/> void Start (){<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> HeadForNextWayPoint();<br/> }<br/><br/> void Update () {<br/> float closeToDestinaton = navMeshAgent.stoppingDistance * 2;<br/> if (navMeshAgent.remainingDistance &lt; closeToDestinaton){<br/> HeadForNextWayPoint ();<br/> }<br/> }<br/><br/> private void HeadForNextWayPoint (){<br/> if(firstWayPoint)<br/> firstWayPoint = false;<br/> else<br/> waypoint = waypoint.GetNextWaypoint();<br/><br/> Vector3 target = waypoint.transform.position;<br/> navMeshAgent.SetDestination (target);<br/> }<br/> }</pre>
<ol start="3">
<li>Create a new <kbd>WayPoint</kbd> C# script-class containing the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>public class Waypoint: MonoBehaviour {<br/>public Waypoint[] waypoints;<br/><br/>public Waypoint GetNextWaypoint () {<br/>return waypoints[ Random.Range(0, waypoints.Length) ];<br/> }<br/> }</pre>
<ol start="4">
<li>Select all six GameObjects called Capsule-waypoint -0/1/2/3/4/5 and add to them an instance-object component of the <kbd>WayPoint</kbd> C# class.</li>
<li>Select the Sphere-arrow GameObject and add to it an instance-object component of the <kbd>WayPoint</kbd> C# class.</li>
<li>Ensure that the Sphere-arrow GameObject is selected. In the Inspector panel for the ArrowNPCMovement scripted component, drag Capsule-waypoint-0 into the <kbd>Waypoint</kbd> public variable slot.</li>
</ol>
<ol start="7">
<li>Now, we need to link Capsule-waypoint-0 to Capsule-waypoint-1, Capsule-waypoint-1 to Capsule-waypoint -2, and so on. Select Capsule-waypoint-0, set its Waypoints array size to 1, and drag in Capsule-waypoint-1. Next, select Capsule-waypoint-1, set its Waypoints array size to 1, and drag in Capsule-waypoint-2. Continue in this way until you finally link Capsule-waypoint-5 back to Capsule-waypoint-0.</li>
</ol>
<p>You now have a much more flexible game architecture, allowing GameObjects to randomly select one of several different paths at each waypoint reached. In this recipe variation, we have implemented a waypoint sequence, since each waypoint has an array of just one linked waypoint. However, if you change the array size to 2 or more, you will then be creating a graph of linked waypoints, adding random variations in the sequence of waypoints that a computer controlled character follows for any given run of your game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controlling object group movement through flocking</h1>
                
            
            
                
<p>A realistic, natural-looking flocking behavior (for example birds, antelope, or bats) can be created through creating collections of objects with the following four simple rules:</p>
<ul>
<li><strong>Separation</strong>: Avoid getting too close to neighbors</li>
<li><strong>Avoid obstacles</strong>: Turn away from an obstacle immediately ahead</li>
<li><strong>Alignment</strong>: Move in the general direction the flock is heading</li>
<li><strong>Cohesion</strong>: Move towards a location in the middle of the flock</li>
</ul>
<p>Each member of the flock acts independently, but needs to know about the current heading and location of the members of its flock. This recipe shows you how to create a scene with two flocks of cubes: one flock of green cubes and one flock of yellow cubes.</p>
<p>To keep things simple, we'll not worry about separation in our recipe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3900a762-31ec-41ad-8a49-9d631f9d5401.png" style="width:31.50em;height:13.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the player-controlled 3D cube Unity project that you created in the first recipe. So, make a copy of this project, open it, and then follow the steps for this recipe.</p>
<p>The required script to control movement of the red Cube (<kbd>PlayerControl.cs</kbd>) is provided in the <kbd>15_07</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To make a group of objects flock together, please follow these steps:</p>
<ol>
<li>Create a Material in the Project panel and name it m_green with the Main Color tinted green.</li>
<li>Create a Material in the Project panel and name it m_yellow with Main Color tinted yellow.</li>
<li>Create a 3D Cube GameObject named Cube-drone at (0,0,0). Drag the m_yellow Material into this object.</li>
<li>Add a Navigation | NavMeshAgent component to Cube-drone. Set the Stopping Distance property of the NavMeshAgent component to 2.</li>
<li>Add a Physics RigidBody component to Cube-drone with the following properties:
<ul>
<li>Mass is 1</li>
<li>Drag is 0</li>
<li>Angular Drag is 0.05</li>
<li>Use Gravity and Is Kinematic are both unchecked</li>
<li>Constraints Freeze Position: check the Y-axis</li>
</ul>
</li>
<li>Create the following <kbd>Drone</kbd> C# script-class, and add an instance-object as a component to the Cube-drone GameObject:</li>
</ol>
<pre style="padding-left: 60px"> using UnityEngine;<br/> using UnityEngine.AI;<br/><br/> public class Drone : MonoBehaviour {<br/> private NavMeshAgent navMeshAgent;<br/><br/> void Start() {<br/> navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<br/> }<br/><br/> public void SetTargetPosition(Vector3 swarmCenterAverage, Vector3 swarmMovementAverage) {<br/> Vector3 destination = swarmCenterAverage + swarmMovementAverage;<br/> navMeshAgent.SetDestination(destination);<br/> }<br/> }</pre>
<ol start="7">
<li>Create a new empty <strong>Prefab</strong> named dronePrefabYellow, and from the Hierarchy panel, drag your Cube-boid GameObject into this Prefab.</li>
<li>Now, drag the m_green Material into the Cube-boid GameObject.</li>
<li>Create a new empty Prefab named dronePrefabGreen, and from the Hierarchy panel, drag your Cube-drone GameObject into this Prefab.</li>
<li>Delete the Cube-drone GameObject from the Scene panel.</li>
<li>Create the following <kbd>Swarm</kbd> C# script-class, and add an instance-object as a component to the Main Camera:</li>
</ol>
<pre style="padding-left: 90px">using UnityEngine;<br/> using System.Collections.Generic;<br/><br/>public class Swarm : MonoBehaviour {<br/> public int droneCount = 20;<br/> public GameObject dronePrefab;<br/><br/>private List&lt;Drone&gt; drones = new List&lt;Drone&gt;();<br/><br/>void Awake() {<br/> for (int i = 0; i &lt; droneCount; i++)<br/> AddDrone();<br/> }<br/><br/>void FixedUpdate() {<br/> Vector3 swarmCenter = SwarmCenterAverage();<br/> Vector3 swarmMovement = SwarmMovementAverage();<br/><br/>foreach(Drone drone in drones )<br/> drone.SetTargetPosition(swarmCenter, swarmMovement);<br/> }<br/><br/>private void AddDrone()<br/> {<br/> GameObject newDroneGo = Instantiate(dronePrefab);<br/> Drone newDrone = newDroneGo.GetComponent&lt;Drone&gt;();<br/> drones.Add(newDrone);<br/> }<br/><br/>private Vector3 SwarmCenterAverage() {<br/> Vector3 locationTotal = Vector3.zero;<br/> foreach(Drone drone in drones )<br/> locationTotal += drone.transform.position;<br/><br/>return (locationTotal / drones.Count);<br/> }<br/><br/>private Vector3 SwarmMovementAverage() {<br/> Vector3 velocityTotal = Vector3.zero;<br/> foreach(Drone drone in drones )<br/> velocityTotal += drone.GetComponent&lt;Rigidbody&gt;().velocity;<br/><br/>return (velocityTotal / drones.Count);<br/> }<br/> }</pre>
<ol start="12">
<li>With Main Camera selected in the Hierarchy panel, drag dronePrefabYellow from the Project panel over the Drone Prefab public variable.</li>
<li>With Main Camera selected in the Hierarchy panel, add a second instance-object of the <kbd>Swarm</kbd> script-class to this GameObject, and then drag dronePrefabGreen from the Project panel over the Drone Prefab public variable.</li>
<li>Create a new 3D Cube named wall-left with the following properties:
<ul>
<li>Position: (-15, 0.5, 0)</li>
<li>Scale: (1, 1, 20)</li>
</ul>
</li>
</ol>
<ol start="15">
<li>Duplicate the wall-left object by naming the new object wall-right, and change the position of wall-right to (15, 0.5, 0).</li>
<li>Create a new 3D Cube named wall-top with the following properties:
<ul>
<li>Position: (0, 0.5, 10)</li>
<li>Scale: (31, 1, 1)</li>
</ul>
</li>
<li>Duplicate the wall-top object by naming the new object wall-bottom, and change the position of wall-bottom to (0, 0.5, -10).</li>
<li>Create a new 3D Sphere named Sphere-obstacle with the following properties:
<ul>
<li>Position: (5, 0, 3)</li>
<li>Scale: (10, 3, 3)</li>
</ul>
</li>
<li>In the Hierarchy panel, select the Sphere-obstacle GameObject. Then in the Navigation panel, check the Navigation Static checkbox. Then, click on the Bake button at the bottom of the Navigation panel.</li>
<li>Finally, create a red 3D Cube for the player to control, making it red by adding Materialm_red to it and making it large by setting its scale to (3,3,3). Now, add an instance-object of the <kbd>PlayerControl</kbd> C# script-class provided as a component to this GameObject.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Swarm class contains three variables:</p>
<ol>
<li><kbd>droneCount</kbd>: It is an integer referencing the number of the Swarm class members created</li>
<li><kbd>dronePrefab</kbd>: It references the Prefab to be cloned to create swarm members</li>
<li><kbd>drones</kbd>: A list of objects that reference drones; a list of all the scripted <kbd>Drone</kbd> components inside all the <kbd>Swarm</kbd> objects that have been created</li>
</ol>
<p>Upon creation, as the scene starts, the Swarm script class's <kbd>Awake()</kbd> method loops to create <kbd>droneCount</kbd> swarm members by repeatedly calling the <kbd>AddDrone()</kbd> method. This method instantiates a new GameObject from the prefab, and then sets the <kbd>newDrone</kbd> variable to be a reference to the Drone scripted object inside the new <kbd>Swarm</kbd> class member. In each frame, the <kbd>FixedUpdate()</kbd> method loops through the list of <kbd>Drone</kbd> objects by calling their <kbd>SetTargetPosition(...)</kbd> method, and passes in the <kbd>Swarm</kbd> center location and the average of all the swarm member velocities.</p>
<p>The rest of this <kbd>Swarm</kbd> class is made up of two methods: one (<kbd>SwarmCenterAverage</kbd>) returns a <kbd>Vector3</kbd> object representing the average position of all the <kbd>Drone</kbd> objects, and the other (<kbd>SwarmMovementAverage</kbd>) returns a <kbd>Vector3</kbd> object representing the average velocity (movement force) of all the <kbd>Drone</kbd> objects:</p>
<ol>
<li><kbd>SwarmMovementAverage()</kbd>:
<ol>
<li>What is the general direction that the swarm is moving in?</li>
<li>This is known as alignment: a swarm member attempting to move in the same direction as the swarm average</li>
</ol>
</li>
<li><kbd>SwarmCenterAverage()</kbd>:
<ol>
<li>What is the center position of the swarm?</li>
<li>This is known as cohesion: a swarm member attempting to move towards the center of the swarm</li>
</ol>
</li>
</ol>
<p>The core work is undertaken by the <kbd>Drone</kbd> class. Each drone's <kbd>Start(...)</kbd> method finds and caches a reference to its NavMeshAgent component.</p>
<p>Each drone's <kbd>UpdateVelocity(...)</kbd> method takes as input two <kbd>Vector3</kbd> arguments: <kbd>swarmCenterAverage</kbd> and <kbd>swarmMovementAverage</kbd>. This method then calculates the desired new velocity for this <kbd>Drone</kbd> by simply adding the two vectors, and then uses the result (a <kbd>Vector3</kbd> location) to update the NavMeshAgent's target location.</p>
<p>Most of the flocking models in modern computing owe much to the work of Craig Reynolds in the 1980s. Learn more about Craig and his boids program at <a href="http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)" target="_blank">http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a movable NavMesh Obstacle</h1>
                
            
            
                
<p>Sometimes, we want a moving object to slow down or prevent an AI NavMeshAgent controlled character passing through an area of our game. Or, perhaps we want something like a door or drawbridge to sometimes permit travel, and not at other times. We can't "bake" these objects into the NavMesh at Design-Time, since we want to change them during Run-Time.</p>
<p>While computationally more expensive (that is, they slow down your game more that static non-navigable objects), NavMesh Obstacles are components that can be added to GameObjects, and these components can be enabled and disabled like any other component.</p>
<p>A special property of NavMesh Obstacles is that they can be set to "carve out" areas of the NavMesh, causing NavMeshAgents to then recalculate routes that avoid these carved out parts of the mesh.</p>
<p>In this recipe, you'll create a player-controlled red Cube, which you can move to obstruct an AI NavMeshAgent controlled character. Also, if your cube stays in one place for a half-second or longer, it will carve out part of the NavMesh around it, and so cause the NavMeshAgent to stop bumping into the obstacle, and calculate and follow a path that avoids it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/78f156e6-4080-48b0-8eb5-8b829f2dbba4.png" style="width:18.33em;height:9.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adds to the first recipe in this chapter, so make a copy of that project folder and do your work for this recipe with that copy.</p>
<p>The required script to control the movement of the red Cube (<kbd>PlayerControl.cs</kbd>) is provided in the <kbd>15_08</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a movable NavMesh Obstacle, please follow these steps:</p>
<ol>
<li>Create a Material in the Project panel, and name it m_green with the Main Color tinted green.</li>
<li>Create a red 3D Cube for the player to control, named Cube-player, making it red by added Material m_red to it and making it large by setting its scale to (3,3,3).</li>
<li>Add an instance of the provided <kbd>PlayerControl</kbd> C# script-class as a component to this GameObject.</li>
</ol>
<ol start="4">
<li>In the Inspector, add a Navigation | NavMesh Obstacle component to Cube-player and check its Carve property.</li>
<li>Run the game. You can move the player-controlled red Cube to get in the way of the moving Sphere-arrow GameObject. After the NavMesh Obstacles Time-to-stationary time of half a second, if you have Gizmos displayed, you'll see the carving out of the NavMesh, so that the area occupied by Cube-player, and a little way around it, is removed from the NavMesh, and the Sphere-arrow GameObject will then recalculate a new route, avoiding the carved out area where Cube-player is located.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>At Run-Time, the AI NavMeshAgent controlled Sphere-arrow GameObject heads towards the destination point, but stops when the player-controlled red Cube is in its way. Once the Cube is stationary for 0.5 seconds or more, the NavMesh is carved out, so that the AI NavMeshAgent controlled <strong>Sphere-arrow</strong> GameObject no longer even attempts to plan a path through the space occupied by the cube, and recalculates a new path completely avoiding the obstacle, even if it means back-tracking and heading away from the target for part of its path.</p>


            

            
        
    </body></html>