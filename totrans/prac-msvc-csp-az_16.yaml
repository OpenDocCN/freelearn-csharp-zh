- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Applications On-Premises and in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to the last chapter, we added additional functionality to the Codebreaker
    application; in [*Chapter 15*](B21217_15.xhtml#_idTextAnchor349), we added services
    communicating with asynchronous communication. We used Azure Storage queues and
    Azure Event Hubs with the Azure Codebreaker variant; with the on-premises version,
    we added a Kafka container.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at what needs to be known when deploying the solution
    to Microsoft Azure and to on-premises environments. Using Azure, we deployed the
    solution to an Azure Container Apps environment from [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)
    onward. The Azure Container Apps environment uses Kubernetes behind the scenes.
    In this chapter, we directly deploy to a Kubernetes cluster, which can easily
    be used in on-premises environments and in any cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing deployment with C# and Aspire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster with Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application to Kubernetes with Aspir8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, like the previous chapters, you need an Azure subscription,
    .NET 8 with .NET Aspire, and Docker Desktop. In this chapter, we’ll use a new
    tool, Aspir8, to deploy the application to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ch16` folder, you’ll see the projects that can be deployed. The most
    important project for this chapter is `Codebreaker.AppHost`, which defines the
    app model using Azure native cloud services, as well as a configuration that can
    be used with an on-premises environment. This configuration is also used to deploy
    the solution to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about deployment in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Codebreaker solution uses several different native Azure cloud services.
    In [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183), you saw how we can use **GitHub
    Actions** to deploy to different environments, such as development, testing, staging,
    and production environments using approvals. As more and more services have been
    added in the last chapters, the deployments need to be updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: With many organizations, deployments to production environments are somewhat
    disconnected from the development environment. Often, a different team from the
    development organization manages these deployments using different tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) and **Continuous Development** (**CD**)
    are often used in repositories separated from the source code. Different products
    such as GitHub Actions, Azure DevOps pipelines, and many third-party offerings
    are used.'
  prefs: []
  type: TYPE_NORMAL
- en: From the pipelines, it’s possible to trigger the Azure Developer CLI (azd),
    use Bicep scripts, directly use the Azure CLI or PowerShell scripts, or use third-party
    offerings such as Terraform, Ansible, Chef, and Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding between the different products, it’s also necessary to think about
    the requirements for the production environment, and what’s different from the
    development environment. With the production environment, different loads are
    expected. For a load test, it’s useful to run the same infrastructure as used
    with the production environment. With this, it’s important that the complete infrastructure
    for an environment needs to be easily creatable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The infrastructure needs to map the needs of the business – what income is
    lost if things are not working as expected? We need to think about these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: Adapting to changing demands. Demand might increase slightly
    over time, or there might also be spikes in demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Making sure that the services work as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Making sure that the services are available from where the
    customers are. Availability metrics are **Mean Time Between Failures** (**MTBF**)
    – how long until a failure happens – and **Mean Time To Repair** (**MTTR**) –
    how long it takes until it’s running again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recovery**: If there’s an outage, recovery metrics that can be used are **Recovery
    Point Time** (**RTO**) – the acceptable time for apps to be unavailable – and
    **Recovery Point Objective** (**RPO**) – the maximum allowed time for a data loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements need to be compared to the business needs. With **redundancy**,
    resources are replicated, and multiple services are running. There’s not a single
    point of failure. Data can be replicated within one data center in an Azure region,
    between different data centers in an Azure region (Azure **availability zones**),
    and across different Azure regions (using a **multi-region** architecture).
  prefs: []
  type: TYPE_NORMAL
- en: Another requirement for the production environment is to enhance security. Data
    protection needs to make sure personal user data is safe. With **encryption at
    rest**, data is stored encrypted in the database. Instead of a service-managed
    key, customer-managed keys can be used. Using customer-managed keys is possible
    with many Azure services, but usually, different (more expensive) SKUs are required
    to enable customer-managed keys. Virtual networks are another option to enhance
    security. With subnets, it’s possible to restrict access to the database server.
    **Private endpoints** can be used to restrict access only to a specific service
    and prevent data exfiltration. IP firewall rules can be configured.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t discuss all the different requirements here, but an important takeaway
    is that with production environments, we might need some additional Azure resources
    (such as virtual networks), different configurations, and other SKUs. See *Figure
    16**.1* for the Codebreaker application making use of multiple Azure regions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Codebreaker with virtual networks](img/B21217_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Codebreaker with virtual networks
  prefs: []
  type: TYPE_NORMAL
- en: This figure shows Azure regions in the US, Europe, and Asia, and Azure Cosmos
    DB replicated across the regions. The database is accessed from Container Apps
    running in the same region of the database. The frontends (Blazor) and backends
    (Game APIs) in one region can run in one Azure Container Apps environment, with
    the Game APIs service only accessible internally. Azure Application Gateway with
    a firewall configured is used to access the Blazor web application. Azure Traffic
    Manager can route across different regions.
  prefs: []
  type: TYPE_NORMAL
- en: How does the Codebreaker solution fulfill all the requirements? With scalability,
    reliability, and security, all the resources used by the application need to be
    verified. In [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294), we added a huge
    load on the Codebreaker services to test scaling up and scaling out. Due to the
    stateless nature of the developed services, the resources used also scale accordingly,
    and we anticipate no issues in meeting all the requirements. The Azure Cosmos
    DB database can replicate worldwide, even with multi-region writes to store games
    near the user for the best performance. We paid attention to the partition key,
    which doesn’t block other gamers’ writes to the database. Azure Event Hubs (added
    in [*Chapter 15*](B21217_15.xhtml#_idTextAnchor349)) offers a lot more performance
    than needed. The Standard SKU supports 1,000 events per second with one throughput
    unit. Additional throughput units can be added, and a switch to the Premium tier,
    which offers even more, could be done. An important aspect is to see what’s going
    on to react early, which was covered in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263).
  prefs: []
  type: TYPE_NORMAL
- en: While many organizations have separate teams for development and infrastructure,
    this has some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET Aspire manifest created from the app model, we covered creating
    Bicep scripts in [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137). These Bicep
    scripts can be customized to fulfill the requirements of the production environment.
    Using customized Bicep scripts has the disadvantage that changes on the app model
    don’t automatically reflect with the Bicep script. The Bicep script needs to be
    manually updated again.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great to use C# code to completely define the Azure infrastructure
    configuration with all the different aspects needed. When the app model is updated
    with this, the infrastructure configuration is changed at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing deployments with C# and .NET Aspire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of this writing, enhancements are in progress to make this happen.
    Currently, it’s just in experimental mode, and the APIs available are likely to
    change, thus we will only look briefly into this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the .NET Aspire app model, APIs have an overload with a delegate
    parameter. For example, the `AddAzureKeyVault` method we used so far is an extension
    method for the `IDistributedApplicationBuilder` interface and uses a `name` parameter.
    A second overload specifies an additional `Action` delegate parameter. This overload
    has the `Experimental` attribute applied to mark that the API may change. The
    parameters used with this delegate are `IResourceBuilder<AzureKeyVaultResource>`,
    `ResourceModuleConstruct`, and `KeyVault`. This allows us to configure a secret
    retrieved from a parameter when creating Azure Key Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the method used here, the first and third parameters of the delegate are
    ignored. The second parameter of the `ResourceModuleConstruct` type specifies
    the scope of creating `KeyVaultSecret` – it’s created for this Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another sample shows configuring properties and invoking method of a builder
    with an Azure Storage Account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When creating the Azure Storage account, the `IResourceBuilder<AzureStorageAccount>`
    and `StorageAccount` parameters are used with the `Action` delegate, and the second
    parameter is ignored. `IResourceBuilder` is used to create a queue and a blob
    container with the storage account. We used these `AddQueues` and `AddBlobs` methods
    already without the experimental API invoking these methods with the return of
    `AddStorageAccount`. The `AddAzureStorage` method returns a builder. This is just
    for convenience defining this within this code block. The `StorageAccount` parameter
    is used to specify properties, setting the SKU to local redundancy, and the access
    tier to hot, which is cheaper for operations but more expensive for the storage.
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations are in the process of changing the way to deploy and manage
    their infrastructure. Knowing about these developments can be useful to decide
    what direction should be taken, and what tools best fit the needs of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it’s very likely that the API will change – so use it with care. With
    the fast development pace of .NET Aspire, new features can improve fast, and this
    feature might be released not too far away (at the time of this writing). Check
    the README file of this chapter for updates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look into easy deployment to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster with Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Azure Container Apps environment is based on Kubernetes, the Kubernetes
    tool (**kubectl**) cannot be used; the Kubernetes functionality is abstracted
    for simplification. Kubernetes is an open source system to scale and manage containerized
    applications and is used by many companies in their on-premises environment. With
    this, for many companies, it’s important to have the possibility to run services
    on-premises and in any cloud environment. See the *Further reading* section for
    links to learn more about Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The Codebreaker application has been built with two launch profiles. We’ll publish
    the `OnPremises` launch profile to a Kubernetes cluster. With this launch profile,
    for example, Kafka is used instead of Azure Event Hubs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By having Docker Desktop installed, you can enable Kubernetes. This single-node
    cluster is just for a small test scenario. Instead, we’ll use a managed version
    of Kubernetes: The **Azure Kubernetes Service** (**AKS**). Compared to a self-installed
    cluster, installation and management are a lot easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the cluster, we need a new resource group, and an **Azure Container**
    **Registry** (**ACR**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Azure CLI, create a new resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify an Azure region of your choice and specify a resource group name. Then,
    create a new ACR using `az` `acr create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Use the previously created resource group, specify an SKU (the cheapest version,
    `Basic`, fits the purpose), and use a unique name for the registry.
  prefs: []
  type: TYPE_NORMAL
- en: With this, create a new AKS in the Azure portal ([https://portal.azure.com](https://portal.azure.com))
    – see *Figure 16**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Basic AKS configuration](img/B21217_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Basic AKS configuration
  prefs: []
  type: TYPE_NORMAL
- en: Select the resource group just created with the first dialog. With **Cluster
    details**, you can choose a preset configuration of either **Production Standard**,
    **Dev/Test**, **Production Economy**, and **Production Enterprise**. The virtual
    machine sizes are different based on the presets, and some features are differently
    configured. For example, **Production Enterprise** has a **private cluster** where
    the API server is only accessible from an internal network. Select the **Dev/Test**
    preset for our test environment. Enter a cluster name and select the region of
    the cluster. All the other **Basics** settings can stay as their defaults – including
    the AKS pricing tier, **Free**. With the **Free** offering, a cost only applies
    for the nodes where our built Docker images are running and other services configured,
    such as managed Prometheus and Grafana. Be aware that every node instance you
    configure is a virtual machine that needs to be paid for. The **Dev/Test** preset
    setting is best for experimenting and testing with fewer than 10 nodes. With the
    **Standard** pricing tier, you can run up to 5,000 nodes in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: After the configuration of the **Basics** settings, click **Next** to configure
    the node pools (*Figure 16**.3*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – AKS node pools](img/B21217_16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – AKS node pools
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration for the node pool is `1`. System node pools need Linux
    for the operating system. These node pools run system pods. To run the applications,
    user node pools are preferred. For a cheaper test, we just use one node pool –
    a system node pool.
  prefs: []
  type: TYPE_NORMAL
- en: When selecting the configuration of the pool, you can select the OS, the VM
    size, auto or manual scaling, the minimum and maximum node count, and the maximum
    pods per node. The allowed range is from 30–250 pods per node. One pod can run
    one or more containers. In most Kubernetes configurations, a pod runs one container.
    If the pod or the node where the pod runs fails, Kubernetes creates a replica.
  prefs: []
  type: TYPE_NORMAL
- en: With the **Node pools** configuration, you can also enable virtual nodes. Virtual
    nodes make use of Azure Container Instances, which allow the fast startup of containers
    if more load is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Creating user node pools allows you to select Windows for a node pool. This
    allows running legacy applications on Kubernetes. This is a difference AKS has
    to offer that’s not available with Azure Container Apps.
  prefs: []
  type: TYPE_NORMAL
- en: After the **Node pools** configuration, clicking **Next** leads to the **Networking**
    configuration. Leave this with the default settings. Clicking **Next** again opens
    the **Integrations** settings (see *Figure 16**.4*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – AKS Integrations settings](img/B21217_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – AKS Integrations settings
  prefs: []
  type: TYPE_NORMAL
- en: With the **Integrations** settings, select the previously created ACR. With
    AKS, a direct integration with the registry is offered.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking `OnPremises` launch profile, Docker containers for Grafana and Prometheus
    are configured. Alternatively, the Azure services Managed Prometheus and Managed
    Grafana could be used.
  prefs: []
  type: TYPE_NORMAL
- en: Leave the remaining settings as default. By clicking on **Review + create**,
    the final checks are done. If this succeeds, click the **Create** button. Creating
    an AKS takes several minutes – but it’s a lot faster than creating a Kubernetes
    cluster manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'After deployment to the Kubernetes cluster succeeds, connect the Kubernetes
    command-line client, `kubectl`, to AKS. With Docker Desktop, this tool is installed
    with it. To connect `kubectl` to this AKS installation, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds the connection to AKS to the `%HOMEPATH%/.kube/config` configuration
    file. Now, you can use the `kubectl` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This returns the running nodes from the AKS service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s publish our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Aspir8 to deploy to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With .NET Aspire, we created the app model to define all the dependencies between
    the different resources that are used. First, in [*Chapter 1*](B21217_01.xhtml#_idTextAnchor014),
    you saw the Aspire manifest that’s created from an app model. This manifest file
    is independent of any technology where to deploy it. The Azure Developer CLI creates
    Bicep scripts for deploying the solution (see [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137)
    and [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)). The open source tool **Aspirate**
    (**Aspir8**) (see [https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests))
    converts the Aspire manifest file to Docker Compose or Kubernetes with **Helm**
    charts or **kustomize** manifests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an Aspire manifest for every launch profile, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our app model is defined with two different versions. One version uses cloud-native
    Azure services, while the other option is independent of any cloud environment.
    The second one is configured by starting the application with the `OnPremises`
    launch profile.
  prefs: []
  type: TYPE_NORMAL
- en: With `dotnet run`, we pass the `--launch-profile OnPremises` option to start
    the application using the profile as specified with the `launchprofiles.json`
    file. The `--` option is a separator to specify arguments to the running application.
    The `--publisher manifest` option creates the Aspire manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have a strict separation with the Codebreaker app model definition. It’s
    also possible in a somehow mixed mode. For example, you can use a solution running
    on-premises to use Azure Application Insights running within Azure to get the
    advantages of this cloud service offering. You can also use Azure Functions to
    run on an on-premises Kubernetes cluster. Many options are available to choose
    the service that best fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the `aspirate` tool, it needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At the time of this writing, this tool is not released, thus it’s necessary
    to set the `--prerelease` option. The `-g` option installs this tool as a global
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, the `aspirate` tool is in a prerelease state, and
    changes are expected. Check the README file of [*Chapter 16*](B21217_16.xhtml#_idTextAnchor373)
    from the book’s repository for the latest updates deploying the Codebreaker application
    to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, you can specify an initial configuration with Aspir8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `aspirate` tool allows specifying a launch profile similar to the .NET CLI
    to customize the configuration accordingly. By using `aspirate init`, you can
    specify a container builder and select between Docker Desktop and Podman. The
    default setting is Docker Desktop. With a fallback value for the container registry,
    enter the URL of the ACR you created. `aspirate init` creates the `aspirate-state.json`
    file with the configuration specified. You can rerun `aspirate init`, which overwrites
    this configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Kubernetes manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now use the app model with the launch profile to generate manifests for
    publishing to Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`aspirate generate` can create Kubernetes manifests for deployment, as well
    as build and publish Docker images. Here, we don’t build Docker images by using
    the `--skip-build` option. With the `--launch-profile` option, the `AppHost` project
    with the app model is directly used. `aspirate generate` can also reference the
    previously generated .NET Aspire manifest with the `--aspirate-manifest` option
    instead. By setting `--output-path`, a different folder is specified to create
    the output result. The `--namespace` option is Kubernetes-related to define a
    namespace for the services deployed. This makes it easier to differentiate between
    the different services running on the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`aspirate` supports generating manifests using Helm and `kustomize`. Helm is
    a package manager that uses a packaging format named `kustomize` is a configuration
    manager natively built into `kubectl` with a template-free approach to patch and
    merge YAML files.'
  prefs: []
  type: TYPE_NORMAL
- en: Check the result of the `kustomize-output` folder. For every project specified,
    a folder is created (e.g., `gameapis`, `bot`, and `redis`) that contains `deployment.yaml`,
    `service.yaml`, and `kustomization.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: A deployment defines a declarative configuration for a pod and a replica set.
    The “desired state” of a pod is described by the deployment. In this file, you
    can read and change the number of replicas used, and the containers running in
    a pod.
  prefs: []
  type: TYPE_NORMAL
- en: A service defines a network application. This specifies the ports used with
    the application. A service runs in one or more pods.
  prefs: []
  type: TYPE_NORMAL
- en: The `kustomization.yaml` file references both `deployment.yaml` and `service.yaml`,
    and specifies configuration values such as the environment variables you’ve seen
    with the .NET Aspire dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Having the manifest files ready, we can create Docker images and push them to
    the ACR.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and pushing Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `aspirate build`, we can build and publish Docker images to the registry.
    With the `aspirate` tool, it’s possible to specify username and password values
    to push images to private registries. When using ACR, this is not necessary because
    Aspir8 makes use of `dotnet publish`. Just make sure to log in to the ACR using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use `aspirate build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Starting this command, specify the name of your registry. Specifying multiple
    tags will add them to the repository as shown in *Figure 16**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – AKS repository](img/B21217_16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – AKS repository
  prefs: []
  type: TYPE_NORMAL
- en: The images are pushed to the ACR and show the `latest` and `3.8` tags, as specified
    with `aspirate build`. Next, deploy the images with the Kubernetes manifests to
    the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can apply the manifests to the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `aspirate apply` command uses the previously created manifest files to
    apply the services and deployments to the Kubernetes cluster by using the `kubectl
    apply` command. Just make sure to have AKS configured as the default Kubernetes
    environment (using the previously used command after creating AKS: `az` `aks get-credentials`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command shows the deployments from the `codebreakerns` namespace. You can
    see the deployments that are available and ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, use this command to see the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see the services with the IP addresses running, and the ports registered.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can configure an `aspirate`. For now, check the *Further reading* section
    to see how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aspir8 also supports Docker Compose besides Kubernetes with `kustomize` and
    Helm. By using `aspirate generate`, you can supply `compose` with the `--output-format`
    option. This creates a simple Docker Compose file that you can start with the
    Docker CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about some final considerations for deploying applications
    using a microservices architecture in a production environment. You now have awareness
    of running the solution in multiple regions and using availability zones and can
    discuss the impact in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about AKS as a managed option to host a Kubernetes cluster and deploy
    the solution by using the .NET Aspire manifest to create deployments with Aspir8.
  prefs: []
  type: TYPE_NORMAL
- en: By reaching [*Chapter 16*](B21217_16.xhtml#_idTextAnchor373) of this book, you’ve
    done an impressive tour, starting with minimal APIs, and adding more services
    from chapter to chapter using different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: With the book’s repository, the solution is planned to be updated to newer .NET
    and .NET Aspire versions. As newer versions become available, the book version
    will stay available in the `dotnet8` branch.
  prefs: []
  type: TYPE_NORMAL
- en: To see more developments with Codebreaker, check the [https://github.com/codebreakerapp](https://github.com/codebreakerapp)
    organization. There, you can see further developments of the solution, as well
    as a list of client applications. Also, check [https://codebreaker.app](https://codebreaker.app)
    to play a few games – of course, now you can also use a version running in your
    (hosted) Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Business continuity and disaster* *recovery*: [https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/design-area/management-business-continuity-disaster-recovery](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/design-area/management-business-continuity-disaster-recovery)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure load-balancing* *options*: [https://learn.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview](https://learn.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes: [https://kubernetes.io/](https://kubernetes.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn Kubernetes basics: [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm – the package manager for Kubernetes: [https://helm.sh](https://helm.sh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `kubectl` command-line tool: [https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aspirate GitHub repository: [https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*aspir8 from* *scratch*: [https://github.com/devkimchi/aspir8-from-scratch](https://github.com/devkimchi/aspir8-from-scratch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configure ingress with Azure Kubernetes* *Services*: [https://learn.microsoft.com/en-us/azure/aks/app-routing](https://learn.microsoft.com/en-us/azure/aks/app-routing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploy a .NET microservice to Kubernetes* *manually*: [https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/](https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl` – the definitive pronunciation guide: [https://www.youtube.com/watch?v=2wgAIvXpJqU](https://www.youtube.com/watch?v=2wgAIvXpJqU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
