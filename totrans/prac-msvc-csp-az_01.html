<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Introduction to .NET Aspire and Microservices</h1>
			<p>Welcome to creating a solution consisting of Microservices. The first chapter provides the foundations for the microservices solution that will be developed in <span class="No-Break">this book.</span></p>
			<p>Here, you will learn which features .NET Aspire offers for microservices. In this book, we create the <strong class="bold">Codebreaker</strong> solution. You <a id="_idIndexMarker000"/>will learn what Codebreaker is and the parts it consists of. In the last section of this chapter, you’ll learn which Azure services are used while we create the application on the tour up to the <span class="No-Break">last chapter.</span></p>
			<p>The first chapter lays <span class="No-Break">the foundation.</span></p>
			<p>In this chapter, you will learn about the advantages that are offered by .NET Aspire on creating microservices and you will gain the foundational knowledge needed to work with this technology, including how to define the app model, what it means for development and deployment, how service discovery is used, and how Azure resources are deployed while debugging the <span class="No-Break">solution locally.</span></p>
			<p>You will get an overview of the application we built in this book, the parts of the solution, and how the different services <span class="No-Break">are connected.</span></p>
			<p>In this chapter, you will learn about <span class="No-Break">the following:</span></p>
			<ul>
				<li>Creating .NET <span class="No-Break">Aspire projects</span></li>
				<li>The parts of the <span class="No-Break">Codebreaker solution</span></li>
				<li>Using Microsoft Azure with .<span class="No-Break">NET Aspire</span></li>
				<li>Azure services used by the <span class="No-Break">Codebreaker solution</span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>In this chapter, you need .NET 8 with the .NET Aspire workload, either Visual Studio or Visual Studio Code, Docker Desktop, and a Microsoft Azure subscription. Information about the installation is explained in this chapter and the readme file of the source <span class="No-Break">code repository.</span></p>
			<p>The code for this chapter can be found in this GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</span></a><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">ch01</strong> folder, you’ll see the projects with the results of this chapter. You’ll see <span class="No-Break">these folders:</span></p>
			<ul>
				<li><strong class="source-inline">Aspire</strong>: This folder contains four projects created with a .NET Aspire template to run a .NET Aspire project including one service and a <span class="No-Break">web application</span></li>
				<li><strong class="source-inline">Azure</strong>: This folder contains the same four projects from the previous folder, enhanced by using an <span class="No-Break">Azure resource</span></li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Starting with .NET Aspire</h1>
			<p>.NET Aspire is <a id="_idIndexMarker001"/>a new .NET technology offering tools and libraries that help create, debug, and deploy .NET solutions built using microservices. With all the chapters of this book, we’ll take advantage of .<span class="No-Break">NET Aspire.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this chapter, you’ll get a core understanding of how .NET Aspire works. In all the other chapters, we’ll make use of .NET Aspire and get into <span class="No-Break">the details.</span></p>
			<p>You can install it using <a id="_idIndexMarker002"/>the .NET <strong class="bold">Command Line Interface</strong> (<strong class="bold">CLI</strong>) or using Visual Studio 2022. The first version of .NET Aspire is based on .NET 8, thus at least .NET 8 is required to use .<span class="No-Break">NET Aspire.</span></p>
			<p>.NET Aspire requires .NET 8, and can be installed by installing a .<span class="No-Break">NET workload:</span></p>
			<pre class="console">
dotnet workload install aspire</pre>
			<p>To see the workloads installed, and the version of .NET Aspire, use <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet workload list</pre>
			<p>If you use Visual Studio, use the Visual Studio Installer, and select the <strong class="bold">.NET Aspire SDK</strong> component to install .<span class="No-Break">NET Aspire.</span></p>
			<p>.NET Aspire apps <a id="_idIndexMarker003"/>are designed to run in containers. Running the application locally, projects run directly on the system without the need for a Docker engine. Docker containers are used when deploying the solution. We can (and will) use available Docker images as part of the application. Here, the container runtime is required to run locally. In this book, we use the most used container runtime – <strong class="bold">Docker Desktop</strong>. Docker Desktop is<a id="_idIndexMarker004"/> free for personal use and for small companies. .NET Aspire also supports running containers<a id="_idIndexMarker005"/> <span class="No-Break">with </span><span class="No-Break"><strong class="bold">Podman</strong></span><span class="No-Break">.</span></p>
			<p>After the installation of .NET Aspire, create a <span class="No-Break">new project.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Creating a .NET Aspire project</h2>
			<p>When .NET Aspire <a id="_idIndexMarker006"/>is installed, you can create a new project containing an API service and a Blazor client application using <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet new aspire-starter -o AspireSample</pre>
			<p>With this template, four projects <span class="No-Break">are created:</span></p>
			<ul>
				<li><strong class="source-inline">AspireSample.ApiService</strong>: This project contains a REST service that uses ASP.NET Core <span class="No-Break">minimal APIs</span></li>
				<li><strong class="source-inline">AspireSample.Web</strong>: An ASP.NET Core Blazor application that sends requests to the <span class="No-Break">API service</span></li>
				<li><strong class="source-inline">AspireSample.ServiceDefaults</strong>: A library project with shared initialization code for all services of <span class="No-Break">the solution</span></li>
				<li><strong class="source-inline">AspireSample.AppHost</strong>: The app host project defines the app model of the solution, and how all the resources <span class="No-Break">are connected</span></li>
			</ul>
			<p>Let’s build and start the <span class="No-Break">solution next.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>The .NET Aspire dashboard</h2>
			<p>When you start the<a id="_idIndexMarker007"/> newly created project (the AppHost project needs to be the starting project), a console opens, showing the logs of the AppHost, and the browser opens a dashboard that shows the resources of the project, as you can see in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B21217_01_01.jpg" alt="Figure 1.1 – Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Aspire dashboard</p>
			<p>With the .NET Aspire dashboard, you can see the resources running (<strong class="source-inline">apiservice</strong> and <strong class="source-inline">webfrontend</strong> in this image), the state of the resources, and the endpoints, and can access details and logs. In the left pane, you have access to logs, traces, and metrics data. While<a id="_idIndexMarker008"/> the dashboard<a id="_idIndexMarker009"/> is typically not used in production environments (we have <strong class="bold">Prometheus</strong>, <strong class="bold">Grafana</strong>, <strong class="bold">Azure Application Insights</strong>, and other environments), it’s<a id="_idIndexMarker010"/> great to know all this information during development time. Are there memory leaks with services? How does the interaction with services happen? Where are the bottlenecks? You can find this information using the dashboard. This is discussed in detail in <a href="B21217_11.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Because the .NET Aspire dashboard is that great, it’s available as a Docker image and can be used in small scenarios in production as well, but it has limitations outside of the <span class="No-Break">development environment.</span></p>
			<p>When you click on the link of the <strong class="source-inline">webfrontend</strong>, the application opens. In case you already created Blazor applications, you <a id="_idIndexMarker011"/>already know the links from the application, as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B21217_01_02.jpg" alt="Figure 1.2 – webfrontend"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – webfrontend</p>
			<p>As you click the <strong class="bold">Weather</strong> link in the left pane, <strong class="source-inline">webfrontend</strong> makes a request to <strong class="source-inline">apiservice</strong> for random <span class="No-Break">weather information.</span></p>
			<p>The app is running, so let’s get into the generated code for .NET <span class="No-Break">Aspire next.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>The .NET Aspire app model</h2>
			<p>To <a id="_idIndexMarker012"/>start digging into .NET Aspire, you need to learn the <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">AspireSample.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = <strong class="bold">DistributedApplication.CreateBuilder(args);</strong>
var apiService = builder.<strong class="bold">AddProject</strong>&lt;Projects.AspireSample_ApiService&gt;(<strong class="bold">"apiservice"</strong>);
// code removed for brevity</pre>
			<p>If you are used to the app builder pattern with .NET applications and the <strong class="source-inline">Host</strong> class to configure the DI container, app configuration, and logging, you can see some similarities. Here, a <strong class="source-inline">DistributedApplication</strong> class is used to create <strong class="source-inline">IDistributedApplicationBuilder</strong> with the <strong class="source-inline">CreateBuilder</strong> method. The returned builder is used to define all the resources needed by the solution. With the generated code, two projects are mapped using the <strong class="source-inline">AddProject</strong> method. The projects are referenced with a generic type, for example, <strong class="source-inline">Projects.AspireSample_ApiService</strong>. This type was created by adding a project reference to the <strong class="source-inline">AspireSample.ApiService</strong> project. You can see the reference when you open the <strong class="source-inline">AspireSample.AppHost.csproj</strong> <span class="No-Break">project file.</span></p>
			<p>Using <a id="_idIndexMarker013"/>project types with <strong class="source-inline">AddProject</strong> is convenient, but it’s not a requirement. You can also pass a string of a directory where the <span class="No-Break">project resides.</span></p>
			<p>Other than adding projects, it’s possible to add executables (<strong class="source-inline">AddExecutable</strong>) or Docker <span class="No-Break">images (</span><span class="No-Break"><strong class="source-inline">AddContainer</strong></span><span class="No-Break">).</span></p>
			<p>.NET Aspire also offers a huge list of predefined resources, for example, RabbitMQ, Kafka, Redis, and SQL Server, and resources running within Microsoft Azure, such as Azure Cosmos DB, Azure Key Vault, and Azure Event Hub. To add resources to the app model, NuGet packages are prefixed with <strong class="source-inline">Aspire.Hosting</strong> and <strong class="source-inline">Aspire.Hosting.Azure</strong> needs to <span class="No-Break">be added.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this book, many new resources are added to the Codebreaker solution. <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> adds SQL Server and Azure Cosmos DB, <a href="B21217_05.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> adds Docker containers, <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> adds Azure App Configuration and Azure Key Vault, <a href="B21217_11.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> adds Azure Log Analytics, Prometheus, and Grafana, <a href="B21217_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> adds Azure SignalR Services, and <span class="No-Break">so on.</span></p>
			<p>The name <strong class="source-inline">"apiservice"</strong> that’s passed as a parameter passed to the <strong class="source-inline">AddProject</strong> method defines the name of the resource. We’ll use this name later in the <em class="italic">Using service </em><span class="No-Break"><em class="italic">discovery</em></span><span class="No-Break"> section.</span></p>
			<p><strong class="source-inline">AddProject</strong> returns an object of the <strong class="source-inline">IResourceBuilder&lt;ProjectResource&gt;</strong> type. The <strong class="source-inline">IResourceBuilder</strong> objects can be used to connect multiple resources within the app model. The <strong class="source-inline">ProjectResource</strong> type derives from the <strong class="source-inline">Aspire.Hosting.ApplicationModel.Resource</strong> base class and implements several resource interface types, such as <strong class="source-inline">IResourceWithEnvironment</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">IResourceWithServiceDiscovery</strong></span><span class="No-Break">.</span></p>
			<p>Let’s use this<a id="_idIndexMarker014"/> resource object to connect <span class="No-Break">another resource:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.AppHost/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
builder.<strong class="bold">AddProject</strong>&lt;Projects.AspireSample_Web&gt;("webfrontend")
<strong class="bold">  .WithExternalHttpEndpoints()</strong>
<strong class="bold">  .WithReference(apiService);</strong>
builder.Build().Run();</pre>
			<p>The <strong class="source-inline">apiService</strong> variable returned from the first <strong class="source-inline">AddProject</strong> method is referenced with the second project – a web frontend – using the <strong class="source-inline">WithReference</strong> method. This allows accessing the web frontend to access the API service. The URL of the API service is assigned as an environment variable to the web frontend – this is what the <strong class="source-inline">IResourceWithServiceDiscovery</strong> interface is used for. While the API service does not need to be accessed externally (only the web frontend needs access), the web frontend should be accessible from the outside. That’s why the <strong class="source-inline">WithExternalHttpEndpoints</strong> method is used with the web frontend project. This configuration information is used to specify how the Ingress controller added as a proxy to the resource <span class="No-Break">is configured.</span></p>
			<p>Before looking into the projects that are referenced by the AppHost, let’s get into the shared <span class="No-Break"><strong class="source-inline">AspireSample.ServiceDefaults</strong></span><span class="No-Break"> project.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>The shared project for common configuration</h2>
			<p>The <strong class="source-inline">AspireSample.ServiceDefaults</strong> project is a library with a common configuration <a id="_idIndexMarker015"/>that can be used by all the <span class="No-Break">resource projects:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static class Extensions
{
<strong class="bold">  public static IHostApplicationBuilder AddServiceDefaults(this </strong>
<strong class="bold">    IHostApplicationBuilder builder)</strong>
  {
    builder.ConfigureOpenTelemetry();
    builder.AddDefaultHealthChecks();
<strong class="bold">    builder.Services.AddServiceDiscovery();</strong>
    builder.Services.<strong class="bold">ConfigureHttpClientDefaults</strong>(http =&gt;
    {
<strong class="bold">      http.AddStandardResilienceHandler();</strong>
<strong class="bold">      http.AddServiceDiscovery();</strong>
    });
    return builder;
  }
  // code removed for brevity</pre>
			<p>This shared <a id="_idIndexMarker016"/>project contains the <strong class="source-inline">AddServiceDefaults</strong> extension method that implements a common configuration for the resource applications. With the implementation, <strong class="source-inline">ConfigureOpenTelemetry</strong> is invoked, which is another extension method defined by the <strong class="source-inline">Extensions</strong> class. The parts that are common for logging, metrics, and distributed tracing are implemented here. This is covered in <a href="B21217_11.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. <strong class="source-inline">AddDefaultHealthChecks</strong> configures health checks for the services, which can include health checks for the .NET Aspire components that <span class="No-Break">are used.</span></p>
			<p><strong class="source-inline">AddServiceDiscovery</strong> makes use of the <strong class="source-inline">Microsoft.Extensions.ServiceDiscovery</strong> library, which is also new since the first release of .NET Aspire, but can also be used independently of .NET Aspire. The <strong class="source-inline">AddServiceDiscovery</strong> method registers default service endpoint resolvers. Service discovery is not only configured with the DI container but also with the configuration of the HTTP client, with the lambda parameter of the <strong class="source-inline">ConfigureHttpClientDefaults</strong> method. Service discovery is discussed in the next section. <strong class="source-inline">ConfigureHttpClientDefaults</strong> is part of the <strong class="source-inline">Microsoft.Extensions.Http</strong> library, the HTTP client factory. The package that’s referenced from the <strong class="source-inline">ServiceDefaults</strong> library is <strong class="source-inline">Microsoft.Extensions.Http.Resiliency</strong>. This library is new since .NET 8 and offers<a id="_idIndexMarker017"/> extensions to the Polly library. With a distributed application, invocations sometimes fail on transient issues. Retrying invocations to these resources can succeed when invoked another time. This functionality is built into .NET Aspire with default resiliency configuration <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">AddStandardResilienceHandler</strong></span><span class="No-Break">.</span></p>
			<p>But now, let’s get into <span class="No-Break">service discovery.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Using service discovery</h2>
			<p><strong class="source-inline">webfrontend</strong> needs<a id="_idIndexMarker018"/> to know about the link of <strong class="source-inline">apiservice</strong> to get the weather information. This link is different depending on the environment<a id="_idIndexMarker019"/> the solution is running with. Running the application locally on the development system, we use localhost links with different port numbers, and depending on the environments where the solution is running (for example, Azure Container App environments, Kubernetes, etc.), different configurations <span class="No-Break">are required.</span></p>
			<p>With the new service discovery, logical names can be used for the services, which are resolved using different providers. Thus, the same functionality works in <span class="No-Break">different environments.</span></p>
			<p>The Blazor client application <span class="No-Break">configures </span><span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.Web/Program.cs</p>
			<pre class="source-code">
builder.Services.AddHttpClient&lt;WeatherApiClient&gt;(client =&gt;
{
<strong class="bold">  client.BaseAddress = new("https+http://apiservice");</strong>
});
// code removed for brevity</pre>
			<p>The <strong class="source-inline">apiservice</strong> name<a id="_idIndexMarker020"/> comes from the app model definition – the name that has been passed to the <strong class="source-inline">AddProject</strong> method. Before the colon, the schema, for example, <strong class="source-inline">http</strong> or <strong class="source-inline">https</strong> can be specified. Separating schemas with <strong class="source-inline">+</strong> allows the use of multiple schemas, and the first one <span class="No-Break">is preferred.</span></p>
			<p>The <strong class="source-inline">AddServiceDiscovery</strong> method<a id="_idIndexMarker021"/> that was added to the DI container earlier adds a configuration-based endpoint resolver by default. With this, the configuration can be added to a JSON configuration file, for example, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
{
  "<strong class="bold">Services</strong>": {
    "<strong class="bold">apiservice</strong>": {
      "<strong class="bold">https</strong>": [
        "localhost:8087",
        "10.466.24.90:80"
      ]
    }
  }
}</pre>
			<p>With the configuration, the section needs to be named <strong class="source-inline">Services</strong>. Within the <strong class="source-inline">Services</strong> section, the named service is looked for (<strong class="source-inline">apiservice</strong>), and there, the values below the schema name (<strong class="source-inline">https</strong>) are resolved. The port numbers are randomly created and will differ with <span class="No-Break">your environment.</span></p>
			<p>With the AppHost, as <strong class="source-inline">apiservice</strong> is referenced from the web frontend, the URIs to the API service are added as environment variables. Open the .NET Aspire dashboard, and in the <strong class="bold">Details</strong> column, click <strong class="bold">View</strong> with <strong class="source-inline">webfrontend</strong>. There, you can see the <strong class="source-inline">services__apiservice_http__0</strong> and <strong class="source-inline">services__apiservice_https_0</strong> environment variables, and the <strong class="source-inline">http://localhost:5395</strong>, and <strong class="source-inline">https://localhost:7313</strong> values. The<a id="_idIndexMarker022"/> URIs are specified <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">Properties/launchsettings.json</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.ApiService/Properties/launchSettings.json</p>
			<pre class="source-code">
"profiles": {
  "http": {
    "commandName": "Project",
    "dotnetRunMessages": true,
    "launchBrowser": true,
    "launchUrl": "weatherforecast",
<strong class="bold">    "applicationUrl": "http://localhost:5395",</strong>
    "environmentVariables": {
      "ASPNETCORE_ENVIRONMENT": "Development"
    }
  },
  "https": {
    "commandName": "Project",
    "dotnetRunMessages": true,
    "launchBrowser": true,
    "launchUrl": "weatherforecast",
<strong class="bold">    "applicationUrl": "https://localhost:7313;http://localhost:5395",</strong>
    "environmentVariables": {
      "ASPNETCORE_ENVIRONMENT": "Development"
    }
  }
}</pre>
			<p>The <strong class="source-inline">applicationUrl</strong> setting defines the URLs used on starting the application, and this is the link that is used to add it to the environment variable. Because environment variables are part of the .NET configuration, these values are retrieved by the service discovery <span class="No-Break">configuration provider.</span></p>
			<p>Azure Container Apps<a id="_idIndexMarker023"/> and Kubernetes offer service <a id="_idIndexMarker024"/>discovery features without using a service discovery library. With applications deployed there, a pass-through provider is configured <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">DnsEndPoint</strong></span><span class="No-Break">.</span></p>
			<p>Running the .NET Aspire solution locally, the process of <strong class="source-inline">webfrontend</strong> and <strong class="source-inline">apiservice</strong> use random ports. A reverse proxy is automatically added before these processes, and the reverse proxy is accessible via the configured <span class="No-Break">launch settings.</span></p>
			<p>This allows the changing of the number of replicas with the <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.AppHost/Program.cs</p>
			<pre class="source-code">
var apiService = builder.AddProject&lt;Projects.AspireSample_ApiService&gt;("apiservice")
<strong class="bold">  .WithReplicas(3);</strong></pre>
			<p>With the app model configuration in the AppHost, using <strong class="source-inline">WithReplicas(3)</strong> starts three instances of the service using three random ports, and the same port number from the reverse proxy as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B21217_01_03.jpg" alt="Figure 1.3 – Multiple replicas"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Multiple replicas</p>
			<p>You can see three <strong class="source-inline">apiservice-</strong> services running with different postfixes, and three processes with the same port number, as shown with the endpoints. The endpoint defined from the<a id="_idIndexMarker025"/> launch settings is the endpoint of the reverse proxy. When you open <strong class="bold">Details</strong>, you<a id="_idIndexMarker026"/> can see different target ports with every service. The reverse proxy acts as a load balancer to choose one of <span class="No-Break">the replicas.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To start the solution with the <strong class="source-inline">http</strong> launch profile, you need to add the <strong class="source-inline">ASPIRE_ALLOW_UNSECURED_TRANSPORT</strong> environment variable to the launch settings of the AppHost project and set it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>This was an important core functionality from .NET Aspire. However, <span class="No-Break">there’s more.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>.NET Aspire components</h2>
			<p>.NET Aspire components <a id="_idIndexMarker027"/>make it easy to use Microsoft and third-party features and services from within the applications that are configured. Azure Cosmos DB, Pomelo MySQL Entity Framework Core, and SQL Server are components available to access databases, and RabbitMQ, Apache Kafka, and Azure Service Bus are components for messaging. There’s a list available <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview</span></a><span class="No-Break">.</span></p>
			<p>To use a component, typically with the AppHost, a resource needs to be configured by adding a host NuGet package, for example, for the Azure Cosmos DB EF Core component, you would add the <strong class="source-inline">Aspire.Hosting.Azure.CosmosDB</strong> package. The component itself is then used by adding the <strong class="source-inline">Aspire.Microsoft.EntityFrameworkCore.Cosmos</strong> package to the service that accesses the database, for example, the <span class="No-Break">API service.</span></p>
			<p>What does a component have to offer? Do you know what names are used by a technology to turn on logging metrics data? Aspire components know this, and it’s easy to configure it. When an Azure Cosmos DB resource is added to the app model, and is referenced by a service project, the connection string is configured as an environment variable (or stored within a secret store) and can be accessed by the project that needs <span class="No-Break">the connection.</span></p>
			<p>In many of the book chapters, we’ll add some new components, thus we don’t get into more <span class="No-Break">details here.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Creating the app model manifest</h2>
			<p>With<a id="_idIndexMarker028"/> the app model defined in the <strong class="source-inline">AppHost</strong> project, we can create a JSON manifest file that describes the resources. You need to stop the project to allow a rebuild if it’s <span class="No-Break">still running:</span></p>
			<pre class="console">
cd ApireSample.AppHost
dotnet run --publisher manifest --output-path aspire-manifest.json</pre>
			<p>An extract of this manifest file is shown in the <span class="No-Break">following snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.AppHost/aspire-manifest.json</p>
			<pre class="source-code">
"webfrontend": {
  "type": "project.v0",
  "path": "../AspireSample.Web/AspireSample.Web.csproj",
  "env": {
    "services__apiservice__http__0": "{apiservice.bindings.http.url}",
    "services__apiservice__https__0": "{apiservice.bindings.https.url}"
  },
  "bindings": {
    "https": {
      "scheme": "https",
      "protocol": "tcp",
      "transport": "http",
      "external": true
    }
  }
}</pre>
			<p>The <a id="_idIndexMarker029"/>manifest contains information about the resource type, environment variables, binding, and more. With the app model, we can also specify the use of Azure resources. This manifest file can now be used by tools to deploy the solution, (e.g., by using the Azure Developer CLI to deploy it to Microsoft Azure). Creating Azure resources is covered in <a href="B21217_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> and continued from there in <span class="No-Break">other chapters.</span></p>
			<p>Using Aspir8 (an open-source project, see <a href="https://github.com/prom3theu5/aspirational-manifests/">https://github.com/prom3theu5/aspirational-manifests/</a>), it’s possible to deploy the solution to a Kubernetes cluster. This is used in <a href="B21217_16.xhtml#_idTextAnchor373"><span class="No-Break"><em class="italic">Chapter 16</em></span></a><span class="No-Break">.</span></p>
			<p>The app model can be customized based on different launch profiles. With this, different manifest files can be created to deploy to (e.g., Azure and use specific Azure resources and to an on-premises <span class="No-Break">Kubernetes cluster).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The AppHost project containing the app model is used when starting and debugging the project during development. For deployment, the manifest of the app model is used. When running the solution in the production environment, the app host is no longer <span class="No-Break">in action.</span></p>
			<p>.NET Aspire is used in this book from the first to the last chapter. Let’s look into what we <span class="No-Break">are building.</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Codebreaker – the solution</h1>
			<p>The <a id="_idIndexMarker030"/>Codebreaker solution is a traditional game to solve a set of colors. With one game type, the player needs to place four colors (which can be duplicates) from a list of six different colors. The correct colors are chosen randomly by the game service. With every move the player makes, an answer is returned: for every color that is correct and positioned at the correct place, a black peg is returned. For every color<a id="_idIndexMarker031"/> that is correct but wrongly positioned, a white peg is returned. The player now has up to 12 moves to find the correct solution. <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.4</em> shows a game run using a Blazor <span class="No-Break">client application.</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B21217_01_04.jpg" alt="Figure 1.4 – Blazor client application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Blazor client application</p>
			<p>This gameplay shows that the solution was found after five moves. In this case, the correct result was yellow – black – red – black. The first selection was red – green – blue – yellow, with a result of two white pegs. With the fifth move, yellow – black – red – black was selected and four black pegs were returned, which means this is the <span class="No-Break">correct move.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Creating client applications is not part of this book (just a simple console application accessing the API is done in <a href="B21217_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>). However, the source code for several client applications is available <span class="No-Break">at </span><a href="https://github.com/codebreakerapp"><span class="No-Break">https://github.com/codebreakerapp</span></a><span class="No-Break">.</span></p>
			<p>Creating a <a id="_idIndexMarker032"/>service to run some game rules seems like a simple task that doesn’t need a microservices architecture. However, there’s more, as shown in the sequence diagrams in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.5</em> and <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B21217_01_05.jpg" alt="Figure 1.5 – The Codebreaker play games sequence"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – The Codebreaker play games sequence</p>
			<p>Multiple services are needed with the solution. The game API service is not only invoked by UIs used by human players; a bot service, which can be triggered on receiving a message, plays multiple games on its own, and the game API service writes information about games and <a id="_idIndexMarker033"/>every move set to <span class="No-Break">a database.</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B21217_01_06.jpg" alt="Figure 1.6 – Codebreaker game completion sequence"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Codebreaker game completion sequence</p>
			<p>On completion of a game, the game API service not only writes this information to a database but also sends events. These events are received by a live service and a ranking service. The live service is used by live clients to monitor running games using ASP.NET Core SignalR. The ranking service writes completed games to its own database, which can be used by clients to get daily, weekly, and monthly game ranks. A service running Microsoft YARP is used as well to authenticate users and forward requests to the <span class="No-Break">different services.</span></p>
			<p>The Codebreaker solution makes use of several Azure services, as <span class="No-Break">discussed next.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Using Microsoft Azure</h1>
			<p>To create and <a id="_idIndexMarker034"/>run the code from this book, you also need to have an Azure subscription. You can activate Microsoft Azure for free at <a href="https://azure.microsoft.com/free">https://azure.microsoft.com/free</a>, which gives you an amount of about $200 Azure credits that are available for the first 30 days and several services that can be used for free for the <span class="No-Break">time after.</span></p>
			<p>What many developers miss is that if you have a Visual Studio Professional or Enterprise subscription, you also have a free amount of Azure resources every month. You just need to activate this with your Visual Studio <span class="No-Break">subscription: </span><a href="https://visualstudio.microsoft.com/subscriptions/"><span class="No-Break">https://visualstudio.microsoft.com/subscriptions/</span></a><span class="No-Break">.</span></p>
			<p>To<a id="_idIndexMarker035"/> create and manage resources, we use the Azure Portal, the Azure CLI, and the Azure Developer CLI. On Windows, you can install them with <span class="No-Break">the following:</span></p>
			<pre class="console">
winget install Microsoft.AzureCLI
winget install Microsoft.Azd</pre>
			<p>To install these tools on Mac and Linux, check <a href="https://learn.microsoft.com/en-us/cli/azure/install-azure-cli">https://learn.microsoft.com/en-us/cli/azure/install-azure-cli</a> <span class="No-Break">and </span><a href="https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd"><span class="No-Break">https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd</span></a><span class="No-Break">.</span></p>
			<p>Let’s look at the resources used with <span class="No-Break">Microsoft Azure.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Azure resources used by Codebreaker</h2>
			<p>To see<a id="_idIndexMarker036"/> what Azure resources are used, check <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B21217_01_07.jpg" alt="Figure 1.7 – Azure resources for Codebreaker"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Azure resources for Codebreaker</p>
			<p>The <a id="_idIndexMarker037"/>compute services where the solution is running is an Azure Container App environment. This is a service that abstracts a Kubernetes cluster. The bot service, game APIs, live service, ranking service, and the gateway using YARP run within Azure Container Apps. The Azure Storage queue is used from the bot service: as a message arrives in the queue, the bot service is triggered to play a series of games. The bot service can be used from all client apps as well – indirectly via a gateway, implemented with YARP. The game API service writes games to the Azure Cosmos DB and caches games with a Redis cluster. As games are completed, game events are pushed to the Azure Event Hub. The live service and ranking service are subscribers to the Event Hub. The live service uses ASP.NET Core SignalR, and to reduce the load of this service, the Azure SignalR service <span class="No-Break">is used.</span></p>
			<p>What’s commonly used is the Azure App Configuration for application configuration values and feature management, Azure Key Vault to store secrets, Azure Active Directory B2C for user registrations, and Log Analytics and Application Insights to monitor <span class="No-Break">the application.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Starting with a small version of Codebreaker, not that many Azure services would be required to use. For a flexible and scalable solution, which might be accessed worldwide, and to learn about all the different aspects of microservices, all these services are in use. Don’t be afraid of the cost when deploying the services with your Azure subscription. As long as you don’t create a huge load (which we do in <a href="B21217_12.xhtml#_idTextAnchor294"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>), the cost stays very small, and by far you will not use the full $200 available with the free subscription when you delete the resources again <span class="No-Break">after use.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Azure provisioning from the development environment</h2>
			<p>Your .NET Aspire solution can easily integrate with Microsoft Azure and deploy resources while debugging <span class="No-Break">the solution.</span></p>
			<p>By<a id="_idIndexMarker038"/> debugging the solution locally, not all resources need to be deployed to Azure. The service projects can run locally while testing and don’t need to be deployed. With Azure Cosmos DB, a Docker container or a locally installed emulator is available. This is not possible with all resources, for example, Azure Key Vault or Azure <span class="No-Break">Application Insights.</span></p>
			<p>To deploy these resources automatically, .NET Aspire needs access to your subscription. To do this, first, log in to your Azure subscription with the <span class="No-Break">Azure CLI:</span></p>
			<pre class="console">
az login</pre>
			<p>This opens a browser, and you can log in with your <span class="No-Break">Azure subscription.</span></p>
			<p>In case you have multiple subscriptions, check the Azure CLI is set to the <span class="No-Break">current one:</span></p>
			<pre class="console">
az account show</pre>
			<p>This shows the current active subscription. In case a different one should be used, use <strong class="source-inline">az account list</strong> to list all subscriptions, and <strong class="source-inline">az account set –subscription &lt;your subscription id&gt;</strong> to set the current subscription to a different one. Remember the value that’s listed with <strong class="source-inline">id</strong> – this is the subscription ID that’s needed with the <span class="No-Break">next steps.</span></p>
			<p>Now, we need to connect the project to the subscription and specify some settings. It’s best to put this information within user secrets; this shouldn’t be put into source <span class="No-Break">code repositories.</span></p>
			<p>In case user secrets are not configured yet with the <strong class="source-inline">AppHost</strong>, <span class="No-Break">initialize it:</span></p>
			<pre class="console">
cd AspireSample.AppHost
dotnet user-secrets init</pre>
			<p>The configurations we need are <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet user-secrets set Azure:SubscriptionId &lt;your subscription id&gt;
dotnet user-secrets set Azure:AllowResourceGroupCreation true
dotnet user-secrets set Azure:ResourceGroup rg-firstsample
dotnet user-secrets set Azure:Location westeurope
dotnet user-secrets set Azure:CredentialSource AzureCli</pre>
			<p>With <strong class="source-inline">SubscriptionId</strong>, you specify the subscription where resources are created. The <a id="_idIndexMarker039"/>resource group you specify with the value for <strong class="source-inline">ResourceGroup</strong> is used to create all the resources needed. The resource group will be created if you set <strong class="source-inline">AllowResourceGroupCreation</strong> to <strong class="source-inline">true</strong>. Otherwise, you need to create the resource group first. With the <strong class="source-inline">Location</strong> setting, specify your preferred location. To see the locations available with your subscription, use <strong class="source-inline">az account list-locations -</strong><span class="No-Break"><strong class="source-inline">o table</strong></span><span class="No-Break">.</span></p>
			<p>Setting the <strong class="source-inline">CredentialSource</strong> setting to <strong class="source-inline">AzureCli</strong> specifies that you are using the same account you just used to log in with the Azure CLI to create the resources. Without this setting, <strong class="source-inline">DefaultAzureCredential</strong> will be used, which tries to use multiple account types with a predefined list until one succeeds. This includes Visual Studio, Azure CLI, PowerShell, Azure Developer CLI, and other credentials. Here, credentials might be used which don’t have access to the subscription. In my experience, it’s better to supply the <span class="No-Break">credentials explicitly.</span></p>
			<p>To see all the secrets, use <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet user-secrets list</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Using Visual Studio, you can connect the project to Azure by using the Solution Explorer. Within the AppHost project, select <strong class="bold">Connected Services</strong>, open the context menu, and select <strong class="bold">Azure Resource Provisioning Settings</strong>. This opens a dialog to select the subscription, location, and <span class="No-Break">resource group.</span></p>
			<p>Next, let’s add the <strong class="source-inline">Aspire.Hosting.Azure.KeyVault</strong> NuGet package to the AppHost<a id="_idIndexMarker040"/> project, and update the <span class="No-Break">app model:</span></p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
<strong class="bold">var keyVault = builder.AddAzureKeyVault("secrets");</strong>
var apiService = builder.AddProject&lt;Projects.AspireSample_ApiService&gt;("apiservice")
  .WithReplicas(3)
<strong class="bold">  .WithReference(keyVault);</strong></pre>
			<p>The <strong class="source-inline">AddAzureKeyVault</strong> method creates a key vault named <strong class="source-inline">secrets</strong>. This is referenced from the <span class="No-Break"><strong class="source-inline">apiservice</strong></span><span class="No-Break"> project.</span></p>
			<p>When you start the AppHost now, the key vault will be created within Azure. Opening the <a id="_idIndexMarker041"/>Azure portal at <a href="https://portal.azure.com">https://portal.azure.com</a>, you will see the resource group, and within the resource group, the Azure Key Vault is created.  If you check the user secrets again, an <strong class="source-inline">Azure:Deployments</strong> section is added, which contains links to the resources created. This information is used to find the resources again, and they don’t need to be published again the next time you start <span class="No-Break">the application.</span></p>
			<p>When you are finished with this chapter, just delete the complete resource group from the portal, so no additional <span class="No-Break">cost applies.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To publish all the resources including the projects to Azure, you can use the Azure Developer CLI. This is covered in <a href="B21217_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Summary</h1>
			<p>In this chapter, you learned about the core features of .NET Aspire, which includes tooling, orchestration, and Aspire components. You learned how resources are connected by the Aspire app model, and how service discovery is done. You’ve seen how to create a manifest describing the app model, which can be used by tools to deploy <span class="No-Break">the solution.</span></p>
			<p>With the Codebreaker solution, you learned about the rules of the game and the parts of the application that are created from the second to the <span class="No-Break">last chapter.</span></p>
			<p>Now, you know the different Microsoft Azure services that are used by the Codebreaker solution when running in Azure. An alternative to these services is offered as well to run the complete solution in an on-premises environment (which can also be hosted in the Azure cloud <span class="No-Break">this way).</span></p>
			<p>From the next chapter on, we’ll start developing the Codebreaker solution. In <a href="B21217_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we will create REST services using ASP.NET Core minimal APIs to play games. We’ll test this API using <span class="No-Break">HTTP files.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><strong class="bold">.NET Aspire setup and </strong><span class="No-Break"><strong class="bold">tooling</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling</span></a></li>
				<li><strong class="bold">.NET Aspire </strong><span class="No-Break"><strong class="bold">components</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview</span></a></li>
				<li><strong class="bold">.NET Aspire manifest </strong><span class="No-Break"><strong class="bold">format</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format</span></a></li>
				<li><strong class="bold">GitHub repository for </strong><span class="No-Break"><strong class="bold">Aspir8</strong></span><span class="No-Break">: </span><a href="https://github.com/prom3theu5/aspirational-manifests"><span class="No-Break">https://github.com/prom3theu5/aspirational-manifests</span></a></li>
			</ul>
		</div>
	</body></html>