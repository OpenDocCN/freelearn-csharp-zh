["```cs\nvar method = typeof(MyComponent).GetMethod(\"MethodName\");\nif (method != null) {\n  method.MethodHandle.GetFunctionPointer();\n  Debug.Log(\"JIT compilation complete!\");\n}\n```", "```cs\nusing System.Reflection;\n// ...\nvar method = typeof(MyComponent).GetMethod(\"MethodName\",  \nBindingFlags.NonPublic | BindingFlags.Instance);\n```", "```cs\npublic class TestComponent {\n  void TestFunction() {\n    int data = 5; // allocated on the stack\n    DoSomething(data);\n  } // integer is deallocated from the stack here\n}\n```", "```cs\npublic class TestComponent : MonoBehaviour {\n  private int _data = 5;\n  void TestFunction() {\n    DoSomething(_data);\n  }\n}\n```", "```cs\npublic class TestData {\n  public int data = 5;\n}\n\npublic class TestComponent {\n  void TestFunction() {\n    TestData dataObj = new TestData(); // allocated on the heap\n    DoSomething(dataObj.data);\n  } // dataObj is not immediately deallocated here, but it will \n    // become a candidate during the next GC sweep\n}\n```", "```cs\npublic class TestComponent {\n  private TestData _testDataObj;\n\n  void TestFunction() {\n    TestData dataObj = new TestData(); // allocated on the heap\n    DoSomething(dataObj.data);\n  }\n\n  void DoSomething (TestData dataObj) {\n    _testDataObj = dataObj; // a new reference created! The referenced \n    // object will now be marked during Mark-and-Sweep\n  }\n}\n```", "```cs\npublic class TestClass {\n  private int[] _intArray = new int[1000]; // Reference type \n                                           // full of Value types\n  void StoreANumber(int num) {\n    _intArray[0] = num; // store a Value within the array\n  }\n}\n```", "```cs\nvoid Start() {\n  int myInt = 5;\n  DoSomething(ref myInt);\n  Debug.Log(String.Format(\"Value = {0}\", myInt));\n}\n\nvoid DoSomething(ref int val) {\n  val = 10;\n}\n```", "```cs\npublic class DamageResult {\n  public Character attacker;\n  public Character defender;\n  public int totalDamageDealt;\n  public DamageType damageType;\n  public int damageBlocked;\n  // etc.\n}\n\npublic void DealDamage(Character _target) {\n  DamageResult result = CombatSystem.Instance.CalculateDamage(this, _target);\n  CreateFloatingDamageText(result);\n}\n```", "```cs\npublic struct DamageResult {\n  // ...\n}\n```", "```cs\npublic struct DataStruct {\n  public int val;\n}\n\npublic class StructHolder {\n  public DataStruct _memberStruct;\n  public void StoreStruct(DataStruct ds) {\n      _memberStruct = ds;\n  }\n}\n```", "```cs\nTestStruct[] dataObj = new TestStruct[1000];\n\nfor(int i = 0; i < 1000; ++i) {\n  dataObj[i].data = i;\n  DoSomething(dataObj[i]);\n}\n```", "```cs\nfor(int i = 0; i < 1000; ++i) {\n  TestStruct dataObj = new TestStruct();\n  dataObj.data = i;\n  DoSomething(dataObj);\n}\n```", "```cs\nvoid TestFunction() {\n  string testString = \"Hello\";\n  DoSomething(testString);\n  Debug.Log(testString);\n}\n\nvoid DoSomething(string localString) {\n  localString = \"World!\";\n}\n```", "```cs\nvoid CreateFloatingDamageText(DamageResult result) {\n  string outputText = result.attacker.GetCharacterName() + \" \n             dealt \" + result.totalDamageDealt.ToString() + \" \" + \n             result.damageType.ToString() + \" damage to \" + \n             result.defender.GetCharacterName() + \" (\" + \n             result.damageBlocked.ToString() + \" blocked)\";\n  // ...\n}\n```", "```cs\nDwarf dealt 15 Slashing damage to Orc (3 blocked)\n```", "```cs\n\"3 blocked)\"\n\" (3 blocked)\"\n\"Orc (3 blocked)\"\n\" damage to Orc (3 blocked)\"\n\"Slashing damage to Orc (3 blocked)\"\n\" Slashing damage to Orc (3 blocked)\"\n\"15 Slashing damage to Orc (3 blocked)\"\n\" dealt 15 Slashing damage to Orc (3 blocked)\"\n\"Dwarf dealt 15 Slashing damage to Orc (3 blocked)\"\n```", "```cs\nusing System.Text;\n// ...\nStringBuilder sb = new StringBuilder(100);\nsb.Append(result.attacker.GetCharacterName());\nsb.Append(\" dealt \" );\nsb.Append(result.totalDamageDealt.ToString());\n// etc.\nstring result = sb.ToString();\n```", "```cs\nint i = 128;\nobject obj = i;\n```", "```cs\nint i = 128;\nobject obj = i;\nobj = 256;\ni = (int)obj; // i = 256\n```", "```cs\nint i = 128;\nobject obj = i;\nobj = 512f;\nfloat f = (float)obj; // f = 512f\n```", "```cs\nint i = 128;\nobject obj = i;\nobj = false;\nbool b = (bool)obj; // b = false\n```", "```cs\nint i = 128;\nobject obj = i;\nobj = 512f;\ni = (int)obj; // InvalidCastException thrown here since most recent conversion was to a float\n```", "```cs\npublic struct MyStruct {\n    int myInt;\n    float myFloat;\n    bool myBool;\n    string myString;\n}\n\nMyStruct[] arrayOfStructs = new MyStruct[1000];\n```", "```cs\nint[] myInts = new int[1000];\nfloat[] myFloats = new float[1000];\nbool[] myBools = new bool[1000];\nstring[] myStrings = new string[1000];\n```", "```cs\nGetComponents<T>(); // (T[])\nMesh.vertices; // (Vector3[])\nCamera.allCameras; // (Camera[])\n```", "```cs\nSystem.Func<int,int> anon = (x) => { return x; };\n\nint result = anon(5); // result = 5\n```", "```cs\nint i = 1024;\nSystem.Func<int,int> anon = (x) => { return x + i; };\nint result = anon(5);\n```", "```cs\npublic interface IPoolableObject{\n  void New();\n  void Respawn();\n}\n```", "```cs\nusing System.Collections.Generic;\n\npublic class ObjectPool<T> where T : IPoolableObject, new() {\n  private Stack<T> _pool;\n  private int _currentIndex = 0;\n\n  public ObjectPool(int initialCapacity) {\n    _pool = new Stack<T>(initialCapacity);\n    for(int i = 0; i < initialCapacity; ++i) {\n      Spawn (); // instantiate a pool of N objects\n    }\n    Reset ();\n  }\n\n  public int Count {\n    get { return _pool.Count; }\n  }\n\n  public void Reset() {\n    _currentIndex = 0;\n  }\n\n  public T Spawn() {\n    if (_currentIndex < Count) {\n      T obj = _pool.Peek ();\n      _currentIndex++;\n      IPoolableObject po = obj as IPoolableObject;\n      po.Respawn();\n      return obj;\n    } else {\n      T obj = new T();\n      _pool.Push(obj);\n      _currentIndex++;\n      IPoolableObject po = obj as IPoolableObject;\n      po.New();\n      return obj;\n    }\n  }\n}\n```", "```cs\npublic class EnemyObject : IPoolableObject {\n  public void New() {\n    // very first initialization here\n  }\n  public void Respawn() {\n    // reset data which allows the object to be recycled here\n  }\n}\n```", "```cs\nprivate ObjectPool<EnemyObject> _objectPool = new ObjectPool<EnemyObject>(100);\n```", "```cs\npublic class PoolableVector3 : IPoolableObject {\n  public Vector3 vector = new Vector3();\n  public void New() {\n    Reset();\n  }\n  public void Respawn() {\n    Reset();\n  }\n  public void Reset() {\n    vector.x = vector.y = vector.z = 0f;\n  }\n}\n```", "```cs\npublic interface IPoolableComponent {\n  void Spawned();\n  void Despawned();\n}\n```", "```cs\npublic class ResetPooledRigidbodyComponent : MonoBehaviour, IPoolableComponent {\n  [SerializeField] Rigidbody _body;\n  public void Spawned() {  }\n  public void Despawned() {\n    if (_body == null) {\n      _body = GetComponent<Rigidbody>();\n      if (_body == null) {\n        // no Rigidbody!\n        return;\n      }\n    }\n    _body.velocity = Vector3.zero;\n    _body.angularVelocity = Vector3.zero;\n  }\n}\n```", "```cs\npublic class PoolableTestMessageListener : MonoBehaviour, IPoolableComponent {\n  public void Spawned() {\n    MessagingSystem.Instance.AttachListener(typeof(MyCustomMessage), \n                                            this.HandleMyCustomMessage);\n  }\n\n  bool HandleMyCustomMessage(BaseMessage msg) {\n    MyCustomMessage castMsg = msg as MyCustomMessage;\n    Debug.Log (string.Format(\"Got the message! {0}, {1}\", \n                             castMsg._intValue, \n                             castMsg._floatValue));\n    return true;\n  }\n\n  public void Despawned() {\n    if (MessagingSystem.IsAlive) {\n      MessagingSystem.Instance.DetachListener(typeof(MyCustomMessage), \n                                              this.HandleMyCustomMessage);\n    }\n  }\n}\n```", "```cs\npublic static class PrefabPoolingSystem {}\n```", "```cs\npublic static class PrefabPoolingSystem {\n  static Dictionary<GameObject,PrefabPool> _prefabToPoolMap = new Dictionary<GameObject,PrefabPool>();\n  static Dictionary<GameObject,PrefabPool> _goToPoolMap = new Dictionary<GameObject,PrefabPool>();\n}\n```", "```cs\npublic static GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation) {\n  if (!_prefabToPoolMap.ContainsKey (prefab)) {\n    _prefabToPoolMap.Add (prefab, new PrefabPool());\n  }\n  PrefabPool pool = _prefabToPoolMap[prefab];\n  GameObject go = pool.Spawn(prefab, position, rotation);\n  _goToPoolMap.Add (go, pool);\n  return go;\n}\n```", "```cs\npublic static GameObject Spawn(GameObject prefab) {\n  return Spawn (prefab, Vector3.zero, Quaternion.identity);\n}\n```", "```cs\npublic static bool Despawn(GameObject obj) {\n  if (!_goToPoolMap.ContainsKey(obj)) {\n    Debug.LogError (string.Format (\"Object {0} not managed by pool system!\", obj.name));\n    return false;\n  }\n\n  PrefabPool pool = _goToPoolMap[obj];\n  if (pool.Despawn (obj)) {\n    _goToPoolMap.Remove (obj);\n    return true;\n  }\n  return false;\n}\n```", "```cs\npublic struct PoolablePrefabData {\n  public GameObject go;\n  public IPoolableComponent[] poolableComponents;\n}\n```", "```cs\npublic class PrefabPool {\n  Dictionary<GameObject,PoolablePrefabData> _activeList = new Dictionary<GameObject,PoolablePrefabData>();\n  Queue<PoolablePrefabData> _inactiveList = new Queue<PoolablePrefabData>();\n}\n```", "```cs\npublic GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation) {    \n  PoolablePrefabData data;\n\n  if (_inactiveList.Count > 0) {\n    data = _inactiveList.Dequeue();\n  } else {\n    // instantiate a new object\n    GameObject newGO = GameObject.Instantiate(prefab, position, rotation) as GameObject;\n    data = new PoolablePrefabData();\n    data.go = newGO;\n    data.poolableComponents = newGO.GetComponents<IPoolableComponent>();\n  }\n\n  data.go.SetActive (true);\n  data.go.transform.position = position;\n  data.go.transform.rotation = rotation;\n\n  for(int i = 0; i < data.poolableComponents.Length; ++i) {\n    data.poolableComponents[i].Spawned ();\n  }\n  _activeList.Add (data.go, data);\n\n  return data.go;\n}\n```", "```cs\npublic static void Prespawn(GameObject prefab, int numToSpawn) {\n  List<GameObject> spawnedObjects = new List<GameObject>();\n\n  for(int i = 0; i < numToSpawn; i++) {\n    spawnedObjects.Add (Spawn (prefab));\n  }\n\n  for(int i = 0; i < numToSpawn; i++) {\n    Despawn(spawnedObjects[i]);\n  }\n\n  spawnedObjects.Clear ();\n}\n```", "```cs\npublic class OrcPreSpawner : MonoBehaviour\n  [SerializeField] GameObject _orcPrefab;\n  [SerializeField] int _numToSpawn = 20;\n\n  void Start() {\n    PrefabPoolingSystem.Prespawn(_orcPrefab, _numToSpawn);\n  }\n}\n```", "```cs\npublic bool Despawn(GameObject objToDespawn) {\n  if (!_activeList.ContainsKey(objToDespawn)) {\n    Debug.LogError (\"This Object is not managed by this object pool!\");\n    return false;\n  }\n\n  PoolablePrefabData data = _activeList[objToDespawn];\n\n  for(int i = 0; i < data.poolableComponents.Length; ++i) {\n    data.poolableComponents[i].Despawned ();\n  }\n\n  data.go.SetActive (false);\n  _activeList.Remove (objToDespawn);\n  _inactiveList.Enqueue(data);\n  return true;\n}\n```", "```cs\npublic class PrefabPoolingTestInput : MonoBehaviour {\n  [SerializeField] GameObject _orcPrefab;\n  [SerializeField] GameObject _trollPrefab;\n  [SerializeField] GameObject _ogrePrefab;\n  [SerializeField] GameObject _dragonPrefab;\n\n  List<GameObject> _orcs = new List<GameObject>();\n  List<GameObject> _trolls = new List<GameObject>();\n  List<GameObject> _ogres = new List<GameObject>();\n  List<GameObject> _dragons = new List<GameObject>();\n\n   void Start() {\n     PrefabPoolingSystem.Prespawn(_orcPrefab, 11);\n     PrefabPoolingSystem.Prespawn(_trollPrefab, 8);\n     PrefabPoolingSystem.Prespawn(_ogrePrefab, 5);\n     PrefabPoolingSystem.Prespawn(_dragonPrefab, 1);\n   }\n\n  void Update () {\n    if (Input.GetKeyDown(KeyCode.Alpha1)) {SpawnObject(_orcPrefab, _orcs);}\n    if (Input.GetKeyDown(KeyCode.Alpha2)) {SpawnObject(_trollPrefab, _trolls);}\n    if (Input.GetKeyDown(KeyCode.Alpha3)) {SpawnObject(_ogrePrefab, _ogres);}\n    if (Input.GetKeyDown(KeyCode.Alpha4)) {SpawnObject(_dragonPrefab, _dragons);}\n    if (Input.GetKeyDown(KeyCode.Q)) { DespawnRandomObject(_orcs); }\n    if (Input.GetKeyDown(KeyCode.W)) { DespawnRandomObject(_trolls); }\n    if (Input.GetKeyDown(KeyCode.E)) { DespawnRandomObject(_ogres); }\n    if (Input.GetKeyDown(KeyCode.R)) { DespawnRandomObject(_dragons); }\n  }\n\n  void SpawnObject(GameObject prefab, List<GameObject> list) {\n    GameObject obj = PrefabPoolingSystem.Spawn (prefab, \n                                                5.0f * Random.insideUnitSphere, \n                                                Quaternion.identity);\n    list.Add (obj);\n  }\n\n  void DespawnRandomObject(List<GameObject> list) {\n    if (list.Count == 0) {\n       // Nothing to despawn\n       return;\n    }\n\n    int i = Random.Range (0, list.Count);\n    PrefabPoolingSystem.Despawn(list[i]);\n    list.RemoveAt(i);\n  }\n}\n```", "```cs\npublic static void Reset() {\n  _prefabToPoolMap.Clear ();\n  _goToPoolMap.Clear ();\n}\n```"]