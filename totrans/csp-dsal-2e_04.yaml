- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variants of Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about arrays and their types. Of course,
    an array is not the only way of storing data. Another popular and even more powerful
    group of data structures contains various variants of **lists**. In this chapter,
    you will see such data structures in action, together with illustrations, explanations,
    and descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: First, you will see a **simple list** as an array list and a generic list, in
    which you can easily add and remove elements according to your needs. Then, you
    will get to know **sorted lists**, which keep an order of elements. Next, you
    will learn about four variants of the **linked list**, namely a singly linked
    list, a doubly linked list, a circular singly linked list, and a circular doubly
    linked list. Finally, you will familiarize yourself with three list-related interfaces
    that you can use while developing applications. Does this sound a bit complicated?
    If so, don’t worry. You will be guided throughout.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List-related interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are really useful data structures and they are applied in many algorithms.
    However, in some cases, their application could be complicated due to their nature,
    which does not allow you to increase or decrease the length of the already-created
    array. What should you do if you do not know the total number of elements to store
    in the collection? Do you need to create a very big array and just not use unnecessary
    elements? Such a solution does not sound good, does it? A much better approach
    is to use a data structure that makes it possible to dynamically increase and
    decrease the size of the collection if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a simple list
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize a simple list and distinguish it from an array,
    close your eyes for a moment and try to think back to when you were just a few
    years old and Christmas was approaching. You and your family were preparing a
    chain to hang on the Christmas tree. You took another piece of paper, passed it
    through the last piece of the chain, and glued the new piece of the chain together.
    In this way, your chain grew by another element, and you could add more and more
    elements to the chain, basically endlessly. Well, maybe the limitation was the
    amount of paper and glue or your tiredness. A list works somewhat similarly, where
    you can easily add new elements. You can also remove them, just like you can remove
    a piece of chain and then glue it back together and you can still hang it on your
    beautiful Christmas tree!
  prefs: []
  type: TYPE_NORMAL
- en: Array lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first data structure that allows you to `ArrayList` class from the `System.Collections`
    namespace. You can use this class to store big collections of data, to which you
    can easily add new elements when necessary. Of course, you can also remove them,
    count items, and find an index of a particular value stored within the array list.
    How can you do this? Let’s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'ArrayList arrayList = Add, AddRange, and Insert methods to add new elements
    to the array list. The difference between them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add` adds a new item at the end of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddRange` adds a collection of elements at the end of the array list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Insert` places an element in a specified location within the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the preceding code is executed, the array list contains the following
    elements: `5`, `6`, `-7`, `8`, `"Marcin"`, `7.8`, and `"Kate"`. Please keep in
    mind that all the items stored within the array list are of the `object` type.
    Thus, you can place various types of data in the same collection at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need to specify a type?
  prefs: []
  type: TYPE_NORMAL
- en: Using `object` instead of a particular type is not always a good idea. So, if
    you want to specify a type of each element stored within the list, you can use
    the generic `List` class, which will be described just after `ArrayList`. I encourage
    you to use a strongly typed version of a collection whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that you can easily access a particular element within
    the array list using an index, as shown in the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: foreach (object element in arrayList)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(element);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: int count = arrayList.Count;
  prefs: []
  type: TYPE_NORMAL
- en: 'int capacity = arrayList.Count) returns the number of elements stored currently
    in the array list, while the other property (Capacity) indicates how many elements
    can be stored within it. If you check the value of the Capacity property after
    adding new elements to the array list, you will see that this value is automatically
    increased to prepare a place for new items. This is shown in the following figure,
    which presents the difference between Count (marked as A) and Capacity (B):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The difference between Count and Capacity](img/B18069_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The difference between Count and Capacity
  prefs: []
  type: TYPE_NORMAL
- en: 'The next common and important task is checking whether the array list contains
    an element with a particular value. You can perform this operation by calling
    the `Contains` method, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'int minusIndex = arrayList.IndexOf method returns an index of the first occurrence
    of the element in the array list, while LastIndexOf returns an index of the last
    occurrence. If a value is not found, -1 is returned by the methods. Thus, you
    can use IndexOf to check whether the array list contains a given element. If the
    result is smaller than zero, this means that the element is not available. On
    the other hand, if the result is greater than or equal to zero, it indicates that
    the item is found, as presented in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: arrayList.Remove(5);
  prefs: []
  type: TYPE_NORMAL
- en: arrayList.RemoveAt(1);
  prefs: []
  type: TYPE_NORMAL
- en: arrayList.RemoveRange(1, 2);
  prefs: []
  type: TYPE_NORMAL
- en: arrayList.Clear();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: List<int> list = [6, 90, -20, 0, 4, 1, 8, -20, 41];
  prefs: []
  type: TYPE_NORMAL
- en: int min = list.Min();
  prefs: []
  type: TYPE_NORMAL
- en: int max = list.Max();
  prefs: []
  type: TYPE_NORMAL
- en: int sum = list.Sum();
  prefs: []
  type: TYPE_NORMAL
- en: double avg = list.min is equal to -20, max is equal to 90, sum is equal to 110,
    and avg is near 12.22.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s check out some conditions on the list elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: int existingElement = list.ElementAtOrDefault(5);
  prefs: []
  type: TYPE_NORMAL
- en: int nonExistingElement = list.ElementAtOrDefault method to get a value of the
    element with an index equal to 5 and 100. In the first case, 1 is returned and
    stored as a value of the existingElement variable. When you try to get an element
    with the index equal to 100, a default value for int is used instead and returned,
    namely 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next extension method is named `Distinct` and can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: List<int> ordered = list.-20, -20, 0, 1, 4, 6, 8, 41, and 90.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting group of methods consists of `Skip` and `Take`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: int page = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int size = 10;
  prefs: []
  type: TYPE_NORMAL
- en: List<int> items = list
  prefs: []
  type: TYPE_NORMAL
- en: .Skip((page - 1) * size)
  prefs: []
  type: TYPE_NORMAL
- en: .Take(size)
  prefs: []
  type: TYPE_NORMAL
- en: .ToList();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: List<double> num = [];
  prefs: []
  type: TYPE_NORMAL
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.Write("Enter the number: ");'
  prefs: []
  type: TYPE_NORMAL
- en: string numStr = Console.ReadLine() ?? string.Empty;
  prefs: []
  type: TYPE_NORMAL
- en: if (!double.TryParse(numStr, out double n)) { break; }
  prefs: []
  type: TYPE_NORMAL
- en: num.Add(n);
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"Average value: {num.Average()}");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: while (true);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the number: 10.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Average value: 10.5 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the number: 15.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Average value: 9.375'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'public record Name, Age, and Country, which stores a country code. In the main
    part of the code, you create a new instance of the List class and add the data
    of a few people with different names, ages, and countries, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line, you sort the list by names of people in ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This line can be simplified using the collection expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: foreach (Person p in r)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string line = $"{p.Name} ({p.Age}) from {p.Country}.";
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(line);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Marcin (35) from PL.
  prefs: []
  type: TYPE_NORMAL
- en: Mark (31) from PL.
  prefs: []
  type: TYPE_NORMAL
- en: Sabine (25) from DE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: List<string> names = people
  prefs: []
  type: TYPE_NORMAL
- en: .Where(p => p.Age <= 30)
  prefs: []
  type: TYPE_NORMAL
- en: .OrderBy(p => p.Name)
  prefs: []
  type: TYPE_NORMAL
- en: .Select(p => p.Name)
  prefs: []
  type: TYPE_NORMAL
- en: .Select clause) of all people whose age is lower than or equal to 30 years (the
    Where clause), ordered by names (the OrderBy clause). The query is then executed
    and the results are returned as a list (ToList).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same task can be accomplished using the `ToList` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: public record Person(
  prefs: []
  type: TYPE_NORMAL
- en: string Name,
  prefs: []
  type: TYPE_NORMAL
- en: string Street,
  prefs: []
  type: TYPE_NORMAL
- en: string PostalCode,
  prefs: []
  type: TYPE_NORMAL
- en: string City,
  prefs: []
  type: TYPE_NORMAL
- en: string Country);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: SortedList<string, Person> people = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Marcin Jamro", new("Marcin Jamro",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Polish Street 1/23", "35-001", "Rzeszow", "PL") },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Martyna Kowalska", new("Martyna Kowalska",'
  prefs: []
  type: TYPE_NORMAL
- en: '"World Street 5", "00-123", "Warsaw", "PL") }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: people.Add("Mark Smith", new("Mark Smith",
  prefs: []
  type: TYPE_NORMAL
- en: '"German Street 6", "10000", "Berlin", "DE"));'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: foreach ((string k, Person p) in people)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{k}: {p.Street}, {p.PostalCode}'
  prefs: []
  type: TYPE_NORMAL
- en: '{p.City}, {p.Country}.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Marcin Jamro: Polish Street 1/23, 35-001 Rzeszow, PL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark Smith: German Street 6, 10000 Berlin, DE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Martyna Kowalska: World Street 5, 00-123 Warsaw, PL.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'public record Content property. Then, you create a few instances of the Page
    class, representing six pages of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the instances have been created, you can construct the doubly linked list
    using a few addition-related methods, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, a new empty list is created. Then, the given operations
    are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the second page at the end (`[2]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the fourth page at the end (`[``2, 4]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the sixth page at the end (`[2,` `4, 6]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the first page at the beginning of the list (`[1, 2,` `4, 6]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the third page before the fourth page (`[1, 2, 3,` `4, 6]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the fifth page after the fourth page (`[1, 2, 3, 4,` `5, 6]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next part of the code is responsible for presenting a page in the console,
    as well as for navigating between pages after pressing the appropriate keys. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, the value of the `c` variable is set to the first node in
    the doubly linked list. Generally speaking, the `c` variable represents the page
    that is currently presented in the console. Then, the initial value for the page
    number is set to `1` (the `number` variable). However, the most interesting and
    complicated part of the code is shown in the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, the current content of the console is cleared and the string
    for presenting the page number is properly formatted to display. Before and after
    it, the `-` characters are added. Moreover, leading spaces are inserted (using
    the `PadLeft` method) to prepare the string that is centered horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the content of the page is divided into lines of no more than `90` characters
    and written in the console. To divide a string, the `Length` property and the
    `content[i..]`. Similarly, additional information is presented in the console.
    Then, `PREV` and `NEXT` captions are shown, if a previous or a next page is available.
  prefs: []
  type: TYPE_NORMAL
- en: Can you improve this example?
  prefs: []
  type: TYPE_NORMAL
- en: This example divides the text into a few lines while not taking spaces into
    account. I encourage you to modify the code so that it supports more user-friendly
    text wrapping. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the code, the program waits until the user presses
    any key and does not present it in the console (by passing `true` as a parameter
    of `ReadKey`). When the user presses *N*, the `c` variable is set to the next
    node, using the `Next` property. Of course, the operation should not be performed
    when the next page is unavailable. The *P* key is handled similarly, which causes
    the user to be navigated to the previous page. It is worth mentioning that the
    number of the page (the `number` variable) is modified alongside changing the
    value of the `c` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the code of the auxiliary `GetSpaces` method is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This prepares and returns the `string` variable with the specified number of
    spaces. Of course, there are several ways to perform this task. However, in this
    book, I wanted to show you various approaches, even those that are not so typical.
    The aim is to show you various ways of achieving your goal and making your horizons
    as broad as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you should be ready to continue your adventure regarding lists. In
    the next section, you’ll learn about circular lists and their two subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: Circular singly linked lists
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two sections, you learned about linked lists. As you should
    remember, in a singly linked list, you can navigate between the nodes using the
    `Next` property. However, the `Next` property of the last node is set to `null`.
    Do you know that you can easily expand this approach to create a **circular singly
    linked list**, where **the last node points to the first element, creating a list
    that can be** **iterated endlessly?**
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a circular singly linked list
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a circular singly linked list, think for a moment
    about a screensaver showing photos from a specific folder. After a certain period
    of inactivity, your screen starts showing photos, one after the other. When the
    last photo is displayed, the first one from the catalog is shown automatically.
    Of course, you can’t control the photos yourself, because any interaction with
    the keyboard or mouse turns off the screensaver. A circular singly linked list
    works similarly. Here, only information about the next list element is saved,
    without the possibility of going back. The last element of the list takes you
    to the very beginning. It’s so easy once you can imagine a real-life case, right?
    Now, move your mouse to make the screensaver disappear, and get back to learning
    more about data structures and algorithms!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates a circular singly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Illustration of a circular singly linked list](img/B18069_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Illustration of a circular singly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'After this short introduction to the topic of circular singly linked lists,
    it is time to take a look at the implementation code. As this data structure is
    not available by default while developing in C#, you will learn how to implement
    it on your own, based on a linked list. Let’s start with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation can be created as a generic class that extends `LinkedList`,
    as shown in the preceding code. It is worth mentioning the implementation of the
    `GetEnumerator` method, which uses the `CircularEnumerator` class. By creating
    it, you will be able to endlessly iterate through all the elements of a circular
    linked list using a `foreach` loop. The code of `CircularEnumerator` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `CircularEnumerator` class implements the `IEnumerator` interface. This
    class declares the `private` field, which represents the current node (`_current`)
    in the iteration over the list. It also contains two properties, namely `Current`
    and `IEnumerator.Current`, which are required by the `IEnumerator` interface.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important parts of the code is the `MoveNext` method. This checks
    whether the current element is equal to `null`. If so, it tries to get the first
    element from the list and starts iterating from it. If it does not exist, the
    method returns `false` since there are no items in the list. If the current element
    is not equal to `null`, it changes the current element to the next one or the
    first node in the list, if the next node is unavailable. In the `Reset` method,
    you just set a value of the `_current` field to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you create the `Next` extension method that navigates to the first
    element while trying to get the next element from the last item in the list. To
    simplify the implementation, such a feature will be available as a method, instead
    of the `Next` property. The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The method checks whether the node exists and whether the list is available.
    In such a case, it returns a value of the `Next` property of the node (if such
    a value is not equal to `null`) or returns a reference to the first element in
    the list using the `First` property.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all! You’ve just completed the C#-based implementation of a circular
    singly linked list that you can use in various applications. But how? Let’s take
    a look at the following example, which uses this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Example – spin the wheel
  prefs: []
  type: TYPE_NORMAL
- en: 'This example simulates a game in which a user spins a wheel at a random speed.
    The wheel rotates slower and slower until it stops. Then, the user can spin it
    again, from the previous stop position, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Illustration of the spin the wheel example](img/B18069_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Illustration of the spin the wheel example
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed to the first part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: bool isStopped = true;
  prefs: []
  type: TYPE_NORMAL
- en: Random random = new();
  prefs: []
  type: TYPE_NORMAL
- en: DateTime targetTime = DateTime.Now;
  prefs: []
  type: TYPE_NORMAL
- en: int ms = 0;
  prefs: []
  type: TYPE_NORMAL
- en: foreach (string category in categories)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (isStopped)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Press [Enter] to start.");
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey key = Console.ReadKey().Key;
  prefs: []
  type: TYPE_NORMAL
- en: if (key == ConsoleKey.Enter)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ms = random.Next(1000, 5000);
  prefs: []
  type: TYPE_NORMAL
- en: targetTime = DateTime.Now.AddMilliseconds(ms);
  prefs: []
  type: TYPE_NORMAL
- en: isStopped = false;
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(category);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else { return; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int remaining = (int)(targetTime
  prefs: []
  type: TYPE_NORMAL
- en: '- DateTime.Now).TotalMilliseconds;'
  prefs: []
  type: TYPE_NORMAL
- en: int waiting = Math.Max(100, (ms - remaining) / 5);
  prefs: []
  type: TYPE_NORMAL
- en: await Task.Delay(waiting);
  prefs: []
  type: TYPE_NORMAL
- en: if (DateTime.Now >= targetTime)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.ForegroundColor = ConsoleColor.Red;
  prefs: []
  type: TYPE_NORMAL
- en: isStopped = true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(category);
  prefs: []
  type: TYPE_NORMAL
- en: Console.ResetColor();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: public static class CircularLinkedListExtensions
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static LinkedListNode<T>? Next<T>(
  prefs: []
  type: TYPE_NORMAL
- en: this LinkedListNode<T> n)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return n != null && n.List != null
  prefs: []
  type: TYPE_NORMAL
- en: '? n.Next ?? n.List.First'
  prefs: []
  type: TYPE_NORMAL
- en: ': null;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static LinkedListNode<T>? Prev<T>(
  prefs: []
  type: TYPE_NORMAL
- en: this LinkedListNode<T> n)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return n != null && n.List != null
  prefs: []
  type: TYPE_NORMAL
- en: '? n.Previous ?? n.List.Last'
  prefs: []
  type: TYPE_NORMAL
- en: ': null;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: string[][] arts = GetArts();
  prefs: []
  type: TYPE_NORMAL
- en: CircularLinkedList<string[]> images = new();
  prefs: []
  type: TYPE_NORMAL
- en: foreach (string[] art in arts) { images.AddLast(art); }
  prefs: []
  type: TYPE_NORMAL
- en: LinkedListNode<string[]> node = images.First!;
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey key = ConsoleKey.Spacebar;
  prefs: []
  type: TYPE_NORMAL
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (key == ConsoleKey.RightArrow)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: node = node.Next()!;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (key == ConsoleKey.LeftArrow)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: node = node.Prev()!;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.Clear();
  prefs: []
  type: TYPE_NORMAL
- en: foreach (string line in node.Value)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(line);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: while ((key = Console.ReadKey().Key) != ConsoleKey.Escape);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: string[][] GetArts() => [
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '"  +-----+  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"o-| o o |-o",'
  prefs: []
  type: TYPE_NORMAL
- en: '"|  -  |  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"  +-----+  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"    | |    "'
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '"o +-----+  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '" \\| o o |\\ ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"  |  -  | o",'
  prefs: []
  type: TYPE_NORMAL
- en: '"  +-----+  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"    / |    "'
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '"+-----+ o",'
  prefs: []
  type: TYPE_NORMAL
- en: '" /| o o |/ ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"o |  -  |  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"  +-----+  ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"    | \\    "'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '];'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
