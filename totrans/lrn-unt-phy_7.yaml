- en: Chapter 7. Optimizing Application's Performance Using Physics in Unity3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to optimize your game or application during
    development with Unity3D. There are several factors that need to be kept in mind
    to run the app or game smoothly. We will handle optimization using Physics best
    practices. Although, this chapter will cover Physics tricks primary to handle
    the performance optimization, you will learn other Unity3D tricks for performance
    handling as bonus topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing an optimized application and game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the static collider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh Colliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complex collider shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigidbodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cloth component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimized graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low timestep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros of performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an optimized application and game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance is a critical factor for games and applications, and for a fast-paced
    action game, it becomes the key point. For those features where fast Physics combined
    with fully animated characters and a 3D world are required, performance optimization
    is the most important factor. Any game or application needs 60 frames per seconds
    of performance, and so we will need to optimize our game for target devices to
    achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Checking performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unity Profiler** is the first thing that we should use to check the performance
    of a game or application. Profiler is a great tool that comes with Unity Pro,
    using which we determine where any frame rate issues are coming from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiler uses a graph to show the CPU usage while we play the game. Profiler
    is divided in categorizes such as **Rendering**, **Scripts**, **Physics**, **Garbage**
    **Collector**, **VSync**, and others. This is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking performance](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's see how we handle optimization during the Physics implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Moving static colliders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make less expensive performance, we should avoid moving static colliders.
    You learned in previous chapters that a static collider is a game object with
    a collider component on it; however, it does not have a Rigidbody component. Moving
    static colliders is one of the top causes of performance issues in Unity games
    and it is expensive. If we need to create them with codes, we should add the collider
    and Physic Materials *after* its positioning.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh Colliders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mesh Colliders** are slow compared to the primitive Box/Sphere Collider.
    A sphere has many more vertices than a cube but the uniform distance from the
    center makes the calculation much easier in comparison to the many individual
    triangles. Mesh colliders have a much higher performance overhead than primitive
    colliders.'
  prefs: []
  type: TYPE_NORMAL
- en: The complex collider shape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get better performance for more complex shapes, we should combine primitive
    colliders. Let''s have a look at an example. If we have a parent object with a
    Box Collider and Rigidbody component, we should add child objects with just a
    Box Collider. The collision for an entire object will have one multipart object.
    Rather than having several objects linked together, we can add more child objects
    with Rigidbodies and colliders and use joints to connect them to the parent object.
    As shown in the following screenshot, we used a Capsule Collider for the complex
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The complex collider shape](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rigidbodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Less use of Rigidbodies and materials saves performance. Again, the use of interpolation
    and extrapolation on Rigidbodies is discouraged all together. The total amount
    of Physics calculation depends on the number of nonsleeping Rigidbodies and colliders
    in the scene and the complexity of the colliders. We should handle performance
    by reducing calculation as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot use multiple basic joints on one game object as it is not supported,
    but we can use multiple configurable joints, which helps a lot in performance
    optimization. Rather than having a network of joint objects, we should use configurable
    joints wherever possible to avoid unnecessary memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: The Cloth component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of multiple Cloth components in one game is very expensive so should
    minimize the use of multiple Cloth components.
  prefs: []
  type: TYPE_NORMAL
- en: Lower timestep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lower frame rate gives breathing room and helps in memory optimization. I
    personally find a 0.03 fixed timestep with a maximum of about 0.05 to be good
    for better performance. We can reduce the time spent on Physics updates by adjusting
    the fixed timestep setting. Increasing the timestep will reduce the CPU overhead
    but sometimes, the accuracy of Physics gets affected.
  prefs: []
  type: TYPE_NORMAL
- en: Precalculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Precalculation during development can be very important to achieve high performance
    and make certain effects possible. Taking the approach of calculating as much
    as possible at the start of execution can have a great impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from Physics-based performance optimizations, there are other factors
    too that we should use to optimize our game or app. Let's have a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance optimization depends upon how fast we can render by GPU, which is
    mostly limited by the number of pixels rendered and by the memory bandwidth. The
    CPU performance is also limited by the amount of draw calls processed. We can
    use GPU Profiler to find out how much time and how many draw calls are in the
    scene. To save rendering time, we should remove as many draw calls as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, by clicking on **Stats**, we can see
    the **Statistics** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing graphics](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To improve CPU performance, we should take into account the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: For high performance, don't use more than a few hundred draw calls per frame
    while draw call counts vary for older devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining nearby objects into single meshes, we can reduce draw calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using automatically Unity's draw call batching, we can reduce draw calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fewer different materials enables better batching of meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using a textures atlas where possible, we can reduce draw calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To improve GPU performance, we should note the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: By reducing the texture quality in the **Quality** settings, we can make the
    game run faster; we limit memory bandwidth by applying this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reduce shader complexity using mobile GPUs and avoid alpha-testing shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use texture compression or 16-bit textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the texture size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script call optimization for an iOS build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a big impact on project completion, from the initial phase of project,
    we should use slow but safe option of **Script Call Optimization**. Using this
    unhandled exception will crash the Unity build but if handled, we can get a higher
    performance at the end of the project. To apply this, navigate to the **Player**
    setting and select **iOS** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Script call optimization for an iOS build](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are some simple rules for handling performance such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Pixel lights are too expensive, so we should avoid them to get high performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your draw call count low because graphics rendering is CPU expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should mark the objects that don't move as static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For moving objects, try to keep the vertex count below 300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should avoid instantiating or destroying objects in runtime as the memory
    is slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid alpha because it rejects pixels on iOS devices and it is slow; use alpha
    blend instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros of performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a successful game or application, the most important and required key point
    is good performance. Smooth game play attracts players; similarly, a better and
    fast user experience allows to capture a large audience.
  prefs: []
  type: TYPE_NORMAL
- en: A great game or application but with a slow speed or that crashes often never
    succeeds. Thus, the most important advantage of performance optimization is that
    using it, we provide fast and smooth gameplay and better user experience, and
    avoid lags or crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the different ways to handle performance. You learned
    about different Physics components and the ways they can be used for better performance.
    You learned how to use a single collider for a complex object, that we should
    not use multiple cloth components in one game, and that we can optimize graphics
    by reducing the number of draw calls.
  prefs: []
  type: TYPE_NORMAL
- en: This book is all about learning Physics with Unity3D. We saw that Unity has
    a powerful Physics engine. You learned about the different Physics components
    provided by Unity3D to make a developer's life easier. You learned how to use
    Physics when creating animations. Now, you are set to learn about networking and
    multiplayer game and application using Unity3D.
  prefs: []
  type: TYPE_NORMAL
