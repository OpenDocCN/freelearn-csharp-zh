["```cs\npublic class Node<T>\n{\n    public int Index { get; set; }\n    public required T Data { get; set; }\n    public List<Node<T>> Neighbors { get; set; } = [];\n    public List<int> Weights { get; set; } = [];\n    public override string ToString() => $\"Index: {Index}.\n        Data: {Data}. Neighbors: {Neighbors.Count}.\";\n}\n```", "```cs\npublic class Edge<T>\n{\n    public required Node<T> From { get; set; }\n    public required Node<T> To { get; set; }\n    public int Weight { get; set; }\n    public override string ToString() => $\"{From.Data}\n        -> {To.Data}. Weight: {Weight}.\";\n}\n```", "```cs\npublic class Graph<T>\n{\n    public required bool IsDirected { get; init; }\n    public required bool IsWeighted { get; init; }\n    public List<Node<T>> Nodes { get; set; } = [];\n}\n```", "```cs\npublic Edge<T>? this[int from, int to]\n{\n    get\n    {\n        Node<T> nodeFrom = Nodes[from];\n        Node<T> nodeTo = Nodes[to];\n        int i = nodeFrom.Neighbors.IndexOf(nodeTo);\n        if (i < 0) { return null; }\n        Edge<T> edge = new()\n        {\n            From = nodeFrom,\n            To = nodeTo,\n            Weight = i < nodeFrom.Weights.Count\n                ? nodeFrom.Weights[i] : 0\n        };\n        return edge;\n    }\n}\n```", "```cs\npublic Node<T> AddNode(T value)\n{\n    Node<T> node = new() { Data = value };\n    Nodes.Add(node);\n    UpdateIndices();\n    return node;\n}\n```", "```cs\npublic void RemoveNode(Node<T> nodeToRemove)\n{\n    Nodes.Remove(nodeToRemove);\n    UpdateIndices();\n    Nodes.ForEach(n => RemoveEdge(n, nodeToRemove));\n}\n```", "```cs\npublic void AddEdge(Node<T> from, Node<T> to, int w = 0)\n{\n    from.Neighbors.Add(to);\n    if (IsWeighted) { from.Weights.Add(w); }\n    if (!IsDirected)\n    {\n        to.Neighbors.Add(from);\n        if (IsWeighted) { to.Weights.Add(w); }\n    }\n}\n```", "```cs\npublic void RemoveEdge(Node<T> from, Node<T> to)\n{\n    int index = from.Neighbors.FindIndex(n => n == to);\n    if (index < 0) { return; }\n    from.Neighbors.RemoveAt(index);\n    if (IsWeighted) { from.Weights.RemoveAt(index); }\n    if (!IsDirected)\n    {\n        index = to.Neighbors.FindIndex(n => n == from);\n        if (index < 0) { return; }\n        to.Neighbors.RemoveAt(index);\n        if (IsWeighted) { to.Weights.RemoveAt(index); }\n    }\n}\n```", "```cs\npublic List<Edge<T>> GetEdges()\n{\n    List<Edge<T>> edges = [];\n    foreach (Node<T> from in Nodes)\n    {\n        for (int i = 0; i < from.Neighbors.Count; i++)\n        {\n            int weight = i < from.Weights.Count\n                ? from.Weights[i] : 0;\n            Edge<T> edge = new()\n            {\n                From = from,\n                To = from.Neighbors[i],\n                Weight = weight\n            };\n            edges.Add(edge);\n        }\n    }\n    return edges;\n}\n```", "```cs\nprivate void UpdateIndices()\n{\n    int i = 0;\n    Nodes.ForEach(n => n.Index = i++);\n}\n```", "```cs\nGraph<int> graph = new()\n    { Node<int> type, as follows:\n\n```", "```cs\n\n Finally, you only need to add edges between nodes, as shown in the preceding diagram. The necessary code is as follows:\n\n```", "```cs\n\n That’s all! As you can see, configuring a graph is very easy using the proposed implementation of this data structure. Now, let’s proceed to a slightly more complex scenario with directed and weighted edges.\nExample – directed and weighted edges\nThe following example involves a directed and weighted graph, as follows:\n![Figure 8.13 – Illustration of the directed and weighted edges example](img/B18069_08_13.jpg)\n\nFigure 8.13 – Illustration of the directed and weighted edges example\nThe implementation is similar to the one described previously. However, some modifications are necessary. To start with, different values of the properties are used to indicate that a directed and weighted variant of the edges is being considered:\n\n```", "```cs\n\n The part regarding adding nodes is the same as in the previous example:\n\n```", "```cs\n\n Some changes are easily visible in the lines of code regarding the addition of edges. Here, you specify directed edges and their weights, as follows:\n\n```", "```cs\n\n You’ve just completed the basic implementation of a graph, shown in two examples. So, let’s proceed to another topic, namely traversing a graph.\nTraversal\nOne of the operations that’s commonly performed on a graph is **traversal** – that is, **visiting all of the nodes in some particular order**. Of course, the aforementioned problem can be solved in various ways, such as using **DFS** or **BFS** approaches. It is worth mentioning that the traversal topic is strictly connected with the task of **searching for a given node in** **a graph**.\nDepth-first search\nThe first graph traversal algorithm described in this chapter is named **DFS**. It tries to go as deep as possible. **First, it proceeds to the next levels of the nodes instead of visiting all the neighbors of the current node**. Its steps, in the context of the example graph, are as follows:\n![Figure 8.14 – Illustration of a DFS of a graph](img/B18069_08_14.jpg)\n\nFigure 8.14 – Illustration of a DFS of a graph\nOf course, it can be a bit difficult to understand how the DFS algorithm operates just by looking at the preceding diagram. For this reason, let’s try to analyze its stages.\nIn **Step 1**, there’s the graph with 8 nodes. In **Step 2**, node **1** is marked with a gray background (indicating that the node was already visited), as well as with a bolder border (indicating that it is the node that is currently being visited). Moreover, an important role in the algorithm is performed by the neighbor nodes (shown as circles with dashed borders) of the current one. When you know the roles of particular indicators, it is clear that in **Step 2**, node **1** is visited. It has two neighbors, namely nodes **2** and **3**.\nThen, the first neighbor (node **2**) is taken into account (**Step 3**) and the same operations are performed – that is, the node is visited and its neighbors (nodes **1** and **4**) are analyzed. As node **1** was visited, it is skipped. In **Step 4**, the first suitable neighbor of node **2** is taken into account, namely node **4**. It has two neighbors, namely node **2** (already visited) and **8**. Next, node **8** is visited (**Step 5**) and, according to the same rules, node **5** (**Step 6**). It has four neighbors, namely nodes **4** (already visited), **6**, **7**, and **8** (already visited). Thus, in **Step 7**, node **6** is taken into account. As it has only one neighbor (node **7**), it is visited next (**Step 8**).\nThen, you check the neighbors of node **7**, namely nodes **5** and **8**. Both were already visited, so you return to the node with an unvisited neighbor. In this example, node **1** has one unvisited node, namely node **3**. When it is visited (**Step 9**), all nodes are traversed and no further operations are necessary.\nGiven this example, let’s try to create the implementation in the C# language. To start, the code of the public `DFS` method (in the `Graph` class) is presented as follows:\n\n```", "```cs\n\n The important role is performed by the `isVisited` array. It has the same number of elements as the number of nodes and stores values indicating whether a given node has already been visited. If so, the `true` value is stored. Otherwise, `false` is stored. The list of traversed nodes is represented as a list in the `result` variable. What’s more, another variant of the `DFS` method is called here, passing three parameters:\n\n*   A reference to the `isVisited` array\n*   The first node to analyze\n*   The list for storing results\n\nThe code for the aforementioned variant of the `DFS` method is as follows:\n\n```", "```cs\n\n First, the current node is added to the collection of traversed nodes, and the element in the `isVisited` array is updated. Then, you use the `foreach` loop to iterate through all the neighbors of the current node. For each of them, if they haven’t already been visited, the `DFS` method is called recursively.\nTo finish, let’s take a look at the code that can be placed in the `Program.cs` file. Its main parts are presented in the following code snippet:\n\n```", "```cs\n\n Here, you initialize a directed and weighted graph. It is worth noting that the missing lines of code (indicated by three dots) are the same as in the example where you created a graph with directed and weighted edges.\nTo start traversing the graph, you just need to call the `DFS` method, which returns a list of `Node` instances. Then, you can easily iterate through elements of the list to print some basic information about each node in the console:\n\n```", "```cs\n\n That’s all! As you can see, the algorithm tries to go as deep as possible and then goes back to find the next unvisited neighbor that can be traversed.\nHowever, this algorithm is not the only approach to the problem of graph traversal. We’ll cover another method and its implementation in the next section.\nBreadth-first search\nIn the previous section, you learned about the DFS approach. Now, you will see another solution, namely **BFS**. Its main aim is to **visit all the neighbors of the current node and then proceed to the next level** **of nodes**.\nIf the previous description sounds a bit complicated, take a look at this diagram, which depicts the steps of the BFS algorithm:\n![Figure 8.15 – Illustration of a BFS of a graph](img/B18069_08_15.jpg)\n\nFigure 8.15 – Illustration of a BFS of a graph\nThe algorithm starts by visiting node **1** (**Step 2**). It has two neighbors, namely nodes **2** and **3**, which are visited next (**Step 3** and **Step 4**). As node **1** does not have more neighbors, the neighbors of its first neighbor (node **2**) are considered. As it has only one unvisited neighbor (node **4**), it is visited in the next step. According to the same method, the remaining nodes are visited in this order: **8**, **5**, **6**, **7**.\nIt sounds very simple, doesn’t it? Let’s take a look at the implementation:\n\n```", "```cs\nprivate List<Node<T>> BFS(Node<T> node)\n{\n    bool[] isVisited = new bool[Nodes.Count];\n    isVisited[node.Index] = true;\n    List<Node<T>> result = [];\n    Queue<Node<T>> queue = [];\n    queue.Enqueue(node);\n    while (queue.Count > 0)\n    {\n        Node<T> next = queue.Dequeue();\n        result.Add(next);\n        foreach (Node<T> neighbor in next.Neighbors)\n        {\n            if (!isVisited[neighbor.Index])\n            {\n                isVisited[neighbor.Index] = true;\n                queue.Enqueue(neighbor);\n            }\n        }\n    }\n    return result;\n}\n```", "```cs\nGraph<int> graph = new()\n    { IsDirected = true, IsWeighted = true };\nNode<int> n1 = graph.AddNode(1); (...)\nNode<int> n8 = graph.AddNode(8);\ngraph.AddEdge(n1, n2, 9); (...)\ngraph.AddEdge(n8, n5, 3);\nList<Node<int>> nodes = graph.BFS();\nnodes.ForEach(Console.WriteLine);\n```", "```cs\nIndex: 0\\. Data: 1\\. Neighbors: 2.\nIndex: 1\\. Data: 2\\. Neighbors: 2.\nIndex: 2\\. Data: 3\\. Neighbors: 1.\nIndex: 3\\. Data: 4\\. Neighbors: 2.\nIndex: 7\\. Data: 8\\. Neighbors: 1.\nIndex: 4\\. Data: 5\\. Neighbors: 4.\nIndex: 5\\. Data: 6\\. Neighbors: 1.\nIndex: 6\\. Data: 7\\. Neighbors: 2.\n```", "```cs\npublic List<Edge<T>> MSTKruskal()\n{\n    List<Edge<T>> edges = GetEdges();\n    edges.Sort((a, b) => a.Weight.CompareTo(b.Weight));\n    Queue<Edge<T>> queue = new(edges);\n    Subset<T>[] subsets = new Subset<T>[Nodes.Count];\n    for (int i = 0; i < Nodes.Count; i++)\n    {\n        subsets[i] = new() { Parent = Nodes[i] };\n    }\n    List<Edge<T>> result = [];\n    while (result.Count < Nodes.Count - 1)\n    {\n        Edge<T> edge = queue.Dequeue();\n        Node<T> from = GetRoot(subsets, edge.From);\n        Node<T> to = GetRoot(subsets, edge.To);\n        if (from == to) { continue; }\n        result.Add(edge);\n        Union(subsets, from, to);\n    }\n    return result;\n}\n```", "```cs\nprivate Node<T> GetRoot(Subset<T>[] subsets, Node<T> node)\n{\n    int i = node.Index;\n    ss[i].Parent = ss[i].Parent != node\n        ? GetRoot(ss, ss[i].Parent) : ss[i].Parent;\n    return ss[i].Parent;\n}\n```", "```cs\nprivate void Union(Subset<T>[] ss, Node<T> a, Node<T> b)\n{\n    ss[b.Index].Parent =\n        ss[a.Index].Rank >= ss[b.Index].Rank\n            ? a : ss[b.Index].Parent;\n    ss[a.Index].Parent =\n        ss[a.Index].Rank < ss[b.Index].Rank\n            ? b : ss[a.Index].Parent;\n    if (ss[a.Index].Rank == ss[b.Index].Rank)\n    {\n        ss[a.Index].Rank++;\n    }\n}\n```", "```cs\npublic class Subset<T>\n{\n    public required Node<T> Parent { get; set; }\n    public int Rank { get; set; }\n    public override string ToString() => $\"Rank: {Rank}.\n        Parent: {Parent.Data}. Index: {Parent.Index}.\";\n}\n```", "```cs\nGraph<int> graph = new()\n    { IsDirected = false, IsWeighted = true };\nNode<int> n1 = graph.AddNode(1);\nNode<int> n2 = graph.AddNode(2);\nNode<int> n3 = graph.AddNode(3);\nNode<int> n4 = graph.AddNode(4);\nNode<int> n5 = graph.AddNode(5);\nNode<int> n6 = graph.AddNode(6);\nNode<int> n7 = graph.AddNode(7);\nNode<int> n8 = graph.AddNode(8);\ngraph.AddEdge(n1, n2, 3);\ngraph.AddEdge(n1, n3, 5);\ngraph.AddEdge(n2, n4, 4);\ngraph.AddEdge(n3, n4, 12);\ngraph.AddEdge(n4, n5, 9);\ngraph.AddEdge(n4, n8, 8);\ngraph.AddEdge(n5, n6, 4);\ngraph.AddEdge(n5, n7, 5);\ngraph.AddEdge(n5, n8, 1);\ngraph.AddEdge(n6, n7, 6);\ngraph.AddEdge(n7, n8, 20);\nList<Edge<int>> edges = graph.MSTKruskal();\nedges.ForEach(Console.WriteLine);\n```", "```cs\n8 -> 5\\. Weight: 1.\n1 -> 2\\. Weight: 3.\n2 -> 4\\. Weight: 4.\n5 -> 6\\. Weight: 4.\n1 -> 3\\. Weight: 5.\n7 -> 5\\. Weight: 5.\n8 -> 4\\. Weight: 8.\n```", "```cs\npublic List<Edge<T>> MSTPrim()\n{\n    int[] previous = new int[Nodes.Count];\n    previous[0] = -1;\n    int[] minWeight = new int[Nodes.Count];\n    Array.Fill(minWeight, int.MaxValue);\n    minWeight[0] = 0;\n    bool[] isInMST = new bool[Nodes.Count];\n    Array.Fill(isInMST, false);\n    for (int i = 0; i < Nodes.Count - 1; i++)\n    {\n        int mwi = GetMinWeightIndex(minWeight, isInMST);\n        isInMST[mwi] = true;\n        for (int j = 0; j < Nodes.Count; j++)\n        {\n            Edge<T>? edge = this[mwi, j];\n            int weight = edge != null ? edge.Weight : -1;\n            if (edge != null\n                && !isInMST[j]\n                && weight < minWeight[j])\n            {\n                previous[j] = mwi;\n                minWeight[j] = weight;\n            }\n        }\n    }\n    List<Edge<T>> result = [];\n    for (int i = 1; i < Nodes.Count; i++)\n    {\n        result.Add(this[previous[i], i]!);\n    }\n    return result;\n}\n```", "```cs\nprivate int GetMinWeightIndex(\n    int[] weights, bool[] isInMST)\n{\n    int minValue = int.MaxValue;\n    int minIndex = 0;\n    for (int i = 0; i < Nodes.Count; i++)\n    {\n        if (!isInMST[i] && weights[i] < minValue)\n        {\n            minValue = weights[i];\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}\n```", "```cs\nGraph<int> graph = new()\n    { IsDirected = false, IsWeighted = true };\nNode<int> n1 = graph.AddNode(1); (...)\nNode<int> n8 = graph.AddNode(8);\ngraph.AddEdge(n1, n2, 3); (...)\ngraph.AddEdge(n7, n8, 20);\nList<Edge<int>> edges = graph.MSTPrim();\nedges.ForEach(Console.WriteLine);\n```", "```cs\n1 -> 2\\. Weight: 3.\n1 -> 3\\. Weight: 5.\n2 -> 4\\. Weight: 4.\n8 -> 5\\. Weight: 1.\n5 -> 6\\. Weight: 4.\n5 -> 7\\. Weight: 5.\n4 -> 8\\. Weight: 8.\n```", "```cs\nGraph<string> graph = new()\n    { IsDirected = false, IsWeighted = true };\nNode<string> nodeB1 = graph.AddNode(\"B1\");\nNode<string> nodeB2 = graph.AddNode(\"B2\");\nNode<string> nodeB3 = graph.AddNode(\"B3\");\nNode<string> nodeB4 = graph.AddNode(\"B4\");\nNode<string> nodeB5 = graph.AddNode(\"B5\");\nNode<string> nodeB6 = graph.AddNode(\"B6\");\nNode<string> nodeR1 = graph.AddNode(\"R1\");\nNode<string> nodeR2 = graph.AddNode(\"R2\");\nNode<string> nodeR3 = graph.AddNode(\"R3\");\nNode<string> nodeR4 = graph.AddNode(\"R4\");\nNode<string> nodeR5 = graph.AddNode(\"R5\");\nNode<string> nodeR6 = graph.AddNode(\"R6\");\ngraph.AddEdge(nodeB1, nodeB2, 2);\ngraph.AddEdge(nodeB1, nodeB3, 20);\ngraph.AddEdge(nodeB1, nodeB4, 30);\ngraph.AddEdge(nodeB2, nodeB3, 30);\ngraph.AddEdge(nodeB2, nodeB4, 20);\ngraph.AddEdge(nodeB2, nodeR2, 25);\ngraph.AddEdge(nodeB3, nodeB4, 2);\ngraph.AddEdge(nodeB4, nodeR4, 25);\ngraph.AddEdge(nodeR1, nodeR2, 1);\ngraph.AddEdge(nodeR2, nodeR3, 1);\ngraph.AddEdge(nodeR3, nodeR4, 1);\ngraph.AddEdge(nodeR1, nodeR5, 75);\ngraph.AddEdge(nodeR3, nodeR6, 100);\ngraph.AddEdge(nodeR5, nodeR6, 3);\ngraph.AddEdge(nodeR6, nodeB5, 3);\ngraph.AddEdge(nodeR6, nodeB6, 10);\ngraph.AddEdge(nodeB5, nodeB6, 6);\n```", "```cs\nConsole.WriteLine(\"Minimum Spanning Tree - Kruskal:\");\nList<Edge<string>> kruskal = graph.MSTKruskal();\nkruskal.ForEach(Console.WriteLine);\nConsole.WriteLine(\"Cost: \" + kruskal.Sum(e => e.Weight));\n```", "```cs\nMinimum Spanning Tree - Kruskal:\nR4 -> R3\\. Weight: 1.\nR3 -> R2\\. Weight: 1.\nR2 -> R1\\. Weight: 1.\nB1 -> B2\\. Weight: 2.\nB3 -> B4\\. Weight: 2.\nR6 -> R5\\. Weight: 3.\nR6 -> B5\\. Weight: 3.\nB6 -> B5\\. Weight: 6.\nB1 -> B3\\. Weight: 20.\nR2 -> B2\\. Weight: 25.\nR1 -> R5\\. Weight: 75.\nCost: 139\n```", "```cs\nConsole.WriteLine(\"\\nMinimum Spanning Tree - Prim:\");\nList<Edge<string>> prim = graph.MSTPrim();\nprim.ForEach(Console.WriteLine);\nConsole.WriteLine(\"Cost: \" + prim.Sum(e => e.Weight));\n```", "```cs\nMinimum Spanning Tree - Prim:\nB1 -> B2\\. Weight: 2.\nB1 -> B3\\. Weight: 20.\nB3 -> B4\\. Weight: 2.\nR6 -> B5\\. Weight: 3.\nB5 -> B6\\. Weight: 6.\nR2 -> R1\\. Weight: 1.\nB2 -> R2\\. Weight: 25.\nR2 -> R3\\. Weight: 1.\nR3 -> R4\\. Weight: 1.\nR1 -> R5\\. Weight: 75.\nR5 -> R6\\. Weight: 3.\nCost: 139\n```", "```cs\npublic int[] Color()\n{\n    int[] colors = new int[Nodes.Count];\n    Array.Fill(colors, -1);\n    colors[0] = 0;\n    bool[] available = new bool[Nodes.Count];\n    for (int i = 1; i < Nodes.Count; i++)\n    {\n        Array.Fill(available, true);\n        foreach (Node<T> neighbor in Nodes[i].Neighbors)\n        {\n            int ci = colors[neighbor.Index];\n            if (ci >= 0) { available[ci] = false; }\n        }\n        colors[i] = Array.IndexOf(available, true);\n    }\n    return colors;\n}\n```", "```cs\nGraph<int> graph = new()\n    { IsDirected = false, IsWeighted = false };\nNode<int> n1 = graph.AddNode(1);\nNode<int> n2 = graph.AddNode(2);\nNode<int> n3 = graph.AddNode(3);\nNode<int> n4 = graph.AddNode(4);\nNode<int> n5 = graph.AddNode(5);\nNode<int> n6 = graph.AddNode(6);\nNode<int> n7 = graph.AddNode(7);\nNode<int> n8 = graph.AddNode(8);\ngraph.AddEdge(n1, n2);\ngraph.AddEdge(n1, n3);\ngraph.AddEdge(n2, n4);\ngraph.AddEdge(n3, n4);\ngraph.AddEdge(n4, n5);\ngraph.AddEdge(n4, n8);\ngraph.AddEdge(n5, n6);\ngraph.AddEdge(n5, n7);\ngraph.AddEdge(n5, n8);\ngraph.AddEdge(n6, n7);\ngraph.AddEdge(n7, n8);\nint[] colors = graph.Color();\nfor (int i = 0; i < colors.Length; i++)\n{\n    Console.WriteLine(\n        $\"Node {graph.Nodes[i].Data}: {colors[i]}\");\n}\n```", "```cs\nNode 1: 0\nNode 2: 1\nNode 3: 1\nNode 4: 0\nNode 5: 1\nNode 6: 0\nNode 7: 2\nNode 8: 3\n```", "```cs\nGraph<string> graph = new()\n    { IsDirected = false, IsWeighted = false };\nList<string> borders =\n[\n    \"PK:LU|SK|MA\",\n    \"LU:PK|SK|MZ|PD\",\n    \"SK:PK|MA|SL|LD|MZ|LU\",\n    \"MA:PK|SK|SL\",\n    \"SL:MA|SK|LD|OP\",\n    \"LD:SL|SK|MZ|KP|WP|OP\",\n    \"WP:LD|KP|PM|ZP|LB|DS|OP\",\n    \"OP:SL|LD|WP|DS\",\n    \"MZ:LU|SK|LD|KP|WM|PD\",\n    \"PD:LU|MZ|WM\",\n    \"WM:PD|MZ|KP|PM\",\n    \"KP:MZ|LD|WP|PM|WM\",\n    \"PM:WM|KP|WP|ZP\",\n    \"ZP:PM|WP|LB\",\n    \"LB:ZP|WP|DS\",\n    \"DS:LB|WP|OP\"\n];\nDictionary<string, Node<string>> nodes = [];\nforeach (string border in borders)\n{\n    string[] parts = border.Split(':');\n    string name = parts[0];\n    nodes[name] = graph.AddNode(name);\n}\nforeach (string border in borders)\n{\n    string[] parts = border.Split(':');\n    string name = parts[0];\n    string[] vicinities = parts[1].Split('|');\n    foreach (string vicinity in vicinities)\n    {\n        Node<string> from = nodes[name];\n        Node<string> to = nodes[vicinity];\n        if (!from.Neighbors.Contains(to))\n        {\n            graph.AddEdge(from, to);\n        }\n    }\n}\n```", "```cs\nint[] colors = graph.Color();\nfor (int i = 0; i < colors.Length; i++)\n{\n    Console.WriteLine(\n        $\"{graph.Nodes[i].Data}: {colors[i]}\");\n}\n```", "```cs\nPK: 0\nLU: 1\nSK: 2\nMA: 1\nSL: 0\nLD: 1\nWP: 0\nOP: 2\nMZ: 0\nPD: 2\nWM: 1\nKP: 2\nPM: 3\nZP: 1\nLB: 2\nDS: 1\n```", "```cs\nusing Priority_Queue; (...)\npublic List<Edge<T>> GetShortestPath(\n    Node<T> source, Node<T> target)\n{\n    int[] previous = new int[Nodes.Count];\n    Array.Fill(previous, -1);\n    int[] distances = new int[Nodes.Count];\n    Array.Fill(distances, int.MaxValue);\n    distances[source.Index] = 0;\n    SimplePriorityQueue<Node<T>> nodes = new();\n    for (int i = 0; i < Nodes.Count; i++)\n    {\n        nodes.Enqueue(Nodes[i], distances[i]);\n    }\n    while (nodes.Count != 0)\n    {\n        Node<T> node = nodes.Dequeue();\n        for (int i = 0; i < node.Neighbors.Count; i++)\n        {\n            Node<T> neighbor = node.Neighbors[i];\n            int weight = i < node.Weights.Count\n                ? node.Weights[i] : 0;\n            int wTotal = distances[node.Index] + weight;\n            if (distances[neighbor.Index] > wTotal)\n            {\n                distances[neighbor.Index] = wTotal;\n                previous[neighbor.Index] = node.Index;\n                nodes.UpdatePriority(neighbor,\n                    distances[neighbor.Index]);\n            }\n        }\n    }\n    List<int> indices = [];\n    int index = target.Index;\n    while (index >= 0)\n    {\n        indices.Add(index);\n        index = previous[index];\n    }\n    indices.Reverse();\n    List<Edge<T>> result = [];\n    for (int i = 0; i < indices.Count - 1; i++)\n    {\n        Edge<T> edge = this[indices[i], indices[i + 1]]!;\n        result.Add(edge);\n    }\n    return result;\n}\n```", "```cs\nGraph<int> graph = new()\n    { IsDirected = true, IsWeighted = true };\nNode<int> n1 = graph.AddNode(1); (...)\nNode<int> n8 = graph.AddNode(8);\ngraph.AddEdge(n1, n2, 9); (...)\ngraph.AddEdge(n8, n5, 3);\nList<Edge<int>> path = graph.GetShortestPath(n1, n5);\npath.ForEach(Console.WriteLine);\n```", "```cs\n1 -> 3\\. Weight: 5.\n3 -> 4\\. Weight: 12.\n4 -> 8\\. Weight: 8.\n8 -> 5\\. Weight: 3.\n```", "```cs\nusing System.Text;\nstring[] lines = new string[]\n{\n    \"0011100000111110000011111\",\n    \"0011100000111110000011111\",\n    \"0011100000111110000011111\",\n    \"0000000000011100000011111\",\n    \"0000001110000000000011111\",\n    \"0001001110011100000011111\",\n    \"1111111111111110111111100\",\n    \"1111111111111110111111101\",\n    \"1111111111111110111111100\",\n    \"0000000000000000111111110\",\n    \"0000000000000000111111100\",\n    \"0001111111001100000001101\",\n    \"0001111111001100000001100\",\n    \"0001100000000000111111110\",\n    \"1111100000000000111111100\",\n    \"1111100011001100100010001\",\n    \"1111100011001100001000100\"\n};\nbool[][] map = new bool[lines.Length][];\nfor (int i = 0; i < lines.Length; i++)\n{\n    map[i] = lines[i]\n        .Select(c => int.Parse(c.ToString()) == 0)\n        .ToArray();\n}\n```", "```cs\nGraph<string> graph = new()\n    { IsDirected = false, IsWeighted = true };\nfor (int i = 0; i < map.Length; i++)\n{\n    for (int j = 0; j < map[i].Length; j++)\n    {\n        if (!map[i][j]) { continue; }\n        Node<string> from = graph.AddNode($\"{i}-{j}\");\n        if (i > 0 && map[i - 1][j])\n        {\n            Node<string> to = graph.Nodes\n                .Find(n => n.Data == $\"{i - 1}-{j}\")!;\n            graph.AddEdge(from, to, 1);\n        }\n        if (j > 0 && map[i][j - 1])\n        {\n            Node<string> to = graph.Nodes\n                .Find(n => n.Data == $\"{i}-{j - 1}\")!;\n            graph.AddEdge(from, to, 1);\n        }\n    }\n}\n```", "```cs\nNode<string> s = graph.Nodes.Find(n => n.Data == \"0-0\")!;\nNode<string> t = graph.Nodes.Find(n => n.Data == \"16-24\")!;\nList<Edge<string>> path = graph.GetShortestPath(s, t);\n```", "```cs\nConsole.OutputEncoding = Encoding.UTF8;\nfor (int r = 0; r < map.Length; r++)\n{\n    for (int c = 0; c < map[r].Length; c++)\n    {\n        bool isPath = path.Any(e =>\n            e.From.Data == $\"{r}-{c}\"\n            || e.To.Data == $\"{r}-{c}\");\n        Console.ForegroundColor = isPath\n            ? ConsoleColor.White\n            : map[r][c]\n                ? ConsoleColor.Green\n                : ConsoleColor.Red;\n        Console.Write(\"\\u25cf \");\n    }\n    Console.WriteLine();\n}\nConsole.ResetColor();\n```", "```cs\n\n```"]