- en: Movie Booking Web App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电影预订 Web 应用
- en: 'So far, we have been exploring the features and fundamentals of ASP.NET Core
    2.0\. The applications we have developed are good examples to learn the concepts
    but do not make use of data persistence. In this chapter, we will learn to do
    read, write, update, and delete data operations, making use of Entity Framework
    Core. We will also learn how to deploy a web app in Azure and monitor its health.
    We will demonstrate this by developing a simple movie booking web app, where a
    user can book a ticket for a movie. So, in this chapter, we will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在探索 ASP.NET Core 2.0 的特性和基础。我们开发的应用是学习概念的好例子，但并未使用数据持久化。在本章中，我们将学习如何进行读取、写入、更新和删除数据操作，并利用
    Entity Framework Core 来实现。我们还将学习如何在 Azure 中部署 Web 应用并监控其健康状况。我们将通过开发一个简单的电影预订
    Web 应用来展示这一点，用户可以在该应用中预订电影票。因此，在本章中，我们将涵盖以下主题：
- en: Introducing Entity Framework and Entity Framework Core
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Entity Framework 和 Entity Framework Core
- en: Getting started with Entity Framework Core
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Entity Framework Core
- en: Movie booking app requirements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影预订应用需求
- en: Designing the movie booking app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计电影预订应用
- en: Coding the movie booking app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写电影预订应用
- en: Deploying the movie booking app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署电影预订应用
- en: Monitoring the movie booking app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控电影预订应用
- en: Let's start with an introduction to Entity Framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Entity Framework 的介绍开始。
- en: Introducing Entity Framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Entity Framework
- en: So what is **Entity Framework** (**EF**)? Is it some other fancy framework that
    I need to learn? If these thoughts are coming to mind, get rid of them, as EF
    is just a set of .NET APIs for accessing data. EF is the official data access
    tool from Microsoft. Like most Microsoft products, it originated from Microsoft
    Research, and later it was adopted by the ADO.NET team as the next innovation
    in Microsoft's data access technology. EF has evolved over time. It had a sluggish
    start in 2008 when developers found it hard to digest a new way of accessing data.
    But with EF4 (yes, the second version of EF was 4, as it was aligned with .NET
    4), it had become the norm to use EF for data accessing with .NET. Continuing
    the journey, it became open source in version EF6 and moved to CodePlex ([http://www.codeplex.com](http://www.codeplex.com)).
    This opened up new avenues for EF. As it became open source, the community could
    make contributions as well. Now that CodePlex is archived, EF6 has moved to GitHub
    and is actively being developed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是 **Entity Framework**（**EF**）？它是不是我需要学习的一些其他花哨的框架？如果这些想法出现在你的脑海中，请摒弃它们，因为
    EF 只是一组用于访问数据的 .NET API。EF 是微软的官方数据访问工具。像大多数微软产品一样，它起源于微软研究院，后来被 ADO.NET 团队采纳作为微软数据访问技术的下一个创新。EF
    随着时间的推移而发展。它在 2008 年起步缓慢，当时开发者发现难以消化一种新的数据访问方式。但随着 EF4（是的，EF 的第二个版本是 4，因为它与 .NET
    4 对齐），使用 EF 进行数据访问已成为 .NET 的标准。继续这一旅程，EF6 版本使其成为开源项目，并迁移到 CodePlex ([http://www.codeplex.com](http://www.codeplex.com))。这为
    EF 开辟了新的道路。随着它成为开源项目，社区也可以做出贡献。现在 CodePlex 已存档，EF6 已迁移到 GitHub 并正在积极开发。
- en: EF is also referred to as an ORM. What is an ORM? An **ORM** stands for **object-relational
    mapping**, which broadly means mapping objects to relational tables. An ORM refers
    to the technique for converting data between two incompatible type systems. For
    example, let us consider a C# **plain old CLR object** (**POCO**) of a `Person`
    class. An instance of the `Person` class has the `Name`, `Id`, and `Age` properties
    of `string`, `int` and `int` types, respectively. In the SQL database, this data
    would be persisted in a table named `Person` with the columns `Name`, `Id`, `Age`,
    and so on. An ORM maps the `Person` POCO to the `Person` database table. The primary
    intent of an ORM is to try and shield the developer from having to write optimized
    SQL code for this inter-conversion. An ORMs are designed to reduce the friction
    between how data is structured in a relational database and how the classes are
    defined. Without an ORM, we typically need to write a lot of code to transform
    database results into instances of the classes. An ORM allows us to express our
    queries using our classes, and then an ORM builds and executes the relevant SQL
    for us, as well as materializing objects from the data that came back from the
    database. What I say here is an oversimplification and there's a lot more to an
    ORMs and to Entity Framework than this. Entity Framework can really enhance developer
    productivity and we will see this while developing the movie booking app. EF has
    a dedicated team at Microsoft. It has been around for almost a decade now. Rather
    than writing the relevant SQL to target whatever relational database you're working
    with, Entity Framework uses the **Language-Integrated Query** (**LINQ**) syntax
    that's part of the .NET framework. LINQ to Entities allows developers to use a
    consistent and strongly-typed query language irrespective of what database they're
    targeting. Additionally, LINQ to Objects is used for querying other elements of
    .NET, even `InMemory` objects, so developers benefit from their knowledge of LINQ.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: EF 也被称为 ORM。什么是 ORM？**ORM** 代表 **对象关系映射**，广义上意味着将对象映射到关系表中。ORM 指的是在两种不兼容的类型系统之间转换数据的技术。例如，让我们考虑一个
    `Person` 类的 C# **普通 CLR 对象**（**POCO**）。`Person` 类的一个实例具有 `Name`、`Id` 和 `Age` 属性，分别对应
    `string`、`int` 和 `int` 类型。在 SQL 数据库中，这些数据将持久化在名为 `Person` 的表中，具有 `Name`、`Id`、`Age`
    等列。ORM 将 `Person` POCO 映射到 `Person` 数据库表。ORM 的主要目的是尽量减少开发者编写优化 SQL 代码进行这种转换的需要。ORMs
    被设计用来减少关系数据库中数据结构化方式与类定义方式之间的摩擦。没有 ORM，我们通常需要编写大量代码来将数据库结果转换为类的实例。ORM 允许我们使用我们的类来表示查询，然后
    ORM 为我们构建并执行相关的 SQL，以及从数据库返回的数据中实例化对象。我这里所说的只是一个简化的描述，ORMs 和 Entity Framework
    的内容远不止这些。Entity Framework 真正提高了开发者的生产力，我们将在开发电影预订应用程序时看到这一点。EF 在微软有一个专门的团队。它已经存在了近十年。与为所使用的任何关系数据库编写相关的
    SQL 相比，Entity Framework 使用的是 .NET 框架的一部分，即 **语言集成查询**（**LINQ**）语法。LINQ to Entities
    允许开发者使用一致且强类型的查询语言，无论他们针对的是哪种数据库。此外，LINQ to Objects 用于查询 .NET 的其他元素，甚至 `InMemory`
    对象，因此开发者可以从他们的 LINQ 知识中受益。
- en: Since we are working with .NET Core and want to make a cross-platform app, we
    cannot use Entity Framework, as it's not compatible with ASP.NET Core. Don't worry!
    We have solutions. Either we can compile our project against the full .NET Framework
    or we can use the latest and greatest version of Entity Framework called Entity
    Framework Core, which is a lightweight and cross-platform version of Entity Framework,
    rewritten from scratch to support a variety of platforms. Let's discuss Entity
    Framework Core.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 .NET Core 并希望制作一个跨平台的应用程序，我们不能使用 Entity Framework，因为它与 ASP.NET Core
    不兼容。别担心！我们有解决方案。要么我们可以将我们的项目编译针对完整的 .NET Framework，要么我们可以使用最新且最优秀的 Entity Framework
    版本，即 Entity Framework Core，这是一个轻量级且跨平台的 Entity Framework 版本，从头开始重写以支持各种平台。让我们来讨论
    Entity Framework Core。
- en: Presenting Entity Framework Core
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Entity Framework Core
- en: EF Core was released in June 2016 after more than 2 years of dedicated effort
    and following numerous alpha, beta, and even a few release candidate versions.
    It was originally named Entity Framework 7, but later its name was changed to
    Entity Framework Core. So what exactly is Entity Framework Core? The official
    Microsoft documentation ([https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/))
    describes Entity Framework Core as a lightweight and extensible version of Entity
    Framework. In other words, this is not simply an update from EF6; it's a brand
    new Entity Framework altogether. EF6 is still actively supported and will continue
    to have tweaks and fixes made to it, though for many reasons, all of the true
    innovation has gone into Entity Framework Core. Apart from new features that the
    team wanted to add to Entity Framework, there are also some critical and comprehensive
    themes for developing EF Core which align with ASP.NET Core and the underlying
    .NET Core. The idea behind developing EF Core is that it should be built from
    lightweight composable APIs; that is, it should be able to run on different operating
    systems that can host native implementations of the CoreCLR and, equally important,
    use modern software practices in the design, coding, and delivery of Entity Framework
    Core. Like EF6, EF Core is open source and available on GitHub. The source code
    of EF Core can be seen at [https://github.com/aspnet/EntityFrameworkCore](https://github.com/aspnet/EntityFrameworkCore).
    The EF team has a road map for the features that they are prioritizing and the
    order in which they will be shipped in the upcoming releases. The road map for
    EF Core can be seen at [https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap](https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core于2016年6月发布，经过了超过2年的专注努力，并经历了多次alpha、beta版本，甚至几个发布候选版本。它最初被命名为Entity Framework
    7，但后来其名称被改为Entity Framework Core。那么，Entity Framework Core究竟是什么呢？官方的Microsoft文档([https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/))将Entity
    Framework Core描述为一个轻量级且可扩展的Entity Framework版本。换句话说，这不仅仅是对EF6的更新；它是一个全新的Entity
    Framework。EF6仍然得到积极支持，并将继续对其进行调整和修复，尽管出于许多原因，所有的真正创新都投入到了Entity Framework Core中。除了团队希望添加到Entity
    Framework中的新特性外，还有一些对开发EF Core至关重要的全面主题，这些主题与ASP.NET Core和底层的.NET Core相一致。开发EF
    Core背后的理念是，它应该由轻量级的可组合API构建；也就是说，它应该能够在可以托管CoreCLR原生实现的操作系统上运行，同样重要的是，在设计、编码和交付Entity
    Framework Core时使用现代软件实践。与EF6一样，EF Core是开源的，可在GitHub上获取。EF Core的源代码可在[https://github.com/aspnet/EntityFrameworkCore](https://github.com/aspnet/EntityFrameworkCore)查看。EF团队有一个针对他们优先考虑的功能和即将发布的版本中它们将按何种顺序发布的路线图。EF
    Core的路线图可在[https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap](https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap)查看。
- en: EF Core runs on .NET Core, and .NET Core runs in a lot of places, such as Windows
    and Linux-based systems, as we have seen in earlier chapters. It runs inside the
    full .NET Framework, so any version that is 4.5.1 or newer. .NET Core itself can
    run on the CoreCLR; that's the runtime. CoreCLR can run natively, not only on
    Windows, but also on Macintosh and Linux. EF Core can also be used with the **Universal
    Windows Platform** (**UWP**) for Windows 10, so it runs on any device or PC that
    can run on Windows 10\. So one may be tempted to think, should I use EF Core anywhere
    and everywhere, just because it is supported? The answer is *no*. This is a really
    important point to keep in mind. EF Core is a brand new set of APIs, and so it
    doesn't have all of the features that you might be used to with EF 6, and while
    some of those features will be coming in future versions of EF Core, there are
    a few that will never be part of EF Core, so it's important to understand this,
    and hence you may not want to start every single new project with EF Core. Before
    using EF Core, ensure that EF Core has all the features that you need. For a comprehensive
    list of features that are available in EF and EF Core and for a comparison, I
    would highly recommend that you visit the official Microsoft documentation describing
    the feature comparison between EF and EF Core in depth at [https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 在 .NET Core 上运行，.NET Core 在许多地方运行，如我们之前章节中看到的，包括基于 Windows 和 Linux 的系统。它可以在完整的
    .NET Framework 内运行，因此任何 4.5.1 或更新版本的版本都可以。.NET Core 本身可以在 CoreCLR 上运行；这就是运行时。CoreCLR
    可以在原生模式下运行，不仅限于 Windows，还可以在 Macintosh 和 Linux 上运行。EF Core 还可以与 **通用 Windows 平台**（**UWP**）结合使用，适用于
    Windows 10，因此它可以在任何可以运行 Windows 10 的设备或 PC 上运行。因此，可能会有人想，我应该在任何地方使用 EF Core，仅仅因为它得到了支持吗？答案是
    *不*。这是一个需要牢记的重要观点。EF Core 是一套全新的 API，因此它没有所有你可能习惯于 EF 6 的功能，尽管其中一些功能将在 EF Core
    的未来版本中提供，但有一些功能将永远不会成为 EF Core 的一部分，因此了解这一点很重要，因此你可能不想用 EF Core 开始每一个新的项目。在使用
    EF Core 之前，请确保 EF Core 具有你需要的所有功能。为了获取 EF 和 EF Core 中可用的功能的完整列表以及比较，我强烈建议您访问官方
    Microsoft 文档，深入了解 EF 和 EF Core 之间的特性比较，请参阅[https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features)。
- en: 'For the sake of completeness, the subset of the feature comparison containing
    the important features are listed in the following table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，包含重要功能的特性比较子集如下表所示：
- en: '| **Name of feature** | **EF6** | **EF Core** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **特性名称** | **EF6** | **EF Core** |'
- en: '| **Entity Data Model Extension** (**EDMX**) designer support | Yes | No |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **实体数据模型扩展**（**EDMX**）设计器支持 | 是 | 否 |'
- en: '| Entity Data Model Wizard (for database first approach) | Yes | No |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 实体数据模型向导（用于数据库优先方法） | 是 | 否 |'
- en: '| Automatic migration | Yes | No |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 自动迁移 | 是 | 否 |'
- en: '| Lazy loading of data | Yes | No |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 数据的懒加载 | 是 | 否 |'
- en: '| Stored procedure mapping with DbContext | Yes | No |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 使用 DbContext 映射存储过程 | 是 | 否 |'
- en: '| Batch `Insert`, `Update`, `Delete` operations | No | Yes |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 批量 `插入`、`更新`、`删除` 操作 | 否 | 是 |'
- en: '| In-memory provider for testing | No | Yes |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 测试用的内存提供程序 | 否 | 是 |'
- en: '| Support for **Inversion of Control** (**IoC**) | No | Yes |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 支持 **控制反转**（**IoC**） | 否 | 是 |'
- en: '| Field mapping | No | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 字段映射 | 否 | 是 |'
- en: '| DbContext pooling | No | Yes |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| DbContext 连池 | 否 | 是 |'
- en: If you are overwhelmed with this comparison and feel out of place with the listed
    features, do not worry. EF is indeed a huge topic to learn. However, we will learn
    to use it from scratch to have the basic fundamentals in place. To do so, we will
    learn to create a simple data access console application. Once we know how to
    use EF Core, we can then use it in our movie booking app.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被这个比较搞得不知所措，对列出的功能感到困惑，不要担心。EF 确实是一个很大的学习主题。然而，我们将从头开始学习使用它，以确保基本原理到位。为此，我们将学习创建一个简单的数据访问控制台应用程序。一旦我们知道了如何使用
    EF Core，我们就可以将其用于我们的电影预订应用程序。
- en: Getting started with Entity Framework Core
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Entity Framework Core
- en: 'In this section, we will create a simple console application to perform CRUD
    operations using Entity Framework Core. The intent is to get started with EF Core
    and understand how to use it. Before we dive into coding, let us see the two development
    approaches that EF Core supports:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个简单的控制台应用程序，使用 Entity Framework Core 执行 CRUD 操作。目的是开始使用 EF Core 并了解如何使用它。在我们开始编码之前，让我们看看
    EF Core 支持的两种开发方法：
- en: Code-first
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码优先
- en: Database-first
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库优先
- en: These two paradigms have been supported for a very long time and therefore we
    will just look at them at a very high level. EF Core mainly targets the code-first
    approach and has limited support for the database-first approach, as there is
    no support for the visual designer or wizard for the database model out of the
    box. However, there are third-party tools and extensions that support this. The
    list of third-party tools and extensions can be seen at [https://docs.microsoft.com/en-us/ef/core/extensions/](https://docs.microsoft.com/en-us/ef/core/extensions/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种范式已经支持了很长时间，因此我们只需从非常高的层次来看它们。EF Core 主要针对代码优先的方法，并且对数据库优先的方法支持有限，因为没有提供数据库模型的可视设计器或向导。然而，有一些第三方工具和扩展支持这一点。第三方工具和扩展的列表可以在
    [https://docs.microsoft.com/en-us/ef/core/extensions/](https://docs.microsoft.com/en-us/ef/core/extensions/)
    上看到。
- en: 'In the code-first approach, we first write the code; that is, we first create
    the domain model classes and then, using these classes, EF Core APIs create the
    database and tables, using migration based on the convention and configuration
    provided. We will look at conventions and configurations a little later in this
    section. The following diagram illustrates the code-first approach:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码优先的方法中，我们首先编写代码；也就是说，我们首先创建领域模型类，然后，使用这些类，EF Core API 基于提供的约定和配置创建数据库和表。我们将在本节稍后讨论约定和配置。以下图示说明了代码优先的方法：
- en: '![](img/fec0da35-b58c-4829-a27d-92378b1fe6df.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fec0da35-b58c-4829-a27d-92378b1fe6df.png)'
- en: 'In the database-first approach, as the name suggests, we have an existing database
    or we create a database first and then use EF Core APIs to create the domain and
    context classes. As mentioned, currently EF Core has limited support for it due
    to a lack of tooling. So, our preference will be for the code-first approach throughout
    our examples. The reader can discover the third-party tools mentioned previously
    to learn more about the EF Core database-first approach as well. The following
    image illustrates the database-first approach:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库优先的方法中，正如其名所示，我们有一个现有的数据库，或者我们首先创建一个数据库，然后使用 EF Core API 创建领域和上下文类。如前所述，由于工具不足，目前
    EF Core 对其支持有限。因此，在我们的示例中，我们将偏好代码优先的方法。读者可以查找前面提到的第三方工具，以了解更多关于 EF Core 数据库优先方法的信息。以下图像说明了数据库优先的方法：
- en: '![](img/07b99ff7-0e84-471c-bcf9-f631183b3754.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07b99ff7-0e84-471c-bcf9-f631183b3754.png)'
- en: We will refer to properties as scalar properties and navigation properties.
    Although it's an old concept, it's worth revisiting it again to gain a better
    understanding. A property can contain primitive data (such as a string, an integer,
    or a Boolean value), or structured data (such as a complex type). Properties that
    are of a primitive type are also called **scalar** properties. The complex properties
    or properties of another non-simple type are referred to as **complex** or **navigation**
    properties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性分为标量属性和导航属性。虽然这是一个旧概念，但值得再次回顾以获得更好的理解。属性可以包含原始数据（例如字符串、整数或布尔值），或者结构化数据（例如复杂类型）。原始类型的属性也称为**标量**属性。复杂属性或非简单类型的属性被称为**复杂**或**导航**属性。
- en: 'Now that we understand the approaches and know that we will be using the code-first
    approach, let''s dive into coding our getting started with EF Core console app.
    Before we do so, we need to have SQL Express installed in our development machine.
    If SQL Express is not installed, download the SQL Express 2017 edition from [https://www.microsoft.com/en-IN/sql-server/sql-server-downloads](https://www.microsoft.com/en-IN/sql-server/sql-server-downloads)
    and run the setup wizard. We will do the Basic installation of SQL Express 2017
    for our learning purposes, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了方法，并且知道我们将使用代码优先的方法，让我们深入到使用 EF Core 控制台应用程序的入门编码中。在这样做之前，我们需要在我们的开发机器上安装
    SQL Express。如果 SQL Express 没有安装，请从 [https://www.microsoft.com/en-IN/sql-server/sql-server-downloads](https://www.microsoft.com/en-IN/sql-server/sql-server-downloads)
    下载 SQL Express 2017 版本，并运行安装向导。为了我们的学习目的，我们将为 SQL Express 2017 执行基本安装，如下面的截图所示：
- en: '![](img/e7c5ae8b-25d4-423d-81e2-230772f4f052.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7c5ae8b-25d4-423d-81e2-230772f4f052.png)'
- en: 'Our objective is to learn how to use EF Core and so we will not do anything
    fancy in our console app. We will just do simple **Create Read Update Delete**
    (**CRUD**) operations of a simple class called `Person`, as defined here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是学习如何使用 EF Core，因此我们不会在我们的控制台应用程序中做任何花哨的事情。我们只会对名为 `Person` 的简单类执行简单的**创建**、**读取**、**更新**和**删除**（**CRUD**）操作，如下所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see in the preceding code, the class has simple properties. To perform
    the CRUD operations on this class, let''s create a console app by performing the
    following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，该类具有简单的属性。为了对这个类执行 CRUD 操作，让我们通过以下步骤创建一个控制台应用程序：
- en: 'Create a new .NET Core console project named `GettingStartedWithEFCore`, as
    shown in the following screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GettingStartedWithEFCore` 的新 .NET Core 控制台项目，如下截图所示：
- en: '![](img/35f82b30-fd0d-44d1-94b8-29bf7d83d6d7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35f82b30-fd0d-44d1-94b8-29bf7d83d6d7.png)'
- en: Create a new folder named `Models` in the project node and add the `Person`
    class to this newly created folder. This will be our model entity class, which
    we will use for CRUD operations.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目节点中创建一个名为 `Models` 的新文件夹，并将 `Person` 类添加到这个新创建的文件夹中。这将是我们用于 CRUD 操作的模型实体类。
- en: 'Next, we need to install the EF Core package. Before we do that, it''s important
    to know that EF Core provides support for a variety of databases. A few of the
    important ones are:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装 EF Core 包。在这样做之前，重要的是要知道 EF Core 提供了对各种数据库的支持。其中一些重要的包括：
- en: SQL Server
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server
- en: SQLite
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: InMemory (for testing)
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: InMemory（用于测试）
- en: 'The complete and comprehensive list can be seen at [https://docs.microsoft.com/en-us/ef/core/providers/](https://docs.microsoft.com/en-us/ef/core/providers/).
    We will be working with SQL Server on Windows for our learning purposes, so let''s
    install the SQL Server package for Entity Framework Core. To do so, let''s install
    the **`Microsoft.EntityFrameworkCore.SqlServer`** package from the NuGet Package
    Manager in Visual Studio 2017\. Right-click on the project. Select Manage Nuget
    Packages and then search for `Microsoft.EntityFrameworkCore.SqlServer`. Select
    the matching result and click Install:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完整且全面的列表可以在[https://docs.microsoft.com/en-us/ef/core/providers/](https://docs.microsoft.com/en-us/ef/core/providers/)中看到。为了我们的学习目的，我们将使用
    Windows 上的 SQL Server，因此让我们安装 Entity Framework Core 的 SQL Server 包。为此，让我们在 Visual
    Studio 2017 的 NuGet 包管理器中安装 **`Microsoft.EntityFrameworkCore.SqlServer`** 包。右键单击项目。选择管理
    NuGet 包，然后搜索 `Microsoft.EntityFrameworkCore.SqlServer`。选择匹配的结果并点击安装：
- en: '![](img/6e166ab1-fc79-462f-a408-58e7131240bc.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e166ab1-fc79-462f-a408-58e7131240bc.png)'
- en: 'Next, we will create a class called `Context`, as shown here:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `Context` 的类，如下所示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The class looks quite simple, but it has the following subtle and important
    things to make note of:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来相当简单，但它有以下需要注意的微妙且重要的事项：
- en: The `Context` class derives from `DbContext`, which resides in the `Microsoft.EntityFrameworkCore`
    namespace. `DbContext` is an integral part of EF Core and if you have worked with
    EF, you will already be aware of it. An instance of `DbContext` represents a session
    with the database and can be used to query and save instances of your entities.
    `DbContext` is a combination of the Unit Of Work and Repository Patterns. Typically,
    you create a class that derives from `DbContext` and contains `Microsoft.EntityFrameworkCore.DbSet` properties
    for each entity in the model.
  id: totrans-57
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 类从 `DbContext` 派生，该类位于 `Microsoft.EntityFrameworkCore` 命名空间中。`DbContext`
    是 EF Core 的一个重要部分，如果你已经使用过 EF，那么你将已经了解它。`DbContext` 的一个实例代表与数据库的会话，并且可以用来查询和保存你的实体实例。`DbContext`
    是工作单元模式和仓储模式的组合。通常，你会创建一个从 `DbContext` 派生的类，并为模型中的每个实体包含 `Microsoft.EntityFrameworkCore.DbSet`
    属性。'
- en: If properties have a `public` setter, they are automatically initialized when
    the instance of the derived context is created.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性具有 `public` 设置器，则在创建派生上下文实例时它们会自动初始化。
- en: It contains a property named `Persons` (plural of the model class `Person`)
    of type `DbSet<Person&gt;`. This will map to the `Persons` table in the underlying
    database.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个名为 `Persons`（模型类 `Person` 的复数形式）的属性，类型为 `DbSet<Person>`。这将对底层数据库中的 `Persons`
    表进行映射。
- en: The class overrides the `OnConfiguring` method of `DbContext` and specifies
    the connection string to be used with the SQL Server database. The connection
    string should be read from the configuration file, `appSettings.json`, but for
    the sake of brevity and simplicity, it's hardcoded in the preceding code. The
    `OnConfiguring` method allows us to select and configure the data source to be
    used with a context using `DbContextOptionsBuilder`. Let's look at the connection
    string. `Server=` specifies the server. It can be `.\SQLEXPRESS`, `.\SQLSERVER`,
    `.\LOCALDB`, or any other instance name based on the installation you have done.
    `Database=` specifies the database name that will be created. `Trusted_Connection=True`
    specifies that we are using integrated security or Windows authentication. An
    enthusiastic reader should read the official Microsoft Entity framework documentation
    on configuring the context at [https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext](https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext).
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类重写了 `DbContext` 的 `OnConfiguring` 方法，并指定了用于 SQL Server 数据库的连接字符串。连接字符串应从配置文件
    `appSettings.json` 中读取，但为了简洁和简单，前面的代码中将其硬编码。`OnConfiguring` 方法允许我们使用 `DbContextOptionsBuilder`
    选择和配置与上下文一起使用的数据源。让我们看看连接字符串。`Server=` 指定服务器。它可以是 `.\SQLEXPRESS`、`.\SQLSERVER`、`.\LOCALDB`
    或任何基于您所进行的安装的其他实例名称。`Database=` 指定将要创建的数据库名称。`Trusted_Connection=True` 指定我们正在使用集成安全或
    Windows 身份验证。一个热情的读者应该阅读官方 Microsoft Entity Framework 文档中关于配置上下文的说明，请参阅 [https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext](https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext)。
- en: 'The `OnModelCreating` method allows us to configure the model using the `ModelBuilder`
    Fluent API. This is the most powerful method of configuration and allows configuration
    to be specified without modifying the entity classes. The Fluent API configuration
    has the highest precedence and will override conventions and data annotations.
    The preceding code has same effect as the following data annotation has on the
    `Name` property in the `Person` class:'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnModelCreating` 方法允许我们使用 `ModelBuilder` 流式 API 来配置模型。这是配置中最强大的方法，允许在不修改实体类的情况下指定配置。流式
    API 配置具有最高优先级，并将覆盖约定和数据注释。前面的代码与以下数据注释对 `Person` 类中的 `Name` 属性具有相同的效果：'
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding point highlights the flexibility and configuration that EF Core
    brings to the table. EF Core uses a combination of conventions, attributes, and
    Fluent API statements to build a database model at runtime. All we have to do
    is to perform actions on the model classes using a combination of these and they
    will automatically be translated to appropriate changes in the database. Before
    we conclude this point, let''s have a quick look at each of the different ways
    to configure a database model:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的观点突出了 EF Core 带来的灵活性和配置能力。EF Core 使用约定、属性和流式 API 语句的组合在运行时构建数据库模型。我们只需对这些模型类执行操作，它们就会自动转换为数据库中的适当更改。在我们结束这个观点之前，让我们快速看一下配置数据库模型的不同方法：
- en: '**EF Core conventions**: The conventions in EF Core are comprehensive. They
    are the default rules by which EF Core builds a database model based on classes.
    A few of the simpler yet important default conventions are listed here:'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EF Core 约定**：EF Core 的约定非常全面。它们是 EF Core 根据类构建数据库模型的默认规则。以下列出了一些简单但重要的默认约定：'
- en: EF Core creates database tables for all `DbSet<TEntity&gt;` properties in a
    `Context` class with the same name as that of the property. In the preceding example,
    the table name would be `Persons` based on this convention.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core 为 `Context` 类中所有与属性同名的 `DbSet<TEntity>` 属性创建数据库表。在先前的示例中，根据此约定，表名将是
    `Persons`。
- en: EF Core creates tables for entities that are not included as `DbSet` properties
    but are reachable through reference properties in the other `DbSet` entities.
    If the `Person` class had a complex/navigation property, EF Core would have created
    a table for it as well.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core 为那些未作为 `DbSet` 属性包含但可以通过其他 `DbSet` 实体的引用属性访问的实体创建表。如果 `Person` 类有一个复杂/导航属性，EF
    Core 也会为它创建一个表。
- en: EF Core creates columns for all the scalar read-write properties of a class
    with the same name as the property by default. It uses the reference and collection
    properties for building relationships among corresponding tables in the database.
    In the preceding example, the scalar properties of `Person` correspond to a column
    in the `Persons` table.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core默认为类的所有标量读写属性创建具有与属性相同名称的列。它使用引用和集合属性在数据库中对应表之间建立关系。在前面的示例中，`Person`的标量属性对应于`Persons`表中的一列。
- en: EF Core assumes a property named `ID` or one that is suffixed with `ID` as a
    primary key. If the property is an `integer` type or `Guid` type, then EF Core
    also assumes it to be `IDENTITY` and automatically assigns a value when inserting
    the data. This is precisely what we will make use of in our example while inserting
    or creating a new `Person`.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core假设一个名为`ID`或以`ID`结尾的属性为主键。如果该属性是`integer`类型或`Guid`类型，则EF Core还假设它为`IDENTITY`，并在插入数据时自动分配值。这正是我们将在插入或创建新的`Person`时使用的内容。
- en: 'EF Core maps the data type of a database column based on the data type of the
    property defined in the C# class. A few of the mappings between the C# data type
    to the SQL Server column data type are listed in the following table:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core根据C#类中定义的属性的数据类型将数据库列的数据类型映射。以下表格列出了C#数据类型到SQL Server列数据类型的一些映射：
- en: '| **C# data type** | **SQL server data type** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **C#数据类型** | **SQL Server数据类型** |'
- en: '| `int` | `int` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `int` |'
- en: '| `string` | `nvarchar(Max)` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `nvarchar(Max)` |'
- en: '| `decimal` | `decimal(18,2)` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `decimal(18,2)` |'
- en: '| `float` | `real` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `real` |'
- en: '| `byte[]` | `varbinary(Max)` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `byte[]` | `varbinary(Max)` |'
- en: '| `datetime` | `datetime` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | `datetime` |'
- en: '| `bool` | `bit` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bit` |'
- en: '| `byte` | `tinyint` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `tinyint` |'
- en: '| `short` | `smallint` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `smallint` |'
- en: '| `long` | `bigint` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `bigint` |'
- en: '| `double` | `float` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `float` |'
- en: There are many other conventions, and we can define custom conventions as well.
    For more details, please read the official Microsoft documentation at [https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他约定，我们也可以定义自定义约定。有关更多详细信息，请阅读官方Microsoft文档[https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/)。
- en: '**Attributes**: Conventions are often not enough to map the class to database
    objects. In such scenarios, we can use attributes called data annotation attributes
    to get the desired results. The `[Required]` attribute that we have just seen
    is an example of a data annotation attribute.'
  id: totrans-83
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：约定通常不足以将类映射到数据库对象。在这种情况下，我们可以使用称为数据注释属性的数据属性来获得所需的结果。我们刚刚看到的`[Required]`属性就是一个数据注释属性的例子。'
- en: '**Fluent API**: This is the most powerful way of configuring the model and
    can be used in addition to or in place of attributes. The code written in the
    `OnModelConfiguring` method is an example of a Fluent API statement.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fluent API**：这是配置模型最强大的方式，可以与属性一起使用，也可以替代属性。在`OnModelConfiguring`方法中编写的代码是Fluent
    API语句的一个示例。'
- en: 'If we check now, there is no `PersonDatabase` database. So, we need to create
    the database from the model by adding a migration. EF Core includes different
    migration commands to create or update the database based on the model. To do
    so in Visual Studio 2017, go to Tools | Nuget Package Manager | Package Manager
    Console, as shown in the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在检查，没有`PersonDatabase`数据库。因此，我们需要通过添加迁移从模型创建数据库。EF Core包括不同的迁移命令，根据模型创建或更新数据库。要在Visual
    Studio 2017中这样做，请转到“工具”|“NuGet包管理器”|“包管理器控制台”，如下面的截图所示：
- en: '![](img/6d137a6b-e4fc-44b4-b98e-690d5f6be93a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d137a6b-e4fc-44b4-b98e-690d5f6be93a.png)'
- en: 'This will open the Package Manager Console window. Select the Default Project
    as `GettingStartedWithEFCore` and type the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开包管理器控制台窗口。选择默认项目为`GettingStartedWithEFCore`，并输入以下命令：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are not using Visual Studio 2017 and you are dependent on .NET Core
    CLI tooling, you can use the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Visual Studio 2017，并且依赖于.NET Core CLI工具，可以使用以下命令：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have not installed the `Microsoft.EntityFrameworkCore.Design` package, so
    it will give an error:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尚未安装`Microsoft.EntityFrameworkCore.Design`包，因此它将报错：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So let''s first go to the NuGet Package Manager and install this package. After
    successful installation of this package, if we run the preceding command again,
    we should be able to run the migrations successfully. It will also tell us the
    command to undo the migration by displaying the message `To undo this action,
    use Remove-Migration`. We should see the new files added in the Solution Explorer
    in the `Migrations` folder, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们转到 NuGet 包管理器并安装此包。在成功安装此包后，如果我们再次运行前面的命令，我们应该能够成功运行迁移。它还会告诉我们如何通过显示消息
    `To undo this action, use Remove-Migration` 来撤销迁移。我们应该在解决方案资源管理器中的 `Migrations`
    文件夹中看到新添加的文件，如下面的截图所示：
- en: '![](img/3dc76353-f5e6-4551-9329-0c3f916d9afc.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dc76353-f5e6-4551-9329-0c3f916d9afc.png)'
- en: Although we have migrations applied, we have still not created a database. To
    create the database, we need to run the following commands.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们已经应用了迁移，但我们还没有创建数据库。要创建数据库，我们需要运行以下命令。
- en: 'In Visual Studio 2017:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In .NET Core CLI:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core CLI 中：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If all goes well, we should have the database created with the `Persons` table
    (property of type `DbSet<Person&gt;`) in the database. Let's validate the table
    and database by using **SQL Server Management Studio** (**SSMS**). If SSMS is
    not installed in your machine, you can also use Visual Studio 2017 to view the
    database and table.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该已经创建了数据库，其中包含 `Persons` 表（`DbSet<Person>` 的属性）在数据库中。让我们使用 **SQL Server
    Management Studio**（**SSMS**）来验证表和数据库。如果 SSMS 没有安装在你的机器上，你也可以使用 Visual Studio
    2017 来查看数据库和表。
- en: 'Let''s check the created database. In Visual Studio 2017, click on the View
    menu and select Server Explorer, as shown in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查创建的数据库。在 Visual Studio 2017 中，点击视图菜单并选择服务器资源管理器，如下面的截图所示：
- en: '![](img/d55398f1-a213-44cd-a87e-95351d283d60.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d55398f1-a213-44cd-a87e-95351d283d60.png)'
- en: 'In Server Explorer, right-click on Data Connections and then select Add Connection.
    The Add Connection dialog will show up. Enter `.\SQLEXPRESS` in the Server name
    (since we installed SQL EXPRESS 2017) and select `PersonDatabase` as the database,
    as shown in the following screenshot:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器资源管理器中，右键单击数据连接，然后选择添加连接。添加连接对话框将出现。在服务器名称中输入 `.\SQLEXPRESS`（因为我们安装了 SQL
    EXPRESS 2017），并将 `PersonDatabase` 作为数据库选择，如下面的截图所示：
- en: '![](img/7ed2a195-3cc8-47fb-838e-6aab77eaf8bd.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ed2a195-3cc8-47fb-838e-6aab77eaf8bd.png)'
- en: 'On clicking OK, we will see the database named `PersonDatabase` and if we expand
    the tables, we can see the `Persons` table as well as the `_EFMigrationsHistory`
    table. Notice that the properties in the `Person` class that had setters are the
    only properties that get transformed into table columns in the `Persons` table.
    Notice that the `Age` property is read-only in the class we created and therefore
    we do not see an age column in the database table, as shown in the following screenshot:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定后，我们将看到名为 `PersonDatabase` 的数据库，如果我们展开表，我们还可以看到 `Persons` 表以及 `_EFMigrationsHistory`
    表。注意，`Person` 类中具有设置器的属性是唯一被转换成 `Persons` 表的列的属性。注意，我们创建的类中的 `Age` 属性是只读的，因此我们在数据库表中看不到年龄列，如下面的截图所示：
- en: '![](img/14616bd5-4e82-40e5-b72d-44a1d60243f2.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14616bd5-4e82-40e5-b72d-44a1d60243f2.png)'
- en: 'This is the first migration to create a database. Whenever we add or update
    the model classes or configurations, we need to sync the database with the model
    using the `add-migration` and `update-database` commands. With this, we have our
    model class ready and the corresponding database created. The following image
    summarizes how the properties have been mapped from the C# class to the database
    table columns:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个迁移，用于创建数据库。每次我们添加或更新模型类或配置时，我们都需要使用 `add-migration` 和 `update-database`
    命令将数据库与模型同步。有了这个，我们就有了准备好的模型类和相应的数据库。以下图像总结了属性是如何从 C# 类映射到数据库表列的：
- en: '![](img/897622d5-4096-4df1-9e21-f5dc1cab8a04.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/897622d5-4096-4df1-9e21-f5dc1cab8a04.png)'
- en: Now, we will use the `Context` class to perform CRUD operations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `Context` 类来执行 CRUD 操作。
- en: 'Let''s go back to our `Main.cs` and write the following code. The code is well
    commented, so please go through the comments to understand the flow:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `Main.cs` 并编写以下代码。代码有很好的注释，所以请阅读注释以了解流程：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this, we have completed our sample app to get started with EF Core. I hope
    this simple example will set you up to start using EF Core with confidence and
    encourage you to start exploring it further. The detailed features of EF Core
    can be learned from the official Microsoft documentation available at[ https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/).
    Now that we have an understanding of EF Core, we are ready to use it in our movie
    booking app. Let's check out the requirements for the movie booking app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了我们的示例应用，以开始使用 EF Core。我希望这个简单的例子能让你有信心开始使用 EF Core，并鼓励你进一步探索它。EF
    Core 的详细功能可以从官方微软文档中学习，该文档可在[https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/)找到。现在我们已经了解了
    EF Core，我们准备在电影预订应用中使用它。让我们查看电影预订应用的需求。
- en: Movie booking app requirements
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电影预订应用需求
- en: In this section, we will discuss the requirements for developing our movie booking
    web app in ASP.NET Core 2.0\. To keep things simple and understandable, we will
    create a single-screen cinema hall and not a multiplex. The requirements for our
    sample movie booking app are as follows.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在 ASP.NET Core 2.0 中开发我们的电影预订网络应用的需求。为了使事情简单易懂，我们将创建一个单银幕电影院而不是多厅电影院。我们的示例电影预订应用的需求如下。
- en: 'As a user or a movie buff, I should be able to:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户或电影爱好者，我应该能够：
- en: See the list of movies showing in the cinema hall with timings
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看电影院正在放映的电影列表及时间表
- en: See the short description and star cast of the movie before booking
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预订之前查看电影的简短描述和主演阵容
- en: Select seats from the available seats
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用座位中选择座位
- en: Book the selected seats
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预订所选座位
- en: Optionally log in to the seat with Facebook/Google credentials or continue as
    a guest.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选使用 Facebook/Google 凭据登录到座位或以访客身份继续。
- en: 'Now that we have the requirement specifications in place, let''s see the activity
    flow of the app and come up with a flowchart. The following is the rough flowchart
    of the app workflow:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经制定了需求规范，让我们看看应用的活动流程，并制定一个流程图。以下是该应用工作流程的粗略流程图：
- en: '![](img/930aeded-ad9b-4930-8e75-1a8ac90dfaa0.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/930aeded-ad9b-4930-8e75-1a8ac90dfaa0.png)'
- en: 'Let''s discuss this flowchart in detail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这个流程图：
- en: '**Start**: This is the start of the flow. The user browses the movie booking
    app.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始**：这是流程的开始。用户浏览电影预订应用。'
- en: '**Now Showing Movie Listing**: The user can see the the list of movies with
    timings that are shown in the cinema hall.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现在上映电影列表**：用户可以看到电影院正在放映的电影列表及时间表。'
- en: '**Movie description**: The user can optionally check out the movie description
    by clicking on the selected movie in the list.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电影描述**：用户可以点击列表中选定的电影来可选地查看电影描述。'
- en: '**Select movie and show**: The user can select an available show.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择电影和放映**：用户可以选择一个可用的放映。'
- en: '**Choose Seat**: The user can choose a seat from the available seats for the
    chosen show.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择座位**：用户可以从所选放映的可用座位中选择座位。'
- en: '**Optional Login**: The user can optionally log in to the web app or continue
    as a guest.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可选登录**：用户可以选择登录到网络应用或以访客身份继续。'
- en: '**Finish**: We will not be implementing a payment interface, as we only intend
    to learn ASP.NET Core and EF Core. Upon choosing the seat and navigating ahead,
    we finish the flow.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完成**：我们不会实现支付界面，因为我们只想学习 ASP.NET Core 和 EF Core。在选择了座位并继续导航后，我们完成流程。'
- en: Now that we have an understanding of the requirements and a fair idea of what
    we wish to achieve, let's design the movie booking app.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了需求，并对我们希望实现的目标有了相当的了解，让我们设计电影预订应用。
- en: Designing the movie booking app
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计电影预订应用
- en: 'In this section, we will do a high-level design of our movie booking web app
    using ASP.NET Core 2.0\. The high-level design of the app is pretty simple, as
    shown in the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 ASP.NET Core 2.0 对我们的电影预订网络应用进行高级设计。应用的高级设计非常简单，如下面的图所示：
- en: '![](img/97ecfe77-cb6e-44b7-a385-ac870819e1af.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97ecfe77-cb6e-44b7-a385-ac870819e1af.png)'
- en: We can see that an **Online user** browses the **Movie Booking Web app**, which
    is an Azure web app. Ideally, there should be a service layer in between the **Movie
    Booking Web app** and the **Database**, to allow for a neat, extensible, modular,
    and layered architecture. However, for the purpose of learning, we will keep things
    simple and eliminate the service layer for now. The web app gets data and stores
    the data in the SQL Azure database. If you are worrying about the Azure web app
    or SQL Azure, stop doing so. We will develop the app locally development machine
    and deploy it in Azure, and at that time we will take care of the Azure web app
    and SQL Azure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个**在线用户**正在浏览**电影预订网页应用**，这是一个Azure网页应用。理想情况下，应该在**电影预订网页应用**和**数据库**之间有一个服务层，以便实现整洁、可扩展、模块化和分层架构。然而，为了学习的目的，我们将保持简单，并暂时消除服务层。网页应用从SQL
    Azure数据库获取数据并将数据存储在SQL Azure数据库中。如果你在担心Azure网页应用或SQL Azure，请停止这样做。我们将在本地开发机器上开发应用，并在Azure中部署它，那时我们将处理Azure网页应用和SQL
    Azure。
- en: 'Based on the requirements, we need to design the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需求，我们需要设计以下内容：
- en: A user interface of the movie booking web app.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电影预订网页应用的用户界面。
- en: A page to list all the movies currently being shown. We will need to design
    the database model to show the list of the movies currently being shown.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个页面用于列出目前正在上映的所有电影。我们需要设计数据库模型以显示目前正在上映的电影列表。
- en: A page to display the details of the selected movie.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个页面用于显示所选电影的详细信息。
- en: A page to display the available seats to choose from.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个页面用于显示可供选择的可用座位。
- en: A login/authentication module using Facebook or Gmail.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Facebook或Gmail的登录/身份验证模块。
- en: 'For *Steps 2* to *4*, we need to do database modeling. We will use SQL Express
    on Windows and use EF Core, which we discussed earlier. Let''s do the class design
    to fulfill the requirements and create the database following the code-first approach.
    A movie booking system is a complicated and time-consuming system to make. However,
    what we will make here is a very simple and limited version of a movie booking
    system, so that we can focus on learning fundamentals rather than on the design
    of the system. From the requirements, it is clear that we need to have a `Movie`
    class to contain the movie information and an `Auditorium` class where the movie
    will be shown. The information about which movie is being shown in the auditorium
    should be stored in a `Show` class. The auditorium has seats, so we will need
    a `Seat` class so that the user can choose a seat and book it using a `Booking`
    class to get a ticket through the `Ticket` class. It''s worth reiterating that
    this is a an over-simplistic design to enable an easy grasp of the system the
    actual system; may be more complex. The following diagram shows how our classes
    will be designed as per the preceding analysis:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*步骤2*到*步骤4*，我们需要进行数据库建模。我们将在Windows上使用SQL Express并使用EF Core，这是我们之前讨论过的。让我们进行类设计以满足要求，并按照代码优先的方法创建数据库。制作电影预订系统是一个复杂且耗时的系统。然而，我们在这里将制作一个非常简单且有限的版本的电影预订系统，这样我们就可以专注于学习基础知识，而不是系统的设计。从需求来看，很明显我们需要一个`Movie`类来包含电影信息，以及一个`Auditorium`类，电影将在其中上映。关于在礼堂上映的电影的信息应该存储在一个`Show`类中。礼堂有座位，因此我们需要一个`Seat`类，以便用户可以选择座位并使用`Booking`类通过`Ticket`类来预订座位并获得票。值得重申的是，这是一个过于简化的设计，以便更容易理解系统；实际系统可能更复杂。以下图表显示了根据前面的分析，我们的类将如何设计：
- en: '![](img/731a4066-a800-4215-b694-17ab4db637cc.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/731a4066-a800-4215-b694-17ab4db637cc.png)'
- en: Since we are using EF Core, our database model will be a replica of these classes,
    as we saw in the earlier section on getting started with EF Core. Once we are
    done with these, we will have to develop a simple application that will just do
    CRUD operations. Now that we have a high-level architecture and class diagrams
    in place, let's start the coding of the web app.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用EF Core，我们的数据库模型将是这些类的复制品，正如我们在之前关于EF Core入门部分的讨论中看到的。完成这些后，我们将必须开发一个简单的应用程序，它将仅执行CRUD操作。现在我们已经有了高级架构和类图，让我们开始编写网页应用的代码。
- en: Coding the movie booking app
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写电影预订应用代码
- en: 'In this section, we will code the movie booking app, according to the requirements
    and design we put together in the preceding sections. We will be using the EF
    Core code-first approach with SQL Express. To make the coding easy to understand,
    we will code in a step-by-step manner. The steps are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据前几节中整理的要求和设计编写电影预订应用程序的代码。我们将使用EF Core的代码优先方法与SQL Express结合使用。为了使编码易于理解，我们将分步骤进行编码。步骤如下：
- en: Create a new ASP.NET Core 2.0 MVC app named `MovieBooking`, as we did in the
    *Creating a simple running code* section of [Chapter 1](ch01.html), *Getting Started*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的ASP.NET Core 2.0 MVC应用程序，命名为`MovieBooking`，就像我们在[第1章](ch01.html)，“入门”的“创建简单运行代码”部分中所做的那样。
- en: 'If you wish to add authentication in your web app, you can click on the Change
    Authentication button at the time of selecting the template, as shown in the following
    screenshot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在你的Web应用程序中添加身份验证，你可以在选择模板时点击“更改身份验证”按钮，如图下所示：
- en: '![](img/76ff1b1c-02f3-4add-bb9b-7700825780fc.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76ff1b1c-02f3-4add-bb9b-7700825780fc.png)'
- en: A new dialog will display, as shown in the following screenshot, which will
    offer multiple authentication options to us, as we discussed in [Chapter 3](ch03.html),
    *Building Our First .NET Core Game – Tic-Tac-Toe*. To keep things simple, you
    can select Individual User Accounts and then choose Store user accounts in-app.
    This will do all the boilerplate code needed to enable the app-level user registration,
    sign-in, and sign-out functionality. Since we have already seen how to use OpenID
    Connect using the Facebook authentication provider in the Let's Chat web application,
    we will not go deep into this part and we encourage the reader to reuse the same
    code and explore and extend it further.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个新对话框，如图下所示，它将为我们提供多种身份验证选项，正如我们在[第3章](ch03.html)，“构建我们的第一个.NET Core游戏——井字棋”中讨论的那样。为了保持简单，你可以选择“个人用户账户”，然后选择“在应用程序中存储用户账户”。这将完成所有必要的样板代码，以启用应用程序级别的用户注册、登录和注销功能。由于我们已经在“Let's
    Chat”Web应用程序中看到了如何使用OpenID Connect和Facebook身份验证提供者，我们将不会深入这部分内容，并鼓励读者重用相同的代码并进一步探索和扩展。
- en: '![](img/3d191f83-e423-46ff-8855-36168eb41901.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d191f83-e423-46ff-8855-36168eb41901.png)'
- en: Next, we will add the `Models` folder in the project and add the classes for
    `Auditorium`, `Movie`, `Show`, `Seat`, `Booking`, and `Ticket` that we designed
    in the preceding section.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在项目中添加`Models`文件夹，并添加前几节中设计的`Auditorium`（礼堂）、`Movie`（电影）、`Show`（放映）、`Seat`（座位）、`Booking`（预订）和`Ticket`（票）类。
- en: 'The code for the classes is listed next. Since the properties are self-explanatory
    by virtue of their naming, comments are not explicitly added, to maintain brevity:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的代码列表如下。由于属性名称本身就具有自解释性，因此没有添加显式的注释，以保持简洁：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, the models are ready.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，模型就准备好了。
- en: Next, we need to install EF Core packages to make use of all the EF Core benefits,
    so let's install the `Microsoft.EntityFrameworkCore.SqlServer` and `Microsoft.EntityFrameworkCore.Design` NuGet
    packages in our project from the NuGet Package Manager. We have already done this
    while making the `GettingStartedWithEFCore` app.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装EF Core包以利用所有EF Core的好处，因此让我们从NuGet包管理器中在我们的项目中安装`Microsoft.EntityFrameworkCore.SqlServer`和`Microsoft.EntityFrameworkCore.Design`NuGet包。我们已经在创建`GettingStartedWithEFCore`应用程序时完成了这项工作。
- en: 'Now, we need to create the context class to create the database based on this
    model. We will create the model named `MovieBookingContext`, as shown in the following
    code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建上下文类，根据此模型创建数据库。我们将创建名为`MovieBookingContext`的模型，如图下代码所示：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that `MovieBookingContext` doesn''t have the `OnConfiguring` method
    call that we used to configure the SQL database in our last EF Core sample. This
    is to show a different way of configuring the database. We will read the connection
    string from the `appsettings.json` configuration file, which has the following
    configuration entry:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`MovieBookingContext`没有我们之前在最后一个EF Core示例中用来配置SQL数据库的`OnConfiguring`方法调用。这是为了展示配置数据库的不同方法。我们将从`appsettings.json`配置文件中读取连接字符串，该配置文件具有以下配置条目：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will configure the database through the context by reading the configuration
    in the `ConfigureServices` method of `Startup.cs`, as shown in the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过上下文配置数据库，通过在`Startup.cs`的`ConfigureServices`方法中读取配置，如图下代码所示：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After developing the context, we need to create the database. To do so, we
    we need to run the following commands in order. The first command will add the
    migration and the second command will actually create the database:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发上下文之后，我们需要创建数据库。为此，我们需要按以下顺序运行以下命令。第一个命令将添加迁移，第二个命令将实际创建数据库：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have the database, but we do not have the necessary data in the tables
    to list the movie information. To do so, we can either write a script, a small
    EF Core-based program, or enter it manually in the table. Since this is SQL stuff,
    we will not go into great detail, but an aware reader should be able to insert
    this data in the corresponding tables correctly.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了数据库，但在表中还没有必要的数据来列出电影信息。为此，我们可以编写一个脚本，一个基于 EF Core 的小程序，或者手动输入到表中。由于这是
    SQL 的事情，我们不会深入细节，但一个有意识的读者应该能够正确地将这些数据插入到相应的表中。
- en: 'Next, we need to create controllers and views for the screens and wire up the
    data access layer. At the outset, the user should be able to see the list of shows
    in the home screen, so we will develop the home screen first. To do so, we will
    reuse the `Index` action of `HomeController.cs` as it is and modify the `Index`
    view to display the user interface, as shown in the following screenshot:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为屏幕创建控制器和视图，并将数据访问层连接起来。一开始，用户应该能够在主页面上看到放映列表，因此我们将首先开发主页。为此，我们将重用 `HomeController.cs`
    中的 `Index` 动作，并修改 `Index` 视图以显示用户界面，如下面的截图所示：
- en: '![](img/f0f66a26-3414-4da4-85fa-b82dc1db8889.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0f66a26-3414-4da4-85fa-b82dc1db8889.png)'
- en: There is nothing fancy here. The user interface has an image carousel, which
    displays the posters of the movies and the quick booking section, which lists
    the movies and show times. Just replace the URLs of the default carousel (which
    comes out of the box in the default template) with the image URLs of movie posters
    by searching them online through Bing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处。用户界面有一个图片轮播，显示电影的宣传海报，以及快速预订部分，列出电影和放映时间。只需将默认轮播的 URL（默认模板中自带）替换为在线通过
    Bing 搜索到的电影海报的图片 URL。
- en: To show the list of movies, we need an API returning the list of movies called
    as `GetMovies` API. Recall that we have added the movie data in the database already,
    so we have movies to be fetched. On selecting a movie, we need to fetch the available
    show times for the movie, so we need another API to fetch the show time based
    on the movie called `GetShowTimesForMovie` API. We have seen how to create APIs
    using the `Context` object in the *Getting started with Entity Framework Core* section.
    We then wire up the APIs to the controller to populate data in the view.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示电影列表，我们需要一个名为 `GetMovies` API 的 API 来返回电影列表。回想一下，我们已经将电影数据添加到数据库中，因此我们有要检索的电影。在选择电影后，我们需要检索该电影的可用放映时间，因此我们需要另一个名为
    `GetShowTimesForMovie` API 的 API 来根据电影检索放映时间。我们在 *使用 Entity Framework Core 入门*
    部分中看到了如何使用 `Context` 对象创建 API。然后我们将 API 连接到控制器以填充视图中的数据。
- en: On clicking the Book button, the user is navigated to the seat selection page.
    To display the seats, we again need an API to get the available seats for a show
    named `GetAvailableSeatsForShow` API.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击预订按钮后，用户将被导航到座位选择页面。要显示座位，我们再次需要一个名为 `GetAvailableSeatsForShow` API 的 API
    来获取放映的可用座位。
- en: On clicking a movie, we can view the selected movie details. The data for this
    comes through the `GetMovieDetails` API.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击电影后，我们可以查看所选电影详情。这些数据通过 `GetMovieDetails` API 获取。
- en: Similarly, the UI and corresponding APIs are developed, as now it's just a simple
    app, that fetches the data from the database and displays it in the user interface.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，UI 和相应的 API 都已开发，因为现在它只是一个简单的应用，从数据库中获取数据并在用户界面中显示。
- en: The complete source code can be seen at [https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example),
    which lists all the APIs and the view code that we discussed previously. It also
    has a script, that can be executed to insert the sample data into the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在 [https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example)
    上看到，其中列出了我们之前讨论的所有 API 和视图代码。它还有一个脚本，可以执行以将示例数据插入到应用程序中。
- en: We will next look at deploying this app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将看看如何部署这个应用。
- en: Deploying the movie booking app
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署电影预订应用
- en: 'We have already deployed one of our sample web apps in Azure and this is no
    different. The assumption here is that the reader already has an Azure subscription
    and is logged in with the email ID used for the subscription. If this is not the
    case, please go through the previous chapters where we have discussed Azure subscription
    at length. Let''s have a look at steps to deploy our movie booking app on the
    cloud:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Azure上部署了我们的一个示例Web应用，这并没有什么不同。这里的假设是读者已经拥有Azure订阅并且使用订阅的电子邮件ID登录。如果不是这种情况，请参阅前面的章节，我们在那里详细讨论了Azure订阅。让我们看看在云上部署我们的电影预订应用的步骤：
- en: In the Visual Studio Solution Explorer window, right-click on the `MovieBooking`
    project and then click Publish. It will open a Publish dialog.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio解决方案资源管理器窗口中，右键单击“MovieBooking”项目，然后点击“发布”。它将打开一个发布对话框。
- en: 'Select Create New and then click OK. It will open the Create App Service dialog.
    Enter the required fields, as shown in the following screenshot:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建新”然后点击“确定”。它将打开创建应用服务对话框。输入所需的字段，如下面的截图所示：
- en: '![](img/13ff8b9c-0e4b-4d90-a1f6-9f57f96447d8.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13ff8b9c-0e4b-4d90-a1f6-9f57f96447d8.png)'
- en: 'After filling in all the required input, click on Services on the left panel.
    It will display the following dialog:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在填写所有必要的输入后，点击左侧面板上的“服务”。它将显示以下对话框：
- en: '![](img/bc5bb555-6f17-48ef-a20e-f53e94187209.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc5bb555-6f17-48ef-a20e-f53e94187209.png)'
- en: 'We need a database for our app to function and the dialog shows the SQL Database
    as the additional Azure resource that we need to deploy. Click on the + icon on
    the right-hand side. It will open a new dialog Configure SQL Database, as shown
    in the following screenshot:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用需要数据库才能运行，对话框显示了SQL数据库作为我们需要部署的附加Azure资源。点击右侧的加号图标。它将打开一个新的对话框“配置SQL数据库”，如下面的截图所示：
- en: '![](img/26ae03e3-88c9-4c55-9713-2c834700654b.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26ae03e3-88c9-4c55-9713-2c834700654b.png)'
- en: Enter the required details. Make a note of the username and password as well
    as the database name and connection string name, as these will be used in the
    code. Click OK and then click Create. This will create the publish profile and
    deploy the app.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入所需的详细信息。注意用户名和密码以及数据库名和连接字符串名称，因为它们将在代码中使用。点击“确定”然后点击“创建”。这将创建发布配置文件并部署应用。
- en: 'However, we need to ensure that our database gets created, our intended connection
    string is used, and migrations are applied. To do so, in the Publish window, click
    on the Settings link, as shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们需要确保我们的数据库被创建，我们预期的连接字符串被使用，并且迁移被应用。为此，在发布窗口中，点击设置链接，如下面的截图所示：
- en: '![](img/1cf37f5d-47f9-4ad8-af3e-abc60e26fc78.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cf37f5d-47f9-4ad8-af3e-abc60e26fc78.png)'
- en: 'The Publish dialog will open. On the Settings tab, ensure that for DefaultConnection,
    under the Databases section, the Use this connection string at runtime checkbox
    is checked, as shown in the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布对话框将会打开。在设置选项卡中，确保在数据库部分下的默认连接中，运行时使用此连接字符串的复选框被勾选，如下面的截图所示：
- en: '![](img/7edf2b7b-7c35-4751-a62f-9460078bc74e.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7edf2b7b-7c35-4751-a62f-9460078bc74e.png)'
- en: If you deploy for the first time, you may also see Entity Framework Migrations,
    just like the Databases section shown in the preceding screenshot. If so, please
    check Apply this migration on publish. Since I have already applied the migrations,
    I don't have it in in preceding screenshot.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您是第一次部署，您也可能看到“Entity Framework迁移”，就像前面截图中的数据库部分所示。如果是这样，请检查“发布时应用此迁移”。由于我已经应用了迁移，所以它没有在前面的截图中出现。
- en: Click Save and then click Publish. This will publish the web app as well as
    the database and migrations.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“保存”然后点击“发布”。这将发布Web应用以及数据库和迁移。
- en: With this, our web app is deployed and after successful deployment, the app
    will automatically be launched in the browser. The sample app can be seen at [http://packtmoviebookingapp.azurewebsites.net/](http://packtmoviebookingapp.azurewebsites.net/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的Web应用已经部署，并且在成功部署后，应用将自动在浏览器中启动。示例应用可以在[http://packtmoviebookingapp.azurewebsites.net/](http://packtmoviebookingapp.azurewebsites.net/)查看。
- en: Monitoring the movie booking app
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控电影预订应用
- en: Coding and deploying an app is fine, but it's equally important to ensure that
    the app keeps running fine once it's deployed in production and end users start
    using it. So monitoring an app is quite important. In this section, we will learn
    to add Application Insights in our web app and also touch upon various out-of-the
    box monitoring options provided by Azure. We will start with Application Insights.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 编码和部署一个应用程序是可以的，但同样重要的是确保应用程序在生产环境中部署并最终用户开始使用后仍然运行良好。因此，监控应用程序非常重要。在本节中，我们将学习如何在我们的Web应用程序中添加Application
    Insights，并简要介绍Azure提供的各种开箱即用的监控选项。我们将从Application Insights开始。
- en: Application Insights
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Application Insights
- en: 'Application Insights is an extensible **Application Performance Management**
    (**APM**) service for web developers on multiple platforms to monitor web applications
    for performance, usability, and availability. It automatically detects performance
    issues. It includes powerful analytics tools to help us diagnose issues and to
    understand what users actually do with our app. How cool is that? We can find
    out about the most and least used features of our web app using Application Insights.
    We can use the actionable insights from Application Insights to continuously improve
    the performance and usability of the app. I have personally found Application
    Insights very useful in diagnosing and fixing performance issues. This is a proactive
    way of identifying the issue, rather than waiting for the end user to experience
    an issue and then reporting it. Let''s start with enabling Application Insights
    in our movie booking web app. To do so, we need to do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Application Insights是一个可扩展的**应用性能管理（APM**）服务，适用于多个平台上的Web开发者，用于监控Web应用程序的性能、可用性和用户体验。它自动检测性能问题。它包括强大的分析工具，帮助我们诊断问题并了解用户实际上是如何使用我们的应用程序的。这有多酷？我们可以使用Application
    Insights找到我们Web应用程序中最常用和最不常用的功能。我们可以使用Application Insights的可操作见解来持续改进应用程序的性能和可用性。我个人发现Application
    Insights在诊断和修复性能问题时非常有用。这是一种主动识别问题的方法，而不是等待最终用户遇到问题并报告它。让我们从在我们的电影预订Web应用程序中启用Application
    Insights开始。为此，我们需要执行以下操作：
- en: 'In Visual Studio 2017 Solution Explorer, expand the `MovieBooking` project
    and click on Connected Services. This will display the Connected Services page,
    as shown in the following screenshot:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2017的Solution Explorer中，展开`MovieBooking`项目并点击Connected Services。这将显示Connected
    Services页面，如下面的截图所示：
- en: '![](img/4681682e-ae87-4bc9-ba98-0f1ba9f23f1b.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4681682e-ae87-4bc9-ba98-0f1ba9f23f1b.png)'
- en: 'Click on Monitoring with Application Insights. This will open the Application
    Insights configuration screen, as shown in the following screenshot:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“使用Application Insights进行监控”。这将打开Application Insights配置屏幕，如下面的截图所示：
- en: '![](img/0222fc40-c975-49c2-a38d-d822610e96db.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0222fc40-c975-49c2-a38d-d822610e96db.png)'
- en: 'This same screen can be reached by right-clicking on the `MovieBooking` project
    in Solution Explorer and then clicking Add | Application Insights Telemetry, as
    shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的屏幕可以通过在Solution Explorer中右键单击`MovieBooking`项目然后点击“添加 | Application Insights遥测”来访问，如下面的截图所示：
- en: '![](img/9e32d207-0007-44d7-8222-8be27f93367e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e32d207-0007-44d7-8222-8be27f93367e.png)'
- en: 'Click on the Start Free button. This will take us to the registration screen,
    shown in the following screenshot. Choose the Subscription and Resource based
    on your requirements. Here, I have created a new resource but you may want to
    reuse an existing resource. We will go with the free variant, so choose the option
    in which Application Insights will remain free and halt data collection after
    the quota of 1 GB / Month is exhausted:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“开始免费”按钮。这将带我们到注册屏幕，如下面的截图所示。根据您的需求选择订阅和资源。在这里，我创建了一个新的资源，但您可能希望重用现有的资源。我们将选择免费版本，因此请选择Application
    Insights将保持免费且在每月1GB配额耗尽后停止数据收集的选项：
- en: '![](img/7efba094-9332-4890-beb9-7b22f357900c.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7efba094-9332-4890-beb9-7b22f357900c.png)'
- en: 'Click on Register. This may take a while and hence show a progress bar, shown
    in the following screenshot. Look at the screenshot and we can see how powerful
    Application Insights is. It has Smart Detection, App Map, Analytics, and CodeLens,
    among other great features:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“注册”。这可能需要一段时间，因此会显示进度条，如下面的截图所示。查看截图，我们可以看到Application Insights有多强大。它具有智能检测、应用地图、分析和CodeLens等众多优秀功能：
- en: '![](img/92992cb8-e8c8-4c5d-aed7-342110055388.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92992cb8-e8c8-4c5d-aed7-342110055388.png)'
- en: 'Once the configuration is done, the progress bar will disappear. Application
    Insights telemetry should now be enabled in the selected project. The configuration
    will add the instrumentation key in `appsettings.json` as well and so, after successfully
    enabling Application Insights, you may get a prompt that the file has been modified.
    This is fine and expected, so click OK:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成配置，进度条将消失。Application Insights 遥测现在应在所选项目中启用。配置将添加仪器密钥到 `appsettings.json`，因此，在成功启用
    Application Insights 后，您可能会收到文件已修改的提示。这是正常的，也是预期的，所以请点击“确定”：
- en: '![](img/fb6c148e-0080-4300-b593-542a5f24e119.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb6c148e-0080-4300-b593-542a5f24e119.png)'
- en: We are now ready to monitor the web app after publishing it to remain in sync
    with the instrumentation key changes and Application Insight SDK changes that
    we have just done. With this, we are done with setting up Application Insights.
    Now, we will see how we can monitor the web app and leverage the benefits of Application
    Insights. We can see the telemetry data of our local debugging setup in Visual
    Studio itself, while the Azure portal is where we can see the insights of our
    deployed application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在发布网站后进行监控，以保持与仪器密钥更改和应用洞察 SDK 更改同步。有了这个，我们就完成了 Application Insights
    的设置。现在，我们将看看如何监控网站应用程序并利用 Application Insights 的优势。我们可以在 Visual Studio 本身中查看我们本地调试设置的遥测数据，而
    Azure 门户是我们可以看到已部署应用程序洞察的地方。
- en: 'In the Visual Studio Solution Explorer, we will now have the `Application Insights`
    folder inside Connected Services for our movie booking project, as shown in the
    following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 解决方案资源管理器中，我们现在将在连接服务中为我们的电影预订项目有一个“Application Insights”文件夹，如下面的截图所示：
- en: '![](img/07a76aa4-a605-46cb-a5fd-70842687218f.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07a76aa4-a605-46cb-a5fd-70842687218f.png)'
- en: 'Right-click on the Application Insights folder and we will get a number of
    options. A few of the important ones are shown in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击“Application Insights”文件夹，我们将获得许多选项。以下截图显示了其中一些重要的选项：
- en: '![](img/1c8b7ec0-0542-4d8d-b399-f1b7e8e72307.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c8b7ec0-0542-4d8d-b399-f1b7e8e72307.png)'
- en: 'Here are the explanations of these options:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对这些选项的解释：
- en: 'Open Application Insights Portal: This will directly open Application Insights
    in the Azure web portal.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开 Application Insights 门户：这将直接在 Azure 网站门户中打开 Application Insights。
- en: 'Application Analytics: This will open the application analytics portal, where
    we can perform detailed analytics and filtering of data.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序分析：这将打开应用程序分析门户，在那里我们可以执行详细的数据分析和筛选。
- en: 'Application Map: This will open the application map for the project in the
    Azure portal. The application map helps us to spot performance bottlenecks or
    failure hotspots across all components of the distributed application.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序映射：这将打开 Azure 门户中项目的应用程序映射。应用程序映射帮助我们识别分布式应用程序所有组件中的性能瓶颈或故障热点。
- en: 'Configure Application Insights: This can be used to configure Application Insights.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Application Insights：这可以用来配置 Application Insights。
- en: 'Choose Telemetry Source: This configures the app that will be used as the telemetry
    source. By default, the current web app will be the telemetry source.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择遥测源：这将配置用作遥测源的应用程序。默认情况下，当前网站应用程序将是遥测源。
- en: 'Search Live Telemetry: This searches the data in the telemetry from Visual
    Studio or in the Azure web portal. Using this, we can also see debug telemetry
    data from the Visual Studio debugging.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索实时遥测：这将搜索来自 Visual Studio 或 Azure 网站门户的遥测数据。使用此功能，我们还可以查看 Visual Studio 调试中的调试遥测数据。
- en: 'To conclude this discussion, let us see the Application Insights data that
    was collected while I wrote this section. The following screenshot shows what
    it looks like for the movie booking app that we developed:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这次讨论，让我们看看我在编写这一部分时收集到的 Application Insights 数据。以下截图显示了我们所开发的电影预订应用程序的外观：
- en: '![](img/9d1a814a-402e-47a4-a5f0-bcf70a63cd92.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d1a814a-402e-47a4-a5f0-bcf70a63cd92.png)'
- en: Application Insights is a huge topic and one section of a chapter doesn't do
    justice to this great and important feature. For a thorough and detailed coverage
    Application Insights, I would highly recommend readers to read the wonderful documentation
    on Application Insights at [https://docs.microsoft.com/en-us/azure/application-insights/](https://docs.microsoft.com/en-us/azure/application-insights/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Application Insights 是一个庞大的主题，一个章节的部分内容并不能公正地体现这一伟大且重要的功能。为了全面详细地了解 Application
    Insights，我强烈建议读者阅读 Application Insights 的出色文档，请参阅[https://docs.microsoft.com/en-us/azure/application-insights/](https://docs.microsoft.com/en-us/azure/application-insights/)。
- en: In this section, we have looked at Application Insights, which is a great monitoring
    tool in the developer's repertoire. However, Azure has much more to offer in terms
    of monitoring options and we will explore these in the next chapter, where I will
    also discuss how to use Application Insights telemetry data to investigate issues.
    With this note, we conclude this chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Application Insights，这是开发者工具箱中一款出色的监控工具。然而，Azure 在监控选项方面还有更多可以提供的内容，我们将在下一章中探讨这些内容，同时我也会讨论如何使用
    Application Insights 的遥测数据来调查问题。带着这个提示，我们结束了本章。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Entity Framework and Entity Framework Core,
    and understood the features of each and the differences between the two. We also
    learned that we should use EF Core only if EF cannot be used or there is a pressing
    cross-platform requirement to use EF Core. We learned how to do CRUD operations
    using EF Core by creating a simple app. We then developed a simple movie booking
    app and learned how to deploy it using Visual Studio. We also saw how we can monitor
    our web app by enabling Application Insights. So far, we have only seen monolithic
    apps where all the APIs reside in one web app. If that one web app goes down,
    our entire app can come to a standstill. There is a way to circumvent this by
    deploying the app in smaller, independent modules, called microservices. In the
    next chapter, we will explore microservices.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Entity Framework 和 Entity Framework Core，并了解了它们各自的特点以及两者之间的区别。我们还了解到，只有在
    EF 无法使用或存在迫切的跨平台需求使用 EF Core 时，我们才应该使用 EF Core。通过创建一个简单的应用程序，我们学习了如何使用 EF Core
    进行 CRUD 操作。然后，我们开发了一个简单的电影预订应用程序，并学习了如何使用 Visual Studio 部署它。我们还看到了如何通过启用 Application
    Insights 来监控我们的 Web 应用程序。到目前为止，我们只看到了单体应用程序，其中所有 API 都驻留在单个 Web 应用程序中。如果这个 Web
    应用程序出现问题，我们的整个应用程序可能会完全停止运行。有一种方法可以通过部署更小、独立的模块（称为微服务）来规避这个问题。在下一章中，我们将探讨微服务。
