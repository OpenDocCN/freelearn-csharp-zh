<html><head></head><body>
<div id="_idContainer086">
<h1 class="chapter-number" id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.2.1">Object-Oriented Refactoring</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the last chapter, we saw how refactoring can help improve classes and their methods. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we’ll explore the bigger picture with creative uses of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">OOP</span></strong><span class="koboSpan" id="kobo.7.1">) to refactor </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.8.1">a series of classes into more maintainable forms. </span><span class="koboSpan" id="kobo.8.2">These tools will help you perform larger and more impactful refactorings and make a bigger difference in improving </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">We’ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Organizing classes </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">via refactoring</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and inheritance</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Controlling inheritance </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">with abstract</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Refactoring for </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">better encapsulation</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Improving classes with interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and polymorphism</span></span></li>
</ul>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">The starting code for this chapter is available from GitHub at </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.25.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">Chapter05/Ch5BeginningCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1"> folder.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.28.1">Refactoring the flight search system</span></h1>
<p><span class="koboSpan" id="kobo.29.1">This chapter’s </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.30.1">code focuses on a flight scheduling system for Cloudy </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Skies Airlines.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The flight scheduling system</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.33.1"> is a simple one that tracks all active flights through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.35.1"> class and allows external callers to search for flights of interest. </span><span class="koboSpan" id="kobo.35.2">This class in turn tracks flights through a collection of </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.37.1"> instances, which may either be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.39.1"> or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">FreightFlightInfo</span></strong><span class="koboSpan" id="kobo.41.1"> instance, depending on whether the flight carries passenger </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">or freight.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">The high-level interactions of these classes can be seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.45.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.47.1"><img alt="Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling system" src="image/B21324_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.48.1">Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling system</span></p>
<p><span class="koboSpan" id="kobo.49.1">The code currently </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.50.1">works and even uses</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.51.1"> polymorphism effectively to track a variety of different flights. </span><span class="koboSpan" id="kobo.51.2">That being said, there are some opportunities for improvement, as we’ll see. </span><span class="koboSpan" id="kobo.51.3">Throughout this chapter, we’ll make targeted improvements while demonstrating the breadth of refactoring possibilities present when using </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">object-oriented programming.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.53.1">Organizing classes via refactoring</span></h1>
<p><span class="koboSpan" id="kobo.54.1">It’s not </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.55.1">uncommon for solutions to have organizational challenges such as misnamed files or types existing in the wrong file </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">or namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">These problems may seem small, but they can make it harder for developers to find the code they’re looking for – particularly when first joining </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s look at a few refactorings that help developers navigate code </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">more easily.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.61.1">Moving classes to individual files</span></h2>
<p><span class="koboSpan" id="kobo.62.1">One common</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.63.1"> mistake I’ve seen teams make is putting multiple types inside of the same file. </span><span class="koboSpan" id="kobo.63.2">Usually, a file starts with a single class or interface and then a developer decides to add a related type. </span><span class="koboSpan" id="kobo.63.3">Instead of putting the new type in a file of its own, the class gets added to the existing file. </span><span class="koboSpan" id="kobo.63.4">Once this happens for a few small classes, it tends to snowball after that with developers continuing to add new types to the file as time </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">goes on.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.65.1">Types</span></p>
<p class="callout"><span class="koboSpan" id="kobo.66.1">If you’re not familiar with the use of the word “type” in the .NET world, a type is a generic term that refers to anything supported by </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.67.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">common type system </span></strong><span class="koboSpan" id="kobo.69.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.70.1">CTS</span></strong><span class="koboSpan" id="kobo.71.1">). </span><span class="koboSpan" id="kobo.71.2">Essentially, if you can use it to declare a variable, it’s probably a type. </span><span class="koboSpan" id="kobo.71.3">Some examples of types include classes, interfaces, structs, enums, and the various record </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">type variants.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">IFlightInfo.cs</span></strong><span class="koboSpan" id="kobo.75.1"> file from the Flight Scheduling System has a few different types defined </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">in it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.77.1">
public interface </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.79.1"> {
  // Details omitted....
</span><span class="koboSpan" id="kobo.79.2">}
public class </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.81.1"> : IFlightInfo {
  // Details omitted...
</span><span class="koboSpan" id="kobo.81.2">}
public class </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">FreightFlightInfo</span></strong><span class="koboSpan" id="kobo.83.1"> : IFlightInfo {
  // Details omitted...
</span><span class="koboSpan" id="kobo.83.2">}</span></pre>
<p><span class="koboSpan" id="kobo.84.1">While this </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.85.1">example might not seem so bad, having multiple types in a single file does cause a </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">few problems:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.87.1">New developers who are looking for a specific type have trouble finding which file contains that type without using </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">search features.</span></span></li>
<li><span class="koboSpan" id="kobo.89.1">Version control systems, such as git, track changes to each file. </span><span class="koboSpan" id="kobo.89.2">This can increase confusion when teams must merge code or even determine what changed in any given </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">software release.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.91.1">The fix for this is to move each type to its own dedicated file. </span><span class="koboSpan" id="kobo.91.2">This can be done by going to the </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.93.1"> menu on a type whose name doesn’t match the file name. </span><span class="koboSpan" id="kobo.93.2">Next, select the </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Move type to [new file name].cs</span></strong><span class="koboSpan" id="kobo.95.1"> option as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.96.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.97.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.99.1"><img alt="Figure 5.2 – Moving a type to its own file" src="image/B21324_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.100.1">Figure 5.2 – Moving a type to its own file</span></p>
<p><span class="koboSpan" id="kobo.101.1">Selecting this option removes the type from the original file and creates a new file containing only the type </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">you selected.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">You’ll need </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.104.1">to repeat this for every type that doesn’t match the name of the file in Visual Studio. </span><span class="koboSpan" id="kobo.104.2">One of the extra refactoring tools that ReSharper and Rider provide allows you to perform this refactoring for every type in the file, folder, or solution. </span><span class="koboSpan" id="kobo.104.3">This can be particularly handy if you encounter a single file with hundreds of types </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">in it.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.106.1">Renaming files and classes</span></h2>
<p><span class="koboSpan" id="kobo.107.1">Occasionally, you’ll</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.108.1"> find cases where a file and the type that it contains don’t match. </span><span class="koboSpan" id="kobo.108.2">This often happens when developers create a new class and then decide to rename it later without using the rename refactoring built into </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">Visual Studio.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">AirportInfo.cs</span></strong><span class="koboSpan" id="kobo.112.1"> file and its </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Airport</span></strong><span class="koboSpan" id="kobo.114.1"> class are an example </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">of this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
namespace Packt.CloudySkiesAir.Chapter5.AirTravel;
public class </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Airport</span></strong><span class="koboSpan" id="kobo.118.1"> {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.119.1">Usually, the fix for this is to rename the file to match the name of the type (though occasionally you’ll determine the file was named correctly) and the class should be renamed to match the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">With either option, open the </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.123.1"> menu on the type in question and select either </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Rename file</span></strong><span class="koboSpan" id="kobo.125.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Rename type</span></strong><span class="koboSpan" id="kobo.127.1"> to ensure the file and type name match. </span><span class="koboSpan" id="kobo.127.2">See the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.129.1"><img alt="Figure 5.3 – Options to rename the file or rename the type" src="image/B21324_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Figure 5.3 – Options to rename the file or rename the type</span></p>
<p><span class="koboSpan" id="kobo.131.1">I chose to</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.132.1"> rename the file to </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">Airport.cs</span></strong><span class="koboSpan" id="kobo.134.1">, as either option will ensure that the file and type have the same name. </span><span class="koboSpan" id="kobo.134.2">This naming consistency is a small improvement, but it helps developers navigate your project more easily </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">over time.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.136.1">Changing namespaces</span></h2>
<p><span class="koboSpan" id="kobo.137.1">.NET uses </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">namespaces</span></strong><span class="koboSpan" id="kobo.139.1"> to </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.140.1">organize</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.141.1"> types into a hierarchical structure. </span><span class="koboSpan" id="kobo.141.2">By convention, these namespaces should match the folders inside the project in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.142.1">Solution Explorer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">The project will start with a namespace such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Packt.CloudySkiesAir.Chapter5</span></strong><span class="koboSpan" id="kobo.146.1">, and each folder nested inside of a project adds to this namespace. </span><span class="koboSpan" id="kobo.146.2">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Filters</span></strong><span class="koboSpan" id="kobo.148.1"> folder in that project should use a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Packt.CloudySkiesAir.Chapter5.Filters</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1"> namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">When classes don’t use the expected namespace, it can lead </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">to confusion.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">As a practical example, let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Airport.cs</span></strong><span class="koboSpan" id="kobo.155.1"> file in the root of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Chapter5</span></strong><span class="koboSpan" id="kobo.157.1"> project as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.158.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.159.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 5.4 – A project with the Airport class directly nested inside of the project" src="image/B21324_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 5.4 – A project with the Airport class directly nested inside of the project</span></p>
<p><span class="koboSpan" id="kobo.163.1">In this scenario, you would expect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Airport</span></strong><span class="koboSpan" id="kobo.165.1"> class to live in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Packt.CloudySkiesAir.Chapter5</span></strong><span class="koboSpan" id="kobo.167.1"> namespace. </span><span class="koboSpan" id="kobo.167.2">However, the file uses a different </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.168.1">namespace, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.170.1">namespace Packt.CloudySkiesAir.Chapter5.AirTravel;</span></strong><span class="koboSpan" id="kobo.171.1">
public class Airport {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.172.1">This discrepancy can be fixed through manual editing of the namespace declaration or by using the </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">Change namespace to match folder structure</span></strong><span class="koboSpan" id="kobo.174.1"> under </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Quick Action</span></strong><span class="koboSpan" id="kobo.176.1"> refactoring, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.177.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.180.1"><img alt="Figure 5.5 – Changing the namespace to match the folder structure" src="image/B21324_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">Figure 5.5 – Changing the namespace to match the folder structure</span></p>
<p><span class="koboSpan" id="kobo.182.1">I personally recommend using the </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.184.1"> refactoring instead of typing the new namespace name manually. </span><span class="koboSpan" id="kobo.184.2">When you do this, you’re less likely to make a typo. </span><span class="koboSpan" id="kobo.184.3">Additionally, the</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.185.1"> refactoring will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">using</span></strong><span class="koboSpan" id="kobo.187.1"> statements to other files as needed to support the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">namespace change.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.189.1">Avoiding partial classes and regions</span></h2>
<p><span class="koboSpan" id="kobo.190.1">Before we </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.191.1">move on to refactoring and inheritance, I want to cover two related </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">anti-patterns</span></strong><span class="koboSpan" id="kobo.193.1"> I’ve seen</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.194.1"> in C# code when dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">large classes.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">When developers have large classes with many different blocks of related code, there’s a temptation to use several language features to make organizing the </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">file easier.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Many developers use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">#region</span></strong><span class="koboSpan" id="kobo.200.1"> preprocessor directive to create regions of code that can expand </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">and collapse.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">For example, you could use a statement such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">#region Stuff I don't want to look at right now</span></strong><span class="koboSpan" id="kobo.204.1"> with a matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">#endregion</span></strong><span class="koboSpan" id="kobo.206.1"> statement on its own line. </span><span class="koboSpan" id="kobo.206.2">This would create a collapsible region of code in the editor, as the collapsed region from lines 33–84 in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.207.1">Figure </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.208.1">5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1"> illustrates:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.211.1"><img alt="Figure 5.6 – A collapsed region of code" src="image/B21324_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.212.1">Figure 5.6 – A collapsed region of code</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">#region</span></strong><span class="koboSpan" id="kobo.214.1"> is viewed as a bad thing to rely on for code organization; it leads to extremely large classes instead of refactoring code into more </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">maintainable patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">So, why does it exist </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">at all?</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">#region</span></strong><span class="koboSpan" id="kobo.220.1"> directive was introduced to help hide auto-generated code commonly built into older versions of .NET applications. </span><span class="koboSpan" id="kobo.220.2">This is code that developers were not expected to work with and often encouraged not to modify for fear of </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">breaking things.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Eventually, .NET got </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">partial classes</span></strong><span class="koboSpan" id="kobo.224.1"> to</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.225.1"> help in scenarios that regions were previously </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">used in.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Partial classes are </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.228.1">classes that are defined in </span><em class="italic"><span class="koboSpan" id="kobo.229.1">multiple files</span></em><span class="koboSpan" id="kobo.230.1"> within the </span><em class="italic"><span class="koboSpan" id="kobo.231.1">same project</span></em><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">This will allow you to have </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">FlightScheduler.ItemManagement.cs</span></strong><span class="koboSpan" id="kobo.234.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">FlightScheduler.Search.cs</span></strong><span class="koboSpan" id="kobo.236.1"> files that each contain parts of the larger class. </span><span class="koboSpan" id="kobo.236.2">This lets you define a large class over </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">multiple files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">partial</span></strong><span class="koboSpan" id="kobo.240.1"> class FlightScheduler {
  // Details omitted...
</span><span class="koboSpan" id="kobo.240.2">}</span></pre>
<p><span class="koboSpan" id="kobo.241.1">Like region directives, partial classes are intended to support automatically generated code. </span><span class="koboSpan" id="kobo.241.2">While I personally prefer partial classes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">#region</span></strong><span class="koboSpan" id="kobo.243.1"> directives, I view both as anti-patterns when they are applied to reducing pains caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">large classes.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Usually, when your classes are big enough for you to want to consider </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">#region</span></strong><span class="koboSpan" id="kobo.247.1"> or partial classes, you are violating the single responsibility principle and your class should be broken up into </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.248.1">multiple smaller classes that are distinctly different from </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">one another.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">We’ll discuss the single responsibility principle and other design principles in </span><a href="B21324_08.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.251.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.252.1">, </span><em class="italic"><span class="koboSpan" id="kobo.253.1">Avoiding Code Anti-patterns </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.254.1">with SOLID</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.256.1">Refactoring and inheritance</span></h1>
<p><span class="koboSpan" id="kobo.257.1">Now that we’ve covered some of the ways refactoring can help organize your code, let’s dive into refactorings related to inheritance. </span><span class="koboSpan" id="kobo.257.2">This is a collection of refactorings that involve either overriding methods, introducing inheritance, or altering in-place inheritance relationships to improve the maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">of code.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.259.1">Overriding ToString</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">ToString</span></strong><span class="koboSpan" id="kobo.261.1"> is one </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.262.1">of the four methods that any .NET object is guaranteed to have due to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">virtual</span></strong><span class="koboSpan" id="kobo.264.1"> definition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">ToString</span></strong><span class="koboSpan" id="kobo.266.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">System.Object</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">This method is used whenever an object is converted to a string and can be particularly handy for logging and </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">debugging purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Sometimes overriding </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">ToString</span></strong><span class="koboSpan" id="kobo.272.1"> can simplify your code in </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">unexpected ways.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">Let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">BuildFlightIdentifier</span></strong><span class="koboSpan" id="kobo.276.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">FreightFlightInfo.cs</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">This method relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">DepartureLocation</span></strong><span class="koboSpan" id="kobo.280.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">ArrivalLocation</span></strong><span class="koboSpan" id="kobo.282.1"> properties of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Airport</span></strong><span class="koboSpan" id="kobo.284.1"> to produce </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">a string:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.286.1">FreightFlightInfo.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
public string BuildFlightIdentifier() =&gt;
  $"{Id} {</span><strong class="bold"><span class="koboSpan" id="kobo.288.1">DepartureLocation.Code</span></strong><span class="koboSpan" id="kobo.289.1">}-" +
  $"{</span><strong class="bold"><span class="koboSpan" id="kobo.290.1">ArrivalLocation.Code}</span></strong><span class="koboSpan" id="kobo.291.1"> carrying " +
  $"{Cargo} for {CharterCompany}";</span></pre>
<p><span class="koboSpan" id="kobo.292.1">It’s annoying to have to drill into these location properties to reach their </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Airport</span></strong><span class="koboSpan" id="kobo.297.1"> overrides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">ToString</span></strong><span class="koboSpan" id="kobo.299.1"> method and returns the airport code, we would be able to simplify the readability of </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">our code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
public string BuildFlightIdentifier() =&gt;
  $"{Id} {</span><strong class="bold"><span class="koboSpan" id="kobo.302.1">DepartureLocation</span></strong><span class="koboSpan" id="kobo.303.1">}-{</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">ArrivalLocation</span></strong><span class="koboSpan" id="kobo.305.1">} " +
  $"carrying {Cargo} for {CharterCompany}";</span></pre>
<p><span class="koboSpan" id="kobo.306.1">To do this, you can either go to </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Airport.cs</span></strong><span class="koboSpan" id="kobo.308.1"> and add the override manually or use the built-in refactoring option through the </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Generate overrides...</span></strong><span class="koboSpan" id="kobo.310.1"> refactoring (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.314.1"><img alt="Figure 5.7 – Generating overrides on a class" src="image/B21324_05_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">Figure 5.7 – Generating overrides on a class</span></p>
<p><span class="koboSpan" id="kobo.316.1">From there, you’ll </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.317.1">need to specify which methods or properties you want to override. </span><span class="koboSpan" id="kobo.317.2">As shown in the following image, any abstract or virtual member of a class you’re inheriting from will </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">be available:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.319.1"><img alt="Figure 5.8 – Selecting the members to override" src="image/B21324_05_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">Figure 5.8 – Selecting the members to override</span></p>
<p><span class="koboSpan" id="kobo.321.1">Selecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">ToString()</span></strong><span class="koboSpan" id="kobo.323.1"> and clicking </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">OK</span></strong><span class="koboSpan" id="kobo.325.1"> generates a stubbed-out method that can be quickly replaced with an </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">actual implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">In this class, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">ToString</span></strong><span class="koboSpan" id="kobo.329.1"> method should return the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">airport code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
public class Airport {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
  </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">public override string? </span><span class="koboSpan" id="kobo.332.2">ToString() =&gt; Code;</span></strong><span class="koboSpan" id="kobo.333.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.334.1">With this</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.335.1"> override in place, existing code can still use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Code</span></strong><span class="koboSpan" id="kobo.337.1"> property without issues. </span><span class="koboSpan" id="kobo.337.2">However, any code that previously tried to write an </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Airport</span></strong><span class="koboSpan" id="kobo.339.1"> object to the console now will see its code instead of the namespace and name of </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.341.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.342.1">The default implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">ToString</span></strong><span class="koboSpan" id="kobo.344.1"> in .NET is to return a string with the namespace and the name of the type. </span><span class="koboSpan" id="kobo.344.2">In this case that would have </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">been </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Packt.CloudySkiesAir.Chapter5.AirTravel.Airport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Next, we should look at everywhere the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">Code</span></strong><span class="koboSpan" id="kobo.350.1"> property is currently being read from and see if it would be more readable to rely on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">ToString</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.352.1">override instead.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">You can do this in any edition of Visual Studio 2022 by right-clicking on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Code</span></strong><span class="koboSpan" id="kobo.355.1"> property declaration and choosing </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">Find All References</span></strong><span class="koboSpan" id="kobo.357.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.358.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.359.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.361.1"><img alt="Figure 5.9 – The Find All References context menu option" src="image/B21324_05_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.362.1">Figure 5.9 – The Find All References context menu option</span></p>
<p><span class="koboSpan" id="kobo.363.1">This opens a new pane with all references of that </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">property highlighted:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.365.1"><img alt="Figure 5.10 – Find All References results" src="image/B21324_05_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 5.10 – Find All References results</span></p>
<p><span class="koboSpan" id="kobo.367.1">You can then </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.368.1">modify these areas to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">ToString</span></strong><span class="koboSpan" id="kobo.370.1"> where appropriate, such as in this modification </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">PassengerFlightInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
public string BuildFlightIdentifier() =&gt;
  $"{Id} {</span><strong class="bold"><span class="koboSpan" id="kobo.375.1">DepartureLocation</span></strong><span class="koboSpan" id="kobo.376.1">}-{</span><strong class="bold"><span class="koboSpan" id="kobo.377.1">ArrivalLocation</span></strong><span class="koboSpan" id="kobo.378.1">} " +
  $"carrying {_passengers} people";</span></pre>
<p><span class="koboSpan" id="kobo.379.1">One added benefit of overriding </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">ToString</span></strong><span class="koboSpan" id="kobo.381.1"> in your objects is an improved display of the class when viewing the Visual </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">Studio debugger:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.383.1"><img alt="Figure 5.11 – ToString override displaying in debugging tools" src="image/B21324_05_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.384.1">Figure 5.11 – ToString override displaying in debugging tools</span></p>
<p><span class="koboSpan" id="kobo.385.1">We’ll explore debugging more in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.387.1">: Defensive </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.388.1">Coding Techniques</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.390.1">Generating equality methods</span></h2>
<p><span class="koboSpan" id="kobo.391.1">In C#, equality</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.392.1"> for reference types (such as classes) is done</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.393.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">reference equality</span></strong><span class="koboSpan" id="kobo.395.1"> –determining whether the two objects are located at the same location in </span><a id="_idIndexMarker284"/><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.397.1">heap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">Sometimes it’s more convenient to compare different properties on two objects to see if their values are equivalent, even if the two objects represent two separate locations on </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">The following code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.403.1"> class shows how its </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Search</span></strong><span class="koboSpan" id="kobo.405.1"> method checks to make sure the airport you’re searching for has the same airport code and country. </span><span class="koboSpan" id="kobo.405.2">Note the repeated logic when determining if two airports </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">are equivalent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
if (depart != null) {
  results = results.Where(f =&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.408.1">    f.DepartureLocation.Code == depart.Code &amp;&amp;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.409.1">    f.DepartureLocation.Country == depart.Country</span></strong><span class="koboSpan" id="kobo.410.1">
  );
}
if (arrive != null) {
  results = results.Where(f =&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">    f.ArrivalLocation.Code == arrive.Code &amp;&amp;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.412.1">    f.ArrivalLocation.Country == arrive.Country</span></strong><span class="koboSpan" id="kobo.413.1">
  );
}</span></pre>
<p><span class="koboSpan" id="kobo.414.1">This code could be simplified by overriding equality members with our own </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">customized implementation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.416.1">Equality members</span></p>
<p class="callout"><span class="koboSpan" id="kobo.417.1">.NET provides two methods to determine equality: </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Equals</span></strong><span class="koboSpan" id="kobo.419.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Equals</span></strong><span class="koboSpan" id="kobo.423.1"> method determines whether two objects are equivalent while </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.425.1"> is used to determine which major “bucket” an object is sorted into</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.426.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">hashing</span></strong><span class="koboSpan" id="kobo.428.1"> algorithms, such as those used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Dictionary</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.430.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">HashSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.433.1">You should never override only one of these two methods; whenever you override </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Equals</span></strong><span class="koboSpan" id="kobo.435.1">, you will need to override </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.437.1"> as well. </span><span class="koboSpan" id="kobo.437.2">Furthermore, you want to make sure you use a good implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.439.1"> that evenly and consistently distributes objects in your class into different </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">hash values.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.441.1">.NET also provides an </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">IEquatable&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.443.1"> interface that you can implement for strongly typed equality comparisons, which can improve performance. </span><span class="koboSpan" id="kobo.443.2">Implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">IEquatable&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.445.1"> is generally recommended when overriding equality members but is not detailed in this book. </span><span class="koboSpan" id="kobo.445.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.446.1">Further reading</span></em><span class="koboSpan" id="kobo.447.1"> section for </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Equality and</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.450.1"> hash codes can get complex very quickly, but thankfully we have some very good tooling for generating equality members in Visual Studio. </span><span class="koboSpan" id="kobo.450.2">Just select your class and then choose </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Generate Equals and GetHashCode…</span></strong><span class="koboSpan" id="kobo.452.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.454.1"> menu, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.455.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.456.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.458.1"><img alt="Figure 5.12 – Generating equality member overrides" src="image/B21324_05_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.459.1">Figure 5.12 – Generating equality member overrides</span></p>
<p><span class="koboSpan" id="kobo.460.1">Once you select this, Visual Studio will ask you what members should contribute to equality and hash code checks, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.462.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.464.1"><img alt="Figure 5.13 – Selecting equality members" src="image/B21324_05_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.465.1">Figure 5.13 – Selecting equality members</span></p>
<p><span class="koboSpan" id="kobo.466.1">Select the </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.467.1">members that </span><em class="italic"><span class="koboSpan" id="kobo.468.1">must</span></em><span class="koboSpan" id="kobo.469.1"> be equal and click </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">OK</span></strong><span class="koboSpan" id="kobo.471.1"> to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">your overrides:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.473.1">Airport.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
public class Airport {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
</span><strong class="bold"><span class="koboSpan" id="kobo.475.1">  public override bool Equals(object? </span><span class="koboSpan" id="kobo.475.2">obj) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.476.1">    return obj is Airport airport &amp;&amp;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.477.1">           Country == airport.Country &amp;&amp;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.478.1">           Code == airport.Code;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.479.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.480.1">}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.481.1">  public override int GetHashCode() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.482.1">    return HashCode.Combine(Country, Code);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.483.1">  }</span></strong><span class="koboSpan" id="kobo.484.1">
  public override string? </span><span class="koboSpan" id="kobo.484.2">ToString() =&gt; Code;
}</span></pre>
<p><span class="koboSpan" id="kobo.485.1">Here, Visual Studio</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.486.1"> generated a pattern matching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">Equals</span></strong><span class="koboSpan" id="kobo.488.1"> implementation that compares the relevant properties. </span><span class="koboSpan" id="kobo.488.2">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.490.1"> implementation uses the newer </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">HashCode.Combine</span></strong><span class="koboSpan" id="kobo.492.1"> method to safely simplify the process of hash code generation </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">for you.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.494.1">Updating equality members</span></p>
<p class="callout"><span class="koboSpan" id="kobo.495.1">If you ever add new properties to your class that should factor into equality checks, be sure to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Equals</span></strong><span class="koboSpan" id="kobo.497.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.499.1"> to include </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">these properties.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">With custom equality members in place, code that previously checked both the airport </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Code</span></strong><span class="koboSpan" id="kobo.503.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Country</span></strong><span class="koboSpan" id="kobo.505.1"> can be simplified to use the equality operator (</span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">==</span></strong><span class="koboSpan" id="kobo.507.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">instead:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.509.1">FlightScheduler.cs – Search</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
if (depart != null) {
  results=results.Where(f=&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">f.DepartureLocation == depart</span></strong><span class="koboSpan" id="kobo.512.1">);
}
if (arrive != null) {
  results=results.Where(f=&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">f.ArrivalLocation == arrive</span></strong><span class="koboSpan" id="kobo.514.1">);
}</span></pre>
<p><span class="koboSpan" id="kobo.515.1">Overriding equality members can be handy when you have many similar objects on the heap that contain identical values. </span><span class="koboSpan" id="kobo.515.2">This can happen when working </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.516.1">with </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">web services</span></strong><span class="koboSpan" id="kobo.518.1"> or other places </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.519.1">where </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.520.1">deserialization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1"> occurs.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.522.1">Equality and records</span></p>
<p class="callout"><span class="koboSpan" id="kobo.523.1">You don’t always need to override equality members to get value-based equality. </span><span class="koboSpan" id="kobo.523.2">In </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.524.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.525.1">: Defensive Coding Techniques</span></em><span class="koboSpan" id="kobo.526.1">, we’ll explore strategic uses of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">record</span></strong><span class="koboSpan" id="kobo.528.1"> keyword for controlling equality. </span><span class="koboSpan" id="kobo.528.2">In fact, whenever I find myself thinking about overriding equality members, I usually decide to make my class a </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">record instead.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.530.1">Extracting a base class</span></h2>
<p><span class="koboSpan" id="kobo.531.1">Sometimes</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.532.1"> you’ll encounter cases with a high degree of duplication between classes. </span><span class="koboSpan" id="kobo.532.2">These classes are conceptually related and share not just similar member signatures, but identical implementations of </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">those members.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">In these cases, it often makes sense to introduce a base class that defines the common shared code. </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">Inheritance</span></strong><span class="koboSpan" id="kobo.536.1"> then</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.537.1"> allows us to remove the common code from multiple classes in the system and maintain it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">centralized place.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">In our flight scheduler example (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.540.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.541.1">.14</span></em><span class="koboSpan" id="kobo.542.1">), the passenger and freight flight classes have several </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">shared properties:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.544.1"><img alt="Figure 5.14 – Shared members between freight and passenger flights" src="image/B21324_05_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.545.1">Figure 5.14 – Shared members between freight and passenger flights</span></p>
<p><span class="koboSpan" id="kobo.546.1">To address this, go to either of the two classes and choose </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">Extract base class...</span></strong><span class="koboSpan" id="kobo.548.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">Quick </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.550.1">Actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1"> menu:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.552.1"><img alt="Figure 5.15 – Extracting a base class" src="image/B21324_05_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.553.1">Figure 5.15 – Extracting a base class</span></p>
<p><span class="koboSpan" id="kobo.554.1">Next, name the </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.555.1">new class and select which members you want to move into it, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.557.1">.16</span></em><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">You can also decide whether you want any of those members to be declared as abstract, but note that this will mark your class as abstract </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">as well.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.560.1"><img alt="Figure 5.16 – Configuring the new base class" src="image/B21324_05_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.561.1">Figure 5.16 – Configuring the new base class</span></p>
<p><span class="koboSpan" id="kobo.562.1">Once you click </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">OK</span></strong><span class="koboSpan" id="kobo.564.1">, the new class will </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">be created:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.566.1">FlightInfoBase.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.569.1"> {
  public Airport ArrivalLocation { get; set; }
  public DateTime ArrivalTime { get; set; }
  public Airport DepartureLocation { get; set; }
  public DateTime DepartureTime { get; set; }
  public TimeSpan Duration =&gt; DepartureTime - ArrivalTime;
  public string Id { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.570.1">The class </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.571.1">you started with now inherits from this new class and the non-abstract members you selected have been removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.573.1">PassengerFlightInfo.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
public class PassengerFlightInfo : </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">FlightInfoBase,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.576.1">                                   IFlightInfo</span></strong><span class="koboSpan" id="kobo.577.1"> {
  private int _passengers;
  public void Load(int passengers) =&gt;
    _passengers = passengers;
  public void Unload() =&gt;
    _passengers = 0;
  public string BuildFlightIdentifier() =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} carrying"
    + $" {_passengers} people";
  public override string ToString() =&gt;
    BuildFlightIdentifier();
}</span></pre>
<p><span class="koboSpan" id="kobo.578.1">Extracting a base class can be very helpful for promoting code reuse, but it’s only half of the refactoring work; extracting a base class did not modify your </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">other class.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">If you want </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.581.1">the related flight class to also inherit from the new class, you’ll have to make that change manually by specifying the base class and removing any members that were “pulled up” to </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">that class:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.583.1">FreightFlightInfo.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
public class FreightFlightInfo : </span><strong class="bold"><span class="koboSpan" id="kobo.585.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.586.1">,
                                 IFlightInfo {
  public string CharterCompany { get; set; }
  public string Cargo { get; set; }
  public string BuildFlightIdentifier() =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} " +
    $"carrying {Cargo} for {CharterCompany}";
  public override string ToString() =&gt;
    BuildFlightIdentifier();
}</span></pre>
<p><span class="koboSpan" id="kobo.587.1">The result of this is that our two flight classes are now focused on the things that are distinct to them. </span><span class="koboSpan" id="kobo.587.2">Additionally, if new logic needs to be added for every flight, it can now be added to the base class and all inheriting classes will </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">receive it.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.589.1">Moving interface implementations up the inheritance tree</span></h2>
<p><span class="koboSpan" id="kobo.590.1">One oddity</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.591.1"> you might have noticed in the last two code listings is that even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">FreightFlightInfo</span></strong><span class="koboSpan" id="kobo.593.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.595.1"> both now inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.597.1">, they both separately implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.599.1"> interface, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.600.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.601.1">.17</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.603.1"><img alt="Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo" src="image/B21324_05_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.604.1">Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo</span></p>
<p><span class="koboSpan" id="kobo.605.1">When every class</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.606.1"> inheriting from a base class implements an interface, there’s usually a good chance that you can pull the interface implementation up into the base </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">class itself.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.610.1"> has all required members defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.612.1"> interface. </span><span class="koboSpan" id="kobo.612.2">So, it makes sense to implement the interface, as </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">shown here:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.614.1">FlightInfoBase.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
public class FlightInfoBase </span><strong class="bold"><span class="koboSpan" id="kobo.616.1">: IFlightInfo</span></strong><span class="koboSpan" id="kobo.617.1"> {
  public Airport ArrivalLocation { get; set; }
  public DateTime ArrivalTime { get; set; }
  public Airport DepartureLocation { get; set; }
  public DateTime DepartureTime { get; set; }
  public TimeSpan Duration =&gt; DepartureTime – ArrivalTime;
  public string Id { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.618.1">With the change in place, we can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.620.1"> implementation from both </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.622.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">FreightFlightInfo</span></strong><span class="koboSpan" id="kobo.624.1">. </span><span class="koboSpan" id="kobo.624.2">This simplifies the class definitions while still inheriting the interface implementation, as </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">pictured here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.626.1"><img alt="Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase" src="image/B21324_05_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.627.1">Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase</span></p>
<p><span class="koboSpan" id="kobo.628.1">By pulling the</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.629.1"> interface up into the base class, we now </span><em class="italic"><span class="koboSpan" id="kobo.630.1">guarantee</span></em><span class="koboSpan" id="kobo.631.1"> that any class inheriting from this class will also implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">IFlightInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.633.1"> interface.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.634.1">Controlling inheritance with abstract</span></h1>
<p><span class="koboSpan" id="kobo.635.1">Now that we’ve covered some refactoring patterns around inheritance, let’s look at using </span><strong class="bold"><span class="koboSpan" id="kobo.636.1">abstract classes</span></strong><span class="koboSpan" id="kobo.637.1"> and </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.638.1">other C# features to restrict our classes and ensure they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">used appropriately.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.640.1">Communicating intent with abstract</span></h2>
<p><span class="koboSpan" id="kobo.641.1">One quirk </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.642.1">about our current design is that it is possible to instantiate a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.644.1"> simply by writing the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
FlightInfoBase flight = new FlightInfoBase();</span></pre>
<p><span class="koboSpan" id="kobo.647.1">While it might not make sense to you – for a new flight to exist that isn’t explicitly a passenger or freight flight, because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.649.1"> class is not marked as abstract – there’s nothing preventing anyone from </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">instantiating it.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">To mark a class as abstract, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">abstract</span></strong><span class="koboSpan" id="kobo.653.1"> keyword to </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">its signature:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.655.1">FlightInfoBase.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.656.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">abstract</span></strong><span class="koboSpan" id="kobo.658.1"> class FlightInfoBase : IFlightInfo {
  public Airport ArrivalLocation { get; set; }
  public DateTime ArrivalTime { get; set; }
  public Airport DepartureLocation { get; set; }
  public DateTime DepartureTime { get; set; }
  public TimeSpan Duration =&gt; DepartureTime - ArrivalTime;
  public string Id { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.659.1">Marking classes as abstract when you do not intend for anyone to instantiate them accomplishes a </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">few things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.661.1">It communicates that the class is not intended to </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">be instantiated</span></span></li>
<li><span class="koboSpan" id="kobo.663.1">The compiler now prevents others from instantiating </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">your class</span></span></li>
<li><span class="koboSpan" id="kobo.665.1">As we’ll see next, it allows you to add abstract members to </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">your class</span></span></li>
</ul>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.667.1">Introducing abstract members</span></h2>
<p><span class="koboSpan" id="kobo.668.1">Now that </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.670.1"> is abstract, it </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.671.1">opens new </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.672.1">possibilities </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">for refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">For example, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">FreightFlightInfo</span></strong><span class="koboSpan" id="kobo.676.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.678.1"> have </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">BuildFlightIdentifier</span></strong><span class="koboSpan" id="kobo.680.1"> methods and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">ToString</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.682.1"> overrides.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.683.1"><img alt="Figure 5.19 – Repeated members in flight info classes" src="image/B21324_05_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.684.1">Figure 5.19 – Repeated members in flight info classes</span></p>
<p><span class="koboSpan" id="kobo.685.1">While the implementation details of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">BuildFlightIdentifier</span></strong><span class="koboSpan" id="kobo.687.1"> method differ, </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">ToString</span></strong><span class="koboSpan" id="kobo.689.1"> overrides the return of the result </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">BuildFlightIdentifier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">We can take advantage of these commonalities by pulling both methods into the base class using </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">Pull [Member name] up...</span></strong><span class="koboSpan" id="kobo.695.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.696.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.697.1">.20</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.699.1"><img alt="Figure 5.20 – Pulling members up to the base type" src="image/B21324_05_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.700.1">Figure 5.20 – Pulling members up to the base type</span></p>
<p><span class="koboSpan" id="kobo.701.1">Next, select the </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.702.1">members you want to pull up into the parent class, making sure to check the </span><strong class="bold"><span class="koboSpan" id="kobo.703.1">Mark abstract</span></strong><span class="koboSpan" id="kobo.704.1"> checkbox for any member you want the </span><em class="italic"><span class="koboSpan" id="kobo.705.1">definition</span></em><span class="koboSpan" id="kobo.706.1"> of to be pulled up without also having its </span><em class="italic"><span class="koboSpan" id="kobo.707.1">implementation</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.708.1">pulled up.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.709.1"><img alt="Figure 5.21 – Selecting destination and making members abstract" src="image/B21324_05_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.710.1">Figure 5.21 – Selecting destination and making members abstract</span></p>
<p><span class="koboSpan" id="kobo.711.1">The result of this is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.713.1"> now has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">ToString</span></strong><span class="koboSpan" id="kobo.715.1"> override as well as an abstract definition for </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">BuildFlightIdentifier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.719.1">FlightInfoBase.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">
public abstract class FlightInfoBase : IFlightInfo {
  // Other members omitted...
</span><strong class="bold"><span class="koboSpan" id="kobo.721.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.722.1">public abstract string BuildFlightIdentifier();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.723.1">  public override string ToString() =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.724.1">    BuildFlightIdentifier();</span></strong><span class="koboSpan" id="kobo.725.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.726.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">BuildFlightIdentifier</span></strong><span class="koboSpan" id="kobo.728.1"> abstract, our original method call remains in place, but it is now</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.729.1"> marked as </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">an override:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.731.1">PassengerFlightInfo.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
public class PassengerFlightInfo : FlightInfoBase {
  // Other members omitted...
</span><span class="koboSpan" id="kobo.732.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">public override string BuildFlightIdentifier()</span></strong><span class="koboSpan" id="kobo.734.1"> =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} carrying"
    + $" {_passengers} people";
}</span></pre>
<p><span class="koboSpan" id="kobo.735.1">Unfortunately, the </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">Pull Members Up</span></strong><span class="koboSpan" id="kobo.737.1"> refactoring does not modify other classes that also inherit from the same base class, so you now must add the override manually in the other </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">flight class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.739.1">
public class FreightFlightInfo : FlightInfoBase {
  // Other members omitted...
</span><span class="koboSpan" id="kobo.739.2">  public </span><strong class="bold"><span class="koboSpan" id="kobo.740.1">override</span></strong><span class="koboSpan" id="kobo.741.1"> string BuildFlightIdentifier() =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} " +
    $"carrying {Cargo} for {CharterCompany}";
}</span></pre>
<p><span class="koboSpan" id="kobo.742.1">Making this refactoring has simplified our code: the individual flight classes no longer need to override </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">ToString</span></strong><span class="koboSpan" id="kobo.744.1">. </span><span class="koboSpan" id="kobo.744.2">More importantly, if we ever add a new type of flight, the compiler will force it to </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.745.1">provide a valid flight identifier through a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">BuildFlightIdentifier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.747.1"> override.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.748.1">Sealed methods and classes</span></p>
<p class="callout"><span class="koboSpan" id="kobo.749.1">While we’re talking about abstract, virtual, and overriding methods, we should touch on </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">sealed</span></strong><span class="koboSpan" id="kobo.751.1">. </span><span class="koboSpan" id="kobo.751.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.752.1">sealed</span></strong><span class="koboSpan" id="kobo.753.1"> keyword</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.754.1"> can be applied to a class or any overridden method in a syntax similar to abstract syntax. </span><span class="koboSpan" id="kobo.754.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">sealed</span></strong><span class="koboSpan" id="kobo.756.1"> keyword has almost the opposite effect. </span><span class="koboSpan" id="kobo.756.2">When a class is marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">sealed</span></strong><span class="koboSpan" id="kobo.758.1">, it cannot be inherited from. </span><span class="koboSpan" id="kobo.758.2">When a </span><em class="italic"><span class="koboSpan" id="kobo.759.1">method</span></em><span class="koboSpan" id="kobo.760.1"> is marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">sealed</span></strong><span class="koboSpan" id="kobo.762.1">, that method may not be overridden further in inheriting classes. </span><span class="koboSpan" id="kobo.762.2">Both uses of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">sealed</span></strong><span class="koboSpan" id="kobo.764.1"> keyword exist to protect what a class does from external modification. </span><span class="koboSpan" id="kobo.764.2">Additionally, there can be some performance benefits to marking members </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">as sealed.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.766.1">Converting abstract methods to virtual methods</span></h2>
<p><span class="koboSpan" id="kobo.767.1">Occasionally, you’ll</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.768.1"> mark a method as abstract and later realize that many overrides of this method have similar implementations. </span><span class="koboSpan" id="kobo.768.2">When this occurs, it can make sense to move the method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">abstract</span></strong><span class="koboSpan" id="kobo.770.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">virtual</span></strong><span class="koboSpan" id="kobo.772.1"> in order to provide a base implementation that others can </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.773.1">optionally</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.774.1"> override.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.777.1"> class defines </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">BuildFlightIdentifier</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.779.1">as abstract:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.780.1">
public abstract string BuildFlightIdentifier();</span></pre>
<p><span class="koboSpan" id="kobo.781.1">This would imply that each implementation of this method </span><em class="italic"><span class="koboSpan" id="kobo.782.1">should</span></em><span class="koboSpan" id="kobo.783.1"> be different from the others. </span><span class="koboSpan" id="kobo.783.2">However, let’s take a look at the actual implementations </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">of this:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.785.1">PassengerFlightInfo.cs</span></span><pre class="source-code"><span class="koboSpan" id="kobo.786.1">
public override string BuildFlightIdentifier() =&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
  $"</span><strong class="bold"><span class="koboSpan" id="kobo.788.1">{Id} {DepartureLocation}-{ArrivalLocation}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.789.1">
    carrying " +</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.790.1">
  $"{_passengers} people";</span></pre></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.791.1">FreightFlightInfo.cs</span></span><pre class="source-code"><span class="koboSpan" id="kobo.792.1">
public override string BuildFlightIdentifier() =&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.793.1">
  $"</span><strong class="bold"><span class="koboSpan" id="kobo.794.1">{Id} {DepartureLocation}-{ArrivalLocation}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.795.1">
    carrying " +</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.796.1">
  $"{Cargo} for {CharterCompany}";</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.797.1">While the strings for both methods are built, they both start with the flight identifier, the departure airport, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">arrival airport.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">If we ever wanted to change the way all flights display this basic information, we’d need to change every class inheriting </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">FlightInfoBase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">Instead, we can modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.805.1"> to provide a good starting point with this </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">shared information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.807.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">virtual</span></strong><span class="koboSpan" id="kobo.809.1"> string BuildFlightIdentifier() </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">=&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.811.1">  $"{Id} {DepartureLocation}-{ArrivalLocation}";</span></strong></pre>
<p><span class="koboSpan" id="kobo.812.1">With this change, two things </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">have happened:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.814.1">New</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.815.1"> flight classes no longer </span><em class="italic"><span class="koboSpan" id="kobo.816.1">need</span></em><span class="koboSpan" id="kobo.817.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">override </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">BuildFlightIdentifier</span></strong></span></li>
<li><span class="koboSpan" id="kobo.820.1">Existing overrides can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">base.BuildFlightIdentifier()</span></strong><span class="koboSpan" id="kobo.822.1"> to get the common format of the basic </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">flight information</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.824.1">In our case, it makes sense to continue to override the method, but we can now change the code to take advantage of common formatting at the </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">base level:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">PassengerFlightInfo.cs</span></strong></span><pre class="source-code"><span class="koboSpan" id="kobo.827.1">
public override string BuildFlightIdentifier() =&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">base.BuildFlightIdentifier() +</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.830.1">
  $" carrying {_passengers} people";</span></pre></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">FreightFlightInfo.cs</span></strong></span><pre class="source-code"><span class="koboSpan" id="kobo.832.1">
public override string BuildFlightIdentifier() =&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.833.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.834.1">base.BuildFlightIdentifier() +</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.835.1">
  $" carrying {Cargo} for {CharterCompany}";</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.836.1">Combining our </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.837.1">abstract class with a virtual method lets us keep flight formatting logic in one centralized place while still giving us the freedom to extend the class and modify </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">its behavior.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.839.1">Refactoring for better encapsulation</span></h1>
<p><span class="koboSpan" id="kobo.840.1">Another core tenet of object-oriented </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.841.1">programming is </span><strong class="bold"><span class="koboSpan" id="kobo.842.1">encapsulation</span></strong><span class="koboSpan" id="kobo.843.1">. </span><span class="koboSpan" id="kobo.843.2">With encapsulation, you assert control of the data in your classes and ensure others work with data in ways that make sense both immediately and as the code grows </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">The following refactorings deal with the various pieces of data composing classes along with the data passed along to methods </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">as parameters.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.847.1">Encapsulating fields</span></h2>
<p><span class="koboSpan" id="kobo.848.1">The simplest </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.849.1">encapsulation refactoring allows you to wrap all uses of a field into </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">a property.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">In the following code example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.853.1"> class has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">_passengers</span></strong><span class="koboSpan" id="kobo.855.1"> field storing the count of passengers on the flight, and this field is used throughout the class when referring to the </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">passenger count:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.857.1">
public class PassengerFlightInfo : FlightInfoBase {
  </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">private int _passengers;</span></strong><span class="koboSpan" id="kobo.859.1">
  public void Load(int passengers) =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">_passengers = passengers;</span></strong><span class="koboSpan" id="kobo.861.1">
  public void Unload() =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">_passengers = 0;</span></strong><span class="koboSpan" id="kobo.863.1">
  public override string BuildFlightIdentifier() =&gt;
    base.BuildFlightIdentifier() +
    $" carrying </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">{_passengers</span></strong><span class="koboSpan" id="kobo.865.1">} people";
}</span></pre>
<p><span class="koboSpan" id="kobo.866.1">This </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.867.1">code isn’t bad, and I’d be fine with this logic in a production application. </span><span class="koboSpan" id="kobo.867.2">However, it does have a few </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">potential drawbacks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.869.1">Nothing outside of the class can read the count of passengers on </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">the flight.</span></span></li>
<li><span class="koboSpan" id="kobo.871.1">Several places modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">_passengers</span></strong><span class="koboSpan" id="kobo.873.1"> field. </span><span class="koboSpan" id="kobo.873.2">If we wanted to add validation or do something every time the value changes, we’d have to modify several </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">different methods.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.875.1">Wrapping all uses of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">_passengers</span></strong><span class="koboSpan" id="kobo.877.1"> field into a property can help with this by giving us a centralized place to perform validation and a property for things outside of the class </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">to read.</span></span></p>
<p><span class="koboSpan" id="kobo.879.1">You can use the </span><strong class="bold"><span class="koboSpan" id="kobo.880.1">Encapsulate field</span></strong><span class="koboSpan" id="kobo.881.1"> refactoring in the </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">Quick Action</span></strong><span class="koboSpan" id="kobo.883.1"> menu to quickly wrap an existing field into </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">a property:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.885.1"><img alt="Figure 5.22 – Encapsulating the passengers field into a property" src="image/B21324_05_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.886.1">Figure 5.22 – Encapsulating the passengers field into a property</span></p>
<p><span class="koboSpan" id="kobo.887.1">This adds a property that your class can use to read and modify the value in a </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">centralized location:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.889.1">
public sealed class PassengerFlightInfo : FlightInfoBase {
  private int _passengers;
</span><strong class="bold"><span class="koboSpan" id="kobo.890.1">  public int Passengers {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.891.1">    get =&gt; _passengers;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.892.1">    set =&gt; _passengers = value;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.893.1">  }</span></strong><span class="koboSpan" id="kobo.894.1">
  public void Load(int passengers) =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">Passengers = passengers;</span></strong><span class="koboSpan" id="kobo.896.1">
  public void Unload() =&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.897.1">Passengers = 0;</span></strong><span class="koboSpan" id="kobo.898.1">
  public override string BuildFlightIdentifier() =&gt;
    base.BuildFlightIdentifier() +
    $" carrying {</span><strong class="bold"><span class="koboSpan" id="kobo.899.1">Passengers</span></strong><span class="koboSpan" id="kobo.900.1">} people";
}</span></pre>
<p><span class="koboSpan" id="kobo.901.1">Keep in </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.902.1">mind that this refactoring does make the setter public by default, which would allow code outside of the class to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">passengers</span></strong><span class="koboSpan" id="kobo.904.1"> value. </span><span class="koboSpan" id="kobo.904.2">If you don’t want this, you can mark the property as having a </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">private</span></strong><span class="koboSpan" id="kobo.906.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">protected</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.908.1">set instead.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.909.1">Wrapping parameters into a class</span></h2>
<p><span class="koboSpan" id="kobo.910.1">As software</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.911.1"> systems grow, more features get added along with the code needed to support them. </span><span class="koboSpan" id="kobo.911.2">This can cause methods that were once simple to grow significantly in complexity and the information they require </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">to operate.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">It’s not unusual for a method that took three parameters in the early days of a project to suddenly find itself needing seven or eight parameters to function after a significant amount of </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">development occurs.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.916.1">’s search method is an example of this since there are so many things that can factor into a </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">flight search:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.918.1">FlightScheduler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.919.1">
public IEnumerable&lt;IFlightInfo&gt; Search(
  </span><strong class="bold"><span class="koboSpan" id="kobo.920.1">Airport? </span><span class="koboSpan" id="kobo.920.2">depart, Airport? </span><span class="koboSpan" id="kobo.920.3">arrive,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.921.1">  DateTime? </span><span class="koboSpan" id="kobo.921.2">minDepartTime, DateTime? </span><span class="koboSpan" id="kobo.921.3">maxDepartTime,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.922.1">  DateTime? </span><span class="koboSpan" id="kobo.922.2">minArriveTime, DateTime? </span><span class="koboSpan" id="kobo.922.3">maxArriveTime,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.923.1">  TimeSpan? </span><span class="koboSpan" id="kobo.923.2">minLength, TimeSpan? </span><span class="koboSpan" id="kobo.923.3">maxLength</span></strong><span class="koboSpan" id="kobo.924.1">) {</span></pre>
<p><span class="koboSpan" id="kobo.925.1">This method currently takes in eight different pieces of information, which makes calls to the method extremely hard </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">to read:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.927.1">
IEnumerable&lt;IflightInfo&gt; flights = </span><strong class="bold"><span class="koboSpan" id="kobo.928.1">scheduler.Search(cmh,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.929.1">  dfw, new DateTime(2024,3,1), new DateTime(2024,3,5),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.930.1">  new DateTime(2024,3,10), new DateTime(2024,3,13),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.931.1">  TimeSpan.FromHours(2.5), TimeSpan.FromHours(4.5))</span></strong><span class="koboSpan" id="kobo.932.1">;</span></pre>
<p><span class="koboSpan" id="kobo.933.1">While I </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.934.1">made that example a little hard to read on purpose, in my experience, complex method signatures exist in the real world. </span><span class="koboSpan" id="kobo.934.2">These complex methods can lead to subtle bugs due to confusion over which value you’re passing to which parameter as you read a long list </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">of parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">Looking at this code, it’s easy to imagine new things that someone might want to search for with regard to flights, including low and high prices, in-flight beverage service, free Wi-Fi, and the type of aircraft being flown. </span><span class="koboSpan" id="kobo.936.2">Each one of these new search features would further expand both the method definition and every caller to </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">One common solution to this problem is to encapsulate related pieces of information into a new class. </span><span class="koboSpan" id="kobo.938.2">In our case, we can define a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">FlightSearch</span></strong><span class="koboSpan" id="kobo.940.1"> class to wrap everything related to searching for </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">a flight:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.942.1">FlightSearch.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.943.1">
public class FlightSearch {
  public Airport? </span><span class="koboSpan" id="kobo.943.2">Depart { get; set; }
  public Airport? </span><span class="koboSpan" id="kobo.943.3">Arrive { get; set; }
  public DateTime? </span><span class="koboSpan" id="kobo.943.4">MinArrive { get; set; }
  public DateTime? </span><span class="koboSpan" id="kobo.943.5">MaxArrive { get; set; }
  public DateTime? </span><span class="koboSpan" id="kobo.943.6">MinDepart { get; set; }
  public DateTime? </span><span class="koboSpan" id="kobo.943.7">MaxDepart { get; set; }
  public TimeSpan? </span><span class="koboSpan" id="kobo.943.8">MinLength { get; set; }
  public TimeSpan? </span><span class="koboSpan" id="kobo.943.9">MaxLength { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.944.1">This new </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.945.1">class allows us to track information on searches in a centralized place and significantly improves the signature of the </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">search method:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.947.1">FlightScheduler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.948.1">
public IEnumerable&lt;IFlightInfo&gt; Search(</span><strong class="bold"><span class="koboSpan" id="kobo.949.1">FlightSearch s</span></strong><span class="koboSpan" id="kobo.950.1">) {
  IEnumerable&lt;IFlightInfo&gt; results = _flights;
  if (</span><strong class="bold"><span class="koboSpan" id="kobo.951.1">s.Depart</span></strong><span class="koboSpan" id="kobo.952.1"> != null) {
    results =
      results.Where(f =&gt; f.DepartureLocation == </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">s.Depart</span></strong><span class="koboSpan" id="kobo.954.1">);
  }
  // Other filters omitted for brevity...
</span><span class="koboSpan" id="kobo.954.2">  return results;
}</span></pre>
<p><span class="koboSpan" id="kobo.955.1">Adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">FlightSearch</span></strong><span class="koboSpan" id="kobo.957.1"> class shrunk the method signature from eight parameters to just one. </span><span class="koboSpan" id="kobo.957.2">Additionally, if new search logic needs to be added in the future, these pieces of information can be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">FlightSearch</span></strong><span class="koboSpan" id="kobo.959.1"> object without needing to further modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">Search</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.961.1">method’s signature.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">Unfortunately, changing the signature of the search method breaks callers to the method until they are updated to use the new search object. </span><span class="koboSpan" id="kobo.962.2">To fix this, you have a </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">few options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.964.1">Update all usages of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">Search</span></strong><span class="koboSpan" id="kobo.966.1"> method to pass a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">FlightSearch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.968.1"> object</span></span></li>
<li><span class="koboSpan" id="kobo.969.1">Create a temporary overload of the Search method that passes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">FlightSearch</span></strong><span class="koboSpan" id="kobo.971.1"> object to the </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">new method.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.973.1">The first option is somewhat self-explanatory, so let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">second option.</span></span></p>
<p><span class="koboSpan" id="kobo.975.1">Here, we’ll</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.976.1"> create an overload of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">Search</span></strong><span class="koboSpan" id="kobo.978.1"> method that takes in the eight old parameters, creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">FlightSearch</span></strong><span class="koboSpan" id="kobo.980.1"> object, and passes it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">new method:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.982.1">[Obsolete("Use the overload that takes a FlightSearch")]</span></strong><span class="koboSpan" id="kobo.983.1">
public IEnumerable&lt;IFlightInfo&gt; Search(
  Airport? </span><span class="koboSpan" id="kobo.983.2">depart, Airport? </span><span class="koboSpan" id="kobo.983.3">arrive,
  DateTime? </span><span class="koboSpan" id="kobo.983.4">minDepartTime, DateTime? </span><span class="koboSpan" id="kobo.983.5">maxDepartTime,
  DateTime? </span><span class="koboSpan" id="kobo.983.6">minArriveTime, DateTime? </span><span class="koboSpan" id="kobo.983.7">maxArriveTime,
  TimeSpan? </span><span class="koboSpan" id="kobo.983.8">minLength, TimeSpan? </span><span class="koboSpan" id="kobo.983.9">maxLength) {
  </span><strong class="bold"><span class="koboSpan" id="kobo.984.1">FlightSearch searchParams = new() {</span></strong><span class="koboSpan" id="kobo.985.1">
    Arrive = arrive,
    MinArrive = minArriveTime,
    MaxArrive = maxArriveTime,
    Depart = depart,
    MinDepart = minDepartTime,
    MaxDepart = maxDepartTime,
    MinLength = minLength,
    MaxLength = maxLength
  </span><strong class="bold"><span class="koboSpan" id="kobo.986.1">};</span></strong><span class="koboSpan" id="kobo.987.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.988.1">return Search(searchParams);</span></strong><span class="koboSpan" id="kobo.989.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.990.1">Note that we marked this method as obsolete. </span><span class="koboSpan" id="kobo.990.2">This will warn programmers trying to use it and tell them what method to use instead (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.991.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.992.1">.23</span></em><span class="koboSpan" id="kobo.993.1">). </span><span class="koboSpan" id="kobo.993.2">Marking things with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">Obsolete</span></strong><span class="koboSpan" id="kobo.995.1"> attribute helps guide developers towards the more recent version. </span><span class="koboSpan" id="kobo.995.2">Typically, a method will be marked as obsolete and then removed from the </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">project later.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.997.1"><img alt="Figure 5.23 – An obsolete warning telling the developer which method to use instead" src="image/B21324_05_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.998.1">Figure 5.23 – An obsolete warning telling the developer which method to use instead</span></p>
<p><span class="koboSpan" id="kobo.999.1">The result of this is that we were able to simplify our method and provide a safe place for the data </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.1000.1">that the method needs to grow over time by introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">a class.</span></span></p>
<p><span class="koboSpan" id="kobo.1002.1">Introducing classes for common sets of parameters significantly speeds up development time for teams, particularly when these same objects are passed around throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">the system.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1004.1">Wrapping properties into a class</span></h2>
<p><span class="koboSpan" id="kobo.1005.1">Sometimes you’ll </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.1006.1">find classes with sets of properties that are related to each other. </span><span class="koboSpan" id="kobo.1006.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.1008.1"> class needs to track both the airport a plane departs from or arrives at and the time and date of </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">that event:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1010.1">FlightInfoBase.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1011.1">
public abstract class FlightInfoBase : IFlightInfo {
</span><strong class="bold"><span class="koboSpan" id="kobo.1012.1">  public Airport ArrivalLocation { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1013.1">  public DateTime ArrivalTime { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1014.1">  public Airport DepartureLocation { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1015.1">  public DateTime DepartureTime { get; set; }</span></strong><span class="koboSpan" id="kobo.1016.1">
  // Other members omitted ...
</span><span class="koboSpan" id="kobo.1016.2">}</span></pre>
<p><span class="koboSpan" id="kobo.1017.1">In this scenario, information about the arrival and departure need both their </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">Airport</span></strong><span class="koboSpan" id="kobo.1019.1"> and the associated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">DateTime</span></strong><span class="koboSpan" id="kobo.1021.1"> to make sense. </span><span class="koboSpan" id="kobo.1021.2">If we needed to track the terminal, gate, or runway in the future, we’d need to add in properties for both arrival </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">and departure.</span></span></p>
<p><span class="koboSpan" id="kobo.1023.1">Because these sets of properties grow together, it makes sense to wrap them together in their own </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">AirportEvent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1026.1">
public class AirportEvent {
  public Airport Location { get; set; }
  public DateTime Time { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1027.1">Now, if we</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.1028.1"> need to expand the information we track on each leg of a flight, we can add it to this class and it will be available to both arrivals </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">and departures.</span></span></p>
<p><span class="koboSpan" id="kobo.1030.1">Of course, for this to fully work we’ll need to modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.1032.1"> to use the new class instead of tracking its </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">properties separately:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1034.1">FlightInfoBase.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
public abstract class FlightInfoBase : IFlightInfo {
</span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">  public AirportEvent Arrival { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1037.1">  public AirportEvent Departure { get; set; }</span></strong><span class="koboSpan" id="kobo.1038.1">
  public TimeSpan Duration =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1039.1">Departure.Time</span></strong><span class="koboSpan" id="kobo.1040.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.1041.1">Arrival.Time</span></strong><span class="koboSpan" id="kobo.1042.1">;
  public string Id { get; set; }
  public virtual string BuildFlightIdentifier() =&gt;
    $"{Id} {</span><strong class="bold"><span class="koboSpan" id="kobo.1043.1">Departure.Location</span></strong><span class="koboSpan" id="kobo.1044.1">}-{</span><strong class="bold"><span class="koboSpan" id="kobo.1045.1">Arrival.Location</span></strong><span class="koboSpan" id="kobo.1046.1">}";
  public sealed override string ToString() =&gt;
    BuildFlightIdentifier();
}</span></pre>
<p><span class="koboSpan" id="kobo.1047.1">However, this change on its own won’t be enough until we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.1049.1"> interface to match our </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">new signature:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1051.1">IFlightInfo.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
public interface IFlightInfo {
  string Id { get; }
</span><strong class="bold"><span class="koboSpan" id="kobo.1053.1">  AirportEvent Arrival { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1054.1">  AirportEvent Departure { get; set; }</span></strong><span class="koboSpan" id="kobo.1055.1">
  TimeSpan Duration { get; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1056.1">With this</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.1057.1"> change, the compiler is now satisfied with our flight classes, but there are now compiler errors in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.1059.1">’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">ScheduleFlight</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1"> method:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1062.1">FlightScheduler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1063.1">
PassengerFlightInfo flight = new() {
  Id = id,
</span><strong class="bold"><span class="koboSpan" id="kobo.1064.1">  ArrivalLocation = arrive,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1065.1">  ArrivalTime = arriveTime,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1066.1">  DepartureLocation = depart,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1067.1">  DepartureTime = departTime,</span></strong><span class="koboSpan" id="kobo.1068.1">
};</span></pre>
<p><span class="koboSpan" id="kobo.1069.1">This method is still trying to set the old properties, so it will need to be updated to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">AirportEvent</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1071.1">objects instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1072.1">
PassengerFlightInfo flight = new() {
  Id = id,
  </span><strong class="bold"><span class="koboSpan" id="kobo.1073.1">Arrival =</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1074.1">new AirportEvent {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1075.1">    Location = arrive,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1076.1">    Time = arriveTime,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1077.1">  }</span></strong><span class="koboSpan" id="kobo.1078.1">,
  </span><strong class="bold"><span class="koboSpan" id="kobo.1079.1">Departure = new AirportEvent {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1080.1">    Location = depart,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1081.1">    Time = departTime,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1082.1">  }</span></strong><span class="koboSpan" id="kobo.1083.1">,
};</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.1085.1"> also has a few more compiler errors in the search method due to uses of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">old properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1087.1">
if (s.Depart != null) {
  results =
    results.Where(f =&gt; f.</span><strong class="bold"><span class="koboSpan" id="kobo.1088.1">DepartureLocation</span></strong><span class="koboSpan" id="kobo.1089.1"> == s.Depart);
}</span></pre>
<p><span class="koboSpan" id="kobo.1090.1">These pieces of code will need to reference the new </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">properties instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1092.1">
if (s.Depart != null) {
  results =
    results.Where(f =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1093.1">f.Departure.Location</span></strong><span class="koboSpan" id="kobo.1094.1"> == s.Depart);
}</span></pre>
<p><span class="koboSpan" id="kobo.1095.1">You may </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.1096.1">have noticed that for this simple change of wrapping properties together into a new object we had to make a number of changes just to get the code to </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">compile again.</span></span></p>
<p><span class="koboSpan" id="kobo.1098.1">This can be normal when making structural changes like this, but the compiler supports you on your refactoring journey here by ensuring your code makes structural sense as you make your changes. </span><span class="koboSpan" id="kobo.1098.2">In fact, I wouldn’t be brave enough to make some of these changes without being able to lean a little on the compiler to help me find places where I missed using the old way of doing things. </span><span class="koboSpan" id="kobo.1098.3">I would encourage you to view the compiler as an ally on your </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">refactoring journey.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1100.1">Favoring composition over inheritance</span></h2>
<p><span class="koboSpan" id="kobo.1101.1">Let’s close</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.1102.1"> our discussion on encapsulation by exploring the directive to </span><em class="italic"><span class="koboSpan" id="kobo.1103.1">favor composition over inheritance</span></em><span class="koboSpan" id="kobo.1104.1">. </span><span class="koboSpan" id="kobo.1104.2">This was a phrase I heard a lot in the early days of my career, though it took me a while to grasp its meaning </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">and implications.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">By favoring composition over inheritance, we make a conscious decision that classes should </span><em class="italic"><span class="koboSpan" id="kobo.1107.1">have something</span></em><span class="koboSpan" id="kobo.1108.1"> instead of </span><em class="italic"><span class="koboSpan" id="kobo.1109.1">being something</span></em><span class="koboSpan" id="kobo.1110.1">. </span><span class="koboSpan" id="kobo.1110.2">If a class has another object it can hand off a responsibility instead of relying on inheritance to make the class more special and able to handle a </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">specific scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.1112.1">Let’s look at the flight scheduling system, </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.1114.1">Cloudy Skies Airlines has decided it wants to offer charter flights. </span><span class="koboSpan" id="kobo.1114.2">These are small flights that carry both passengers and cargo paid for by various companies. </span><span class="koboSpan" id="kobo.1114.3">In this case, a charter flight is neither a passenger flight nor a freight flight, but in fact a bit </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">of both.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">A direct implementation of this using inheritance would look something </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
public class CharterFlightInfo : FlightInfoBase {
</span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">  public string CharterCompany { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1120.1">  public string Cargo { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1121.1">  public int Passengers { get; set; }</span></strong><span class="koboSpan" id="kobo.1122.1">
  public override string BuildFlightIdentifier() =&gt;
    base.BuildFlightIdentifier() +
</span><strong class="bold"><span class="koboSpan" id="kobo.1123.1">    $" carrying {Cargo} for {CharterCompany}" +</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1124.1">    $" and {Passengers} passengers";</span></strong><span class="koboSpan" id="kobo.1125.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1126.1">Note here that a single class has both cargo </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">and passengers.</span></span></p>
<p><span class="koboSpan" id="kobo.1128.1">On its own, this isn’t so bad, but what if we wanted our charter flight to hold multiple pieces of cargo? </span><span class="koboSpan" id="kobo.1128.2">We’d now need to have a collection of cargo strings with their charter companies (which might be different from </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">one another).</span></span></p>
<p><span class="koboSpan" id="kobo.1130.1">Any customizations to this cargo or how it would be displayed would require either additional customization of this class or a separate but related class also inheriting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">FlightInfoBase</span></strong><span class="koboSpan" id="kobo.1132.1">. </span><span class="koboSpan" id="kobo.1132.2">It’s not too hard to imagine this system spawning a swarm of related classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">BulkCargoFlightInfo</span></strong><span class="koboSpan" id="kobo.1134.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">ExpressFlightInfo</span></strong><span class="koboSpan" id="kobo.1136.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">MedicalFlightInfo</span></strong><span class="koboSpan" id="kobo.1138.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">HazardousCargoFlightInfo</span></strong><span class="koboSpan" id="kobo.1140.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.1142.1">While this inheritance-based approach would work, using </span><strong class="bold"><span class="koboSpan" id="kobo.1143.1">composition</span></strong><span class="koboSpan" id="kobo.1144.1"> will result in more maintainable code and </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">fewer </span></span><span class="No-Break"><a id="_idIndexMarker324"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1147.1">Composition</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.1148.1"> lets us say that an individual flight is </span><em class="italic"><span class="koboSpan" id="kobo.1149.1">composed of</span></em><span class="koboSpan" id="kobo.1150.1"> cargo items. </span><span class="koboSpan" id="kobo.1150.2">Cargo items can be defined using a simple </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">CargoItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1153.1">
public class CargoItem {
  public string ItemType { get; set; }
  public int Quantity { get; set; }
  public override string ToString() =&gt;
    $"{Quantity} {ItemType}";
}</span></pre>
<p><span class="koboSpan" id="kobo.1154.1">This simple approach stores the item type and its quantity and provides a string representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">the two.</span></span></p>
<p><span class="koboSpan" id="kobo.1156.1">We can then incorporate this into an alternative version </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">CharterFlightInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1160.1">
public class CharterFlightInfo : FlightInfoBase {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1161.1">public List&lt;CargoItem&gt; Cargo { get; } = new();</span></strong><span class="koboSpan" id="kobo.1162.1">
  public override string BuildFlightIdentifier() {
    StringBuilder sb = new(base.BuildFlightIdentifier());
    if (Cargo.Count != 0) {
      sb.Append(" carrying ");
</span><strong class="bold"><span class="koboSpan" id="kobo.1163.1">      foreach (var cargo in Cargo) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1164.1">        sb.Append($"{cargo}, ");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1165.1">      }</span></strong><span class="koboSpan" id="kobo.1166.1">
    }
    return sb.ToString();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1167.1">This approach allows a charter flight to be composed of different cargo items. </span><span class="koboSpan" id="kobo.1167.2">Each item is then displayed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">BuildFlightIdentifier</span></strong><span class="koboSpan" id="kobo.1169.1"> method using its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">ToString</span></strong><span class="koboSpan" id="kobo.1171.1"> method. </span><span class="koboSpan" id="kobo.1171.2">See the </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.1173.1"><img alt="Figure 5.24 – CharterFlightInfo is composed of CargoItems" src="image/B21324_05_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1174.1">Figure 5.24 – CharterFlightInfo is composed of CargoItems</span></p>
<p><span class="koboSpan" id="kobo.1175.1">Composing</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.1176.1"> our charter flight with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">CargoItems</span></strong><span class="koboSpan" id="kobo.1178.1"> gives us additional flexibility. </span><span class="koboSpan" id="kobo.1178.2">Not only does this arrangement pattern allow a charter flight to have multiple cargo items, but it also allows it to do so without you having to declare different classes for different </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">cargo loads.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1180.1">Improving classes with interfaces and polymorphism</span></h1>
<p><span class="koboSpan" id="kobo.1181.1">We’re nearly at the close of this chapter on object-oriented refactoring. </span><span class="koboSpan" id="kobo.1181.2">However, before we close the chapter, let’s discuss a few places where introducing interfaces and polymorphism can help further improve </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">our code.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.1183.1">Extracting interfaces</span></h2>
<p><span class="koboSpan" id="kobo.1184.1">At the </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.1185.1">moment, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">CharterFlightInfo</span></strong><span class="koboSpan" id="kobo.1187.1"> class stores a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1189.1">s representing </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">its cargo:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1191.1">
public class CharterFlightInfo : FlightInfoBase {
</span><strong class="bold"><span class="koboSpan" id="kobo.1192.1">  public List&lt;CargoItem&gt; Cargo { get; } = new();</span></strong><span class="koboSpan" id="kobo.1193.1">
  // Other members omitted...
</span><span class="koboSpan" id="kobo.1193.2">}</span></pre>
<p><span class="koboSpan" id="kobo.1194.1">Each cargo item the charter flight includes must be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1196.1"> or something that inherits from it. </span><span class="koboSpan" id="kobo.1196.2">For example, if we were to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">HazardousCargoItem</span></strong><span class="koboSpan" id="kobo.1198.1"> we discussed in the last section and try to store it in the cargo collection, it </span><em class="italic"><span class="koboSpan" id="kobo.1199.1">must</span></em><span class="koboSpan" id="kobo.1200.1"> inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">CargoItem</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1202.1">to compile.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">In many </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.1204.1">systems, you don’t want to force people to inherit from your classes if they want to customize the system’s behavior. </span><span class="koboSpan" id="kobo.1204.2">In these places, it can be helpful to introduce </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">an interface.</span></span></p>
<p><span class="koboSpan" id="kobo.1206.1">Let’s do that with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1208.1"> class by selecting the class and then choosing </span><strong class="bold"><span class="koboSpan" id="kobo.1209.1">Extract interface…</span></strong><span class="koboSpan" id="kobo.1210.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.1211.1">Quick </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1212.1">Actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1"> menu.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.1214.1"><img alt="Figure 5.25 – Extracting an interface" src="image/B21324_05_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1215.1">Figure 5.25 – Extracting an interface</span></p>
<p><span class="koboSpan" id="kobo.1216.1">Once you’ve done this, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1217.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1218.1">.25</span></em><span class="koboSpan" id="kobo.1219.1">, you now need to specify which members of the class should be included in the interface as well as what the interface should </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">be called:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.1221.1"><img alt="Figure 5.26 – Customizing the extracted interface" src="image/B21324_05_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1222.1">Figure 5.26 – Customizing the extracted interface</span></p>
<p><span class="koboSpan" id="kobo.1223.1">Name your </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.1224.1">interface </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">ICargoItem</span></strong><span class="koboSpan" id="kobo.1226.1">, select both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">ItemType</span></strong><span class="koboSpan" id="kobo.1228.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">Quantity</span></strong><span class="koboSpan" id="kobo.1230.1">, and then click </span><strong class="bold"><span class="koboSpan" id="kobo.1231.1">OK</span></strong><span class="koboSpan" id="kobo.1232.1">. </span><span class="koboSpan" id="kobo.1232.2">This will generate a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">ICargoItem</span></strong><span class="koboSpan" id="kobo.1234.1"> interface in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">new file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1236.1">
public interface ICargoItem {
  string ItemType { get; set; }
  int Quantity { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1237.1">This will also modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1239.1"> to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">this interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1241.1">
public class CargoItem </span><strong class="bold"><span class="koboSpan" id="kobo.1242.1">: ICargoItem</span></strong><span class="koboSpan" id="kobo.1243.1"> {
  public string ItemType { get; set; }
  public int Quantity { get; set; }
  public override string ToString() =&gt;
    $"{Quantity} {ItemType}";
}</span></pre>
<p><span class="koboSpan" id="kobo.1244.1">Note that by default, extracting an interface will introduce both getters and setters on properties. </span><span class="koboSpan" id="kobo.1244.2">If you do not need your interface to expose a way of modifying a property, you can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">set</span></strong><span class="koboSpan" id="kobo.1246.1"> from the property definition in </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">the interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1248.1">
public interface ICargoItem {
  string ItemType </span><strong class="bold"><span class="koboSpan" id="kobo.1249.1">{ get; }</span></strong><span class="koboSpan" id="kobo.1250.1">
  int Quantity </span><strong class="bold"><span class="koboSpan" id="kobo.1251.1">{ get; }</span></strong><span class="koboSpan" id="kobo.1252.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1253.1">Removing the set </span><em class="italic"><span class="koboSpan" id="kobo.1254.1">does not prevent you</span></em><span class="koboSpan" id="kobo.1255.1"> from having a setter on your property in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1257.1">; it just means you’re not </span><em class="italic"><span class="koboSpan" id="kobo.1258.1">required</span></em><span class="koboSpan" id="kobo.1259.1"> to have a setter on </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">the property.</span></span></p>
<p><span class="koboSpan" id="kobo.1261.1">With our new interface </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.1262.1">in hand, let’s go in and modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">CharterFlightInfo</span></strong><span class="koboSpan" id="kobo.1264.1"> to store </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">ICargoItem</span></strong><span class="koboSpan" id="kobo.1266.1">s instead </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">CargoItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">s:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1270.1">
public class CharterFlightInfo : FlightInfoBase {
  public List&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.1271.1">ICargoItem</span></strong><span class="koboSpan" id="kobo.1272.1">&gt; Cargo { get; } = new();
  // Other members omitted...
</span><span class="koboSpan" id="kobo.1272.2">}</span></pre>
<p><span class="koboSpan" id="kobo.1273.1">This change allows us to store anything that implements the interface and improves the flexibility of what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">CharterFlightInfo</span></strong><span class="koboSpan" id="kobo.1275.1"> can store. </span><span class="koboSpan" id="kobo.1275.2">However, this does introduce another interface to your code, which slightly increases the complexity and can slow down development time in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.1277.1">Be careful when introducing interfaces. </span><span class="koboSpan" id="kobo.1277.2">Interfaces that exist for the sake of added abstraction will ultimately do more harm than good in your application. </span><span class="koboSpan" id="kobo.1277.3">However, interfaces that are implemented by more than one class or designed to give another set of developers greater </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.1278.1">freedom or flexibility can ultimately do a lot of good in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">software system.</span></span></p>
<p><span class="koboSpan" id="kobo.1280.1">We’ll talk more about the appropriate place for interfaces in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1281.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.1282.1"> when we explore SOLID. </span><span class="koboSpan" id="kobo.1282.2">For now, let’s move on to a newer feature in </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">C# interfaces.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.1284.1">Providing default interface implementations</span></h2>
<p><span class="koboSpan" id="kobo.1285.1">While we’re </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.1286.1">exploring interfaces, let’s see how </span><strong class="bold"><span class="koboSpan" id="kobo.1287.1">default interface implementations</span></strong><span class="koboSpan" id="kobo.1288.1"> can </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1289.1">simplify the experience of implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">an interface.</span></span></p>
<p><span class="koboSpan" id="kobo.1291.1">Default interface implementations allow you to provide a default implementation inside the interface. </span><span class="koboSpan" id="kobo.1291.2">When a class chooses to implement this interface, it is not </span><em class="italic"><span class="koboSpan" id="kobo.1292.1">forced to</span></em><span class="koboSpan" id="kobo.1293.1"> provide implementations of methods with </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">default implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">Let’s see what this means by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">ManifestText</span></strong><span class="koboSpan" id="kobo.1297.1"> property with a default getter and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">LogManifest</span></strong><span class="koboSpan" id="kobo.1299.1"> method with a default implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">ICargoItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1303.1">
public interface ICargoItem {
  string ItemType { get; }
  int Quantity { get; }
</span><strong class="bold"><span class="koboSpan" id="kobo.1304.1">  string ManifestText =&gt; $"{ItemType} {Quantity}";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1305.1">  void LogManifest() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1306.1">    Console.WriteLine(ManifestText);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1307.1">  }</span></strong><span class="koboSpan" id="kobo.1308.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1309.1">By adding these new members to the interface, we’d normally break anything that implemented the interface, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1311.1"> class, unless it had those members. </span><span class="koboSpan" id="kobo.1311.2">However, because we provided a </span><em class="italic"><span class="koboSpan" id="kobo.1312.1">default implementation</span></em><span class="koboSpan" id="kobo.1313.1"> of both properties, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">CargoItem</span></strong><span class="koboSpan" id="kobo.1315.1"> no longer </span><em class="italic"><span class="koboSpan" id="kobo.1316.1">must</span></em><span class="koboSpan" id="kobo.1317.1"> provide implementations. </span><span class="koboSpan" id="kobo.1317.2">Instead, it effectively inherits these </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">default implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.1319.1">We can still provide a version of these new members. </span><span class="koboSpan" id="kobo.1319.2">If we did, that version would be used instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1320.1">default implementation:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1321.1">CargoItem.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1322.1">
public class CargoItem : ICargoItem {
  public string ItemType { get; set; }
  public int Quantity { get; set; }
</span><strong class="bold"><span class="koboSpan" id="kobo.1323.1">  public void LogManifest() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1324.1">    Console.WriteLine($"Customized: {ToString()}");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1325.1">  }</span></strong><span class="koboSpan" id="kobo.1326.1">
  public override string ToString() =&gt;
    $"{Quantity} {ItemType}";
}</span></pre>
<p><span class="koboSpan" id="kobo.1327.1">I don’t like default interface implementations very much because they confuse the concept of an interface with a contract to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">certain members.</span></span></p>
<p><span class="koboSpan" id="kobo.1329.1">However, I must </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.1330.1">concede that when adding a simple member to an interface, it sometimes makes sense to add a default implementation so that you don’t need to change existing implementations of the interface. </span><span class="koboSpan" id="kobo.1330.2">This can save you from having to add the same code to many different implementations of your interface throughout your solution. </span><span class="koboSpan" id="kobo.1330.3">Additionally, default interface implementations reduce the work needed for classes trying to implement the interface by providing a </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">default implementation.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1332.1">Introducing polymorphism</span></h2>
<p><span class="koboSpan" id="kobo.1333.1">Whenever you are working with an interface, you are intentionally supporting </span><strong class="bold"><span class="koboSpan" id="kobo.1334.1">polymorphism</span></strong><span class="koboSpan" id="kobo.1335.1"> in</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.1336.1"> your application. </span><span class="koboSpan" id="kobo.1336.2">This is the ability to treat different objects based on their similarities instead of on </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">their differences.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">ICargoItem</span></strong><span class="koboSpan" id="kobo.1340.1"> approach</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.1341.1"> introduced earlier with charter flights is an example of polymorphism. </span><span class="koboSpan" id="kobo.1341.2">A charter flight doesn’t care about what type of cargo it has as long as the cargo implements the interface. </span><span class="koboSpan" id="kobo.1341.3">This means that we can load a charter flight full of different types of cargo and the class works fine </span><span class="No-Break"><span class="koboSpan" id="kobo.1342.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.1343.1">The chapter’s code has another place that could strongly benefit from polymorphism: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">FlightScheduler</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">Search</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1347.1">
public IEnumerable&lt;IFlightInfo&gt; Search(FlightSearch s) {
  IEnumerable&lt;IFlightInfo&gt; results = _flights;
  </span><strong class="bold"><span class="koboSpan" id="kobo.1348.1">if (s.Depart != null) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1349.1">    results =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1350.1">      results.Where(f =&gt; f.Departure.Location == s.Depart);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1351.1">  }</span></strong><span class="koboSpan" id="kobo.1352.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1353.1">// Many filters omitted...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1354.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1355.1">if (s.MaxLength != null) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1356.1">    results =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1357.1">      results.Where(f =&gt; f.Duration &lt;= s.MaxLength);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1358.1">  }</span></strong><span class="koboSpan" id="kobo.1359.1">
  return results;
}</span></pre>
<p><span class="koboSpan" id="kobo.1360.1">This method </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.1361.1">has some very repetitive code (much of it omitted) that checks to see if the search object specifies a property. </span><span class="koboSpan" id="kobo.1361.2">If the property was specified, the potential results are filtered down to only include those that match </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">the filter.</span></span></p>
<p><span class="koboSpan" id="kobo.1363.1">The search method uses this approach to filter </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">based on:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1365.1">Departure and </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">arrival locations</span></span></li>
<li><span class="koboSpan" id="kobo.1367.1">Minimum/maximum </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">departure time</span></span></li>
<li><span class="koboSpan" id="kobo.1369.1">Minimum/maximum </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">arrival time</span></span></li>
<li><span class="koboSpan" id="kobo.1371.1">Minimum/maximum </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">flight length</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1373.1">It’s not too hard to imagine new things we might filter for, such as the price of the flight, whether the flight has a beverage service or even the type </span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">of aircraft.</span></span></p>
<p><span class="koboSpan" id="kobo.1375.1">An alternative approach would be to take in a collection of filter objects. </span><span class="koboSpan" id="kobo.1375.2">These filter objects would determine whether each flight should be included in the results through a common </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">FlightFilterBase</span></strong><span class="koboSpan" id="kobo.1377.1"> class and a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">ShouldInclude</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1380.1">
public abstract class FlightFilterBase {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1381.1">public abstract bool ShouldInclude(IFlightInfo flight)</span></strong><span class="koboSpan" id="kobo.1382.1">;
}</span></pre>
<p><span class="koboSpan" id="kobo.1383.1">With this change, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">Search</span></strong><span class="koboSpan" id="kobo.1385.1"> could be modified to loop over all filters and only include results that pass through all the </span><span class="No-Break"><span class="koboSpan" id="kobo.1386.1">provided filters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1387.1">
List&lt;IFlightInfo&gt; Search(</span><strong class="bold"><span class="koboSpan" id="kobo.1388.1">List&lt;FlightFilterBase&gt; rules</span></strong><span class="koboSpan" id="kobo.1389.1">) =&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.1390.1">_flights.Where(f =&gt; rules.All(r =&gt; r.ShouldInclude(f)))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1391.1">          .ToList();</span></strong></pre>
<p><span class="koboSpan" id="kobo.1392.1">This cuts our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">Search</span></strong><span class="koboSpan" id="kobo.1394.1"> method</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.1395.1"> down from over 40 lines long to only 3 lines of code </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">through polymorphism.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1397.1">Alternative implementation</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1398.1">An interface would also work fine instead of an abstract </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.1400.1">By following this design, we can create a series of classes that inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">FlightFilterBase</span></strong><span class="koboSpan" id="kobo.1402.1"> to provide specific </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">filtering capabilities:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.1404.1"><img alt="Figure 5.27 – Distinct filter classes to help simplify our search code" src="image/B21324_05_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1405.1">Figure 5.27 – Distinct filter classes to help simplify our search code</span></p>
<p><span class="koboSpan" id="kobo.1406.1">We now have </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.1407.1">dedicated filters that filter out flights that don’t match their specific criterion. </span><span class="koboSpan" id="kobo.1407.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">AirportFilter</span></strong><span class="koboSpan" id="kobo.1409.1"> would filter out flights that don’t specify </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">an airport:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1411.1">
public class AirportFilter : </span><strong class="bold"><span class="koboSpan" id="kobo.1412.1">FlightFilterBase</span></strong><span class="koboSpan" id="kobo.1413.1"> {
  public bool IsDeparture { get; set; }
  public Airport Airport { get; set; }
</span><strong class="bold"><span class="koboSpan" id="kobo.1414.1">  public override bool ShouldInclude(IFlightInfo flight) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1415.1">    if (IsDeparture) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1416.1">      return flight.Departure.Location == Airport;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1417.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1418.1">    return flight.Arrival.Location == Airport;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1419.1">  }</span></strong><span class="koboSpan" id="kobo.1420.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1421.1">Each individual filter class is small and easy to understand, maintain, </span><span class="No-Break"><span class="koboSpan" id="kobo.1422.1">and test.</span></span></p>
<p><span class="koboSpan" id="kobo.1423.1">Additionally, if we want to add a new way of filtering flights in the future, all we need to do is add a new class inheriting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">FlightFilterBase</span></strong><span class="koboSpan" id="kobo.1425.1">. </span><span class="koboSpan" id="kobo.1425.2">No modifications would be needed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">Search</span></strong><span class="koboSpan" id="kobo.1427.1"> method to support this because all the method needs is a collection of individual filters. </span><span class="koboSpan" id="kobo.1427.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">Search</span></strong><span class="koboSpan" id="kobo.1429.1"> method doesn’t need to know which filters are involved – it just needs to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">ShouldInclude</span></strong><span class="koboSpan" id="kobo.1431.1"> method and interpret </span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.1433.1">I find a lot of beauty in polymorphic solutions and have found my programming style changing over the years in search of more opportunities to take advantage of polymorphism through inheritance </span><span class="No-Break"><span class="koboSpan" id="kobo.1434.1">or interfaces.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.1435.1">Reviewing and testing our refactored code</span></h1>
<p><span class="koboSpan" id="kobo.1436.1">With these </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.1437.1">changes made, let’s take a step back and look at </span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.1439.1">We took a flight search system and used object-oriented programming techniques to improve its flexibility and maintainability by doing </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1441.1">Reorganizing the code into appropriate files </span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">and namespaces</span></span></li>
<li><span class="koboSpan" id="kobo.1443.1">Introducing a base class and improving code reuse in </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">flight information</span></span></li>
<li><span class="koboSpan" id="kobo.1445.1">Controlling a large number of parameters by moving them into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">new class</span></span></li>
<li><span class="koboSpan" id="kobo.1447.1">Introducing another new class to manage common information about airport events including both an airport and a </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">time component</span></span></li>
<li><span class="koboSpan" id="kobo.1449.1">Adding a charter flight class with a flexible cargo </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">tracking system</span></span></li>
<li><span class="koboSpan" id="kobo.1451.1">Introducing a polymorphic way of searching flights that will be more flexible and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">over time</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1453.1">Refactored code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1454.1">The final refactored code from this chapter is available in the </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.1455.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.1456.1"> repository inside of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">Chapter05/Ch5RefactoredCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1459.1">As always, refactoring </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.1460.1">should never be done without testing the code to make sure that no new defects were introduced in the refactoring process. </span><span class="koboSpan" id="kobo.1460.2">Running the tests (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1461.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1462.1">.28</span></em><span class="koboSpan" id="kobo.1463.1">) provided in the solution shows a full slate of passing tests, which will suffice for now until we get to </span><em class="italic"><span class="koboSpan" id="kobo.1464.1">Part 2</span></em><span class="koboSpan" id="kobo.1465.1"> and explore testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1">more depth.</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.1467.1"><img alt="Figure 5.28 – Test Explorer showing that all tests pass" src="image/B21324_05_28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1468.1">Figure 5.28 – Test Explorer showing that all tests pass</span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.1469.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1470.1">In this chapter, we explored the various ways that object-oriented programming techniques such as inheritance, encapsulation, and polymorphism can be used to refactor code toward more </span><span class="No-Break"><span class="koboSpan" id="kobo.1471.1">maintainable forms.</span></span></p>
<p><span class="koboSpan" id="kobo.1472.1">Refactoring can be a complex endeavor, and yet so many of the fundamental concepts of object-oriented programming can come together to build elegant, flexible, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">maintainable solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.1474.1">This concludes </span><em class="italic"><span class="koboSpan" id="kobo.1475.1">Part 1</span></em><span class="koboSpan" id="kobo.1476.1"> of the book. </span><span class="koboSpan" id="kobo.1476.2">In the next part of the book, we’ll look at how testing can give you the safety and freedom needed to safely refactor your code and move forward with confidence that your changes have improved the application without </span><span class="No-Break"><span class="koboSpan" id="kobo.1477.1">breaking anything.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1478.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1479.1">Does your code follow a well-structured and consistent namespace hierarchy with not too many or too few classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1">each namespace?</span></span></li>
<li><span class="koboSpan" id="kobo.1481.1">Is there any part of your code that might be improved by using inheritance to promote </span><span class="No-Break"><span class="koboSpan" id="kobo.1482.1">code reuse?</span></span></li>
<li><span class="koboSpan" id="kobo.1483.1">Can you think of any repetitive rules or other structures in your code that might benefit </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">from polymorphism?</span></span></li>
</ol>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.1485.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1486.1">You can find more information about materials discussed in this chapter at </span><span class="No-Break"><span class="koboSpan" id="kobo.1487.1">these URLs:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1488.1">Inheritance in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1489.1">C#:</span></em></span><span class="No-Break"> </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance"><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1491.1">Sealed </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1492.1">Modifier</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1493.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed"><span class="No-Break"><span class="koboSpan" id="kobo.1494.1">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1495.1">IEquatable&lt;T&gt;:</span></em></span><span class="No-Break"> </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1"><span class="No-Break"><span class="koboSpan" id="kobo.1496.1">https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer087">
<h1 id="_idParaDest-133" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.1.1">Part 2: Refactoring Safely</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In the second part of the book, we’ll cover coding techniques such as unit tests that help ensure your refactoring efforts don’t result in </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">unintentional changes.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This chapter focuses on various testing frameworks and standard testing practices before moving on to discussions about programming best practices and writing </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">SOLID code.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The final two chapters in this part focus on more advanced testing strategies and ways the C# language can help you detect and prevent errors from reaching </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">your users.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">following chapters:</span></span></p>
<ul>
<li><a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Unit Testing</span></em></li>
<li><a href="B21324_07.xhtml#_idTextAnchor161"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, Test-Driven Development</span></em></li>
<li><a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.15.1">, Avoiding Code Anti-Patterns with SOLID</span></em></li>
<li><a href="B21324_09.xhtml#_idTextAnchor189"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.17.1">, Advanced Unit Testing</span></em></li>
<li><a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.19.1">, Defensive Coding Techniques</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer088">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer089">
</div>
</div>
</body></html>