<html><head></head><body>
		<div><h1 id="_idParaDest-97" class="chapter-number"><a id="_idTextAnchor097"/>4</h1>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Advanced MVVM Concepts</h1>
			<p>After learning the basics of the MVVM pattern and its implementation in WinUI, it’s now time to build on that knowledge base to handle some more advanced techniques. Now, you will learn how to keep components loosely coupled and testable when adding new dependencies to the project.</p>
			<p>Few modern applications have only a single page or window. There are MVVM techniques that can be leveraged to navigate between pages from a <code>ViewModel</code> command without being coupled to the UI layer.</p>
			<p>In this chapter, you will learn about the following concepts:</p>
			<ul>
				<li>Understanding the basics of <strong class="bold">Dependency </strong><strong class="bold">Injection</strong> (<strong class="bold">DI</strong>)</li>
				<li>Leveraging DI to expose <code>ViewModel</code> classes to WinUI views</li>
				<li>Using MVVM and <code>x:Bind</code> to handle additional UI events with event handlers in the ViewModel</li>
				<li>Navigating between pages with MVVM and DI</li>
			</ul>
			<p>By the end of this chapter, you will have a deeper understanding of the MVVM pattern and will know how to decouple your view models from any external dependencies.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, please reference the <em class="italic">Technical requirements</em> section in <a href="B20908_02.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Configuring the Development Environment and Creating </em><em class="italic">the Project</em>.</p>
			<p>You will find the code files for this chapter here: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Understanding the basics of DI</h1>
			<p>Before <a id="_idIndexMarker304"/>starting down the path of using DI in our project, we should take some time to understand what DI is and why it is fundamental for building modern applications. You <a id="_idIndexMarker305"/>will often see DI referenced with another related concept, <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>). Let’s discuss these two concepts by doing the following:</p>
			<ul>
				<li>Clarify the relationship between them</li>
				<li>Prepare you to use DI properly in this chapter</li>
			</ul>
			<p>DI is used by modern developers to inject dependent objects into a class rather than creating instances of the objects inside the class. There are several ways to inject those objects:</p>
			<ul>
				<li><strong class="bold">Method injection</strong>: Objects are <a id="_idIndexMarker306"/>passed as parameters to a method in the class</li>
				<li><strong class="bold">Property injection</strong>: Objects <a id="_idIndexMarker307"/>are set through properties</li>
				<li><strong class="bold">Constructor injection</strong>: Objects <a id="_idIndexMarker308"/>are passed as constructor parameters</li>
			</ul>
			<p>The most common method of DI is constructor injection. In this chapter, we will be using both property injection and constructor injection. Method injection will not be used because it is not common to use methods to set a single object’s value in .NET projects. Most developers use properties for this purpose.</p>
			<p>IoC is<a id="_idIndexMarker309"/> the concept that a class should not be responsible for (or have knowledge of) the creation of its dependencies. You’re inverting control over object creation. This sounds a bit like DI, doesn’t it? Well, DI is one method of achieving this IoC in your code. There are other ways to implement IoC, including the following:</p>
			<ul>
				<li><strong class="bold">Delegate</strong>: This <a id="_idIndexMarker310"/>holds a reference to a method that can be used to create and return an object</li>
				<li><strong class="bold">Event</strong>: Like a <a id="_idIndexMarker311"/>delegate, this is typically used in association with user input or other outside actions</li>
				<li><strong class="bold">Service Locator Pattern</strong>: This is<a id="_idIndexMarker312"/> used to inject the implementation of a service at runtime</li>
			</ul>
			<p>When you separate the responsibilities of object creation and use, it facilitates code reuse and increases testability.</p>
			<p>The classes that will be taking advantage of DI in this chapter are views and ViewModels. So, if we will not be creating instances of objects in those classes, where will they be created? Aren’t we just moving the tight coupling somewhere else? In a way, that is true, but the coupling will be minimized by centralizing it to one part of the project, the <code>App.xaml.cs</code> file. If you remember from the previous chapter, the <code>App</code> class is where we handle application-wide actions and data.</p>
			<p>We are going to use a <code>App</code> class to manage the application’s dependencies. A DI container<a id="_idIndexMarker313"/> is responsible for creating and maintaining the lifetime of the objects it manages. The object’s lifetime in the container is usually either <em class="italic">per instance</em> (each object request returns a new instance of the object) or a <em class="italic">singleton</em> (every object request returns the same instance of the object). The container is configured in the <code>App</code> class, and it makes instances available to other classes in the application.</p>
			<p>In .NET 6 and later, DI is now a part of .NET itself. We will leverage the <strong class="bold">host builder</strong> configuration<a id="_idIndexMarker314"/> in .NET to register our application’s dependencies and resolve them in the classes where they are needed.</p>
			<p>There are a <a id="_idIndexMarker315"/>number of other DI implementations that can be leveraged from MVVM frameworks. If you would like to explore some of them, here are their respective links:</p>
			<ul>
				<li><strong class="bold">Unity</strong>: This<a id="_idIndexMarker316"/> DI implementation supports all types of .NET applications and has a full-featured IOC container (<a href="http://unitycontainer.org/articles/introduction.html)&#13;">http://unitycontainer.org/articles/introduction.html)</a></li>
				<li><strong class="bold">DryIoc</strong>: This<a id="_idIndexMarker317"/> small, lightweight IOC container supports .NET Standard 2.0 and .NET 4.5 and later applications (<a href="https://github.com/dadhi/DryIoc">https://github.com/dadhi/DryIoc</a>)</li>
				<li><strong class="bold">Prism</strong>: This <a id="_idIndexMarker318"/>MVVM framework does not support WinUI 3, but developers can still leverage the DI capabilities (<a href="https://prismlibrary.com/docs/dependency-injection/index.html">https://prismlibrary.com/docs/dependency-injection/index.html</a>)</li>
			</ul>
			<p>These concepts will be easier to understand as we implement the code in our application. Now, it’s time to see DI and DI containers in practice.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Using DI with ViewModel classes</h1>
			<p>Most of the popular <a id="_idIndexMarker319"/>MVVM frameworks<a id="_idIndexMarker320"/> today include a DI container to manage dependencies. Because .NET now includes its own DI container, we will use that one. The .NET team has incorporated the DI container that used to be bundled<a id="_idIndexMarker321"/> with <strong class="bold">ASP.NET Core</strong>. It’s both lightweight and easy to use. Luckily, this container is now available to all types of .NET projects via<a id="_idIndexMarker322"/> a <strong class="bold">NuGet</strong> package:</p>
			<ol>
				<li>Open the project from the previous chapter or use the project in the <code>Start</code> folder in the GitHub repository for this chapter. In the <code>MyMediaCollection</code> project, open <code>Microsoft.Extensions.Hosting</code>:</li>
			</ol>
			<div><div><img src="img/B20908_04_01.jpg" alt="Figure 4.1 – Microsoft’s DI NuGet package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Microsoft’s DI NuGet package</p>
			<ol>
				<li value="2">Select the package and install the latest stable version. After the installation completes, close the <code>App.xaml.cs</code>. We will make a few changes here to start using the DI container.<p class="list-inset">The DI container implements DI through interfaces called <code>IHostBuilder</code> and <code>IServiceCollection</code>. As the names imply, they are intended to create a collection of services for the application through a shared host. However, we can add any type of class to the container. Its use is not restricted to services. <code>IServiceCollection</code> builds the container, implementing the <code>IServiceProvider</code> interface. In the following steps, you will add support for DI to the application.</p></li>
				<li>The first thing you should do is add a <code>public</code> property to the <code>App</code> class that makes the host container available to the project:<pre class="source-code">
public static IHost HostContainer { get; private set;
}</pre><p class="list-inset">Here, <code>get</code> is public, but the property has a <code>private set</code> accessor. This restricts the <a id="_idIndexMarker323"/>creation of the container<a id="_idIndexMarker324"/> to the <code>App</code> class. Don’t forget to add the required <code>using</code> statements to the code:</p><pre class="source-code">using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;</pre></li>				<li>The next step is to create a new method that initializes the container, sets it to the <code>public</code> property, and adds our first dependency:<pre class="source-code">
private void RegisterComponents()
{
    HostContainer = Host.CreateDefaultBuilder()
        .ConfigureServices(services =&gt;
    {
        services.AddTransient&lt;MainViewModel&gt;();
    }).Build();
}</pre><p class="list-inset">In the new <code>RegisterComponents</code> method, we are creating <code>HostContainer</code> and its service collection, registering <code>MainViewModel</code> as a <code>Build</code> method to create and return the DI container. Although it’s not strictly required, when adding multiple types to the container, it’s a good practice to add dependent objects to the service collection first. We’ll be adding more items to the container soon.</p></li>				<li>Finally, you will call <code>RegisterComponents</code> before creating the instance of <code>MainWindow</code> in the <code>App.OnLaunched</code> event handler:<pre class="source-code">
protected override void
OnLaunched(LaunchActivatedEventArgs args)
{
<strong class="bold">    RegisterComponents();</strong>
<strong class="bold">    m_window = new MainWindow();</strong>
    m_window.Activate();
}</pre></li>			</ol>
			<p>That’s all the <a id="_idIndexMarker325"/>code needed to create and expose <a id="_idIndexMarker326"/>the DI container to the application. Now that we are delegating the creation of <code>MainViewModel</code> to the container, you can remove the property that exposes a static instance of <code>MainViewModel</code> from the <code>App</code> class.</p>
			<p>Using the ViewModel controlled by the container is simple. Go ahead and open <code>MainWindow.xaml.cs</code> and update the <code>ViewModel</code> property to remove the initialization. Then, set the value of the <code>ViewModel</code> property using <code>HostContainer.Services.GetService</code> from the <code>App</code> class before the call to <code>InitializeComponent</code>:</p>
			<pre class="source-code">
public MainWindow()
{
    ViewModel = App.HostContainer.Services
      .GetService&lt;MainViewModel&gt;();
    this.InitializeComponent();
}
public MainViewModel ViewModel;</pre>			<p>If you build and run the application now, it will work just as it did before. However, now our <code>MainViewModel</code> instance will be registered in the <code>App</code> class and managed by the container. As new models, view models, services, and other dependencies are added to the project, they can be<a id="_idIndexMarker327"/> added to the <code>HostContainer</code> in <a id="_idIndexMarker328"/>the <code>RegisterComponents</code> method.</p>
			<p>We will be adding page navigation to the app<a id="_idIndexMarker329"/> later in this chapter. First, let’s discuss the <strong class="bold">event-to-command</strong> pattern.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Leveraging x:Bind with events</h1>
			<p>In the previous chapter, we bound <code>ViewModel</code> commands to the <code>Command</code> properties of the <code>Command</code> property? For<a id="_idIndexMarker330"/> this scenario, you have two <a id="_idIndexMarker331"/>options:</p>
			<ul>
				<li>Use a custom behavior such as <code>EventToCommandBehavior</code> in the .NET MAUI Community Toolkit. This allows you to wire up a command in the ViewModel to any event.</li>
				<li>Use <code>x:Bind</code> in the view to bind directly to an event handler on the view model.</li>
			</ul>
			<p>In this application, we will use <code>x:Bind</code>. This option will provide compile-time type checking and added performance. If you want to learn more about the .NET MAUI Community Toolkit, you can read the documentation<a id="_idIndexMarker332"/> on Microsoft Learn: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior">https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior</a>.</p>
			<p>We want to<a id="_idIndexMarker333"/> provide users of the <strong class="bold">My Media Collection</strong> application <a id="_idIndexMarker334"/>with the option to double-click (or double-tap) a row on the list to view or edit its details. The new <strong class="bold">Item Details</strong> window will be added in the next section. Until then, double-clicking an item will invoke the same code as the <strong class="bold">Add Item</strong> button, as this will become the <strong class="bold">Add/Edit Item</strong> button later:</p>
			<ol>
				<li>Start by adding an <code>ItemRowDoubleTapped</code> event handler to the <code>MainViewModel</code> class that calls the existing <code>AddEdit</code> method:<pre class="source-code">
public void ListViewDoubleTapped(object sender,
DoubleTappedRoutedEventArgs args)
{
    AddEdit();
}</pre></li>				<li>Next, bind the <code>ListView.DoubleTapped</code> event to the ViewModel:<pre class="source-code">
&lt;ListView Grid.Row="1" ItemsSource="{x:Bind
    ViewModel.Items}"
    SelectedItem="{x:Bind
    ViewModel.SelectedMediaItem,
    Mode=TwoWay}"
    <strong class="bold">DoubleTapped="{x:Bind ViewModel</strong>
<code>Grid</code> inside <code>ListView.ItemTemplate</code> to set the <code>IsHitTestVisible</code> property to <code>False</code>:<pre class="source-code">
&lt;ListView.ItemTemplate&gt;
    &lt;DataTemplate x:DataType="model:MediaItem"&gt;
        &lt;Grid <strong class="bold">IsHitTestVisible="False"</strong>&gt;
            ...
        &lt;/Grid&gt;
    &lt;/DataTemplate&gt;
&lt;/ListView.ItemTemplate&gt;</pre></li>			</ol>
			<p>Now when<a id="_idIndexMarker335"/> you run the application, you can either click the <strong class="bold">Add Item</strong> button<a id="_idIndexMarker336"/> or double-click a row in the list to add new items. In the next section, you will update the <strong class="bold">Add Item</strong> button to be an <strong class="bold">Add/Edit </strong><strong class="bold">Item</strong> button.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Page navigation with MVVM and DI</h1>
			<p>Until this point, the <a id="_idIndexMarker337"/>application has consisted of only a single window. Now it’s time to implement page navigation by adding a host <code>Frame</code> and two <code>Page</code> objects so we can handle adding new items or editing existing items. The new <code>Page</code> will be accessible from the <strong class="bold">Add/Edit Item</strong> button or by double-clicking on an item in the list.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Migrating MainWindow to MainPage</h2>
			<p>If you’re familiar with <a id="_idIndexMarker338"/>UWP app development, you should already understand page navigation. In UWP, the application consists of only a single window. At the root of the window, there is a <code>Frame</code> object, which hosts pages and handles the navigation between them. To achieve the same result in a desktop WinUI 3 app, we will create a new <code>MainPage</code>, move all the XAML content from <code>MainWindow</code> into <code>MainPage</code>, and update the <code>App</code> class to create a <code>Frame</code> as the new content of <code>MainWindow</code>. Then we can display the same contents by navigating to <code>MainPage</code>. Let’s get started:</p>
			<ol>
				<li>First, add a new folder to the project named <code>Views</code>.</li>
				<li>Right-click the <strong class="bold">Views</strong> folder and select <strong class="bold">Add</strong> | <strong class="bold">New Item</strong>.</li>
				<li>On the <code>MainPage</code> and click <strong class="bold">Create</strong>.</li>
				<li>Open <code>MainWindow.xaml</code> and cut the entire XAML contents of the <code>Window</code>.</li>
				<li>Open <code>MainPage.xaml</code> and paste the XAML from <code>MainWindow</code>, replacing the empty <code>Grid</code> control.</li>
				<li>You will also need to cut and paste the <code>xmlns</code> declaration for <code>model</code> from <code>MainWindow</code> to <code>MainPage</code>:<pre class="source-code">
xmlns:model="using:MyMediaCollection.Model"</pre></li>				<li>In <code>MainWindow.xaml.cs</code>, remove the <code>ViewModel</code> variable and the constructor code that fetches it from the <code>HostContainer</code>. Put this same code into <code>MainPage.xaml.cs</code>:<pre class="source-code">
public MainPage()
{
    ViewModel = App.HostContainer.Services.GetService
      &lt;MainViewModel&gt;();
    this.InitializeComponent();
}
public MainViewModel ViewModel;</pre></li>				<li>Next, open <code>App.xaml.cs</code> and add some code inside <code>OnLaunched</code> to create a <code>rootFrame</code>, add it to the <code>MainWindow</code>, and navigate to <code>MainPage</code> before activating the <a id="_idIndexMarker339"/>window:<pre class="source-code">
protected override void OnLaunched
  (LauchActivatedEventArgs args)
{
    m_window = new MainWindow();
    var rootFrame = new Frame();
    RegisterComponents();
    rootFrame.NavigationFailed +=
      RootFrame_NavigationFailed;
    rootFrame.Navigate(typeof(MainPage), args);
    m_window.Content = rootFrame;
    m_window.Activate();
}
private void RootFrame_NavigationFailed(object sender,
  NavigationFailedEventArgs e)
{
    throw new Exception($"Error loading page
      {e.SourcePageType.FullName}");
}</pre><p class="list-inset">We’ve also added an event handler to handle navigation failures for the <code>Frame</code>.</p></li>				<li>Make sure to<a id="_idIndexMarker340"/> add the necessary <code>using</code> statements to the file:<pre class="source-code">
using System;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Navigation;
using MyMediaCollection.Views;</pre></li>			</ol>
			<p>If you run the app now, it should look and behave just as it did before, but now the controls are nested within a <code>Page</code> and a <code>Frame</code> on the <code>Window</code>. Let’s add a second page and get ready to start navigating between our list and detail pages.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Adding ItemDetailsPage</h2>
			<p>The full <code>ItemDetailsPage.xaml</code> code <a id="_idIndexMarker341"/>can be found on GitHub (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml</a>). You can follow along with the steps in this section or review the final code on GitHub.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The project will not compile successfully until we have added the new ViewModel to the project and added it to the DI container for consumption by the view. Before we add the ViewModel, we need to create some services to enable navigation and data persistence between views.</p>
			<p>We will be<a id="_idIndexMarker342"/> showing <code>Page</code> control. The <code>Page</code> will be set as the content and navigated to by the <code>Frame</code> we created. For more information about page navigation with WinUI, you can read this Microsoft Learn article: <a href="https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk">https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk</a>.</p>
			<p>To add <code>ItemDetailsPage</code>, follow these steps:</p>
			<ol>
				<li>Right-click the <strong class="bold">Views</strong> folder in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong> | <strong class="bold">New Item</strong>.</li>
				<li>On the new item dialog, select <code>ItemDetailsPage</code>.</li>
				<li>There are going to be several input controls with some common attributes on the page. Start by adding three styles to a <code>Page.Resources</code> section just before the top-level <code>Grid</code> control:<pre class="source-code">
&lt;Page.Resources&gt;
    &lt;Style x:Key="AttributeTitleStyle"
      TargetType="TextBlock"&gt;
        &lt;Setter Property="HorizontalAlignment"
          Value="Right"/&gt;
        &lt;Setter Property="VerticalAlignment"
          Value="Center"/&gt;
    &lt;/Style&gt;
    &lt;Style x:Key="AttributeValueStyle"
       TargetType="TextBox"&gt;
        &lt;Setter Property="HorizontalAlignment"
          Value="Stretch"/&gt;
        &lt;Setter Property="Margin" Value="8"/&gt;
    &lt;/Style&gt;
    &lt;Style x:Key="AttributeComboxValueStyle"
       TargetType="ComboBox"&gt;
        &lt;Setter Property="HorizontalAlignment"
          Value="Stretch"/&gt;
        &lt;Setter Property="Margin" Value="8"/&gt;
    &lt;/Style&gt;
&lt;/Page.Resources&gt;</pre><p class="list-inset">In the <a id="_idIndexMarker343"/>next step, we can assign <code>AttributeTitleStyle</code> to each <code>TextBlock</code>, <code>AttributeValueStyle</code> to each <code>TextBox</code>, and <code>AttributeComboValueStyle</code> to each <code>ComboBox</code>. If you need to add any other attributes to input labels later, you will only update <code>AttributeTitleStyle</code> and the attributes will automatically be applied to every <code>TextBlock</code> using that style.</p></li>				<li>The top-level <code>Grid</code> will contain three child <code>Grid</code> controls to partition the view into three areas—a header, the input controls, and the <code>Grid.RowDefinitions</code> like this:<pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
    &lt;RowDefinition Height="Auto"/&gt;
&lt;/Grid.RowDefinitions&gt;</pre></li>				<li>The header area will contain only a <code>TextBlock</code>. You are welcome to design this area however you like:<pre class="source-code">
&lt;TextBlock Text="Item Details" FontSize="18"
Margin="8"/&gt;</pre></li>				<li>The input area<a id="_idIndexMarker344"/> contains a <code>Grid</code> with four <code>RowDefinitions</code> and two <code>ColumnDefinitions</code> for the labels and input controls for the four fields that users can currently edit:<pre class="source-code">
&lt;Grid Grid.Row="1"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="200"/&gt;
        &lt;ColumnDefinition Width="*"/&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;TextBlock Text="Name:" Style="{StaticResource
      AttributeTitleStyle}"/&gt;
    &lt;TextBox Grid.Column="1"
        Style="{StaticResource AttributeValueStyle}"
        Text="{x:Bind ViewModel.ItemName, Mode=TwoWay,
UpdateSourceTrigger=PropertyChanged}"/&gt;
    &lt;TextBlock Text="Media Type:" Grid.Row="1"
        Style="{StaticResource AttributeTitleStyle}"/&gt;
    &lt;ComboBox Grid.Row="1" Grid.Column="1"
        Style="{StaticResource AttributeCombox
          ValueStyle}"
        ItemsSource="{x:Bind ViewModel.ItemTypes}"
        SelectedValue="{x:Bind ViewModel
          .SelectedItemType, Mode=TwoWay}"/&gt;
    &lt;TextBlock Text="Medium:" Grid.Row="2"
        Style="{StaticResource AttributeTitleStyle}"/&gt;
    &lt;ComboBox Grid.Row="2" Grid.Column="1"
        Style="{StaticResource
          AttributeComboxValueStyle}"
        ItemsSource="{x:Bind ViewModel.Mediums}"
        SelectedValue="{x:Bind ViewModel
          .SelectedMedium, Mode=TwoWay}"/&gt;
    &lt;TextBlock Text="Location:" Grid.Row="3"
        Style="{StaticResource AttributeTitleStyle}"/&gt;
    &lt;ComboBox Grid.Row="3" Grid.Column="1"
        Style="{StaticResource
          AttributeComboxValueStyle}"
        ItemsSource="{x:Bind ViewModel.LocationTypes}"
        SelectedValue="{x:Bind ViewModel
          .SelectedLocation,Mode=TwoWay}"/&gt;
&lt;/Grid&gt;</pre></li>				<li>The item’s <code>Name</code> is a free-text entry field, while the others are <code>ComboBox</code> controls to <a id="_idIndexMarker345"/>allow the user to pick values from lists bound to <code>ItemsSource</code>. The final child element of the top-level <code>Grid</code> is a right-aligned horizontal <code>StackPanel</code> containing the <strong class="bold">Save</strong> and <strong class="bold">Cancel</strong> buttons:<pre class="source-code">
&lt;StackPanel Orientation="Horizontal"
        Grid.Row="2" HorizontalAlignment="Right"&gt;
    &lt;Button Content="Save" Margin="8,8,0,8"
        Command="{x:Bind ViewModel.SaveCommand}"/&gt;
    &lt;Button Content="Cancel" Margin="8"
        Command="{x:Bind ViewModel.CancelCommand}"/&gt;
&lt;/StackPanel&gt;</pre></li>			</ol>
			<p>The next stage is to add interfaces and services, so let’s work on this next.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Adding new interfaces and services</h2>
			<p>Now that <a id="_idIndexMarker346"/>we have more than a single page to manage in the application, we need some services to centralize the page management and abstract the details from the <code>ViewModel</code> code. Start by creating <code>Services</code> and <code>Interfaces</code> folders in the project. Each service will implement an interface. This interface will be used for DI and later, if you were to add unit tests to a test project.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Creating a navigation service</h2>
			<p>The first service <a id="_idIndexMarker347"/>we need is a <code>INavigationService</code> interface in the <code>Interfaces</code> folder. The interface defines methods to get the current page name, navigate to a specific page, or navigate back to the previous page:</p>
			<pre class="source-code">
public interface INavigationService
{
string CurrentPage { get; }
void NavigateTo(string page);
void NavigateTo(string page, object parameter);
void GoBack();
}</pre>			<p>Now, create a <code>NavigationService</code> class in the <code>Services</code> folder. In the class definition, make sure that <code>NavigationService</code> implements the <code>INavigationService</code> interface. The full class can be viewed on GitHub (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs</a>). Let’s discuss a few highlights.</p>
			<p>The purpose of a navigation service in MVVM is to store a collection of available pages in the application so that when its <code>NavigateTo</code> method is called, the service can find a page that matches the requested <code>Name</code> or <code>Type</code> and navigate to it.</p>
			<p>The collection of pages will be stored in a <code>ConcurrentDictionary&lt;T&gt;</code> collection. The <code>ConcurrentDictionary&lt;T&gt;</code> functions like the standard <code>Dictionary&lt;T&gt;</code>, but it can automatically add locks to prevent changes to the dictionary simultaneously across multiple threads:</p>
			<pre class="source-code">
private readonly IDictionary&lt;string, Type&gt; _pages = new
ConcurrentDictionary&lt;string, Type&gt;();</pre>			<p>The <code>Configure</code> method will be called when you create <code>NavigationService</code> before adding it to the DI <a id="_idIndexMarker348"/>container. This method is not a part of the <code>INavigationService</code> interface and will not be available to classes that consume the service from the container. There is a check here to ensure views are only added to the service once. We check the dictionary to determine whether any pages of the same data type exist. If this condition is <code>true</code>, then the page has already been registered:</p>
			<pre class="source-code">
public void Configure(string page, Type type)
{
    if (_pages.Values.Any(v =&gt; v == type))
    {
        throw new ArgumentException($"The {type.Name} view
          has already been registered under another
            name.");
    }
    _pages[page] = type;
}</pre>			<p>These are the implementations of the three navigation methods in the service. The two <code>NavigateTo</code> methods navigate to a specific page, with the second providing the ability to pass a parameter to the page. The third is <code>GoBack</code>, which does what you would think: it navigates to the previous page in the application. They wrap the <code>Frame</code> navigation calls to abstract the UI implementation from the view models that will be consuming this service:</p>
			<pre class="source-code">
public void NavigateTo(string page)
{
    NavigateTo(page, null);
}
public void NavigateTo(string page, object parameter)
{
    if (!_pages.ContainsKey(page))
    {
        throw new ArgumentException($"Unable to find a page
          registered with the name {page}.");
    }
    AppFrame.Navigate(_pages[page], parameter);
}
public void GoBack()
{
    if (AppFrame?.CanGoBack == true)
    {
        AppFrame.GoBack();
    }
}</pre>			<p>We’re ready to <a id="_idIndexMarker349"/>start using <code>NavigationService</code>, but first, let’s create a data service for the application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can jump ahead to implementing the services in the next section if you like. The <code>DataService</code> and <code>IDataService</code> code is available in the completed solution on GitHub: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection</a>.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Creating a data service</h2>
			<p>The<a id="_idIndexMarker350"/> data on <code>MainPage</code> of <code>MainViewModel</code>. This isn’t going to work very well across multiple pages. By using a data service, view models will not need to know how the data is created or stored.</p>
			<p>For now, the<a id="_idIndexMarker351"/> data will still be sample records that are not saved between sessions. Later, we can update the data service to save and load data from a database without any changes to the view models that use the data.</p>
			<p>The first step is to add an interface named <code>IDataService</code> to the <code>Interfaces</code> folder:</p>
			<pre class="source-code">
public interface IDataService
{
    IList&lt;MediaItem&gt; GetItems();
    MediaItem GetItem(int id);
    int AddItem(MediaItem item);
    void UpdateItem(MediaItem item);
    IList&lt;ItemType&gt; GetItemTypes();
    Medium GetMedium(string name);
    IList&lt;Medium&gt; GetMediums();
    IList&lt;Medium&gt; GetMediums(ItemType itemType);
    IList&lt;LocationType&gt; GetLocationTypes();
    int SelectedItemId { get; set; }
}</pre>			<p>These methods should look familiar to you from previous chapters, but let’s briefly review the purpose of each:</p>
			<ul>
				<li><code>GetItems</code>: Returns all the available media items</li>
				<li><code>GetItem</code>: Finds a media item with the provided <code>id</code></li>
				<li><code>AddItem</code>: Adds a new media item to the collection</li>
				<li><code>UpdateItem</code>: Updates a media item in the collection</li>
				<li><code>GetItemTypes</code>: Gets the list of media item types</li>
				<li><code>GetMedium</code>: Gets a <code>Medium</code> with the provided name</li>
				<li><code>GetMediums</code>: These two methods either get all available mediums or any available for the provided <code>ItemType</code></li>
				<li><code>GetLocationTypes</code>: Gets all the available media locations</li>
				<li><code>SelectedItemId</code>: Persists the ID of the selected item on <code>MainPage</code></li>
			</ul>
			<p>Now, create the <code>DataService</code> class in the <code>Services</code> folder. Make sure that <code>DataService</code> implements <code>IDataService</code> in the class definition.</p>
			<p>Again, we will only <a id="_idIndexMarker352"/>review parts of the code. You can review the entire implementation on GitHub (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs</a>). The data in <code>DataService</code> will be persisted in four lists and the <code>SelectedItemId</code> property:</p>
			<pre class="source-code">
private IList&lt;MediaItem&gt; _items;
private IList&lt;ItemType&gt; _itemTypes;
private IList&lt;Medium&gt; _mediums;
private IList&lt;LocationType&gt; _locationTypes;
public int SelectedItemId { get; set; }</pre>			<p>Copy the <code>PopulateItems</code> method from <code>MainViewModel</code> and modify it to use <code>List&lt;T&gt;</code> collections and add the <code>Location</code> property assignment to each item.</p>
			<p>Start by creating the three <code>MediaItem</code> objects:</p>
			<pre class="source-code">
var cd = new MediaItem
{
    Id = 1,
    Name = "Classical Favorites",
    MediaType = ItemType.Music,
    MediumInfo = _mediums.FirstOrDefault(m =&gt; m.Name ==
      "CD"),
    Location = LocationType.InCollection
};
var book = new MediaItem
{
    Id = 2,
    Name = "Classic Fairy Tales",
    MediaType = ItemType.Book,
    MediumInfo = _mediums.FirstOrDefault(m =&gt; m.Name ==
      "Hardcover"),
    Location = LocationType.InCollection
};
var bluRay = new MediaItem
{
    Id = 3,
    Name = "The Mummy",
    MediaType = ItemType.Video,
    MediumInfo = _mediums.FirstOrDefault(m =&gt; m.Name ==
      "Blu Ray"),
    Location = LocationType.InCollection
};</pre>			<p>Then, initialize<a id="_idIndexMarker353"/> the <code>_items</code> list and add the three <code>MediaItem</code> objects you just created:</p>
			<pre class="source-code">
_items = new List&lt;MediaItem&gt;
{
    cd,
    book,
    bluRay
};</pre>			<p>There are <a id="_idIndexMarker354"/>three other methods to pre-populate the sample data: <code>PopulateMediums</code>, <code>Populate</code><code> ItemTypes</code>, and <code>PopulateLocationTypes</code>. All of these are called from the <code>Data</code><code> Service</code> constructor. These methods will be updated later to use an <strong class="bold">SQLite</strong> data store<a id="_idIndexMarker355"/> for data persistence.</p>
			<p>Most of the <code>Get</code> method implementations are very straightforward. The <code>GetMediums(ItemType itemType)</code> method uses <code>Medium</code> objects for the selected <code>ItemType</code>:</p>
			<pre class="source-code">
public IList&lt;Medium&gt; GetMediums(ItemType itemType)
{
    return _mediums
        .Where(m =&gt; m.MediaType == itemType)
        .ToList();
}</pre>			<p class="callout-heading">Note</p>
			<p class="callout">If you are not familiar with<a id="_idIndexMarker357"/> LINQ expressions, Microsoft has some good documentation on the topic: <a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/">https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/</a>.</p>
			<p>The <code>AddItem</code> and <code>UpdateItems</code> methods are also simple. They add to and update the <code>_items</code> collection:</p>
			<pre class="source-code">
public int AddItem(MediaItem item)
{
    item.Id = _items.Max(i =&gt; i.Id) + 1;
    _items.Add(item);
    return item.Id;
}
public void UpdateItem(MediaItem item)
{
    var idx = -1;
    var matchedItem = (from x in _items
                       let ind = idx++
                       where x.Id == item.Id
                       select ind).FirstOrDefault();
    if (idx == -1)
    {
        throw new Exception("Unable to update item. Item
          not found in collection.");
    }
    _items[idx] = item;
}</pre>			<p>The <code>AddItem</code> method <a id="_idIndexMarker358"/>has some basic logic to find the highest <code>Id</code> and increment it by <code>1</code> to use at the new item’s <code>Id</code>. <code>Id</code> is also returned to the calling method in case the caller needs the information.</p>
			<p>The services are all created. It is time to set them up when the application launches and consume them in the view models.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Increasing maintainability by consuming services</h2>
			<p>Before using the<a id="_idIndexMarker359"/> services in view models, open the <code>RegisterServices</code> method in <code>App.xaml.cs</code> and add the following code to register the new services in the DI container and register a new <code>ItemDetailsViewModel</code> (yet to be created). We’re also adding a parameter to the method to pass along to the constructor of the <code>NavigationService</code>. This will provide access to the <code>Frame</code> for page navigation:</p>
			<pre class="source-code">
private IServiceProvider RegisterServices(Frame rootFrame)
{
var navigationService = new NavigationService(rootFrame);
navigationService.Configure(nameof(MainPage),
typeof(MainPage));
navigationService.Configure(nameof(ItemDetailsPage),
typeof(ItemDetailsPage));
HostContainer = Host.CreateDefaultBuilder()
    .ConfigureServices(services =&gt;
    {
        services.AddSingleton&lt;INavigationService&gt;
          (navigationService);
        services.AddSingleton&lt;IDataService, DataService&gt;();
        services.AddTransient&lt;MainViewModel&gt;();
        services.AddTransient&lt;ItemDetailsViewModel&gt;();
    }).Build();
}</pre>			<p>Both <code>INavigationService</code> and <code>IDataService</code> are registered<a id="_idIndexMarker360"/> as <strong class="bold">singletons</strong>. This means that there will be <a id="_idIndexMarker361"/>only a single instance of each stored in the container. Any state held in these services is shared across all classes that consume them.</p>
			<p>You will<a id="_idIndexMarker362"/> notice that when we’re registering <code>INavigationService</code>, we are passing the instance we already created to the constructor. This is a feature of Microsoft’s DI container and most other DI containers. It allows for initialization and configuration of instances before they’re added to the container.</p>
			<p>We need to make a few changes to <code>MainViewModel</code> to consume <code>IDataService</code> and <code>INavigationService</code>, update the <code>PopulateData</code> method, and navigate to <code>ItemDetailsPage</code> when <code>AddEdit()</code> is invoked:</p>
			<ol>
				<li>Start by adding properties to <code>MainViewModel</code> for <code>INavigationService</code> and <code>IDataService</code>:<pre class="source-code">
private INavigationService _navigationService;
private IDataService _dataService;</pre><p class="list-inset">Don’t forget to add a <code>using</code> statement for <code>MyMediaCollection.Interfaces</code>.</p></li>				<li>Next, update the constructor to receive and store the services:<pre class="source-code">
public MainViewModel(<strong class="bold">INavigationService</strong>
<strong class="bold">navigationService, IDataService dataService</strong>)
{
<strong class="bold">    _navigationService = navigationService;</strong>
<strong class="bold">    _dataService = dataService;</strong>
    PopulateData();
}</pre><p class="list-inset">Wait, we’ve added two parameters to the constructor but haven’t changed the code that adds them to the DI container. How does that work? Well, the container is smart enough to pass them because both of those interfaces are also registered. Pretty cool!</p></li>				<li>Next, update <code>PopulateData</code> to get the <a id="_idIndexMarker363"/>data the view model needs from <code>_dataService</code>:<pre class="source-code">
public void PopulateData()
{
    items.Clear();
    foreach(var item in _dataService.GetItems())
    {
        items.Add(item);
    }
    allItems = new
    ObservableCollection&lt;MediaItem&gt;(Items);
    mediums = new ObservableCollection&lt;string&gt;
    {
        AllMediums
    };
    foreach(var itemType in _dataService
      .GetItemTypes())
    {
        mediums.Add(itemType.ToString());
    }
    selectedMedium = Mediums[0];
}</pre><p class="list-inset">You need to add the <code>AllMediums</code> string constant with a value of <code>"All"</code> to the <code>mediums</code> collection because it’s not part of the persisted data. It’s only needed for the UI filter. Be sure to add this constant definition to <code>MainViewModel</code>.</p></li>				<li>Finally, when the<a id="_idIndexMarker364"/> hidden <code>AddEditCommand</code> calls the <code>AddEdit</code> method, instead of adding hardcoded items to the collection, you will pass <code>selectedItemId</code> as a parameter when navigating to <code>ItemDetailsPage</code>:<pre class="source-code">
private void AddEdit()
{
    var selectedItemId = -1;
    if (SelectedMediaItem != null)
    {
        selectedItemId = SelectedMediaItem.Id;
    }
    _navigationService.NavigateTo("ItemDetailsPage",
      selectedItemId);
}</pre></li>			</ol>
			<p>That’s it for <code>MainViewModel</code>. Now let’s work on the <code>ItemDetailsPage</code>.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>Handling parameters in ItemDetailsPage</h2>
			<p>To accept a <a id="_idIndexMarker365"/>parameter passed from another page during navigation, you must override the <code>OnNavigatedTo</code> method in <code>ItemDetailsPage.xaml.cs</code>. The <code>NavigationEventArgs</code> parameter contains a property named <code>Parameter</code>. In our case, we passed an <code>int</code> containing the selected item’s <code>Id</code>. Cast this <code>Parameter</code> property to <code>int</code> and pass it to a method on the <code>ViewModel</code> named <code>InitializeItemDetailData</code>, which will be created in the next section:</p>
			<pre class="source-code">
protected override void OnNavigatedTo(NavigationEventArgs
e)
{
    base.OnNavigatedTo(e);
    var itemId = (int)e.Parameter;
    if (itemId &gt; 0)
    {
        ViewModel.InitializeItemDetailData(itemId);
    }
}</pre>			<p>In the <a id="_idIndexMarker366"/>next section, we’ll add the final piece of the puzzle, the <code>ItemDetailsViewModel</code> class.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Creating the ItemDetailsViewModel class</h2>
			<p>To add or <a id="_idIndexMarker367"/>edit items in the application, you will need a view model to bind to <code>ItemDetails</code><code> Page</code>. Right-click the <code>ViewModels</code> folder in <code>ItemDetailsViewModel</code>.</p>
			<p>The class will inherit from <code>ObservableObject</code> like <code>MainViewModel</code>. The full class can be found on GitHub at <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs</a>. Let’s review some of the important members of the class.</p>
			<p>The constructor receives the two services from the container and calls <code>PopulateLists</code> to populate <code>ComboBox</code> data from the data service:</p>
			<pre class="source-code">
public ItemDetailsViewModel(INavigationService
  navigationService, IDataService dataService)
{
    _navigationService = navigationService;
    _dataService = dataService;
    PopulateLists();
}</pre>			<p>A <code>public</code> method <a id="_idIndexMarker368"/>named <code>InitializeItemDetailData</code> will accept the <code>itemId</code> parameter passed by <code>ItemDetailsPage.OnNavigatedTo</code>. It will call methods to populate the lists and initializes an <code>IsDirty</code> flag to enable or disable the <code>SaveCommand</code>:</p>
			<pre class="source-code">
public void InitializeItemDetailData(int itemId)
{
    _selectedItemId = itemId;
    PopulateExistingItem(_dataService);
    IsDirty = false;
}</pre>			<p>The <code>PopulateExistingItem</code> method will add existing item data if the page is in edit mode, and <code>PopulateLists</code>, called from the constructor, fills the drop-down data to be bound to the view:</p>
			<pre class="source-code">
private void PopulateExistingItem(IDataService dataService)
{
    if (_selectedItemId &gt; 0)
    {
        var item = _dataService.GetItem(_selectedItemId);
        Mediums.Clear();
        foreach (string medium in dataService.GetMediums
          (item.MediaType).Select(m =&gt; m.Name))
            Mediums.Add(medium);
        _itemId = item.Id;
        ItemName = item.Name;
        SelectedMedium = item.MediumInfo.Name;
        SelectedLocation = item.Location.ToString();
        SelectedItemType = item.MediaType.ToString();
    }
}
private void PopulateLists()
{
    ItemTypes.Clear();
    foreach (string iType in Enum.GetNames
      (typeof(ItemType)))
        ItemTypes.Add(iType);
    LocationTypes.Clear();
    foreach (string lType in Enum.GetNames
      (typeof(LocationType)))
        LocationTypes.Add(lType);
    Mediums = new TestObservableCollection&lt;string&gt;();
}</pre>			<p>Most of this view model’s properties are straightforward, but <code>SelectedItemType</code> has some logic to repopulate the list of <code>Mediums</code> based on the <code>ItemType</code> selected. For instance, if you are adding a book to the collection, there’s no need to see the DVD or CD mediums in the<a id="_idIndexMarker369"/> selection list. We’ll handle this custom logic in <code>OnSelectedItemTypeChanged</code>:</p>
			<pre class="source-code">
partial void OnSelectedItemTypeChanged(string value)
{
    IsDirty = true;
    Mediums.Clear();
    if (!string.IsNullOrWhiteSpace(value))
    {
        foreach (string med in _dataService.GetMediums
          ((ItemType)Enum.Parse(typeof(ItemType),
            SelectedItemType)).Select(m =&gt; m.Name))
            Mediums.Add(med);
    }
}</pre>			<p>Lastly, let’s look at <a id="_idIndexMarker370"/>the code that <code>SaveCommand</code> and <code>CancelCommand</code> will invoke to save and navigate back to <code>MainPage</code>:</p>
			<pre class="source-code">
private void Save()
{
    MediaItem item;
    if (_itemId &gt; 0)
    {
        item = _dataService.GetItem(_itemId);
        item.Name = ItemName;
        item.Location = (LocationType)Enum.Parse
          (typeof(LocationType), SelectedLocation);
        item.MediaType = (ItemType)Enum.Parse(typeof
          (ItemType), SelectedItemType);
        item.MediumInfo = _dataService.GetMedium
          (SelectedMedium);
        _dataService.UpdateItem(item);
    }
    else
    {
        item = new MediaItem
        {
            Name = ItemName,
            Location = (LocationType)Enum.Parse
              (typeof(LocationType), SelectedLocation),
            MediaType = (ItemType)Enum.Parse(typeof
              (ItemType), SelectedItemType),
            MediumInfo = _dataService.GetMedium
              (SelectedMedium)
        };
        _dataService.AddItem(item);
    }
    _navigationService.GoBack();
}
private void Cancel()
{
    _navigationService.GoBack();
}</pre>			<p>The other change<a id="_idIndexMarker371"/> needed before you run the application to test the new page is to consume <code>ItemDetailsViewModel</code> from <code>ItemDetailsPage.xaml.cs</code>:</p>
			<pre class="source-code">
public ItemDetailsPage()
{
    ViewModel = App.HostContainer.Services.GetService
      &lt;ItemDetailsViewModel&gt;();
    this.InitializeComponent();
}
public ItemDetailsViewModel ViewModel;</pre>			<p>Now, run the app and<a id="_idIndexMarker372"/> try to add or edit an item—you should see the new page. If you are editing, you should also see the existing item data in the controls:</p>
			<div><div><img src="img/B20908_04_02.jpg" alt="Figure 4.2 – The Item Details page with edited data populated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The Item Details page with edited data populated</p>
			<p>Great! Now when you save, you should see any added records or edited data appear on <code>MainPage</code>. Things are really starting to take shape in our project. Let’s review what we have learned about WinUI and MVVM in this chapter.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Summary</h1>
			<p>You have learned quite a bit about MVVM and WinUI page navigation in this chapter. You have learned how to create and consume services in your application, and you have leveraged DI and DI containers to keep your view models and services loosely coupled. Understanding and using DI is key to building testable, maintainable code. At this point, you should have enough knowledge to create a robust, testable WinUI application.</p>
			<p>In the next chapter, you will learn about more of the available controls and libraries in WinUI 3.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Questions</h1>
			<ol>
				<li>How do DI and IoC relate?</li>
				<li>How do you navigate to the previous page in a WinUI application?</li>
				<li>What object do we use to manage dependencies?</li>
				<li>With Microsoft’s DI container, what method can you call to get an object instance?</li>
				<li>What is the name of the framework that queries objects in memory?</li>
				<li>What event argument property can you access to get a parameter passed to another <code>Page</code>?</li>
				<li>Which dictionary type is safe to use across threads?</li>
			</ol>
		</div>
	</body></html>