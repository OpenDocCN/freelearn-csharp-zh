- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Navigation and Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing and navigation are essential features in any modern web application.
    In a Blazor Web App, routing is the process that maps URLs to Razor components,
    allowing users to navigate between different views. Navigation refers to the actions
    and processes involved in moving from one route to another, whether through user
    interactions, programmatic commands, or other means. Blazor provides a flexible
    routing system that supports both static and interactive routing, depending on
    how you configure the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static routing** occurs during static server-side rendering when prerendering
    is enabled. In this mode, the Blazor router, defined by the **Router** component
    in **Routes.razor** , performs routing based on the HTTP request path, mapping
    URLs directly to components. Conversely, when the Blazor router is set to an interactive
    render mode, it automatically transitions from static to **interactive routing**
    after the initial rendering on the server is completed. Interactive routing uses
    the document’s URL (the URL in the browser’s address bar) to determine which component
    to render dynamically, allowing an application to respond to user interactions
    and navigate without performing full HTTP requests. This approach enables dynamic
    content updates and seamless navigation within the application.'
  prefs: []
  type: TYPE_NORMAL
- en: When comparing routing in Blazor to routing in ASP.NET Core, there are both
    similarities and key differences to consider. ASP.NET Core primarily uses controllers
    and actions for routing, where routes are typically defined in a centralized manner,
    often using attribute-based or conventional routing. In contrast, Blazor’s routing
    is component-based, directly mapping URLs to Razor components instead of controller
    actions. This component-based approach in Blazor allows a more modular and encapsulated
    routing experience, where each component can manage its own navigation logic.
    Additionally, Blazor supports navigation within a client-side browser, without
    requiring full-page reloads, which is a significant difference from traditional
    server-side routing in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover aspects of routing and navigation in Blazor web
    apps using .NET 9. We will begin with enabling routes from multiple assemblies,
    essential for building modular applications and scenarios where you’ll leverage
    external NuGet packages. Then, we will explore parameterized routes, where you
    will learn to create dynamic and flexible URLs with route parameters. Then, we
    will discuss implementing unified **deep linking** for centralizing route definitions
    for easier management. We will also cover handling incorrect navigation requests
    and controlling navigation history to enhance the user experience. Near the end,
    we will explain how to execute asynchronous operations during navigation and cancel
    long-running tasks when users navigate away. Lastly, we will explore how to prevent
    unintentional data loss by prompting users about unsaved changes before navigating
    away from forms.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how routing works in Blazor
    and how to implement various routing and navigation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Routing and navigation are critical components that often impact entire application
    behavior. However, the recipes in this chapter are fully independent and don’t
    build on one another. This approach also means you can review and implement each
    recipe in isolation. Recipes begin with instructions on what working directory
    you should create and which sample files you need to execute the following task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling routes from multiple assemblies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with parameterized routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing unified deep linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling incorrect navigation requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing an asynchronous operation with navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a long-running task when users navigate away
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling navigation history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving in, make sure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET 9 SDK installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern IDE (that supports Blazor development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser (that supports WebAssembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build all recipes in a **BlazorCookbook.App** project, so all references
    will reflect that assembly. Make sure you adjust assembly references to match
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the code written in this chapter and code samples on GitHub
    at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter09)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling routes from multiple assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might want to modularize your Blazor application by spreading routes across
    multiple assemblies. **Modularization** is the practice of breaking down an application
    into smaller, manageable, and independent modules, each responsible for a specific
    functionality. It’s an ideal development approach when working in big or distributed
    teams, as each team can deliver features independently. Modularization is also
    beneficial in larger applications, as you can encapsulate different features in
    separate assemblies. Blazor allows you to discover routable components from additional
    assemblies through the **Router** component’s API, for interactive routing, and
    the endpoint convention builder, for static route setups.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to allow users to navigate to a component from an assembly different
    than our base project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we extend assemblies, where Blazor scans for routable components, copy
    the **BlazorCookbook.Library** project from the GitHub repository to your solution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to allow Blazor to discover routes from different assemblies:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **BlazorCookbook.App** server-side project of your solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **BlazorCookbook.App.csproj** and add a reference to the **BlazorCookbook.Library**
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **Program.cs** and locate a component mapping section. Use the **AddAdditionalAssemblies()**
    method to map routes from the **ExternalEventManager** assembly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **Routes** component and extend the array attached to the **AdditionalAssemblies**
    parameter with the **ExternalEventManager** assembly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we add all the configurations for routable component discoverability
    in the server-side project of the solution. In *step 2* , we find the **BlazorCookbook.App**
    project configuration file and reference the **BlazorCookbook.Library** project
    that you’ve copied from the GitHub repository. **BlazorCookbook.Library** contains
    an **ExternalEventManager** component, and we want our users to be able to navigate
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we set up the discoverability of the static routing that might
    come from the **BlazorCookbook.Library** . We navigate to the **Program.cs** file
    of the **BlazorCookbook.App** project and locate where we build the endpoint convention
    of the application. The endpoint route builder starts from the **MapRazorComponents()**
    method call. At the end of the builder, we call the **AddAdditionalAssemblies()**
    method to map all the static routes from the **BlazorCookbook.App.Client** project.
    Now, we extend the additional assemblies’ array with the **ExternalEventManager**
    assembly. To make the registration type-safe, rather than a simple string, we
    use the **typeof()** method. The **typeof()** method in .NET allows us to obtain
    the **Type** object for a given type name, enabling reflection and metadata access
    at runtime. Additionally, it allows retrieval of the assembly containing the type,
    which solves our requirement perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we navigate to the **Routes** component, still in the server-side
    project, to extend the discoverability of interactive routes. Here, we find our
    application **Router** configuration. By specifying assemblies with the **AppAssembly**
    and **AdditionalAssemblies** parameters, **Router** dynamically discovers and
    maps routes to components defined in those assemblies. In our case, again, we
    find that the client-side project assembly is already attached to the **AdditionalAssemblies**
    parameter of the **Router** . We extend the **AdditionalAssemblies** with reference
    to the **ExternalEventManager** assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with parameterized routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Blazor, parameterized routes allow you to pass parameters through the URL,
    making your application more dynamic and flexible. By leveraging route parameters,
    you can create components that respond to specific URL segments and render content
    based on those parameters. You can also use route parameters to persist the component
    state and allow users to bookmark it (which we explored at the beginning of [*Chapter
    5*](B22020_05.xhtml#_idTextAnchor165) ).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extend component routing with parametrized routes, enforcing parameter
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before exploring parametrized routing, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter09** / **Recipe02** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **ExternalEventManager** from the **Chapter09** / **Recipe01** directory
    in the **BlazorCookbook.Library** project or the matching directory in the GitHub
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement routes with parameters and intercept their
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **ExternalEventManager** component and extend its routes with
    parametrized options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **ExternalEventManager** , initialize the **@code** block with two parameters
    – **EventId** and **Venue** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the **ExternalEventManager** markup by constructing a conditional display
    of the **Venue** and **EventId** values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to **ExternalEventManager** and extend the routing
    there. We add a new route that expects an **eventId** parameter by placing the
    parameter name in curly braces. We also declare that it must be of type **guid**
    . Blazor also supports route parameter constraints, which enhance your application’s
    security by automatically rejecting parameter values that don’t meet the specified
    constraints. Users providing incompatible values will receive a **404** error
    status code. While the route parameter name is case-insensitive, the constraint
    must follow the configured casing. As constraint support is limited, in the *See
    also* section for this recipe, there’s a link to all currently supported data
    types. In the last route we add, we declare the **venue?** optional route parameter
    by adding a **?** symbol at the end. Having an optional parameter means users
    can navigate to the page whether they provide the value of the **venue** or not,
    and we can adjust the display logic accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we initialize a **@code** block in **ExternalEventManager** and
    declare two parameters, **EventId** and **Venue** , matching the names of the
    parameters added in the routes but following the Pascal case convention. That’s
    all it takes to enable Blazor to bind route parameters to the component’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we construct a simple markup in **ExternalEventManager** . Below
    the existing **h1** element, we check whether **EventId** was set in the route
    and render its value in a paragraph. Lastly, we add another paragraph, below **EventId**
    , to display the current value of **Venue** or a message indicating that the user
    is viewing all venues (if **Venue** was not provided in the route). With this
    setup, you can test how different routes impact the component’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, you can implement a *catch’em all* pattern to intercept route
    parameters. You can intercept an entire route segment into a string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We still declare the route parameter in curly braces and a matching **string**
    parameter in the **@code** block, similar to other routing cases. However, to
    indicate that we want to intercept an entire route segment, we prefix the parameter
    name with a ***** symbol. For example, when a user navigates to **/ch09r02/im/definitely/lost**
    , Blazor assigns **im/definitely/lost** to the **Path** value. You can still mix
    standard route parameters and constraints as long as the catch-all route segment
    parameter is the last in the route path.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the full list of data types that Blazor supports as route parameter constraints,
    check out the following Microsoft documentation link: [https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints](https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Working with query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Query strings** and parameters are parts of a URL that allow you to pass
    optional data to a web application. They appear after the **?** symbol in a URL
    and consist of key-value pairs, separated by **=** and joined by **&** . The use
    of query parameters is useful for filtering data, pagination, and passing user-specific
    information without altering the URL structure significantly.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enhance the routing by allowing the conditional passing of an event date
    that will be loaded dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before exploring query parameters, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter09** / **Recipe03** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **ExternalEventManager** from the *Working with parameterized routes* recipe
    or the **Chapter09** / **Recipe02** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to intercept values from query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **@code** block of the **ExternalEventManager** and introduce
    a **Date** parameter, but use a **SupplyParameterFromQuery** attribute to indicate
    that Blazor should intercept it from the query string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the **ExternalEventManager** markup, check whether **Date** is
    available and render another paragraph with the **Date** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to **ExternalEventManager** and declare a **Date**
    parameter. Instead of using the standard **Parameter** attribute, we leverage
    the **SupplyParameterFromQuery** variant, instructing Blazor to intercept parameters
    from the query string. There’s no need to manipulate routes; simply annotating
    the parameter with **SupplyParameterFromQuery** enables this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we extend the **ExternalEventManager** markup. We check whether
    the **Date** value matches the default value of **DateTime** , which indicates
    that the parameter was not in the query string. If Blazor intercepts the **Date**
    parameter, we render a paragraph displaying its value. However, it’s important
    to note that the format of the date provided in the query string needs to match
    the culture settings of the application. By default, Blazor and .NET expect dates
    in the **MM-DD-YYYY** format, which is a default format in the **en-US** culture,
    reflecting the United States standard. If the date is provided in a different
    format, such as **DD-MM-YYYY** , it may not be parsed correctly unless the application’s
    culture is set appropriately. This can be adjusted either globally or within specific
    components by configuring the appropriate culture settings, ensuring that Blazor
    interprets the date in the desired format.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your C# parameter name differs from the one provided in a query string,
    or when a parameter key is present multiple times in a query string and you need
    to intercept all values into an array, you must explicitly declare the **Name**
    property of the **SupplyParameterFromQuery** attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this code, Blazor will intercept all the query parameters attached to the
    **seat** key and store them in the **Seats** array. You can then use that array
    to highlight or reserve seats with specific numbers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’d like to learn more about globalization and culture settings in Blazor,
    check out the Microsoft Learn resource here: [https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization](https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization#globalization)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing unified deep linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deep linking** in a web application is the ability to link directly to specific
    content or functionality. Implementing a unified deep linking service in your
    application centralizes route management, making the application more maintainable
    and scalable. It’s much easier to manage routing changes and avoid inconsistencies
    with all routes in one place.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move some routes to a static deep links container and update component
    routing to leverage these unified deep links.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we encapsulate routes into a dedicated container, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe04** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **ExternalEventManager** from the *Working with query parameters* recipe
    or the **Chapter09** / **Recipe03** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to introduce a container for routes in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, create a **DeepLinks** static class, not a component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **DeepLinks** class, define three **const** routes that match the
    ones you have in **ExternalEventManager** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **ExternalEventManager** , and replace the **@page** directives
    with the **@attribute** and **[Route]** attributes. Instead of providing the routes
    explicitly, leverage the **DeepLinks** constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a new **DeepLinks** class. **DeepLinks** is not a component
    but, rather, a **static** class, as it represents a fixed library that should
    be easily accessible in the entire application and won’t change through the application’s
    lifetime. In *step 2* , we declare three **const** routes for the **LandingPage**
    , **EventPage** , and **EventAtVenuePage** pages inside **DeepLinks** . These
    routes match the ones we already have explicitly declared in **ExternalEventManager**
    , so we copy those values here.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we navigate to **ExternalEventManager** and replace all **@page**
    directives with **@attribute** . With **@attribute** , we can leverage the **[Route]**
    attribute, which accepts a route as a parameter. We use the **DeepLinks** route
    repository to explicitly construct the same routing we had with **@page** directives.
    Even though we’ve encapsulated routes in **string** variables, Blazor still respects
    the constraints and optionality of the route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: You can leverage the **DeepLinks** class to safely set up navigation links in
    the application menu or anywhere else. By having routes as named objects, you
    avoid mistyping and reduce the risk of errors in your routing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can extend the **DeepLinks** class with methods that allow you to generate
    stateful links and enable a more flexible and dynamic way to create URLs with
    route parameters. For instance, you can implement a method that accepts **EventId**
    and places it correctly in the **EventPage** route template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When rendering a grid with events, you can leverage the **GetPage()** method
    and safely generate links to the event page with details. **GetPage()** accepts
    the **eventId** parameter and uses the **Replace()** extension method to insert
    parameters into the **EventPage** route template.
  prefs: []
  type: TYPE_NORMAL
- en: Handling incorrect navigation requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graceful handling of incorrect navigation requests is mandatory in modern web
    development to ensure a smooth and user-friendly experience. By preventing users
    from encountering confusing error messages or broken links, you make your application
    feel professional and reliable. While we have already covered unauthorized navigation
    in [*Chapter 8*](B22020_08.xhtml#_idTextAnchor273) , other error states might
    unexpectedly occur. How you handle broken links or mistyped URLs defines the quality
    of the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a global, safe redirection to a friendly error page when users
    face unexpected navigation exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before implementing the safe redirection, you must have something to redirect
    to. If you have been following along with the entire book or just scaffolded your
    project, you already have a routable **Error** component. Otherwise, you can get
    it from the **Modules** directory in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a global safe redirection when user navigation fails:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Program** file of the server-side project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After all the existing middleware registrations, use the **UseStatusCodePagesWithRedirects()**
    extension method of **WebApplication** to register an error redirection middleware
    and redirect users to the **/** **error** route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Blazor apps, before the introduction of Blazor web apps, you would use the
    **NotFound** parameter of **Router** to handle users navigating to an unavailable
    route. Blazor web apps still support the **NotFound** parameter for backward compatibility,
    but leveraging the server-side middleware pipeline to resolve status codes provides
    much more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **Program** file of the server-side project,
    where we configure the server-side middleware pipeline. In *step 2* , we locate
    where the existing middleware registrations end and use the **UseStatusCodePagesWithRedirects()**
    method to extend the middleware pipeline. With **UseStatusCodePagesWithRedirects()**
    , we define that whenever a server request results in an unhandled error status
    code, users get redirected to an **/error** page. With the **Error** component,
    we can customize the message, details, and next steps that our users see.
  prefs: []
  type: TYPE_NORMAL
- en: The added benefit of **UseStatusCodePagesWithRedirects()** is that it covers
    all unsuccessful status codes, not just the *route not* *found* case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered **UseStatusCodePagesWithRedirects()** , as it’s the method most
    commonly used in UI-based applications. However, it’s just one of the options
    from the **UseStatusCodePages()** family of methods. Handling ranges from simple
    text status representation to fully customized exception-handling logic and retries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all available options, with examples of when and how to use each,
    in the Microsoft docs: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0#usestatuscodepages)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Executing an asynchronous operation with navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern web applications, executing common logic during navigation can be
    crucial for maintaining a seamless user experience and gathering valuable insights.
    You can implement navigation event logging and achieve a better understanding
    of user behavior, identify the most frequently used features, and improve them
    accordingly. You can also implement periodic security checks and refresh a user’s
    access token seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s log all navigation requests inside the application to understand better
    which features users use the most so that you can prioritize them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work inside the **Routes** component, which you must already have, as
    it’s an integral part of the Blazor application. No preparation is required in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to trigger an operation on all navigation inside
    the app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Routes** component and inject a **Logger** instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize an **@code** block in the **Routes** component, and implement a
    **LogNavigation()** method that accepts **NavigationContext** and logs the path
    that the user entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Routes** markup, locate **Router** and attach the **LogNavigation()**
    method to its **OnNavigateAsync** callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **Routes** component. You learned about **Routes**
    in the *Enabling routes from multiple assemblies* recipe. First, we inject an
    instance of **ILogger** . The **ILogger** interface simplifies logging information
    in applications and allows you to log messages with different severity levels
    (such as information, warning, or error) without depending on a specific logging
    implementation. **ILogger** allows you to provide a logger category, which is
    then reflected in logs, implying the log source. In our case, we declare the **Routes**
    as the logger category. You can find more logging resources in the *See also*
    section at the end of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we initialize an **@code** block and implement a **LogNavigation()**
    method. **LogNavigation()** accepts **NavigationContext** , which provides information
    about the navigation event. By accessing the **Path** property of the **NavigationContext**
    , we can pass the navigation destination path to **Logger** and log the path the
    user navigated to.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we move to the **Routes** markup. Here, we find the **Router**
    construction. The **Router** component exposes an **OnNavigateAsync** callback,
    so we attach the **LogNavigation()** method there. Now, with each navigation request,
    **Router** will invoke the **OnNavigateAsync** callback and trigger the **LogNavigation()**
    method, effectively logging every path our users enter inside the application.
  prefs: []
  type: TYPE_NORMAL
- en: By default, you will have a **Console** logger registered, but you can freely
    extend the logging behavior to cover your business use case. You can either implement
    your own logger or find multiple NuGet packages that support logging from different
    hosting models.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about logging by checking out the Microsoft learning resources:
    [https://learn.microsoft.com/en-us/dotnet/core/extensions/logging](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a long-running task when users navigate away
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the traffic in your application, long-running tasks can negatively
    impact performance and user experience if you don’t properly manage them. With
    components rendered in SSR mode, the server handles cancellations for you, similar
    to what happens in web API projects. But in interactive modes, when state is persisted
    either on the server or the client side when users navigate away from a page where
    a long-running task is in progress, it’s essential that you gracefully cancel
    the task to free up resources and prevent unnecessary processing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a graceful cancellation of long-running tasks with the help
    of Blazor’s **NavigationManager** and **CancellationToken** .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore graceful cancellation of a long-running task when a user
    navigates away, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter09** / **Recipe07** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **ExternalEventManager** and **DeepLinks** files from the *Implementing
    unified deep linking* recipe or the **Chapter09** / **Recipe04** directory in
    the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As **DeepLinks** contains recipe-specific routes and routes in the application
    must be unique, update the paths with **ch09r07** to reflect the current recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Source** file from the **Chapter09** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to trigger graceful cancellation when a user navigates away:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **ExternalEventManager** component, and then enhance it to
    render it in **InteractiveWebAssembly** mode and implement **IDisposable** . We
    will address the resulting compilation error shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of the **@code** block of **ExternalEventManager** , inject **NavigationManager**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **Nav** injection, declare a **_cts** variable of type **CancellationTokenSource**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the **@code** block of **ExternalEventManager** , implement a
    **CancelTask()** method, matching the signature for an **EventHandler** object
    returning **LocationChangedEventArgs** , which acts as a proxy to call the **Cancel()**
    method of the **_cts** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **CancelTask()** method, override the **OnInitialized()** life cycle
    method and subscribe the **CancelTask()** method to the **LocationChanged** event
    exposed by the injected **Nav** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next to **OnInitialized()** , implement a **Dispose()** method required by
    the **IDisposable** interface, where you safely unsubscribe from the **LocationChanged**
    event and gracefully dispose of the **_cts** instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the **@code** block, implement a **GetAsync()** method, where you
    get **eventId** from **Source** , and redirect the user to the event details page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the **ExternalEventManager** markup area, and below the header, replace
    the fast-return clause when **EventId** is not set with a rendering of a button,
    allowing users to load an event if it has not yet loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **ExternalEventManager** component and declare
    it to render in **InteractiveWebAssembly** mode, as we want to monitor the execution
    of a long-running task to cancel it if needed. We also need **ExternalEventManager**
    to implement **IDisposable** . Declaring the component as **IDisposable** results
    in a compilation error, but we will resolve it before the end of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we inject a **NavigationManager** instance at the top of the **@code**
    block of **ExternalEventManager** . The **NavigationManager** instance allows
    us to react to navigation and location changes. In *step 3* , we set up the backbone
    of graceful task cancellation by declaring a **CancellationTokenSource** variable.
    With **CancellationTokenSource** , we can signal and manage cancellation requests
    for asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we implement a **CancelTask()** method with a signature matching
    an **EventHandler** object returning **LocationChangedEventArgs** . The **CancelTask()**
    method’s responsibility is to invoke **Cancel()** of the **_cts** instance and
    cancel all running operations, depending on that instance. We leverage the **?**
    operator, called a **null-conditional operator** , as it allows us to invoke a
    method or access to a member only if the preceding object ( **_cts** in this case)
    is not **null** . In *step 5* , we override the **OnInitialized()** life cycle
    method of **ExternalEventManager** and subscribe **CancelTask()** to the **LocationChanged**
    event exposed by **Nav** . Blazor triggers the **LocationChanged** event whenever
    a user navigates to a new location within the application. In *step 6* , we complete
    the implementation of **IDisposable** by constructing a **Dispose()** method.
    In the **Dispose()** method, we safely unsubscribe from the **LocationChanged**
    event to prevent memory leaks. We also dispose of the **_cts** instance using
    the **Dispose()** method it exposes. In *step 7* , we complete the **@code** block
    by implementing a **GetAsync()** method to test the graceful cancellation of a
    long-running task. As part of **GetAsync()** , we initialize a new **_cts** instance
    and call the **LoadAsync()** method of the **Source** class, passing in a **CancellationToken**
    sourced from the **_cts** instance. **CancellationToken** allows **LoadAsync()**
    to be aware of any cancellation requests as it executes. As we expect loading
    cancellations, we add a **_cts** state-check. With the **IsCancellationRequested**
    property, we can verify whether cancellation was requested and short-circuit the
    code execution. Lastly, if **LoadAsync()** completes, we redirect the user to
    the appropriate event details page.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* , we move to the **ExternalEventManager** markup and add a simple
    button, allowing users to trigger **GetAsync()** and put the implementation to
    the test. You can run the application and click the **Get event** button. The
    **LoadAsync()** method from the **Source** has a hardcoded delay of five seconds
    and logs status messages to your browser console. If you navigate away from the
    **ExternalEventManager** page before the timer elapses, you will see that the
    saving request you’ve queued was gracefully canceled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Messages in the browser console, indicating graceful task cancellation](img/Figure_9.1_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Messages in the browser console, indicating graceful task cancellation'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling navigation history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **NavigationManager** in Blazor uses the browser’s **History API** to maintain
    navigation history. Manipulating navigation history is particularly useful when
    authenticating users with external identity providers, where users are redirected
    back to an application after authentication. It’s also beneficial when displaying
    intermediate pages that allow users to configure their application, but you want
    to restrict them from going backward in that process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s simulate intermediate page removal from the browser history and force
    users to navigate to the last stable page when they try to return to the intermediate
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore browser navigation history manipulations, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter09** / **Recipe08** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **ExternalEventManager** and **DeepLinks** files from the *Canceling
    a long running task when users navigate away* recipe or the **Chapter09** / **Recipe07**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As **DeepLinks** contains recipe-specific routes and routes in the application
    must be unique, update the paths with **ch09r08** to reflect the current recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Source** file from the **Chapter09** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to replace an entry in the browser’s navigation history:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **@code** block of **ExternalEventManager** and find the **GetAsync()**
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside **GetAsync()** , when invoking the **NavigateTo()** method of the injected
    **NavigationManager** , explicitly set the additional **replace** parameter to
    **true** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **ExternalEventManager** . Here, in the **@code**
    block, we have a **GetAsync()** method that users trigger when retrieving event
    details from an external source. In *step 2* , we extend the **GetAsync()** navigation
    logic by passing **true** as the **replace** argument. With the **replace** argument
    in **NavigationManager.NavigateTo()** , we ensure that the current entry in the
    browser’s history is replaced with the new URL rather than adding a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: If a user hasn’t loaded any event yet, we will display a page with a button
    allowing them to load an event. After clicking the button, they get redirected
    to the event details page automatically. From there, when users try to navigate
    back, they will land on whatever page they were on before getting the event. The
    browser will not be aware of the intermediate step of loading the event in the
    first place.
  prefs: []
  type: TYPE_NORMAL
