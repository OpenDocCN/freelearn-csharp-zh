# 原型

使用原型模式的目标是帮助建立一个基于原型的对象复制的一致方式。这个原型通常是一个**典型对象**，我们在应用程序的生命周期中需要多次创建它。为了避免初始化新对象可能带来的性能成本，我们可以使用原型模式来设置一个类似于复印机的系统。通过实现原型模式，我们可以在不降低应用程序整体性能的情况下，即时复制典型对象。换句话说，原型模式是我们编程工具箱中的一个实用工具。

本章将涵盖以下主题：

+   我们将回顾原型模式的核心理念。

+   我们将实现一个生成系统，以原型模式作为我们的基础。

# 技术要求

本章是一个实践章节；你需要对Unity和C#有一个基本的了解。

我们将使用以下特定的Unity引擎和C#语言概念：

+   接口

+   组合

如果你对这些概念不熟悉，请在开始本章之前复习它们。

本章的代码文件可以在GitHub上找到：

[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)

观看以下视频，以查看代码的实际效果：

[http://bit.ly/2WviTwe](http://bit.ly/2WviTwe)

# 原型模式概述

原型模式被归类为**创建型模式**，这意味着它的主要职责是优化初始化对象的过程。在Unity脚本API中，我们通常不使用构造函数；相反，我们将我们的类转换为组件并将它们附加到GameObject上。采用这种方法，引擎管理我们的对象初始化序列到内存中。

从理论上讲，对象的初始化开销超出了我们的控制，因为引擎为我们管理这一点。这个说法在某种程度上是正确的，但它没有考虑到场景生命周期中发生的事情。如果我们需要在场景的特定时刻动态加载预制体，引擎将无法防止在将整个实体加载到内存中时帧率突然下降。

**预制体**是一个由组装好的GameObject和组件组成的预制容器。例如，你可以为游戏中每种类型的角色创建一个预制体。预制体易于加载和复制到内存中。它们通常被称为游戏的构建块。

原型模式为这个技术难题提供了一个简单的解决方案；我们不是加载一个新的预制件，而是复制一个已经存在于内存中的。类似于复印机，我们可以从一个单一引用中制作出我们需要的任意数量的副本。这种方法适用于生成预制件和单个组件。

以下 UML 图是一个使用原型模式作为基础的生成系统设计的示例：

![](img/9d2de532-49d8-4b16-9578-8add31aff2de.png)

正如你所见，原型模式的核心元素是名为 `ICopyable` 的接口类。正如其名所示，任何实现了 `ICopyable` 的类都需要能够返回其自身的副本。在先前的图中，`Enemy` 类实现了 `ICopyable` 接口。这种关系表明，我们将能够请求 **Drone** 和 **Tank** 的实例，而无需每次都创建新的实例。

将设计模式与实际系统关联可以帮助你记住特定模式的定义。我个人总是将原型模式与复印机相比较。

# 优点和缺点

让我们回顾一下与原型模式实现相关的优点和潜在缺点的简短列表。

以下是一些好处：

+   **减少初始化开销**：理论上，复制已经存在于内存中的对象比初始化一个新的对象要快。

+   **内存中实例的可重用性**：在原型对象从一个状态转移到另一个状态的过程中，可以复制其排列组合。

+   **一致性**：让对象自我复制具有结构上的优势；这样做更安全，并且为复制过程提供了一个标准接口。

以下是一些缺点：

+   **维护引用**：如果在复制之前我们总是销毁原型对象，那么我们最终会消除使用此模式的所有好处。

+   **不支持和不支持循环引用**：在某些情况下，对象的内部结构不支持克隆。在这些情况下，可能很难在实现原型模式的系统中使用这些对象。

在这本书中，我们将避免使用严格的计算机科学术语。对于任何编程概念，总有一个科学和实用的定义。我们将专注于实用的定义，同时仍然考虑模式的理论解释。

# 用例示例

现在你已经对原型模式有了基本的了解，让我们实际实现一个游戏中的系统，将模式作为我们架构的基础。生成系统是原型模式这类创建型模式的一个完美用例。在正确的时间生成敌人对于设计一个非常沉浸式的游戏体验至关重要。

我们需要避免的最关键的技术问题是敌人生成过程中的帧率下降。这就是为什么我们将使用原型模式；我们将复制特定敌人的现有实例，而不是每次需要生成它们时都创建新的实例。

在下一节中，我们将实现我们在本章开头审查的 UML 图。

# 代码示例

在本节中，我们将实现一个仅包含无人机和狙击手作为主要敌人类型的游戏的基本生成系统。在此阶段，让我们确保我们的生成系统能够向客户端返回特定敌人类型的副本。

当我们在这本书中使用术语 **客户端** 时，我们指的是使用模式功能的一个类。在我们的上下文中，它通常是一个 `Client` 类，它允许我们测试我们的代码示例。

在整本书中，我们将在我们的示例中经常使用接口。它们是面向对象编程中的强大工具。它们提供了一种简单的方式来声明实现合同。参考以下步骤：

1.  作为第一步，让我们实现一个名为 `ICopyable` 的接口。我们将公开一个名为 `Copy()` 的函数：

[PRE0]

注意，我们的接口名为 `ICopyable`；这是为了避免与 C# 的原生接口 `ICloneable` 混淆，后者用于声明一个类为 **可克隆**。在我们的示例中，我们不会使用这个 C# 接口。

1.  现在我们有了我们的接口，让我们在名为 `Enemy` 的具体类中实现它：

[PRE1]

我们的 `Enemy` 父类现在能够通过 `Copy()` 函数返回其自身的克隆实例。正如我们之前提到的，我们没有使用 C# 的原生 `ICloneable` 接口，因为我们正在通过使用 Unity 的 `Instantiate()` 函数利用 Unity 的 API。这个 API 函数更适合我们的上下文，因为它可以在克隆过程中持续原生 Unity GameObject 或组件的层次关系。换句话说，当使用 `Instantiate()` 克隆 GameObject 时，您也在复制（克隆）其子对象。这种方法在 Unity 中至关重要，因为 GameObjects 通常由多个对象和组件组成，以父子结构排列。

1.  下一步涉及实现我们的两个主要敌人；让我们从 `Drone` 开始：

[PRE2]

如您所见，我们的 `Drone` 类现在是 `Enemy` 类的一个子类，并且因为在面向对象的环境中子对象继承其父对象的属性，`Drone` 类获得了访问 `Copy()` 函数的权限。这种安排意味着客户端可以通过调用 `Copy()` 来请求 `Drone` 的副本。

1.  现在，让我们为我们的 `Sniper` 做同样的事情：

[PRE3]

1.  现在我们已经将所有具体的 `Enemy` 类型类写下来，让我们实现我们的 `EnemySpawner`：

[PRE4]

我们的生成系统相当简单；它通过复制接收到的任何对应于`Enemy`类型的对象来生成敌人。就像一台复印机；给它正确的文档，它就会复制它。然而，有一个核心区别；我们的`EnemySpawner`不执行复制。它只是要求它接收到的对象复制自己，然后将复制品返回给客户端。

1.  为了测试我们的敌人生成系统实现，让我们编写一个`Client`类：

[PRE5]

我们的`Client`类相当简单；根据玩家是否在键盘上按下*S*或*D*，它将请求`EnemySpawner`返回一个`Drone`或`Sniper`实例，然后它将把它放在之前生成的实体旁边。

在本书中，我们假设读者具备基本的Unity技能，并且已经知道如何设置GameObject以及将组件附加到它们上。作为一个快速提醒，为了使此代码示例在Unity场景中编译并工作，你需要执行以下操作：

1.  创建两个GameObject，并将Drone或Sniper脚本附加到它们作为组件。

1.  创建一个带有客户端（脚本）的GameObject。

1.  在客户端（脚本）组件的检查器中，将Drone和Sniper GameObject设置为相应字段中的引用。

以下截图显示了测试我们的代码示例的典型Unity场景设置：

![图片](img/c3306d86-bf00-403c-9460-40dfd82887a9.png)

本书的相关源代码和Unity项目可在GitHub仓库[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)中找到。

我们在构建简单的生成系统时成功实现了原型模式。这段代码是开发更高级生成系统的坚实基础。需要记住的最重要的一课是始终考虑在创建对象之前复制它。这种方法是一种直接的优化策略。

# 摘要

我们这本书的实践部分以一个灵活但简单的模式开始。原型模式背后的整体概念很简单；我们不是初始化新对象，而是仅仅从内存中已有的实例克隆它们。为了在克隆过程中保持一致性，我们封装了对象自我克隆的方式，将这一责任从客户端移除。作为好处，我们可以获得在游戏中生成实体的性能和一致性。

在下一章中，我们将探讨原型模式的一个近亲，即工厂模式。

# 练习

每次你学习一个新的模式并将其适应到Unity中时，你应该验证它是否在使你的代码看起来结构化之外还有益处。与其他领域不同，游戏程序员不仅被他们的编写整洁代码的能力所评判，还在于代码的运行速度。你会发现很多设计模式为了结构的一致性而牺牲了性能。

作为一项练习，我建议你比较使用`Instantiate()`通过复制内存中现有对象和使用`Resource.Load()`加载相同对象的现有预制件来使用`Instantiate()`的性能。

为了完成这个任务，你可以尝试使用Unity的本地分析工具。

我建议阅读Unity的分析器文档；你可以在本章的“进一步阅读”部分查看链接。经常分析你的代码是一个好习惯，尤其是在尝试任何优化之前。这种方法将帮助你避免花费数小时优化那些甚至不经常执行的代码。

# 进一步阅读

+   《游戏编程模式》由Robert Nystrom著：[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)

+   《Unity手册 – 分析器概述：》[https://docs.unity3d.com/Manual/Profiler.html](https://docs.unity3d.com/Manual/Profiler.html)
