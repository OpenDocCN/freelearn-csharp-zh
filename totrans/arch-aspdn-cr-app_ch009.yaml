- en: 8 Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter explores the ASP.NET Core **Dependency Injection** (**DI**) system,
    how to leverage it efficiently, and its limits and capabilities.We learn to compose
    objects using DI and delve into the Inversion of Control (IoC) principle. As we
    traverse the landscape of the built-in DI container, we explore its features and
    potential uses.Beyond practical examples, we lay down the conceptual foundation
    of Dependency Injection to understand its purpose, its benefits, and the problems
    it solves and to lay down the ground for the rest of the book as we rely heavily
    on DI.We then return to the first three Gang of Four (GoF) design patterns we
    encountered, but this time, through the lens of Dependency Injection. By refactoring
    these patterns using DI, we gain a more holistic understanding of how this powerful
    design tool influences the structure and flexibility of our software.Dependency
    Injection is a cornerstone in your path toward mastering modern application design
    and its transformative role in developing efficient, adaptable, testable, and
    maintainable software.In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding guard clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Service Locator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DI is a way to apply the **Inversion of Control** (**IoC**) principle. IoC is
    a broader version of the dependency inversion principle (the *D* in SOLID).The
    idea behind DI is to move the creation of dependencies from the objects themselves
    to the **composition root**. That way, we can delegate the management of dependencies
    to an **IoC container**, which does the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: An IoC container and a **DI container** are the same thing—they’re just different
    words people use. I use both interchangeably in real life, but I stick to IoC
    container in the book because it seems more accurate than DI container.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IoC is the concept (the principle), while DI is a way of inverting the flow
    of control (applying IoC). For example, you apply the IoC principle (inverting
    the flow) by injecting dependencies at runtime (doing DI) using a container. Feel
    free to use any or both.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we define the composition root.
  prefs: []
  type: TYPE_NORMAL
- en: The composition root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A critical concept behind DI is the composition root. The composition root
    is where we tell the container about our dependencies and their expected lifetime:
    where we compose our dependency trees. The composition root should be as close
    to the program''s starting point as possible, so from ASP.NET Core 6 onward, the
    composition root is in the `Program.cs` file. In the previous versions, it was
    in the `Program` or `Startup` classes.Next, we explore how to leverage DI to create
    highly adaptable systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Striving for adaptability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To achieve a high degree of flexibility with DI, we can apply the following
    formula, driven by the SOLID principles:Object `A` should not know about object
    `B` that it is using. Instead, `A` should use an interface, `I`, implemented by
    `B`, and `B` should be resolved and injected at runtime.Let’s decompose this:'
  prefs: []
  type: TYPE_NORMAL
- en: Object `A` should depend on interface `I` instead of concrete type `B`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance `B`, injected into `A`, should be resolved by the IoC container at
    runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` should not be aware of the existence of `B`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` should not control the lifetime of `B`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also inject objects directly without passing by an interface. It all
    depends on what we inject, in what context, and our requirements. We tackle many
    use cases throughout the book to help you understand DI.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we translate this equation into an analogy that helps explain the reasons
    to use a container.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the use of the IoC container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To better understand the use of the IoC container and to create an image around
    the previous adaptability concept, let’s start with a LEGO® analogy where IoC
    is the equivalent of drawing a plan to build a LEGO®castle:'
  prefs: []
  type: TYPE_NORMAL
- en: We draw the plan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We gather the blocks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We press the start button on a hypothetical robot builder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot assembles the blocks by following our plan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The castle is complete
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following this logic, we can create a new 4x4 block with a unicorn painted
    on its side (concrete type), update the plan (composition root), and then press
    the restart button to rebuild the castle with that new block inserted into it,
    replacing the old one without affecting the structural integrity of the castle
    (program). As long as we respect the 4x4 block contract (interface), everything
    is updatable without impacting the rest of the castle, leading to great flexibility.Following
    that idea, if we need to manage every single LEGO® block one by one, it would
    quickly become incredibly complex! Therefore, managing all dependencies by hand
    in a project would be super tedious and error-prone, even in the smallest program.
    This situation is where an IoC container (the hypothetical robot builder) comes
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: The role of an IoC container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An IoC container manages objects for us. We configure it, and then, when we
    ask for a service, the container resolves and injects it. On top of that, the
    container manages the lifetime of dependencies, leaving our classes to do only
    one thing, the job we designed them to do. No more need to think about their dependencies!The
    bottom line is that an IoC container is a DI framework that does the auto-wiring
    for us. We can conceptualize Dependency Injection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The *consumer* of a dependency states its needs about one or more dependencies
    (contracts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IoC container injects that dependency (implementation) upon creating the
    *consumer*, fulfilling its needs at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we explore an code smell that applying Dependency Injection helps us avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell – Control Freak
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Control freak is a code smell and even an anti-pattern that forbids us from
    using the `new` keyword. Yes, using the `new` keyword is the code smell! The following
    code is wrong and can’t leverage DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted line shows the anti-pattern in action. To enable the Consumer
    class to use dependency injection, we could update it like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code removes the new keyword and is now open for modification.
    The highlighted lines represent the constructor injection pattern we explore subsequently
    in this chapter.Nevertheless, do not ban the `new` keyword just yet. Instead,
    every time you use it, ask yourself whether the object you instantiated using
    the `new` keyword is a dependency that could be managed by the container and injected
    instead.To help with that, I borrowed two terms from Mark Seemann’s book *Dependency
    Injection in .NET*; the name *Control Freak* also comes from that book. He describes
    the following two categories of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Stable dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatile dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is my take on defining them.
  prefs: []
  type: TYPE_NORMAL
- en: Stable dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Stable dependencies** should not break our application when a new version
    is released. They should use deterministic algorithms (input `X` should always
    produce output `Y`), and you should not expect to change them with something else
    in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: Most data structures devoided of behaviors, like Data Transfer Objects (DTOs),
    fall into this category. You can also consider the .NET BCL as stable dependencies.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can still instantiate objects using the `new` keyword when they fall into
    this category because the dependencies are stable and unlikely to break anything
    if they change.Next, we look at their counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Volatile dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Volatile dependencies** can change at runtime, like extendable elements with
    contextual behaviors. They may also be likely to change for various reasons like
    new features development.'
  prefs: []
  type: TYPE_NORMAL
- en: Most classes we create, such as data access and business logic code, are volatile
    dependencies.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The primary way to break the tight coupling between classes is to rely on interfaces
    and DI and no longer instantiate those volatile dependencies using the `new` keyword.
    Volatile dependencies are why dependency injection is key to building flexible,
    testable, and maintainable software.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To conclude this interlude: don’t be a control freak anymore; those days are
    behind you!'
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, inject the dependency instead of using the `new` keyword.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore the available lifetimes we can attribute to our volatile dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Object lifetime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we understand we should no longer use the `new` keyword, we need a
    way to create those classes. From now on, the IoC container will play that role
    and manage object instantiation and their lifetime for us.
  prefs: []
  type: TYPE_NORMAL
- en: What’s an object's lifetime?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we create an instance manually, using the `new` keyword, we create a hold
    on that object; we know when we create it and when its life ends. That’s the lifetime
    of the object.Of course, using the `new` keyword leaves no chance to control these
    objects from the outside, enhance them, intercept them, or swap them for another
    implementation—as covered in the preceding *Code smell – Control Freak* section.
  prefs: []
  type: TYPE_NORMAL
- en: .NET object lifetime
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With dependency injection, we need to forget about controlling objects and
    start to think about using dependencies, or more explicitly, depending on their
    interfaces. In ASP.NET Core, there are three possible lifetimes to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lifetime** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Transient | The container creates a new instance every time. |'
  prefs: []
  type: TYPE_TB
- en: '| Scoped | The container creates an instance per HTTP request and reuses it.In
    some rare cases, we can also create custom scopes. |'
  prefs: []
  type: TYPE_TB
- en: '| Singleton | The container creates a single instance of that dependency and
    always reuses that unique object. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: objects lifetime description'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now manage our volatile dependencies using one of those three scopes.
    Here are some questions to help you choose:'
  prefs: []
  type: TYPE_NORMAL
- en: Do I need a single instance of my dependency? Yes? Use the **singleton** lifetime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need a single instance of my dependency shared over an HTTP request? Yes?
    Use the **scoped** lifetime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need a new instance of my dependency every time? Yes? Use the **transient**
    lifetime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general approach to object lifetime is to design the components to be *singletons*.
    When impossible, we go for *scoped*. When *scoped* is also impossible, go for
    *transient*. This way, we maximize instance reuse, lower the overhead of creating
    objects, lower the memory cost of keeping those objects in memory, and lower the
    amount of garbage collection needed to remove unused instances.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, we can pick *singleton* mindlessly for stateless objects, which
    are the easiest to maintain and less likely to break.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For stateful objects, where multiple consumers use the same instance, we must
    ensure the object is thread-safe if the lifetime is *singleton* or *scoped* because
    multiple consumers could try to access it simultaneously.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One essential aspect to consider when choosing a lifetime is the consumers of
    stateful objects. For example, if we load data related to the current user, we
    must ensure that data do not leak to other users. To do so, we can define the
    lifetime of that object to *scoped*, which is limited to a single HTTP request.
    If we don’t want to reuse that state between multiple consumers, we can choose
    a *transient* lifetime to ensure every consumer gets their own instance.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does that translate into code? .NET offers multiple extension methods to
    help us configure the lifetimes of our objects, like `AddTransient`, `AddScoped`,
    and `AddSingleton`, which explicitly state their lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: We use the built-in container throughout the book with many of its registration
    methods, so you should grow familiar with it very quickly. It has good discoverability,
    so you can explore the possibilities using IntelliSense while writing code or
    reading the documentation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we use those methods and explore how to register dependencies with the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Registering our dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In ASP.NET Core, we register our dependencies in the `Program.cs` file, which
    represents the composition root. Since the minimal hosting model, the `WebApplicationBuilder`
    exposes the `Services` property we use to add our dependencies to the container.
    Afterward, .NET creates the container when it builds the `WebApplication` instance.Next
    is a minimal `Program.cs` file depicting this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `builder.Services` property to register our dependencies in
    that `IServiceCollection` implementation. Here’s an example of registering some
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code registers the dependencies using the singleton lifetime,
    so we get the same instance each time we request one.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to compose the program in the composition root. That removes the need
    for those pesky `new` keywords spread around your code base and all the tight
    coupling that come with them. Moreover, it centralizes the application’s composition
    into that location, creating the plan to assemble the LEGO® blocks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you may be thinking right now, that can lead to a lot of registration statements
    in a single location, and you are correct; maintaining such a composition root
    would be a challenge in almost any application. To address this concern, we introduce
    an elegant way to encapsulate the registration code next, ensuring it remains
    manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Registering your features elegantly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've just discovered, while we should register dependencies in the composition
    root, we can also arrange our registration code in a structured manner. For example,
    we can break down our application's composition into several methods or classes
    and invoke them from our composition root. Another strategy could be to use an
    auto-discovery system to automate the registration of certain services.
  prefs: []
  type: TYPE_NORMAL
- en: The critical part is to centralize the program composition in one place.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A common pattern in ASP.NET Core is having special methods like `Add[Feature
    name]`. These methods register their dependencies, letting us add a group of dependencies
    with just one method call. This pattern is convenient for breaking down program
    composition into smaller, easier-to-handle parts, like individual features. This
    also makes the composition root more readable.
  prefs: []
  type: TYPE_NORMAL
- en: A feature is the correct size as long as it stays cohesive. If your feature
    becomes too big, does too many things, or starts to share dependencies with other
    features, it may be time for a redesign before losing control over it. That’s
    usually a good indicator of undesired coupling.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To implement this pattern, we use extension methods, making it trivial. Here’s
    a guide:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a static class named `[subject]Extensions` in the `Microsoft.Extensions.DependencyInjection`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an extension method that returns the `IServiceCollection` interface,
    which allows method calls to be chained.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to Microsoft's recommendation, we should create the class in the same
    namespace as the element we extend. In our case, the `IServiceCollection` interface
    lives in the `Microsoft.Extensions.DependencyInjection` namespace.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, this is not mandatory, and we can adapt this process to our needs.
    For example, we can define the class in another namespace if we want consumers
    to add a `using` statement implicitly. We can also return something else when
    the registration process can continue beyond that first method, like a builder
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Builder interfaces are used to configure more complex features, like ASP.NET
    Core MVC. For example, the `AddControllers` extension method returns an `IMvcBuilder`
    interface that contains a `PartManager` property. Moreover, some extension methods
    target the `IMvcBuilder` interface, allowing further configuration of the feature
    by requiring its registration first; that is, you can’t configure `IMvcBuilder`
    before calling `AddControllers`. You can also design your features to leverage
    that pattern when needed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s explore a demo.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Registering the Demo Feature
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s explore registering the dependencies of the Demo Feature. That feature
    contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there is nothing complex but two empty classes and an interface.
    Remember that we are exploring the registration of dependencies, not what to do
    with them or what they can do—yet.Now, we want the container to serve an instance
    of the `MyFeatureDependency` class when a dependency requests the `IMyFeatureDependency`
    interface as the `MyFeature` class does. We want a singleton lifetime.To achieve
    this, in the `Program.cs` file, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also chain the two method calls instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not yet elegant. What we want to achieve is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To build that registration method, we can write the following extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As highlighted, the registration is the same but uses the `services` parameter,
    which is the extended type, instead of the `builder.Services` (`builder` does
    not exist in that class, yet the `services` parameter is the same object as the
    `builder.Services` property).If you are unfamiliar with extension methods, they
    come in handy for extending existing classes, like we just did. Besides having
    a static method inside a static class, the `this` keyword next to the first parameter
    determines whether it is an extension method.For example, we can build sophisticated
    libraries that are easy to use with a set of extension methods. Think `System.Linq`
    for such a system.Now that we learned the basics of dependency injection, there
    is one last thing to cover before revisiting the Strategy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Using external IoC containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides an extensible built-in IoC container out of the box.
    It is not the most powerful IoC container because it lacks some advanced features,
    but it does the job for most applications.Rest assured; we can change it to another
    one if need be. You might also want to do that if you are used to another IoC
    container and want to stick to it.Here’s the strategy I recommend:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the built-in container, as per Microsoft's recommendation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you can’t achieve something with it, look at your design and see if you
    can redesign your feature to work with the built-in container and simplify your
    design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is impossible to achieve your goal, see if extending the default container
    using an existing library or coding the feature yourself is possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is still impossible, explore swapping it for another IoC container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming the container supports it, it is super simple to swap. The third-party
    container must implement the `IServiceProviderFactory<TContainerBuilder>` interface.
    Then, in the `Program.cs` file, we must register that factory using the `UseServiceProviderFactory<TContainerBuilder>`
    method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `ContainerBuilder` and `ContainerBuilderFactory` classes
    are just wrappers around ASP.NET Core, but your third-party container of choice
    should provide you with those types. I suggest you visit their documentation to
    know more.Once that factory is registered, we can configure the container using
    the `ConfigureContainer<TContainerBuilder>` method and register our dependencies
    as usual, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s the only difference; the rest of the `Program.cs` file remains the same.As
    I sense you don’t feel like implementing your own IoC container, multiple third-party
    integrations already exist. Here is a non-exhaustive list taken from the official
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Autofac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DryIoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LightInject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lamar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stashbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Injector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of replacing the container entirely, some libraries extend the default
    container and add functionalities to it. We explore this option in *Chapter 11*,
    *Structural Patterns*.Now that we have covered most of the theory, we revisit
    the Strategy pattern as the primary tool to compose our applications and add flexibility
    to our systems.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we leverage the Strategy pattern to compose complex object
    trees and use DI to dynamically create those instances without using the `new`
    keyword, moving away from being control freaks and toward writing DI-ready code.The
    Strategy pattern is a behavioral design pattern we can use to compose object trees
    at runtime, allowing extra flexibility and control over objects’ behavior. Composing
    our objects using the Strategy pattern makes our classes smaller, easier to test
    and maintain, and puts us on the SOLID path.From now on, we want to compose objects
    and lower the amount of inheritance to a minimum. We call that principle **composition
    over inheritance**. The goal is to inject dependencies (composition) into the
    current class instead of depending on base class features (inheritance). Additionally,
    this approach enables us to pull out behaviors and place them in separate classes,
    adhering to the Single Responsibility Principle (SRP) and Interface Segregation
    Principle (ISP). We can reuse these behaviors in one or more different classes
    through their interface, embodying the Dependency Inversion Principle (DIP). This
    strategy promotes code reuse and composition.The following list covers the most
    popular ways of injecting dependencies into objects, allowing us to control their
    behaviors from the outside by composing our objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also get dependencies directly from the container. This is known as the
    Service Locator (anti-)pattern. We explore the Service Locator pattern later in
    this chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s look at some theory and then jump into the code to see DI in action.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Constructor injection** consists of injecting dependencies into the constructor
    as parameters. This is the most popular and preferred technique by far. Constructor
    injection is useful for injecting required dependencies; you can add null checks
    to ensure that, also known as the guard clause (see the *Adding a guard clause*
    section).'
  prefs: []
  type: TYPE_NORMAL
- en: Property injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The built-in IoC container does not support **property injection** out of the
    box. The concept is to inject **optional dependencies** into properties. Most
    of the time, you want to avoid doing this because property injection leads to
    optional dependencies, leading to nullable properties, more null checks, and often
    avoidable code complexity. So when we think about it, it is good that ASP.NET
    Core left this one out of the built-in container.You can usually remove the property
    injection requirements by reworking your design, leading to a better design. If
    you cannot avoid using property injection, use a third-party container or find
    a way to build the dependency tree yourself (maybe leveraging one of the Factory
    patterns).Nevertheless, from a high-level view, the container would do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new instance of the class and inject all required dependencies into
    the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find extension points by scanning properties (this could be attributes, contextual
    bindings, or something else).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each extension point, inject (set) a dependency, leaving unconfigured properties
    untouched, hence its definition of an optional dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a couple of exceptions to the previous statement regarding the lack
    of support:'
  prefs: []
  type: TYPE_NORMAL
- en: Razor components (Blazor) support property injection using the `[Inject]` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor contains the `@inject` directive, which generates a property to hold a
    dependency (ASP.NET Core manages to inject it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t call that property injection per se because they are not optional but
    required, and the `@inject` directive is more about generating code than doing
    DI. They are more about an internal workaround than “real” property injection.
    That is as close as .NET gets from property injection.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend aiming for constructor injection instead. Not having property injection
    should not cause you any problems. Often, our need for property injection stems
    from less-than-optimal design choices, whether from our design strategies or a
    framework we're utilizing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we look at method injection.
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ASP.NET Core supports method injection only at a few locations, such as in a
    controller’s actions (methods), the `Startup` class (if you are using the pre-.NET
    6 hosting model), and the middleware’s `Invoke` or `InvokeAsync` methods. We cannot
    liberally use method injection in our classes without some work on our part.Method
    injection is also used to inject **optional dependencies** into classes. We can
    also validate those at runtime using null checks or any other required logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**I recommend aiming for constructor injection whenever you can**. We should
    only resort to method injection when it''s our sole option or when it brings added
    value to our design.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, in a controller, injecting a transient service in the only action
    that needs it instead of using constructor injection could save a lot of useless
    object instantiation and, by doing so, increase performance (less instantiation
    and less garbage collection). This can also lower the number of class-level dependencies
    a single class has.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Manually injecting a dependency in a method as an argument is valid. Here’s
    an example, starting with the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code represents the `Subject` class that consumes an instance
    of the `Context` from its `Operation` method. It then returns the value of its
    `Number` property.
  prefs: []
  type: TYPE_NORMAL
- en: This example follows a similar pattern to injecting an `HttpContext` into an
    endpoint delegate. In that case, the `HttpContext` represents the current HTTP
    request. In our case, the `Context` contains only an arbitrary number we use in
    the consuming code next.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To test that our code does as it should, we can write the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, it works. We successfully injected the `context` into
    the `subject`. Now to simulate a more complex system, let’s have a look at a theory
    that does the same more dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code showcases the same concept, but xUnit injects the dependencies
    into the method, which is closer to what would happen in a real program. Remember,
    we want to remove the `new` keywords from our life!
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the implementation is not important. I only pieced the simulation
    together to showcase this scenario. One interesting detail is that the `Subject`
    is always the same (singleton) while the `Context` is always different (transient),
    leading to a different outcome every time (`Context { Number = 0 }`, `Context
    { Number = 1 }`, and `Context { Number = 2 }`).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having explored how to inject dependencies, we are ready to roll up our sleeves
    and dive into hands-on coding.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Strategy project, we delve into various methods of injecting dependencies,
    transitioning from the Control Freak approach to a SOLID one. Through this exploration,
    we evaluate the advantages and drawbacks of each technique.The project takes the
    form of a travel agency''s location API, initially returning only hardcoded cities.
    We''ve implemented the same endpoint five times across different controllers to
    facilitate comparison and trace the progression. Each controller comes in pair
    except for one. The pairs comprise a base controller that uses an in-memory service
    (dev) and an updated controller that simulates a SQL database (production). Here’s
    the breakdown of each controller:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ControlFreakLocationsController` instantiates the `InMemoryLocationService`
    class using the `new` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ControlFreakUpdatedLocationsController` instantiates the `SqlLocationService`
    class and its dependency using the `new` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InjectImplementationLocationsController` leverages constructor injection
    to get an instance of the `InMemoryLocationService` class from the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InjectImplementationUpdatedLocationsController` leverages constructor injection
    to get an instance of the `SqlLocationService` class from the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InjectAbstractionLocationsController` leverages dependency injection and
    interfaces to let its consumers change its behavior at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controllers share the same building blocks; let’s start there.
  prefs: []
  type: TYPE_NORMAL
- en: Shared building blocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Location` data structure is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LocationSummary` DTO returned by the controller is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The service interface is the following and has only one method that returns
    one or more `Location` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The two implementations of this interface are an in-memory version to use when
    developing and a SQL version to use when deploying (let’s call this production
    to keep it simple).The in-memory service returns a predefined list of cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL implementation uses an `IDatabase` interface to access the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That database access interface is simply the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the project itself, the `IDatabase` interface has only the `NotImplementedDatabase`
    implementation, which throws a `NotImplementedException` when its `ReadManyAsync`
    method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since the goal is not learning database access, I mocked that part in a test
    case in a xUnit test using the controller and the `SqlLocationService` class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With those shared pieces, we can start with the first two controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Control Freak controllers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This first version of the code showcases the lack of flexibility that creating
    dependencies using the `new` keyword brings when the time to update the application
    arises. Here’s the initial controller that leverages an in-memory collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code works and returns the `LocationSummary` equivalent of the
    `Location` objects returned by the `FetchAllAsync` method of the `InMemoryLocationService`
    class. However, changing the `InMemoryLocationService` to a `SqlLocationService`
    is impossible without changing the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The changes are highlighted in the two code blocks. We could also create an
    if statement to load one or the other conditionally, but exporting this to a whole
    system makes a lot of duplication.**Advantages:**
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to understand the code and what objects the controller uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages:**'
  prefs: []
  type: TYPE_NORMAL
- en: The controller is tightly coupled with its dependencies, leading to a lack of
    flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going from `InMemoryLocationService` to `SqlLocationService` requires updating
    the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s improve on that design next with the next controller pair.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting an implementation in the controllers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This second version of the codebase improves flexibility by leveraging dependency
    injection. In the following controller, we inject the `InMemoryLocationService`
    class in its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the **InMemoryLocationService** class is registered with the container,
    running this code would yield the same result as the Control Freak version and
    return the in-memory cities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register a class with the container, we can do the following:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, to change that service for the `SqlLocationService`, we need
    to change the code again. This time, however, we must only change the constructor
    injection code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is yet another not ideal outcome.**Advantages:**
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to understand the code and what objects the controller uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constructor injection allows changing the dependency in one place, and
    all the methods get it (assuming we have more than one method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can inject subclasses without changing the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages:**'
  prefs: []
  type: TYPE_NORMAL
- en: The controller is tightly coupled with its dependencies, leading to a lack of
    flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going from `InMemoryLocationService` to `SqlLocationService` requires updating
    the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are getting there but still have a last step to make that controller flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting an abstraction in the controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this last controller, we leverage the SOLID principles, constructor injection,
    and, inherently, the Strategy pattern to build a controller that we can change
    from the outside. All we have to do to make the code flexible is inject the interface
    instead of its implementation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines showcase the changes. Injecting the `ILocationService`
    interface lets us control if we inject an instance of the `InMemoryLocationService`
    class, the `SqlLocationService` class, or any other implementation we’d like.This
    is the most flexible possibility we can get.**Advantages:**
  prefs: []
  type: TYPE_NORMAL
- en: Using constructor injection allows changing the dependency in one place, and
    all the methods get it (assuming we have more than one method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting the `ILocationService` interface allows us to inject any of its implementations
    without changing the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the `ILocationService` interface, the controller is loosely coupled
    with its dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages:**'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what objects the controller uses is harder since the dependencies
    are resolved at runtime. However, this forces us to program against an interface
    instead (a good thing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a look at this flexibility in action.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the InjectAbstractionLocationsController
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I created a few xUnit tests to explore the possibilities, making it easy to
    create classes manually.
  prefs: []
  type: TYPE_NORMAL
- en: I used Moq to mock implementations. If you are unfamiliar with Moq and want
    to learn more, I left a link in the *Further Reading* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two of the tests refers to the following member, a static `Location` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The test cases are not to assess the correctness of our code but to explore
    how easy it is to compose the controller differently. Let’s explore the first
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: Mock_the_IDatabase
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first is an integration test that injects an instance of the `SqlLocationService`
    class into the controller and mocks the database. The fake database returns a
    collection of one item. That item is the `Location` instance referenced by the
    `ExpectedLocation` property. Here’s that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows how we can control the dependency we inject into the
    classes because of how the `InjectAbstractionLocationsController` was designed.
    We can’t say the same about the four other controller versions.Next, we call the
    GetAsync method to verify that everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s verify we received that collection of one object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, or instead, we could validate the service called the database mock,
    like this:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of useful features in the Moq library.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Validating that the code was correct is not important for this example. The
    key is to understand the composition of the controller, which the following diagram
    represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Composition of the controller in a test that mocks the IDatabase
    interface](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Composition of the controller in a test that mocks the IDatabase
    interface'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the diagram, the classes depend on interfaces, and we inject
    implementations when building them. The next two tests are simpler than this,
    only depending on the `ILocationService`. Let’s explore the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Use_the_InMemoryLocationService
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Next, we use the in-memory location service to compose the controller like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding code, we injected a different service into
    the controller, changing its behavior. This time, after calling the `GetAsync`
    method, the controller returned the ten `Location` objects from the `InMemoryLocationService`.The
    visual representation of our object tree is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService
    instance.](img/file41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService
    instance.'
  prefs: []
  type: TYPE_NORMAL
- en: It is harder to write assertions for the preceding test because we inject an
    instance of the `InMemoryLocationService` class, which ties the result to its
    implementation. For this reason, we won’t look at that code here. Nonetheless,
    we succeeded at composing the controller differently. Let’s have a look at the
    last test case.
  prefs: []
  type: TYPE_NORMAL
- en: Mock_the_ILocationService
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The last unit test mocks the ILocationService directly. The mock service returns
    a collection of one item. That item is the `Location` instance referenced by the
    `ExpectedLocation` property. Here’s that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the `GetAsync` method, we get the same result as in the first
    test case: a collection of a single test `Location` object. We can assert the
    correctness of the method by comparing values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also leverage Moq to verify that the controller called the `FetchAllAsync`
    method using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The object tree of is very similar to the previous diagram but we faked the
    service implementation, making this a real unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Composition of the controller in a test that mocks the ILocationService
    interface.](img/file42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Composition of the controller in a test that mocks the ILocationService
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: As we explored in this project, with the right design and dependency injection,
    we can easily compose different object trees using the same building blocks. However,
    with a bad design, it is hard to impossible to do so without altering the code.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, we used the `new` keyword in the controller to instantiate
    the DTO. DTOs are stable dependencies. We also explore object mappers in *Chapter
    15*, *Object mappers, Aggregate Services, and Façade*, which is a way to encapsulate
    the logic of copying an object into another.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s conclude before our next subject.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we saw that the strategy pattern went from a simple behavioral
    GoF pattern to the cornerstone of dependency injection. We explored different
    ways of injecting dependencies with a strong focus on constructor injection.Constructor
    injection is the most commonly used approach as it injects required dependencies,
    which we want the most. Method injection allows injecting algorithms, shared states,
    or contexts in a method that could not otherwise access that information. We can
    use property injection to inject optional dependencies, which should rarely happen.You
    can see optional dependencies as code smells because if the class has an optional
    role to play, it also has a primary role resulting in dual responsibilities. Moreover,
    if a role is optional, it could be better to move it to another class or rethink
    the system''s design in that specific area.To practice what you just learned,
    you could connect the code sample to a real database, an Azure Table, Redis, a
    JSON file, or any other data source—tip: code classes that implement the `ILocationService`
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: As we covered, we can inject classes into other classes directly. There is nothing
    wrong with that. However, I suggest injecting interfaces as your initial approach
    until you are confident that you have mastered the different architectural principles
    and patterns covered in this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore guard clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding guard clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A guard clause represents a condition the code must meet before executing a
    method. Essentially, it''s a type of code that "guards" against continuing the
    execution of the method if certain conditions aren''t met.In most cases, guard
    clauses are implemented at the beginning of a method to throw an exception early
    when the conditions necessary for the method''s execution are not satisfied. Throwing
    an exception allows callers to catch the error without the need to implement a
    more complex communication mechanism.We already stated that we use constructor
    injection to inject the required dependencies reliably. However, nothing fully
    guarantees us that the dependencies are not `null`. Ensuring a dependency is not
    `null` is one of the most common guard clauses, which is trivial to implement.
    For example, we could check for nulls in the controller by replacing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses a `throw` expression from C# 7 (See *Appendix A* for
    more information). The `ArgumentNullException` type makes it evident that the
    `locationService` parameter is `null`. So if the `locationService` parameter is
    `null`, an `ArgumentNullException` is thrown; otherwise, the `locationService`
    parameter is assigned to the `_locationService` member.Of course, with the introduction
    of the nullable reference types (see *Appendix A*), receiving a `null` argument
    is less likely yet still possible.
  prefs: []
  type: TYPE_NORMAL
- en: A built-in container will automatically throw an exception if it can’t fulfill
    all dependencies during the instantiation of a class (such as a controller). That
    does not mean that all third-party containers act the same.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moreover, that does not protect you from passing `null` to a class you manually
    instantiates, nor that a method will not receive a `null` value. I recommend adding
    guards even since they are less mandatory now. The tooling can handle most of
    the work for us, leading to only a minor time overhead.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Furthermore, suppose you are writing code consumed by other projects, like a
    library. In that case, adding guards is more important since nothing guarantees
    that the consumers of that code have nullable reference type checks enabled.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When we need to validate a parameter and don''t need an assignment, like with
    most parameters of a constructor, we can use the following helper, and the BCL
    handles the check for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When we need to validate a string and want to ensure it is not empty, we can
    use the following instead:ArgumentException.ThrowIfNullOrEmpty(name);Of course,
    we can always revert to `if` statements to validate parameters. When doing so,
    we must ensure we throw relevant exceptions. If no pertinent exceptions exist,
    we can create one. Creating custom exceptions is a great way to write manageable
    applications.Next, we revisit an (anti-)pattern while exploring the singleton
    lifetime replacing it.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Singleton pattern is obsolete, goes against the SOLID principles, and we
    replace it with a lifetime, as we’ve already seen. This section explores that
    lifetime and recreates the good old application state, which is nothing more than
    a singleton-scoped dictionary.We explore two examples: one about the application
    state, in case you were wondering where that feature disappeared to. Then, the
    Wishlist project also uses the singleton lifetime to provide an application-level
    feature. There are also a few unit tests to play with testability and to allow
    safe refactoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Project – Application state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might remember the application state if you programmed ASP.NET using .NET
    Framework or the “good” old classic ASP with VBScript. If you don’t, the application
    state was a key/value dictionary that allowed you to store data globally in your
    application, shared between all sessions and requests. That is one of the things
    that ASP always had and other languages, such as PHP, did not (or do not easily
    allow).For example, I remember designing a generic reusable typed shopping cart
    system with classic ASP/VBScript. VBScript was not a strongly typed language and
    had limited object-oriented capabilities. The shopping cart fields and types were
    defined at the application level (once per application), and then each user had
    their own “instance” containing the products in their “private shopping cart”
    (created once per session).In ASP.NET Core, there is no more `Application` dictionary.
    To achieve the same goal, you could use a static class or static members, which
    is not the best approach; remember that global objects (`static`) make your application
    harder to test and less flexible. We could also use the Singleton pattern or create
    an ambient context, allowing us to create an application-level instance of an
    object. We could even mix that with a factory to create end-user shopping carts,
    but we won’t; these are not the best solution either. Another way could be to
    use one of the ASP.NET Core caching mechanisms, memory cache, or distributed cache,
    but this is a stretch.We could also save everything in a database to persist the
    shopping cart between visits, but that is not related to the application state
    and requires more work, potentially a user account, so we will not do that either.We
    could save the shopping cart on the client-side using cookies, local storage,
    or any other modern mechanism to save data on the user’s computer. However, we’d
    get even further from the application state than using a database.For most cases
    requiring an application state-like feature, the best approach would be to create
    a standard class and an interface and then register the binding with a singleton
    lifetime in the container. Finally, you inject it into the component that needs
    it, using constructor injection. Doing so allows the mocking of dependencies and
    changing the implementations without touching the code but the composition root.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the best solution is not the technically complex ones or design pattern-oriented;
    the best solution is often the simplest. Less code means less maintenance and
    fewer tests, resulting in a simpler application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s implement a small program that simulates the application state. The API
    is a single interface with two implementations. The program also exposes part
    of the API over HTTP, allowing users to get or set a value associated with the
    specified key. We use the singleton lifetime to ensure the data is shared between
    all requests.The interface looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the value associated with a key, associate a value with a key (set),
    and validate whether a key exists.The `Program.cs` file contains the code responsible
    for handling HTTP requests. We can swap the implementations by commenting or uncommenting
    the first line of the `Program.cs` file, which is `#define USE_MEMORY_CACHE`.
    That changes the dependency registration, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now explore the first implementation.
  prefs: []
  type: TYPE_NORMAL
- en: First implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first implementation uses the memory cache system, and I thought it would
    be educational to show that to you. Caching data in memory is something you might
    need to do sooner rather than later. However, we are hiding the cache system behind
    our implementation, which is also educational.Here is the `ApplicationMemoryCache`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `ApplicationMemoryCache` class is a thin wrapper over `IMemoryCache`, hiding
    the implementation details. Such a wrapper is similar to the Façade and Adapter
    patterns we explore in *Chapter 11*, *Structural Patterns*.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This simple class and two lines in our composition root make it an application-wide
    key-value store; done already! Let’s now explore the second implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Second implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The second implementation uses `ConcurrentDictionary<string, object>` to store
    the application state data and ensure thread safety, as multiple users could use
    the application state simultaneously. The `ApplicationDictionary` class is almost
    as simple as `ApplicationMemoryCache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code leverages the `TryGetValue` and `AddOrUpdate` methods to
    ensure thread safety while keeping the logic to a minimum and ensuring we avoid
    coding mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Can you spot the flaw that might cause some problems in this design? See the
    solution at the end of the project section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s explore how to use the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the implementations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can now use any of the two implementations without impacting the rest of
    the program. That demonstrates the strength of DI when it comes to dependency
    management. Moreover, we control the lifetime of the dependencies from the composition
    root.If we were to use the `IApplicationState` interface in another class, say
    `SomeConsumer`, its usage could look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In that code, `SomeConsumer` depends only on the `IApplicationState` interface,
    not `ApplicationDictionary` or `ApplicationMemoryCache`, and even less on `IMemoryCache`
    or `ConcurrentDictionary<string, object>`. Using DI allows us to hide the implementation
    by inverting the flow of dependencies. It also breaks direct coupling between
    concrete implementations. This approach also promotes programming against interfaces,
    as recommended by the Dependency Inversion Principle (DIP), and facilitates the
    creation of open-closed classes, in accordance with the Open/Closed Principle
    (OCP).Here is a diagram illustrating our application state system, making it visually
    easier to notice how it breaks coupling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: DI-oriented diagram representing the application state system](img/file43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: DI-oriented diagram representing the application state system'
  prefs: []
  type: TYPE_NORMAL
- en: From this sample, let’s remember that the singleton lifetime allows us to reuse
    objects between requests and share them application-wide. Moreover, hiding implementation
    details behind interfaces can improve the flexibility of our design.It is important
    to note that the singleton scope is only valid in a single process, so you can’t
    rely purely on in-memory mechanisms for larger applications that span multiple
    servers. We could use the `IDistributedCache` interface to circumvent this limitation
    and persist our application state system to a persistent caching tool, like Redis.
  prefs: []
  type: TYPE_NORMAL
- en: '**The flaw**: If we look closely at the `Has<TItem>` method, it returns true
    only when an entry is present for the specified key AND has the right type. So
    we could override an entry of a different type without knowing it exists.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, `ConsumerA` sets an item of type `A` for the key `K`. Elsewhere
    in the code, `ConsumerB` looks to see if an item of type `B` exists for the key
    `K`. The method returns `false` because it’s a different type. `ConsumerB` overrides
    the value of the `K` with an object of type `B`. Here’s the code representing
    this:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Improving the design to support such a scenario could be a good practice exercise.
    You could, for example, remove the `TItem` type from the `Has` method or, even
    better, allow storing multiple items under the same key, as long as their types
    are different.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s now explore the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Wishlist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get into another sample to illustrate using the singleton lifetime and
    DI. Seeing DI in action should help understand it and then leverage it to create
    SOLID software.**Context**: The application is a site-wide wishlist where users
    can add items. Items expire every 30 seconds. When a user adds an existing item,
    the system must increment the count and reset the item’s expiration time. That
    way, popular items stay on the list longer, making it to the top. When displayed,
    the system must sort the items by count (highest count first).'
  prefs: []
  type: TYPE_NORMAL
- en: An expiration time of 30 seconds is very fast, but I’m sure you don’t want to
    wait days before an item expires when running the app. It is a test config.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The program is a tiny web API that exposes two endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an item to the wishlist (`POST`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the wishlist (`GET`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The wishlist interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The two operations are there, and by making them async (returning a `Task<T>`),
    we could implement another version that relies on a remote system, such as a database,
    instead of an in-memory store. Then, the `WishListItem` record class is part of
    the `IWishList` contract; it is the model. To keep it simple, the wishlist only
    stores the names of items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Trying to foresee the future is not usually a good idea, but designing APIs
    to be awaitable is generally a safe bet. Other than this, I’d recommend you stick
    to the simplest code that satisfies the program's needs (KISS). When you try to
    solve problems that do not exist yet, you usually end up coding a lot of useless
    stuff, leading to additional unnecessary maintenance and testing time.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the composition root, we must serve the `IWishList` implementation instance
    in a singleton scope (highlighted) so all requests share the same instance. Let’s
    start with the first half of the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering where `IConfigureOptions`, `IValidateOptions`, and `IOptions`
    come from, we cover the ASP.NET Core Options pattern in *Chapter 9*, *Options,
    Settings, and Configuration*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s now look at the second half of the `Program.cs` file that contains the
    minimal API code to handle the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GET` endpoint delegates the logic to the injected `IWishList` implementation
    and returns the result, while the `POST` endpoint validates the `CreateItem` DTO
    before delegating the logic to the wishlist.To help us implement the `InMemoryWishList`
    class, we started by writing some tests to back our specifications up. Since static
    members are hard to configure in tests (remember globals?), I borrowed a concept
    from the ASP.NET Core memory cache and created an `ISystemClock` interface that
    abstracts away the static call to `DateTimeOffset.UtcNow` or `DateTime.UtcNow`.This
    way, we can program the value of `UtcNow` in our tests to create expired items.
    Here’s the clock interface and implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '.NET 8 adds a new `TimeProvider` class to the `System` namespace, which does
    not help us much here. However, if we want to leverage that API, we could update
    the SystemClock to the following:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: That code leverages the new API, but we’ll stick to our simple implementation
    instead.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s look at the outline of the unit tests next because the whole code would
    take pages and be of low value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The full source code is on GitHub: [https://adpg.link/ywy8](https://adpg.link/ywy8).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the test class, we can mock the `ISystemClock` interface and program it
    to obtain the desired results based on each test case. We can also program some
    helper methods to make it easier to read the tests. Those helpers use tuples to
    return multiple values (see *Appendix A* for more information on language features).
    Here’s the mock field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of such a helper method setting the clock to the present
    time and the `ExpectedExpiryTime` to a later time (`UtcNow + ExpirationInSeconds`
    later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of another helper method setting the clock and the `ExpectedExpiryTime`
    to the past (two-time `ExpirationInSeconds` for the clock and once `ExpirationInSeconds`
    for the `ExpectedExpiryTime`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have five tests covering the `AddOrRefreshAsync` method and two covering
    the `AllAsync` method. Now that we have those failing tests, here is the implementation
    of the `InMemoryWishList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `InMemoryWishList` class uses `ConcurrentDictionary<string, InternalItem>`
    internally to store the items and make the wishlist thread-safe. It also uses
    a `with` expression to manipulate and copy the `InternalItem` record class.The
    `AllAsync` method filters out expired items, while the `AddOrRefreshAsync` method
    removes expired items. This might not be the most advanced logic ever, but that
    does the trick.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the code is not the most elegant of all, and I left
    it this way on purpose. While using the test suite, I invite you to refactor the
    methods of the `InMemoryWishList` class to be more readable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I took a few minutes to refactor it myself and saved it as `InMemoryWishListRefactored`.
    You can also uncomment the first line of `InMemoryWishListTest.cs` to test that
    class instead of the main one. My refactoring is a way to make the code cleaner,
    to give you ideas. It is not the only way, nor the best way, to write that class
    (the “best way” being subjective).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lastly, optimizing for readability and performance are often very different
    things.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Back to DI, the line that makes the wishlist shared between users is in the
    composition root we explored earlier. As a reference, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Yes, only that line makes all the difference between creating multiple instances
    and a single shared instance. Setting the lifetime to Singleton allows you to
    open multiple browsers and share the wishlist.
  prefs: []
  type: TYPE_NORMAL
- en: To `POST` to the API, I recommend using the `Wishlist.http` file in the project
    or the Postman collection ([https://adpg.link/postman6](https://adpg.link/postman6))
    that comes with the book. The collection already contains multiple requests you
    can execute in batches or individually. You can also use the Swagger UI that I
    added to the project.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That’s it! All that code to demo what a single line of code in the composition
    root can do, and we have a working program, as tiny as it may be.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section explored replacing the classic Singleton pattern with a standard
    instantiable class registered with a singleton lifetime. We looked at the old
    application state, learned that it was no more, and implemented two versions of
    it. We no longer need that, but it was a good way of learning about singletons.We
    then implemented a wishlist system as a second example. We concluded that the
    whole thing was working due to and managed by a single line of the composition
    root: the call to the `AddSingleton` method. Changing that line could drastically
    change the system''s behavior, making it unusable.From now on, you can see the
    Singleton pattern as an anti-pattern in .NET, and unless you find strong reasons
    to implement it, you should stick to normal classes and DI instead. Doing this
    moves the creation responsibility from the singleton class to the composition
    root, which is the composition root’s responsibility, leaving the class only one
    responsibility.Next, we explore the Service Locator anti-pattern/code smell.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Service Locator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service Locator is an anti-pattern that reverts the IoC principle to its Control
    Freak roots. The only difference is using the IoC container to build the dependency
    tree instead of the `new` keyword.There is some use of this pattern in ASP.NET,
    and we may argue that there are some reasons for using the Service Locator pattern,
    but it should happen rarely or never in most applications. For that reason, let’s
    call the Service Locator pattern a **code smell** instead of an **anti-pattern**.My
    strong recommendation is *don’t use the Service Locator pattern* unless you know
    you are not creating hidden coupling or have no other option. As a rule of thumb,
    you want to avoid injecting an `IServiceProvider` in your application’s codebase.
    Doing so reverts to the classic flow of control and defeats the purpose of dependency
    injection.A good use of Service Locator could be to migrate a legacy system that
    is too big to rewrite. So you could build the new code using DI and update the
    legacy code using the Service Locator pattern, allowing both systems to live together
    or migrate one into the other, depending on your goal. Fetching dependencies dynamically
    is another potential use of the Service Locator pattern; we explore this in *Chapter
    15*, *Object Mappers, Aggregate Services, and Façade*.Without further ado, let’s
    jump into some more code.
  prefs: []
  type: TYPE_NORMAL
- en: Project – ServiceLocator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to avoid something is to know about it, so let’s see how to implement
    the Service Locator pattern using `IServiceProvider` to find a dependency.The
    service we want to use is an implementation of `IMyService`. Let’s start with
    the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface inherits from the `IDisposable` interface and contains a single
    `Execute` method. Here is the implementation, which does nothing more than throw
    an exception if the instance has been disposed of (we’ll leverage this later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s add a controller that implements the Service Locator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, instead of injecting `IMyService` into the constructor,
    we are injecting `IServiceProvider`. Then, we use it (highlighted line) to locate
    the `IMyService` instance. Doing so shifts the responsibility for creating the
    object from the container to the consumer (`MyController`, in this case). `MyController`
    should not be aware of `IServiceProvider` and should let the container do its
    job without interference.What could go wrong? If we run the application and navigate
    to `/service-locator`, everything works as expected. However, if we reload the
    page, we get an error thrown by the `Execute()` method because we called `Dispose()`
    during the previous request. `MyController` should not control its injected dependencies,
    which is the point that I am trying to emphasize here: leave the container to
    control the lifetime of dependencies rather than trying to be a control freak.
    Using the Service Locator pattern opens pathways toward those wrong behaviors,
    which will likely cause more harm than good in the long run.Moreover, even though
    the ASP.NET Core container does not natively support this, we lose the ability
    to inject dependencies contextually when using the Service Locator pattern because
    the consumer controls its dependencies. What do I mean by contextually? Let’s
    assume we have two classes, `A` and `B`, implementing interface `I`. We could
    inject an instance of `A` into `Consumer1` but an instance of `B` into `Consumer2`.Before
    exploring ways to fix this, here is the `Program.cs` code that powers this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code enables controller support and registers our service.To
    fix the controller, we must either remove the using statement or even better:
    move away from the Service Locator pattern and inject our dependencies instead.
    Of course, you are reading a dependency injection chapter, so I picked moving
    away from the Service Locator pattern. Here''s what we are about to tackle:'
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with method injection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing method injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following controller uses *method injection* instead of the Service Locator
    pattern. Here’s the code that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FromServicesAttribute` class tells the model binder about method injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a guard clause to protect us from `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we kept the original code except for the `using` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method injection like this is convenient when a controller has multiple actions
    but only one uses the service.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s reexplore constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing constructor injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, you should be familiar with constructor injection. Nonetheless,
    next is the controller''s code after migrating the Service Locator pattern to
    constructor injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When using constructor injection, we ensure that `IMyService` is not `null`
    upon class instantiation. Since it is a class member, it is even less tempting
    to call its `Dispose()` method in an action method, leaving that responsibility
    to the container (as it should be).Let’s analyze the code before moving to the
    next possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the strategy pattern with constructor injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a guard clause to ensure no `null` value could get in at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We simplified the action to the bare minimum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both techniques are an acceptable replacement for the Service Locator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a minimal API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, we can do the same with a minimal API. Here is the code of that
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'That code does the same as the method injection sample without the guard clause
    that I omitted because no external consumer will likely inject nulls into it:
    the endpoint is a delegate passed directly to the `MapGet` method.Refactoring
    out the Service Locator pattern is often as trivial as this.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time, by following the Service Locator anti-pattern, we only hide
    that we are taking control of objects instead of decoupling our components. The
    code sample demonstrated a problem when disposing of an object, which could also
    happen using constructor injection. However, when thinking about it, it is more
    tempting to dispose of an object that we create than one we inject.Moreover, the
    service locator takes control away from the container and moves it into the consumer,
    against the **Open-Closed Principle**. You should be able to update the consumer
    by updating the composition root’s bindings.In the case of the sample code, we
    could change the binding, and it would work. In a more advanced case, binding
    two implementations to the same interface would be tough when contextual injection
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: The IoC container is responsible for weaving the program’s thread, connecting
    its pieces together where each independent piece should be as clueless as possible
    about the others.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On top of that, the Service Locator pattern complicates testing. When unit testing
    your class, you must mock a container that returns a mocked service instead of
    mocking only the service.One place where I can see its usage justified is in the
    composition root, where bindings are defined, and sometimes, especially when using
    the built-in container, we can’t avoid it to compensate for the lack of advanced
    features. Another good place would be a library that adds functionalities to the
    container. Other than that, try to stay away!
  prefs: []
  type: TYPE_NORMAL
- en: '**Beware**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moving the service locator elsewhere does not make it disappear; it only moves
    it around, like any dependency. However, moving it to the composition root can
    improve the maintainability of that code and remove the tight coupling.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we revisit our third and final pattern of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A factory creates other objects; it is like a literal real-world factory. We
    explored in the previous chapter how to leverage the Abstract Factory pattern
    to create families of objects. A factory can be as simple as an interface with
    one or more `Create[Object]` methods or, even more, a simple delegate. We explore
    a DI-oriented simple factory in this section. We are building on top of the Strategy
    pattern example.In that example, we coded two classes implementing the `ILocationService`
    interface. The composition root used the `#define` preprocessor directive to tell
    the compiler what bindings to compile. In this version, we want to choose the
    implementation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Not compiling the code we don’t need is good for many reasons, including security
    (lowering the attack surface). In this case, we are simply using an alternative
    strategy useful for many scenarios.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To achieve our new goal, we can extract the construction logic of the `ILocationService`
    interface into a factory.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the project, a copy from the Strategy project, we start by renaming the
    `InjectAbstractionLocationsController` class to `LocationsController`. We can
    then delete the other controllers.Now, we want to change the `ILocationService`
    bindings to reflect the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: When developing the application, we use the `InMemoryLocationService` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deploying to any environment, we must use the `SqlLocationService` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve this, we use the `Environment` property of the `WebApplicationBuilder`
    object. That property of type `IWebHostEnvironment` contains some useful properties
    like the `EnvironmentName`, and .NET adds extension methods, like the `IsDevelopment`
    method that returns true when the `EnvironmentName` equals `Development`. Here’s
    the `Program.cs` file code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is fairly straightforward; it registers a delegate to act
    as a factory, which builds the appropriate service based on the ASP.NET Core `Environment`.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `new` keyword here, but is this wrong? The composition root
    is where we should create or configure elements, so instantiating objects there
    is correct, as it is to use the Service Locator pattern. It is best to avoid the
    `new` keyword and the Service Locator pattern whenever possible, but using the
    default container makes it harder than with a full-featured third-party one. Nevertheless,
    we can avoid doing that in many cases, and even if we must use the `new` keyword
    and the Service Locator pattern, we often don’t need a third-party container.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When we run the program, the right instance is injected into the controller
    based on the logic we added to the factory. The flow is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A client sends an HTTP request to the controller (`GET /travel/locations`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ASP.NET Core creates the controller and leverages the IoC container to inject
    the `ILocationService` dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our factory creates the correct instance based on the current environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The action method runs, and the client receives the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could also create a factory class and an interface, as explored in the previous
    chapter. However, in this case, it would likely just create noise.
  prefs: []
  type: TYPE_NORMAL
- en: An essential thing to remember is that *moving code around your codebase does
    not make that code, logic, dependencies, or coupling disappear*. Coding a factory
    doesn’t make all your design issues disappear. Moreover, adding more complexity
    adds a cost to your project, so factory or not, each time you try to break tight
    coupling or remove a dependency, ensure that you are not just moving the responsibility
    elsewhere or overengineering your solution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, to keep our composition root clean, we could create an extension
    method that does the registration, like an `AddLocationService` method. I’ll leave
    you to try this one out, find other ways to improve the project, or even improve
    one of your own projects.The possibilities are almost endless when you think about
    the Factory patterns. Now that you’ve seen a few in action, you may find other
    uses for a factory when injecting some classes with complex instantiation logic
    into other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter delved into Dependency Injection, understanding its crucial role
    in crafting adaptable systems. We learned how DI applies the Inversion of Control
    principle, shifting dependency creation from the objects to the composition root.
    We explored the IoC container''s role in object management, service resolution
    and injection, and dependency lifetime management. We tackled the Control Freak
    anti-pattern, advocating for dependency injection over using the `new` keyword.We
    revisited the Strategy pattern and explored how to use it with Dependency Injection
    to compose complex object trees. We learned about the principle of composition
    over inheritance, which encourages us to inject dependencies into the classes
    instead of relying on base class features and inheritance. We explored different
    ways of injecting dependencies into objects, including constructor injection,
    property injection, and method injection.We learned that a guard clause is a condition
    that must be met before a method is executed, often used to prevent null dependencies.
    We explored how to implement guard clauses. We also discussed the importance of
    adding guard clauses, as nullable reference type checks offer no guarantee at
    runtime.We revisited the Singleton pattern and how to replace it with a lifetime.
    We explored two examples utilizing the singleton lifetime to provide application-level
    features.We delved into the Service Locator pattern, often considered an anti-pattern,
    as it can create hidden coupling and revert the Inversion of Control principle.
    We learned that avoiding using the Service Locator pattern is generally best.
    We explored how to implement the Service Locator pattern and discussed the potential
    issues that could arise. We revisited the Factory pattern and learned how to build
    a simple, DI-oriented factory that replaces the object creation logic of the IoC
    container.**Here are the key takeaways from this substantial chapter**:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection is a technique applying the Inversion of Control principle
    for effective dependency management and lifetime control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IoC container resolves and manages dependencies, offering varying control
    over object behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can categorize dependencies into stable and volatile, the latter justifying
    DI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lifetime of a service is Transient, Scoped, or Singleton.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection allows us to avoid the Control Freak anti-pattern and stop
    creating objects with the `new` keyword, improving flexibility and testability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Service Locator pattern often creates hidden coupling and should be avoided
    but in the composition root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The composition root is where we register our service bindings with the IoC
    container; in the `Program.cs` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing objects using the Strategy pattern alongside constructor injection
    facilitates handling complex object trees, emphasizing the principle of composition
    over inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of constructor injection, there’s also method injection and property
    injection, which are less supported. It is best to prioritize constructor injection
    over the others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard clauses safeguard method execution from unmet conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is better to avoid the Singleton pattern in favor of binding a class and
    an interface with a singleton lifetime in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory pattern is ideal for creating objects with complex instantiation
    logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving code around doesn't eliminate dependencies or coupling; it's important
    not to overengineer solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In subsequent sections, we explore tools that add functionalities to the default
    built-in container. Meanwhile, we explore options, settings, and configurations
    in the next chapter. These ASP.NET Core patterns aim to make our lives easier
    when managing such common problems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the three DI lifetimes that we can assign to objects in ASP.NET Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the composition root for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that we should avoid the `new` keyword when instantiating volatile
    dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pattern that we revisited in this chapter that helps compose objects
    to eliminate inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the Service Locator pattern a design pattern, a code smell, or an anti-pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the principle of composition over inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some links to build upon what we have learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moq: [https://adpg.link/XZv8](https://adpg.link/XZv8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need more options, such as contextual injections, you can check out
    an open-source library I built. It adds support for new scenarios: [https://adpg.link/S3aT](https://adpg.link/S3aT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official documentation, Default service container replacement: [https://adpg.link/5ZoG](https://adpg.link/5ZoG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transient, Scoped, Singleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The composition root holds the code that describes how to compose the program’s
    object graph—the types bindings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, it is true. Volatile dependencies should be injected instead of instantiated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Strategy pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Service Locator pattern is all three. It is a design pattern used by DI
    libraries internally but becomes a code smell in application code. If misused,
    it is an anti-pattern with the same drawbacks as using the `new` keyword directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The principle of composition over inheritance encourages us to inject dependencies
    into classes and use them instead of relying on base class features and inheritance.
    This approach promotes flexibility and code reuse. It also negates the need for
    the LSP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
