- en: Chapter 4. Composing Event-Based Programs Using Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用响应式扩展（Reactive Extensions）组合基于事件的程序
- en: 'This chapter deals with **Reactive Extensions** (**Rx**). To understand Rx,
    we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论**响应式扩展**（**Rx**）。为了理解Rx，我们将涵盖以下食谱：
- en: Installing Rx
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Rx
- en: Events versus observables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件与可观察对象
- en: Using LINQ to perform queries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ执行查询
- en: Using schedulers in Rx
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rx中使用调度器
- en: Debugging lambda expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试lambda表达式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Often, during your day-to-day dealings with developing applications in C#, you
    will have to use asynchronous programming. You might also have to deal with many
    data sources. Think of a web service that returns the current exchange rates,
    a Twitter search returning a stream of related data, or even different events
    generated by multiple computers. Rx provides an elegant solution in the form of
    the `IObserver<T>` interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在用C#开发应用程序的日常事务中，你将不得不使用异步编程。你也可能需要处理许多数据源。想想一个返回当前汇率的服务器，一个返回相关数据流的Twitter搜索，或者甚至由多台计算机生成的事件。Rx提供了一个优雅的解决方案，即`IObserver<T>`接口。
- en: 'You use the `IObserver<T>` interface to subscribe to the events. Then, the
    `IObservable<T>` interface, which maintains a list of `IObserver<T>` interfaces,
    will notify them on the change of state. In essence, Rx will stick together multiple
    data sources (social media, RSS feeds, UI events, and so on) that generate data.
    Rx, therefore, brings these data sources together in one interface. In fact, Rx
    can be thought of as consisting of three sections:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`IObserver<T>`接口来订阅事件。然后，维护`IObserver<T>`接口列表的`IObservable<T>`接口将在状态变化时通知它们。本质上，Rx会将多个数据源（社交媒体、RSS源、UI事件等）粘合在一起生成数据。因此，Rx将这些数据源汇集在一个接口中。实际上，Rx可以被视为由三个部分组成：
- en: '**Observables**: The interface that brings together and represents all these
    data streams'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察对象**：将所有这些数据流汇集在一起并代表的接口'
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple data streams'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）：使用LINQ查询这些多个数据流的能力'
- en: '**Schedulers**: Parametrizing concurrency using schedulers'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：使用调度器参数化并发'
- en: 'The question on many minds might be why developers should use (or find use
    for) Rx. Here are a few examples where Rx are really useful:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人心中可能都会问，为什么开发者应该使用（或找到使用）Rx。以下是一些Rx真正有用的例子：
- en: Creating a search that has an autocomplete function. You don't want the code
    to perform a search for each value you type into the search area. Rx allows you
    to throttle the search.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有自动完成功能的搜索。你不想代码为搜索区域中输入的每个值执行搜索。Rx允许你限制搜索。
- en: Making the UI of your application more responsive.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的应用程序的用户界面更加响应。
- en: Being notified when data changes instead of having to poll the data for changes.
    Think of real-time stock prices.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据发生变化时被通知，而不是必须轮询数据以查找变化。想想实时股价。
- en: 'To keep up to date with Rx, you can have a look at the GitHub page: [https://github.com/Reactive-Extensions/Rx.NET](https://github.com/Reactive-Extensions/Rx.NET).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要保持Rx的更新，你可以查看GitHub页面：[https://github.com/Reactive-Extensions/Rx.NET](https://github.com/Reactive-Extensions/Rx.NET)。
- en: Installing Rx
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Rx
- en: Before we can begin exploring Rx, we need to install it. The easiest way to
    do this is using NuGet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索Rx之前，我们需要安装它。最简单的方法是使用NuGet。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this chapter on Rx, we will not create a separate class. All the code will
    be written in a console application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章节关于Rx的内容，我们不会创建一个单独的类。所有代码都将编写在控制台应用程序中。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Right-click on your solution and select **Manage NuGet Packages for Solution…**
    from the context menu:![How to do it…](img/B05391_04_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击你的解决方案，从上下文菜单中选择**管理解决方案的NuGet包…**：![如何操作…](img/B05391_04_01.jpg)
- en: In the window that is displayed afterwards, type `System.Reactive` in the search
    text box and search for the NuGet installer:![How to do it…](img/B05391_04_02.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后显示的窗口中，在搜索文本框中输入`System.Reactive`并搜索NuGet安装程序：![如何操作…](img/B05391_04_02.jpg)
- en: At the time of writing this book, the last stable release was version 3.0.0\.
    Next, select the projects that you want to install Rx on. For simplicity sake,
    we just selected it to be installed project wide:![How to do it…](img/B05391_04_03.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本书时，最后一个稳定的版本是3.0.0。接下来，选择你想要安装Rx的项目。为了简单起见，我们只是将其安装到整个项目中：![如何操作…](img/B05391_04_03.jpg)
- en: The next screenshot that is displayed is a confirmation dialog box, asking you
    to confirm the changes to the project. It will show a preview of the changes it
    will be making to each project. If you are happy with the changes, click on the
    **OK** button:![How to do it…](img/B05391_04_04.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个显示的截图是一个确认对话框，询问你确认对项目的更改。它将显示它将对每个项目进行的更改预览。如果你对更改满意，请点击**确定**按钮：![如何操作…](img/B05391_04_04.jpg)
- en: A license agreement might be presented to you in the last dialog screen, which
    you will need to accept. To continue, click on the **I Accept** button.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个对话框屏幕可能会显示一个许可协议，你需要接受它。要继续，请点击**我接受**按钮。
- en: 'After the installation is complete, you will see the references added to Rx
    under the **References** node in your project. These are as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你将在项目的**引用**节点下看到添加到Rx的引用。具体如下：
- en: '`System.Reactive.Core`'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Core`'
- en: '`System.Reactive.Interfaces`'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Interfaces`'
- en: '`System.Reactive.Linq`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Linq`'
- en: '`System.Reactive.PlatformServices`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.PlatformServices`'
- en: '![How to do it…](img/B05391_04_06.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/B05391_04_06.jpg)'
- en: How it works…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'NuGet is by far the easiest way to add additional components to your projects.
    As you can see from the added references, `System.Reactive` is the main assembly.
    To gain a better understanding of `System.Reactive`, view the assemblies in **Object
    Browser**. To do this, double-click on any of the assemblies in the **References**
    option of your project:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet是向你的项目添加额外组件的最简单方法。正如你所看到的添加的引用，`System.Reactive`是主要程序集。为了更好地理解`System.Reactive`，查看**对象浏览器**中的程序集。为此，请双击项目**引用**选项中的任何程序集：
- en: '![How it works…](img/B05391_04_07.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_04_07.jpg)'
- en: '`System.Reactive.Linq` contains all the querying functionality in Rx. You will
    also notice that `System.Reactive.Concurrency` contains all the schedulers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Reactive.Linq`包含Rx中的所有查询功能。你还会注意到`System.Reactive.Concurrency`包含所有调度器。'
- en: Events versus observables
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件与可观察对象
- en: 'Being developers, we should all be quite familiar with events. Most developers
    have been creating events since we started writing code. In fact, if you have
    even dropped a button control on a form and double-clicked the button to create
    the method that handles the click of the button, you have created an event. In
    .NET, we can declare events using the `event` keyword, publish to the event by
    invoking it, and subscribe to that event by adding a handler to the event. We
    therefore have the following operations:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们都应该非常熟悉事件。大多数开发者自从开始编写代码以来就一直在创建事件。实际上，如果你甚至在表单上放置了一个按钮控件，并双击按钮以创建处理按钮点击的方法，你就已经创建了一个事件。在.NET中，我们可以使用`event`关键字声明事件，通过调用它来发布到事件，并通过向事件添加处理程序来订阅该事件。因此，我们有以下操作：
- en: Declare
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明
- en: Publish
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布
- en: Subscribe
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: With Rx, we have a similar structure where we declare a data stream, publish
    data to that stream, and subscribe to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rx，我们有类似的架构，其中我们声明一个数据流，向该流发布数据，并订阅它。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: First, we will see how an event works in C#. We will then see the working of
    an event using Rx and, in doing so, highlight the differences.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到C#中事件是如何工作的。然后，我们将使用Rx查看事件的工作原理，并在此过程中突出显示差异。
- en: How to do it…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In your console application, add a new class called `DotNet`. To this class,
    add a property called `AvailableDatatype`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的控制台应用程序中，添加一个名为`DotNet`的新类。向此类添加一个名为`AvailableDatatype`的属性：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the main program class, add a new static action event called `types`. Basically,
    this is just a delegate and will receive some value, in our case, the available
    .NET data types:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主程序类中，添加一个名为`types`的新静态操作事件。基本上，这只是一个委托，将接收一些值，在我们的例子中，是可用的.NET数据类型：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside `void Main`, create a `List<DotNet>` class called `lstTypes`. Inside
    this list, add several values of type `DotNet` class. Here, we will just add hardcoded
    data of some of the data types in .NET:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void Main`内部，创建一个名为`lstTypes`的`List<DotNet>`类。在这个列表中，添加几个`DotNet`类的值。在这里，我们只添加一些.NET数据类型的硬编码数据：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our next task is to subscribe to this event with an event handler that is simply
    outputting the value of *x* to the console window. We will then raise the event
    each time we loop through our `lstTypes` list by adding the line `types(lstTypes[i].AvailableDatatype);`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来的任务是使用一个简单地将*x*的值输出到控制台窗口的事件处理程序来订阅此事件。然后，每次我们通过添加`types(lstTypes[i].AvailableDatatype);`行来遍历`lstTypes`列表时，我们将引发事件：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, before raising an event, we should always check that the event isn't
    null. Only after this check should we raise the event. For brevity, we have not
    added this check before raising the event.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，在引发事件之前，我们应该始终检查事件是否为null。只有在这个检查之后，我们才应该引发事件。为了简洁，我们在引发事件之前没有添加这个检查。
- en: 'When you have added all the code from step 1 to step 4, your console application
    should look like this:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将步骤1到步骤4的所有代码添加完毕后，你的控制台应用程序应该看起来像这样：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running your application will set our list with values and then raise the event
    created to output the values of the list to the console window:![How to do it…](img/B05391_04_08.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序将设置我们的值列表，然后引发创建的事件，将列表的值输出到控制台窗口：![如何做…](img/B05391_04_08.jpg)
- en: 'Let''s see the working of events using Rx. Add a static `Subject` of `string`.
    You might also need to add the `System.Reactive.Subjects` namespace to your project
    as `Subjects` live in this separate namespace:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看使用Rx的事件的工作原理。添加一个静态的`Subject`字符串。你可能还需要将`System.Reactive.Subjects`命名空间添加到你的项目中，因为`Subjects`位于这个单独的命名空间中：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the code that created the list of `DotNet`, we used `+=` to wire up an
    event handler. This time round, we will use `Subscribe`. This is the `IObservable`
    portion of the code. After you have added this, raise the event using the `OnNext`
    keyword. This is the `IObserver` portion of the code. Therefore, as we loop through
    our list, we will call `OnNext` to pump out the values to the subscribed `IObservable`
    interface:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`DotNet`列表的代码之后，我们使用了`+=`来连接事件处理器。这次，我们将使用`Subscribe`。这是代码中的`IObservable`部分。在你添加了这部分之后，使用`OnNext`关键字引发事件。这是代码中的`IObserver`部分。因此，当我们遍历我们的列表时，我们将调用`OnNext`来将值泵送到已订阅的`IObservable`接口：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you have completed adding all the code, your application should look like
    this:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成所有代码的添加后，你的应用程序应该看起来像这样：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you run your application, you will see the same items output to the console
    window as earlier:![How to do it…](img/B05391_04_09.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你将在控制台窗口中看到与之前相同的项输出：![如何做…](img/B05391_04_09.jpg)
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: In Rx, we can declare an event stream with the `Subject` keyword. So, we have
    a source of events that we can publish to using `OnNext`. To see those values
    in the console window, we subscribed to the event stream using `Subscribe`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rx中，我们可以使用`Subject`关键字声明一个事件流。因此，我们有一个事件源，我们可以使用`OnNext`来发布。为了在控制台窗口中看到这些值，我们使用`Subscribe`订阅了事件流。
- en: 'Rx allows you to have objects that are just publishers or just subscribers.
    This is because the `IObservable` and `IObserver` interfaces are in fact separate.
    Also, note that in Rx, the observables can be passed as parameters, returned as
    results, and stored in variables, which makes them first class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rx允许你拥有仅是发布者或仅是订阅者的对象。这是因为`IObservable`和`IObserver`接口实际上是分开的。此外，请注意，在Rx中，可观察对象可以作为参数传递，作为结果返回，并存储在变量中，这使得它们成为一等公民：
- en: '![How it works…](img/B05391_04_10.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_04_10.jpg)'
- en: 'Rx also allows you to specify that the event stream is completed or that an
    error occurred. This really sets Rx apart from events in .NET. Also, it is important
    to note that including the `System.Reactive.Linq` namespace in your project allows
    developers to write queries over the `Subject` type because a `Subject` is an
    `IObservable` interface:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Rx还允许你指定事件流已完成或发生了错误。这真正将Rx与.NET中的事件区分开来。此外，重要的是要注意，在项目中包含`System.Reactive.Linq`命名空间允许开发者对`Subject`类型编写查询，因为`Subject`是一个`IObservable`接口：
- en: '![How it works…](img/B05391_04_11.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_04_11.jpg)'
- en: This is another feature that sets Rx apart from the events in .NET.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是Rx与.NET中的事件区别的一个特性。
- en: Using LINQ to perform queries
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ进行查询
- en: 'Rx allow developers to use the `IObservable` interface that represents synchronous
    data streams to write queries using LINQ. To recap, Rx can be thought of as consisting
    of three sections:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Rx允许开发者使用代表同步数据流的`IObservable`接口，通过LINQ编写查询。为了回顾，Rx可以被视为由三个部分组成：
- en: '**Observables**: The interface that brings together and represents all these
    data streams'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察对象**：将所有这些数据流汇集并代表的接口'
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple data streams'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）：使用LINQ查询这些多个数据流的能力'
- en: '**Schedulers**: Parametrizing concurrency using schedulers'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：使用调度器参数化并发'
- en: In this recipe, we will be looking at the LINQ functionality of Rx in more detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将更详细地查看Rx的LINQ功能。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As observables are just data streams, we can use LINQ to query them. In the
    following recipe, we will output text to the screen based on a LINQ query.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可观察者只是数据流，我们可以使用LINQ来查询它们。在下面的示例中，我们将根据LINQ查询将文本输出到屏幕。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Start by adding a new Windows Forms project to your solution:![How to do it…](img/B05391_04_12.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先向您的解决方案添加一个新的Windows Forms项目：![如何操作…](img/B05391_04_12.jpg)
- en: Call the project `winformRx` and click on the **OK** button:![How to do it…](img/B05391_04_13.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`winformRx`并点击**确定**按钮：![如何操作…](img/B05391_04_13.jpg)
- en: In **Toolbox**, search for the **TextBox** control and add it to your form:![How
    to do it…](img/B05391_04_14.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**中搜索**文本框**控件并将其添加到您的表单中：![如何操作…](img/B05391_04_14.jpg)
- en: Finally, add a label control to your form:![How to do it…](img/B05391_04_15.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将标签控件添加到您的表单中：![如何操作…](img/B05391_04_15.jpg)
- en: Right-click on your `winformRx` project and select **Manage NuGet Packages…**
    from the context menu:![How to do it…](img/B05391_04_16.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的`winformRx`项目，并从上下文菜单中选择**管理NuGet包…**：![如何操作…](img/B05391_04_16.jpg)
- en: In the search text box, enter `System.Reactive` to search for the NuGet package
    and click on the **Install** button:![How to do it…](img/B05391_04_17.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索文本框中输入`System.Reactive`以搜索NuGet包，然后点击**安装**按钮：![如何操作…](img/B05391_04_17.jpg)
- en: Visual Studio will ask you to review the changes it's about to make to your
    project. Click on the **OK** button:![How to do it…](img/B05391_04_18.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将要求您审查它即将对项目进行的更改。点击**确定**按钮：![如何操作…](img/B05391_04_18.jpg)
- en: 'Before the installation starts, you might need to accept the license agreement
    by clicking on the **I Accept** button:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装开始之前，您可能需要通过点击**我接受**按钮来接受许可协议：
- en: After the installation completes, you should see the newly added references
    to your `winformRx` project if you expand the **References** for the project:![How
    to do it…](img/B05391_04_20.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，如果您展开项目的**引用**，应该会看到新添加到您的`winformRx`项目中的引用：![如何操作…](img/B05391_04_20.jpg)
- en: Finally, right-click on the project and set `winformRx` as your startup project
    by clicking on **Set as StartUp Project** from the context menu:![How to do it…](img/B05391_04_21.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，右键单击项目，并通过从上下文菜单中选择**设置为启动项目**来将`winformRx`设置为您的启动项目：![如何操作…](img/B05391_04_21.jpg)
- en: Create the form load event handler for the form by double-clicking anywhere
    on the Windows Form. To this form, add the `Observable` keyword. You will notice
    that the keyword is immediately underlined. This is because you are missing the
    reference to the LINQ assembly of `System.Reactive`:![How to do it…](img/B05391_04_22.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Windows Form上任何位置双击来创建表单的加载事件处理程序。向此表单添加`Observable`关键字。您会注意到关键字立即被下划线标注。这是因为您缺少对`System.Reactive`的LINQ组件的引用：![如何操作…](img/B05391_04_22.jpg)
- en: To add this, press *Ctrl* + *.* (period) to bring up the possible suggestions
    to fix the issue. Select to add the `using System.Reactive.Linq` namespace to
    your project:![How to do it…](img/B05391_04_23.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加此内容，请按*Ctrl* + *.*（句号）以显示可能的建议以修复问题。选择将`using System.Reactive.Linq`命名空间添加到您的项目中：![如何操作…](img/B05391_04_23.jpg)
- en: 'Continue adding the following code to your form load event. Basically, you
    are using LINQ and telling the compiler that you want to select the text from
    the event pattern that matches the text changed event of the text box on the form
    called `textBox1`. After you have done that, add a subscription to the variable
    and tell it to output whatever it finds in the text to the label on the form called
    `label1`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续将以下代码添加到表单的加载事件中。基本上，您正在使用LINQ并告诉编译器您想要从名为`textBox1`的表单上的文本框的文本更改事件匹配的事件模式中选择文本。完成此操作后，向变量添加订阅并告诉它将找到的任何文本输出到名为`label1`的表单上的标签：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we added the text box and label to our form, we left the control names
    as default. If, however, you changed the default names, you would need to specify
    those names instead of `textBox1` and `label1` for the controls on the form.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们将文本框和标签添加到我们的表单中时，我们保留了控件名称的默认值。然而，如果您更改了默认名称，您将需要指定这些名称而不是表单上的控件`textBox1`和`label1`。
- en: Click on the run button to run your application. The Windows Form will be displayed
    with the text box and label on it:![How to do it…](img/B05391_04_24.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行按钮来运行您的应用程序。Windows Form将显示带有文本框和标签的表单：![如何操作…](img/B05391_04_24.jpg)
- en: Notice that the text is output to the label on the form as you type:![How to
    do it…](img/B05391_04_25.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，随着您输入文本，文本将输出到表单上的标签：![如何操作…](img/B05391_04_25.jpg)
- en: 'Let''s jazz things up a bit by adding a `Where` condition to the LINQ statement.
    We will specify that the `text` string must only select the text when it ends
    with a period. This means that the text will only be displayed in the label after
    each full sentence. As you can see, we aren''t doing anything special here. We
    are merely using standard LINQ to query our data stream and return the results
    to our `searchTerm` variable:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过向LINQ语句添加一个`Where`条件来让事情变得更有趣。我们将指定只有当`text`字符串以句号结尾时才选择文本。这意味着文本只有在每个完整的句子之后才会显示在标签中。正如你所看到的，我们在这里并没有做什么特别的事情。我们只是在使用标准的LINQ查询我们的数据流并将结果返回到`searchTerm`变量：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run your application and start typing in a line of text. You will see that nothing
    is output to the label control as you type, as was evident in the previous example
    before we added in our `Where` condition:![How to do it…](img/B05391_04_26.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序并开始输入一行文本。你会看到，当你输入时，标签控件没有输出任何内容，正如我们在添加我们的`Where`条件之前的上一个例子中所见：![如何做到这一点…](img/B05391_04_26.jpg)
- en: Add a period and start adding a second line of text:![How to do it…](img/B05391_04_27.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个句号，并开始添加第二行文本：![如何做到这一点…](img/B05391_04_27.jpg)
- en: You will see that only after each period, the text entered is added to the label.
    Our `Where` condition is, therefore, working perfectly:![How to do it…](img/B05391_04_28.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到，只有在每个周期之后，输入的文本才会添加到标签中。因此，我们的`Where`条件工作得非常完美：![如何做到这一点…](img/B05391_04_28.jpg)
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The LINQ aspect of Rx allows developers to construct observables. Here are
    some examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Rx的LINQ方面允许开发者构建观察序列。以下是一些示例：
- en: '`Observable.Empty<>`: Returns an empty observable sequence'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Empty<>`: 返回一个空的观察序列'
- en: '`Observable.Return<>`: Returns an observable sequence containing a single element'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Return<>`: 返回包含单个元素的观察序列'
- en: '`Observable.Throw<>`: Returns an observable sequence terminating with an exception'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Throw<>`: 返回以异常终止的观察序列'
- en: '`Observable.Never<>`: Returns a non-terminating observable sequence infinite
    in duration'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Never<>`: 返回一个非终止的观察序列，持续时间无限'
- en: The use of LINQ in Rx allows the developer to manipulate and filter the data
    stream to return exactly what they need.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ在Rx中的使用允许开发者操纵和过滤数据流，以返回他们所需的确切内容。
- en: Using schedulers in Rx
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rx中使用调度器
- en: Sometimes, we need to have an `IObservable` subscription run at a specific time.
    Imagine having to synchronize events across servers in geographically different
    areas and time zones. You might also need to read data from a queue while preserving
    the order in which the events occur. Another example would be to perform some
    kind of I/O task that could take some time to complete. Schedulers come in very
    handy in these situations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要在特定时间运行一个`IObservable`订阅。想象一下，需要在地理上不同区域和时区同步事件。你可能还需要在保持事件发生顺序的情况下从队列中读取数据。另一个例子是执行可能需要一些时间才能完成的某种I/O任务。在这些情况下，调度器非常有用。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Additionally, you can consider reading up more on using schedulers on MSDN.
    Have a look at [https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以考虑在MSDN上阅读更多关于使用调度器的信息。查看[https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx)。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If you haven't already done so, create a new Windows Form application and call
    it `winformRx`. Open the form designer and in **Toolbox**, search for the **TextBox**
    control and add it to your form:![How to do it…](img/B05391_04_14.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，创建一个新的Windows表单应用程序，并将其命名为`winformRx`。打开表单设计器，在**工具箱**中搜索**TextBox**控件并将其添加到你的表单中：![如何做到这一点…](img/B05391_04_14.jpg)
- en: Next, add a label control to your form:![How to do it…](img/B05391_04_15.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将一个标签控件添加到你的表单中：![如何做到这一点…](img/B05391_04_15.jpg)
- en: 'Double-click on your Windows Form designer to create the onload event handler.
    Inside this handler, add some code to read the text entered into the text box
    and only display that text 5 seconds after the user has stopped typing. This is
    achieved using the `Throttle` keyword. Add a subscription to the `searchTerm`
    variable, writing the result of the text input to the label control''s text property:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击Windows表单设计器以创建onload事件处理程序。在这个处理程序内部，添加一些代码来读取文本框中输入的文本，并在用户停止输入5秒后只显示该文本。这是通过使用`Throttle`关键字实现的。向`searchTerm`变量添加一个订阅，将文本输入的结果写入标签控件的文本属性：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you might need to add `System.Reactive.Linq` in your `using` statements.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可能需要在你的`using`语句中添加`System.Reactive.Linq`。
- en: Run your application and start typing in some text into the text box. Immediately,
    we will receive an exception. It is a cross-thread violation. This occurs when
    there is an attempt to update the UI from a background thread. The `Observable`
    interface is running a timer from `System.Threading`, which isn't on the same
    thread as the UI. Luckily, there is an easy way to overcome this. Well, it turns
    out that the UI-threading capabilities lie in a different assembly, which we found
    easiest to get via the **Package Manager Console**:![How to do it…](img/B05391_04_29.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序并在文本框中输入一些文本。立即，我们会收到一个异常。这是一个跨线程违规。这发生在尝试从后台线程更新UI时。`Observable`接口正在从`System.Threading`运行计时器，它不在UI的同一线程上。幸运的是，有一个简单的方法可以克服这个问题。嗯，结果证明UI线程功能位于不同的程序集，我们发现通过**包管理器控制台**获取它最简单：![如何操作…](img/B05391_04_29.jpg)
- en: Click on **View** | **Other Windows** | **Package Manager Console** to access
    the **Package Manager Console**:![How to do it…](img/B05391_04_16.jpg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**查看** | **其他窗口** | **包管理器控制台**以访问**包管理器控制台**：![如何操作…](img/B05391_04_16.jpg)
- en: 'Enter the following command: `PM> Install-Package System.Reactive.Windows.Forms`![How
    to do it…](img/B05391_04_30.jpg)'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：`PM> Install-Package System.Reactive.Windows.Forms`![如何操作…](img/B05391_04_30.jpg)
- en: Note
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that you need to ensure that the **Default project** selection is
    set to `winformRx` in the **Package Manager Console**. If you don't see this option,
    resize the **Package Manager Console** screen width until the option is displayed.
    This way you can be certain that the package is added to the correct project.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，你需要确保在**包管理器控制台**中**默认项目**选择设置为`winformRx`。如果你看不到这个选项，调整**包管理器控制台**屏幕宽度直到选项显示。这样你可以确定包被添加到正确的项目中。
- en: 'After the installation completes, modify your code in the onload event handler
    and change `searchTerm.Subscribe(trm => label1.Text = trm);`, which does the subscription,
    to look like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，修改你的代码在`onload`事件处理器中，并将`searchTerm.Subscribe(trm => label1.Text = trm);`，执行订阅，改为如下所示：
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will notice that we are using the `ObserveOn` method here. What this basically
    tells the compiler is that the `this` keyword in `new ControlScheduler(this)`
    is actually a reference to our Windows Form. Therefore, `ControlScheduler` will
    use the Windows Forms timers to create the interval to update our UI. The message
    happens on the correct thread, and we no longer have our cross-thread violation.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我们在这里使用的是`ObserveOn`方法。这基本上告诉编译器，`new ControlScheduler(this)`中的`this`关键字实际上是对我们的Windows窗体的引用。因此，`ControlScheduler`将使用Windows
    Forms计时器来创建更新我们的UI的间隔。消息发生在正确的线程上，我们不再有跨线程违规。
- en: If you have not added the `System.Reactive.Concurrency` namespace to your project,
    Visual Studio will underline the `ControlScheduler` line of code with a squiggly
    line. Pressing *Ctrl* + *.* (the Control key and dot) will allow you to add the
    missing namespace:![How to do it…](img/B05391_04_33.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有将`System.Reactive.Concurrency`命名空间添加到你的项目中，Visual Studio将会用波浪线下划线标记`ControlScheduler`代码行。按下*Ctrl*
    + *.*（控制键和点）将允许你添加缺少的命名空间：![如何操作…](img/B05391_04_33.jpg)
- en: This means that `System.Reactive.Concurrency` contains a scheduler that can
    talk to Windows Forms controls so that it can do the scheduling. Run your application
    again and start typing some text into your text box:![How to do it…](img/B05391_04_34.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着`System.Reactive.Concurrency`包含一个可以与Windows Forms控件通信的调度器，以便它可以进行调度。再次运行您的应用程序并在文本框中输入一些文本：![如何操作…](img/B05391_04_34.jpg)
- en: Five seconds after we stop typing, the throttle condition is fulfilled, and
    the text is output to our label:![How to do it…](img/B05391_04_35.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止输入五秒后，节流条件得到满足，文本输出到我们的标签：![如何操作…](img/B05391_04_35.jpg)
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What we need to keep in mind here from the code we created is that there are
    `ObserveOn` and `Subscribe`. You should not confuse the two. In most cases, when
    dealing with schedulers, you will use `ObserveOn`. The `ObserveOn` method allows
    you to parametrize where the `OnNext`, `OnCompleted`, and `OnError` messages run.
    With `Subscribe`, we parameterize where the actual subscribe and unsubscribe code
    runs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的是，从我们创建的代码中，有`ObserveOn`和`Subscribe`。你不应该混淆这两个。在大多数情况下，处理调度器时，你会使用`ObserveOn`。`ObserveOn`方法允许你参数化`OnNext`、`OnCompleted`和`OnError`消息的运行位置。使用`Subscribe`，我们参数化实际订阅和取消订阅代码的运行位置。
- en: 'We also need to remember that Rx use the threading timers (`System.Threading.Timer`)
    as a default, which is why we encountered the cross-thread violation earlier.
    As you saw though, we used schedulers to parameterize what timer to use. The way
    schedulers do this is by exposing three components. These are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住，Rx 使用线程计时器 (`System.Threading.Timer`) 作为默认设置，这就是为什么我们之前遇到了跨线程违规。然而，正如你所看到的，我们使用了调度器来参数化使用哪个计时器。调度器这样做是通过暴露三个组件来实现的。这些是：
- en: The scheduler's ability to perform some action
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器执行某些操作的能力
- en: The order in which the action or work to be performed is executed
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行要执行的操作或工作的顺序
- en: A clock that allows the scheduler to have a notion of time
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许调度器有时间概念的时钟
- en: The use of a clock is important because it allows the developer to use timers
    on remote machines, for example (where there might be a time difference between
    you and them), to tell them to perform an action at a particular time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时钟的重要性在于它允许开发者使用远程机器上的计时器，例如（在你和他们之间可能存在时间差异的情况下），告诉它们在特定时间执行操作。
- en: Debugging lambda expressions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Lambda 表达式
- en: Visual Studio 2015 has added the ability for developers to debug lambda expressions.
    This is a fantastic addition to the features of our favorite IDE. It allows us
    to check the results of a lambda expression on the fly and modify the expression
    to test different scenarios.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 为开发者添加了调试 lambda 表达式的功能。这是我们最喜欢的 IDE 功能的绝佳补充。它允许我们即时检查 lambda
    表达式的结果，并修改表达式以测试不同的场景。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a very basic lambda expression and change it in the **Watch**
    window to produce a different value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常基础的 lambda 表达式，并在**监视**窗口中更改它以产生不同的值。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Add a class called `CSharpSix`. Add a property to this class called `FavoriteFeature`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `CSharpSix` 的类。向这个类添加一个名为 `FavoriteFeature` 的属性：
- en: '[PRE12]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create a `List<CSharpSix>` object and add a few of your favorite C# 6
    features to this list:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `List<CSharpSix>` 对象，并将一些你最喜欢的 C# 6 特性添加到这个列表中：
- en: '[PRE13]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, create an expression to return only the features starting with the `"Ex"`
    string. Here, we would obviously expect to see exception filters as a result:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个只返回以 `"Ex"` 字符串开头的特性的表达式。在这里，我们显然期望看到异常过滤器作为结果：
- en: '[PRE14]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Place a breakpoint on the expression and run your application. When the code
    stops at the breakpoint, you can copy the lambda expression:![How to do it…](img/B05391_04_36.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表达式中放置断点并运行你的应用程序。当代码在断点处停止时，你可以复制 lambda 表达式：![如何操作…](img/B05391_04_36.jpg)
- en: Paste the lambda expression into your **Watch** windows and change the string
    in the `StartsWith` method. You will see that the result has changed to the `"Nameof
    Expressions"` string:![How to do it…](img/B05391_04_37.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 lambda 表达式粘贴到你的**监视**窗口中，并更改 `StartsWith` 方法中的字符串。你会发现结果已经更改为 `"Nameof Expressions"`
    字符串：![如何操作…](img/B05391_04_37.jpg)
- en: How it works…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Being able to debug lambda expressions allows us to change and debug a lambda
    expression easily. This is something that was not possible in previous versions
    of Visual Studio. It is obviously of great importance to know this tip when working
    with these expressions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 能够调试 lambda 表达式使我们能够轻松地更改和调试 lambda 表达式。这是在 Visual Studio 的早期版本中不可能做到的事情。当与这些表达式一起工作时，了解这个技巧显然非常重要。
- en: Another point to note is that you can do the same thing from the **Immediate**
    window in Visual Studio 2015, as well as pinned variables from the lambda expression.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的点是，你可以在 Visual Studio 2015 的**立即**窗口中做同样的事情，也可以从 lambda 表达式中的固定变量中做。
