- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection in a Minimal API Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter of the book, we will discuss some basic topics of minimal APIs
    in .NET 6.0\. We will learn how they differ from the controller-based Web APIs
    that we were used to using in the previous version of .NET. We will also try to
    underline the pros and the cons of this new approach of writing APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing dependency injection in a minimal API project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the explanations in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. You can refer the Technical requirements section
    of [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023)*, Exploring Minimal APIs and
    Their Advantages* to know how to do it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter04](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a while, .NET has natively supported the **dependency injection** (often
    referred to as **DI**) software design pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is a way to implement in .NET the **Inversion of Control**
    (**IoC**) pattern between service classes and their dependencies. By the way,
    in .NET, many fundamental services are built with dependency injection, such as
    logging, configuration, and other services.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a practical example to get a good understanding of how it works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, a dependency is an object that depends on another object.
    In the following example, we have a `LogWriter` class with only one method inside,
    called `Log`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Other classes in the project, or in another project, can create an instance
    of the `LogWriter` class and use the `Log` method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This class depends directly on the `LogWriter` class, and it’s hardcoded in
    each class of your projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: This means that you will have some issues if you want to change the `Log` method;
    for instance, you will have to replace the implementation in each class of your
    solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation has some issues if you want to implement unit tests
    in your solution. It’s not easy to create a mock of the `LogWriter` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency injection can solve these problems with some changes in our code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Use an interface to abstract the dependency.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the dependency injection in the built-in service connecte to .NET.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the service into the constructor of the class.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding things might seem like they require big change in your code, but
    they are very easy to implement.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can achieve this goal with our previous example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create an `ILogWriter` interface with the abstraction of our
    logger:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, implement this `ILogWriter` interface in a real class called `ConsoleLogWriter`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, change the `Worker` class and replace the explicit `LogWriter` class with
    the new `ILogWriter` interface:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改`Worker`类，将显式的`LogWriter`类替换为新的`ILogWriter`接口：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, it’s very easy to work in this new way, and the advantages
    are substantial. Here are a few advantages of dependency injection:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，以这种方式工作非常简单，优势很大。以下是依赖注入的一些优点：
- en: Maintainability
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Testability
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Reusability
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Now we need to perform the last step, that is, register the dependency when
    the application starts up.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要执行最后一步，即在应用程序启动时注册依赖项。
- en: 'At the top of the `Program.cs` file, add this line of code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的顶部添加以下代码行：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next section, we will discuss the difference between dependency injection
    lifetimes, another concept that you need to understand before using dependency
    injection in your minimal API project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论依赖注入生命周期之间的差异，这是在使用最小API项目进行依赖注入之前你需要理解的概念。
- en: Understanding dependency injection lifetimes
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解依赖注入的生命周期
- en: In the previous section, we learned the benefits of using dependency injection
    in our project and how to transform our code to use it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了在项目中使用依赖注入的好处以及如何将我们的代码转换为使用它。
- en: In one of the last paragraphs, we added our class as a service to `ServiceCollection`
    of .NET.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段中，我们将我们的类作为服务添加到.NET的`ServiceCollection`中。
- en: In this section, we will try to understand the difference between each dependency
    injection’s lifetime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试理解每种依赖注入的生命周期差异。
- en: The service lifetime defines how long an object will be alive after it has been
    created by the container.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务生命周期定义了对象在容器创建之后将存活多长时间。
- en: When they are registered, dependencies require a lifetime definition. This defines
    the conditions when a new service instance is created.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们被注册时，依赖项需要生命周期定义。这定义了何时创建新的服务实例。
- en: 'In the following list, you can find the lifetimes defined in .NET:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，你可以找到.NET中定义的生命周期：
- en: '**Transient**: A new instance of the class is created every time it is requested.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**：每次请求时都会创建该类的新实例。'
- en: '**Scoped**: A new instance of the class is created once per scope, for instance,
    for the same HTTP request.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**：每个作用域创建该类的一个新实例，例如，对于同一个HTTP请求。'
- en: '**Singleton**: A new instance of the class is created only on the first request.
    The next request will use the same instance of the same class.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：仅在第一次请求时创建该类的新实例。下一次请求将使用相同类的相同实例。'
- en: Very often, in web applications, you only find the first two lifetimes, that
    is, transient and scoped.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，你通常只找到前两种生命周期，即瞬态和作用域。
- en: If you have a particular use case that requires a singleton, it’s not prohibited,
    but for best practice, it is recommended to avoid them in web applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要单例的特殊用例，这并不被禁止，但为了最佳实践，建议在Web应用程序中避免使用它们。
- en: In the first two cases, transient and scoped, the services are disposed of at
    the end of the request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两种情况下，即瞬态和作用域内，服务在请求结束时被销毁。
- en: In the next section, we will see how to implement all the concepts that we have
    mentioned in the last two sections (the definition of dependency injection and
    its lifetime) in a short demo that you can use as a starting point for your next
    project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何通过一个简短的演示来实现我们在上一节中提到的所有概念（依赖注入的定义及其生命周期），你可以将其作为你下一个项目的起点。
- en: Implementing dependency injection in a minimal API project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在最小API项目中实现依赖注入
- en: After understanding how to use dependency injection in an ASP.NET Core project,
    let’s try to understand how to use dependency injection in our minimal API project,
    starting with the default project using the `WeatherForecast` endpoint.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何在ASP.NET Core项目中使用依赖注入之后，让我们尝试理解如何在我们的最小API项目中使用依赖注入，从使用`WeatherForecast`端点的默认项目开始。
- en: 'This is the actual code of the `WeatherForecast` GET endpoint:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WeatherForecast` GET端点的实际代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we mentioned before, this code works but it’s not easy to test it, especially
    the creation of the new values of the weather.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这段代码可以工作，但它不容易测试，尤其是天气的新值的创建。
- en: The best choice is to use a service to create fake values and use it with dependency
    injection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳选择是使用一个服务来创建假值，并使用依赖注入来使用它。
- en: 'Let’s see how we can better implement our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何更好地实现我们的代码：
- en: 'First of all, in the `Program.cs` file, add a new interface called `IWeatherForecastService`
    and define a method that returns an array of the `WeatherForecast` entity:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Program.cs`文件中，添加一个名为`IWeatherForecastService`的新接口，并定义一个返回`WeatherForecast`实体数组的函数：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next step is to create the real implementation of the class inherited from
    the interface.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建从接口继承的类的实际实现。
- en: 'The code should look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该看起来像这样：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now cut and paste the code from the project template inside our new implementation
    of the service. The final code looks like this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将项目模板中的代码复制粘贴到我们新实现的服务中。最终的代码如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are now ready to add our implementation of `WeatherForecastService` as a
    dependency injection in our project. To do that, insert the following line below
    the first line of code in the `Program.cs` file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将`WeatherForecastService`的实现添加到我们的项目中作为依赖注入。为此，在`Program.cs`文件的第一行代码下方插入以下行：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the application starts, insert our service into the services collection.
    Our work is not finished yet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，将我们的服务插入到服务集合中。我们的工作还没有完成。
- en: We need to use our service in the default `MapGet` implementation of the `WeatherForecast`
    endpoint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`WeatherForecast`端点的默认`MapGet`实现中使用我们的服务。
- en: The minimal API has his own parameter binding implementation and it’s very easy
    to use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API有自己的参数绑定实现，并且非常容易使用。
- en: First of all, to implement our service with dependency injection, we need to
    remove all the old code from the endpoint.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使用依赖注入实现我们的服务，我们需要从端点中移除所有旧代码。
- en: 'The code of the endpoint, after removing the code, looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除代码后，端点的代码看起来像这样：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can improve our code and use the dependency injection very easily by simply
    replacing the old code with the new code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地用新代码替换旧代码来轻松改进我们的代码并使用依赖注入：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the minimal API project, the real implementations of the services in the
    service collection are passed as parameters to the functions and you can use them
    directly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小API项目中，服务集合中服务的实际实现被作为参数传递给函数，并且可以直接使用它们。
- en: 'From time to time, you may have to use a service from the dependency injection
    directly in the main function during the startup phase. In this case, you must
    retrieve the instance of the implementation directly from the services collection,
    as shown in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在启动阶段，你可能需要在主函数中直接使用依赖注入中的服务。在这种情况下，你必须直接从服务集合中检索实现实例，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, we have implemented dependency injection in a minimal API project,
    starting from the default template.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们从默认模板开始，在最小API项目中实现了依赖注入。
- en: We reused the existing code but implemented it with logic that’s more geared
    toward an architecture that’s better suited to being maintained and tested in
    the future.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了现有的代码，但用更符合未来维护和测试的架构逻辑来实现它。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Dependency injection is a very important approach to implement in modern applications.
    In this chapter, we learned what dependency injection is and discussed its fundamentals.
    Then, we saw how to use dependency injection in a minimal API project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是实现现代应用的重要方法之一。在本章中，我们学习了依赖注入是什么，并讨论了其基本原理。然后，我们看到了如何在最小API项目中使用依赖注入。
- en: In the next chapter, we will focus on another important layer of modern applications
    and discuss how to implement a logging strategy in a minimal API project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注现代应用的另一个重要层，并讨论如何在最小API项目中实现日志策略。
