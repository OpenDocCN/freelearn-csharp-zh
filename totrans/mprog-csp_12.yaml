- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Go Beyond Inheritance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越继承
- en: With object-oriented languages such as C#, we can derive our types from other
    types and we can also implement contracts (interfaces) and make them fulfill that
    contract. Implementing interfaces and making an implementation fulfill these is
    really one of the great things about a type-safe language. With the compiler,
    we get everything checked to make sure we implement the contract, while at runtime,
    we can leverage the interface type to be a representation rather than having to
    know the actual implementor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在像C#这样的面向对象语言中，我们可以从其他类型派生我们的类型，我们还可以实现契约（接口）并使它们满足该契约。实现接口并使实现满足这些契约是类型安全语言的一大优点。有了编译器，我们可以确保我们实现了契约，而在运行时，我们可以利用接口类型作为表示，而不是必须知道实际的实现者。
- en: Sometimes, however, the verbosity of having to implement an interface can be
    too much. It can also be limited to what you’re trying to achieve.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时实现接口的冗长性可能过多。它也可能仅限于你试图实现的目标。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Method signature conventions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名约定
- en: By the end of the chapter, you will have an idea of how conventions can let
    you go beyond having to inherit from a base type or an interface and how that
    sometimes caters to a cleaner code base.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解约定如何让你超越必须从基类型或接口继承的需求，以及有时这如何有助于更干净的代码库。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12))
    and it builds on top of the **Fundamentals** code that is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12)），并且它建立在[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)中找到的**基础**代码之上。
- en: Method signature conventions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法签名约定
- en: Coming up with good examples to do a home run on a topic for a book can be very
    hard. For this chapter, I’ve decided to go with something that is part of my day-to-day
    job.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个好的例子来为一本书的主题做一次完美的展示可能非常困难。对于本章，我决定选择我日常工作的一部分内容。
- en: I work with a platform that is centered around event-driven architecture, or
    more specifically, with event sourcing. This topic might be unfamiliar to you,
    so let’s dive into what this specifically is, to give you the context.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我与一个以事件驱动架构为中心的平台合作，更具体地说，是与事件溯源。这个主题可能对你来说很陌生，所以让我们深入了解这个具体是什么，以便为你提供背景。
- en: In traditional **CRUD** (short for **Create, Read, Update, Delete**) systems,
    the primary focus is on the concrete data that is commonly stored in a relational
    or document database. These systems revolve around the four fundamental operations
    – creating new records, retrieving existing records, updating records, and deleting
    records.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的**CRUD**（代表**创建、读取、更新、删除**）系统中，主要关注的是通常存储在关系型或文档数据库中的具体数据。这些系统围绕着四个基本操作——创建新记录、检索现有记录、更新记录和删除记录。
- en: The data in such systems represents the outcome of a user’s actions, and the
    system’s flow typically follows a one-to-one mapping from the user’s input form
    to the database. However, this approach to software development has a significant
    drawback – it only captures the effect and not the cause.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统中的数据代表用户操作的结果，系统的流程通常遵循从用户输入表单到数据库的一对一映射。然而，这种软件开发方法有一个显著的缺点——它只捕捉效果，而不是原因。
- en: 'With event sourcing, the effect is less important, and it’s all about capturing
    what caused the effect. The cause captures how we got to the conclusion, as shown
    in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件溯源中，效果并不那么重要，关键是捕捉导致效果的原因。原因捕捉了我们如何得出结论，如下面的图所示：
- en: '![](img/B19418_12_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_12_01.jpg)'
- en: Figure 12.1 – Capturing the cause
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 捕获原因
- en: The cause is what is known as an event – something that happened in the system.
    We capture these by giving them a clear name, and we store them in the sequence
    in which they occur. The events are never deleted. All events are stored in what
    is referred to as an **event store**. There are technologies out there that specialize
    in this, such as the platform I’m working on, called Cratis ([https://cratis.io](https://cratis.io)),
    but you could also use any database and do this yourself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 原因被称为事件——系统中发生的事情。我们通过给它们一个清晰的名字来捕捉这些事件，并将它们按发生的顺序存储。事件永远不会被删除。所有事件都存储在被称为**事件存储**的地方。有一些技术专门从事这项工作，例如我正在工作的平台，称为Cratis
    ([https://cratis.io](https://cratis.io))，但您也可以使用任何数据库并自行完成这项工作。
- en: By prioritizing the capturing of events, we gain the ability to control how
    the effects are presented. This is achieved by extracting relevant information
    from various event types as they occur and then converting it into specialized
    objects for easy access. These objects are typically stored in conventional data
    stores such as relational or document databases, which allow for the efficient
    querying of the end result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优先捕获事件，我们获得了控制效果呈现方式的能力。这是通过在事件发生时从各种事件类型中提取相关信息，然后将其转换为易于访问的专用对象来实现的。这些对象通常存储在传统的数据存储中，如关系型或文档数据库，这允许高效地查询最终结果。
- en: One major advantage of this approach is that the event store becomes the source
    of truth in the system rather than relying solely on traditional data stores.
    This means that modifying how data is represented becomes significantly easier,
    as you can simply replay the relevant events when implementing changes. You can
    also decide to have multiple representations, catering to special needs within
    a system. This could then have a huge performance benefit, as well as clarity
    in code, and avoiding tension often seen in developing systems where one shares
    the same data and objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个主要优势是，事件存储成为系统中的真相来源，而不是仅仅依赖于传统的数据存储。这意味着修改数据表示方式变得显著更容易，因为您只需在实施更改时简单地重放相关事件。您还可以决定拥有多个表示形式，以满足系统内的特殊需求。这可能会带来巨大的性能优势，以及代码的清晰度，并避免在开发系统中常见的一种紧张关系，即共享相同的数据和对象。
- en: The following figure shows an imaginary bank system with events being produced
    and how they are projected down to materialized objects, referred to as read models.
    It also shows the relationship with other systems or other microservices in a
    microservice-centric architecture by projecting to events that can be communicated
    outside of the bounds of the system-producing events.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了一个假想的银行系统，其中产生了事件以及它们如何投影到被称为读取模型的实体对象中。它还显示了在微服务为中心的架构中，通过投影到可以超出系统边界进行通信的事件，与其他系统或微服务的关系。
- en: '![](img/B19418_12_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_12_02.jpg)'
- en: Figure 12.2 – Imaginary bank system with events produced
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 产生事件的假想银行系统
- en: The observer is a key element of this architecture. They are the ones responsible
    for observing the events as they occur and creating an effect. For the most part,
    the effect comes in the form of a projection to a read model that is stored, but
    it could also perform other tasks such as sending emails or, in fact, append new
    events as the consequence of an analysis the observer performs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者是这种架构的关键元素。他们是负责观察事件发生并产生效果的那些人。大部分情况下，效果以投影到存储的读取模型的形式出现，但它们也可能执行其他任务，例如发送电子邮件，或者实际上，作为观察者执行分析的结果，追加新事件。
- en: 'It’s these observers that we want to bring forward as an example in this chapter.
    Let’s narrow it down to a pipeline that looks like the following figure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在本章中将这些观察者作为例子提出来。让我们将其缩小到以下图所示的管道：
- en: '![](img/B19418_12_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_12_03.jpg)'
- en: Figure 12.3 – Logical pipeline
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 逻辑管道
- en: A command represents something the user desires, an action to be performed.
    The action typically would then decide what event, or possibly multiple events,
    it should generate. This is appended to the main event log within the event store.
    The event log is the event sequence that holds all the events in the order they
    occurred, with an incremental sequence number.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令代表用户希望执行的操作。该操作通常会决定应该生成什么事件，或者可能是多个事件。这些事件随后被附加到事件存储中的主事件日志中。事件日志是按发生顺序持有所有事件的序列，并带有递增的序列号。
- en: Once the event is in the event log, we want to notify all the interested observers
    that the event has been appended and they should react.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件进入事件日志，我们希望通知所有感兴趣的观察者事件已被附加，并且他们应该做出反应。
- en: The following figure shows more concretely what we want to accomplish and will
    be the basis of the example in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下图更具体地展示了我们想要实现的内容，并将成为本章示例的基础。
- en: '![](img/B19418_12_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![img/B19418_12_04.jpg]'
- en: Figure 12.4 – Concrete pipeline
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 具体管道
- en: In order to be able to do this, you’re going to need some infrastructure that
    will give you the conventions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够做到这一点，你需要一些基础设施来提供这些约定。
- en: Infrastructure
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施
- en: Let’s create a bare foundation of what’s needed for having observers that can
    respond to events being appended.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基础结构，以便拥有能够响应附加事件的观察者。
- en: 'Let’s create a folder called **Chapter12** at the root of your repository.
    Change into this folder in your command-line interface and create a new console
    project:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在你的仓库根目录下创建一个名为**Chapter12**的文件夹。在命令行界面中切换到这个文件夹，并创建一个新的控制台项目：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You’re going to make use of the Microsoft hosting model to get the .NET default
    service provider without spinning up a web application. To achieve this, you’ll
    need the package called **Microsoft.Extensions.Hosting**. In the terminal, you’d
    add the reference by doing the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你将利用微软托管模型来获取.NET默认服务提供者，而无需启动一个Web应用程序。为了实现这一点，你需要一个名为**Microsoft.Extensions.Hosting**的包。在终端中，你可以通过以下方式添加引用：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next thing you’ll need to do is to reference the **Fundamentals** project.
    In the terminal, do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你需要做的是引用**Fundamentals**项目。在终端中，执行以下操作：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As I discussed in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning
    about Types Using Reflection*, one of the things I do in all my code is to formalize
    types rather than use primitives. This makes the APIs much clearer and also helps
    avoid mistakes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[*第4章*](B19418_04.xhtml#_idTextAnchor059)中讨论的，*使用反射进行类型推理*，我在所有代码中做的一件事是正式化类型而不是使用原始类型。这使得API更加清晰，并有助于避免错误。
- en: You’re going to be using **ConceptAs<>** to formalize the types.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用**ConceptAs<>**来正式化类型。
- en: Inside the **Chapter12** folder, create a folder dedicated to the **EventSourcing**
    infrastructure, and call this folder **EventSourcing**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter12**文件夹内，创建一个专门用于**EventSourcing**基础设施的文件夹，并将其命名为**EventSourcing**。
- en: 'Within the **EventSourcing** folder, create a file called **EventSourceId.cs**
    and make it look like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹内，创建一个名为**EventSourceId.cs**的文件，并使其看起来如下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **EventSourceId** concept represents the unique identifier of the source
    of events. In domain modeling, this is typically the identifier of an object,
    a noun, in your domain. An example of this could be the unique identifier of a
    bank account or the unique identifier of a person in the system. The **EventSourceId**
    code sets up **ConceptAs<>** for this and makes the inner value a string, enabling
    basically any representation of a unique identifier. It adds a convenient method
    for creating a new **EventSourceId** by leveraging **Guid**, which can then generate
    a unique identifier on the fly. You’ll be using **EventSourceId** later and it
    should become clearer why it’s needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**EventSourceId**概念表示事件源的唯一标识符。在领域建模中，这通常是领域内一个对象、名词的标识符。这个例子可以是银行账户的唯一标识符或系统中个人的唯一标识符。**EventSourceId**代码为**ConceptAs<>**设置，并将内部值设为字符串，基本上允许任何唯一标识符的表示。它添加了一个方便的方法来创建新的**EventSourceId**，通过利用**Guid**，这可以即时生成一个唯一标识符。你将在后面使用**EventSourceId**，它将变得更为清晰为什么需要它。'
- en: When appending an event to a sequence of events, as we discussed earlier, every
    event gets a sequence number. This is an incremental number that increases by
    1 for every event added. Let’s formalize a type that represents this number.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当将事件附加到一系列事件中，正如我们之前讨论的，每个事件都会得到一个序列号。这是一个增量数字，每次添加事件时增加1。让我们正式化一个表示这个数字的类型。
- en: 'Within the **EventSourcing** folder, create a file called **EventSequenceNumber.cs**
    and make it look like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹内，创建一个名为**EventSequenceNumber.cs**的文件，并使其看起来如下：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code introduces a concrete type for **EventSequenceNumber** that is **ConceptAs<>**
    with its inner value of the **ulong** type. With **ulong**, you get a full 64-bit
    value and this should most likely be more than sufficient as an incremental sequence
    number. For convenience, there is also an implicit operator that can convert **ulong**
    to the encapsulated **EventSequenceNumber** type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个具体的**EventSequenceNumber**类型，它是**ConceptAs<>**，其内部值为**ulong**类型。使用**ulong**，您可以得到完整的64位值，这应该足以作为增量序列号。为了方便，还有一个隐式运算符可以将**ulong**转换为封装的**EventSequenceNumber**类型。
- en: For the observers that you’ll be adding later, you’ll be marking them with an
    attribute to indicate they are an observer. An alternative to this would be to
    use an empty interface. The point of this is just to be able to mark a type, making
    it possible to discover.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您稍后要添加的观察者，您将使用一个属性来标记它们是观察者。这种方法的替代方案是使用一个空接口。这样做的目的是仅仅能够标记一个类型，使其可以被发现。
- en: 'Within the **EventSourcing** folder, create a file called **ObserverAttribute.cs**
    and make it look like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹中，创建一个名为**ObserverAttribute.cs**的文件，并使其看起来如下：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code introduces an attribute that can be added to classes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个可以添加到类中的属性。
- en: For the observer methods, you typically find the information related to the
    event in addition to the actual event itself. The type of information you want
    to know is the **EventSourceId**, **EventSequenceNumber**, and when the event
    occurred. We call this **EventContext**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于观察者方法，您通常除了实际事件本身外，还会找到与事件相关的信息。您想了解的信息类型是**EventSourceId**、**EventSequenceNumber**以及事件发生的时间。我们称之为**EventContext**。
- en: 'Within the **EventSourcing** folder, create a file called **EventContext.cs**
    and make it look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹中，创建一个名为**EventContext.cs**的文件，并使其看起来如下：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code holds **EventSourceId**, **SequenceNumber**, and **Occurred** in the
    form of **DateTimeOffset**. In a full event-sourced system, we would typically
    hold more details, but this will suffice for this example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以**DateTimeOffset**的形式持有**EventSourceId**、**SequenceNumber**和**Occurred**。在一个完整的事件源系统中，我们通常会保留更多细节，但这对这个例子就足够了。
- en: For the events to be discoverable and classified as events, you’re going to
    need a building block in the infrastructure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事件可发现并被分类为事件，您将需要在基础设施中有一个构建块。
- en: 'Within the **EventSourcing** folder, create a file called **IEvent.cs** and
    make it look like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹中，创建一个名为**IEvent.cs**的文件，并使其看起来如下：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now comes the juicy part: the code that will discover methods on a type that
    matches certain criteria.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是精彩的部分：将发现符合某些标准的类型的代码。
- en: The convention we’re looking for is one that allows for two base method signatures
    and two variants of these, supporting both synchronous and asynchronous models.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找的约定是允许两种基本方法签名及其两种变体，支持同步和异步模型。
- en: 'The synchronous signatures are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同步签名如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then the asynchronous signatures are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后异步签名如下：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the convention does not care about the name of the method but
    only the parameters and return types. This gives flexibility to the developer
    in creating more precise named methods and increases the readability and maintainability
    of the code, something regular inheritance wouldn’t allow for.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该约定不关心方法名称，而只关心参数和返回类型。这为开发者提供了创建更精确命名的方法的灵活性，并增加了代码的可读性和可维护性，这是常规继承所不允许的。
- en: Let’s create a system that enables calling the methods by convention.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个系统，使得可以通过约定调用方法。
- en: 'Within the **EventSourcing** folder, create a file called **ObserverHandler.cs**
    and make it look like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹中，创建一个名为**ObserverHandler.cs**的文件，并使其看起来如下：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code sets up the basis for the **ObserverHandler** class. The constructor
    takes two parameters, **serviceProvider** and **targetType**. The **serviceProvider**
    parameter will be used to get instances of **targetType** representing the observer
    when an event needs to be handled. Within the constructor, the code uses reflection
    to look for instance methods, both public and non-public methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码为**ObserverHandler**类设置了基础。构造函数接受两个参数，**serviceProvider**和**targetType**。当需要处理事件时，**serviceProvider**参数将用于获取表示观察者的**targetType**的实例。在构造函数中，代码使用反射来查找实例方法，包括公共和非公共方法。
- en: It then filters down the methods by those matching the signature with a method
    called **IsObservingMethod()**, which you’ll be adding next. Then it groups it
    by the first parameter on the method, which is the event type, and creates a dictionary
    enabling fast lookup.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过一个名为**IsObservingMethod()**的方法过滤出与签名匹配的方法，你将在下一个步骤中添加它。然后，它根据方法的第一参数（即事件类型）进行分组，并创建一个字典以实现快速查找。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice the **EventTypes** property that is added; this exposes what event types
    the handler supports, and this will come in handy later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意添加的**EventTypes**属性；这暴露了处理程序支持的事件类型，这将在以后很有用。
- en: 'In the LINQ query, it uses the **IsObservingMethod()** method, which is a method
    that should be inside the **ObserverHandler** class. Add the following private
    method at the bottom of the **ObserverHandler** class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQ查询中，它使用**IsObservingMethod()**方法，这是一个应该位于**ObserverHandler**类内部的方法。在**ObserverHandler**类的底部添加以下私有方法：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To identify allowed signatures, the code examines **MethodInfo** and begins
    by recognizing the permitted return types, which are **Task** or **void**. If
    the return type is anything other than a valid observing method, it will be considered
    invalid. The code then proceeds to examine the parameters of the method. If the
    method has one parameter and its type implements the **IEvent** interface, it
    qualifies as an observing method. Alternatively, if the method has two parameters
    and the first parameter type implements **IEvent**, and the second parameter type
    is **EventContext**, then it is also classified as an observing method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别允许的签名，代码会检查**MethodInfo**，并首先识别允许的返回类型，这些类型是**Task**或**void**。如果返回类型不是有效的观察方法，它将被视为无效。然后代码继续检查方法的参数。如果一个方法有一个参数，并且其类型实现了**IEvent**接口，它就符合观察方法的资格。或者，如果一个方法有两个参数，第一个参数类型实现了**IEvent**，第二个参数类型是**EventContext**，那么它也被归类为观察方法。
- en: With the discovery part in place, all you need is a method that understands
    the convention and can invoke the method on the observer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现部分就绪后，你所需要的只是一个理解约定并能调用观察者方法的方法。
- en: 'In the **ObserverHandler** class, add the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ObserverHandler**类中，添加以下代码：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The **OnNext()** method is responsible for doing the call to the observer; it
    does so by taking an event of any type implementing the **IEvent** interface and
    **EventContext** for the event. From this, it finds the method in **_methodsByEventType**
    populated in the constructor based on the type of event supported by the observer.
    If it is supported, it goes on to get an instance of the observer type by using
    the service provider. For each method, it invokes based on the correct signature
    for the method and if the method is asynchronous, it will await **Task** returned.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**OnNext()**方法负责对观察者进行调用；它通过接受任何类型实现**IEvent**接口的事件和事件对应的**EventContext**来实现。从这些信息中，它根据观察者支持的事件类型，在构造函数中填充的**_methodsByEventType**中找到相应的方法。如果支持，它将继续通过服务提供者获取观察者类型的实例。对于每个方法，它根据方法的正确签名进行调用，如果方法是异步的，它将等待返回的**Task**。'
- en: With the concrete handler that handles the invocation, you’re going to need
    a service that knows about all the observers and can call the correct ones when
    an event occurs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理调用的具体处理程序一起，你需要一个了解所有观察者并能调用正确观察者的服务。
- en: 'Within the **EventSourcing** folder, create a file called **IObservers.cs**
    and make it look like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹中，创建一个名为**IObservers.cs**的文件，并使其看起来如下：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code represents the contract for **IObservers**. The **OnNext()** method
    will be the method called by the system that knows when events have occurred.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码代表了**IObservers**的契约。**OnNext()**方法将是系统调用以知道事件何时发生的方法。
- en: You’re going to need an implementation of this interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一个此接口的实现。
- en: 'Within the **EventSourcing** folder, create a file called **Observers.cs**
    and make it look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹中，创建一个名为**Observers.cs**的文件，并使其看起来如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code leverages **ITypes** from fundamentals for discovery. The code scans
    through all the types and filters out those that do not have **ObserverAttribute**,
    leaving only the types that do have it. For every type that has the **ObserverAttribute**,
    it then creates an instance of **ObserverHandler** by passing in **serviceProvider**
    and the target type, which is the observer itself.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码利用**ITypes**从基础中进行发现。代码扫描所有类型，并过滤掉那些没有**ObserverAttribute**的类型，只留下具有**ObserverAttribute**的类型。对于每个具有**ObserverAttribute**的类型，它通过传递**serviceProvider**和目标类型（即观察者本身）来创建一个**ObserverHandler**实例。
- en: 'For invoking the handler, you need an implementation of the **OnNext()** method.
    In the **Observers** class, add the following method at the bottom:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用处理器，您需要一个实现**OnNext()**方法的实例。在**Observers**类中，在底部添加以下方法：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code filters down to only the handlers that are capable by looking at the
    **EventTypes** property of the handler, and whether it contains the type of the
    **@event** argument. It then calls the **OnNext()** method of the handler and
    collects all the **Task** instances for all the calls it made, so that it can
    wait for them all to finish.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过查看处理器的**EventTypes**属性以及它是否包含**@event**参数的类型来筛选出能够处理的事件处理器，然后调用处理器的**OnNext()**方法，并收集它所做所有调用中的所有**Task**实例，以便它可以等待它们全部完成。
- en: With the observer infrastructure in place, you’ll need something that triggers
    this. We’re not going to implement a fully working event sourcing system, as that
    would be too involved. Instead, we’re going to make a few shortcuts and not save
    the events anywhere.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了观察者基础设施之后，您需要某种触发器。我们不会实现一个完整的工作事件源系统，因为这会过于复杂。相反，我们将采取一些捷径，并且不会将事件保存到任何地方。
- en: In an event-sourced system, you need a place to append the events to a sequence;
    the main place you append to is called an event log. Let’s introduce this concept.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件源系统中，您需要一个地方将事件追加到序列中；您追加到的主要地方称为事件日志。让我们介绍这个概念。
- en: 'Within the **EventSourcing** folder, create a file called **IEventLog.cs**
    and make it look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹内，创建一个名为**IEventLog.cs**的文件，并使其看起来如下：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code represents the contract for the event log with only one method in this
    version, which enables you to append an event for a specific **EventSourceId**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码代表了这个版本的事件日志合约，其中只有一个方法，这使您能够为特定的**EventSourceId**追加一个事件。
- en: You’ll need an implementation of the **IEventLog** interface.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个实现**IEventLog**接口的实例。
- en: 'Within the **EventSourcing** folder, create a file called **EventLog.cs** and
    make it look like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在**EventSourcing**文件夹内，创建一个名为**EventLog.cs**的文件，并使其看起来如下：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code represents a very simplistic implementation that takes a direct dependency
    on **IObservers** for it to call when an event has been appended. It manages internally
    the **_sequenceNumber**. As you can see, there is no persistence and the whole
    implementation is naive at best. But it serves the purpose of this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码代表了一个非常简单的实现，它直接依赖于**IObservers**来调用，当事件被追加时。它内部管理**_sequenceNumber**。正如您所看到的，这里没有持久化，整个实现至多算是天真。但它服务于本章的目的。
- en: Now that you have built all this nice infrastructure for invoking methods by
    the convention on observers, you’re probably eager to take it out for a spin.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为通过约定在观察者上调用方法建立了所有这些美好的基础设施，您可能渴望将其付诸实践。
- en: Using the infrastructure
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基础设施
- en: Going with the bank theme of the chapter, let’s create something that represents
    that domain. In a bank, you can open an account, deposit and withdraw money from
    it, and then possibly, and ultimately, close an account. All of these are very
    important events that happen in the lifespan of an account.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着本章的银行主题，让我们创建一些代表该领域的东西。在银行中，您可以开设账户，从账户中存钱和取钱，然后可能最终关闭账户。所有这些都是在账户生命周期中发生的重要事件。
- en: 'Within the root folder of the chapter code, create a file called **Events.cs**
    and make it look like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节代码的根目录下，创建一个名为**Events.cs**的文件，并使其看起来如下：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code holds all the events we want for now as **record** types and they all
    implement the **IEvent** interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在持有我们想要的全部事件，它们都是**record**类型，并且都实现了**IEvent**接口。
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In a production environment, I would recommend keeping one file per type, as
    that makes it easier to navigate and discover events in your system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我建议每个类型保留一个文件，因为这使您更容易在系统中导航和发现事件。
- en: With the events in place, you can now go ahead and create observers that will
    react to the events occurring.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件就绪后，你现在可以继续创建观察者，它们将对发生的事件做出反应。
- en: 'Within the root folder of the chapter code, create a file called **AccountLifecycle.cs**
    and make it look like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节代码的根目录下创建一个名为**AccountLifecycle.cs**的文件，并使其看起来如下所示：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code adds a class called **AccountLifecycle** and adorns it with the **[Observer]**
    attribute. Its purpose is to only deal with the life cycle events of **BankAccountOpened**
    and **BankAccountClosed**. Notice that it uses the convention fully with custom
    names of the methods and also the different signatures.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了一个名为**AccountLifecycle**的类，并使用**[Observer]**属性对其进行装饰。它的目的是仅处理**BankAccountOpened**和**BankAccountClosed**的生命周期事件。请注意，它完全遵循约定，使用自定义方法名称和不同的签名。
- en: For the events that affect the balance of an account, you could then separate
    that particular logic into its own observer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于影响账户余额的事件，你可以将这部分特定逻辑分离成它自己的观察者。
- en: 'Within the root folder of the chapter code, create a file called **AccountBalance.cs**
    and make it look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节代码的根目录下创建一个名为**AccountBalance.cs**的文件，并使其看起来如下所示：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code adds a class called **AccountBalance** and adorns it with the **[Observer]**
    attribute. Its purpose is to only deal with the balance events of **DepositPerformed**
    and **WithdrawalPerformed**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了一个名为**AccountBalance**的类，并使用**[Observer]**属性对其进行装饰。它的目的是仅处理**DepositPerformed**和**WithdrawalPerformed**的余额事件。
- en: Both observers are just logging what has happened to the console. In a real
    implementation of these, you’d probably want to store the data somewhere. The
    benefit here is that you could store the data in two different locations. For
    life cycle events, you’re only interested in the ownership and any details related
    to the account, while with the balance events, you’re only interested in what
    affects the balance and not interested in anything else. Breaking these things
    up makes it easier to choose the right technology for the job and also model each
    of these independently and create a less coupled system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个观察者只是将发生的事情记录到控制台。在实际实现这些时，你可能想要将数据存储在某个地方。这里的优点是你可以将数据存储在两个不同的位置。对于生命周期事件，你只对所有权和与账户相关的任何细节感兴趣，而对于余额事件，你只对影响余额的内容感兴趣，而不对其他任何事情感兴趣。将这些事情分开来使得选择合适的技术和独立地建模每个部分以及创建一个松耦合的系统变得更加容易。
- en: Now you want to do the last hookup and throw some events at it and verify that
    it does the job.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想要进行最后的连接，向其抛出一些事件并验证它是否完成了工作。
- en: 'Open the **Program.cs** file and make it look like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Program.cs**文件，使其看起来如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code sets up the necessary plumbing code to get the default .NET inversion
    of the control container going; it leverages **AddBindingsByConvention()** that
    you created in [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over
    Configuration*, to hook up services by convention, and **AddSelfBinding()** that
    you created in [*Chapter 11*](B19418_11.xhtml#_idTextAnchor177), *Applying the*
    *Open-Closed Principle*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了必要的管道代码，以启动默认的.NET控制反转容器；它利用你在[*第10章*](B19418_10.xhtml#_idTextAnchor162)，*约定优于配置*中创建的**AddBindingsByConvention()**来通过约定连接服务，以及你在[*第11章*](B19418_11.xhtml#_idTextAnchor177)，*应用开闭原则*中创建的**AddSelfBinding()**。
- en: With the basic infrastructure in place, you can now ask for an instance of **IEventLog**
    and start appending events to it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本基础设施就绪后，你现在可以请求**IEventLog**的实例并将其开始附加事件。
- en: 'Add the following code at the bottom of **Program.cs**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Program.cs**文件的底部添加以下代码：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running your program should give you a similar output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序应该给出类似的输出：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You now have the beginning of an event-sourcing component. But more importantly,
    it should give you an idea of what could be done dynamically without having to
    be tied to the strictness of inheritance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有了事件源组件的开始。但更重要的是，它应该给你一个动态执行而不必严格依赖于继承的想法。
- en: 'As an illustration of the implication of doing this with inheritance instead,
    we would need something like an interface that defines the method for the event;
    it could look something like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用继承而不是这种方式进行操作的后果的说明，我们需要一个定义事件方法的接口；它可能看起来如下所示：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this interface, we could take the **AccountLifecycle** observer and do
    the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此接口，我们可以对**AccountLifecycle**观察者执行以下操作：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While using this approach can provide compile-time safety, there are several
    downsides to consider. Firstly, naming every method **Handle** can lead to ambiguity
    and confusion, both in terms of tooling and readability. It may be difficult to
    determine which method to work with without carefully examining the parameters.
    Additionally, this approach limits you to only one method handling one event,
    while the convention-based approach allows for multiple individual methods with
    specific purposes to handle different aspects of the event.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用这种方法可以提供编译时安全性，但也有一些缺点需要考虑。首先，给每个方法命名**Handle**可能会导致歧义和混淆，无论是在工具使用上还是可读性方面。如果不仔细检查参数，可能很难确定要使用哪个方法。此外，这种方法限制你只能处理一个事件的一个方法，而基于约定的方法则允许有多个具有特定目的的独立方法来处理事件的不同方面。
- en: If you have an observer handling numerous events, you’d end up having to implement
    **IObserveEvent<>** for every type it handles. This can easily make your code
    less readable and maintainable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个处理多个事件的观察者，你将不得不为它处理的每个类型实现**IObserveEvent<>**。这可能会使你的代码的可读性和可维护性降低。
- en: There are pros and cons to both approaches, but hopefully, the takeaway is the
    potential this gives and, hopefully, it is useful and applicable to the code bases
    you work on.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有利有弊，但希望你能从中获得这种潜力，并且希望它对你所工作的代码库是有用且适用的。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Conventions, like those explained in this chapter with the discovery of well-known
    signatures, can be very powerful and help clean up your code. Forcing the developer
    to implement an interface for every class supported can be tedious and make the
    code look a little strange.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 约定，就像本章中解释的通过发现已知的签名，可以非常强大，并有助于清理你的代码。强迫开发者为每个支持的类实现一个接口可能会很繁琐，并使代码看起来有些奇怪。
- en: The downside of using a convention for method signatures is obviously that you
    are now at the mercy of runtime checks; there is no compiler that will help you.
    If you happen to make a little error, it won’t be noticed until you’re at runtime,
    which can be very annoying while in the zone and developing. In [*Chapter 17*](B19418_17.xhtml#_idTextAnchor299),
    *Static Code Analysis*, we will look at how we can detect errors at compile time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法签名约定的缺点显然是，你现在完全依赖于运行时检查；没有编译器能帮助你。如果你不小心犯了一点错误，它直到运行时才会被发现，这在专注开发时可能会非常恼人。在[*第17章*](B19418_17.xhtml#_idTextAnchor299)，“静态代码分析”中，我们将探讨如何在编译时检测错误。
- en: In the next chapter, we’re going to look at how automation can go further with
    conventions to put developers in the pit of success and avoid a recipe-driven
    development.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过约定进一步实现自动化，将开发者置于成功的深渊，并避免基于食谱的开发。
