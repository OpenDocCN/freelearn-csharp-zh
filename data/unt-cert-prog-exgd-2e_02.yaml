- en: '*Chapter 2*: Adding and Manipulating Objects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：添加和操作对象'
- en: In the previous chapter, we discussed the importance of the Official Unity Programmer
    exam and what benefits it can produce for any developer who is looking to reassure
    either themselves or others in understanding programming in Unity. We also discussed
    the building blocks of being a programmer in general and our game's design brief.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了官方Unity程序员考试的重要性以及它可以为任何寻求确保自己或他人理解Unity编程的开发者带来的好处。我们还讨论了成为程序员的一般构建块以及我们游戏的设计概要。
- en: As we are programmers working on a game engine, it is likely you will be working
    for a range of industries. In many of these industries, you will be issued with
    a technical brief/documentation (well, you should be!) for building an application.
    With this project, we are making a game, and the game design brief is effectively
    the blueprint for making this game. In this chapter, we will be applying the majority
    of our code, game objects, prefabs, and more based on the guidance of the brief
    and the game framework. We will be reminding ourselves of the brief and game framework
    during this chapter and will transfer specific information into our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在游戏引擎上工作的程序员，你可能会为多个行业工作。在这些行业中，你可能会收到一份技术概要/文档（嗯，你应该会！）用于构建应用程序。在这个项目中，我们正在制作一个游戏，游戏设计概要实际上是制作这个游戏的蓝图。在本章中，我们将根据概要和游戏框架的指导，应用我们的大部分代码、游戏对象、预制体等。我们将在本章中提醒自己概要和游戏框架，并将具体信息转移到我们的代码中。
- en: With regard to our code, we will be covering the importance of interfaces and
    scriptable objects to help structure and uniform our code, preventing it from
    bloating unnecessarily, which we covered in [*Chapter 1*](B18381_01_Epub.xhtml#_idTextAnchor016),
    *Setting Up and Structuring Our Project*, with SOLID principles. We will also
    be getting used to the Unity Editor and becoming familiar with game objects, prefabs,
    and importing three-dimensional models to animate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的代码，我们将讨论接口和可脚本化对象的重要性，以帮助结构化和统一我们的代码，防止其无必要地膨胀，这一点我们在[*第一章*](B18381_01_Epub.xhtml#_idTextAnchor016)，“设置和结构化我们的项目”，基于SOLID原则中已经讨论过。我们还将熟悉Unity编辑器，并了解游戏对象、预制体以及导入三维模型进行动画制作。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Setting up our Unity project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的Unity项目
- en: Introducing our interface (`IActorTemplate`)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍我们的接口（`IActorTemplate`）
- en: Introducing our `ScriptableObject` (`SOActorModel`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍我们的`ScriptableObject`（`SOActorModel`）
- en: Setting up our `Player`, `PlayerSpawner`, and `PlayerBullet` scripts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的`Player`、`PlayerSpawner`和`PlayerBullet`脚本
- en: Planning and creating our enemy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划和创建我们的敌人
- en: Setting up our `EnemySpawner` and enemy script
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的`EnemySpawner`和敌人脚本
- en: The next section will outline the exam objectives covered in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将概述本章涵盖的考试目标。
- en: Core exam skills covered in this chapter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技能
- en: '*Programming core interactions*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互*：'
- en: Implement and configure game object behavior and physics.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象行为和物理。
- en: Implement and configure input and controls.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置输入和控制。
- en: Implement and configure camera views and movement.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置摄像机视图和移动。
- en: '*Working in the art pipeline*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*在艺术管道中工作*：'
- en: Understand lighting and write scripts that interact with Unity's lighting API.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解光照并编写与Unity光照API交互的脚本。
- en: Understand two- and three-dimensional animation and write scripts that interact
    with Unity's animation API.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解二维和三维动画，并编写与Unity动画API交互的脚本。
- en: '*Programming for scene and environment design*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景和环境设计编程*：'
- en: Identify methods for implementing game object instantiation, destruction, and
    management.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实现游戏对象实例化、销毁和管理的方法。
- en: Demonstrate knowledge of developer testing and its impact on the software development
    process, including Unity Profiler and traditional debugging and testing techniques.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示对开发者测试及其对软件开发过程影响的了解，包括Unity Profiler和传统的调试和测试技术。
- en: Recognize techniques for structuring scripts for modularity, readability, and
    re-usability.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到结构化脚本的模块化、可读性和可重用性技术。
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可以在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02)找到。
- en: You can download the entire chapter project files at [https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载整个章节的项目文件[https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All content for this chapter is held in the relevant `unitypackage` file, including
    a `Complete` folder that contains all of the work we'll carry out in the chapter,
    so if at any point you need some reference material or extra guidance, be sure
    to check it out.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都存储在相关的 `unitypackage` 文件中，包括包含我们在本章中将要执行的所有工作的 `Complete` 文件夹，所以如果您在任何时候需要一些参考资料或额外指导，请务必查看。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3yfWyt5](https://bit.ly/3yfWyt5).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解 *Code in Action*：[https://bit.ly/3yfWyt5](https://bit.ly/3yfWyt5)。
- en: Setting up our Unity project
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的 Unity 项目
- en: Things can get messy quickly in a project if we don't manage our files correctly
    by placing them in the allocated folders. If you want to structure your folders
    your own way, or during the book, you decide to stray away from how I'm doing
    it, that's also fine. Just try and be conscious of your future self or other people
    working on this project when it comes to finding and organizing files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不正确地管理文件，将它们放置在分配的文件夹中，项目可能会很快变得混乱。如果您想以自己的方式组织文件夹，或者在本书中，您决定偏离我的做法，那也是可以的。只是当涉及到查找和组织文件时，尽量意识到您未来的自己或其他在这个项目上工作的人。
- en: 'Open the project up if you haven''t already and create the following folders:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有打开项目，请创建以下文件夹：
- en: '`Model` contains 3D models (the player ship, enemies, bullets, and so on).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model` 包含 3D 模型（玩家飞船、敌人、子弹等）。'
- en: '`Prefab` holds instances of game objects (these are created within Unity).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Prefab` 存储游戏对象的实例（这些是在 Unity 中创建的）。'
- en: '`Scene` stores our first-level scene as well as other levels.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scene` 存储我们的第一级场景以及其他级别。'
- en: '`Script` contains all of our code.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Script` 包含我们所有的代码。'
- en: '`Material` stores our game object materials.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Material` 存储我们的游戏对象材质。'
- en: '`Resources` stores assets and objects to load into our game.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources` 存储要加载到游戏中的资源和对象。'
- en: '`ScriptableObject` are data containers that are capable of storing large amounts
    of data.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScriptableObject` 是能够存储大量数据的数据容器。'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You should know what a prefab is, as it''s one of the main parts of what makes
    Unity so quick and easy to use. However, if you don''t: it''s typically your game
    object with its settings and components stored in an instance. You can store your
    game objects in your **Project** window as prefabs by dragging the game object
    from the **Hierarchy** window. A blue box icon will be generated following the
    game object''s name, and if you select the prefab in the **Project** window, its
    **Inspector** window details will show all its stored values. If you would like
    to know more about prefabs, you can check out the documentation at [https://docs.unity3d.com/Manual/Prefabs.html](https://docs.unity3d.com/Manual/Prefabs.html).'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该了解预制件是什么，因为它是使 Unity 迅速易用的主要部分之一。然而，如果您不知道：它通常是存储在实例中的具有其设置和组件的游戏对象。您可以通过从
    **Hierarchy** 窗口中拖动游戏对象到 **Project** 窗口中，将游戏对象作为预制件存储在您的 **Project** 窗口中。游戏对象名称之后将生成一个蓝色框图标，如果您在
    **Project** 窗口中选择预制件，其 **Inspector** 窗口将显示所有存储的值。如果您想了解更多关于预制件的信息，可以查看[https://docs.unity3d.com/Manual/Prefabs.html](https://docs.unity3d.com/Manual/Prefabs.html)上的文档。
- en: 'The following screenshot shows you how to create these folders:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何创建这些文件夹：
- en: '![Figure 2.1 – Creating a folder in the Unity editor'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – 在 Unity 编辑器中创建文件夹'
- en: '](img/Figure_2.01_B18381.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.01_B18381.jpg]'
- en: Figure 2.1 – Creating a folder in the Unity Editor
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 在 Unity 编辑器中创建文件夹
- en: 'Next, we will create subfolders; we need to do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建子文件夹；我们需要执行以下操作：
- en: 'Within our `Prefab` folder, create another two folders, `Enemies` and `Player`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Prefab` 文件夹中，创建另外两个文件夹，`Enemies` 和 `Player`：
- en: '![Figure 2.2 – Folders created in the Unity editor'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – 在 Unity 编辑器中创建的文件夹'
- en: '](img/Figure_2.02_B18381.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.02_B18381.jpg]'
- en: Figure 2.2 – Folders created in the Unity Editor
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Unity编辑器中创建的文件夹
- en: '`Resources` is a special folder that Unity recognizes. It will allow us to
    load assets while the game is running. For more information about the `Resources`
    folder, check the documentation at [https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resources`是一个Unity识别的特殊文件夹。它将允许我们在游戏运行时加载资源。有关`Resources`文件夹的更多信息，请查看[https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html)上的文档。'
- en: Further Information
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: It's worth mentioning the `StreamingAssets` folder at this point. Even though
    we aren't using it in this project, it relates well to how similar (and how different)
    it is to the `Resources` folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提一下`StreamingAssets`文件夹。尽管我们在这个项目中没有使用它，但它很好地说明了它与`Resources`文件夹的相似之处（以及不同之处）。
- en: The `Resources` folder imports assets and converts them into internal formats
    that will be compatible with the target platform. So, for example, a PNG file
    will get converted and compressed when the project is being built.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resources`文件夹导入资源并将它们转换为与目标平台兼容的内部格式。例如，当项目构建时，PNG文件将被转换和压缩。'
- en: 'The `StreamingAssets` folder will hold the PNG file, not convert or compress
    it. For more information on Streaming Assets, check out the following link: [https://docs.unity3d.com/Manual/StreamingAssets.html](https://docs.unity3d.com/Manual/StreamingAssets.html).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamingAssets`文件夹将保存PNG文件，不会对其进行转换或压缩。有关Streaming Assets的更多信息，请参阅以下链接：[https://docs.unity3d.com/Manual/StreamingAssets.html](https://docs.unity3d.com/Manual/StreamingAssets.html)。'
- en: 'Provided in the *Technical requirements* section is the download link for the
    GitHub repository of this chapter. Once downloaded, double-click the `Chapter2.unitypackage`
    file, and we will be given a list of assets to import into our Unity project:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在**技术要求**部分提供了本章GitHub仓库的下载链接。下载后，双击`Chapter2.unitypackage`文件，我们将得到一个资产列表，这些资产将被导入到我们的Unity项目中：
- en: '`Player_ship.fbx`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player_ship.fbx`'
- en: '`enemy_wave.fbx`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enemy_wave.fbx`'
- en: 'The following screenshot shows the **Import** window of the assets we are about
    to bring into our project:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将要导入到项目中的资产的**导入**窗口：
- en: '![Figure 2.3 – Importing assets into your project'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 将资源导入到你的项目中'
- en: '](img/Figure_2.03_B18381.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B18381.jpg)'
- en: Figure 2.3 – Importing assets into your project
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 将资源导入到你的项目中
- en: Make sure all assets are ticked and click the **Import** button at the bottom-right
    corner of the window. We can now move on to organizing our files and folders in
    the **Project** window in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有资源都被勾选，然后点击窗口右下角的**导入**按钮。我们现在可以继续到下一节，在**项目**窗口中组织我们的文件和文件夹。
- en: Creating prefabs
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预制件
- en: 'In this section, we are going to create three prefabs: the player, the player''s
    bullet, and the enemy. These prefabs will hold components, settings, and other
    property values for our game that we can instantiate throughout our game.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建三个预制件：玩家、玩家的子弹和敌人。这些预制件将包含我们游戏中的组件、设置和其他属性值，我们可以在整个游戏中实例化它们。
- en: Let's start by making our `player_ship.fbx` file into a prefab instance by doing
    the following.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将我们的`player_ship.fbx`文件制作成预制件实例开始，操作如下。
- en: Sometimes, when importing any three-dimensional file, it may contain extra data
    that we might not need. For example, our `player_ship` model comes with its own
    material and animation properties. We don't require any of these, so let's remove
    these properties before continuing to import our models fully into our Unity project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在导入任何三维文件时，它可能包含我们可能不需要的额外数据。例如，我们的`player_ship`模型附带其自身的材质和动画属性。我们不需要这些，所以让我们在将模型完全导入Unity项目之前移除这些属性。
- en: 'To remove the `player_ship` model, we need to do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除`player_ship`模型，我们需要执行以下操作：
- en: In the `Assets/Model` and select the `player_ship` file.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Model`中，选择`player_ship`文件。
- en: In the **Inspector** window, select the **Materials** button.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，选择**材质**按钮。
- en: Make sure the **Material Creation Mode** is set to **None** from the drop-down
    list, and then click the **Apply** button.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从下拉列表中将**材质创建模式**设置为**无**，然后点击**应用**按钮。
- en: Now, click the **Animation** button next to the **Materials** button.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**材质**按钮旁边的**动画**按钮。
- en: Untick the **Import Animation** checkbox, followed by clicking the **Apply**
    button.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选**导入动画**复选框，然后点击**应用**按钮。
- en: Select the **Rig** button next to the **Animation** button.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**按钮旁边选择**绑定**按钮。
- en: Select the current value in the **Animation Type** drop-down menu and select
    **None**, followed by the **Apply** button.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画类型**下拉菜单中选择当前值，然后选择**无**，接着点击**应用**按钮。
- en: That's all of the `player_ship` model.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是`player_ship`模型的全部内容。
- en: Important Information
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要信息
- en: Throughout the book, whenever we select a three-dimensional model, make sure
    to run through the same process, as we will not require imported extras such as
    the ones we just removed. This means I would like you now to repeat the process
    we have just gone through with the `enemy_wave.fbx` model.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在整本书中，每次我们选择一个三维模型时，确保运行相同的流程，因为我们不会需要导入额外的元素，就像我们刚才移除的那些。这意味着我现在希望您重复我们刚刚对`enemy_wave.fbx`模型所进行的流程。
- en: 'Let''s continue preparing our `player_ship` model for our game:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为我们的游戏准备`player_ship`模型：
- en: Click and drag `player_ship` from `Assets/Model` into the **Hierarchy** window.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/Model`中点击并拖动`player_ship`到**层次结构**窗口。
- en: Select the `player_ship` in the `player_ship`
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“玩家飞船”中选中`player_ship`
- en: '`0` apart from `1` on all axes'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有轴向上与`1`不同`0`
- en: 'The following screenshot shows the `player_ship` values in the **Inspector**
    window:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了**检查器**窗口中的`player_ship`值：
- en: '![Figure 2.4 – The player_ship values in the Inspector window'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 玩家飞船值在检查器窗口中'
- en: '](img/Figure_2.04_B18381.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 创建预制体对话框](img/Figure_2.04_B18381.jpg)'
- en: Figure 2.4 – The player_ship values in the Inspector window
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 检查器窗口中的玩家飞船值
- en: Click and drag the `player_ship` from the `Assets/Prefab/Player` folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/Prefab/Player`文件夹中点击并拖动`player_ship`。
- en: 'When creating a prefab, sometimes you might be asked if this is an **Original**
    or **Variant**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建预制体时，有时您可能会被问及这是**原始**还是**变体**：
- en: '![](img/Figure_2.05_B18381.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 创建预制体对话框](img/Figure_2.05_B18381.jpg)'
- en: Figure 2.5 – The Create Prefab Dialog
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 创建预制体对话框
- en: A variant prefab will be a copy of an original prefab but will also carry any
    changes made from the prefab it originates from. So, for example, if the original
    prefab was a car with 4 wheels, the variant will have the same. If the original
    prefab changes it's numbers from 4 to 3, the variant will copy the original prefab.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 变体预制体将是原始预制体的副本，但也将携带从原始预制体中做出的任何更改。例如，如果原始预制体是一辆有4个轮子的车，那么变体也将有相同的。如果原始预制体将其数量从4改为3，变体将复制原始预制体。
- en: Note that `player_ship` in the **Hierarchy** window has turned blue, which means
    it has become a prefab.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**层次结构**窗口中的`player_ship`已经变成蓝色，这意味着它已经变成了一个预制体。
- en: Delete the `player_ship` from the **Hierarchy** window.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中删除`player_ship`。
- en: We are going to use a similar process to create our `enemy_wave` prefab, but
    we will also need to create its own name tag because there isn't an **Enemy**
    tag... yet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似的过程来创建我们的`enemy_wave`预制体，但我们也需要创建它自己的名称标签，因为目前还没有**敌人**标签...
- en: An Enemy prefab and custom tags
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敌人预制体和自定义标签
- en: In this section, we are going to create an `enemy_wave` prefab along with a
    custom tag. The tag will be used to identify and categorize all related enemies
    under one tag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个`enemy_wave`预制体以及一个自定义标签。该标签将用于识别和分类所有相关敌人。
- en: 'To create an `enemy_wave` prefab and custom name tag, follow these instructions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`enemy_wave`预制体和自定义名称标签，请按照以下说明操作：
- en: In the `enemy_wave.fbx` file from `Assets/Model` into the **Hierarchy** window.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Assets/Model`中的`enemy_wave.fbx`文件拖入**层次结构**窗口。
- en: With the `enemy_wave` file selected in the `enemy_wave`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`enemy_wave`中选中`enemy_wave`文件。
- en: '`0` apart from `1` on all axes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有轴向上与`1`不同`0`：
- en: '![](img/Figure_2.06_B18381.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 玩家飞船值在检查器窗口中](img/Figure_2.06_B18381.jpg)'
- en: Figure 2.6 – The enemy_wave values in the Inspector window
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 检查器窗口中的敌人波值
- en: 'Now, let''s create a new tag for the `enemy_wave` game object by doing the
    following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤为`enemy_wave`游戏对象创建一个新的标签：
- en: Choose the **Untagged** parameter in the **Inspector** window.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中选择**未标记**参数。
- en: From the **Tag** drop-down menu, select **Add Tag...**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**标签**下拉菜单中选择**添加标签...**。
- en: The **Inspector** window will now show the **Tags & Layers** window.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查器**窗口现在将显示**标签和层**窗口。'
- en: Click the **+** to add a new tag, as circled in the following screenshot.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**以添加一个新的标签，如图下截图所示。
- en: 'Enter `Enemy` in the pop-up window, as shown in the following screenshot, and
    then click the **Save** button:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出窗口中输入`Enemy`，如图下截图所示，然后点击**保存**按钮：
- en: '![](img/Figure_2.07_B18381.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 玩家飞船值在检查器窗口中](img/Figure_2.07_B18381.jpg)'
- en: Figure 2.7 – Add a tag to the Tags & Layers list
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 向标签和层列表添加标签
- en: Back in the `enemy_wave` game object to bring back our **Inspector** window
    details.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`enemy_wave`游戏对象以恢复我们的**检查器**窗口详细信息。
- en: Click the **Untagged** parameter again.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击**未标记**参数。
- en: We can now see **Enemy** in our drop-down list, so select it.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在下拉列表中看到**敌人**，因此选择它。
- en: Drag the `enemy_wave` game object from the `Assets/Prefab/Enemies`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`enemy_wave`游戏对象从`Assets/Prefab/Enemies`拖动。
- en: Delete `enemy_wave` from the **Hierarchy** window
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中删除`enemy_wave`
- en: We now move on to our third prefab creation – the player's bullet. But this
    time, we won't import a three-dimensional model – we are going to create one in
    the Unity Editor, and then create a prefab from it in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续进行第三个预制体创建 – 玩家的子弹。但这次，我们不会导入三维模型 – 我们将在Unity编辑器中创建一个，然后在下一节中将其创建为预制体。
- en: Creating the player's bullet prefab
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建玩家的子弹预制体
- en: Next, we are going to create the visuals for the player's bullet in the Unity
    Editor. We will make a blue sphere and give it a surrounding light source. Let's
    start by creating a three-dimensional sphere game object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在Unity编辑器中创建玩家子弹的视觉效果。我们将制作一个蓝色球体并为其添加一个环绕光源。让我们先创建一个三维球体游戏对象。
- en: In the **Hierarchy** window, right-click, and from the drop-down list, select
    **3D Object** | **Sphere**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击，从下拉列表中选择**3D对象** | **球体**。
- en: 'With the newly created `Sphere` in the **Hierarchy** window still selected,
    make the following changes to the **Inspector** window:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仍然选中新创建的`Sphere`，在**检查器**窗口中进行以下更改：
- en: Change the game object name from `Sphere` to `player_bullet`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象名称从`Sphere`更改为`player_bullet`。
- en: Change **Tag** from **Untagged** to **Player**. The tag name makes it easier
    to identify later on in the chapter.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**从**未标记**更改为**玩家**。标签名称使得在章节的后续部分更容易识别。
- en: The `0`, apart from the `2` on all axes.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了所有轴上的`2`之外，`0`。
- en: 'The following screenshot shows all three changes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了所有三个更改：
- en: '![Figure 2.8 – The player_bullet values in the Inspector window'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 检查器窗口中的player_bullet值'
- en: '](img/Figure_2.08_B18381.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.08_B18381.jpg)'
- en: Figure 2.8 – The player_bullet values in the Inspector window
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 检查器窗口中的player_bullet值
- en: Next, we will give the `player_bullet` game object a new blue material.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将给`player_bullet`游戏对象添加一个新的蓝色材质。
- en: Creating and applying a material to the player's bullet
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建并应用玩家的子弹材质
- en: 'In this section, we will be creating a simple unlit material that will not
    take up much of the device''s performance, thanks to the simplicity of the material.
    To create a basic material and apply it to the `player_bullet` object, do the
    following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个简单的无光照材质，由于材质的简单性，它不会占用设备太多性能。要创建基本材质并将其应用到`player_bullet`对象上，请执行以下操作：
- en: In the `Assets/Material` folder.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Material`文件夹中。
- en: Inside the `Material` folder, make a new folder (the same way we did in the
    *Setting up our Unity project* section) and name the folder `Player`. That way,
    any material related to the player can be stored inside.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Material`文件夹内，创建一个新的文件夹（与我们在*设置我们的Unity项目*部分中所做的方式相同）并命名为`Player`。这样，任何与玩家相关的材质都可以存储在其中。
- en: Double click the newly created `Player` folder and right-click in the **Project**
    window (in the open space in the right section of the window) again, and from
    the drop-down list, select **Create** | **Material**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新创建的`Player`文件夹，然后在**项目**窗口中（在窗口右侧的空白区域）再次右键单击，从下拉列表中选择**创建** | **材质**。
- en: A new material file will be made. Rename it `player_bullet`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个新的材质文件。将其重命名为`player_bullet`。
- en: 'Select the `player_bullet` material, and in the **Inspector** window, change
    the material from a **Standard** shader to **Unlit** | **Color** by following
    the three steps in the following screenshot:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`player_bullet`材质，并在**检查器**窗口中，将材质从**标准**着色器更改为**不发光** | **颜色**，按照以下截图中的三个步骤操作：
- en: '![Figure 2.9 – Creating an Unlit Color Material'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – 创建不发光颜色材质'
- en: '](img/Figure_2.09_B18381.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.09_B18381.jpg)'
- en: Figure 2.9 – Creating an Unlit Color Material
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 创建不发光颜色材质
- en: The **Inspector** window will remove the majority of the properties and strip
    the material back to something simpler and easier to perform on any device.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查器**窗口将移除大部分属性并将材质简化，以便在任何设备上更容易执行。'
- en: Still in the `0`, `190`, `255`, and `255`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`0`，`190`，`255`和`255`。
- en: 'We have created and calibrated our player''s bullet, so now, we can apply the
    material to the `player_bullet` prefab by doing the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建并校准了玩家的子弹，现在我们可以通过以下步骤将材质应用到`player_bullet`预制件上：
- en: Select the `player_bullet` prefab in the following location of the `Assets/Prefab/Player`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下位置选择`player_bullet`预制件：`Assets/Prefab/Player`。
- en: In the `player_bullet` in the drop-down list until you see the material, and
    then select it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中选择`player_bullet`，直到你看到材质，然后选择它。
- en: 'The following screenshot shows the `player_bullet` prefab''s **Mesh Renderer**
    component updated to our new unlit material:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`player_bullet`预制件的**网格渲染器**组件更新到我们新的无光照材质：
- en: '![Figure 2.10 – player_bullet now has a player_bulletMat material'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.10 – player_bullet现在具有player_bulletMat材质'
- en: '](img/Figure_2.10_B18381.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.10_B18381.jpg](img/Figure_2.10_B18381.jpg)'
- en: Figure 2.10 – player_bullet now has a player_bulletMat material
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – `player_bullet`现在具有`player_bulletMat`材质
- en: In [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation,
    and Particles*, we will return to materials and art in general, which will be
    of note if you found this interesting. We will also play around with particle
    systems to create a fleet of stars rushing past the player's ship.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18381_04_Epub.xhtml#_idTextAnchor087)*，应用艺术、动画和粒子中，我们将回到材料和艺术的一般讨论，如果你对此感兴趣，这将值得关注。我们还将玩转粒子系统，创建一队星星飞掠过玩家的飞船。
- en: The last component we will add to our player's bullet is a surrounding light
    to give our bullet an energy glow.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到玩家子弹的最后一个组件是一个环绕灯光，给子弹一个能量发光的效果。
- en: Adding a light to the player's bullet
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向玩家的子弹添加灯光
- en: In this section, we will be adding a light component to the player's bullet
    to hide the impression that all that we are doing is firing spheres. It will also
    introduce us to Unity's point light, which acts as a glowing ball.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向玩家的子弹添加一个灯光组件，以隐藏我们只是在发射球体的印象。它还将介绍Unity的点光源，它充当发光球体。
- en: 'To add and customize a ball of light to the player''s bullet, we need to do
    the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加和自定义一个球状灯光到玩家的子弹，我们需要做以下操作：
- en: In the `Assets/Prefab/Player` folder, select the `player_bullet` prefab, and
    drag it into the **Hierarchy** window (if it isn't in the Hierarchy window already).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefab/Player`文件夹中，选择`player_bullet`预制件，并将其拖入**层次结构**窗口（如果它还没有在层次结构窗口中）。
- en: In the **Inspector** at the bottom of the components listed, click the **Add
    Component** button and select **Light** from the drop-down list.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件列表底部的**检查器**中，点击**添加组件**按钮，从下拉列表中选择**灯光**。
- en: The `player_bullet` prefab will now have a **Light** component attached to it.
    We just need to change three property values to make the light suit the game object
    more.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`player_bullet`预制件现在将附加一个**灯光**组件。我们只需更改三个属性值，使灯光更适合游戏对象。'
- en: Change the following property values in the `player_bullet` file's `50`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`player_bullet`文件的`50`中更改以下属性值
- en: '`0`, `190`, `255`, and `255`'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`, `190`, `255`, 和 `255`'
- en: '`20`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`20`'
- en: 'The following screenshot shows the **Light** component after the values have
    been updated:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了更新值后的**灯光**组件：
- en: '![Figure 2.11 – The Light component values in the Inspector window'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.11 – 检查器窗口中的灯光组件值'
- en: '](img/Figure_2.11_B18381.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.11_B18381.jpg](img/Figure_2.11_B18381.jpg)'
- en: Figure 2.11 – The Light component values in the Inspector window
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 检查器窗口中的灯光组件值
- en: Before moving onto the next section, because we have taken an existing prefab
    and added a material and a light component, we need to click the **Override**
    button to confirm the new changes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，因为我们已经对一个现有的预制件添加了材质和灯光组件，我们需要点击**覆盖**按钮以确认新的更改。
- en: 'The following screenshot shows the `player_bullet` prefab:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`player_bullet`预制件：
- en: '![Figure 2.12 – Updating the player_bullet prefab'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.12 – 更新player_bullet预制件'
- en: '](img/Figure_2.12_B18381.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.12_B18381.jpg](img/Figure_2.12_B18381.jpg)'
- en: Figure 2.12 – Updating the player_bullet prefab
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 更新player_bullet预制件
- en: Finally, click on `player_bullet` from the **Hierarchy**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**层次结构**中的`player_bullet`。
- en: In the next section, we will continue to update our three prefabs by applying
    Unity's own physics system, the **Rigidbody** component, to help detect collisions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续通过应用Unity自己的物理系统，即**刚体**组件，来更新我们的三个预制件，以帮助检测碰撞。
- en: Adding Rigidbody components and fixing game objects
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加刚体组件和修复游戏对象
- en: Because this game involves collisions with game objects, we need to apply collision
    detection to the player, the player's bullets, and the enemy. Unity offers a range
    of different shapes to wrap around a game object that functions as an invisible
    shield; we can set our code to react to contact being made with the shield.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个游戏涉及到与游戏对象的碰撞，我们需要对玩家、玩家的子弹和敌人应用碰撞检测。Unity 提供了一系列不同的形状来围绕游戏对象，使其作为一个不可见的盾牌；我们可以设置我们的代码以响应与盾牌接触。
- en: Before we add colliders to the player and enemy game objects (the **Sphere**
    game object automatically comes with a collider), we need to add a Unity component
    called **Rigidbody**. If a game object is going to collide with at least one other
    game object, it requires a **Rigidbody** component, which can affect a game object's
    mass, gravity, drag, constraints, and more. If you would like to know more about
    **Rigidbody** components, check out the documentation at [https://docs.unity3d.com/Manual/class-Rigidbody.html](https://docs.unity3d.com/Manual/class-Rigidbody.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将碰撞器添加到玩家和敌人游戏对象之前（**Sphere**游戏对象自动带有碰撞器），我们需要添加一个名为**Rigidbody**的Unity组件。如果一个游戏对象将要与至少一个其他游戏对象发生碰撞，它需要一个**Rigidbody**组件，该组件可以影响游戏对象的质量、重力、阻力、约束等。如果您想了解更多关于**Rigidbody**组件的信息，请查看[https://docs.unity3d.com/Manual/class-Rigidbody.html](https://docs.unity3d.com/Manual/class-Rigidbody.html)上的文档。
- en: Rigidbody Joints
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbody 联结
- en: Unity has other physics types apart from the collider. **Joints** also require
    the **Rigidbody** system, and they come in different forms, such as **Hinge**,
    **Spring**, and others.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Unity除了碰撞器之外还有其他物理类型。**关节**也需要**Rigidbody**系统，并且它们有不同的形式，如**铰链**、**弹簧**等。
- en: These **Joints** will simulate at a fixed point; for example, the **Hinge**
    **Joint** would be good at making a door swing back and forth around a door hinge's
    pivot point.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**关节**将在一个固定点进行模拟；例如，**铰链****关节**非常适合使门在门铰链的旋转点来回摆动。
- en: If you would like to know more about Joints, check the documentation at [https://docs.unity3d.com/Manual/Joints.html](https://docs.unity3d.com/Manual/Joints.html).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于**关节**的信息，请查看[https://docs.unity3d.com/Manual/Joints.html](https://docs.unity3d.com/Manual/Joints.html)上的文档。
- en: 'Let''s add the `player_ship` and `player_bullet` prefabs in one go:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次性添加`player_ship`和`player_bullet`预制件：
- en: In the **Project** window, navigate to **Prefab | Player**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，导航到**Prefab | Player**。
- en: Hold *Ctrl* (*command* on a Mac) and click on the `player_ship` and `player_bullet`
    files.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*（在Mac上为*command*）并点击`player_ship`和`player_bullet`文件。
- en: In the **Inspector** window, click the **Add Component** button.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**添加组件**按钮。
- en: From the drop-down menu, type `Rigidbody`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中，输入`Rigidbody`。
- en: Select **Rigidbody** (not **Rigidbody 2D**).
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Rigidbody**（不是**Rigidbody 2D**）。
- en: The **Rigidbody** component has now been assigned to our two game objects.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Rigidbody**组件现在已经被分配给了我们的两个游戏对象。'
- en: With the two game objects still selected in the **Inspector** window, under
    **Rigidbody**, make sure that the **Gravity** checkbox isn't ticked. If it was,
    our game objects would begin to sink into the scene while the game is being played.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中仍然选择两个游戏对象，在**Rigidbody**下，确保**重力**复选框没有被勾选。如果勾选了，我们的游戏对象在游戏进行时会开始沉入场景。
- en: 'Now, we can add colliders to our `player_ship` and `enemy_wave` game objects
    (our `player_bullet` already has a **SphereCollider**). We will be adding a **SphereCollider**
    to our game objects because it''s the cheapest collider to use, relative to performance
    costs:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将碰撞器添加到我们的`player_ship`和`enemy_wave`游戏对象中（我们的`player_bullet`已经有一个**SphereCollider**）。我们将为我们的游戏对象添加一个**SphereCollider**，因为它相对于性能成本来说是最便宜的碰撞器：
- en: Click and drag the `player_ship` prefab from the `Assets/Prefab/Player` into
    the **Hierarchy** window.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`player_ship`预制件从`Assets/Prefab/Player`拖动到**层次结构**窗口中。
- en: With the `player_ship` still selected in the `Sphere Collider` in the drop-down
    menu.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中的`Sphere Collider`下仍然选择`player_ship`。
- en: As soon as you see `player_ship` game object.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你看到`player_ship`游戏对象。
- en: You will notice a green wireframe around the `player_ship` in the `player_ship`
    still selected in the `player_ship` collider that will be used to detect hits.
    It may be too big for the purpose of a hitbox, so let's reduce its size.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在`player_ship`的碰撞器中有一个绿色的线框围绕在`player_ship`周围，这将用来检测击中。它可能对于击中框的用途来说太大，所以让我们减小其大小。
- en: 'With the `player_ship` prefab still selected in the `0.3` in the **Inspector**
    window, as shown in the following screenshot:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中仍然选择`player_ship`预制件，在`0.3`处，如图所示：
- en: '![Figure 2.13 – The triggered sphere collider added to the player_ship prefab'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13 – 添加到`player_ship`预制体的触发球体碰撞器'
- en: '](img/Figure_2.13_B18381.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B18381.jpg)'
- en: Figure 2.13 – The triggered sphere collider added to the player_ship prefab
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 添加到`player_ship`预制体的触发球体碰撞器
- en: Also, while we still have the `player_ship` prefab selected, check the `player_ship`
    prefab look for another collider without causing any form of potential physics
    collision.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当我们仍然选择`player_ship`预制体时，检查`player_ship`预制体中是否有另一个碰撞器，而不会引起任何形式的潜在物理碰撞。
- en: Click **Override** at the top-right corner followed by **Apply All** in the
    **Inspector** window to update the modifications we've made to our prefab with
    its **Rigidbody** and **SphereCollider** components.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口的右上角点击**Override**，然后点击**Apply All**以更新我们对预制体的**Rigidbody**和**SphereCollider**组件所做的修改。
- en: We can now select the `player_ship` prefab in the **Hierarchy** window and press
    *Delete* on our keyboard, as we no longer need it in our **Scene**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在**Hierarchy**窗口中选择`player_ship`预制体，然后在键盘上按*Delete*键，因为我们不再需要在**Scene**中使用它。
- en: 'We now need to apply the same methodology to the `player_bullet`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将同样的方法应用到`player_bullet`上：
- en: In the `player_bullet` prefab from `Assets /Prefab/Player` into the **Hierarchy**
    window.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`player_bullet`预制体从`Assets /Prefab/Player`拖放到**Hierarchy**窗口中。
- en: Check the **Is Trigger** box and adjust the **Radius** in the **SphereCollider**
    component in the **Inspector** window.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口的**SphereCollider**组件中勾选**Is Trigger**框，并调整**Radius**。
- en: Click `player_bullet` changes, and delete the `player_bullet` prefab from the
    **Hierarchy** window.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`player_bullet`更改，并从**Hierarchy**窗口中删除`player_bullet`预制体。
- en: 'The last game object we need to update is the `enemy_wave` prefab. We have
    already covered the steps with the `player_ship` and `player_bullet` prefabs,
    so it''s not ideal to repeat the instructions in full; however, we need to do
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的最后一个游戏对象是`enemy_wave`预制体。我们已经用`player_ship`和`player_bullet`预制体覆盖了步骤，所以完全重复指令并不理想；然而，我们需要做以下事情：
- en: Briefly, I want you to drag and drop the `enemy_wave` prefab from its location
    at `Assets/Prefab/Enemies` in the **Project** window into the **Hierarchy** window..
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简而言之，我想让你将`enemy_wave`预制体从**Project**窗口中`Assets/Prefab/Enemies`的位置拖放到**Hierarchy**窗口中..
- en: Add a `enemy_wave` prefab in the **Inspector** window.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口中添加一个`enemy_wave`预制体。
- en: Adjust the `enemy_wave` prefab with the correct proportions, as we did with
    `player_ship`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`enemy_wave`预制体的正确比例，就像我们调整`player_ship`一样。
- en: The `enemy_wave` prefab doesn't require a **Rigidbody** component, as it will
    be colliding with relevant game objects that hold one themselves.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`enemy_wave`预制体不需要**Rigidbody**组件，因为它将与自身包含一个组件的相关游戏对象发生碰撞。'
- en: Finally, `enemy_wave` prefab from the **Hierarchy** window.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从**Hierarchy**窗口中删除`enemy_wave`预制体。
- en: 'Use the following screenshot as a reference for the preceding mini-brief, and
    if you get stuck, use the previous steps that we discussed in this section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下截图作为前面简短说明的参考，如果你卡住了，请使用本节中讨论的先前步骤：
- en: '![Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14 – 添加并缩放到`enemy_wave`预制体的触发碰撞器'
- en: '](img/Figure_2.14_B18381.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B18381.jpg)'
- en: Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 添加并缩放到`enemy_wave`预制体的触发碰撞器
- en: Hopefully, that went well for you. If you get stuck at any point, refer to the
    [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage)
    folder containing all the completed files to check them out and compare.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这对你来说进展顺利。如果你在任何地方卡住了，请参考包含所有完成文件的[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage)文件夹，检查它们并进行比较。
- en: Before moving on, note that if a game object is pink, such as our `enemy_wave`
    object in the previous screenshot, it simply means that it doesn't have a material
    attached. In other cases, it can also mean there is something wrong with the shader
    attached to the material.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，如果一个游戏对象是粉红色的，例如我们之前截图中的`enemy_wave`对象，这仅仅意味着它没有附加材质。在其他情况下，这也可能意味着附加到材质上的着色器有问题。
- en: 'We can fix this pink issue by doing the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式修复这个粉红色问题：
- en: In the `Assets/Prefab/Enemies`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Prefab/Enemies`。
- en: Drag and drop enemy_wave into the Hierarchy window. Expand the drop down next
    to `enemy_wave` in the Hierarchy window..
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 enemy_wave 拖放到层次窗口中。展开层次窗口中 `enemy_wave` 旁边的下拉菜单。
- en: Select the first game object, titled `enemy_wave_core`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一个游戏对象，标题为 `enemy_wave_core`。
- en: 'In the **Inspector** window, select the small **remote** circle next to the
    **Element 0** parameter in the **Mesh Renderer** component (denoted by **1** in
    the following screenshot), and then select **Default-Material** (denoted by **2**)
    from the drop-down list, as shown in the following screenshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，选择 **Mesh Renderer** 组件中 **元素 0** 参数旁边的小 **远程** 圆圈（在下述截图中用 **1**
    表示），然后从下拉列表中选择 **默认材质**（在下述截图中用 **2** 表示），如图所示：
- en: '![Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.15 – 将默认材质添加到 enemy_wave_core 游戏对象'
- en: '](img/Figure_2.15_B18381.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.15_B18381.jpg)'
- en: Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 将默认材质添加到 enemy_wave_core 游戏对象
- en: Follow the same steps for its sibling game object, `enemy_wave_ring`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其兄弟游戏对象 `enemy_wave_ring`，遵循相同的步骤。
- en: The `enemy_wave` object will now have a default material applied.If any changes
    were made to the prefab be sure to click **Override, Apply All**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`enemy_wave` 对象现在将应用默认材质。如果对预制体进行了任何更改，请确保点击 **覆盖，应用全部**。'
- en: Attributes
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: 'If a game object requires a component such as `Rigidbody`, we can place, above
    the class name, what is effectively a reminder to the script that the game object
    needs it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个游戏对象需要像 `Rigidbody` 这样的组件，我们可以在类名上方放置一个实际上是对脚本的一个提醒，表明游戏对象需要它：
- en: '`[RequireComponent(typeof(Rigidbody))]`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`[需要组件(typeof(Rigidbody))]`'
- en: If the game object doesn't have the component, the script will create one, and
    if we try to remove the `Rigidbody` component, we will receive a message in the
    Unity Editor that it is a required component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏对象没有组件，脚本将创建一个，如果我们尝试移除 `Rigidbody` 组件，我们将在 Unity 编辑器中收到一条消息，表明这是一个必需的组件。
- en: This code isn't a requirement as such, more of a good practice with components
    in general.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是必需的，更多的是一种在组件中的一般良好实践。
- en: If you would like to know more about the `RequireComponent` attribute, check
    the documentation at [https://docs.unity3d.com/ScriptReference/RequireComponent.html](https://docs.unity3d.com/ScriptReference/RequireComponent.html).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 `RequireComponent` 属性的信息，请查看 [https://docs.unity3d.com/ScriptReference/RequireComponent.html](https://docs.unity3d.com/ScriptReference/RequireComponent.html)
    的文档。
- en: So, now we have our colliders and **Rigidbody** components applied to our game
    objects. This gives us the ability to create a reaction when colliders come into
    contact with each other.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经将碰撞体和 **Rigidbody** 组件应用到我们的游戏对象上。这使我们能够在碰撞体相互接触时创建反应。
- en: Because we are starting to build up our project, let's quickly discuss saving
    our scenes, projects, and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们开始构建我们的项目，让我们快速讨论保存我们的场景、项目等。
- en: Saving and publishing our work
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和发布我们的工作
- en: It's easy to get stuck into our project, but as a brief reminder, save your
    work as often as possible. That way, if anything bad happens, you can always revert
    back.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 容易陷入我们的项目，但作为简短的提醒，尽可能频繁地保存你的工作。这样，如果发生任何不好的事情，你总是可以回滚。
- en: Because we have created and saved our `testLevel` scene from the previous chapter,
    we can also add this scene to the **Build Settings** window. The reason for this
    is so that Unity is aware of what scenes we want to include in our project. It
    is also a requirement when it comes to packaging up our game as a build for deployment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经从前一章创建了并保存了 `testLevel` 场景，我们还可以将此场景添加到 **构建设置** 窗口中。这样做的原因是让 Unity 知道我们想在项目中包含哪些场景。在将游戏打包为部署的构建时，这也是一个要求。
- en: 'To add our scene to **Build Settings**, do the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的场景添加到 **构建设置**，请执行以下操作：
- en: At the top of the Unity Editor, click **File | Build Settings**. The **Build
    Settings** window will appear.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器顶部，点击 **文件 | 构建设置**。将出现 **构建设置** 窗口。
- en: Click the `testLevel` scene.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `testLevel` 场景。
- en: 'The following screenshot shows the `testLevel` scene. When we add more scenes
    later, each scene will be numbered:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了 `testLevel` 场景。当我们稍后添加更多场景时，每个场景都将被编号：
- en: '![Figure 2.16 – Adding the testLevel scene to the Scenes In Build list'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16 – 将 testLevel 场景添加到构建场景列表中'
- en: '](img/Figure_2.16_B18381.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.16_B18381.jpg)'
- en: Figure 2.16 – Adding the testLevel scene to the Scenes In Build list
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 将测试级别场景添加到构建场景列表中
- en: Close the **Build Settings** window. We will come back to this when we have
    more scenes to add in the next chapter.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 **Build Settings** 窗口。我们将在下一章添加更多场景时回到这里。
- en: It's a good habit to save the project by clicking **File | Save Project**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **文件 | 保存项目** 来保存项目是一个好习惯。
- en: Let's now continue with setting up our scene camera in the Unity Editor.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续在 Unity 编辑器中设置场景相机。
- en: Unity Editor Layout
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 编辑器布局
- en: For our side-scrolling shooter game *Killer Wave*, we need control over a camera
    to display the aspect ratio and visible depth of the scene, and to make sure we
    show the correct amount of our game's environment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的横向卷轴射击游戏 *Killer Wave*，我们需要控制相机来显示场景的宽高比和可见深度，并确保我们展示了正确数量的游戏环境。
- en: Let's get started and decide on the screen ratio of our game. We'll create our
    own resolution, which will be fairly common across most platforms.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并决定我们游戏的屏幕比例。我们将创建自己的分辨率，这在大多数平台上将是相当常见的。
- en: 'To change the **Game** window''s screen ratio to a custom aspect, do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 **Game** 窗口的屏幕比例更改为自定义比例，请执行以下操作：
- en: Click the current aspect ratio under the **Game** window tab and select the
    **+** symbol.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Game** 窗口选项卡下点击当前宽高比并选择 **+** 符号。
- en: Enter the custom aspect ratio values shown in the following screenshot.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下截图所示的自定义宽高比值。
- en: 'Click `1080` resolution we have just made:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们刚刚创建的 `1080` 分辨率：
- en: '![Figure 2.18 – Setting a custom Game window resolution'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.18 – 设置自定义游戏窗口分辨率'
- en: '](img/Figure_2.18_B18381.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.18_B18381.jpg)'
- en: Figure 2.17 – Setting a custom Game window resolution
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 设置自定义游戏窗口分辨率
- en: It is good to be aware of the need to make our game's artwork support (or to
    give it the scope to extend to) as many screen ratios as possible, especially
    if we ever wanted to make a game for portable devices such as tablets or mobile
    phones. This is because nearly every major brand of phone and tablet comes in
    different ratio sizes, and we don't want to start squashing and squeezing our
    content, as it won't look right. It's also possible that our small mobile games
    will become successful and could later be ported to a console or PC. If that's
    the case, we need to make the game screen support these ratios too. The main point
    to take from all of this is that we are targeting our game to cover all possible
    common screen ratios. The more platforms (consoles, portable devices, and so on)
    we can cover with flexible screen ratios, the easier it will be to extend our
    game out to those devices without requiring extra work. We explain more about
    screen size ratios in [*Chapter 8*](B18381_08_Epub.xhtml#_idTextAnchor150), *Adding
    Custom Fonts and UI*, and [*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161),
    *Creating a 2D Shop Interface and In-Game HUD*, where we discuss UI display settings.
    Additionally, in [*Chapter 13*](B18381_13_Epub.xhtml#_idTextAnchor219), *Effects,
    Testing, Performance, and Alt Controls*, we will explain how to display our game
    screen on a raw image component.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们需要使我们的游戏艺术作品支持尽可能多的屏幕比例（或者给它扩展到）的需求是很好的，尤其是如果我们想为平板电脑或手机等便携式设备制作游戏的话。这是因为几乎每个主要品牌的手机和平板电脑都有不同的比例尺寸，我们不希望开始挤压和压缩我们的内容，因为它看起来不会正确。也有可能我们的小型移动游戏会取得成功，并且以后可以被移植到游戏机或PC上。如果是这样的话，我们需要让游戏屏幕也支持这些比例。从所有这些中我们可以得出的主要观点是我们正在针对我们的游戏覆盖所有可能的常见屏幕比例。我们可以覆盖的平台（游戏机、便携式设备等）越多，灵活的屏幕比例，就越容易将我们的游戏扩展到那些设备上，而无需额外的工作。我们在[*第
    8 章*](B18381_08_Epub.xhtml#_idTextAnchor150)，“添加自定义字体和UI”，和[*第 9 章*](B18381_09_Epub.xhtml#_idTextAnchor161)，“创建
    2D 商店界面和游戏内 HUD”，中解释了更多关于屏幕尺寸比例的内容，其中我们讨论了UI显示设置。此外，在[*第 13 章*](B18381_13_Epub.xhtml#_idTextAnchor219)，“效果、测试、性能和替代控制”，中我们将解释如何在一个原始图像组件上显示我们的游戏屏幕。
- en: 'Before we continue any further with our project, it''s probably a good time
    to confirm our understanding of Unity''s own UI layout. The following screenshot
    shows the Unity Editor, where I have outlined and labeled the relevant windows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续我们的项目之前，确认我们对 Unity 自身 UI 布局的了解可能是一个好时机。以下截图显示了 Unity 编辑器，我在其中勾勒并标注了相关的窗口：
- en: '![Figure 2.19 – The Unity editor window layout'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.19 – Unity 编辑器窗口布局'
- en: '](img/Figure_2.19_B18381.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.19_B18381.jpg)'
- en: Figure 2.18 – The Unity Editor window layout
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – Unity 编辑器窗口布局
- en: 'Typically, the Unity Editor window is made up of five main windows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Unity 编辑器窗口由五个主要窗口组成：
- en: '**Scene**: This is our two-/three-dimensional workspace.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：这是我们二维/三维的工作空间。'
- en: '**Game**: This window is what the end user will see. By default, the **Game**
    tab shares the same space as the **Scene** window.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏**：这是最终用户将看到的窗口。默认情况下，**游戏**选项卡与**场景**窗口共享相同的空间。'
- en: '**Hierarchy**: All game objects in our scene will be listed here.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：我们场景中的所有游戏对象都将列在这里。'
- en: '**Inspector**: When an object is selected, information about it will be displayed
    here.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查器**：当选择一个对象时，其信息将在这里显示。'
- en: '**Project**: This is our Unity project folder. Consider it a structure of files
    and folders that we can use in our game.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目**：这是我们Unity项目文件夹。将其视为我们可以用于游戏的文件和文件夹的结构。'
- en: Tip
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: To drag each window around individually, left-click and drag the name of the
    tab, and it will then snap into different locations.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要单独拖动每个窗口，左键点击并拖动标签名称，然后它会自动定位到不同的位置。
- en: My **Game** window is set to **1080**, and because I don't have the luxury of
    a second screen, I've clicked its name tab (**Game**) and pulled it down in the
    bottom-right corner. The window is small, but as you can see at the top of the
    **Game** window, the scale is set to 1x, which means I have a full picture; nothing
    is hidden or cut out of view.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我的**游戏**窗口设置为**1080**，因为我没有第二个屏幕的奢侈，所以我点击了它的名称标签（**游戏**）并将其拉到右下角。窗口很小，但正如您在**游戏**窗口顶部所看到的，缩放设置为1x，这意味着我有一个完整的画面；没有任何东西被隐藏或从视野中裁剪掉。
- en: 'To check that we have the main camera''s `0`. We can also reset the **Transform**
    option as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否具有主摄像机的`0`。我们还可以按照以下方式重置**变换**选项：
- en: 'With the main camera selected in the **Hierarchy** window, click the three
    dots at the top-right corner of the **Transform** panel in the **Inspector** window,
    as shown in the following screenshot:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择主摄像机后，在**检查器**窗口中，点击**变换**面板右上角的三点，如图下截图所示：
- en: '![Figure 2.20 – The Transform settings cog location'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.20 – 变换设置齿轮位置'
- en: '](img/Figure_2.20_B18381.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.20_B18381.jpg)'
- en: Figure 2.19 – The Transform settings cog location
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 变换设置齿轮位置
- en: When the dropdown appears, click **Reset**.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当下拉菜单出现时，点击**重置**。
- en: 'Continuing with setting up our main camera, let''s get rid of the landscape
    background in our **Scene**/**Game** window by changing its **Background** setting:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 继续设置我们的主摄像机，让我们通过更改其**背景**设置来从**场景**/**游戏**窗口中移除景观背景：
- en: Click the **Main Camera** in the **Hierarchy** window.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中点击**主摄像机**。
- en: In the **Inspector** window, we have the **Camera** component with a property
    called **Clear Flags**. Click the **Skybox** value.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，我们有**摄像机**组件，其属性名为**清除标志**。点击**天空盒**值。
- en: 'A dropdown will appear. Click **Solid Color**, as shown in the following screenshot:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉菜单。点击**纯色**，如图下截图所示：
- en: '![Figure 2.21 – Changing Background to a Solid Color'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.21 – 将背景更改为纯色'
- en: '](img/Figure_2.21_B18381.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.21_B18381.jpg)'
- en: Figure 2.20 – Changing Background to a Solid Color
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 将背景更改为纯色
- en: We will now be presented with a blue background, which is less distracting.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将看到一个蓝色背景，这会减少干扰。
- en: 'If you don''t like blue, you can change it to any color in the `0`, `0`, `0`,
    and `255`, as shown in the following screenshot:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不喜欢蓝色，您可以将它更改为`0`，`0`，`0`和`255`中的任何颜色，如图下截图所示：
- en: '![Figure 2.22 – Setting Background color values'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.22 – 设置背景颜色值'
- en: '](img/Figure_2.22_B18381.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.22_B18381.jpg)'
- en: Figure 2.21 – Setting Background color values
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 设置背景颜色值
- en: Great, now let's move on to coding these properties for our main camera.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在让我们继续为主摄像机编写这些属性。
- en: Updating our camera properties via a script
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过脚本更新摄像机属性
- en: We now have our main camera's behavior set in our **Scene**. Next, we need to
    code this into a script so that whenever a scene is loaded, Unity will read the
    script and understand how the main camera should be set up.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在我们的**场景**中设置了主摄像机的行为。接下来，我们需要将这段代码编写到一个脚本中，这样每当场景被加载时，Unity都会读取脚本并理解主摄像机应该如何设置。
- en: 'Observing our framework again, let''s see where the camera script should be
    placed:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 再次观察我们的框架，让我们看看摄像机脚本应该放置在哪里：
- en: '![Figure 2.23 – Killer Wave UML'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.23 – 杀手波 UML'
- en: '](img/Figure_2.23_B18381.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.23_B18381.jpg)'
- en: Figure 2.22 – Killer Wave UML
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 杀手波 UML
- en: As you can see in the diagram, there is no reference to the camera, so should
    we make a script to support this? Arguably, the only reason to make a script based
    on the camera would be if the camera had a complex purpose filled with multiple
    properties and functions. The camera in our game, however, is put in place when
    the game starts. Later on, on the third level, the camera will move from left
    to right with a simple component script, but it doesn't hold any other complexity.
    It would, therefore, be more ideal to use the `GameManager`, as it only takes
    up a small role. If the game became bigger and the camera took on more of a role,
    then this might justify the camera having a class of its own. Others might disagree
    based on personal preference, but this is the approach we'll take.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图中所见，图中没有提及相机，那么我们应该编写一个脚本来支持这一点吗？可以说，基于相机编写脚本的唯一原因可能是如果相机具有复杂的目的，并且包含多个属性和功能。然而，在我们的游戏中，相机是在游戏开始时放置的。稍后，在第三级，相机将使用简单的组件脚本从左向右移动，但它不包含任何其他复杂性。因此，使用`GameManager`会更理想，因为它只扮演着一个小角色。如果游戏变得更大，相机承担了更多角色，那么这可能就为相机拥有自己的类提供了理由。其他人可能会根据个人喜好提出不同意见，但我们将采取这种方法。
- en: 'Let''s make the `GameManager` script, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`GameManager`脚本，如下所示：
- en: 'Create a script in the same way that we created a folder. Right-click the open
    space area in the **Project** window, and a dropdown will appear. Click **Create
    | C# Script**, as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以创建文件夹的方式创建脚本。在**项目**窗口的空白区域右键单击，将出现一个下拉菜单。点击**创建 | C# 脚本**，如下所示：
- en: '![Figure 2.24 – Creating a C# script in the Unity editor'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24 – 在Unity编辑器中创建C#脚本'
- en: '](img/Figure_2.24_B18381.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.24_B18381.jpg)'
- en: Figure 2.23– Creating a C# script in the Unity Editor
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23– 在Unity编辑器中创建C#脚本
- en: The script appears with the title `NewBehaviourScript`. We don't want to call
    it that, so type (in camel case) `GameManager`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本以标题`NewBehaviourScript`出现。我们不想这样称呼它，所以（以驼峰命名法）输入`GameManager`。
- en: What's camel casing?
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 什么是驼峰命名法？
- en: Camel casing is a way to avoid spacing between words. This is fairly common
    with programming, as spaces are typically not welcomed for various reasons. Each
    new word starts with a capital letter, so in this case, the M in `GameManager`
    is the hump of the camel. However, variables typically start with lowercase, as
    you will see shortly.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 驼峰命名法是一种避免单词之间空格的方法。这在编程中相当常见，因为出于各种原因，通常不欢迎空格。每个新单词都以大写字母开头，所以在这种情况下，`GameManager`中的M就是驼峰的顶部。然而，变量通常以小写字母开头，您很快就会看到。
- en: 'We now have our `GameManager` script. Notice how Unity is trying to be helpful
    by changing the icon to a silver cog because what we are doing is a recognized
    method with Unity:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们的`GameManager`脚本。注意Unity如何试图提供帮助，将图标更改为银色齿轮，因为我们正在执行的是Unity中认可的方法：
- en: '![Figure 2.25 – The GameManager icon'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.25 – GameManager图标'
- en: '](img/Figure_2.25_B18381.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.25_B18381.jpg)'
- en: Figure 2.24 – The GameManager icon
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 – GameManager图标
- en: As we did when placing our three-dimensional models into the `GameManager` into
    the `Script` folder.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将三维模型放入`GameManager`的`Script`文件夹中时做的那样。
- en: Good. Now, before we open our script to code in it, we need to attach it to
    a game object in our scene so that when the scene runs, the script attached to
    the game object also runs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在，在我们打开脚本进行编码之前，我们需要将其附加到场景中的游戏对象上，这样当场景运行时，附加到游戏对象上的脚本也会运行。
- en: 'To create our `GameManager` game object, we need to do the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的`GameManager`游戏对象，我们需要执行以下操作：
- en: Right-click in an open space in the **Hierarchy** window.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口的空白区域右键单击。
- en: From the drop-down menu, select **Create Empty**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**创建空对象**。
- en: Right-click the newly created game object and select **Rename** from the drop-down
    menu.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的游戏对象，从下拉菜单中选择**重命名**。
- en: Rename this game object `GameManager`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此游戏对象重命名为`GameManager`。
- en: Finally, with the `GameManager` game object still selected, click the **Add
    Component** button in the far-right **Inspector** window.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，仍然选择`GameManager`游戏对象，点击最右侧的**检查器**窗口中的**添加组件**按钮。
- en: Type `GameManager` from the drop-down menu until you see the `GameManager` script
    and select it.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中输入`GameManager`，直到您看到`GameManager`脚本并选择它。
- en: Tip
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever we make an empty game object, we must be sure that all of its **Transform**
    property values are reset to their default values unless we are specifically changing
    them.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次我们创建一个空的游戏对象时，我们必须确保将其所有**变换**属性值重置为默认值，除非我们明确更改它们。
- en: To reset a game object's **Transform** value, make sure that the game object
    we are resetting is selected. Click the metal cog at the top-right corner of the
    **Inspector** window, and then select **Reset**.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要重置游戏对象的**Transform**值，请确保我们正在重置的游戏对象已被选中。点击**Inspector**窗口右上角的金属齿轮，然后选择**Reset**。
- en: 'Double-click the `GameManager` script to open it up in your IDE (Visual Studio
    or whatever IDE you use), and then proceed as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 双击`GameManager`脚本以在您的IDE（Visual Studio或您使用的任何IDE）中打开它，然后按照以下步骤操作：
- en: 'Inside the `GameManager` script, we will be faced with the `UnityEngine` library
    being imported into our script to add extra functionality to Unity''s own components:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameManager`脚本内部，我们将面临将`UnityEngine`库导入我们的脚本以向Unity自身组件添加额外功能的情况：
- en: '[PRE0]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also in the preceding code, we have the name of our script along with `MonoBehaviour`
    being inherited yet again to add more functionality to our script. `MonoBehaviour`
    is also required if the game object that attaches to this script needs to be used
    in the Unity Editor.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还有我们脚本的名称以及`MonoBehaviour`被继承，以向我们的脚本添加更多功能。`MonoBehaviour`也是必需的，如果附加到该脚本的游戏对象需要在Unity编辑器中使用。
- en: Let's start adding some of our own code into our `GameManager` script.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的`GameManager`脚本中添加一些自己的代码。
- en: 'Create an empty method, `CameraSetup`, and then run this method in the `Start`
    function:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的方法，`CameraSetup`，然后在`Start`函数中运行此方法：
- en: '[PRE1]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `CameraSetup` method, add a reference to the camera and set the
    position and angle of the camera to zero apart from its *z* axis. We''ll set `Z`
    to `-300`, which will move the camera back and ensure all game objects are in
    the shot:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CameraSetup`方法内部，添加对相机的引用，并将相机的位置和角度设置为除其*z*轴外的零。我们将`Z`设置为`-300`，这将使相机后退，并确保所有游戏对象都在镜头中：
- en: '[PRE2]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will change the properties of the camera within our `CameraSetup`
    method:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`CameraSetup`方法中更改相机属性：
- en: '[PRE3]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This does the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行以下操作：
- en: Removes the sky background and replaces it with a solid color
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除天空背景，并用实色替换
- en: Changes the solid color from the default blue to black
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实色从默认的蓝色更改为黑色
- en: Finally, save the script.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存脚本。
- en: 'Now, you should have something like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有类似以下的内容：
- en: '![Figure 2.26 – The current code layout for the GameManager script'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.26 – The current code layout for the GameManager script'
- en: '](img/Figure_2.26_B18381.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.26_B18381.jpg)'
- en: Figure 2.25– The current code layout for the GameManager script
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25– GameManager脚本的当前代码布局
- en: Tip
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you would like to change other settings relating to the camera, you can find
    out about them at [https://docs.unity3d.com/ScriptReference/Camera.html](https://docs.unity3d.com/ScriptReference/Camera.html).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更改与相机相关的其他设置，您可以在[https://docs.unity3d.com/ScriptReference/Camera.html](https://docs.unity3d.com/ScriptReference/Camera.html)了解更多信息。
- en: 'Press the **Play** button in the upper middle of the editor window, or by using
    the shortcut *Ctrl* + *P* (*Command* + *P* on the Mac). The following screenshot
    shows where the **Play** button is located:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器窗口的右上中部按下**Play**按钮，或使用快捷键*Ctrl* + *P*（在Mac上为*Command* + *P*）。以下截图显示了**Play**按钮的位置：
- en: '![](img/Figure_2.27_B18381.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.27_B18381.jpg)'
- en: Figure 2.26 – The Play, Pause, and Step button locations
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 – 播放、暂停和步骤按钮的位置
- en: 'With the scene in play mode, we can now check out the **Main Camera** game
    object''s properties by doing the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景处于播放模式时，我们可以通过以下方式检查**Main Camera**游戏对象的属性：
- en: In the **Hierarchy** window, select **Main Camera**.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中，选择**Main Camera**。
- en: Observe the **Inspector** window in the next screenshot to see the following
    changes our script has made.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 观察下一张截图中的**Inspector**窗口，以查看我们的脚本所做的以下更改。
- en: In the **Transform** component of the **Inspector** window, we can see that
    the **Position** and **Rotation** properties are set to the same values set in
    our script (denoted by **1** in the following screenshot).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口的**Transform**组件中，我们可以看到**Position**和**Rotation**属性被设置为与我们在脚本中设置相同的值（以下截图中的**1**所示）。
- en: In the **Camera** component of the **Inspector** window, we can see that the
    **Clear Flags** and **Background** values are also set to the same values set
    in our script (denoted by **2i** and **2ii**).
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口的**Camera**组件中，我们可以看到**Clear Flags**和**Background**值也被设置为与我们在脚本中设置的相同值（以下截图中的**2i**和**2ii**所示）。
- en: 'The following screenshot shows the **Main Camera** component properties being
    updated in Play mode:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在播放模式下**Main Camera**组件属性更新的情况：
- en: '![Figure 2.28 – Main Camera values changing with our script'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.28 – Main Camera values changing with our script'
- en: '](img/Figure_2.28_B18381.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.28_B18381.jpg)'
- en: Figure 2.27 – Main Camera values changing with our script
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 – 主相机值随着我们的脚本变化
- en: Now, hopefully, our properties should be the same as what we have scripted (with
    no errors). If not, you will likely have an error message in the **Console** window.
    If there is an error, it will likely tell you what line the error is on. You can
    also double-click the error, and it will take you to the line the error is on.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，希望我们的属性应该与我们所编写的脚本相同（没有错误）。如果不是，你可能会在**控制台**窗口中看到一个错误消息。如果有错误，它可能会告诉你错误所在的行。你还可以双击错误，它会带你到错误所在的行。
- en: To double-check everything has worked, change the **Position** and **Rotation**
    of the camera in the editor, and then press the **Play** button. The properties
    for the camera should now be set to our script's **Position** and **Rotation**
    properties.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切正常，请在编辑器中更改相机的**位置**和**旋转**，然后按**播放**按钮。相机的属性现在应该设置为脚本中的**位置**和**旋转**属性。
- en: 'At this point, while the editor is still playing, we can also make a prefab
    of the camera:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当编辑器仍在播放时，我们还可以创建一个相机的预制体：
- en: 'Click and drag the **Camera** from the **Hierarchy** window down into the **Project**
    window, and we will generate a blue cube with the camera''s name or an empty icon.
    Depending on the scale of our icons, the size of the icon can be altered by moving
    the slider shown in the following screenshot:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动**相机**从**层次结构**窗口到**项目**窗口，我们将生成一个带有相机名称或空图标蓝色的立方体。根据我们图标的尺寸，可以通过以下截图所示的滑块来调整图标的大小：
- en: '![Figure 2.29 – The slider in the bottom right of the Project window zooms
    in and out of thumbnails'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.29_B18381.jpg)'
- en: '](img/Figure_2.29_B18381.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.29_B18381.jpg)'
- en: Figure 2.28 – The slider in the bottom right of the Project window zooms in
    and out of thumbnails
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 – 项目窗口右下角的滑块可以放大和缩小缩略图
- en: Move this camera prefab into the `Prefab` folder.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个相机预制体移动到`Prefab`文件夹。
- en: 'You might be thinking, *why didn''t we just make a prefab of the camera in
    the first place instead of fiddling with its property settings in code?* However,
    two key things are important here: firstly, we are studying for an exam that is
    likely to cover such properties; and secondly, you now know how to change these
    settings dynamically through code.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，*为什么我们一开始不直接创建一个相机的预制体，而不是在代码中调整其属性设置呢？*然而，这里有两个关键点很重要：首先，我们正在为可能涵盖此类属性的考试做准备；其次，你现在知道如何通过代码动态更改这些设置。
- en: Tip
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Another benefit to scripting Unity's components is that we can sometimes be
    offered more functionality than what is displayed in the Editor. For example,
    the `Camera` component has a `layerCullDistances` property that is only accessible
    via scripting. This can offer functionality such as skipping the rendering of
    smaller game objects in the far distance to increase a game's performance.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity组件进行脚本编写的好处是，我们有时可以获得比编辑器中显示的更多功能。例如，`Camera`组件有一个`layerCullDistances`属性，只能通过脚本访问。这可以提供诸如跳过渲染远距离较小游戏对象以增加游戏性能等功能。
- en: To read more about `layerCullDistances`, check the documentation at [https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html](https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`layerCullDistances`的信息，请查看[https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html](https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html)的文档。
- en: 'This brings this section to a close. So far, we have covered the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束。到目前为止，我们已经涵盖了以下内容：
- en: Setting up a ratio for our game camera
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置游戏相机的比例
- en: Setting up our Unity Editor with individual windows
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的Unity编辑器中的单独窗口
- en: Changing the properties of our **Camera** component in the Unity Editor
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中更改我们的**相机**组件属性
- en: Repeating the changes we made to our camera in the `GameManager` script
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复我们在`GameManager`脚本中对相机所做的更改
- en: Adding our `GameManager` script to our scene as a game object
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的`GameManager`脚本作为游戏对象添加到场景中
- en: As a programmer, the importance of being able to understand and change the settings
    in the Unity Editor (but also being able to do the same in code) can be expanded
    to other components that are in the editor. This is what we will do next, with
    a focus on directional light.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，能够理解和更改Unity编辑器中的设置（同时也能在代码中做到这一点）的重要性可以扩展到编辑器中的其他组件。这就是我们接下来要做的，重点关注方向光。
- en: Setting up our light
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的灯光
- en: As a default setup, each scene comes with a directional light, and currently,
    this is all we need to get going; ideally, we want the scene to be well lit.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认设置，每个场景都附带一个方向光，目前这是我们开始所需的所有；理想情况下，我们希望场景得到良好的照明。
- en: With the directional light already present in the scene as the default light,
    select it in the `50`, `-30`, and `0`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中已经存在作为默认灯光的方向光，在 `50`，`-30` 和 `0` 中选择它。
- en: 'When we put our player ship into the scene, this will light it up well, as
    shown in the following screenshot:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将玩家飞船放入场景中时，这将很好地照亮它，如下面的截图所示：
- en: '![Figure 2.30 – The player ship lit up'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.30 – 照亮的玩家飞船'
- en: '](img/Figure_2.30_B18381.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.30_B18381.jpg]'
- en: Figure 2.29 – The player ship lit up
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – 照亮的玩家飞船
- en: Different Lights
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的灯光
- en: Unity provides three different types of real-time lights. As well as the **directional**
    light we mentioned, it also provides a **point** light, which is like a 360° glow
    that we will cover in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087), *Applying
    Art, Animation, and Particles*. The third type of light is a spotlight or, as
    Unity refers to it, a **spot**. The **spot** can also have masks applied, so it
    can project images known as cookies.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了三种不同类型的实时灯光。除了我们提到的 **方向** 光之外，它还提供了一个 **点** 光，这是一种 360° 的发光，我们将在 [*第
    4 章*](B18381_04_Epub.xhtml#_idTextAnchor087) *应用艺术、动画和粒子* 中介绍。第三种灯光类型是聚光灯，或如 Unity
    所称的 **spot**。**spot** 也可以应用遮罩，因此它可以投射称为 cookies 的图像。
- en: For more information about the three types of lights, check out [https://docs.unity3d.com/Manual/Lighting.html](https://docs.unity3d.com/Manual/Lighting.html).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于三种灯光类型的信息，请查看 [https://docs.unity3d.com/Manual/Lighting.html](https://docs.unity3d.com/Manual/Lighting.html)。
- en: We can now make sure these settings stay in place by adding them to the `GameManager`
    script. We can also alter the light's color.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过将它们添加到 `GameManager` 脚本来确保这些设置保持不变。我们还可以更改灯光的颜色。
- en: Updating our light properties via a script
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过脚本更新我们的灯光属性
- en: 'In the `GameManager`, we will set the **Transform** **Rotation** values and
    change the color tint from a light yellow to a cold blue:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameManager` 中，我们将设置 **Transform** **Rotation** 值，并将颜色色调从浅黄色更改为冷蓝色：
- en: 'Open the `GameManager` script and enter the following method:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameManager` 脚本并输入以下方法：
- en: '[PRE4]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add `LightSetup();` in the scope of the `Start` function.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Start` 函数的作用域内添加 `LightSetup();`。
- en: Save the script.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'The `LightSetup` method does three things:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightSetup` 方法做了三件事：'
- en: It grabs the light from the scene and stores it as a reference.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从场景中获取灯光并将其存储为引用。
- en: It sets the rotation of the light with `EulerAngles`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `EulerAngles` 设置灯光的旋转。
- en: Finally, it changes the light's color.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它改变了灯光的颜色。
- en: EulerAngles
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: EulerAngles
- en: '`eulerAngles` allows us to give `Vector3` coordinates instead of `Quaternion`
    values. `eulerAngles` makes rotations less complicated to work with. More information
    about `eulerAngles` can be found at [https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html](https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html).'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`eulerAngles` 允许我们给出 `Vector3` 坐标而不是 `Quaternion` 值。`eulerAngles` 使得旋转操作更加简单。有关
    `eulerAngles` 的更多信息，请参阅 [https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html](https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html)。'
- en: That's all we need to do with our light. As with the camera, we can access the
    light and change its properties via a script.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的关于灯光的所有操作。与相机一样，我们可以通过脚本访问灯光并更改其属性。
- en: We have become familiar with our light by changing its settings in the Unity
    Editor and the `GameManager` script. Next, we will set up our interface for the
    majority of our game objects.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 Unity 编辑器和 `GameManager` 脚本中更改其设置已经熟悉了我们的灯光。接下来，我们将为大多数游戏对象设置我们的接口。
- en: Introducing our interface – IActorTemplate
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的界面 – IActorTemplate
- en: The `IActorTemplate` interface is what we are using to prompt damage control,
    death, and scriptable object assets. The reason for using an interface such as
    this is that it ties general uses together between classes that inherit it.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`IActorTemplate` 接口是我们用来提示伤害控制、死亡和可脚本化对象资产的。使用此类接口的原因是它将继承它的类之间的通用用途联系起来。'
- en: 'A total of six classes will be using the `IActorTemplate` interface, which
    is as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有六个类将使用 `IActorTemplate` 接口，如下所示：
- en: '`Player`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`'
- en: '`PlayerBullet`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerBullet`'
- en: '`PlayerSpawner`'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerSpawner`'
- en: '`Enemy`'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enemy`'
- en: '`EnemyBullet`'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemyBullet`'
- en: '`EnemySpawner`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemySpawner`'
- en: 'The following diagram shows the `IActorTemplate` interface with a partial overview
    of our game framework:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 `IActorTemplate` 接口以及我们游戏框架的部分概述：
- en: '![Figure 2.31 – IActorTemplate UML'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.31 – IActorTemplate UML'
- en: '](img/Figure_2.31_B18381.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.31_B18381.jpg)'
- en: Figure 2.30 – IActorTemplate UML
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30 – IActorTemplate UML
- en: 'Let''s create our interface and explain its content along the way:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的接口并在过程中解释其内容：
- en: Create a script in the `Assets/Scripts` folder with the filename `IActorTemplate`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中创建一个名为`IActorTemplate`的脚本。
- en: 'Open the script and enter the following code:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并输入以下代码：
- en: '[PRE5]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure to save the script.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保保存脚本。
- en: The code we just entered looks like we have declared a class, but it acts fundamentally
    differently. Instead of using the `class` keyword, we enter `interface` followed
    by the name of the interface, `IActorTemplate`. It's not a requirement to start
    any interface name with an `I`, but it makes the script easily identifiable.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚输入的代码看起来像我们声明了一个类，但它的行为本质上不同。我们不是使用`class`关键字，而是输入`interface`后跟接口名称`IActorTemplate`。虽然不是必须以`I`开头命名任何接口，但这使得脚本易于识别。
- en: Within the `interface`, we make a list of methods that act like contracts to
    whichever class implements them. For example, the `Player` script that we'll create
    later on in the chapter inherits the `IActorTemplate` interface. The `Player`
    script must declare the function names from `IActorTemplate` or the `Player` script
    will throw an error.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在`interface`中，我们创建了一个方法列表，这些方法就像是对实现它们的任何类的合同。例如，我们将在本章后面创建的`Player`脚本继承自`IActorTemplate`接口。`Player`脚本必须声明来自`IActorTemplate`的函数名，否则`Player`脚本将抛出错误。
- en: Inside the scope of the `interface`, we declare methods without accessors (it
    doesn't require `private` or `public` at the beginning of each method). Methods
    also don't require any content in them (that is, they are empty bodies).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在`interface`的作用域内，我们声明方法而不需要访问器（这意味着每个方法的开头不需要`private`或`public`）。方法也不需要任何内容（也就是说，它们是空的）。
- en: For more information about interfaces, check out [https://learn.unity.com/tutorial/interfaces](https://learn.unity.com/tutorial/interfaces).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于接口的信息，请参阅[https://learn.unity.com/tutorial/interfaces](https://learn.unity.com/tutorial/interfaces)。
- en: The last method in our `interface` is `ActorStats`, which takes a `SOActorModel`
    type. `SOActorModel` is a scriptable object that we are going to explain and create
    in the next section.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`interface`中的最后一个方法是`ActorStats`，它接受一个`SOActorModel`类型。`SOActorModel`是一个可脚本化的对象，我们将在下一节中解释和创建。
- en: Introducing our ScriptableObject – SOActorModel
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的可脚本化对象 – SOActorModel
- en: In this section, we are going to cover scriptable objects and their benefits.
    Similar to our `interface`, scriptable objects cover the same six classes. The
    reason for this is that our `interface` uses the `SOActorModel` and, therefore,
    creates an attachment with the other variables.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍可脚本化对象及其优点。与我们的`interface`一样，可脚本化对象覆盖了相同的六个类。这样做的原因是，我们的`interface`使用了`SOActorModel`，因此与其他变量建立了关联。
- en: It is also good to remind ourselves of the **Game Design Document** (**GDD**)
    and how it is incorporated into the overview of the creation of our game.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 也要提醒自己**游戏设计文档**（**GDD**）以及它是如何融入我们游戏创建概述中的。
- en: 'Our game has three series of game objects that will hold similar properties:
    `EnemyWave`, `EnemyFlee`, and `Player`. These properties will include health,
    speed, score value, and more. The difference between each of these as described
    in the game design brief is the way they act and also how they are instantiated
    in our game.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏有三个系列的游戏对象，它们将具有相似属性：`EnemyWave`、`EnemyFlee`和`Player`。这些属性将包括健康、速度、得分值等。这些对象之间的区别，如游戏设计简报所述，在于它们的行为以及它们在我们游戏中的实例化方式。
- en: '`Player` will be instantiated at every level, `EnemyWave` will be spawned from
    `EnemySpawner`, and `EnemyFlee` will be placed in particular areas of the third
    level.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`将在每个级别实例化，`EnemyWave`将从`EnemySpawner`生成，而`EnemyFlee`将被放置在第三级的特定区域。'
- en: All of the aforementioned game objects will relate to the `SOActorModel` object.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有游戏对象都将与`SOActorModel`对象相关联。
- en: 'The following diagram is also a partial view of our game framework, showing
    the scriptable object and the six classes that inherit it:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表也是我们游戏框架的部分视图，显示了可脚本化对象及其继承的六个类：
- en: '![Figure 2.32 – SOActorModel UML'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.32 – SOActorModel UML'
- en: '](img/Figure_2.32_B18381.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.32_B18381.jpg)'
- en: Figure 2.31 – SOActorModel UML
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – SOActorModel UML
- en: Similar to what was mentioned with the `interface` script is that the name of
    the scriptable object name starts with `SO`, which isn't a standard way of naming
    the script, but it's easier to identify as a `ScriptableObject`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的 `interface` 脚本类似，脚本化对象的名字以 `SO` 开头，这并不是命名脚本的常规方式，但它更容易被识别为 `ScriptableObject`。
- en: The purpose of this scriptable object is to hold general values for each of
    the game objects it's being given to. For example, all game objects have a name,
    so within our `SOActorModel` is a `string` named `actorName`. This `actorName`
    will be used to name the type of enemy, spawner, or bullet it is.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本化对象的目的在于为每个分配给它的游戏对象保存通用值。例如，所有游戏对象都有一个名称，因此在我们的 `SOActorModel` 中有一个名为 `actorName`
    的 `string`。这个 `actorName` 将被用来命名敌人、生成器或子弹的类型。
- en: 'Let''s create a scriptable object, as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本化对象，如下所示：
- en: In the `Assets/Scripts` folder with the filename `SOActorModel`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中，文件名为 `SOActorModel`。
- en: 'Open the script and enter the following code:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并输入以下代码：
- en: '[PRE6]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the script.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Inside the `SOActorModel`, we will be naming most, if not all, of these variables
    in the `Player` script. Similar to how an `interface` signs a contract with a
    class, the `SOActorModel` does the same because it's being inherited, but isn't
    as strict as an `interface` by throwing an error if the content from the scriptable
    object isn't applied.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SOActorModel` 中，我们将命名 `Player` 脚本中的大多数，如果不是所有这些变量。类似于 `interface` 与类签订合同的方式，`SOActorModel`
    也做了同样的事情，因为它正在被继承，但它不像 `interface` 那样严格，如果脚本化对象的内容没有被应用，它会抛出一个错误。
- en: The following is an overview of the `SOActorModel` code we just entered.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚输入的 `SOActorModel` 代码的概述。
- en: We named our scriptable object `SOActorModel` as a generic term to try and cover
    as many game objects as will likely use the scriptable object. This way of working
    also supports the SOLID principles we covered in the first chapter by encouraging
    us to try and keep our code concise and efficient.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将可脚本化对象命名为 `SOActorModel`，作为一个通用术语，试图涵盖尽可能多的可能使用脚本化对象的游戏对象。这种工作方式也支持我们在第一章中提到的
    SOLID 原则，它鼓励我们尝试保持代码简洁高效。
- en: 'The main categories we''ll cover for this script are as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本脚本涵盖的主要类别如下：
- en: '`SOActorModel` script is `using UnityEngine`; no other libraries are required.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOActorModel` 脚本使用 `using UnityEngine`；不需要其他库。'
- en: '`CreateAssetMenu` attribute creates an extra selection from the drop-down list
    in the **Project** window in the Unity Editor when we right-click and select **Create**,
    as shown in the following screenshot:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateAssetMenu` 属性在 Unity 编辑器中右键单击并选择 **创建** 时，在 **项目** 窗口的下拉列表中创建一个额外的选择，如下面的截图所示：'
- en: '![Figure 2.33 – Creating an Actor in the Unity editor'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.33 – 在 Unity 编辑器中创建 Actor]'
- en: '](img/Figure_2.33_B18381.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.33_B18381.jpg]'
- en: Figure 2.32 – Creating an Actor in the Unity Editor
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 – 在 Unity 编辑器中创建 Actor
- en: '`MonoBehaviour` but `ScriptableObject` instead, as it''s a requirement when
    it comes to creating an asset.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `MonoBehaviour` 而不是 `ScriptableObject`，因为这是创建资产时的一个要求。
- en: '**Variables**: Finally, these are the variables that will be sent to our selected
    classes.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：最后，这些是将被发送到我们选定类中的变量。'
- en: In the following sections, we are going to create assets from the scriptable
    object script to give our scripts different values.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将从脚本化对象脚本创建资产，以赋予我们的脚本不同的值。
- en: Creating a PlayerSpawner ScriptableObject asset
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 PlayerSpawner 脚本化对象资产
- en: With our `SOActorModel` `ScriptableObject` made, we can now create an asset
    that will act as a template that can be used not just by programmers but also
    by designers who want to tweak game properties/settings without needing to know
    how to code.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的 `SOActorModel` `ScriptableObject` 之后，我们现在可以创建一个资产，它将作为一个模板，不仅可供程序员使用，还可以供想要调整游戏属性/设置但不需要了解如何编码的设计师使用。
- en: 'To create an `Actor Model` asset, do the following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `Actor Model` 资产，请按照以下步骤操作：
- en: Back in the Unity Editor, in the **Project** window, right-click and choose
    **Create | Create Actor**.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中，回到 **项目** 窗口，右键单击并选择 **创建 | 创建 Actor**。
- en: Rename the newly created asset file in the `Player_Default` and store the file
    in the `Assets/Resources` folder.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产文件重命名为 `Player_Default` 并将其存储在 `Assets/Resources` 文件夹中。
- en: Click on the new asset, and in the **Inspector** window, you'll see the content
    of the asset.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新资产，在 **检查器** 窗口中，您将看到资产的内容。
- en: 'The following screenshot shows the `Actor Model` asset''s fields, where I have
    entered my own values:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `Actor Model` 资产的字段，其中我已输入自己的值：
- en: '![Figure 2.34 – Player values'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.34 – 玩家值'
- en: '](img/Figure_2.34_B18381.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.34 – 图2.34_B18381.jpg]'
- en: Figure 2.33 – Player values
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.33 – 玩家值
- en: 'Let''s break down each of the values that have been added to our newly created
    asset:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析添加到我们新创建的资产中的每个值：
- en: '`Player`).'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`）。'
- en: '**Ship Type**: Choose which category this game object belongs to.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**船型**：选择这个游戏对象属于哪个类别。'
- en: '**Description**: Designer/internal notes that don''t affect the game but can
    be helpful.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：设计师/内部备注，不影响游戏但可能有所帮助。'
- en: '**Health**: How many times the player can get hit before dying.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康值**：玩家在死亡之前可以承受多少次打击。'
- en: '**Speed**: The movement speed of the player.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：玩家的移动速度。'
- en: '**Hit Power**: Determines how much damage the player will cause if they collide
    with the enemy.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打击力**：确定玩家与敌人相撞时会造成多少伤害。'
- en: '`player_ship` prefab here (`Assets/Prefab/Player`'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player_ship`预制体在这里（`Assets/Prefab/Player`）'
- en: '`player_bullet` prefab here (`Assets/Prefab /Player/`).'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player_bullet`预制体在这里（`Assets/Prefab /Player/`）。'
- en: We will add this asset to our `PlayerSpawner` script once it's built later on
    in the chapter. Let's move on to the next scriptable object asset.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面构建此资产后将其添加到`PlayerSpawner`脚本中。让我们继续下一个可脚本对象资产。
- en: Creating an EnemySpawner ScriptableObject asset
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个`EnemySpawner` ScriptableObject资产
- en: In this section, we are going to make our enemy asset attach to `EnemySpawner`
    for later on in the chapter. For the sake of keeping our work fresh and complete,
    let's continue with that before moving on to the `EnemySpawner` script.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使我们的敌人资产附加到`EnemySpawner`，以便在章节的后面部分使用。为了保持我们的工作新鲜完整，让我们继续进行，然后再转到`EnemySpawner`脚本。
- en: 'To make an enemy asset, follow these instructions:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个敌人资产，请按照以下说明操作：
- en: Back in the Editor, in the **Project** window, right-click and choose **Create
    | Create Actor**.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在**项目**窗口中，右键单击并选择**创建 | 创建演员**。
- en: Rename the new file to refer to what it's being attached to (`BasicWave Enemy`)
    and store the file in the `Assets/ScriptableObject` location.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件重命名为它所附加的内容（`BasicWave Enemy`）并将文件存储在`Assets/ScriptableObject`位置。
- en: Click on the new script, and our **Inspector** window will show the content
    of our script.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新脚本，我们的**检查器**窗口将显示脚本的内容。
- en: 'The following screenshot shows what the `BasicWave Enemy` asset is going to
    look like once we''ve finished:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了完成后的`BasicWave Enemy`资产将看起来像什么：
- en: '![Figure 2.35 – The Basic Wave Enemy values'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.35 – 基本波敌人值'
- en: '](img/Figure_2.35_B18381.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.35 – 图2.35_B18381.jpg]'
- en: Figure 2.34 – The Basic Wave Enemy values
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34 – 基本波敌人值
- en: 'Let''s briefly go through each of the values for our enemy:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地过一下我们敌人的每个值：
- en: '`enemy_wave`.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enemy_wave`。'
- en: '`Wave`. This explains what type of enemy it is and how it attacks the player.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wave`。这解释了敌人的类型以及它是如何攻击玩家的。'
- en: '`Typically in groups`. As mentioned before, it''s more of a guideline than
    a rule to comment on anything.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通常在组中`。如前所述，这更多的是一个指南而不是规则，用于注释任何内容。'
- en: '`1`, which means it takes 1 hit to die.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`，这意味着它需要1次打击才能死亡。'
- en: '`-50`, because our enemy is moving from right to left, so we give it a minus
    figure.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-50`，因为我们的敌人是从右向左移动的，所以我们给它一个负数。'
- en: '`1`, which means that if this enemy collides with the player, it will cause
    1 hit point of damage.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`，这意味着如果这个敌人与玩家相撞，它将造成1点伤害。'
- en: '`enemy_wave` prefab here (`Assets/Prefab/Enemies`).'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enemy_wave`预制体在这里（`Assets/Prefab/Enemies`）。'
- en: '**Actors Bullets**: This enemy doesn''t fire bullets.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员子弹**：这个敌人不发射子弹。'
- en: Hopefully, you can see how useful scriptable objects are. Imagine continuing
    to develop this game with `50` enemies, where all we need to do is create an asset
    and customize it.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到可脚本对象有多有用。想象一下，如果我们继续开发这个游戏，有`50`个敌人，我们只需要创建一个资产并对其进行自定义。
- en: We are going to move on to the final scriptable object asset for this chapter
    in the next section.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节继续本章的最后一个可脚本对象资产。
- en: Creating a PlayerBullet ScriptableObject Asset
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PlayerBullet ScriptableObject资产
- en: In this section, we are going to create an asset for the player's bullet for
    when they fire. As with the last two sections, create an asset, name it `PlayerBullet`,
    and store it in the same folder as the other assets.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为玩家开火时创建一个玩家子弹的资产。与最后两个部分一样，创建一个资产，命名为`PlayerBullet`，并将其存储在其他资产相同的文件夹中。
- en: 'The following screenshot shows the final results for the `PlayerBullet` asset:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`PlayerBullet`资产的最后结果：
- en: '![Figure 2.36 – The Player Bullet values'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.36 – 玩家子弹值'
- en: '](img/Figure_2.36_B18381.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.36 – 图2.36_B18381.jpg]'
- en: Figure 2.35 – The Player Bullet values
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35 – 玩家子弹的值
- en: 'Let''s briefly go through each variable''s values:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地过一下每个变量的值：
- en: '`player_bullet`.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player_bullet`。'
- en: '**Ship Type**: Bullet.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**船型**：子弹。'
- en: '**Description**: It is optional to enter any details about the asset here.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：在此处输入有关资产的任何详细信息是可选的。'
- en: '`1`.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`。'
- en: '`700`.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`700`。'
- en: '`1` sends a hit point of 1.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`发送1点伤害值。'
- en: '`player_bullet` prefab here (`Assets/Prefab/Player`).'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player_bullet`预制体在这里（`Assets/Prefab/Player`）。'
- en: '**Actors Bullets**: **None (Game Object)**.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员子弹**：**无（游戏对象）**。'
- en: In a later chapter, when we build a shop for our game, we will be able to buy
    power-ups for our player's ship. One of the power-ups will be similar to the one
    that we just made, but the **Actor Name** will be different, and the **Hit Power**
    will have a higher number.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，当我们为游戏构建商店时，我们将能够为玩家的飞船购买增强功能。其中一个增强功能将与我们刚刚制作的类似，但**演员名称**将不同，**伤害力**将更高。
- en: Now, we can move on to the next section and create the player's scripts and
    attach these assets to them.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到下一部分，创建玩家的脚本并将这些资产附加到它们上。
- en: Setting up our Player, PlayerSpawner, and PlayerBullet scripts
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的Player、PlayerSpawner和PlayerBullet脚本
- en: 'In the following series of sections, we are going to create three of the scripts
    that will cover the following: spawning the player, the player''s controls, and
    the player''s bullet.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将创建三个脚本，这些脚本将涵盖以下内容：创建玩家、玩家的控制以及玩家的子弹。
- en: 'The scripts we will be creating and including are as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建并包含的脚本如下：
- en: '`PlayerSpawner`: Creates and calibrates the player'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerSpawner`：创建和校准玩家'
- en: '`Player`: Player controls and general functionality'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`：玩家控制和一般功能'
- en: '`PlayerBullet`: Bullet movement and general functionality'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerBullet`：子弹移动和一般功能'
- en: '`IActorTemplate`: A template of the expected rules assigned to a given object
    (already made)'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IActorTemplate`：分配给特定对象的预期规则模板（已创建）'
- en: '`SOActorModel`: A set of values that can be altered by non-programmers (already
    made)'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOActorModel`：一组可以被非程序员修改的值（已创建）'
- en: We will cover all of these scripts thoroughly and break down each of their purposes,
    as well as how they depend on and communicate with one another. We will start
    with the `PlayerSpawner`, which will create the player's ship and issue its values.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对所有这些脚本进行彻底的讲解，并分解它们各自的目的，以及它们如何相互依赖和通信。我们将从`PlayerSpawner`开始，它将创建玩家的飞船并分配其值。
- en: Setting up our PlayerSpawner script
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的PlayerSpawner脚本
- en: The purpose of the `PlayerSpawner` script is to be attached to a game object,
    resulting in the player appearing at its position in the game. The `PlayerSpawner`
    script will also set the player's values when it is created. For example, if our
    player had a particular speed value, or if they had received an upgrade from the
    shop, the `PlayerSpawner` script would grab these values and apply them to the
    `Player` script.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSpawner`脚本的目的是将它附加到一个游戏对象上，从而使玩家在游戏中的该位置出现。当`PlayerSpawner`脚本被创建时，它还将设置玩家的值。例如，如果我们的玩家有一个特定的速度值，或者如果他们在商店中获得了升级，`PlayerSpawner`脚本将获取这些值并将它们应用到`Player`脚本上。'
- en: 'The following diagram shows a partial view of the `PlayerSpawner` class in
    the game''s framework and its relationship with the other classes around it:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了游戏框架中`PlayerSpawner`类的部分视图及其与其他类的关联：
- en: '![Figure 2.37 – PlayerSpawner UML'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.37 – PlayerSpawner UML'
- en: '](img/Figure_2.37_B18381.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.37_B18381.jpg)'
- en: Figure 2.36 – PlayerSpawner UML
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.36 – PlayerSpawner UML
- en: 'As we can see, the `PlayerSpawner` script is connected to four other scripts:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`PlayerSpawner`脚本与四个其他脚本相连：
- en: '`Player`: `PlayerSpawner` is connected to `Player` because it creates the player.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`：`PlayerSpawner`与`Player`相连，因为它创建了玩家。'
- en: '`SOActorModel`: This is a `ScriptableObject` that gives the `PlayerSpawner`
    its values, which are then passed on to the `Player`.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOActorModel`：这是一个`ScriptableObject`，它为`PlayerSpawner`提供其值，这些值随后传递给`Player`。'
- en: '`IActorTemplate`: This is the `interface` that generalizes the script with
    other common functions.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IActorTemplate`：这是通用于其他常见功能的`interface`。'
- en: '`GameManager`: This will send and receive general game information from and
    to the `PlayerSpawner` script.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameManager`：这将从`PlayerSpawner`脚本发送和接收一般游戏信息。'
- en: Before we create our `PlayerSpawner` script, it would be good housekeeping to
    create an empty game object to store anything to do with our player, their bullets,
    and whatever else the player might create in our `testLevel` scene.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建`PlayerSpawner`脚本之前，创建一个空的游戏对象来存储与我们的玩家、他们的子弹以及玩家可能在`testLevel`场景中创建的其他任何东西有关的内容是很好的管理。
- en: 'Make and name the game object by following these steps:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建并命名游戏对象：
- en: Right-click the **Hierarchy** window in its open space.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击打开空间中的**层次结构**窗口。
- en: A drop-down list will appear. From the list, select **Create Empty**.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉列表。从列表中选择**创建空对象**。
- en: Name the game object `_Player`.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象命名为`_Player`。
- en: 'That''s all that we need to do. Now, let''s make a start with the `PlayerSpawner`
    script:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的全部。现在，让我们从`PlayerSpawner`脚本开始：
- en: In the `Assets/Scripts` folder with the filename `PlayerSpawner`.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中，文件名为`PlayerSpawner`。
- en: 'Open the script and make sure that we have the following library entered at
    the top of our script:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本，确保我们在脚本顶部输入以下库：
- en: '[PRE7]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We only require `using UnityEngine`, as it covers all of the objects we need
    in the script.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要`using UnityEngine`，因为它涵盖了脚本中需要的所有对象。
- en: 'Continue by making sure our class is labeled as follows:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续确保我们的类如下标记：
- en: '[PRE8]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is common in Unity to inherit `MonoBehaviour` to give the script more functionality
    within Unity. Its common purpose is so the script can be attached to a game object.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，继承`MonoBehaviour`是常见的，以便在Unity中为脚本提供更多功能。它的常见目的是让脚本可以附加到游戏对象上。
- en: 'Continue by entering the script''s variables:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续输入脚本的变量：
- en: '[PRE9]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside the `PlayerSpawner` class, we add two global variables: the first variable
    is the `actorModel`, which holds a scriptable object asset that will contain values
    for the player ship, and the second variable will hold our player ship once it''s
    been created from our `CreatePlayer` method.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerSpawner`类内部，我们添加两个全局变量：第一个变量是`actorModel`，它包含一个可脚本化对象资产，该资产将包含玩家飞船的值，第二个变量将持有从我们的`CreatePlayer`方法创建的玩家飞船。
- en: 'Continue by entering the script''s `Start` function:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过输入脚本的`Start`函数：
- en: '[PRE10]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the global variables, we add a `Start` function that will run automatically
    as soon as the game object holding the `PlayerSpawner` script is active at runtime.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局变量之后，我们添加一个`Start`函数，该函数将在运行时`PlayerSpawner`脚本所持有的游戏对象激活时自动运行。
- en: Inside the scope of the `Start` function is a method that we are going to create
    called `CreatePlayer`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`函数的作用域内，有一个我们将要创建的方法，称为`CreatePlayer`。
- en: 'Continue by entering the `CreatePlayer` method:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过输入`CreatePlayer`方法：
- en: '[PRE11]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I have split the `CreatePlayer` method into two commented-out parts (`//CREATE
    PLAYER` and `//SET PLAYER UP`) due to its size.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`CreatePlayer`方法分为两个注释部分（`//CREATE PLAYER`和`//SET PLAYER UP`），因为其大小。
- en: This first part of the `CreatePlayer` method will `instantiate` the player ship's
    `ScriptableObject` asset and store it in the `actorModel` variable. We then `instantiate`
    a game object that refers to our `ScriptableObject` that holds the game object
    called `actor` in our game object variable named `playerShip`. Finally, we apply
    our `ScriptableObject` asset to the `playerShip` method called `ActorStats` that
    exists in the `Player` component script (which we will create later on in this
    chapter).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreatePlayer`方法的第一部分将`实例化`玩家飞船的`ScriptableObject`资产，并将其存储在`actorModel`变量中。然后，我们`实例化`一个游戏对象，该对象引用我们的`ScriptableObject`，其中包含名为`actor`的游戏对象，位于名为`playerShip`的游戏对象变量中。最后，我们将我们的`ScriptableObject`资产应用到`Player`组件脚本中的`ActorStats`方法（我们将在本章后面创建）。'
- en: 'Continue on inside the `CreatePlayer` method to add the second half:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在`CreatePlayer`方法中添加第二部分：
- en: '[PRE12]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the second half of the `CreatePlayer` method, we add more code at the same
    point where we have commented `//SET PLAYER UP`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CreatePlayer`方法的第二部分，我们在注释`//SET PLAYER UP`的位置添加了更多代码。
- en: The code from `//SET PLAYER UP` onward is dedicated to setting up the player's
    ship in the correct position at the start of the level.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 从`//SET PLAYER UP`开始的代码专门用于在关卡开始时将玩家的飞船设置在正确的位置。
- en: 'The code does the following:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行以下操作：
- en: Sets the rotation of the player's ship to face the right way.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置玩家飞船的旋转方向。
- en: Sets the scale of the player ship to `60` on all axes.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家飞船的缩放设置为所有轴上的`60`。
- en: When we `instantiate` any game object, Unity will add `(Clone)` to the end of
    the game object's name. We can rename it `Player`.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们`实例化`任何游戏对象时，Unity会在游戏对象名称的末尾添加`(Clone)`。我们可以将其重命名为`Player`。
- en: We make the `playerShip` game object a child of the `_Player` game object in
    the **Hierarchy** window so that we can easily find it.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在**层次结构**窗口中，将`playerShip`游戏对象设置为`_Player`游戏对象的孩子，这样我们就可以轻松找到它。
- en: Finally, we reset the player ship's position.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们重置玩家飞船的位置。
- en: That is our `PlayerSpawner` script coded. Now, in the next section, we need
    to create and attach this script to a game object and name it. Make sure to save
    the script before moving on.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `PlayerSpawner` 脚本编写完成。现在，在下一节中，我们需要创建并将此脚本附加到游戏对象上并为其命名。确保在继续之前保存脚本。
- en: Creating the PlayerSpawner game object
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 PlayerSpawner 游戏对象
- en: In this section, we will create a game object that will hold our newly created
    `PlayerSpawner` script, and then we will position the `PlayerSpawner` game object
    in the `testLevel` scene.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个游戏对象，它将包含我们刚刚创建的 `PlayerSpawner` 脚本，然后我们将 `PlayerSpawner` 游戏对象放置在
    `testLevel` 场景中。
- en: 'To create and set up our `PlayerSpawner` game object, we need to do the following:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和设置我们的 `PlayerSpawner` 游戏对象，我们需要执行以下操作：
- en: In the `PlayerSpawner`.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerSpawner` 中。
- en: Drag and drop the `PlayerSpawner` game object onto the `_Player` (remember that
    `_Player` is the empty game object in our scene) game object to make the `PlayerSpawner`
    its child.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PlayerSpawner` 游戏对象拖放到 `_Player`（记住 `_Player` 是我们场景中的空游戏对象）游戏对象上，使其成为 `PlayerSpawner`
    的子对象。
- en: Because our `PlayerSpawner` game object doesn't have anything visually applied
    to it, we can give it an icon.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `PlayerSpawner` 游戏对象没有应用任何视觉元素，我们可以给它一个图标。
- en: 'With the `PlayerSpawner` game object still selected in the **Inspector** window,
    click the multi-colored box to the left of its name. A selection of colors will
    be offered, as shown in the following screenshot:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中仍然选中 `PlayerSpawner` 游戏对象，点击其名称左侧的多彩方块。将提供一系列颜色选项，如以下截图所示：
- en: '![Figure 2.38 – Selecting an icon for the PlayerSpawner'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.38 – 为 PlayerSpawner 选择图标'
- en: '](img/Figure_2.38_B18381.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.38_B18381.jpg](img/Figure_2.38_B18381.jpg)'
- en: Figure 2.37 – Selecting an icon for the PlayerSpawner
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37 – 为 PlayerSpawner 选择图标
- en: Pick a color. Now, the `PlayerSpawner` game object will be given a label to
    show us where it is in the scene. This will now appear in the **Scene** window.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个颜色。现在，`PlayerSpawner` 游戏对象将被赋予一个标签，以显示它在场景中的位置。这将现在出现在 **场景** 窗口中。
- en: Tip
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you still can't see the icon in the **Scene** window, make sure **3D icons**
    are turned off. You can check by clicking the **Gizmos** button in the top right
    of the **Scene** window and unchecking the **3D Icons** box.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你仍然在 **场景** 窗口中看不到图标，请确保 **3D 图标** 已关闭。你可以通过点击 **场景** 窗口右上角的 ** Gizmos** 按钮并取消选中
    **3D 图标** 复选框来检查。
- en: 'With the `PlayerSpawner` game object sitting inside the `_Player` game object
    in the `PlayerSpawner` game object the following values:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_Player` 游戏对象内部的 `PlayerSpawner` 游戏对象中，以下值：
- en: 'With the `PlayerSpawner` game object still selected, in the **Inspector** window,
    give it the following **Transform** values:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerSpawner` 游戏对象仍然被选中时，在 **检查器** 窗口中，给它以下 **变换** 值：
- en: '![Figure 2.39 – PlayerSpawner Transform values in the Inspector window'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.39 – 检查器窗口中的 PlayerSpawner 变量'
- en: '](img/Figure_2.39_B18381.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.39_B18381.jpg](img/Figure_2.39_B18381.jpg)'
- en: Figure 2.38 – PlayerSpawner Transform values in the Inspector window
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.38 – 检查器窗口中的 PlayerSpawner 变量
- en: While still in the `PlayerSpawner` until you see the script appear in the drop-down
    list.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerSpawner` 中继续操作，直到你在下拉列表中看到脚本出现。
- en: Click the `PlayerSpawner` script to add this to the `PlayerSpawner` game object.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `PlayerSpawner` 脚本来将其添加到 `PlayerSpawner` 游戏对象中。
- en: We can't move the ship yet, nor can we fire because we haven't coded this in
    yet. In the following section, we will go through the player's controls, then
    we will move on to coding our player and its bullet to travel across the screen.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不能移动飞船，也不能开火，因为我们还没有编写这部分代码。在下一节中，我们将介绍玩家的控制方式，然后我们将继续编写玩家的代码以及子弹在屏幕上移动的代码。
- en: Setting up our Input Manager
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的输入管理器
- en: 'Remember that this is a side-scrolling shooter game, so the controls will be
    two-dimensional even though our visuals are three-dimensional. Our focus now is
    to get the `Players` controls set up. To do this, we need to access the **Input
    Manager**:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这是一个横向卷轴射击游戏，所以控制将是二维的，尽管我们的视觉效果是三维的。我们现在的重点是设置 `Players` 的控制。为此，我们需要访问 **输入管理器**：
- en: 'Select **Edit**, followed by **Project Settings**, and then select **Input
    Manager** from the list:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **编辑**，然后选择 **项目设置**，然后从列表中选择 **输入管理器**：
- en: '![Figure 2.40 – Selecting the Input Manager in the Unity editor'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.40 – 在 Unity 编辑器中选择输入管理器'
- en: '](img/Figure_2.40_B18381.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.40_B18381.jpg](img/Figure_2.40_B18381.jpg)'
- en: Figure 2.39 – Selecting the Input Manager in the Unity Editor
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.39 – 在 Unity 编辑器中选择输入管理器
- en: 'The **Input Manager** will offer a list of all available controls for our game.
    We will first check what the controls are set to by default. There are a lot of
    options here, but as mentioned, we only need to browse through the properties
    that matter to us, namely the following:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入管理器**将提供我们游戏所有可用控制器的列表。我们首先检查默认设置的控制。这里有很多选项，但如前所述，我们只需要浏览对我们有意义的属性，即以下属性：'
- en: '**Horizontal**: Moves the player''s ship along its x-axis'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**：沿着玩家的 x 轴移动玩家的飞船'
- en: '**Vertical**: Moves the player''s ship along its y-axis'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直**：沿着玩家的 y 轴移动玩家的飞船'
- en: '**Fire1**: Makes our player shoot'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fire1**：使玩家开火'
- en: 'To check these three properties, we need to do the following:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这三个属性，我们需要做以下几步：
- en: Expand the **Axes** dropdown by clicking the arrow next to it.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击其旁边的箭头展开 **轴** 下拉菜单。
- en: 'Expand **Horizontal**, as shown in the following screenshot:'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如下截图所示，展开 **水平**：
- en: '![Figure 2.41 – The Input Manager'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.41 – 输入管理器'
- en: '](img/Figure_2.41_B18381.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.41_B18381.jpg)'
- en: Figure 2.40 – The Input Manager
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.40 – 输入管理器
- en: '`-1`), and the right button configures it positively (`+1`). Alternative key
    presses to this effect are *A* for left and *D* for right.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`），右键配置为正数（`+1`）。其他具有相同效果的按键是左边的 *A* 和右边的 *D*。'
- en: If we had analog controls such as a joystick or a steering wheel, we would likely
    need to be concerned about the influence of gravity when the player releases the
    controls and it returns to its center. Dead refers to the center of the analog
    controls. Sometimes, controllers can be unbalanced and naturally lean to one side,
    so by increasing the dead zone, we can eliminate false feedback from the player
    that could be detected as a movement.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有类似摇杆或方向盘的模拟控制，那么当玩家释放控制并返回中心时，我们可能需要关注重力的影响。死点指的是模拟控制器的中心。有时，控制器可能不平衡，并且自然倾向于一侧，因此通过增加死区，我们可以消除玩家可能检测到的虚假反馈。
- en: '`-1`) and the positive button is up (`+1`). Alternative buttons are *S* for
    down and *W* for up.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`），而正数按钮向上（`+1`）。其他按钮是向下的 *S* 和向上的 *W*。'
- en: '`mouse 0` (that is, the left mouse button). For now, remove `mouse 0` from
    the alternative button.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouse 0`（即左鼠标按钮）。目前，从替代按钮中移除 `mouse 0`。'
- en: To find out more about the **Input Manager** window, click the little blue book
    at the top-right corner of the **Input Manager** panel.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 **输入管理器** 窗口的信息，请点击 **输入管理器** 面板右上角的蓝色小书。
- en: Our controls are now set in the `Player` script to take advantage of these controls.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 `Player` 脚本中设置了控制，以利用这些控制。
- en: Setting up our Player script
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的玩家脚本
- en: 'The `Player` script will be attached to the player ship game object, from which
    the player will be able to move and shoot, as well as inflict and receive damage.
    We will also make the player ship not go outside of the screenplay area. Before
    we continue, let''s remind ourselves where the `Player` script lies in our game
    framework:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 脚本将被附加到玩家飞船游戏对象上，玩家将能够移动和开火，以及造成和承受伤害。我们还将确保玩家飞船不会超出剧本区域。在我们继续之前，让我们提醒自己
    `Player` 脚本在我们游戏框架中的位置：'
- en: '![Figure 2.42 – Player UML'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.42 – 玩家 UML'
- en: '](img/Figure_2.42_B18381.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.42_B18381.jpg)'
- en: Figure 2.41 – Player UML
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.41 – 玩家 UML
- en: 'The `Player` script will be in contact with the following scripts:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 脚本将与以下脚本进行交互：'
- en: '`PlayerBullet`: The `Player` script will create bullets to fire.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerBullet`：`Player` 脚本将创建子弹进行射击。'
- en: '`PlayerSpawner`: The `Player` script is created from the `PlayerSpawner`.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerSpawner`：`Player` 脚本由 `PlayerSpawner` 创建。'
- en: '`IActorTemplate`: Contains damage control and the properties for `Player`.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IActorTemplate`：包含伤害控制和 `Player` 的属性。'
- en: '`GameManager`: Extra information such as the number of lives, the score, the
    level, and whatever upgrades the player ship has accumulated will be stored in
    `GameManager`.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameManager`：存储额外的信息，如生命值、分数、等级以及玩家飞船积累的任何升级。'
- en: '`SOActorModel`: Holds `ScriptableObject` properties for `Player`.'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOActorModel`：存储 `ScriptableObject` 的 `Player` 属性。'
- en: 'Now that we are familiar with the `Player` script''s relation to the other
    scripts, we can start coding it:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了 `Player` 脚本与其他脚本的关系，我们可以开始编写它：
- en: In the `Assets/Scripts` folder with the filename `Player`.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中，文件名为 `Player`。
- en: 'Open the script and add the `IActorTemplate` interface to the existing default
    code:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本，并将 `IActorTemplate` 接口添加到现有的默认代码中：
- en: '[PRE13]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The script will by default import a `UnityEngine` library (including some others),
    the name of the class, and `MonoBehaviour`. All of these are essential to make
    the script work in the Unity Editor.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，脚本将导入一个`UnityEngine`库（包括其他一些库），类的名称，以及`MonoBehaviour`。所有这些对于使脚本在Unity编辑器中工作都是必需的。
- en: 'Continuing with the `Player` script, enter the following global variables:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在`Player`脚本中输入以下全局变量：
- en: '[PRE14]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have entered a mixture of integers, floats, and game objects in our global
    variables; starting from the top, the first six variables will be updated from
    the player's `SOActorModel` script. `travelSpeed` is the speed of the player's
    ship, `health` is how many hits the player can take before dying, `hitPower` is
    the damage the ship will cause when colliding into something that can receive
    damage (the enemy), `actor` is the three-dimensional model used to represent the
    player, and finally, the `fire` variable is the three-dimensional model from which
    the player fires. If that seemed a little rushed, go back to the *Introducing
    our ScriptableObject – SOActorModel* section, where we went into more detail about
    these variables.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的全局变量中输入了整数、浮点数和游戏对象混合体；从顶部开始，前六个变量将从玩家的`SOActorModel`脚本中更新。`travelSpeed`是玩家飞船的速度，`health`是玩家在死亡之前可以承受的打击次数，`hitPower`是飞船在撞击可以承受伤害的物体（敌人）时造成的伤害，`actor`是用于表示玩家的三维模型，最后，`fire`变量是玩家发射的三维模型。如果这看起来有点仓促，请回到*介绍我们的ScriptableObject
    – SOActorModel*部分，在那里我们更详细地介绍了这些变量。
- en: The two public properties of `Health` and `Fire` are there to give access to
    our two `private health` and `fire` variables from other classes that require
    access.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health`和`Fire`这两个公共属性存在是为了让其他需要访问的类能够访问我们的两个`private health`和`fire`变量。'
- en: The `_Player` variable will be used as a reference to the `_Player` game object
    in the scene.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`_Player`变量将用于引用场景中的`_Player`游戏对象。'
- en: The last two variables of `width` and `height` will be used to store the measured
    results of the world space dimensions of the screen that the game is played in.
    We will discuss these two more in the next block of code.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个变量`width`和`height`将用于存储游戏在游戏中使用的屏幕世界空间尺寸的测量结果。我们将在下一块代码中进一步讨论这两个变量。
- en: Before we begin the following `Start` function code block, you may question
    why we would pick `Start` over `Awake` when it comes to running a function's code
    content. Both functions run once at runtime; the only noticeable difference is
    that `Awake` runs when the object is created. `Start` is executed when it's enabled,
    as can be seen in the documentation at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始以下`Start`函数代码块之前，你可能想知道为什么在运行函数代码内容时我们会选择`Start`而不是`Awake`。这两个函数在运行时都只运行一次；唯一明显的区别是`Awake`在对象创建时运行。`Start`在对象启用时执行，如[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)上的文档所示。
- en: For simplicity in our Unity project, we will vary between which of the two functions
    to use. This is so we avoid conflicts between several `Awake` functions running
    at the same time. As an example, one script may try to update its Text UI, but
    the variable updating the text may still be null at runtime because the script
    with the variable is still waiting for its content to be updated.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的Unity项目，我们将在这两个函数之间进行选择。这是为了避免多个`Awake`函数同时运行时的冲突。例如，一个脚本可能试图更新其Text
    UI，但更新文本的变量在运行时可能仍然是null，因为包含该变量的脚本仍在等待其内容更新。
- en: There is a way to avoid conflicts between several `Awake` functions being called
    by several scripts at runtime, by going to Unity's **Script Execution Order**
    in **Edit** | **Project Settings** | **Script Execution Order**.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转到Unity的**脚本执行顺序**在**编辑** | **项目设置** | **脚本执行顺序**，可以避免在运行时由多个脚本调用多个`Awake`函数之间的冲突。
- en: If you would like to know more about the **Script Execution Order**, check the
    documentation at [https://docs.unity3d.com/Manual/class-MonoManager.html](https://docs.unity3d.com/Manual/class-MonoManager.html).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于**脚本执行顺序**的信息，请查看[https://docs.unity3d.com/Manual/class-MonoManager.html](https://docs.unity3d.com/Manual/class-MonoManager.html)上的文档。
- en: 'Continuing with entering code into the `Player` script, next up, we will type
    out the `Start` function along with its content:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在`Player`脚本中输入代码，接下来，我们将输入`Start`函数及其内容：
- en: '[PRE15]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As previously mentioned, the `height` and `width` variables will store our world
    space measurements. These are required so that we can clamp the player's ship
    inside the screen. Both the height and width lines of code use similar methods;
    the only difference is with the axis we are reading.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`height`和`width`变量将存储我们的世界空间测量值。这些是必需的，以便我们可以将玩家的飞船限制在屏幕内。高度和宽度代码行使用类似的方法；唯一的区别是我们读取的轴。
- en: 'The `Camera.main` component refers to the camera in our scene, and the function
    it uses, `WorldToViewportPoint`, is to take the results from the game''s three-dimensional
    world space and convert the results into viewport space. If you aren''t sure what
    viewport space is, it''s similar to what we know as a screen resolution, except
    its measurements are in points and not pixels, and these points are measured from
    `0` to `1`. The following diagram shows the comparison between screen and viewport
    measurements:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera.main`组件指的是场景中的摄像机，它使用的函数`WorldToViewportPoint`是将游戏的三维世界空间的结果转换为视口空间。如果你不确定视口空间是什么，它类似于我们知道的屏幕分辨率，只是其测量单位是点而不是像素，这些点是从`0`到`1`进行测量的。以下图表显示了屏幕与视口测量的比较：'
- en: '![Figure 2.43 – Screen versus viewport measurements'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.43 – 屏幕与视口测量'
- en: '](img/Figure_2.43_B18381.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.43_B18381.jpg)'
- en: Figure 2.42 – Screen versus viewport measurements
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.42 – 屏幕与视口测量
- en: So, with viewports, no matter what the screen's resolution is, the full height
    and width are `1` and everything between that is a fraction. So, for the height,
    we feed `Vector3` to `WorldToViewportPoint`, where `Vector3` represents a world
    space value, followed by `-0.5f`, which sets its offset back to `0`. Then, we
    divide `1` (which is our full-screen size) by the result of our formula. This
    will give us our current world space height of the screen. We then apply the same
    principles for the width and use `x` instead of `y` and store the result.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用视口，无论屏幕的分辨率如何，完整的高度和宽度都是`1`，而所有介于其间的都是分数。所以，对于高度，我们向`WorldToViewportPoint`提供`Vector3`，其中`Vector3`表示世界空间值，后面跟着`-0.5f`，将其偏移量设置回`0`。然后，我们将`1`（这是我们全屏大小）除以我们公式的结果。这将给我们当前屏幕的世界空间高度。然后，我们应用相同的原则来处理宽度，使用`x`而不是`y`，并存储结果。
- en: Finally, the last line of code takes the reference of the `_Player` game object
    in the scene and stores it into our variable.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码的最后一行将场景中`_Player`游戏对象的引用存储到我们的变量中。
- en: 'Continuing with the `Player` script, we have our `Update` function that is
    called on every frame. Enter the function along with the following two methods:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用`Player`脚本，我们有一个在每一帧被调用的`Update`函数。输入函数以及以下两个方法：
- en: '[PRE16]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Update` function runs the `Movement` method and `Attack` method on every
    frame. We will go into depth about these two methods later on in the chapter,
    for now we will comment ("//") these two methods out to avoid the script not being
    able to run.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update`函数在每一帧运行`Movement`方法和`Attack`方法。我们将在本章后面深入探讨这两个方法，现在我们将这两个方法注释掉（"//"），以避免脚本无法运行。'
- en: The next method we are going to put into our `Player` script is the `ActorStats`
    method. This method is a requirement, as we declare it in the interface we are
    inheriting.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要放入`Player`脚本中的下一个方法是`ActorStats`方法。这个方法是必需的，因为我们声明了我们在继承的接口中。
- en: 'Just after the scope of our `Update` function, enter the following piece of
    code:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Update`函数作用域之后，输入以下代码段：
- en: '[PRE17]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code we have just entered assigns values from the player's `SOActorModel`
    `ScriptableObject` asset that we made earlier on in the chapter.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚输入的代码将分配来自玩家`SOActorModel` `ScriptableObject`资产中的值，这是我们本章早期制作的。
- en: This method doesn't get run in our script but gets accessed by other classes,
    the reason being that these variables hold values regarding our player and don't
    need to be anywhere else.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不会在我们的脚本中运行，而是由其他类访问，原因在于这些变量持有关于我们的玩家的值，并且不需要在任何其他地方。
- en: Save the `Player` script.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`Player`脚本。
- en: Before we test what we have so far, we need to attach our `Player` script to
    our `player_ship` in the **Project** window.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试到目前为止的内容之前，我们需要在**项目**窗口中将我们的`Player`脚本附加到`player_ship`上。
- en: In the `Assets/Prefab` and select the `player_ship` prefab.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefab`中，选择`player_ship`预制体。
- en: Select the `Player` until the script appears and then select it.
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Player`，直到脚本出现，然后选择它。
- en: With our `_Player`, `PlayerSpawner`, and the `GameManager` game objects, it's
    time to test out the game. We can see the player ship get created in our **Game**
    window by pressing **Play** in the Editor.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`_Player`、`PlayerSpawner`和`GameManager`游戏对象，现在是时候测试游戏了。我们可以在编辑器中按**播放**键看到玩家飞船在我们的**游戏**窗口中创建。
- en: 'The following screenshot shows our game in `PlayerSpawner` game object as the
    parent of the `Player` game object; also note the `PlayerSpawner` icon:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的游戏中的`PlayerSpawner`游戏对象作为`Player`游戏对象的父亲；同时注意`PlayerSpawner`图标：
- en: '![Figure 2.44 – The current Player setup in our game'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.44 – 我们游戏中当前的玩家设置'
- en: '](img/Figure_2.44_B18381.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.44_B18381.jpg)'
- en: Figure 2.43 – The current Player setup in our game
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.43 – 我们游戏中当前的玩家设置
- en: Tip
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before moving on to the next section, create a prefab of the `PlayerSpawner`
    game object by dragging and dropping it into the `Assets/Player`. That way, if
    you lose the scene for whatever reason along with its **Hierarchy** content, you
    can drag and drop your prefab back in. This should be a rule with any common active
    game object.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，通过将`PlayerSpawner`游戏对象拖放到`Assets/Player`中创建一个预制体。这样，如果你因为任何原因丢失了场景及其**层次结构**内容，你可以将你的预制体拖回。这应该适用于任何常见的活动游戏对象。
- en: Let's move on to the next section where we'll continue to work on the `Player`
    script, but this time, we will look at what happens when our player's game object
    comes into contact with an enemy.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入下一节，我们将继续在`Player`脚本上工作，但这次，我们将查看当玩家的游戏对象与敌人接触时会发生什么。
- en: Colliding with an enemy – OnTriggerEnter
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与敌人碰撞 – OnTriggerEnter
- en: 'In this section, we are going to add a function to our `Player` script that
    will check to see what has collided with our player''s game object during runtime.
    Currently, the only thing that can collide with our player is an enemy, but we
    can still demonstrate the use of Unity''s own `OnTriggerEnter` function, which
    handles most of the work for us:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在`Player`脚本中添加一个函数，用于在运行时检查我们的玩家游戏对象发生了什么碰撞。目前，唯一可以与我们的玩家发生碰撞的是敌人，但我们仍然可以展示Unity自带的`OnTriggerEnter`函数的使用，该函数为我们处理了大部分工作：
- en: 'Continuing after the scope of our last method (`ActorStats`) in the `Player`
    script, we are going to add the following code that detects our enemy colliding
    with the player''s ship:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`脚本中我们的上一个方法（`ActorStats`）的作用域之后继续，我们将添加以下代码，用于检测我们的敌人是否与玩家的飞船发生碰撞：
- en: '[PRE18]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s explain some of the code we have just entered into the `Player` script:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们刚刚输入到`Player`脚本中的部分代码：
- en: '`OnTriggerEnter(Collider other)` is a function that Unity recognizes to check
    what has entered into the player''s trigger collider.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter(Collider other)`是一个Unity识别的函数，用于检查什么进入了玩家的触发碰撞器。'
- en: We use an `if` statement to check whether the `tag` to the collider is called
    `Enemy`. Note when we create our enemy, we will give them an `Enemy` `tag` so
    they are easily identified. If the `tag` is equal to `Enemy`, we drop it into
    that `if` statement.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个`if`语句来检查碰撞器的`tag`是否被命名为`Enemy`。注意当我们创建我们的敌人时，我们将给他们一个`Enemy` `tag`，这样它们就容易被识别。如果`tag`等于`Enemy`，我们就将其放入那个`if`语句中。
- en: The next `if` statement checks to see whether our player's `health` is equal
    to or more than `1`. If it is, that means the player can take a hit and continue
    without dying and also means we can go into its `if` statement.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个`if`语句检查玩家的`health`是否等于或大于`1`。如果是，这意味着玩家可以承受打击并继续游戏而不会死亡，同时也意味着我们可以进入其`if`语句。
- en: We approach the third `if` statement that checks to see whether the collider
    has a game object named `energy +1(Clone)`. The name of this object is the name
    of the shield the player can purchase in the game shop, which we will add in [*Chapter
    6*](B18381_06_Epub.xhtml#_idTextAnchor120), *Purchasing In-Game Items and Advertisements*.
    If the player has this `energy +1(Clone)` object, we can `Destroy` it with Unity's
    premade function. We also deduct the player's extra health from the enemies' `SendDamage`
    function. We will discuss `SendDamage` later on in the chapter.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接近第三个`if`语句，该语句检查碰撞器是否有一个名为`energy +1(Clone)`的游戏对象。这个对象的名称是玩家可以在游戏商店购买的护盾的名称，我们将在[*第6章*](B18381_06_Epub.xhtml#_idTextAnchor120)，*购买游戏内物品和广告*中添加。如果玩家有这个`energy
    +1(Clone)`对象，我们可以使用Unity的预制函数`Destroy`它。我们还从敌人的`SendDamage`函数中扣除玩家的额外生命值。我们将在本章后面讨论`SendDamage`。
- en: Following the third `if` statement is an `else` condition where, in the event
    that the player doesn't have an `energy +1(Clone)` game object, they get their
    health deducted.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三个 `if` 语句之后是一个 `else` 条件，其中，如果玩家没有 `energy +1(Clone)` 游戏对象，他们的健康值会被扣除。
- en: Finally, if the player's `health` is at a value of zero or under, we run the
    `Die` method, which we will cover later in the chapter.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果玩家的 `health` 值为零或以下，我们将运行 `Die` 方法，我们将在本章后面介绍。
- en: Tip
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to keep saving your work as we continue to add more code to the
    project.
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们继续向项目中添加更多代码的同时，不要忘记保存你的工作。
- en: Let's continue with our `Player` script and add the functionality so that the
    player can receive and send damage from and to the enemy respectively.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的 `Player` 脚本并添加功能，以便玩家可以从敌人那里接收和发送伤害。
- en: In the next method, we are going to add two methods. The first method (`TakeDamage`)
    will take an integer called `incomingDamage` and use whatever the value is to
    deduct from our player's `health` value.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个方法中，我们将添加两个方法。第一个方法 (`TakeDamage`) 将接受一个名为 `incomingDamage` 的整数，并使用该值从我们的玩家
    `health` 值中扣除。
- en: The second method (`SendDamage`) will `return` an integer of our `hitPower`
    value.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法 (`SendDamage`) 将返回我们的 `hitPower` 值的整数。
- en: 'Just below and outside of the scope of our `ActorStats` method, now add the
    following code:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `ActorStats` 方法下方和范围之外，现在添加以下代码：
- en: '[PRE19]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's continue with another method for the `Player` script and make it possible
    for the player to control the player ship around the **Game** window.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续另一个 `Player` 脚本的方法，并使其能够控制玩家飞船在 **游戏** 窗口周围移动。
- en: The Movement method
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动方法
- en: In this section, we will code the `Movement` method, which will take input from
    the player's joypad/keyboard and also make use of the `height` and `width` floats
    to keep the player's ship within the scree:.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写 `Movement` 方法，它将从玩家的摇杆/键盘接收输入，并利用 `height` 和 `width` 浮点数来确保玩家的飞船保持在屏幕内：。
- en: 'Still in the `Player` script, make a start with the following method using
    the following content to check for the player''s input:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `Player` 脚本中，使用以下内容开始以下方法以检查玩家的输入：
- en: '[PRE20]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Movement` method will consist of detecting movement in four directions
    being made from the player; we'll start with when the player presses right on
    the controller/keyboard. We run an `if` statement that checks whether the Input
    Manager has detected any movement from the `Horizontal` property. If the `GetAxisRaw`
    detects a value higher than zero, we fall into the `if` statement's condition.
    Note that `GetAxisRaw` has no smoothing, so the player's ship will instantly move
    unless extra code is added.
  id: totrans-680
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Movement` 方法将包括检测玩家从四个方向进行的移动；我们将从玩家按下控制器/键盘上的右键开始。我们运行一个 `if` 语句来检查输入管理器是否检测到来自
    `Horizontal` 属性的任何移动。如果 `GetAxisRaw` 检测到一个大于零的值，我们就会进入 `if` 语句的条件。请注意，`GetAxisRaw`
    没有平滑处理，所以除非添加额外的代码，否则玩家的飞船会立即移动。'
- en: Next, we have another `if` statement; this checks whether the player has exceeded
    past the `width` (that is, of the screen's world space that we calculated earlier
    on in the chapter). We've also added an extra partial `width` to avoid the geometry
    of the player's ship leaving the screen. If the player's position is still under
    the `width` (and its buffer) value, we run the content inside the `if` statement.
  id: totrans-681
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们还有一个 `if` 语句；这个语句检查玩家是否超过了 `width`（即我们之前在章节中计算的屏幕世界空间）。我们还添加了一个额外的部分 `width`
    以避免玩家的飞船几何形状离开屏幕。如果玩家的位置仍然低于 `width`（及其缓冲区）值，我们将在 `if` 语句内运行内容。
- en: The player's position is updated with a `Vector3` struct, which holds the value
    of the `Horizontal` direction, multiplied by time per frame and by the `travelSpeed`
    we set from our `ScriptableObject`.
  id: totrans-682
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的位置通过一个 `Vector3` 结构更新，它包含 `Horizontal` 方向的值，乘以每帧的时间以及我们从 `ScriptableObject`
    设置的 `travelSpeed`。
- en: 'Let''s continue in the `Movement` method and add a similar `if` statement for
    moving the player ship to the left:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `Movement` 方法中继续，并添加一个类似的 `if` 语句以将玩家飞船向左移动：
- en: '[PRE21]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, the code is close to the previous block; the only difference
    is that our first `if` statement checks whether we are moving left; the second
    `if` statement checks whether the player's position is greater than the width
    and a slightly different buffer.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码接近之前的块；唯一的区别是，我们的第一个 `if` 语句检查我们是否在向左移动；第二个 `if` 语句检查玩家的位置是否大于宽度以及一个略微不同的缓冲区。
- en: Apart from that, the `if` statement and its content serve the same position,
    just in the opposite direction.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，`if`语句及其内容在相反的方向上服务于相同的位置。
- en: 'Let''s continue with our `Movement` method and add the `if` statement code
    for moving the player''s ship down:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用我们的`Movement`方法，并添加移动玩家飞船下方的`if`语句代码：
- en: '[PRE22]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Yet again, we follow the same rule from the previous two `if` statements, but
    this time, instead of `Horizontal`, we add the `Vertical` `string` property. In
    the second `if` statement, we check whether the player's y-axis is higher than
    a negative `height/3`. The reason why we divide by this value is that later on
    in the book ([*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161)*, Creating a
    2D Shop Interface and In-Game HUD*), we will be adding graphics at the bottom
    of the screen that will restrict the player's view.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们遵循与前面两个`if`语句相同的规则，但这次，我们添加了`Vertical` `string`属性，而不是`Horizontal`。在第二个`if`语句中，我们检查玩家的y轴是否高于负的`height/3`。我们之所以除以这个值，是因为在本书的后面部分（[*第9章*](B18381_09_Epub.xhtml#_idTextAnchor161)*，创建2D商店界面和游戏内HUD*），我们将在屏幕底部添加图形，这将限制玩家的视野。
- en: 'Let''s move on to the last `if` statement in the `Movement` method, moving
    up:'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续到`Movement`方法中的最后一个`if`语句，即向上移动：
- en: '[PRE23]'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As before, this `if` statement carries a similar role, but this time, it's checking
    whether the player's position is under the `height/2.5f` value. A buffer is applied
    to stop the three-dimensional geometry from leaving the top of the screen.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，这个`if`语句承担着类似的角色，但这次，它检查的是玩家的位置是否低于`height/2.5f`值。应用了一个缓冲区以防止三维几何体离开屏幕顶部。
- en: Tip
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When making a game, sometimes it occurs that when the player moves diagonally,
    their speed increases. This is because the player is effectively pressing two
    directions at the same time instead of just one.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作游戏时，有时会遇到玩家斜向移动时速度增加的情况。这是因为玩家实际上同时按下了两个方向，而不是一个方向。
- en: To ensure a direction has just the magnitude of `1`, we can use Unity's pre-made
    `Normalize` function.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一个方向只有`1`的量级，我们可以使用Unity预制的`Normalize`函数。
- en: To find out more about this function, check the documentation at [https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html](https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html).
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这个函数的信息，请查看[https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html](https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html)上的文档。
- en: Don't forget to save the script.
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记保存脚本。
- en: We will continue with the `Player` script by adding the `Die` method.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过添加`Die`方法来完善`Player`脚本。
- en: The Die method
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Die`方法'
- en: Adding the `Die` method to the `Player` script will make it possible for our
    player to be destroyed. Currently, inside the `Die` method is a Unity function
    called `Destroy`; this function will delete whatever game object is within its
    parameter.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Die`方法添加到`Player`脚本中，将使我们的玩家可以被摧毁。目前，在`Die`方法中有一个Unity函数叫做`Destroy`；这个函数将删除其参数内的任何游戏对象。
- en: 'Enter the following method in the `Player` script to destroy the player:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法输入到`Player`脚本中，以摧毁玩家：
- en: '[PRE24]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's move on to the last method in the `Player` script, which is to attack.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到`Player`脚本中的最后一个方法，即攻击方法。
- en: The Attack method
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Attack`方法'
- en: In this section, we will add content to the `Attack` method in the `Player`
    script.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向`Player`脚本中的`Attack`方法添加内容。
- en: The purpose of this `Attack` method is to receive input from the player, create
    a bullet, point the bullet in the correct direction, and make the bullet a child
    of the `Player` game object to keep our **Hierarchy** window tidy.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Attack`方法的目的是从玩家那里接收输入，创建子弹，将子弹指向正确的方向，并将子弹设置为`Player`游戏对象的子对象，以保持我们的**层次结构**窗口整洁。
- en: 'Enter the following `Attack` method into the `Player` script to allow the player
    to fire bullets:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`Attack`方法输入到`Player`脚本中，以允许玩家开火：
- en: '[PRE25]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside the `Attack` method, we call an `if` statement that checks whether the
    player has pressed the `Fire1` button (*Left Ctrl* on Windows; *command* if you
    are using a Mac). If the player has pressed the `Fire1` button, we will drop into
    the `if` statement's scope.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Attack`方法内部，我们调用一个`if`语句来检查玩家是否按下了`Fire1`按钮（Windows上的*左Ctrl*；如果你使用的是Mac，则是*command*）。如果玩家按下了`Fire1`按钮，我们将进入`if`语句的作用域。
- en: Note
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When a developer refers to the scope of a function, `if` statement, class,
    and so on, they are referring to what is happening between the opening and closing
    of the curly braces. For example, if the following code has a higher value in
    its `money` variable, the following `if` statement will run:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者提到函数的作用域、`if` 语句、类等时，他们指的是大括号开闭之间的内容。例如，如果以下代码中的 `money` 变量值更高，下面的 `if`
    语句将会执行：
- en: '`if (money > costOfPizza)`'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (money > costOfPizza)`'
- en: '`{`'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`//Whatever happens between the top and bottom of the two curly braces is within
    the if statements scope.`'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '`//两个大括号顶部和底部之间发生的事情都在 if 语句的作用域内。`'
- en: '`}`'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: Within the `if` statement, we make another `if` statement to make sure that
    when clicking the mouse, we are clicking on the screen and not anything UI-related.
    This will become more relevant when we look at adding a Pause button in [*Chapter
    10*](B18381_10_Epub.xhtml#_idTextAnchor173), *Pausing the Game, Altering Sound,
    and a Mock Test*. If we do click on something UI-related, we call `return`, which
    means we exit the `if` statement so that we don't fire a shot.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 语句内部，我们再添加一个 `if` 语句以确保在点击鼠标时，我们点击的是屏幕而不是任何 UI 相关的内容。当我们在 [*第 10 章*](B18381_10_Epub.xhtml#_idTextAnchor173)
    中查看添加暂停按钮、更改音效和模拟测试时，这会变得更加相关。如果我们点击了任何 UI 相关的内容，我们调用 `return`，这意味着我们退出 `if` 语句，这样就不会发射子弹。
- en: Because we have entered the movement and attack function content we can scroll
    back up to the `Update` function and remove the comments we added.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经输入了移动和攻击函数的内容，我们可以滚动回 `Update` 函数并移除我们添加的注释。
- en: 'Our `Update` function will now look like the following:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Update` 函数现在看起来如下所示：
- en: '[PRE26]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we `Instantiate` our `PlayerBullet` game object from its instance name,
    `fire`. We also face the `fire` game object to the right, relative to the screen,
    and move it toward oncoming enemies. We store the results of creating and orienting
    our game object in a variable named `bullet`.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从其实例名称 `fire` 中 `Instantiate` 我们的 `PlayerBullet` 游戏对象。我们还使 `fire` 游戏对象相对于屏幕向右，并移动它以朝向迎面而来的敌人。我们将创建和定位我们的游戏对象的结果存储在一个名为
    `bullet` 的变量中。
- en: We then set the size of the bullet to be seven times larger than its original
    size, which makes it look bigger.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将子弹的大小设置为原始大小的七倍，使其看起来更大。
- en: Finally, within the `if` statement, we make our `bullet` game object sit within
    a single game object with the variable name `_Player`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `if` 语句内部，我们让我们的 `bullet` 游戏对象位于一个名为 `_Player` 的单个游戏对象内。
- en: That is all of the code required for the `Player` script! Make sure to save
    the script before moving on.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为 `Player` 脚本所需的全部代码！在继续之前，请确保保存脚本。
- en: In the next section, we are going to move on to a different player script that
    controls what happens when the player fires their bullet.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续到另一个玩家脚本，该脚本控制玩家发射子弹时发生的情况。
- en: Setting up our PlayerBullet script
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的 `PlayerBullet` 脚本
- en: In this section, we will be creating a bullet that will travel across the screen
    from the player's ship.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个子弹，它将从玩家的飞船穿越屏幕。
- en: You will notice how similar the `PlayerBullet` script is to the `Player` script
    because it carries the `IActorTemplate` and `SOActorModel` scripts, which are
    already coded into the `Player` script.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `PlayerBullet` 脚本与 `Player` 脚本非常相似，因为它携带了 `IActorTemplate` 和 `SOActorModel`
    脚本，这些脚本已经编码在 `Player` 脚本中。
- en: 'Let''s create our `PlayerBullet` script:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 `PlayerBullet` 脚本：
- en: In the `Assets/Scripts` folder with the filename `PlayerBullet`.
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中，文件名为 `PlayerBullet`。
- en: 'Open the script and check/enter the following code at the top of the script:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本，并在脚本顶部检查/输入以下代码：
- en: '[PRE27]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By default, we require the `UnityEngine` library, as previously mentioned.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，默认情况下，我们需要 `UnityEngine` 库。
- en: 'Let''s continue by checking the correct class name and entering the following
    inheritance:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续检查正确的类名并输入以下继承：
- en: '[PRE28]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We declare the `public` class and by default inherit `MonoBehaviour`. We also
    inherit the `IActorTemplate` interface to give our game object-related methods
    from the other game object scripts, such as `SendDamage` and `TakeDamage`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 `public` 类并默认继承 `MonoBehaviour`。我们还继承 `IActorTemplate` 接口，以便从其他游戏对象脚本（如
    `SendDamage` 和 `TakeDamage`）中获取与游戏对象相关的函数。
- en: 'Enter the following global variables into the `PlayerBullet` script:'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下全局变量输入到 `PlayerBullet` 脚本中：
- en: '[PRE29]'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All the variables we add are `private`. The last variable has a `SerializeField`
    attribute added. `SerializeField` makes it possible for this variable to be visible
    in the `private`, we can still drag and drop assets into its field (which we will
    do shortly). More information on the `SerializeField` attributes can be found
    at [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的所有变量都是 `private`。最后一个变量添加了 `SerializeField` 属性。`SerializeField` 使得这个变量在
    `private` 中可见，我们仍然可以将资产拖放到其字段中（我们将在稍后这样做）。有关 `SerializeField` 属性的更多信息，请参阅 [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html)。
- en: 'Next, we''ll move on and enter the `Awake` function along with its content:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进入 `Awake` 函数及其内容：
- en: '[PRE30]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our `Awake` function is the `ActorStats` method, which is a requirement because
    we are inheriting an `interface` that declares it.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Awake` 函数中是 `ActorStats` 方法，这是必需的，因为我们正在继承一个声明它的 `interface`。
- en: 'Continue by entering the `SendDamage` and `TakeDamage` methods:'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续输入 `SendDamage` 和 `TakeDamage` 方法：
- en: '[PRE31]'
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As mentioned already in this chapter, we require these methods to send and receive
    damage.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章已提到的，我们需要这些方法来发送和接收伤害。
- en: 'Moving on, we enter the `Die` method along with its content:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续前进，我们进入 `Die` 方法及其内容：
- en: '[PRE32]'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Another method to include from our `interface` is the `Die` method.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 `interface` 中包含的另一个方法是 `Die` 方法。
- en: 'Next, enter the `ActorStats` method:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入 `ActorStats` 方法：
- en: '[PRE33]'
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The last method that we inherit from our `interface` is the `ActorStats` method,
    which will hold our `ScriptableObject` asset. This asset will then be assigned
    to our `PlayerBullet` script's global variables.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `interface` 继承的最后一个方法是 `ActorStats` 方法，它将包含我们的 `ScriptableObject` 资产。然后，这个资产将被分配给
    `PlayerBullet` 脚本的全局变量。
- en: 'The next function is the `OnTriggerEnter`, along with its `if` statement condition
    checks, as follows:'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数是 `OnTriggerEnter`，以及其 `if` 语句条件检查，如下所示：
- en: '[PRE34]'
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding block of code, we run a check to see whether our bullet has
    collided with an `"Enemy"` tagged collider. If the collider is tagged as `"Enemy"`
    to the player, we then check to see whether the collider holds an `IActorTemplate`
    interface. If it doesn't, then it's likely the `"Enemy"` collider is an obstacle.
    Otherwise, we deduct `health` from the `Enemy` game object and check to see whether
    it's dead.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们进行了一个检查，看看我们的子弹是否与被标记为 `"Enemy"` 的碰撞器发生了碰撞。如果碰撞器被标记为 `"Enemy"` 并指向玩家，我们接着检查该碰撞器是否包含
    `IActorTemplate` 接口。如果没有，那么 `"Enemy"` 碰撞器可能是一个障碍物。否则，我们从 `"Enemy"` 游戏对象中扣除 `health`
    并检查它是否已死亡。
- en: 'Now, let''s enter Unity''s `Update` function for the bullet''s movement:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进入子弹移动的 Unity `Update` 函数：
- en: '[PRE35]'
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Update` function adds to its x-axis each frame based on its `travelSpeed`
    value multiplied by `Time.deltaTime` (`Time.deltaTime` is the time in seconds
    from the last frame).
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 函数根据其 `travelSpeed` 值乘以 `Time.deltaTime`（`Time.deltaTime` 是从上一帧开始的秒数）在每一帧向其
    x 轴添加值。'
- en: Important Note
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you would like to know more about `Time.deltaTime`, check the documentation
    at [https://docs.unity3d.com/ScriptReference/Time-deltaTime.html](https://docs.unity3d.com/ScriptReference/Time-deltaTime.html).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 `Time.deltaTime` 的信息，请查看文档 [https://docs.unity3d.com/ScriptReference/Time-deltaTime.html](https://docs.unity3d.com/ScriptReference/Time-deltaTime.html)。
- en: 'Next, enter Unity''s `OnBecameInvisible` function:'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入 Unity 的 `OnBecameInvisible` 函数：
- en: '[PRE36]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This last function will remove any unnecessary bullets that have left the screen.
    This will help the performance of our game and keep it tidy. Make sure you have
    saved the script before continuing.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数将移除任何已离开屏幕的不必要子弹。这将有助于提高我们游戏的表现并保持其整洁。在继续之前，请确保已保存脚本。
- en: 'Next, we need to apply the `PlayerBullet` script to our `player_bullet` prefab:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 `PlayerBullet` 脚本应用到我们的 `player_bullet` 预制件上：
- en: Navigate to `Assets/Prefab/Player` and select `player_bullet`.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Assets/Prefab/Player` 并选择 `player_bullet`。
- en: With `Player_Bullet` selected, click the `PlayerBullet` until you see the `PlayerBullet`
    script.
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 `Player_Bullet` 后，点击 `PlayerBullet` 直到看到 `PlayerBullet` 脚本。
- en: Select the script and add the `PlayerBullet` asset to it from the **Bullet Model**
    field (drag the asset into the field or click the remote button to the right of
    its field).
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择脚本，并将 `PlayerBullet` 资产从 **Bullet Model** 字段添加到其中（将资产拖放到字段中或点击其字段右侧的远程按钮）。
- en: 'The following screenshot shows our `player_bullet` with its script and asset:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有脚本和资产的 `player_bullet`：
- en: '![Figure 2.45 – The player_bullet components in the Inspector window'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.45 – 检查器窗口中的玩家_子弹组件'
- en: '](img/Figure_2.45_B18381.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.45_B18381.jpg)'
- en: Figure 2.44 – The player_bullet components in the Inspector window
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.44 – 检查器窗口中的player_bullet组件
- en: We can now move on to the next section about making enemies for the player to
    attack!
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续下一节，关于为玩家攻击而创建敌人的内容！
- en: Planning and creating our enemy
  id: totrans-771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划和创建我们的敌人
- en: We have a player that moves, shoots, and takes damage; we can now start looking
    into creating an enemy that shares these attributes.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可以移动、射击和承受伤害的玩家；我们现在可以开始考虑创建一个具有这些属性的敌人。
- en: To remind ourselves of the genre we are making, our game carries the same traits
    as classic arcade shooters such as Konami's *Gradius*, Capcom's *UN Squadron*,
    and Irem's *R-Type* ([https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png](https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png)).
    Typically, with these types of games, the player is swarmed by enemies coming
    from the right of the screen and exiting to the left.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒自己我们正在制作的类型，我们的游戏具有与经典街机射击游戏（如Konami的*Gradius*、Capcom的*UN Squadron*和Irem的*R-Type*）相同的特征([https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png](https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png)）。通常，在这类游戏中，玩家会被从屏幕右侧涌来的敌人包围，并从左侧退出。
- en: In this section, we will be repeating similar aspects of the `PlayerSpawner`
    and `Player` scripts. The `EnemySpawner` script needs to be tweaked so that it
    will instantiate a given number of enemy ships at a certain rate.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重复`PlayerSpawner`和`Player`脚本的一些类似方面。`EnemySpawner`脚本需要调整，以便以一定速率实例化一定数量的敌人飞船。
- en: 'The `Enemy` game objects will be moving on their own, so there needs to be
    some extra code applied to their behavior. Before we go into creating our first
    enemy script, let''s look at a part of our game framework and note that the layout
    is basically the same as the player''s side of the game framework:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enemy`游戏对象将自行移动，因此需要对其行为应用一些额外的代码。在我们开始创建第一个敌人脚本之前，让我们看看我们的游戏框架的一部分，并注意布局基本上与游戏框架的玩家端相同：'
- en: '![Figure 2.46 – EnemySpawner and Enemy UML'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.46 – EnemySpawner和Enemy UML'
- en: '](img/Figure_2.46_B18381.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.46_B18381.jpg)'
- en: Figure 2.45 – EnemySpawner and Enemy UML
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.45 – EnemySpawner和Enemy UML
- en: 'Before we jump into the `EnemySpawner` script, let''s do the same housekeeping
    we did for our player game objects, namely creating an empty game object and storing
    all game objects relating to it in that one game object. The reason we did this
    is to remove the clutter in the **Hierarchy** window, so let''s do the same for
    our enemies:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入`EnemySpawner`脚本之前，让我们做与我们的玩家游戏对象相同的清理工作，即创建一个空的游戏对象并将所有相关的游戏对象存储在该游戏对象中。我们这样做是为了在**层次结构**窗口中去除杂乱，所以让我们为我们的敌人也这样做：
- en: Right-click in the **Hierarchy** window's open space.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口的空白区域右键点击。
- en: A drop-down list will appear; select **Create Empty**.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉列表；选择**创建空对象**。
- en: Name the game object `_Enemies`.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象命名为`_Enemies`。
- en: Let's move on to our enemy scripts.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写敌人脚本。
- en: Setting up our EnemySpawner and Enemy scripts
  id: totrans-784
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的EnemySpawner和Enemy脚本
- en: 'In this section, we are going to make a start on our `EnemySpawner` script
    and game object. The purpose of the `EnemySpawner` script is to have a game object
    spawn an enemy game object a series of times at a set rate. As soon as our `testLevel`
    scene begins, our enemy spawners will start releasing enemies. It will then be
    up to the enemies to move to the left of the screen. This is fairly simple, and
    as mentioned briefly in the previous section, the `EnemySpawner` uses the same
    `interface` and scriptable object as the `PlayerSpawner` to `instantiate` enemies.
    Let''s start by creating our `EnemySpawner` script:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始编写我们的`EnemySpawner`脚本和游戏对象。`EnemySpawner`脚本的目的是在设定速率下多次生成一个敌人游戏对象。一旦我们的`testLevel`场景开始，我们的敌人生成器将开始释放敌人。然后敌人将移动到屏幕的左侧。这相当简单，正如前一小节简要提到的，`EnemySpawner`使用与`PlayerSpawner`相同的`interface`和可脚本化的对象来`实例化`敌人。让我们首先创建我们的`EnemySpawner`脚本：
- en: In the `Assets/Scripts` folder with the filename `EnemySpawner`.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中，文件名为`EnemySpawner`。
- en: 'Open the script and enter the following code:'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并输入以下代码：
- en: '[PRE37]'
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As usual, we are using the default `UnityEngine` library.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们使用默认的`UnityEngine`库。
- en: We are also going to be using another library, called `System.Collections`.
    This is required when we come to use `Coroutines`, which will be explained later
    in this section.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用另一个名为 `System.Collections` 的库。当我们使用协程时，需要这个库，这将在本节后面解释。
- en: 'Next, we will check/enter the class name and its inheritance:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查/输入类名及其继承：
- en: '[PRE38]'
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Make sure the class is named `EnemySpawner` and that it also inherits `MonoBehaviour`
    by default.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 确保类名为 `EnemySpawner`，并且它默认继承自 `MonoBehaviour`。
- en: 'Following this, add four global variables to the `EnemySpawner` script:'
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `EnemySpawner` 脚本添加四个全局变量：
- en: '[PRE39]'
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All variables entered in the previous code have an accessibility level of `private`,
    and all of the variables apart from the `enemies` variable have a `SerializeField`
    and a `Range` attribute of between `0` to `10` applied. The reason for this is
    so that we or other designers can easily change the spawn rate and quantity of
    enemies from our `EnemySpawner` in the **Inspector** window, as shown in the following
    screenshot:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中输入的所有变量都具有 `private` 的可访问级别，除了 `enemies` 变量之外的所有变量都应用了 `SerializeField`
    和 `Range` 属性，范围在 `0` 到 `10` 之间。这样做的原因是，我们可以或其他设计师可以轻松地从 **Inspector** 窗口中更改 `EnemySpawner`
    的生成速率和敌人数量，如下面的截图所示：
- en: '![Figure 2.47 – Enemy spawn rate slider'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.47 – Enemy spawn rate slider](img/Figure_2.47_B18381.jpg)'
- en: '](img/Figure_2.47_B18381.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.47_B18381.jpg](img/Figure_2.47_B18381.jpg)'
- en: Figure 2.46 – Enemy spawn rate slider
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.46 – Enemy spawn rate slider](img/Figure_2.46_B18381.jpg)'
- en: 'Now, let''s enter Unity''s `Awake` function along with some content:'
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们输入 Unity 的 `Awake` 函数和一些内容：
- en: '[PRE40]'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Inside the `Awake` function, we make an instance from the empty `_Enemies` game
    object divider and store it in the `enemies` variable.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Awake` 函数中，我们从一个空的 `_Enemies` 游戏对象分隔符创建一个实例，并将其存储在 `enemies` 变量中。
- en: The second line of code inside our `Awake` function is a `StartCoroutine`.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Awake` 函数中的第二行代码是一个 `StartCoroutine`。
- en: Important Information
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: '`StartCoroutine()` and `IEnumerator` go hand in hand with each other. They
    act similarly to a method, taking parameters and running the code inside it. The
    main difference with coroutines is that they can be delayed by frame updates or
    time. You can consider them a more advanced version of Unity''s own `Invoke` function.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartCoroutine()` 和 `IEnumerator` 两者相辅相成。它们的作用类似于一个方法，接受参数并在其中运行代码。与协程的主要区别在于，它们可以被帧更新或时间延迟。你可以把它们看作是
    Unity 自身 `Invoke` 函数的更高级版本。'
- en: To find out more about coroutines and how to implement them in `IEnumerator`
    instances, check Unity's documentation at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html).
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于协程以及如何在 `IEnumerator` 实例中实现它们的信息，请查看 Unity 的文档：[https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html)。
- en: This will be used to run our method of creating an enemy, but as you may also
    notice, it takes two parameters. The first is the `quantity` of enemies it holds
    and the second is the `spawnRate`, which delays each spawned enemy.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于运行我们创建敌人的方法，但正如你可能也注意到的，它接受两个参数。第一个是它所包含的敌人数量，第二个是 `spawnRate`，它延迟每个生成的敌人。
- en: Next, in our `EnemySpawner` script, we have the `FireEnemy`, which will be used
    to run a cycle of creating and positioning each enemy, before waiting to repeat
    the process.
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `EnemySpawner` 脚本中，我们有 `FireEnemy`，它将被用来运行创建和定位每个敌人的循环，然后等待重复该过程。
- en: 'Next, below and outside of the `Awake` function, we can add our `IEnumerator`:'
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Awake` 函数下方和外部，我们可以添加我们的 `IEnumerator`：
- en: '[PRE41]'
  id: totrans-810
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inside the `FireEnemy` `IEnumerator`, we start a `for` loop that will iterate
    over its `qty` value.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FireEnemy` `IEnumerator` 中，我们启动一个 `for` 循环，该循环将遍历其 `qty` 值。
- en: 'Within the `for` loop, the following is added:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环内，添加以下内容：
- en: A method that we haven't covered yet, called `CreateEnemy`. The result of `CreateEnemy`
    will be turned into a game object instance called `enemyUnit`.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还没有介绍的一个方法，称为 `CreateEnemy`。`CreateEnemy` 的结果将被转换成一个名为 `enemyUnit` 的游戏对象实例。
- en: The `enemyUnit` is the enemy flying out of the `EnemySpawner` game object.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enemyUnit` 是从 `EnemySpawner` 游戏对象中飞出的敌人。'
- en: Our `EnemySpawner` position is issued to our `enemyUnit`.
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `EnemySpawner` 位置分配给我们的 `enemyUnit`。
- en: We then wait however many seconds the `spwnRte` value is set to.
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们等待 `spwnRte` 值所设置的秒数。
- en: Finally, the process is repeated up until the `for` loop has reached its total.
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个过程会一直重复，直到 `for` 循环达到其总数。
- en: 'Finally, below and outside of the `FireEnemy` `IEnumerator`, add the following
    method:'
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `FireEnemy` `IEnumerator` 下方和外部添加以下方法：
- en: '[PRE42]'
  id: totrans-819
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we mentioned, there is a method called `CreateEnemy`. Apart from the obvious,
    this method will do the following:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，有一个名为 `CreateEnemy` 的方法。除了显而易见的功能外，此方法还将执行以下操作：
- en: '`Instantiate` the `enemy` game object from its `ScriptableObject` asset.'
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其 `ScriptableObject` 资产中 `Instantiate` `enemy` 游戏对象。
- en: Apply values to our enemy from its `ScriptableObject` asset.
  id: totrans-822
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其 `ScriptableObject` 资产中为我们的敌人应用值。
- en: Name the enemy game object from its `ScriptableObject` asset.
  id: totrans-823
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其 `ScriptableObject` 资产中为敌人游戏对象命名。
- en: Don't forget to save the script.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记保存脚本。
- en: We can now move on to the next section where we will create and prepare the
    `EnemySpawner` with its game object.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一节，我们将创建并准备带有其游戏对象的 `EnemySpawner`。
- en: Adding our script to the EnemySpawner game object
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的脚本添加到敌人生成器游戏对象
- en: 'Finally, we need to attach our `EnemySpawner` script to an empty game object
    so that we can use it in our `testLevel` scene. To set up the `EnemySpawner` game
    object, do the following:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的 `EnemySpawner` 脚本附加到一个空的游戏对象上，这样我们就可以在 `testLevel` 场景中使用它。要设置 `EnemySpawner`
    游戏对象，请执行以下操作：
- en: Create an empty game object and name it `EnemySpawner`.
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的游戏对象并将其命名为 `EnemySpawner`。
- en: As we did with the `_Player` and `PlayerSpawner`, we need to move the `EnemySpawner`
    game object inside the `_Enemies` game object in the **Hierarchy** window.
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们处理 `_Player` 和 `PlayerSpawner` 一样，我们需要在 **层次结构** 窗口中将 `EnemySpawner` 游戏对象移动到
    `_Enemies` 游戏对象内部。
- en: 'After moving the `EnemySpawner` game object into the `_Enemies` game object,
    we now need to update the `EnemySpawner` game object''s **Transform** property
    values in the **Inspector** window:'
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `EnemySpawner` 游戏对象移动到 `_Enemies` 游戏对象后，我们现在需要在 **检查器** 窗口中更新 `EnemySpawner`
    游戏对象的 **变换** 属性值：
- en: '![Figure 2.48 – The EnemySpawner Transform values in the Inspector window'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.48 – 在检查器窗口中敌人生成器的变换值'
- en: '](img/Figure_2.48_B18381.jpg)'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.48_B18381.jpg](img/Figure_2.48_B18381.jpg)'
- en: Figure 2.47 – The EnemySpawner Transform values in the Inspector window
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.47 – 在检查器窗口中敌人生成器的变换值
- en: Still in the `EnemySpawner` until you see it in the list, and then click it.
  id: totrans-834
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `EnemySpawner` 中，直到你在列表中看到它，然后点击它。
- en: Also, for a visual aid in the `EnemySpawner` game object, as we did with our
    `PlayerSpawner` game object in the *Creating the PlayerSpawner game object* section.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了在 `EnemySpawner` 游戏对象中提供视觉辅助，就像我们在 *创建玩家生成器游戏对象* 部分中所做的那样。
- en: 'The following screenshot shows the icon I gave to my `EnemySpawner`:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了给我的 `EnemySpawner` 分配的图标：
- en: '![Figure 2.49 – The EnemySpawner icon'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.49 – 敌人生成器图标'
- en: '](img/Figure_2.49_B18381.jpg)'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.49_B18381.jpg](img/Figure_2.49_B18381.jpg)'
- en: Figure 2.48 – The EnemySpawner icon
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.48 – 敌人生成器图标
- en: 'We can now add an enemy to our `EnemySpawner` game object with its script in
    the **Inspector** window:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 **检查器** 窗口中将一个敌人添加到我们的 `EnemySpawner` 游戏对象中，并使用其脚本：
- en: '![Figure 2.50 – The EnemySpawner component holding the BasicWave Enemy actor'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.50 – 持有基本波敌人演员的敌人生成器组件'
- en: '](img/Figure_2.50_B18381.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.50_B18381.jpg](img/Figure_2.50_B18381.jpg)'
- en: Figure 2.49 – The EnemySpawner component holding the BasicWave Enemy actor
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.49 – 持有基本波敌人演员的敌人生成器组件
- en: We can now move on to creating our enemy script in the next section.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一节，创建我们的敌人脚本。
- en: Setting up our enemy script
  id: totrans-845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的敌人脚本
- en: As with our player ship being created from the `PlayerSpawner`, our first enemy
    will be created from its `EnemySpawner`. The enemy script will hold similar variables
    and functions, but it will also have its own movement, similar to the `PlayerBullet`
    moving along its *x* axis.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的玩家飞船是从 `PlayerSpawner` 创建出来的一样，我们的第一个敌人将是从其 `EnemySpawner` 创建出来的。敌人脚本将包含类似的变量和函数，但它还将有自己的移动，类似于
    `PlayerBullet` 沿其 *x* 轴移动。
- en: 'Let''s make a start and create our enemy script:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的敌人脚本：
- en: In the `Assets/Scripts` folder with the filename `EnemyWave`.
  id: totrans-848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中，文件名为 `EnemyWave`。
- en: 'Open the script and check/enter the following required library code at the
    top of the script:'
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本，并在脚本顶部检查/输入以下所需的库代码：
- en: '[PRE43]'
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Like the majority of our classes, we require the `UnityEngine` library.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的大多数类一样，我们需要 `UnityEngine` 库。
- en: 'Check and enter the class name and its inheritance:'
  id: totrans-852
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查并输入类名及其继承：
- en: '[PRE44]'
  id: totrans-853
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have a `public class` named `EnemyWave` that inherits `MonoBehaviour` by
    default but also adds our `IActorTemplate` interface.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `EnemyWave` 的 `public class`，默认继承自 `MonoBehaviour`，但还添加了我们的 `IActorTemplate`
    接口。
- en: 'Within the `EnemyWave` class, enter the following global variables:'
  id: totrans-855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `EnemyWave` 类中，输入以下全局变量：
- en: '[PRE45]'
  id: totrans-856
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The global variables for the `EnemyWave` class are the top four variables updated
    with values from its `ScriptableObject` asset. The other variables are specific
    to the enemy, and we have given two of these variables `SerializeField` attributes
    for debugging purposes in the **Inspector** window.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnemyWave`类的全局变量是前四个变量，这些变量使用其`ScriptableObject`资产中的值进行更新。其他变量是针对特定敌人的，我们为其中两个变量赋予了`SerializeField`属性，以便在**检查器**窗口中进行调试。'
- en: 'Add Unity''s `Update` function along with its content:'
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Unity的`Update`函数及其内容：
- en: '[PRE46]'
  id: totrans-859
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After the global variables, we add an `Update` function containing an `Attack`
    method.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局变量之后，我们添加一个包含`Attack`方法的`Update`函数。
- en: 'Add our `ScriptableObject` method, `ActorStats`, and its content:'
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们的`ScriptableObject`方法`ActorStats`及其内容：
- en: '[PRE47]'
  id: totrans-862
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We have our `ActorStats` method that takes in a `ScriptableObject` `SOActorModel`.
    This `ScriptableObject` then applies the variable values it holds and applies
    them to the `EnemyWave` script's variables.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`ActorStats`方法，它接受一个`ScriptableObject` `SOActorModel`。然后，这个`ScriptableObject`应用它持有的变量值，并将它们应用到`EnemyWave`脚本的变量中。
- en: 'Still in the `EnemyWave` script, add the `Die` method along with its content:'
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`EnemyWave`脚本中，添加`Die`方法及其内容：
- en: '[PRE48]'
  id: totrans-865
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Another familiar method if you have been following along is the `Die` method,
    which is called when the enemy has been destroyed by the player.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直跟随着，另一个熟悉的方法是`Die`方法，该方法在玩家摧毁敌人时被调用。
- en: 'Add Unity''s `OnTriggerEnter` function to the `EnemyWave` script:'
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Unity的`OnTriggerEnter`函数添加到`EnemyWave`脚本中：
- en: '[PRE49]'
  id: totrans-868
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Unity's own `OnTriggerEnter` function will check to see whether they have collided
    with the player and, if so, will send damage, and the enemy will destroy themselves
    with the `Die` method.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: Unity自带的`OnTriggerEnter`函数将检查它们是否与玩家发生碰撞，如果是，将发送伤害，并且敌人将使用`Die`方法摧毁自己。
- en: 'Continue and enter the `TakeDamage` and `SendDamage` methods:'
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续输入`TakeDamage`和`SendDamage`方法：
- en: '[PRE50]'
  id: totrans-871
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Another common set of methods from the `IActorTemplate` interface is to send
    and receive damage from the `EnemyWave` script.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`IActorTemplate`接口的另一组常见方法是，从`EnemyWave`脚本发送和接收伤害。
- en: Next is the `Attack` method, which controls the movement/attack of the enemy.
    This method is called in the `Update` function on every frame.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Attack`方法，它控制敌人的移动/攻击。该方法在每一帧的`Update`函数中被调用。
- en: 'With this attack, we will make the enemy move from right to left in a wavy
    animation (like a snake) instead of just going straight right to left. The following
    image shows our enemies moving from right to left in a wavy line:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个攻击，我们将使敌人以波浪动画（类似于蛇）的形式从右向左移动，而不是直接从右向左移动。以下图像显示了我们的敌人以波浪线从右向左移动：
- en: '![Figure 2.51 – The enemies'' wave attack pattern'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.51 – 敌人的波浪攻击模式'
- en: '](img/Figure_2.51_B18381.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.51_B18381.jpg](img/Figure_2.51_B18381.jpg)'
- en: Figure 2.50 – The enemies' wave attack pattern
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.50 – 敌人的波浪攻击模式
- en: 'Enter the following `Attack` method code into the `EnemyWave` script:'
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`Attack`方法代码输入到`EnemyWave`脚本中：
- en: '[PRE51]'
  id: totrans-879
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `Attack` method starts with `Time.deltaTime` being collected in a `float`
    variable labeled `time`.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attack`方法从收集在标记为`time`的`float`变量中的`Time.deltaTime`开始。'
- en: We then use a premade function from Unity that returns a sine ([https://docs.unity3d.com/ScriptReference/Mathf.Sin.html](https://docs.unity3d.com/ScriptReference/Mathf.Sin.html))
    using our `time` variable, multiplied by a set speed from the `verticalSpeed`
    variable, followed by the result being multiplied by `verticalAmplitude`.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Unity的一个预制函数，该函数返回一个正弦值（[https://docs.unity3d.com/ScriptReference/Mathf.Sin.html](https://docs.unity3d.com/ScriptReference/Mathf.Sin.html)），使用我们的`time`变量，乘以`verticalSpeed`变量中的设置速度，然后乘以结果乘以`verticalAmplitude`。
- en: The end result is stored in the `Vector3` *y* axis. What this basically does
    is make our enemy ship move up and down. The `verticalSpeed` parameter sets its
    speed and `verticalAmplitude` alters how far it goes up and down.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果存储在`Vector3` *y*轴上。这基本上会使我们的敌人飞船上下移动。`verticalSpeed`参数设置其速度，而`verticalAmplitude`则改变其上下移动的距离。
- en: Then, we do a similar task to what we did with the `PlayerBullet` to make the
    enemy ship move along the *x* axis, and we also add a sine calculation to its
    `Y` position for it to move up and down.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行与`PlayerBullet`类似的任务，使敌人飞船沿着*x*轴移动，并且我们还添加了正弦计算来改变其`Y`位置，使其上下移动。
- en: Make sure to save the script before we wind down this chapter.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，请确保保存脚本。
- en: 'Before we summarize, click **Play** in the Editor, and hopefully, if all is
    well, you will have a player ship that you will be able to fly around within the
    boundaries of the **Game** window''s aspect ratio; enemies will come floating
    into the screen and move from right to left; you will be able to destroy these
    enemies with your bullets. These enemies will also be able to destroy you if they
    make contact with you. Finally, our **Hierarchy** window is all neat and well-structured
    both before and after playing our game. The following screenshot shows what I
    have just explained:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，请在编辑器中点击**播放**，希望一切顺利的话，你将能够驾驶一艘飞船在**游戏**窗口的边界内飞行；敌人将会从屏幕右侧漂浮进入并向左移动；你将能够用你的子弹摧毁这些敌人。如果敌人与你接触，它们也会摧毁你。最后，我们的**层次结构**窗口在游戏前后都整洁且结构良好。以下截图展示了我所解释的内容：
- en: '![Figure 2.52 – The Game window with the current gameplay and the Hierarchy
    game object structured'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.52 – 包含当前游戏玩法和层次结构游戏对象结构的游戏窗口]'
- en: '](img/Figure_2.52_B18381.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.52 – Figure_2.52_B18381.jpg]'
- en: Figure 2.51 – The Game window with the current gameplay and the Hierarchy game
    object structured
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.51 – 包含当前游戏玩法和层次结构游戏对象结构的游戏窗口
- en: You have done so much already! The good news is that you've just conquered one
    of the biggest chapters in the book – quite sneaky of me, I know. But we already
    have the backbone of our game, and most importantly, we've covered a good chunk
    of the Unity Programmer exam.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经做了很多！好消息是，你刚刚征服了本书中最大的章节之一——我知道这很巧妙。但我们已经有了我们游戏的核心，最重要的是，我们已经覆盖了Unity程序员考试的大部分内容。
- en: Understandably, you may have come across some possible issues on the way, and
    you may feel stuck. Don't worry if this is the case – check the `Complete` folder
    for this chapter to load up the Unity project and compare the code in that folder
    with your own to double-check. Make sure you have the right game objects in your
    scene, check that the right game objects are tagged, check the radius size of
    your **Sphere** colliders, and if you have any errors or warnings appear in the
    **Console** window, double-click them, and they will take you to the code that's
    causing the issue.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 可以理解的是，你可能已经在路上遇到了一些可能的问题，你可能感到卡住了。如果这种情况发生，请不要担心——检查本章的`Complete`文件夹以加载Unity项目，并将该文件夹中的代码与你的代码进行比较以进行双重检查。确保你的场景中有正确的游戏对象，检查正确的游戏对象是否被标记，检查你的**球体**碰撞器的半径大小，如果你在**控制台**窗口中看到任何错误或警告，双击它们，它们将带你到导致问题的代码。
- en: Let's wrap up this chapter and talk about our game so far.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结本章，并谈谈到目前为止我们的游戏。
- en: Summary
  id: totrans-892
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have reached the end of this chapter, and we have conquered the majority
    of our game framework, as we can see in the following diagram:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本章的内容，我们已经征服了我们游戏框架的大部分内容，正如我们可以在以下图表中看到的那样：
- en: '![Figure 2.53 – Killer Wave UML'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.53 – Killer Wave UML]'
- en: '](img/Figure_2.53_B18381.jpg)'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.53 – Figure_2.53_B18381.jpg]'
- en: Figure 2.52 – Killer Wave UML
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.52 – Killer Wave UML
- en: We have created a game framework that would need only a few changes whether
    we added 1 or 1,000 more enemies to our game. Some of the benefits of this use
    of reusable code and `ScriptableObject` is that it will benefit non-programmers,
    save time, and prevent collaborators from being bogged down in the code.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个游戏框架，无论我们为游戏添加1个还是1000个更多的敌人，都需要进行很少的更改。这种使用可重用代码和`ScriptableObject`的一些好处是，它将使非程序员受益，节省时间，并防止合作者陷入代码的困境。
- en: We have also made it possible that if and when we want to add more `EnemySpawner`
    points, we can drag and drop more prefabs into our scene and update its `ScriptableObject`
    to change the enemy without coding in exact `Vector3` locations.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使得，如果我们想要添加更多的`EnemySpawner`点，我们可以将更多的预制体拖放到我们的场景中，并更新其`ScriptableObject`来更改敌人，而无需在精确的`Vector3`位置编码。
- en: We've covered other common Unity features, including instantiating game objects
    such as enemies and player bullets.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了其他常见的Unity功能，包括实例化游戏对象，如敌人和玩家子弹。
- en: 'In the next chapter, we will be covering the following scripts:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍以下脚本：
- en: '`ScoreManager`: When an enemy is destroyed, the player will receive a score.'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScoreManager`：当一个敌人被摧毁时，玩家将获得分数。'
- en: '`ScenesManager`: If the player dies, one life will be deducted; if the player
    loses all of their lives, the level will reset.'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScenesManager`：如果玩家死亡，将扣除一条生命；如果玩家失去所有生命，则关卡将重置。'
- en: '`Sounds`: Our ships and bullets will also have added sounds.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sounds`：我们的飞船和子弹也将添加声音。'
- en: Finally, we will be updating the overall structure of our code.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新我们代码的整体结构。
