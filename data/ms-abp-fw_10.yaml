- en: '*Chapter 8*: Using the Features and Services of ABP'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用ABP的功能和服务'
- en: ABP Framework is a full-stack application development framework, so it has many
    building blocks for every aspect of an enterprise solution. In the last three
    chapters, we have explored the fundamental services, data access infrastructure,
    and cross-cutting concern solutions provided by ABP Framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架是一个全栈应用程序开发框架，因此它为企业的每个方面提供了许多构建块。在前三章中，我们已经探讨了ABP框架提供的核心服务、数据访问基础设施和横切关注点解决方案。
- en: 'In this final chapter of *Part 2*, *Fundamentals of ABP Framework*, we will
    continue with some ABP features frequently used in business applications, in the
    following order:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节“第2部分”的最后一章，“ABP框架基础”中，我们将继续探讨在业务应用程序中经常使用的ABP功能，顺序如下：
- en: Obtaining the current user
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前用户
- en: Using the data filtering system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据过滤系统
- en: Controlling the audit logging system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制审计日志系统
- en: Caching data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存数据
- en: Localizing the **user interface** (**UI**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化用户界面（**UI**）
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow and try the examples, you need to install an **integrated
    development environment** (**IDE**)/editor (such as Visual Studio) to build ASP.NET
    Core projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随并尝试这些示例，您需要安装一个**集成开发环境**（**IDE**）/编辑器（例如Visual Studio）来构建ASP.NET Core项目。
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下GitHub仓库下载代码示例：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
- en: Obtaining the current user
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前用户
- en: If your application requires user authentication for some functionalities, you
    generally need to get information about the current user. ABP provides the `ICurrentUser`
    service to obtain detailed information for the currently logged-in user. For web
    applications, the implementation of `ICurrentUser` is completely integrated with
    ASP.NET Core's authentication system, so you can easily get claims of the current
    user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要某些功能进行用户身份验证，通常您需要获取当前用户的信息。ABP提供了`ICurrentUser`服务来获取当前登录用户的详细信息。对于Web应用程序，`ICurrentUser`的实现完全集成到ASP.NET
    Core的认证系统中，因此您可以轻松获取当前用户的声明。
- en: 'See the following code block for simple usage of the `ICurrentUser` service:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了`ICurrentUser`服务的简单用法：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the `MyService` constructor injects the `ICurrentUser` service,
    then gets the unique `Id`, `Username`, and `Email` values of the current user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`MyService`构造函数注入了`ICurrentUser`服务，然后获取当前用户的唯一`Id`、`Username`和`Email`值。
- en: 'Here are the properties of the `ICurrentUser` interface:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`ICurrentUser`接口的属性：
- en: '`IsAuthenticated` (`bool`): Returns `true` if the current user has logged in
    (authenticated).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsAuthenticated`（`bool`）：如果当前用户已登录（认证），则返回`true`。'
- en: '`Id` (`Guid?`): The `null` if the current user has not logged in.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`（`Guid?`）：如果当前用户未登录，则为`null`。'
- en: '`UserName` (`string`): Username of the current user. Returns `null` if the
    current user has not logged in.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserName`（`string`）：当前用户的用户名。如果当前用户未登录，则返回`null`。'
- en: '`TenantId` (`Guid?`): Tenant ID of the current user. It is usable for multi-tenant applications.
    Returns `null` if the current user is not related to a tenant.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TenantId`（`Guid?`）：当前用户的租户ID。对于多租户应用程序是可用的。如果当前用户与租户无关，则返回`null`。'
- en: '`Email` (`string`): Email address of the current user. Returns `null` if the
    current user has not logged in or has not set an email address.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Email`（`string`）：当前用户的电子邮件地址。如果当前用户未登录或未设置电子邮件地址，则返回`null`。'
- en: '`EmailVerified` (`bool`): Returns `true` if the current user''s email address
    has been verified.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailVerified`（`bool`）：如果当前用户的电子邮件地址已验证，则返回`true`。'
- en: '`PhoneNumber` (`string`): Phone number of the current user. Returns `null`
    if the current user has not logged in or has not set a phone number.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhoneNumber`（`string`）：当前用户的电话号码。如果当前用户未登录或未设置电话号码，则返回`null`。'
- en: '`PhoneNumberVerified` (`bool`): Returns `true` if the current user''s phone
    number has been verified.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhoneNumberVerified`（`bool`）：如果当前用户的电话号码已验证，则返回`true`。'
- en: '`Roles` (`string[]`): All roles of the current user as a string array.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Roles`（`string[]`）：当前用户的所有角色作为一个字符串数组。'
- en: Injecting the ICurrentUser Service
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注入ICurrentUser服务
- en: '`ICurrentUser` is a widely used service. Thus, some base ABP classes (such
    as `ApplicationService` and `AbpController`) provide it pre-injected. In these
    classes, you can directly use the `CurrentUser` property instead of manually injecting
    this service.'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ICurrentUser`是一个广泛使用的服务。因此，一些基础ABP类（如`ApplicationService`和`AbpController`）预先注入了它。在这些类中，你可以直接使用`CurrentUser`属性，而不是手动注入此服务。'
- en: ABP can work with any authentication provider since it works with the current
    claims that are provided by ASP.NET Core. **Claims** are key-value pairs issued
    on user login and stored in the authentication ticket. If you are using cookie-based
    authentication, they are stored in a cookie and sent to the server in every request.
    If you are using token-based authentication, they are sent by the client in every
    request, typically in the **HyperText Transfer Protocol** (**HTTP**) header.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ABP可以与任何身份验证提供者一起工作，因为它使用ASP.NET Core提供的当前声明。**声明**是在用户登录时发放的键值对，并存储在身份验证票据中。如果你使用基于cookie的身份验证，它们存储在cookie中，并在每次请求中发送到服务器。如果你使用基于令牌的身份验证，它们由客户端在每次请求中发送，通常在**超文本传输协议**（**HTTP**）头中。
- en: The `ICurrentUser` service gets all the information from the current claims.
    If you want to query the current claims directly, you can use the `FindClaim`,
    `FindClaims`, and `GetAllClaims` methods. These methods are especially useful
    if you create your own custom claims.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICurrentUser`服务从当前声明中获取所有信息。如果你想直接查询当前声明，可以使用`FindClaim`、`FindClaims`和`GetAllClaims`方法。如果你创建了自定义声明，这些方法特别有用。'
- en: Defining custom claims
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义声明
- en: ABP provides an easy way to add your custom claims to the authentication ticket
    so that you can safely get these custom values on the next requests of the same
    user. You can implement the `IAbpClaimsPrincipalContributor` interface to add
    custom claims to the authentication ticket.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了一种简单的方法将你的自定义声明添加到身份验证票据中，以便你可以在同一用户的下一个请求中安全地获取这些自定义值。你可以实现`IAbpClaimsPrincipalContributor`接口，将自定义声明添加到身份验证票据中。
- en: 'In the following example, we are adding social security number information—a
    custom claim—to the authentication ticket:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在将社会保险号码信息——一个自定义声明——添加到身份验证票据中：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we are first getting the `ClaimsIdentity` and finding the current
    user's ID. Then, we are getting the social security number from `IUserService`,
    which is a custom service that you should develop yourself. You can get any service
    from the `ServiceProvider` to query the data that you need. Finally, we are adding
    a new `Claim` to the `identity`. `SocialSecurityNumberClaimsPrincipalContributor`
    is then used whenever a user logs in to the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们首先获取`ClaimsIdentity`并找到当前用户的ID。然后，我们从`IUserService`获取社会保险号码，这是一个你应该自己开发的自定义服务。你可以从`ServiceProvider`获取任何服务来查询所需的数据。最后，我们向`identity`添加一个新的`Claim`。`SocialSecurityNumberClaimsPrincipalContributor`随后在用户登录应用程序时使用。
- en: You can use custom claims to authorize the current user for specific business
    requirements, filter data, or just show on the UI. Notice that authentication
    ticket claims cannot be changed unless you invalidate the authentication ticket
    and force the user to re-authenticate, so do not store frequently changed data
    in the claims. You can use the caching system (which will be introduced in the
    *Caching data* section) if your purpose is to store user data where it can be
    quickly accessed later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用自定义声明来授权当前用户满足特定业务需求、过滤数据或仅显示在UI上。请注意，除非你使身份验证票据无效并强制用户重新认证，否则身份验证票据的声明不能更改，因此不要在声明中存储频繁更改的数据。如果你的目的是存储可以在以后快速访问的用户数据，你可以使用缓存系统（将在*数据缓存*部分介绍）。
- en: '`ICurrentUser` is a core service that you frequently use in your application
    code. The next section introduces the data filtering system that seamlessly works
    most of the time.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICurrentUser`是在你的应用程序代码中频繁使用的核心服务。下一节将介绍数据过滤系统，它在大多数情况下可以无缝工作。'
- en: Using the data filtering system
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据过滤系统
- en: Filtering data in a query is very common in database operations. If you are
    using `WHERE` clause. If you are using `Where` extension method in C#. While most
    of these filtering conditions vary in your queries, some expressions are applied
    to all queries you run if you implement patterns such as soft-delete and multi-tenancy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库操作中过滤数据是非常常见的。如果你使用`WHERE`子句。如果你在C#中使用`Where`扩展方法。虽然这些过滤条件在查询中可能有所不同，但如果你实现了如软删除和多租户等模式，一些表达式将应用于你运行的每个查询。
- en: ABP automates the data filtering process to help you avoid repeating the same
    filtering logic everywhere in your application code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 自动化数据过滤过程，帮助你避免在应用程序代码的每个地方重复相同的过滤逻辑。
- en: In this section, we will first see the pre-built data filters of ABP Framework,
    then learn how to disable the filters when we need to. Finally, we will see how
    to implement our custom data filters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解 ABP 框架的预构建数据过滤器，然后学习如何在需要时禁用这些过滤器。最后，我们将看到如何实现我们自己的自定义数据过滤器。
- en: We typically use simple interfaces to enable filtering for entities. ABP defines
    two pre-defined data filters to implement soft-delete and multi-tenancy patterns.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用简单的接口来为实体启用过滤功能。ABP 定义了两个预定义的数据过滤器来实现软删除和多租户模式。
- en: The soft-delete data filter
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软删除数据过滤器
- en: If you use the soft-delete pattern for an entity, you never delete the entity
    in the database physically. Instead, you mark it as *deleted*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为实体使用软删除模式，你永远不会在数据库中物理删除该实体。相反，你将其标记为 *已删除*。
- en: 'ABP defines the `ISoftDelete` interface to standardize the property to mark
    an entity as soft-delete. You can implement that interface for an entity, as shown
    in the following code block:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 定义了 `ISoftDelete` 接口，以标准化标记实体为软删除的属性。你可以为实体实现该接口，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Order` entity, in this example, has an `IsDeleted` property that is defined
    by the `ISoftDelete` interface. Once you implement that interface, ABP automates
    the following tasks for you:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Order` 实体有一个由 `ISoftDelete` 接口定义的 `IsDeleted` 属性。一旦你实现了该接口，ABP 会为你自动完成以下任务：
- en: When you delete an order, ABP identifies that the `Order` entity implements
    the soft-delete pattern, prevents the deletion, and sets `IsDeleted` to `true`.
    So, the order is not physically deleted in the database.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你删除一个订单时，ABP 会识别出 `Order` 实体实现了软删除模式，阻止删除操作，并将 `IsDeleted` 设置为 `true`。因此，订单在数据库中不会被物理删除。
- en: When you query orders, ABP automatically filters deleted entities (by adding
    an `IsDeleted == false` condition to the query) to avoid accidentally retrieving
    deleted orders from the database.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你查询订单时，ABP 会自动过滤已删除的实体（通过在查询中添加 `IsDeleted == false` 条件），以避免意外从数据库中检索已删除的订单。
- en: Data filtering is related to queries, so, the first task is not directly related
    to data filtering but is a supporting logic implemented by ABP Framework.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据过滤与查询相关，因此，第一个任务与数据过滤没有直接关系，而是由 ABP 框架实现的支持逻辑。
- en: Data Filtering Limitations
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据过滤限制
- en: The data filtering automation only works when you use repositories or `DbContext`
    (for `DELETE` or `SELECT` command, you should handle this yourself because ABP
    cannot intercept your operation in such cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据过滤自动化仅在您使用存储库或 `DbContext`（对于 `DELETE` 或 `SELECT` 命令，您应该自己处理，因为 ABP 在这些情况下无法拦截您的操作）时才有效。
- en: The soft-delete filter is one of the built-in ABP data filters. Another built-in
    filter is for multi-tenancy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除过滤器是 ABP 数据过滤器中内置的一种。另一种内置过滤器用于多租户。
- en: The multi-tenancy data filter
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多租户数据过滤器
- en: Multi-tenancy is a widely used pattern to share resources between tenants in
    **software-as-a-service** (**SaaS**) solutions. It is essential to isolate the
    data between different tenants in a multi-tenant application. One tenant cannot
    read or write to another tenant's data, even if they are located in the same physical
    database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户是一种广泛使用的模式，用于在软件即服务（**SaaS**）解决方案中共享租户之间的资源。在多租户应用程序中隔离不同租户之间的数据至关重要。一个租户不能读取或写入另一个租户的数据，即使它们位于同一个物理数据库中。
- en: ABP has a complete multi-tenant system, which will be explained in detail in
    [*Chapter 16*](B17287_16_Epub_AM.xhtml#_idTextAnchor457), *Implementing Multi-Tenancy*.
    However, it would be good to mention the multi-tenancy filter here since it is
    related to the data filtering system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 拥有一个完整的多租户系统，这将在[*第16章*](B17287_16_Epub_AM.xhtml#_idTextAnchor457)中详细解释，*实现多租户*。然而，在这里提及多租户过滤器也是好的，因为它与数据过滤系统相关。
- en: 'ABP defines the `IMultiTenant` interface to enable the multi-tenancy data filter
    for an entity. We can implement that interface for an entity, as shown in the
    following code block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 定义了 `IMultiTenant` 接口，以启用实体的多租户数据过滤器。我们可以为实体实现该接口，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `IMultiTenant` interface defines the `TenantId` property, as shown in this
    example. ABP uses `Guid` values for tenant IDs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMultiTenant` 接口定义了 `TenantId` 属性，如下面的示例所示。ABP 使用 `Guid` 值作为租户 ID。'
- en: Once we implement the `IMultiTenant` interface, ABP automatically filters all
    queries for the `Order` entity using the ID of the current tenant. The current
    tenant's ID is obtained from the `ICurrentTenant` service, which will be explained
    in [*Chapter 16*](B17287_16_Epub_AM.xhtml#_idTextAnchor457), *Implementing Multi-Tenancy*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了`IMultiTenant`接口，ABP将自动使用当前租户的ID对所有`Order`实体的查询进行过滤。当前租户的ID是从`ICurrentTenant`服务中获取的，这将在[*第16章*](B17287_16_Epub_AM.xhtml#_idTextAnchor457)中解释，*实现多租户*。
- en: Working with Multiple Data Filters
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多个数据过滤器的使用
- en: Multiple data filters can be enabled for the same entity. For example, the `Order`
    entity defined in this section could implement both the `ISoftDelete` and `IMultiTenant`
    interfaces.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同一实体，可以启用多个数据过滤器。例如，本节中定义的`Order`实体可以同时实现`ISoftDelete`和`IMultiTenant`接口。
- en: As you see, implementing a data filter for an entity is pretty easy—just implement
    the interface related to the data filter. All data filters are enabled by default
    unless you explicitly disable them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为实体实现数据过滤器相当简单——只需实现与数据过滤器相关的接口。除非您明确禁用它们，否则所有数据过滤器默认启用。
- en: Disabling a data filter
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用数据过滤器
- en: Disabling an automatic filter can be necessary in some cases—for example, you
    may want to disable the soft-delete filter to read deleted entities from the database,
    or maybe you want to allow the user to recover deleted entities. You may want
    to disable the multi-tenancy filter to query data from all the tenants in a multi-tenant
    system. For whatever reason, ABP provides an easy and safe way to disable a data
    filter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，禁用自动过滤器可能是必要的——例如，您可能想要禁用软删除过滤器以从数据库中读取已删除的实体，或者您可能希望允许用户恢复已删除的实体。您可能想要禁用多租户过滤器以查询多租户系统中的所有租户的数据。无论出于何种原因，ABP都提供了一个简单且安全的方法来禁用数据过滤器。
- en: 'The following example shows how to get all the orders from the database, including
    deleted ones, by disabling the `ISoftDelete` data filter using the `IDataFilter`
    service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何通过使用`IDataFilter`服务禁用`ISoftDelete`数据过滤器来从数据库中获取所有订单，包括已删除的订单：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`OrderService`, in this example, injects the `Order` repository and the `IdataFilter`
    service. It then uses the `_dataFilter.Disable<IsoftDelete>()` expression to disable
    the soft-delete filter. In the `using` statement, the filter is disabled, and
    we can query deleted orders too.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`OrderService`注入了`Order`存储库和`IdataFilter`服务。然后它使用`_dataFilter.Disable<IsoftDelete>()`表达式来禁用软删除过滤器。在`using`语句中，过滤器被禁用，我们也可以查询已删除的订单。
- en: Always Use a using Statement
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用using语句
- en: The `Disable` method returns a disposable object so that we can use it in a
    `using` statement. Once the `using` block ends, the filter automatically turns
    back to the previous state, which means that if it was enabled before that `using`
    block, it returns to the enabled state. If it was already disabled before the
    `using` statement, the `Disable` method does not affect it, and it remains disabled
    after the `using` statement. This system allows us to safely disable a filter
    without affecting any logic that calls the `GetAllOrders` method. It is always
    recommended to disable a filter in a `using` statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disable`方法返回一个可处置的对象，这样我们就可以在`using`语句中使用它。一旦`using`块结束，过滤器将自动恢复到之前的状态，这意味着如果它在`using`块之前已启用，它将返回到启用状态。如果它在`using`语句之前已经禁用，则`Disable`方法不会影响它，并且它在`using`语句之后保持禁用状态。这个系统允许我们安全地禁用过滤器，而不会影响调用`GetAllOrders`方法的任何逻辑。始终建议在`using`语句中禁用过滤器。'
- en: '`IdataFilter` service provides two more methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdataFilter`服务提供了另外两个方法：'
- en: '`Enable<Tfilter>`: Enables a data filter. You can use this to temporarily enable
    a data filter in a scope in which the filter was disabled. It has no effect if
    the filter is already enabled. It is always recommended to enable a filter in
    a `using` statement, just as with the `Disable` method.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enable<Tfilter>`：启用数据过滤器。您可以使用此方法在禁用过滤器的范围内临时启用数据过滤器。如果过滤器已经启用，则此方法没有效果。始终建议在`using`语句中启用过滤器，就像使用`Disable`方法一样。'
- en: '`IsEnabled<Tfilter>`: Returns `true` if the given filter is currently enabled.
    You generally do not need this method since `Enable` and `Disable` work as expected
    in both cases.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsEnabled<Tfilter>`：如果给定的过滤器当前已启用，则返回`true`。您通常不需要此方法，因为`Enable`和`Disable`在两种情况下都按预期工作。'
- en: We've learned how to use the `Disable` and `Enable` pre-built data filters.
    The next section shows how to create custom data filters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用预构建的`Disable`和`Enable`数据过滤器。下一节将展示如何创建自定义数据过滤器。
- en: Defining custom data filters
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义数据过滤器
- en: Just as with pre-built data filters, you may want to define your own filters.
    A data filter is represented by an interface, so the first step is to define an
    interface for your filter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与预构建的数据过滤器一样，你可能想定义自己的过滤器。数据过滤器由一个接口表示，因此第一步是为你的过滤器定义一个接口。
- en: 'Assume that you want to archive your entities and automatically filter the
    archived data to not retrieve them into the application by default. For this example,
    we can define such a simple interface (you can define this in your domain layer),
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要存档你的实体，并自动过滤存档数据，以便默认情况下不将它们检索到应用程序中。对于这个例子，我们可以定义这样一个简单的接口（你可以在你的领域层中定义这个接口），如下所示：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `IsArchived` property will be used to filter the entities. Entities with
    `IsArchived` is `true` will be eliminated by default. Once we define such an interface,
    we can implement it for the entities that can be archived. See the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsArchived` 属性将用于过滤实体。默认情况下，具有 `IsArchived` 为 `true` 的实体将被排除。一旦我们定义了这样的接口，我们就可以为可以存档的实体实现它。请看以下示例：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Order` entity, in this example, implements the `Iarchivable` interface,
    which makes it possible to apply the data filter on that entity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Order` 实体实现了 `Iarchivable` 接口，这使得可以在该实体上应用数据过滤器。
- en: Note that the `Iarchivable` interface doesn't define a setter for `IsArchived`,
    but the `Order` entity defines it. That is my design decision; we don't need to
    set `IsArchived` over the interface, but we need to set it on the entity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Iarchivable` 接口没有为 `IsArchived` 定义设置器，但 `Order` 实体定义了它。这是我的设计决策；我们不需要在接口上设置
    `IsArchived`，但需要在实体上设置它。
- en: 'Since data filtering is done at the database provider level, custom filter
    implementation also depends on the database provider. This section will show how
    to implement the `Iarchivable` filter for the EF Core provider. If you are looking
    for MongoDB, please refer to ABP''s documentation: [https://docs.abp.io/en/abp/latest/Data-Filtering](https://docs.abp.io/en/abp/latest/Data-Filtering).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据过滤是在数据库提供程序级别完成的，因此自定义过滤器实现也取决于数据库提供程序。本节将展示如何为 EF Core 提供程序实现 `Iarchivable`
    过滤器。如果你在寻找 MongoDB，请参阅 ABP 的文档：[https://docs.abp.io/en/abp/latest/Data-Filtering](https://docs.abp.io/en/abp/latest/Data-Filtering)。
- en: ABP uses EF Core's `DbContext` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 使用 EF Core 的 `DbContext` 类。
- en: 'The first step is to define a property in your `DbContext` class that will
    be used in the filter expression, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在你的 `DbContext` 类中定义一个属性，该属性将用于过滤表达式，如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This property directly uses the `IdataFilter` service to get the filter state.
    The `DataFilter` property comes from the base `AbpDbContext` class, and it can
    be `null` if the `DbContext` instance was not resolved from the `null` check.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性直接使用 `IdataFilter` 服务来获取过滤状态。`DataFilter` 属性来自基 `AbpDbContext` 类，如果 `DbContext`
    实例未从 `null` 检查中解析出来，则它可以是 `null`。
- en: 'The next step is to override the `ShouldFilterEntity` method to decide if a
    given entity type should be filtered or not:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重写 `ShouldFilterEntity` 方法以决定是否应该过滤给定的实体类型：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ABP Framework calls this method for each entity type in this `DbContext` class
    (it is called only once—the first time the `DbContext` class is used after an
    application start). If this method returns `true`, it enables the EF Core global
    filters for that entity. Here, I just checked if the given entity implemented
    the `IArchivable` interface and returned `true` in that case. Otherwise, call
    the `base` method so that it checks for other data filters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架为这个 `DbContext` 类中的每个实体类型调用此方法（它只调用一次——在应用程序启动后第一次使用 `DbContext` 类时）。如果此方法返回
    `true`，则启用该实体的 EF Core 全局过滤器。在这里，我只是检查了给定的实体是否实现了 `IArchivable` 接口，并在该情况下返回 `true`。否则，调用
    `base` 方法，以便它检查其他数据过滤器。
- en: '`ShouldFilterEntity` only decides to enable filtering or not. The actual filtering
    logic should be implemented by overriding the `CreateFilterExpression` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShouldFilterEntity` 只决定是否启用过滤。实际的过滤逻辑应该通过重写 `CreateFilterExpression` 方法来实现：'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The implementation seems a bit complicated because it creates and combines expressions.
    The important part is how the `archiveFilter` expression was defined. `!IsArchiveFilterEnabled`
    checks if the filter is disabled. If the filter is disabled, then the other condition
    is not evaluated, and all the entities are retrieved without filtering. `!EF.Property<bool>(e,
    "IsArchived")` checks if the `IsArchived` value is `false` for that entity, so
    it eliminates entities with `IsArchived` as `true`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实现似乎有点复杂，因为它创建了并组合了表达式。重要的是如何定义`archiveFilter`表达式。`!IsArchiveFilterEnabled`检查过滤器是否已禁用。如果过滤器已禁用，则不会评估其他条件，并且将检索所有实体而不进行过滤。`!EF.Property<bool>(e,
    "IsArchived")`检查该实体的`IsArchived`值是否为`false`，因此消除了`IsArchived`值为`true`的实体。
- en: As you've seen from the preceding code block, I haven't used the `Order` entity
    in the filter implementation. That means the implementation is generic and can
    work with any entity type—all you need is to implement the `IArchivable` interface
    for the entity that you want to apply the filter for.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码块中看到的，我未在过滤器实现中使用`Order`实体。这意味着实现是通用的，可以与任何实体类型一起工作——您只需要为要应用过滤器的实体实现`IArchivable`接口。
- en: In summary, ABP allows us to create and control global query filters easily.
    It also uses that system to implement two popular patterns—soft-delete and multi-tenancy.
    The next section introduces the audit logging system, ABP's other feature that
    is very common in enterprise software solutions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，ABP使我们能够轻松创建和控制全局查询过滤器。它还使用该系统实现两种流行的模式——软删除和多租户。下一节将介绍审计日志系统，这是ABP的另一个在企业级软件解决方案中非常常见的功能。
- en: Controlling the audit logging system
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制审计日志系统
- en: ABP's audit logging system tracks all requests and entity changes and writes
    them into a database. Then, you can get a report of what was done in your application,
    when it was made, and who did it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ABP的审计日志系统跟踪所有请求和实体更改，并将它们写入数据库。然后，您可以获取关于在您的应用程序中做了什么、何时做的以及谁做的报告。
- en: The audit log system is installed and properly configured when you create a
    new solution from the startup templates. Most of the time, you use it without
    any configuration. However, ABP allows you to control, customize, and extend the
    audit logging system. But first, let's understand what an audit log object is.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从启动模板创建新解决方案时，审计日志系统已安装并正确配置。大多数时候，您无需任何配置即可使用它。然而，ABP允许您控制、自定义和扩展审计日志系统。但首先，让我们了解审计日志对象是什么。
- en: Audit log object
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计日志对象
- en: An audit log object is a group of actions and related entity changes performed
    together in a limited scope, typically in an HTTP request for a web application.
    We will talk more about audit log scopes in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志对象是一组在有限的作用域内（通常是在Web应用的HTTP请求中）一起执行的动作和相关实体更改。我们将在下一节中更多地讨论审计日志作用域。
- en: 'The diagram in *Figure 8.1* represents an audit log object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1* 中的图表示审计日志对象：'
- en: '![Figure 8.1 – Audit log object'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 审计日志对象'
- en: '](img/Figure_8.1_B17287.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B17287.jpg)'
- en: Figure 8.1 – Audit log object
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 审计日志对象
- en: 'Let''s explain that diagram by beginning from the root object, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从根对象开始解释该图，如下所示：
- en: '`AuditLogInfo`: In every scope (typically, a web request), there is one `AuditLogInfo`
    object that contains information about the current user, current tenant, HTTP
    request, client and browser details, and execution time and duration of the operation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuditLogInfo`: 在每个作用域（通常是一个Web请求）中，都有一个包含有关当前用户、当前租户、HTTP请求、客户端和浏览器详细信息以及操作执行时间和持续时间的`AuditLogInfo`对象。'
- en: '`AuditLogActionInfo`: In every audit log, there may be zero or more actions.
    An action is typically a controller action call, a page handler call, or an application
    service method call. It includes the class name, method name, and method arguments
    in that call.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuditLogActionInfo`: 在每个审计日志中，可能有零个或多个动作。动作通常是控制器动作调用、页面处理程序调用或应用程序服务方法调用。它包括调用中的类名、方法名和方法参数。'
- en: '`EntityChangeInfo`: An audit log object may contain zero or more changes on
    the entities in the database. Each entity change contains the change type (created,
    updated, or deleted), entity type (full class name), and ID of the changed entity.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityChangeInfo`: 审计日志对象可能包含零个或多个对数据库中实体的更改。每个实体更改包含更改类型（创建、更新或删除）、实体类型（完整类名）以及更改实体的ID。'
- en: '`EntityPropertyChangeInfo`: For every entity change, it logs the changes on
    the properties (fields in the database). This object contains the name, type,
    old value, and the new value of the affected property.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityPropertyChangeInfo`：对于每个实体变化，它会在属性（数据库中的字段）上记录变化。此对象包含受影响属性的名字、类型、旧值和新值。'
- en: '`Exception`: A list of exceptions occurred during this audit log scope.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`：在这次审计日志作用域中发生的异常列表。'
- en: '`Comment`: Additional comments/logs related to this audit log.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comment`：与这个审计日志相关的附加评论/日志。'
- en: 'The audit log object is saved into multiple tables in a relational database:
    `AbpAuditLogs`, `AbpAuditLogActions`, `AbpEntityChanges`, and `AbpEntityPropertyChanges`.
    I''ve written the fundamental properties of the audit log object in the previous
    list. You can check these database tables or investigate the `AuditLogInfo` object
    to see all the details.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志对象被保存到关系数据库的多个表中：`AbpAuditLogs`、`AbpAuditLogActions`、`AbpEntityChanges`
    和 `AbpEntityPropertyChanges`。我在前面的列表中已经写出了审计日志对象的基本属性。你可以检查这些数据库表或调查 `AuditLogInfo`
    对象以查看所有详细信息。
- en: MongoDB Limitation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 限制
- en: Entity changes are not logged for MongoDB since ABP uses EF Core's change-tracking
    system to get the entity change information, and the MongoDB driver has no such
    change-tracking system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ABP 使用 EF Core 的更改跟踪系统来获取实体更改信息，而 MongoDB 驱动程序没有这样的更改跟踪系统，因此不会为 MongoDB 记录实体更改。
- en: As mentioned at the beginning of this section, an audit log object is created
    per audit log scope.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，每个审计日志作用域都会创建一个审计日志对象。
- en: Audit log scope
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计日志作用域
- en: The audit log scope uses the **Ambient Context Pattern**. When you create a
    new audit log scope, all actions and changes made in this scope are saved as a
    single audit log object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志作用域使用 **环境上下文模式**。当你创建一个新的审计日志作用域时，在这个作用域中进行的所有操作和更改都会保存为一个单独的审计日志对象。
- en: There are a few ways to establish an audit log scope.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以建立审计日志作用域。
- en: Audit log middleware
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计日志中间件
- en: 'The first and the most common way to create an audit log scope is to use the
    audit log middleware in the ASP.NET Core pipeline configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建审计日志作用域的第一种和最常见的方式是在 ASP.NET Core 管道配置中使用审计日志中间件：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is typically placed before the `app.UseEndpoints()` or `app.UseConfiguredEndpoints()`
    endpoint configuration. When you use this middleware, every HTTP request writes
    a separate audit log record, which is the wanted behavior most of the time and
    is already configured in the startup templates by default.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常放置在 `app.UseEndpoints()` 或 `app.UseConfiguredEndpoints()` 端点配置之前。当你使用这个中间件时，每个HTTP请求都会写入一个单独的审计日志记录，这在大多数情况下是期望的行为，并且默认情况下已经在启动模板中配置好了。
- en: Audit log interceptor
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计日志拦截器
- en: If you don't use the audit log middleware or if your application is not a request/reply-style
    ASP.NET Core application (for example, a desktop or Blazor Server application),
    then ABP creates a new audit log scope per application service method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用审计日志中间件，或者如果你的应用程序不是请求/回复风格的 ASP.NET Core 应用程序（例如，桌面或 Blazor Server 应用程序），那么
    ABP 会为每个应用程序服务方法创建一个新的审计日志作用域。
- en: Manually creating audit scopes
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动创建审计作用域
- en: 'You typically won''t need to do this, but if you want to create an audit scope
    manually, you can use the `IAuditingManager` service, as shown in the following
    code block:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不需要这样做，但如果你想手动创建审计作用域，可以使用 `IAuditingManager` 服务，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you inject the `IAuditingManager` service, you can use the `BeginScope`
    method to create a new scope. Then, create a `try`-`catch` block to save the audit
    log, including exception cases. In the `try` section, you can just perform your
    logic, call any other service, and so on. All these operations and the changes
    in these operations are saved as a single audit log object in the `finally` block.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注入了 `IAuditingManager` 服务，你可以使用 `BeginScope` 方法创建一个新的作用域。然后，创建一个 `try`-`catch`
    块来保存审计日志，包括异常情况。在 `try` 部分中，你只需执行你的逻辑，调用其他服务等。所有这些操作以及这些操作中的更改都作为单个审计日志对象保存在 `finally`
    块中。
- en: Inside an audit log scope (regardless of whether it is created by ABP or manually
    by you), `_auditingManager.Current.Log` can be used to get the current audit log
    object to investigate or manipulate it (for example, add comment lines or additional
    information). If you are not in an audit log scope, then `_auditingManager.Current`
    returns `null`, so check for `null` if you are unsure as to whether there is a
    surrounding audit log scope.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在审计日志作用域内（无论是由 ABP 创建还是您手动创建），可以使用 `_auditingManager.Current.Log` 来获取当前的审计日志对象以进行调查或操作它（例如，添加注释行或附加信息）。如果您不在审计日志作用域内，则
    `_auditingManager.Current` 返回 `null`，因此如果您不确定是否存在周围的审计日志作用域，请检查 `null`。
- en: I've introduced the audit log object and audit log scopes, which work seamlessly
    by default. Now, let's see options to understand the defaults and the global configuration
    possibilities for the audit log system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了审计日志对象和审计日志作用域，它们默认情况下可以无缝工作。现在，让我们看看选项，以了解默认值和审计日志系统的全局配置可能性。
- en: Auditing options
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计选项
- en: 'The `AbpAuditingOptions` class is used to configure default options for the
    auditing system. It can be configured using the standard `options` pattern, as
    shown in the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpAuditingOptions` 类用于配置审计系统的默认选项。它可以使用标准的 `options` 模式进行配置，如下面的示例所示：'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can configure `options` inside the `ConfigureServices` method of your module.
    See the following list for the main options for the auditing system:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模块的 `ConfigureServices` 方法中配置 `options`。以下列表显示了审计系统的主要选项：
- en: '`IsEnabled` (`bool`; default: `true`): The main point to completely disable
    the auditing system.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsEnabled` (`bool`; 默认: `true`): 完全禁用审计系统的主要点。'
- en: '`IsEnabledForGetRequests` (`bool`; default: `false`): ABP does not save audit
    logs for HTTP `GET` requests by default because `GET` requests are not supposed
    to change the database. However, you can set this to `true`, which enables audit
    logging for `GET` requests too.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsEnabledForGetRequests` (`bool`; 默认: `false`): ABP 默认不保存 HTTP `GET` 请求的审计日志，因为
    `GET` 请求不应该更改数据库。但是，您可以将其设置为 `true`，这样也可以为 `GET` 请求启用审计日志。'
- en: '`IsEnabledForAnonymousUsers` (`bool`; default: `true`): Set this to `false`
    if you want to write audit logs only for authenticated users. If you save audit
    logs for anonymous users, you will see `null` for `UserId` values for these users.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsEnabledForAnonymousUsers` (`bool`; 默认: `true`): 如果您只想为认证用户写入审计日志，请将其设置为
    `false`。如果您为匿名用户保存审计日志，您将看到这些用户的 `UserId` 值为 `null`。'
- en: '`AlwaysLogOnException` (`bool`; default: `true`): If an exception occurs in
    your application code, ABP saves the audit log by default, without considering
    the `IsEnabledForGetRequests` and `IsEnabledForAnonymousUsers` options. Set this
    to `false` to disable that behavior.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlwaysLogOnException` (`bool`; 默认: `true`): 如果您的应用程序代码中发生异常，ABP 默认会保存审计日志，而不考虑
    `IsEnabledForGetRequests` 和 `IsEnabledForAnonymousUsers` 选项。将此设置为 `false` 以禁用该行为。'
- en: '`hideErrors` (`bool`; default: `true`): ABP ignores exceptions while saving
    audit log objects to the database. Set this to `false` to throw exceptions instead
    of hiding them.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hideErrors` (`bool`; 默认: `true`): ABP 在将审计日志对象保存到数据库时忽略异常。将此设置为 `false` 以抛出异常而不是隐藏它们。'
- en: '`ApplicationName` (`string`; default: `null`): If multiple applications are
    using the same database to save the audit logs, you can set this option in each
    application so that you can filter the logs based on the application name.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationName` (`string`; 默认: `null`): 如果多个应用程序使用相同的数据库来保存审计日志，您可以在每个应用程序中设置此选项，以便可以根据应用程序名称过滤日志。'
- en: '`IgnoredTypes` (`List<Type>`): You can ignore some specific types in the audit
    log system, including entity types.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IgnoredTypes` (`List<Type>`): 您可以在审计日志系统中忽略一些特定的类型，包括实体类型。'
- en: In addition to these simple global options, you can enable/disable change tracking
    for entities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些简单的全局选项之外，您还可以为实体启用/禁用更改跟踪。
- en: Enabling entity histories
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用实体历史记录
- en: The audit log object contains entity changes with property details. However,
    it is disabled for all entities by default because it may write too many logs
    into the database, which may rapidly increase the database size. It is suggested
    to enable it in a controlled way for the entities you want to track.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志对象包含具有属性详细信息的实体更改。然而，默认情况下它对所有实体都是禁用的，因为它可能会将过多的日志写入数据库，这可能会迅速增加数据库的大小。建议以受控的方式为要跟踪的实体启用它。
- en: 'There are two ways to enable entity histories for entities, as outlined here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为实体启用实体历史记录有两种方式，如下所述：
- en: The `[Auditing]` attribute is used to enable it for a single entity. It will
    be explained in the next section.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[Auditing]` 属性为单个实体启用它。它将在下一节中解释。
- en: The `EntityHistorySelectors` option is used to enable it for multiple entities.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityHistorySelectors` 选项用于为多个实体启用它。'
- en: 'In the following example, I''ve enabled the `EntityHistorySelectors` option
    for all entities:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我为所有实体启用了 `EntityHistorySelectors` 选项：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `AddAllEntities` method is a shortcut. `EntityHistorySelectors` is a list
    of named selectors, and you can add a lambda expression to select the entities
    you want. The following code is equivalent to the preceding configuration code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAllEntities` 方法是一个快捷方式。`EntityHistorySelectors` 是一个命名选择器的列表，你可以添加一个 lambda
    表达式来选择你想要的实体。以下代码与前面的配置代码等效：'
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first argument of `NamedTypeSelector` is the selector name—`MySelectorName`,
    for this example. Selector names are arbitrary, and they can be used later to
    find or remove a selector from the selector list. You typically don't use it;
    just give it a unique name. The second argument of `NamedTypeSelector` takes an
    expression. It gives you an entity `type` and waits for `true` or `false`. Returns
    `true`, if you want to enable entity histories for a given entity type. So, you
    can pass an expression such as `type => type.Namespace.StartsWith("MyRootNamespace")`
    to select all entities with a namespace. You can add as many selectors as you
    need. All selectors are tested. If one of them returns `true`, the entity is selected
    for logging property changes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamedTypeSelector` 的第一个参数是选择器名称——在这个例子中是 `MySelectorName`。选择器名称是任意的，并且可以在以后用来在选择器列表中查找或删除选择器。通常你不会使用它；只需给它一个独特的名称。`NamedTypeSelector`
    的第二个参数接受一个表达式。它为你提供一个实体 `type` 并等待 `true` 或 `false`。如果你想为给定的实体类型启用实体历史记录，则返回 `true`。因此，你可以传递一个如
    `type => type.Namespace.StartsWith("MyRootNamespace")` 的表达式来选择所有具有命名空间的实体。你可以添加你需要的任意数量的选择器。所有选择器都会被测试。如果其中任何一个返回
    `true`，则实体将被选中以记录属性更改。'
- en: Besides these global options and selectors, there are ways to enable/disable
    audit logging per class, method, and property level.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些全局选项和选择器之外，还有方法可以按类、方法和属性级别启用/禁用审计日志。
- en: Disabling and enabling audit logging in detail
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细禁用和启用审计日志
- en: 'When you use the audit log system, you typically want to log every access.
    However, in some cases, you may want to disable audit logging for some specific
    actions or entities. Here are some potential reasons for that: the action parameters
    may be dangerous to write into the logs (for example, it may contain the user''s
    password), the action call or entity change might be out of the user''s control,
    so it isn''t worth recording for audit purposes, or the operation can be a bulk
    operation that writes too many audit logs and decreases performance.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用审计日志系统时，通常你想要记录每一次访问。然而，在某些情况下，你可能想要禁用某些特定操作或实体的审计日志。以下是一些可能的原因：操作参数可能对写入日志是危险的（例如，它可能包含用户的密码），操作调用或实体更改可能超出用户控制，因此不值得为了审计目的记录，或者操作可能是一个大量操作，它写入过多的审计日志并降低性能。
- en: 'ABP defines the `[DisableAuditing]` and `[Audited]` attributes to control logged
    objects declaratively. There are two targets that you can control for audit logging:
    service calls and entity histories.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 定义了 `[DisableAuditing]` 和 `[Audited]` 属性来声明性地控制记录的对象。你可以控制审计日志的两个目标：服务调用和实体历史记录。
- en: Controlling audit logging for service calls
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制服务调用的审计日志
- en: Application service methods, Razor Page handlers, and `[DisableAuditing]` attribute
    at the class or method level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务方法、Razor 页面处理程序以及类或方法级别的 `[DisableAuditing]` 属性。
- en: 'The following example uses the `[DisableAuditing]` attribute on an application
    service class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在应用服务类上使用了 `[DisableAuditing]` 属性：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this usage, ABP won''t include the execution of these methods into the
    audit log object. If you just want to disable one of the methods, you can use
    it at the method level:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种用法，ABP 不会将这些方法的执行包括在审计日志对象中。如果你只想禁用其中一个方法，你可以在方法级别使用它：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, the `CreateAsync` method call is not included in the audit log,
    while the `DeleteAsync` method call is written into the audit log object. The
    same behavior could be accomplished using the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CreateAsync` 方法调用不包括在审计日志中，而 `DeleteAsync` 方法调用被写入审计日志对象。同样的行为可以使用以下代码实现：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I disabled audit logging for all methods except the `DeleteAsync` method because
    the `DeleteAsync` method declares the `[Audited]` attribute.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我禁用了所有方法（除了 `DeleteAsync` 方法），因为 `DeleteAsync` 方法声明了 `[Audited]` 属性。
- en: The `[Audited]` attribute can be used on any class (used with the DI system)
    to enable audit logging on that class, even if the class is not audit-logged by
    default. Moreover, you can use it in any method of any class to just enable it
    for that particular method call. If you use the `[Audited]` attribute on a class,
    you can then disable a specific method using the `[DisableAuditing]` attribute.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Audited]`属性可以用于任何类（与DI系统一起使用）以在该类上启用审计日志，即使该类默认不进行审计日志记录。此外，您可以在任何类的任何方法中使用它，只为该特定方法调用启用它。如果您在类上使用`[Audited]`属性，然后可以使用`[DisableAuditing]`属性禁用特定方法。'
- en: 'When ABP includes a method call information in the audit log object, it also
    includes all the parameters of the executed method. That is super-useful to understand
    which changes were made in your system; however, you may want to exclude some
    properties of the input in some cases. Consider a scenario that you get credit
    card information from the user. You probably don''t want to include this in the
    audit logs. You can use the `[DisableAuditing]` attribute on any property of an
    input object in such a case. See the following example, which excludes a property
    of a `Dto` input from the audit log:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当ABP在审计日志对象中包含方法调用信息时，它也会包含执行方法的所有参数。这对于了解您的系统中哪些更改非常有用；然而，在某些情况下，您可能想排除输入的一些属性。考虑一个场景，您从用户那里获取信用卡信息。您可能不想将其包含在审计日志中。在这种情况下，您可以在输入对象的任何属性上使用`[DisableAuditing]`属性。请参阅以下示例，它从`Dto`输入的属性中排除了审计日志：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For this example, ABP won't write the `CreditCardNumber` value into the audit
    log.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，ABP不会将`CreditCardNumber`值写入审计日志。
- en: Disabling audit logging for method calls won't affect the entity histories.
    If an entity is changed and it was selected for audit logging, changes are still
    logged. The next section explains how to control the audit logging system for
    entity histories.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用方法调用审计日志不会影响实体历史记录。如果一个实体被更改并且它被选中进行审计日志记录，更改仍然会被记录。下一节将解释如何控制实体历史记录的审计日志系统。
- en: Controlling audit logging for entity histories
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制实体历史记录的审计日志
- en: 'In the *Enabling entity histories* section, we saw how to enable entity histories
    for one or more entities by defining selectors. However, if you want to enable
    the entity histories for a single entity, there is an alternative and simpler
    way: just add the `[Audited]` attribute above your entity class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在*启用实体历史记录*部分，我们看到了如何通过定义选择器来为一个或多个实体启用实体历史记录。然而，如果您只想为单个实体启用实体历史记录，有一个替代且更简单的方法：只需在您的实体类上方添加`[Audited]`属性：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, I added the `[Audited]` attribute to an `Order` entity to configure
    the audit logging system to enable entity histories for this entity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我向`Order`实体添加了`[Audited]`属性，以配置审计日志系统为该实体启用实体历史记录。
- en: Suppose you've used selectors to enable entity histories for many or all entities
    but want to disable them for a specific entity. In that case, you can use the
    `[DisableAuditing]` attribute for that entity class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已使用选择器为许多或所有实体启用了实体历史记录，但想为特定实体禁用它们。在这种情况下，您可以使用该实体类的`[DisableAuditing]`属性。
- en: 'The `[DisableAuditing]` attribute can also be used on a property of an entity
    to exclude this property from the audit logs, as shown in the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`[DisableAuditing]`属性也可以用于实体的属性，以排除此属性从审计日志中，如下例所示：'
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For that example, ABP won't write the `CreditCardNumber` value into the audit
    log.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那个例子，ABP不会将`CreditCardNumber`值写入审计日志。
- en: Storing audit logs
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储审计日志
- en: 'The core of the ABP Framework has been designed to not assume any data store
    by introducing abstractions wherever it needs to touch a data source. The audit
    logging system is not an exception. It defines the `IAuditingStore` interface
    to abstract where the audit log objects are saved. That interface only has a single
    method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架的核心设计是通过在需要接触数据源的地方引入抽象，不假设任何数据存储。审计日志系统也不例外。它定义了`IAuditingStore`接口来抽象审计日志对象保存的位置。该接口只有一个方法：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can implement this interface to save audit logs where you want. If you use
    ABP's startup templates to create a new solution, it is configured to save audit
    logs to the application's main database, so you normally don't have to implement
    the `IAuditingStore` interface manually.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实现此接口以将审计日志保存到您想要的位置。如果您使用ABP的启动模板创建新解决方案，它已配置为将审计日志保存到应用程序的主要数据库中，因此您通常不需要手动实现`IAuditingStore`接口。
- en: We've seen different ways to control and customize the audit log system. Audit
    logging is an essential system for enterprise systems to track and log changes
    in your system. The next section introduces the caching system, another essential
    feature of a web application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了控制和管理审计日志系统的方法。审计日志是企业系统跟踪和记录系统更改的必要系统。下一节将介绍缓存系统，这是Web应用程序的另一个基本功能。
- en: Caching data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存数据
- en: Caching is one of the most fundamental systems to improve your application's
    performance and scalability. ABP extends ASP.NET Core's **distributed caching**
    system and makes it compatible with other features of ABP Framework, such as multi-tenancy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是提高应用程序性能和可伸缩性的最基本系统之一。ABP扩展了ASP.NET Core的**分布式缓存**系统，并使其与ABP框架的其他功能兼容，如多租户。
- en: Distributed caching is essential if you run multiple instances of your application
    or have a distributed system, such as a microservice solution. It provides consistency
    between different applications and allows the sharing of cached values. A distributed
    cache is typically an external, standalone application, such as Redis and Memcached.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行多个应用程序实例或拥有分布式系统，如微服务解决方案，分布式缓存是必不可少的。它提供了不同应用程序之间的一致性，并允许共享缓存值。分布式缓存通常是一个外部独立的应用程序，例如Redis和Memcached。
- en: It is suggested to use the distributed caching system even if your application
    has a single running instance. Don't worry about the performance since the default
    implementation of distributed cache works in memory. That means it is not distributed
    unless you explicitly configure a real distributed cache provider, such as Redis.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的应用程序只有一个运行实例，也建议使用分布式缓存系统。无需担心性能，因为分布式缓存的默认实现是在内存中工作的。这意味着除非您明确配置一个真实的分布式缓存提供者，如Redis，否则它不是分布式的。
- en: Distributed Caching in ASP.NET Core
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core中的分布式缓存
- en: 'This section focuses on ABP''s caching features and doesn''t cover all ASP.NET
    Core''s distributed caching system features. You can refer to Microsoft''s documentation
    to learn more about distributed caching in ASP.NET Core: [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍ABP的缓存功能，并不涵盖所有ASP.NET Core的分布式缓存系统功能。您可以参考Microsoft的文档来了解有关ASP.NET Core中分布式缓存的更多信息：[https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed)。
- en: In this section, I will show you how to use the `IDistributedCache<T>` interface,
    configure options, and deal with error handling and batch operations. We will
    also learn about using Redis as the distributed cache provider. Finally, I will
    talk about invalidating cached values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何使用`IDistributedCache<T>`接口，配置选项，并处理错误处理和批量操作。我们还将了解如何使用Redis作为分布式缓存提供者。最后，我将讨论如何使缓存值无效。
- en: Let's start from the basics—the `IDistributedCache<T>` interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始——`IDistributedCache<T>`接口。
- en: Using the IDistributedCache<T> interface
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IDistributedCache<T>接口
- en: 'ASP.NET Core defines an `IDistributedCache` interface, but it is not type-safe.
    It sets and gets `byte` arrays rather than objects. ABP''s `IDistributedCache<T>`
    interface, on the other hand, is designed as generic with type-safe method parameters
    (`T` stands for the type of items stored in the cache). It internally uses the
    standard `IDistributedCache` interface to be 100% compatible with ASP.NET Core''s
    caching system. ABP''s `IDistributedCache<T>` interface has two main advantages,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core定义了一个`IDistributedCache`接口，但它不是类型安全的。它设置和获取`byte`数组而不是对象。ABP的`IDistributedCache<T>`接口，另一方面，被设计为泛型，具有类型安全的参数方法（`T`代表存储在缓存中的项的类型）。它内部使用标准的`IDistributedCache`接口，以确保与ASP.NET
    Core的缓存系统100%兼容。ABP的`IDistributedCache<T>`接口有两个主要优势，如下所示：
- en: Automatically serializes/deserializes the objects to `byte` arrays. So, you
    don't deal with serialization and deserialization.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动将对象序列化和反序列化为`byte`数组。因此，您无需处理序列化和反序列化。
- en: It automatically adds the cache name prefix to the cache keys to allow the use
    of the same key for different kinds of cache objects.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动将缓存名称前缀添加到缓存键中，以便可以使用相同的键用于不同类型的缓存对象。
- en: 'The first step in using the `IDistributedCache<T>` interface is to define a
    class to represent items in the cache. I''ve defined the following class to store
    a user''s information in the cache:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IDistributedCache<T>`接口的第一步是定义一个类来表示缓存中的项。我已经定义了以下类来在缓存中存储用户信息：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That is a plain C# class. The only restriction is that it should be serializable
    because it is serialized to JSON while saving to the cache and deserialized while
    reading from the cache (for example, do not add references to other objects that
    should not or cannot be stored in the cache; keep it simple).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通的 C# 类。唯一的限制是它应该是可序列化的，因为它在保存到缓存时被序列化为 JSON，在从缓存读取时被反序列化（例如，不要添加引用到其他对象，这些对象不应该或不能存储在缓存中；保持简单）。
- en: 'Once we''ve defined the cache item class, we can inject the `IDistributedCache<T>`
    interface, as shown in the following code block:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了缓存项类，我们就可以注入 `IDistributedCache<T>` 接口，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I''ve injected the `IDistributedCache<UserCacheItem>` service to work with
    the distributed cache for `UserCacheItem` objects. The following code block shows
    how we can use it to get cached user information and fall back to the database
    query if the given user was not found in the cache:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我已注入了 `IDistributedCache<UserCacheItem>` 服务以处理 `UserCacheItem` 对象的分布式缓存。以下代码块显示了我们可以如何使用它来获取缓存的用户信息，如果给定的用户未在缓存中找到，则回退到数据库查询：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I''ve passed three parameters to the `GetOrAddAsync` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我已向 `GetOrAddAsync` 方法传递了三个参数：
- en: The first parameter is the cache key, which should be a string value, so I converted
    the `Guid` `userId` value to a string value.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是缓存键，它应该是一个字符串值，因此我将 `Guid` `userId` 值转换为字符串值。
- en: The second parameter is a factory method that is executed if the given key is
    not found in the cache. I passed the `GetUserFromDatabaseAsync` method here. In
    that method, you should build the cache item from its data source.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个工厂方法，如果给定的键未在缓存中找到，则会执行。我在这里传递了 `GetUserFromDatabaseAsync` 方法。在该方法中，您应从其数据源构建缓存项。
- en: The final parameter is a factory method that returns a `DistributedCacheEntryOptions`
    object. This is optional and configures the expiration time for the cached item.
    The factory method is only called if the `GetOrAddAsync` method adds the entry.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是一个工厂方法，它返回一个 `DistributedCacheEntryOptions` 对象。这是可选的，并配置了缓存项的过期时间。只有当
    `GetOrAddAsync` 方法添加条目时，才会调用工厂方法。
- en: Cache keys are `string` data types by default. However, ABP defines another
    interface, `IDistributedCache<TCacheItem, TCacheKey>`, allowing you to specify
    the cache key so that you don't need to convert your keys to `string` data types
    manually. We could inject the `IDistributedCache<UserCacheItem, Guid>` service
    and remove the `ToString()` usage in the first parameter for this example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存键默认为 `string` 数据类型。然而，ABP 定义了另一个接口 `IDistributedCache<TCacheItem, TCacheKey>`，允许您指定缓存键，这样您就不需要手动将您的键转换为
    `string` 数据类型。我们可以注入 `IDistributedCache<UserCacheItem, Guid>` 服务，并移除此示例中第一个参数的
    `ToString()` 使用。
- en: '`DistributedCacheEntryOptions` has the following options to control the lifetime
    of the cached item:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`DistributedCacheEntryOptions` 提供以下选项来控制缓存项的生存周期：'
- en: '`AbsoluteExpiration`: You can set an absolute time, as we''ve done in this
    example. The item is automatically deleted from the cache at that time.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbsoluteExpiration`：您可以设置一个绝对时间，就像我们在本例中所做的那样。在该时间，项目将从缓存中自动删除。'
- en: '`AbsoluteExpirationRelativeToNow`: An alternative way to set the absolute expiration
    time. We could rewrite the option in this example so that it reads `AbsoluteExpirationRelativeToNow
    = TimeSpan.FromHours(1)`. The result will be the same.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbsoluteExpirationRelativeToNow`：设置绝对过期时间的另一种方法。我们可以将本例中的选项重写为 `AbsoluteExpirationRelativeToNow
    = TimeSpan.FromHours(1)`。结果将是相同的。'
- en: '`SlidingExpiration`: Sets how long the cache item can be inactive (not accessed)
    before it is removed. This means that if you continue to access the cached item,
    the expiration time is automatically extended.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SlidingExpiration`：设置缓存项在移除之前可以不活跃（未访问）多长时间。这意味着如果您继续访问缓存项，则过期时间会自动延长。'
- en: 'If you don''t pass the expiration time parameter, the default value is used.
    You can configure the default value and some other global options using the `AbpDistributedCacheOptions`
    class explained in the next section. Before that, let''s see the other methods
    of the `IDistributedCache<UserCacheItem>` service, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您未传递过期时间参数，则使用默认值。您可以使用下一节中解释的 `AbpDistributedCacheOptions` 类配置默认值和一些其他全局选项。在此之前，让我们看看
    `IDistributedCache<UserCacheItem>` 服务的其他方法，如下所示：
- en: '`GetAsync` is used to read data from the cache with a cache key.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAsync` 用于使用缓存键从缓存中读取数据。'
- en: '`SetAsync` is used to save an item to the cache. It overwrites the existing
    value if available.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetAsync` 用于将项保存到缓存中。如果可用，它将覆盖现有值。'
- en: '`RefreshAsync` is used to reset the sliding expiration time for the given key.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RefreshAsync` 用于重置给定键的滑动过期时间。'
- en: '`RemoveAsync` is used to delete an item from the cache.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAsync` 用于从缓存中删除一个项。'
- en: About Synchronous Cache Methods
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于同步缓存方法
- en: All the methods also have synchronous versions, such as the `GET` method for
    the `GetAsync` method. However, it is suggested to use the asynchronous version
    wherever possible.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有方法也有同步版本，例如 `GetAsync` 方法的 `GET` 方法。然而，建议尽可能使用异步版本。
- en: These methods are the standard methods of ASP.NET Core. ABP adds methods to
    work with multiple items for each method, such as `GetManyAsync` for `GetAsync`.
    Working with `Many` methods has a significant performance gain if you have a lot
    of items to read or write. The `GetOrAddAsync` method (used in the `GetUserInfoAsync`
    example in this section) is also defined by ABP Framework to safely read a cache
    value, fall back to the original data source, and set the cache value in a single
    method call.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是 ASP.NET Core 的标准方法。ABP 为每个方法添加了处理多个项的方法，例如 `GetManyAsync` 对应 `GetAsync`。如果你有很多项需要读取或写入，使用
    `Many` 方法会有显著的性能提升。`GetOrAddAsync` 方法（在本节中 `GetUserInfoAsync` 示例中使用）也是由 ABP 框架定义的，用于安全地读取缓存值，回退到原始数据源，并在单个方法调用中设置缓存值。
- en: Configuring cache options
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置缓存选项
- en: '`AbpDistributedCacheOptions` is the main options class to configure the caching
    system. You can configure it in the `ConfigureServices` method of your module
    class (you can do this in the domain or application layers), as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpDistributedCacheOptions` 是配置缓存系统的主要选项类。你可以在模块类的 `ConfigureServices` 方法中配置它（你可以在领域层或应用层中这样做），如下所示：'
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I've configured the `GlobalCacheEntryOptions` property to configure the default
    cache expiration time to `2` hours in this code block.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我已在此代码块中将 `GlobalCacheEntryOptions` 属性配置为将默认缓存过期时间设置为 `2` 小时。
- en: '`AbpDistributedCacheOptions` has some other properties too, as outlined here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpDistributedCacheOptions` 还有一些其他属性，如下所述：'
- en: '`KeyPrefix` (`string`; default: `null`): A prefix value that is added to the
    beginning of all cache keys for that application. This option can be used to isolate
    your application''s cache items when using a distributed cache shared by multiple
    applications.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyPrefix` (`string`; 默认: `null`): 添加到该应用程序所有缓存键开头的前缀值。此选项可用于在使用多个应用程序共享的分布式缓存时隔离你的应用程序的缓存项。'
- en: '`hideErrors` (`bool`; default: `true`): A value to control the default value
    of error handling on cache service methods.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hideErrors` (`bool`; 默认: `true`): 用于控制缓存服务方法上错误处理的默认值。'
- en: As you've seen in the previous examples, these options can be overridden by
    passing parameters to the methods of the `IDistributedCache` service.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的示例中所看到的，这些选项可以通过传递参数到 `IDistributedCache` 服务的 `GetAsync` 方法的参数来覆盖。
- en: Error handling
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: When we use an external process (such as Redis) for distributed caching, it
    is probable to have problems while reading data from and writing data to the cache.
    The cache server may be offline, or we may have temporary network problems. These
    temporary problems can be ignored most of the time, especially while trying to
    read data from the cache. You can safely try to read from the original data source
    if the cache service is not available at the moment. It may be slower but is better
    than throwing an exception and failing the current request.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用外部进程（如 Redis）进行分布式缓存时，在从缓存中读取数据或写入数据时可能会遇到问题。缓存服务器可能离线，或者我们可能遇到暂时的网络问题。这些临时问题通常可以忽略，尤其是在尝试从缓存中读取数据时。如果缓存服务当前不可用，你可以安全地尝试从原始数据源读取。这可能会慢一些，但比抛出异常并使当前请求失败要好。
- en: All the `IDistributedCache<T>` methods get an optional `hideErrors` parameter
    to control the exception-handling behavior. If you pass `false`, then all the
    exceptions are thrown. If you pass `true`, then ABP hides cache-related errors.
    If you don't specify a value, the default value is used, as explained in the previous
    section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `IDistributedCache<T>` 方法都有一个可选的 `hideErrors` 参数来控制异常处理行为。如果你传递 `false`，则所有异常都会抛出。如果你传递
    `true`，则 ABP 隐藏与缓存相关的错误。如果你没有指定值，则使用上一节中解释的默认值。
- en: Using the cache in a multi-tenancy application
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多租户应用程序中使用缓存
- en: If your application is multi-tenant, ABP automatically adds the current tenant's
    ID to the cache key to distinguish between cache values of different tenants.
    In this way, it provides isolation between tenants.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是多租户的，ABP 会自动将当前租户的 ID 添加到缓存键中，以区分不同租户的缓存值。这样，它提供了租户之间的隔离。
- en: 'If you want to create a cache that is shared between tenants, you can use the
    `[IgnoreMultiTenancy]` attribute for the cache item class, as shown in the following
    code block:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个在租户之间共享的缓存，您可以使用 `[IgnoreMultiTenancy]` 属性为缓存项类，如下面的代码块所示：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For this example, `MyCacheItem` values can be accessed by different tenants.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，`MyCacheItem` 的值可以被不同的租户访问。
- en: Using Redis as the distributed cache provider
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redis 作为分布式缓存提供者
- en: Redis is a popular tool that is used as a distributed cache. ASP.NET Core provides
    a cache integration package for Redis. You can use it by following Microsoft's
    documentation ([https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed)),
    and it works perfectly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个流行的工具，用作分布式缓存。ASP.NET Core 为 Redis 提供了一个缓存集成包。您可以通过遵循 Microsoft 的文档（[https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed)）来使用它，并且它运行得非常好。
- en: 'ABP also provides a Redis integration package that extends Microsoft''s integration
    to support the batch operations (such as `GetManyAsync`, mentioned in the *Using
    the IDistributedCache<T> interface* section). So, it is suggested to use ABP''s
    integration `Volo.Abp.Caching.StackExchangeRedis` NuGet package to use Redis as
    the cache provider. You can install it using the ABP **command-line interface**
    (**CLI**) with the following command in the directory of the project you want
    to use:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 还提供了一个 Redis 集成包，它扩展了 Microsoft 的集成以支持批量操作（如 *Using the IDistributedCache<T>
    interface* 部分中提到的 `GetManyAsync`）。因此，建议使用 ABP 的集成 `Volo.Abp.Caching.StackExchangeRedis`
    NuGet 包来使用 Redis 作为缓存提供者。您可以使用以下命令在您想要使用的项目的目录中使用 ABP **命令行界面**（**CLI**）来安装它：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After the installation, all you need to do is to add a configuration to the
    `appsettings.json` file to connect to the Redis server, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您只需将配置添加到 `appsettings.json` 文件中，以连接到 Redis 服务器，如下所示：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You write the server address and port (a connection string) to the `Configuration`
    option. Please see Microsoft''s documentation for details of the configuration:
    [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您将服务器地址和端口（一个连接字符串）写入到 `Configuration` 选项中。请参阅 Microsoft 的文档以获取配置的详细信息：[https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed)。
- en: Invalidating cache values
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存值失效
- en: There is a popular saying that cache invalidation is one of the two hard problems
    in computer science (the other one is naming things). A cached value is typically
    a duplication of data originally located somewhere costly to read frequently or
    a computed value that is costly to recalculate. In such cases, it increases performance
    and scalability, but the problem begins when the original data changes and makes
    the cached value outdated. We should carefully watch these changes and remove
    or refresh the related data in the cache. That is called cache invalidation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个流行的说法，缓存失效是计算机科学中两个难题之一（另一个是命名事物）。缓存的值通常是原始数据的一个副本，原始数据位于经常需要读取且成本较高的位置，或者是一个计算成本较高的值。在这种情况下，它可以提高性能和可伸缩性，但当原始数据发生变化并使缓存值过时时，问题就开始了。我们应该仔细观察这些变化，并从缓存中删除或刷新相关数据。这被称为缓存失效。
- en: The cache invalidation process depends greatly on the cached data and your application
    logic. However, there are some specific cases where ABP can help you to invalidate
    cached data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存失效过程在很大程度上取决于缓存数据和您的应用程序逻辑。然而，有一些特定的情况，ABP 可以帮助您失效缓存数据。
- en: 'One specific case is that we may want to invalidate a cache item when an entity
    has changed (is updated or deleted). For this case, we can register for events
    published by ABP Framework. The following code invalidates a user cache item when
    the related user entity changes:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具体的情况是我们可能希望在实体发生变化（被更新或删除）时使缓存项失效。对于这种情况，我们可以注册 ABP 框架发布的事件。以下代码在相关用户实体发生变化时使用户缓存项失效：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`MyUserService` registers for an `EntityChangedEventData<IdentityUser>` local
    event. This event is triggered when a new `IdentityUser` entity is created or
    an existing `IdentityUser` entity is updated or deleted. The `HandleEventAsync`
    method is called in that case with the related entity in the `data.Entity` property.
    This method simply removes the user from the cache with the `Id` value of the
    changed entity.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyUserService`注册了一个`EntityChangedEventData<IdentityUser>`本地事件。当创建一个新的`IdentityUser`实体或更新或删除现有的`IdentityUser`实体时，将触发此事件。在这种情况下，会调用`HandleEventAsync`方法，并将相关实体在`data.Entity`属性中。此方法简单地从缓存中删除具有更改实体`Id`值的用户。'
- en: Local events work in the current process. That means the handler class (`MyUserService`
    here) should be in the same process as the entity change.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本地事件在当前进程中工作。这意味着处理类（这里为`MyUserService`）应该与实体变更在同一个进程中。
- en: About the Event Bus System
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于事件总线系统
- en: 'Local and distributed events are interesting features of ABP Framework that
    are not included in this book. See the ABP documentation if you want to learn
    more about them: [https://docs.abp.io/en/abp/latest/Event-Bus](https://docs.abp.io/en/abp/latest/Event-Bus).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本地和分布式事件是ABP框架的有趣特性，但本书中没有包括。如果你想了解更多关于它们的信息，请参阅ABP文档：[https://docs.abp.io/en/abp/latest/Event-Bus](https://docs.abp.io/en/abp/latest/Event-Bus)。
- en: In this section, we've learned how to work with the distributed caching system,
    configure options, and deal with error handling. We've also introduced the Redis
    cache provider installation. Finally, we've introduced automatic ABP events that
    can help us to invalidate cached values.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何与分布式缓存系统协同工作，配置选项，并处理错误处理。我们还介绍了Redis缓存提供程序的安装。最后，我们介绍了可以帮助我们使缓存值无效的自动ABP事件。
- en: The next section will be related to UI localization, the final ABP feature I
    will introduce in this chapter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将涉及UI本地化，这是我在本章中将要介绍的ABP的最后一个功能。
- en: Localizing the user interface
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化用户界面
- en: If you are building a global product, you probably want to show the UI localized
    on the basis of the current user's language. ASP.NET Core provides a system to
    localize your application's UI. ABP adds some useful features and conventions
    to make it even easier and flexible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个全球产品，你可能希望根据当前用户的语言显示本地化的UI。ASP.NET Core提供了一个系统来本地化你的应用程序的UI。ABP增加了一些有用的功能和约定，使其更加容易和灵活。
- en: This section explains how to define the languages that you want to support,
    create text for different languages, and get the correct text for the current
    user. You will understand the localization resource concept and embedded localization
    resource files.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何定义你想要支持的语言，为不同的语言创建文本，并获取当前用户的正确文本。你将了解本地化资源概念和嵌入式本地化资源文件。
- en: We can begin by defining the languages supported by your application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先定义你的应用程序支持的语言。
- en: Configuring supported languages
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置支持的语言
- en: 'The first question about localization is this: *Which languages do you want
    to support on your UI?* ABP provides a simple configuration to define languages,
    using `AbpLocalizationOptions`, as shown in the following code block:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本地化的第一个问题是这样的：*你希望在UI上支持哪些语言？* ABP提供了一个简单的配置来定义语言，使用`AbpLocalizationOptions`，如下面的代码块所示：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can write that code into the `ConfigureServices` method of your module class.
    In fact, that configuration is already done (with a lot of languages) when you
    create a new solution using the ABP application startup templates. You just edit
    the list as needed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这段代码写入你的模块类的`ConfigureServices`方法中。实际上，当你使用ABP应用程序启动模板创建新解决方案时，这个配置（以及许多语言）已经完成了。你只需根据需要编辑列表即可。
- en: 'The `LanguageInfo` constructor takes a few parameters:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`LanguageInfo`构造函数接受几个参数：'
- en: '`cultureName`: The culture name (code) for the language, which is set to `CultureInfo.CurrentCulture`
    on runtime.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cultureName`：语言的文化名称（代码），在运行时设置为`CultureInfo.CurrentCulture`。'
- en: '`uiCultureName`: The UI culture name (code) for the language, which is set
    to `CultureInfo.` `CurrentUICulture` on runtime.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uiCultureName`：语言的UI文化名称（代码），在运行时设置为`CultureInfo.CurrentUICulture`。'
- en: '`displayName`: Name of the language that is shown to the user while selecting
    this language. It is suggested to write that name in its original language.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayName`：在用户选择此语言时显示的语言名称。建议用其原始语言书写该名称。'
- en: '`flagIcon`: A string value that the UI can use to show a country flag near
    the language name.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flagIcon`：一个字符串值，UI可以使用它来在语言名称附近显示国家国旗。'
- en: ABP determines one of these languages based on the current HTTP request.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 根据当前的 HTTP 请求确定这些语言之一。
- en: Determining the current language
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定当前语言
- en: 'ABP determines the current language by using the `AbpRequestLocalizationMiddleware`
    class. This is an ASP.NET Core middleware that is added to the ASP.NET Core request
    pipeline with the following line of code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 通过使用 `AbpRequestLocalizationMiddleware` 类来确定当前语言。这是一个 ASP.NET Core 中间件，通过以下代码行添加到
    ASP.NET Core 请求管道中：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the request passes through this middleware, one of the configured languages
    is selected and set to `CultureInfo.CurrentCulture` and `CultureInfo.CurrentUICulture`.
    These are the standard systems of .NET to set and get the current culture in localization.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求通过此中间件时，将选择配置的语言之一并将其设置为 `CultureInfo.CurrentCulture` 和 `CultureInfo.CurrentUICulture`。这是
    .NET 中设置和获取当前文化定位的标准系统。
- en: 'The current language is selected based on the following HTTP request parameters
    in the given priority order:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当前语言的选择基于以下 HTTP 请求参数，按照以下优先级顺序：
- en: If the `culture` query string parameter is set, it is used to determine the
    current language. An example is `http://localhost:5000/?culture=en-US`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了 `culture` 查询字符串参数，它将用于确定当前语言。一个例子是 `http://localhost:5000/?culture=en-US`。
- en: If the `.AspNetCore.Culture` cookie value is set, then it is used as the current
    language.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了 `.AspNetCore.Culture` cookie 的值，则它将用作当前语言。
- en: If the `Accept-Language` HTTP header is set, it is used as the current language.
    The browser generally sends this last one by default.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了 `Accept-Language` HTTP 头，它将用作当前语言。浏览器通常默认发送最后一个。
- en: About ASP.NET Core's Localization System
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 ASP.NET Core 的本地化系统
- en: 'The behaviour explained in this section was the default behavior. However,
    ASP.NET Core''s language determination system is more flexible and customizable.
    Please see Microsoft''s documentation for more information: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization).'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节中解释的行为是默认行为。然而，ASP.NET Core 的语言确定系统更加灵活和可定制。请参阅 Microsoft 的文档以获取更多信息：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization).
- en: After defining the languages we want to support, we can define our localization
    resources.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们想要支持的语言之后，我们可以定义我们的本地化资源。
- en: Defining a localization resource
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义本地化资源
- en: 'ABP is 100% compatible with ASP.NET Core''s localization system. So, you can
    use the `.resx` files as localization resources by following Microsoft''s documentation:
    [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization).
    However, ABP offers a lightweight, flexible, and extensible way to define localized
    texts using simple JSON files.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 与 ASP.NET Core 的本地化系统 100% 兼容。因此，你可以通过遵循 Microsoft 的文档使用 `.resx` 文件作为本地化资源：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization)。然而，ABP
    提供了一种轻量级、灵活且可扩展的方式来定义本地化文本，使用简单的 JSON 文件。
- en: 'When you create a new solution using the ABP startup templates, the `Domain.Shared`
    project contains the localization resource of the application with the localization
    JSON files:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 ABP 启动模板创建一个新的解决方案时，`Domain.Shared` 项目包含应用程序的本地化资源以及本地化 JSON 文件：
- en: '![Figure 8.2 – Localization resource and localization JSON files'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 本地化资源和本地化 JSON 文件'
- en: '](img/Figure_8.2_B17287.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B17287.jpg)'
- en: Figure 8.2 – Localization resource and localization JSON files
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 本地化资源和本地化 JSON 文件
- en: For this example, the `DemoAppResource` class represents the localization resource.
    An application can have more than one localization resource, and each defines
    its own JSON files. You can think of a localization resource as a group of localization
    texts. It helps to build modular systems where each module has its own localization
    resource.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，`DemoAppResource` 类代表本地化资源。一个应用程序可以拥有多个本地化资源，每个资源定义其自己的 JSON 文件。你可以将本地化资源视为一组本地化文本。它有助于构建模块化系统，其中每个模块都有自己的本地化资源。
- en: 'A localization resource class is an empty class, as shown in the following
    code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化资源类是一个空类，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This class refers to the related resource when you want to use texts in that
    localization resource. The `LocalizationResourceName` attribute sets a string
    name to the resource. Every localization resource has a unique name that is used
    in the client-side code to refer to the resource. We will explore client-side
    localization in *Using localization in the client side* section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要在该本地化资源中使用文本时，此类引用相关资源。`LocalizationResourceName`属性为资源设置一个字符串名称。每个本地化资源都有一个唯一的名称，该名称在客户端代码中用于引用资源。我们将在*在客户端使用本地化*部分中探讨客户端本地化。
- en: Default Localization Resource of the Application
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的默认本地化资源
- en: You typically have a single (default) localization resource in your application
    that comes with the startup template when creating a new ABP solution. The default
    localization resource class's name starts with the project name—for example, `ProductManagementResource`
    if you've specified `ProductManagement` as the project name.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中，通常只有一个（默认）本地化资源，该资源在创建新的ABP解决方案时随启动模板一起提供。默认本地化资源类的名称以项目名称开头——例如，如果您将项目名称指定为`ProductManagement`，则类名为`ProductManagementResource`。
- en: Once we have a localization resource, we can create a JSON file for each language
    we support.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了本地化资源，我们就可以为每个我们支持的语言创建一个JSON文件。
- en: Working with the localization JSON files
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与本地化JSON文件一起工作
- en: 'A localization file is a simple JSON-formatted file, as shown in the following
    code block:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化文件是一个简单的JSON格式文件，如下面的代码块所示：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are two main root elements in that file, as outlined here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件中有两个主要的根元素，如下所述：
- en: '`culture`: The culture code for the related language. It matches the culture
    code that was introduced in *Configuring the supported languages* section.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`culture`：相关语言的区域代码。它与在*配置支持的语言*部分中引入的区域代码相匹配。'
- en: '`texts`: Contains key-value pairs for the localization texts. The key is used
    to access the localized texts and should be the same in all JSON files of different
    languages. The value is the localized text for the current culture (language).'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`texts`：包含本地化文本的键值对。键用于访问本地化文本，应在所有不同语言的JSON文件中相同。值是当前文化（语言）的本地化文本。'
- en: After defining localization texts for each language, we can request localized
    texts at runtime.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每种语言定义了本地化文本之后，我们可以在运行时请求本地化文本。
- en: Getting localized texts
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取本地化文本
- en: 'ASP.NET Core defines an `IStringLocalizer<T>` interface to get the localized
    texts in the current culture, where `T` stands for the localization resource class.
    You can inject that interface into your class, as shown in the following code
    block:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core定义了一个`IStringLocalizer<T>`接口，用于获取当前文化的本地化文本，其中`T`代表本地化资源类。您可以将该接口注入到您的类中，如下面的代码块所示：
- en: '[PRE34]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code block, the `LocalizationDemoService` class injects the
    `IStringLocalizer<DemoAppResource>` service, which is used to access localized
    texts for the `DemoAppResource` class. In the `GetWelcomeMessage` method, we simply
    get the localized text for the `WelcomeMessage` key. If the current language is
    English, it returns `Welcome to the application.`, as we defined in the JSON file
    in the previous section.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`LocalizationDemoService`类注入了`IStringLocalizer<DemoAppResource>`服务，该服务用于访问`DemoAppResource`类的本地化文本。在`GetWelcomeMessage`方法中，我们简单地获取`WelcomeMessage`键的本地化文本。如果当前语言是英语，它将返回我们在上一节中定义的JSON文件中的`Welcome
    to the application.`。
- en: We can pass parameters while localizing text.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地化文本时传递参数。
- en: Parameterized texts
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化文本
- en: 'Localization texts can contain parameters, as shown in the following example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化文本可以包含参数，如下面的示例所示：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Parameters can be passed to the localizer, as shown in the following code block:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将参数传递给本地化器，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The given name for this example replaces the `{0}` placeholder.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中给出的名称替换了`{0}`占位符。
- en: The fallback logic
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回退逻辑
- en: The localization system uses fallbacks to parent or default cultures when the
    requested text is not found in the current culture's JSON file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求的文本在当前文化的JSON文件中找不到时，本地化系统会使用父级或默认文化进行回退。
- en: 'For example, assume that you''ve requested to get a `WelcomeMessage` text while
    the current culture (`CultureInfo.CurrentUICulture`) is `de-DE` (German–Germany).
    In that case, one of the following scenarios occurs:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您请求获取`WelcomeMessage`文本，而当前区域代码（`CultureInfo.CurrentUICulture`）为`de-DE`（德国-德国）。在这种情况下，以下情况之一会发生：
- en: 'If you haven''t defined a JSON file with `"culture": "de-DE"` or you have defined
    a JSON file but it doesn''t contain the `WelcomeMessage` key, then it falls back
    to the parent culture (`"de"`), tries to find the given key in that culture, and
    returns it if available.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果您没有定义具有 `"culture": "de-DE"` 的 JSON 文件，或者您已经定义了一个 JSON 文件但它不包含 `WelcomeMessage`
    键，那么它将回退到父文化（`"de"`），尝试在该文化中找到给定的键，如果可用则返回它。'
- en: If it is not found in the parent culture, it falls back to the default culture
    of the localization resource (see the next section to configure the default culture).
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在父文化中找不到，它将回退到本地化资源的默认文化（请参阅下一节以配置默认文化）。
- en: If it is not found in the default culture, then the given key (`WelcomeMessage`,
    for this example) is returned as the response.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在默认文化中找不到，则返回给定的键（例如本例中的 `WelcomeMessage`）作为响应。
- en: Configuring localization resources
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置本地化资源
- en: 'A localization resource should be added to `AbpLocalizationOptions` before
    using it. This configuration is already done in the startup template with the
    following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，应将本地化资源添加到 `AbpLocalizationOptions` 中。此配置已在启动模板中完成，如下所示：
- en: '[PRE37]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Localization JSON files are generally defined as embedded resources. We are
    configuring ABP's virtual filesystem (using the `AbpVirtualFileSystemOptions`)
    to add all embedded files in that assembly into the virtual filesystem so that
    the localization files are also added.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化 JSON 文件通常定义为嵌入式资源。我们正在配置 ABP 的虚拟文件系统（使用 `AbpVirtualFileSystemOptions`），将此程序集中的所有嵌入式文件添加到虚拟文件系统中，以便本地化文件也被添加。
- en: Then, in the second part, we add `DemoAppResource` to the `Resources` dictionary
    so that ABP recognizes it. Here, the `"en"` parameter sets the default culture
    of that localization resource.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二部分中，我们将 `DemoAppResource` 添加到 `Resources` 字典中，以便 ABP 能够识别它。在这里，`"en"`
    参数设置了该本地化资源的默认文化。
- en: ABP's localization system is pretty advanced. It allows you to reuse the texts
    of a localization resource by inheriting the localization resource from another
    localization resource. In this example, we are inheriting `AbpValidationResource`,
    which is defined in ABP Framework and contains standard validation error messages.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的本地化系统相当先进。它允许您通过从另一个本地化资源继承本地化资源来重用本地化资源的文本。在本例中，我们正在继承 `AbpValidationResource`，它由
    ABP 框架定义，并包含标准的验证错误消息。
- en: The `AddVirtualJson` method is used to set the JSON files related to that resource
    using the virtual filesystem.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddVirtualJson` 方法用于通过虚拟文件系统设置与该资源相关的 JSON 文件。'
- en: Finally, `DefaultResourceType` sets the default localization resource for that
    application. You can have a default resource used in some places where you don't
    specify the localization resource. The next section explains the main usage point
    of this configuration.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DefaultResourceType` 设置了该应用程序的默认本地化资源。您可以在未指定本地化资源的地方使用默认资源。下一节将解释此配置的主要使用点。
- en: Localizing in special services
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在特殊服务中进行本地化
- en: Injecting the `IStringLocalizer<T>` service everywhere can be tedious. ABP pre-injects
    the localizer into some special base classes. When you inherit from these classes,
    you can directly use the `L` shortcut property to localize texts.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个地方注入 `IStringLocalizer<T>` 服务可能会很繁琐。ABP 预先将这些本地化器注入到一些特殊的基类中。当您从这些类继承时，您可以直接使用
    `L` 短路属性来本地化文本。
- en: 'The following example shows how to localize text in an application service
    method:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在应用程序服务方法中本地化文本：
- en: '[PRE38]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `L` property, in this example, is defined by the `ApplicationService` base
    class, so you don't need to inject the `IStringLocalizer<T>` service manually.
    You may wonder, as we haven't specified a localization resource, which one is
    used here. The answer is the `DefaultResourceType` option that was explained in
    the previous section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`L` 属性由 `ApplicationService` 基类定义，因此您不需要手动注入 `IStringLocalizer<T>` 服务。您可能会想知道，因为我们没有指定本地化资源，这里使用的是哪一个。答案是上一节中解释的
    `DefaultResourceType` 选项。
- en: 'If you want to specify another localization resource for a particular application
    service, then set the `LocalizationResource` property in the constructor of your
    service:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为特定应用程序服务指定另一个本地化资源，则请在服务的构造函数中设置 `LocalizationResource` 属性：
- en: '[PRE39]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In addition to the `ApplicationService` class, some other common base classes,
    such as `AbpController` and `AbpPageModel`, provide the same `L` property as a
    shortcut of injecting the `IStringLocalizer<T>` service.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ApplicationService` 类之外，一些其他常见的基类，如 `AbpController` 和 `AbpPageModel`，也提供了相同的
    `L` 属性，作为注入 `IStringLocalizer<T>` 服务的快捷方式。
- en: Using localization on the client side
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在客户端使用本地化
- en: One of the ABP's benefits for the localization system is that all the localization
    resources are directly usable on the client-side code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的本地化系统的一个优点是所有本地化资源都可以直接在客户端代码中使用。
- en: 'For example, the following code localizes the `WelcomeMessage` key in the JavaScript
    code for an ASP.NET Core MVC/Razor Pages application:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码在 ASP.NET Core MVC/Razor Pages 应用程序的 JavaScript 代码中将 `WelcomeMessage`
    键本地化：
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`DemoApp` is the localization resource name, and `WelcomeMessage` is the localization
    key here. Client-side localization will be covered in *Part 4*, *User Interface
    and API Development,* of this book.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemoApp` 是本地化资源名称，而 `WelcomeMessage` 是这里的本地化键。客户端本地化将在本书的 *第 4 部分*，*用户界面和
    API 开发* 中介绍。'
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some essential features that you will need in almost
    any web application.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了您几乎在所有 Web 应用程序中都需要的一些基本功能。
- en: The `ICurrentUser` service allows you to get information about the current user
    in your application. You can work with the standard claims (such as username and
    ID) and define custom claims based on your requirements.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICurrentUser` 服务允许您获取您应用程序中当前用户的信息。您可以使用标准声明（例如用户名和 ID）并根据您的需求定义自定义声明。'
- en: We have explored the data filtering system that automates filtering data while
    querying from the database. In this way, we can easily implement some patterns
    such as soft-delete and multi-tenancy. We also learned how to define custom data
    filters and disable the filters whenever necessary.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了数据过滤系统，该系统在从数据库查询数据时自动过滤数据。这样，我们可以轻松实现一些模式，如软删除和多租户。我们还学习了如何定义自定义数据过滤器，并在必要时禁用过滤器。
- en: We have understood how the audit log system works to track and save all the
    operations done by users. We can control the audit log system declaratively and
    conventionally with attributes and options.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了审计日志系统是如何跟踪和保存用户执行的所有操作的。我们可以通过属性和选项声明性和约定性地控制审计日志系统。
- en: Caching data is another essential concept to improve the performance and scalability
    of the system. We've learned about ABP's `IDistributedCache<T>` service, which
    provides a type-safe way to interact with the cache provider and automates some
    common tasks such as serialization and exception handling.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存数据是提高系统性能和可扩展性的另一个基本概念。我们学习了 ABP 的 `IDistributedCache<T>` 服务，它提供了一种类型安全的方式与缓存提供程序交互，并自动化了一些常见任务，例如序列化和异常处理。
- en: Finally, we've explored the localization infrastructure of ASP.NET Core and
    ABP Framework to define and consume localized texts in our applications easily.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了 ASP.NET Core 和 ABP 框架的本地化基础设施，以便我们可以在应用程序中轻松定义和消费本地化文本。
- en: Now we have come to the end of this chapter, we've completed *Part 2*, *Fundamentals
    of ABP Framework* of this book, covering ABP Framework and ASP.NET Core infrastructure
    fundamentals. The next part is a practical guide for implementing **domain-driven
    design** (**DDD**) using ABP Framework. DDD is one of the core concepts upon which
    ABP is based. It includes principles, patterns, and practices to build maintainable
    business solutions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达本章的结尾，我们已经完成了本书的 *第 2 部分*，*ABP 框架基础*，涵盖了 ABP 框架和 ASP.NET Core 基础设施的基本知识。下一部分是使用
    ABP 框架实现 **领域驱动设计**（**DDD**）的实用指南。DDD 是 ABP 基于的核心概念之一。它包括构建可维护业务解决方案的原则、模式和最佳实践。
