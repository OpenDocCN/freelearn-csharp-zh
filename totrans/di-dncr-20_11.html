<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Best Practices and Other Related Techniques</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The last chapter was a very interesting one as we explored Dependency Injection in different frameworks such as TypeScript, ES2015, and Angular 2. </span><span class="koboSpan" id="kobo.2.2">This is the last chapter and we are going to discuss the coding and architectural practices proved to be the best while implementing Dependency Injection in the project.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.3.1">It's obvious that, when you learn something new and try to implement it in your application, excitement might lead you to create a bad architecture. </span><span class="koboSpan" id="kobo.3.2">That would eventually lead to a bad practice because, after you code it for a few times unknowingly, it becomes a habit. </span><span class="koboSpan" id="kobo.3.3">Suppose, you get a requirement to save user details to the database. </span><span class="koboSpan" id="kobo.3.4">You will definitely send the details to the </span><kbd><span class="koboSpan" id="kobo.4.1">Service Layer</span></kbd><span class="koboSpan" id="kobo.5.1"> method which in turn would connect to the </span><kbd><span class="koboSpan" id="kobo.6.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.7.1"> method, to save the details. </span><span class="koboSpan" id="kobo.7.2">Quickly (if you are new to the application and don't know about the architecture implemented), the first thing you would do is to use the </span><kbd><span class="koboSpan" id="kobo.8.1">new</span></kbd><span class="koboSpan" id="kobo.9.1"> keyword to instantiate the dependencies and directly call the methods. </span><span class="koboSpan" id="kobo.9.2">In that way, we can't achieve loosely coupled modules. </span><span class="koboSpan" id="kobo.9.3">However, we could have designed the app and the layers in such a way that the consumers won't be able to generate coupling by any means. </span><span class="koboSpan" id="kobo.9.4">We will explore these techniques in this chapter.</span></p>
<p><span class="koboSpan" id="kobo.10.1">So, exploring how to deliver your best with the concept you just learned is important for you and your app. </span><span class="koboSpan" id="kobo.10.2">For that reason, there are best practices which you should be aware of. </span><span class="koboSpan" id="kobo.10.3">Dependency Injection deals with Object Composition, Object Lifetime, and Interception as a whole, which should be ideally managed by DI Containers. </span><span class="koboSpan" id="kobo.10.4">If we try to deal with these building blocks ourselves instead of using a container to manage the dependencies, we might end up with a bad design.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Although we can choose one DI Container, designing and refactoring our code accordingly to help the container to work with our classes might be an erroneous task.</span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will touch upon these points in detail to understand the real-time problems faced during the induction of DI into the projects. </span><span class="koboSpan" id="kobo.12.2">We will learn techniques to avoid bad habits in DI.</span></p>
<p><span class="koboSpan" id="kobo.13.1">We will discuss the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Best practices and recommendations in Dependency Injection</span></li>
<li><span class="koboSpan" id="kobo.15.1">Some recommended techniques to remove tight coupling</span></li>
<li><span class="koboSpan" id="kobo.16.1">Refactoring and implementation of DI in legacy layered applications</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Tightly coupled systems</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Till now, we have discussed </span><em><span class="koboSpan" id="kobo.3.1">DI in .NET Core 2.0, Pillars of DI, DI Patterns, Anti-Patterns, DI in other frameworks</span></em><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Someone who is new to the DI concept might do make mistakes and it's normal. </span><span class="koboSpan" id="kobo.4.3">We will see more of such scenarios in upcoming sections. </span><span class="koboSpan" id="kobo.4.4">Before that, let's analyze something which you might find more often in ASP.NET MVC projects. </span><span class="koboSpan" id="kobo.4.5">If you don't, ask your colleagues and friends. </span><span class="koboSpan" id="kobo.4.6">You will definitely see such instances.</span></p>
<p><span><span class="koboSpan" id="kobo.5.1">Let's see one simple controller without DI implemented and learn how to refactor that so that it will respect the principles of</span></span> <em><span class="koboSpan" id="kobo.6.1">Inversion of Control</span></em><span class="koboSpan" id="kobo.7.1">.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.8.1">Inversion of Control states </span><em><span class="koboSpan" id="kobo.9.1">Do not call us we will call you</span></em><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">When a class tries to instantiate another class inside it, it basically creates a coupling with the second class. </span><span class="koboSpan" id="kobo.10.3">Now the first class creation depends on the second class.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.11.1">If the second class fails, for any reason, we won't be able to get the instance of the first class, as the constructor will break:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="195" width="438" src="assets/62615398-6b59-4eb3-8657-451926cf6fe7.png"/></span></div>
<p class="mce-root"><span><span class="koboSpan" id="kobo.13.1">The </span><strong><span class="koboSpan" id="kobo.14.1">Someone</span></strong><span class="koboSpan" id="kobo.15.1"> in the picture can be an IoC Container.</span></span><br/><span class="koboSpan" id="kobo.16.1">
I would strongly recommend Mr. </span><span class="koboSpan" id="kobo.16.2">Shivprasad Koirala's article, if you want to grasp this concept in depth. </span><span class="koboSpan" id="kobo.16.3">Here is the link--</span><a href="https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency"><span class="koboSpan" id="kobo.17.1">https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency</span></a><span class="koboSpan" id="kobo.18.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following diagram depicts what we are going to do now. </span><span class="koboSpan" id="kobo.2.2">We will have a </span><strong><span class="koboSpan" id="kobo.3.1">Controller</span></strong><span class="koboSpan" id="kobo.4.1"> depending on a </span><strong><span class="koboSpan" id="kobo.5.1">Service</span></strong><span class="koboSpan" id="kobo.6.1">, which in turn depends on a </span><strong><span class="koboSpan" id="kobo.7.1">Repository</span></strong><span class="koboSpan" id="kobo.8.1"> for data:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"><img height="100" width="396" src="assets/2a6cbf62-357a-46b5-9785-14b3fb11853a.png"/></span></div>
<p><span class="koboSpan" id="kobo.10.1">First of all, let's think of a simple controller and how that is generally implemented in projects. </span><span class="koboSpan" id="kobo.10.2">The following is a simple </span><kbd><span class="koboSpan" id="kobo.11.1">UsersController</span></kbd><span class="koboSpan" id="kobo.12.1"> which has an action method </span><kbd><span class="koboSpan" id="kobo.13.1">Edit</span></kbd><span class="koboSpan" id="kobo.14.1">:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    public class UsersController : Controller</span><br/><span class="koboSpan" id="kobo.16.1">    {</span><br/><span class="koboSpan" id="kobo.17.1">      public IActionResult Edit(int userId)</span><br/><span class="koboSpan" id="kobo.18.1">      {</span><br/><span class="koboSpan" id="kobo.19.1">        var usersService = new UsersService();</span><br/><span class="koboSpan" id="kobo.20.1">        return View(usersService.GetUser(userId));</span><br/><span class="koboSpan" id="kobo.21.1">      }</span><br/><span class="koboSpan" id="kobo.22.1">    } </span></pre>
<p><span class="koboSpan" id="kobo.23.1">The following are the conclusions (more accurately the problems), which can be made from the preceding code block:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.24.1">UsersController</span></kbd><span class="koboSpan" id="kobo.25.1"> instantiates </span><kbd><span class="koboSpan" id="kobo.26.1">UsersService</span></kbd><span class="koboSpan" id="kobo.27.1"> using the </span><kbd><span class="koboSpan" id="kobo.28.1">new</span></kbd><span class="koboSpan" id="kobo.29.1"> keyword (creates an instance of a concrete class)</span></li>
<li><span><kbd><span class="koboSpan" id="kobo.30.1">UsersController</span></kbd><span class="koboSpan" id="kobo.31.1"> is tightly coupled with </span><kbd><span class="koboSpan" id="kobo.32.1">UsersService</span></kbd></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">As far as our knowledge from other chapters is concerned, we should definitely avoid both of the preceding points. </span><span class="koboSpan" id="kobo.33.2">This makes Unit Testing difficult. </span><span class="koboSpan" id="kobo.33.3">DI principles encourage us to utilize the area of the Composition Root to register all required classes/dependencies (such as </span><kbd><span class="koboSpan" id="kobo.34.1">UsersService</span></kbd><span class="koboSpan" id="kobo.35.1">) and then use a DI container to resolve the instances instead of using the </span><kbd><span class="koboSpan" id="kobo.36.1">new</span></kbd><span class="koboSpan" id="kobo.37.1"> keyword whenever required.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Next is </span><kbd><span class="koboSpan" id="kobo.39.1">UsersService</span></kbd><span class="koboSpan" id="kobo.40.1">, which might look something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.41.1">    public class UsersService</span><br/><span class="koboSpan" id="kobo.42.1">    {</span><br/><span class="koboSpan" id="kobo.43.1">      private readonly UsersRepository _usersRepository;</span><br/><span class="koboSpan" id="kobo.44.1">      public UsersService()</span><br/><span class="koboSpan" id="kobo.45.1">      {</span><br/><span class="koboSpan" id="kobo.46.1">        _usersRepository = </span><strong><span class="koboSpan" id="kobo.47.1">new UsersRepository();</span><br/><span class="koboSpan" id="kobo.48.1">        // Concrete Class Dependency</span></strong><br/><span class="koboSpan" id="kobo.49.1">      }</span><br/><span class="koboSpan" id="kobo.50.1">      public User GetUser(int userId) =&gt; _usersRepository.GetUser(userId);</span><br/><span class="koboSpan" id="kobo.51.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.52.1">Yet another concrete dependency with </span><kbd><span class="koboSpan" id="kobo.53.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.54.1">. </span><kbd><span class="koboSpan" id="kobo.55.1">UsersService</span></kbd><span class="koboSpan" id="kobo.56.1"> now does the same kind of stuff as we saw in the case of the controller. </span><span class="koboSpan" id="kobo.56.2">In this example, the service is trying to pass the data returned from the repository. </span><span class="koboSpan" id="kobo.56.3">But in reality, it might do a lot of things. </span><span class="koboSpan" id="kobo.56.4">The important aspect here is how we are managing our dependencies inside a class which might get uglier as we build a complex system in the future. </span><span class="koboSpan" id="kobo.56.5">The exercise we are doing now is just to point out the problem, so don't go by the simplicity of the structure.</span></p>
<p><span class="koboSpan" id="kobo.57.1">The repository would look like the following:</span></p>
<pre><span class="koboSpan" id="kobo.58.1">    public class UsersRepository</span><br/><span class="koboSpan" id="kobo.59.1">    {</span><br/><span class="koboSpan" id="kobo.60.1">      public User GetUser(int userId) =&gt; new </span><br/><span class="koboSpan" id="kobo.61.1">         DataContext().Users.SingleOrDefault(u =&gt; u.UserId == userId);</span><br/><span class="koboSpan" id="kobo.62.1">      // You can just return a demo user like: </span><br/><span class="koboSpan" id="kobo.63.1">      // new User { UserId = 1, UserName = "Tadit" };</span><br/><span class="koboSpan" id="kobo.64.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.65.1">The following diagram explains what has been done so far:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.66.1"><img height="175" width="493" src="assets/f1e7fe9d-fda2-48ee-989f-a17cc250d795.png"/></span></div>
<p><span class="koboSpan" id="kobo.67.1">Everything stops here. </span><span class="koboSpan" id="kobo.67.2">This is the last in the queue. </span><span class="koboSpan" id="kobo.67.3">It gets the data from the </span><kbd><span class="koboSpan" id="kobo.68.1">Users</span></kbd><span class="koboSpan" id="kobo.69.1"> table and sends it back to the client. </span><span class="koboSpan" id="kobo.69.2">This architecture works, but there are shortcomings which might get worse as you progress:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.70.1">Unit testing is not easy as the classes are tightly coupled with each other. </span><span class="koboSpan" id="kobo.70.2">For instance, </span><kbd><span class="koboSpan" id="kobo.71.1">UsersController</span></kbd><span class="koboSpan" id="kobo.72.1"> depends on </span><kbd><span class="koboSpan" id="kobo.73.1">UsersService</span></kbd><span class="koboSpan" id="kobo.74.1">, which in turn depends upon </span><kbd><span class="koboSpan" id="kobo.75.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.76.1">, and then, at last, it deals with the database, while unit testing might fail due to database interactions.</span></li>
<li><span class="koboSpan" id="kobo.77.1">If this architecture grows and becomes a fully fledged application, then maintenance becomes difficult as the classes are wound up with dependencies all over which will be difficult to identify and manage.</span></li>
<li><span class="koboSpan" id="kobo.78.1">There is no technique/method by which we can easily modify the dependencies. </span><span class="koboSpan" id="kobo.78.2">Suppose we want to implement another class for a service named </span><kbd><span class="koboSpan" id="kobo.79.1">UsersNewService</span></kbd><span class="koboSpan" id="kobo.80.1"> and we want to use that instead of </span><kbd><span class="koboSpan" id="kobo.81.1">UsersService</span></kbd><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">It will be a tedious task as we have to identify all dependencies of </span><kbd><span class="koboSpan" id="kobo.83.1">UsersService</span></kbd><span class="koboSpan" id="kobo.84.1"> and then change them everywhere.</span></li>
<li><span class="koboSpan" id="kobo.85.1">Moreover, the concrete service reference might fail in certain circumstances where the method signatures may vary across different classes. </span><span class="koboSpan" id="kobo.85.2">For example, the </span><kbd><span class="koboSpan" id="kobo.86.1">GetUser</span></kbd><span class="koboSpan" id="kobo.87.1"> method in both of these service classes may vary in the signature, making the developer's life difficult as you have to modify the </span><kbd><span class="koboSpan" id="kobo.88.1">GetUser</span></kbd><span class="koboSpan" id="kobo.89.1"> caller methods as well, including service reference changes.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.90.1">These flaws not only describe a poorly </span><span><span class="koboSpan" id="kobo.91.1">architected project but also become a developer's nightmare to refactor and maintain.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The solution - refactoring with DI</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we all know, the Dependency Inversion Principle states the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">High-level modules should not depend on low-level modules. </span><span class="koboSpan" id="kobo.3.2">Both should depend on </span><strong><span class="koboSpan" id="kobo.4.1">abstractions</span></strong><span class="koboSpan" id="kobo.5.1">.</span></li>
<li><span class="koboSpan" id="kobo.6.1">Abstractions should not depend on details. </span><span class="koboSpan" id="kobo.6.2">Details should depend on abstractions.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">Therefore, let's design the interfaces to abstract out the concrete classes.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Start from the last one in the hierarchy, which is the repository:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"><img height="49" width="325" src="assets/7487ff3b-e86b-480e-a7ac-5520ffbc3fd5.png"/></span></div>
<p><span class="koboSpan" id="kobo.10.1">The abstraction for the repository would look like the following:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    public interface IUsersRepository</span><br/><span class="koboSpan" id="kobo.12.1">    {</span><br/><span class="koboSpan" id="kobo.13.1">      User GetUser(int userId);</span><br/><span class="koboSpan" id="kobo.14.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.15.1">So, </span><kbd><span class="koboSpan" id="kobo.16.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.17.1"> would implement </span><kbd><span class="koboSpan" id="kobo.18.1">IUsersRepository</span></kbd><span class="koboSpan" id="kobo.19.1"> as follows:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    public class UsersRepository : IUsersRepository</span><br/><span class="koboSpan" id="kobo.21.1">    {</span><br/><span class="koboSpan" id="kobo.22.1">      public User GetUser(int userId)  =&gt; new </span><br/><span class="koboSpan" id="kobo.23.1">        DataContext().Users.SingleOrDefault(u =&gt; u.UserId == userId);</span><br/><span class="koboSpan" id="kobo.24.1">      // You can just return a demo user like:</span><br/><span class="koboSpan" id="kobo.25.1">      // new User { UserId = 1, UserName = "Tadit" }; </span><br/><span class="koboSpan" id="kobo.26.1">    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Interface extraction</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Do you know how easy it is to extract an interface out of a class? </span><span class="koboSpan" id="kobo.2.2">It's very easy and effective with Visual Studio. </span><span class="koboSpan" id="kobo.2.3">Let's see the following steps:</span></p>
<ol>
<li class="mce-root"><span class="koboSpan" id="kobo.3.1">Hover on the concrete class; you will see a bulb at the left side.</span></li>
<li><span class="koboSpan" id="kobo.4.1">Click on that to open a drop-down menu. </span><span class="koboSpan" id="kobo.4.2">Refer to the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1">                      </span><span class="koboSpan" id="kobo.6.1"><img height="191" width="562" src="assets/0a1663e5-99b6-41d1-9af6-3d7527067b01.png"/></span></div>
<ol start="3">
<li><span class="koboSpan" id="kobo.7.1">Select the </span><kbd><span class="koboSpan" id="kobo.8.1">Extract</span></kbd><span class="koboSpan" id="kobo.9.1"> Interface.</span></li>
<li><span class="koboSpan" id="kobo.10.1">A modal pops up which also lists the public members of the class. </span><span class="koboSpan" id="kobo.10.2">See the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1">                      </span><span class="koboSpan" id="kobo.12.1"><img style="font-size: 1em" height="315" width="381" src="assets/4ee3d902-fa21-4d9c-919a-7eda2914b586.png"/></span></div>
<ol start="5">
<li><span class="koboSpan" id="kobo.13.1">Hit </span><span class="packt_screen"><span class="koboSpan" id="kobo.14.1">OK</span></span><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">It will create the interface for you.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.16.1">There is another way to extract an interface. </span><span class="koboSpan" id="kobo.16.2">You can write the interface name and then do a </span><em><span class="koboSpan" id="kobo.17.1">Ctrl</span></em><span class="koboSpan" id="kobo.18.1"> + </span><em><span class="koboSpan" id="kobo.19.1">.</span></em><span class="koboSpan" id="kobo.20.1"> (dot) so that the option bubble appears. </span><span class="koboSpan" id="kobo.20.2">You need to select either of the top two options to generate the interface:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1"><img src="assets/1fc8f6e0-c1f6-4ecc-b9a3-6ae91d585fa9.png"/></span></div>
<p class="mce-root"><span class="koboSpan" id="kobo.22.1">However, there is a difference in comparison to the first approach; its marked with the red block. </span><span class="koboSpan" id="kobo.22.2">If you select either of the </span><kbd><span class="koboSpan" id="kobo.23.1">Generate</span></kbd><span class="koboSpan" id="kobo.24.1"> options shown in the screenshot, it will create a block for interface with a blank block without any code inside it (indicated inside the red block). </span><span class="koboSpan" id="kobo.24.2">However, in the first case, we had the opportunity to select the public members to include them in the interface. </span><span class="koboSpan" id="kobo.24.3">Imagine a huge class with lots of public members. </span><span class="koboSpan" id="kobo.24.4">Undoubtedly, the first approach wins for obvious reasons as previously described.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.25.1">Alright. </span><span class="koboSpan" id="kobo.25.2">Now we can modify the </span><kbd><span class="koboSpan" id="kobo.26.1">UsersService</span></kbd><span class="koboSpan" id="kobo.27.1"> to inject the repository as a dependency instead of instantiating using the </span><kbd><span class="koboSpan" id="kobo.28.1">new</span></kbd><span class="koboSpan" id="kobo.29.1"> keyword inside the constructor. </span><span class="koboSpan" id="kobo.29.2">The </span><kbd><span class="koboSpan" id="kobo.30.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.31.1"> interface can be designed as we did for the repository in order to use it inside the controller, which we will see in a while:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.32.1"><img height="52" width="345" src="assets/05c82b32-7b0b-461c-907c-2ba6bdfe3bf9.png"/></span></div>
<p><kbd><span class="koboSpan" id="kobo.33.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.34.1"> is just a simple interface with </span><kbd><span class="koboSpan" id="kobo.35.1">GetUser</span></kbd><span class="koboSpan" id="kobo.36.1"> as a public member:</span></p>
<pre><span class="koboSpan" id="kobo.37.1">  public interface IUsersService</span><br/><span class="koboSpan" id="kobo.38.1">  {</span><br/><span class="koboSpan" id="kobo.39.1">    User GetUser(int userId);</span><br/><span class="koboSpan" id="kobo.40.1">  }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.41.1">UsersService</span></kbd><span class="koboSpan" id="kobo.42.1"> can be modified now to implement </span><kbd><span class="koboSpan" id="kobo.43.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">Injection can be done using the Constructor Injection pattern to inject the </span><kbd><span class="koboSpan" id="kobo.45.1">IUserRepository</span></kbd><span class="koboSpan" id="kobo.46.1"> dependency:</span></p>
<pre><span class="koboSpan" id="kobo.47.1">    public class UsersService : </span><strong><span class="koboSpan" id="kobo.48.1">IUsersService // Abstraction</span></strong><br/><span class="koboSpan" id="kobo.49.1">    {</span><br/><strong><span class="koboSpan" id="kobo.50.1">      private readonly IUsersRepository _usersRepository;</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">      public UsersService(IUsersRepository </span><br/><span class="koboSpan" id="kobo.52.1">         usersRepository) // Constructor Injection</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">      {</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">        _usersRepository = usersRepository;</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">      }</span></strong><br/><span class="koboSpan" id="kobo.56.1">       public User GetUser(int userId) =&gt; _usersRepository.GetUser(userId);</span><br/><span class="koboSpan" id="kobo.57.1">    }</span></pre>
<p class="mce-root"><span><span class="koboSpan" id="kobo.58.1">This change will trigger a modification to the controller; otherwise the compiler would complain. </span><span class="koboSpan" id="kobo.58.2">Let's make the compiler happy:</span></span></p>
<pre><span class="koboSpan" id="kobo.59.1">    public IActionResult Edit(int userId)</span><br/><span class="koboSpan" id="kobo.60.1">    {</span><br/><strong><span class="koboSpan" id="kobo.61.1">    var usersService = new UsersService(new UsersRepository());</span></strong><br/><span class="koboSpan" id="kobo.62.1">    return View(usersService.GetUser(userId));</span><br/><span class="koboSpan" id="kobo.63.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.64.1">We can now inject/insert the repository instance to the service inside the controller action </span><kbd><span class="koboSpan" id="kobo.65.1">Edit</span></kbd><span class="koboSpan" id="kobo.66.1">.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.67.1">So far, we have eliminated one concrete reference from the architecture that is from the </span><kbd><span class="koboSpan" id="kobo.68.1">UsersService</span></kbd><span class="koboSpan" id="kobo.69.1"> class. </span><span class="koboSpan" id="kobo.69.2">It's very important to understand our goal. </span><span class="koboSpan" id="kobo.69.3">We are actually trying to get every dependency in one place so that the design gets simplified. </span><span class="koboSpan" id="kobo.69.4">Thus, with minimal change, we can easily inject different types of dependency into the system.</span></div>
<p><span class="koboSpan" id="kobo.70.1">For example, our </span><kbd><span class="koboSpan" id="kobo.71.1">UsersService</span></kbd><span class="koboSpan" id="kobo.72.1"> is now taking responsibility for managing the </span><kbd><span class="koboSpan" id="kobo.73.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.74.1"> dependency instead of the service managing it internally with a tight coupling.</span></p>
<p><span class="koboSpan" id="kobo.75.1">However, we are still not done. </span><span class="koboSpan" id="kobo.75.2">We have another clearly visible dependency in the controller instantiated using the </span><kbd><span class="koboSpan" id="kobo.76.1">new</span></kbd><span class="koboSpan" id="kobo.77.1"> keyword inside the action </span><kbd><span class="koboSpan" id="kobo.78.1">Edit</span></kbd><span class="koboSpan" id="kobo.79.1"> and that is none other than the </span><kbd><span class="koboSpan" id="kobo.80.1">UsersService</span></kbd><span class="koboSpan" id="kobo.81.1">.</span></p>
<p><span class="koboSpan" id="kobo.82.1">The refactored injectible </span><kbd><span class="koboSpan" id="kobo.83.1">UsersController</span></kbd><span class="koboSpan" id="kobo.84.1"> would look like the following:</span></p>
<pre><span class="koboSpan" id="kobo.85.1">    public class UsersController : Controller</span><br/><span class="koboSpan" id="kobo.86.1">    {</span><br/><strong><span class="koboSpan" id="kobo.87.1">      private readonly IUsersService _usersService;</span></strong><br/><strong><span class="koboSpan" id="kobo.88.1">      public UsersController(IUsersService usersService) // </span><br/><span class="koboSpan" id="kobo.89.1">        Constructor Injection</span></strong><br/><strong><span class="koboSpan" id="kobo.90.1">      {</span></strong><br/><strong><span class="koboSpan" id="kobo.91.1">        _usersService = usersService;</span></strong><br/><strong><span class="koboSpan" id="kobo.92.1">      }</span><br/></strong><br/><span class="koboSpan" id="kobo.93.1">      public IActionResult Edit(int userId)</span><br/><span class="koboSpan" id="kobo.94.1">      {</span><br/><strong><span class="koboSpan" id="kobo.95.1">        // We commented out the following line and used</span><br/><span class="koboSpan" id="kobo.96.1">        // private member _usersService instead.</span></strong><br/><span class="koboSpan" id="kobo.97.1">        //var userService = new UsersService(new UsersRepository());</span><br/><span class="koboSpan" id="kobo.98.1">        return View(</span><strong><span class="koboSpan" id="kobo.99.1">_usersService.GetUser(userId)</span></strong><span class="koboSpan" id="kobo.100.1">);</span><br/><span class="koboSpan" id="kobo.101.1">      }</span><br/><span class="koboSpan" id="kobo.102.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.103.1">Simple, isn't it? </span><span class="koboSpan" id="kobo.103.2">Constructor Injection again comes to our rescue and allows us to inject the service so that we can use it for further operations.</span></p>
<p><span class="koboSpan" id="kobo.104.1">Awesome, now we removed all dependencies. </span><span class="koboSpan" id="kobo.104.2">Go ahead and run the app:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.105.1"><img height="38" width="672" src="assets/57020285-5416-42e4-b3e2-57a2503a9318.png"/></span></div>
<p><span class="koboSpan" id="kobo.106.1">Unfortunately, it threw an exception. </span><span class="koboSpan" id="kobo.106.2">It isn't a surprise. </span><span class="koboSpan" id="kobo.106.3">The framework would expect one parameter less constructor inside the controller which we don't have anymore and then it found one parameterized constructor accepting the </span><kbd><span class="koboSpan" id="kobo.107.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.108.1"> implementation instance which was never provided anywhere in the app. </span><span class="koboSpan" id="kobo.108.2">Thus, the exception was formulated.</span></p>
<p><span class="koboSpan" id="kobo.109.1">Okay, I know what you are thinking. </span><span class="koboSpan" id="kobo.109.2">Adding one parameter less or default constructor won't change the scene. </span><span class="koboSpan" id="kobo.109.3">Rather it will show the following in the browser:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.110.1"><img height="39" width="638" src="assets/5fc28848-c597-42cc-9482-e8261406f8d4.png"/></span></div>
<p><span class="koboSpan" id="kobo.111.1">Moreover, DI does not recommend using multiple constructors, so that is not an option anyway.</span></p>
<p><span class="koboSpan" id="kobo.112.1">Before we go ahead with the solution, let me summarise what we have done so far.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.113.1">We created abstractions for concrete classes</span></li>
<li><span class="koboSpan" id="kobo.114.1">We replaced new keywords with constructors injected with abstractions</span></li>
<li><span class="koboSpan" id="kobo.115.1">In the process, we also modified the default constructor of </span><kbd><span class="koboSpan" id="kobo.116.1">UsersController</span></kbd><span class="koboSpan" id="kobo.117.1"> to inject the </span><kbd><span class="koboSpan" id="kobo.118.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.119.1"> dependency</span></li>
</ul>
<p><span class="koboSpan" id="kobo.120.1">However, we received exceptions. </span><span class="koboSpan" id="kobo.120.2">That is because we have neither instantiated any implementation of the </span><kbd><span class="koboSpan" id="kobo.121.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.122.1"> interface nor provided it to the constructor.</span></p>
<p><span class="koboSpan" id="kobo.123.1">We need to do two more things to make the app run. </span><span class="koboSpan" id="kobo.123.2">That is to let the compiler know what the implementations of the following are:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.124.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.125.1"> interface</span></li>
<li><kbd><span class="koboSpan" id="kobo.126.1">IUsersRepository</span></kbd><span class="koboSpan" id="kobo.127.1"> interface</span></li>
</ul>
<p><span class="koboSpan" id="kobo.128.1">That can be done with an IoC Container. </span><span class="koboSpan" id="kobo.128.2">As we are on .NET Core 2.0, let's use the built-in container and see what happens. </span><span class="koboSpan" id="kobo.128.3">The </span><kbd><span class="koboSpan" id="kobo.129.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.130.1"> method of the </span><kbd><span class="koboSpan" id="kobo.131.1">Startup</span></kbd><span class="koboSpan" id="kobo.132.1"> class would look like the following:</span></p>
<pre><span class="koboSpan" id="kobo.133.1">    public void ConfigureServices(IServiceCollection services)</span><br/><span class="koboSpan" id="kobo.134.1">    {</span><br/><span class="koboSpan" id="kobo.135.1">    services.AddTransient&lt;IUsersService, UsersService&gt;()</span><br/><span class="koboSpan" id="kobo.136.1">            .AddTransient&lt;IUsersRepository, UsersRepository&gt;();</span><br/><span class="koboSpan" id="kobo.137.1">    services.AddMvc();</span><br/><span class="koboSpan" id="kobo.138.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.139.1">Let's run the app now:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.140.1"><img height="474" width="275" src="assets/b96498fe-fcd1-4546-9f01-953678456324.png"/></span></div>
<p><span class="koboSpan" id="kobo.141.1">Finally, it runs. </span><span class="koboSpan" id="kobo.141.2">Everything is perfect and we got the output in the browser, thanks to the DI engine of .NET Core and yes, of course, to the progress you have made so far with the book.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.142.1">We did a fabulous job in refactoring the classes to inject dependencies instead of referring concrete classes which were inefficient and not maintainable. </span><span class="koboSpan" id="kobo.142.2">Still, the tight coupling is not totally eliminated. </span><span class="koboSpan" id="kobo.142.3">The service is still returning a database model class </span><kbd><span class="koboSpan" id="kobo.143.1">User</span></kbd><span class="koboSpan" id="kobo.144.1"> instance to the controller.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.145.1">Imagine a three-layered architecture, where the layers can be the </span><kbd><span class="koboSpan" id="kobo.146.1">ASP.NET MVC Web App Layer</span></kbd><span class="koboSpan" id="kobo.147.1">, </span><kbd><span class="koboSpan" id="kobo.148.1">Service/Business Layer</span></kbd><span class="koboSpan" id="kobo.149.1">, and </span><kbd><span class="koboSpan" id="kobo.150.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">If a developer uses the model classes directly in the presentation layer (</span><kbd><span class="koboSpan" id="kobo.152.1">ASP.NET MVC Web App Layer</span></kbd><span class="koboSpan" id="kobo.153.1">), that means it is tightly coupled and can't live without a reference to the </span><kbd><span class="koboSpan" id="kobo.154.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.155.1"> in the project. </span><span class="koboSpan" id="kobo.155.2">In the next section, we will see such a problem and try to refactor it to DI.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Layered architecture</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">In a typical modern ASP.NET MVC web app, you will find a three-layered architecture with isolated components depending on each other as shown in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="72" width="368" src="assets/877c5277-733d-409e-8e5e-ef8fffdb14ff.png"/></span></div>
<p><span class="koboSpan" id="kobo.4.1">When we say some layer depends on another, that means the layer that depends, needs instances of the dependency objects to perform certain operations. </span><span class="koboSpan" id="kobo.4.2">As we saw in the previous section, to get a user from the database, the controller was asking the service to provide it from the repository. </span><span class="koboSpan" id="kobo.4.3">Thus, we can easily separate the classes and package them as components or a class library, speaking technically.</span></p>
<p><span class="koboSpan" id="kobo.5.1">That means my controller remains in </span><kbd><span class="koboSpan" id="kobo.6.1">UI Layer</span></kbd><span class="koboSpan" id="kobo.7.1"> or </span><kbd><span class="koboSpan" id="kobo.8.1">Presentation Layer</span></kbd><span class="koboSpan" id="kobo.9.1">, </span><kbd><span class="koboSpan" id="kobo.10.1">Service Class</span></kbd><span class="koboSpan" id="kobo.11.1"> make another layer who talks to the database through </span><kbd><span class="koboSpan" id="kobo.12.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.13.1"> classes. </span><span class="koboSpan" id="kobo.13.2">Now, as we chose Dependency Injection Technique to manage the dependencies, it's the responsibility of the IoC Container to provide the dependent </span><kbd><span class="koboSpan" id="kobo.14.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.15.1"> objects to the </span><kbd><span class="koboSpan" id="kobo.16.1">Service Layer</span></kbd><span class="koboSpan" id="kobo.17.1">, and </span><kbd><span class="koboSpan" id="kobo.18.1">Service Layer</span></kbd><span class="koboSpan" id="kobo.19.1"> objects to the UI Layer. </span><span class="koboSpan" id="kobo.19.2">Most importantly, it takes the control from each layer for object creation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The problem - The concrete class reference again</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">I think you may not have noticed one thing in the last section. </span><span class="koboSpan" id="kobo.2.2">We tried to decouple the system as far as we could. </span><span class="koboSpan" id="kobo.2.3">But we have not totally achieved a loosely coupled architecture. </span><span class="koboSpan" id="kobo.2.4">Let me explain in the next paragraph.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Composition Root is the place where we register all the dependencies to be used by the application. </span><span class="koboSpan" id="kobo.3.2">The </span><kbd><span class="koboSpan" id="kobo.4.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.5.1"> method in the </span><kbd><span class="koboSpan" id="kobo.6.1">Startup</span></kbd><span class="koboSpan" id="kobo.7.1"> class was the location of this dependency registration as we saw:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">    services.AddTransient&lt;IUsersService, UsersService&gt;()</span><br/><span class="koboSpan" id="kobo.9.1">    .AddTransient&lt;IUsersRepository, UsersRepository&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.10.1">Notice that we are saying, take the </span><kbd><span class="koboSpan" id="kobo.11.1">UsersService</span></kbd><span class="koboSpan" id="kobo.12.1"> instance when </span><kbd><span class="koboSpan" id="kobo.13.1">IUserService</span></kbd><span class="koboSpan" id="kobo.14.1"> dependency is required and the </span><kbd><span class="koboSpan" id="kobo.15.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.16.1"> instance when </span><kbd><span class="koboSpan" id="kobo.17.1">IUsersRepository</span></kbd><span class="koboSpan" id="kobo.18.1"> is required. </span><span class="koboSpan" id="kobo.18.2">So, basically, we now have to get the assembly references of both </span><kbd><span class="koboSpan" id="kobo.19.1">Service Layer</span></kbd><span class="koboSpan" id="kobo.20.1"> and </span><kbd><span class="koboSpan" id="kobo.21.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.22.1"> in order to run this code without compilation issues. </span><span class="koboSpan" id="kobo.22.2">Check out the following screenshot, which proves what I just said:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.23.1"><img height="435" width="349" src="assets/d51c44e6-078c-46d8-95ee-81e4513f18c8.png"/></span></div>
<p><span><span class="koboSpan" id="kobo.24.1">Whatever classes we have designed so far are just separated out in these three layers. </span><span class="koboSpan" id="kobo.24.2">The repository is in the </span><kbd><span class="koboSpan" id="kobo.25.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.26.1"> and the service is inside the </span><kbd><span class="koboSpan" id="kobo.27.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Clearly, you can see there is a </span><kbd><span class="koboSpan" id="kobo.30.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.31.1"> assembly reference in the UI Layer. </span><span class="koboSpan" id="kobo.31.2">As the </span><kbd><span class="koboSpan" id="kobo.32.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.33.1"> has a reference to the </span><kbd><span class="koboSpan" id="kobo.34.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.35.1">, so automatically it is carried over to the UI Layer.</span></p>
<p><span class="koboSpan" id="kobo.36.1">Due to this, the </span><kbd><span class="koboSpan" id="kobo.37.1">Presentation Layer</span></kbd><span class="koboSpan" id="kobo.38.1"> now has access to various implementations of the </span><kbd><span class="koboSpan" id="kobo.39.1">Service Layer</span></kbd><span class="koboSpan" id="kobo.40.1"> and </span><kbd><span class="koboSpan" id="kobo.41.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">This is a very bad coding practice as we are trying to violate the layered architecture concept altogether. </span><span class="koboSpan" id="kobo.42.3">There is no separation existing between the layers. </span><span class="koboSpan" id="kobo.42.4">Moreover, developers can misuse the concrete class implementations, as they have direct access due to the assembly reference. </span><span class="koboSpan" id="kobo.42.5">This is not acceptable at all.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Misuse of business and Data Access Layer assemblies</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">Here we will discuss how we, as developers, could misuse the layers in the code by direct reference to the layers. </span></span><span class="koboSpan" id="kobo.3.1">Let's try to understand a few scenarios where these assemblies can be misused in the </span><kbd><span class="koboSpan" id="kobo.4.1">UI Layer</span></kbd><span class="koboSpan" id="kobo.5.1">:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.6.1">Direct Business Layer Service Access</span></strong><span class="koboSpan" id="kobo.7.1">: As we have a reference of </span><kbd><span class="koboSpan" id="kobo.8.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.9.1">, so we can instantiate it and then call the </span><kbd><span class="koboSpan" id="kobo.10.1">GetUser()</span></kbd><span class="koboSpan" id="kobo.11.1"> method. </span><span class="koboSpan" id="kobo.11.2">We needed a </span><kbd><span class="koboSpan" id="kobo.12.1">Repository</span></kbd><span class="koboSpan" id="kobo.13.1"> instance for the </span><kbd><span class="koboSpan" id="kobo.14.1">Service</span></kbd><span class="koboSpan" id="kobo.15.1"> constructor, which we can also easily provide.</span></li>
</ul>
<pre><span class="koboSpan" id="kobo.16.1">    public IActionResult Edit(int userId)</span><br/><span class="koboSpan" id="kobo.17.1">    {</span><br/><span class="koboSpan" id="kobo.18.1">      UsersService service = new UsersService(new UsersRepository());</span><br/><span class="koboSpan" id="kobo.19.1">      return View(service.GetUser(userId));</span><br/><span class="koboSpan" id="kobo.20.1">    }</span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">Notice how we can easily instantiate the </span><kbd><span class="koboSpan" id="kobo.22.1">UsersService</span></kbd><span class="koboSpan" id="kobo.23.1"> class by passing the </span><kbd><span class="koboSpan" id="kobo.24.1">Repository</span></kbd><span class="koboSpan" id="kobo.25.1"> instance to its constructor. </span><span class="koboSpan" id="kobo.25.2">That means we still love the </span><kbd><span class="koboSpan" id="kobo.26.1">new</span></kbd><span class="koboSpan" id="kobo.27.1"> keyword.</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.28.1">Direct Data Access Repository Access</span></strong><span class="koboSpan" id="kobo.29.1">: Why go through </span><kbd><span class="koboSpan" id="kobo.30.1">Service</span></kbd><span class="koboSpan" id="kobo.31.1"> when we have the </span><kbd><span class="koboSpan" id="kobo.32.1">Data Access</span></kbd><span class="koboSpan" id="kobo.33.1"> reference? </span><span class="koboSpan" id="kobo.33.2">Why not directly deal with the Repository to get the data? </span><span class="koboSpan" id="kobo.33.3">Cool isn't it!</span></li>
</ul>
<pre><span><span class="koboSpan" id="kobo.34.1">    public IActionResult Edit(int userId)</span></span><br/><span><span class="koboSpan" id="kobo.35.1">    {</span></span><br/><span><span class="koboSpan" id="kobo.36.1">      UsersRepository repo = </span></span><strong><span class="koboSpan" id="kobo.37.1">new</span></strong><span><span class="koboSpan" id="kobo.38.1"> UsersRepository();</span></span><br/><span><span class="koboSpan" id="kobo.39.1">      return View(repo.GetUser(userId));</span><br/></span><span><span class="koboSpan" id="kobo.40.1">    }</span></span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.41.1">Yet another </span><kbd><span class="koboSpan" id="kobo.42.1">new</span></kbd><span class="koboSpan" id="kobo.43.1"> keyword usage.</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.44.1">Direct Data Layer Context Access</span></strong><span class="koboSpan" id="kobo.45.1">: Even better is the following approach where we don't even need these intermediate </span><kbd><span class="koboSpan" id="kobo.46.1">Service</span></kbd><span class="koboSpan" id="kobo.47.1"> or </span><kbd><span class="koboSpan" id="kobo.48.1">Repository</span></kbd><span class="koboSpan" id="kobo.49.1"> instances. </span><span class="koboSpan" id="kobo.49.2">We can directly get data from contexts:</span></li>
</ul>
<pre><span class="koboSpan" id="kobo.50.1">        public IActionResult Edit(int userId)</span><br/><span class="koboSpan" id="kobo.51.1">        {</span><br/><span class="koboSpan" id="kobo.52.1">          return View(</span><strong><span class="koboSpan" id="kobo.53.1">new</span></strong><span class="koboSpan" id="kobo.54.1"> DataContext()</span><br/><span class="koboSpan" id="kobo.55.1">           .Users</span><br/><span class="koboSpan" id="kobo.56.1">           .SingleOrDefault(u =&gt; u.UserId == userId)</span><br/><span class="koboSpan" id="kobo.57.1">          );</span><br/><span class="koboSpan" id="kobo.58.1">        }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.59.1">DataContext</span></kbd><span class="koboSpan" id="kobo.60.1"> can provide the data directly inside the Controller Action as shown in the preceding code.</span></p>
<p><span class="koboSpan" id="kobo.61.1">We destroyed the layered architecture and the modules are not independent anymore. </span><span class="koboSpan" id="kobo.61.2">Rather the </span><kbd><span class="koboSpan" id="kobo.62.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.63.1"> and </span><kbd><span class="koboSpan" id="kobo.64.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.65.1"> are now tightly coupled with the </span><kbd><span class="koboSpan" id="kobo.66.1">UI Layer</span></kbd><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">This happened just because we had to register concrete implementations for the interfaces with the Service Collections inside the </span><kbd><span class="koboSpan" id="kobo.68.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.69.1"> method. </span><span class="koboSpan" id="kobo.69.2">For DI injection to take place, we need this registration step so that we can ask the container for dependencies whenever required.</span></p>
<p><span class="koboSpan" id="kobo.70.1">Now, we have to find a way. </span><span class="koboSpan" id="kobo.70.2">Let's discover a best practice for this kind of problem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Best practice for layered architecture</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Remember, you can do a ton of things to improve the architecture and optimize the performance whilst using DI techniques; however, you can't remove the assemblies from inside the </span><kbd><span class="koboSpan" id="kobo.3.1">bin</span></kbd><span class="koboSpan" id="kobo.4.1"> folder of the ASP.NET MVP web application. </span><span class="koboSpan" id="kobo.4.2">You need to understand that the problem lies with access to different concrete implementations of the </span><kbd><span class="koboSpan" id="kobo.5.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.6.1"> and </span><kbd><span class="koboSpan" id="kobo.7.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.8.1"> inside the </span><kbd><span class="koboSpan" id="kobo.9.1">Presentation Layer</span></kbd><span class="koboSpan" id="kobo.10.1">; as we saw how devastating it can be when developers try to play with the layers instead of properly using them.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Therefore, we need to figure out a way to overcome this situation and not allow the </span><kbd><span class="koboSpan" id="kobo.12.1">Presentation Layer</span></kbd><span class="koboSpan" id="kobo.13.1"> to access the concrete classes of other layers while being benefited by Dependency Injection. </span><span class="koboSpan" id="kobo.13.2">The solution is MEF. </span><span class="koboSpan" id="kobo.13.3">Let's explore more in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Managed Extensibility Framework (MEF)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before exploring MEF, let me summarize the problem.</span></p>
<p><strong><span class="koboSpan" id="kobo.3.1">Tight coupling:</span></strong><span class="koboSpan" id="kobo.4.1"> Concrete classes are referenced inside the </span><kbd><span class="koboSpan" id="kobo.5.1">UI Layer</span></kbd><span class="koboSpan" id="kobo.6.1"> by DI during the </span><kbd><span class="koboSpan" id="kobo.7.1">Startup</span></kbd><span class="koboSpan" id="kobo.8.1"> inside </span><kbd><span class="koboSpan" id="kobo.9.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.10.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.11.1">So, basically, we need to do some automation which enables us not to depend upon concrete classes of other layers. </span><span class="koboSpan" id="kobo.11.2">That is where MEF comes into the picture.</span></p>
<p><span class="koboSpan" id="kobo.12.1">MEF is a library for creating lightweight extensible applications. </span><span class="koboSpan" id="kobo.12.2">With the help of MEF, developers can easily build the an app to automatically bind extensions together without any configurations. </span><span><span class="koboSpan" id="kobo.13.1">There is more on MEF at </span><a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/index"><span class="koboSpan" id="kobo.14.1">https://docs.microsoft.com/en-us/dotnet/framework/mef/index</span></a></span><a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/index"><span class="koboSpan" id="kobo.15.1">.</span></a><span><a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/index"/></span></p>
<p><span class="koboSpan" id="kobo.16.1">We are not going deeply into the MEF; you can do that from the preceding link I shared. </span><span class="koboSpan" id="kobo.16.2">We just need to understand how we can solve our issue with MEF. </span><span class="koboSpan" id="kobo.16.3">For example, we have a </span><kbd><span class="koboSpan" id="kobo.17.1">Service</span></kbd><span class="koboSpan" id="kobo.18.1"> class and a </span><kbd><span class="koboSpan" id="kobo.19.1">Repository</span></kbd><span class="koboSpan" id="kobo.20.1"> class which we don't want to expose to UI for direct consumption as we saw in our preceding code snippets. </span><span class="koboSpan" id="kobo.20.2">MEF would do that for us by pulling the classes required to register the dependencies.</span></p>
<p><span class="koboSpan" id="kobo.21.1">The following diagram depicts the role MEF is going to play in our app:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="298" width="525" src="assets/84fe4a37-b067-4153-bc63-a5eed43e85ad.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">You can see we have </span><kbd><span class="koboSpan" id="kobo.24.1">ModuleInit</span></kbd><span class="koboSpan" id="kobo.25.1"> classes in every layer with one </span><kbd><span class="koboSpan" id="kobo.26.1">Init()</span></kbd><span class="koboSpan" id="kobo.27.1"> method and these classes implement a common interface called </span><kbd><span class="koboSpan" id="kobo.28.1">IModule</span></kbd><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">It's obvious that the DLLs of all the layers will be there in the </span><kbd><span class="koboSpan" id="kobo.30.1">bin</span></kbd><span class="koboSpan" id="kobo.31.1"> folder of the </span><span class="packt_screen"><span class="koboSpan" id="kobo.32.1">ASP.NET MVC Web Project.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Now the interesting scene. </span><span class="koboSpan" id="kobo.33.2">MEF gets all assemblies from the </span><kbd><span class="koboSpan" id="kobo.34.1">bin</span></kbd><span class="koboSpan" id="kobo.35.1"> folder of the App, then it does the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.36.1">Searches for the implementations of </span><kbd><span class="koboSpan" id="kobo.37.1">IModule</span></kbd><span class="koboSpan" id="kobo.38.1">.</span></li>
<li><span class="koboSpan" id="kobo.39.1">Fires the </span><kbd><span class="koboSpan" id="kobo.40.1">Init()</span></kbd><span class="koboSpan" id="kobo.41.1"> method of each found module.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.42.1">In the next section, we will see the codes in different layers and how MEF can bring back loosely coupled modules to optimise the architecture.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Layers and MEF implementation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before going into the code in some depth, let's first analyze the layers. </span><span class="koboSpan" id="kobo.2.2">So, there are three layers.</span></p>
<ol>
<li><strong><span class="koboSpan" id="kobo.3.1">Web App Layer:</span></strong><span class="koboSpan" id="kobo.4.1"> Contains </span><kbd><span class="koboSpan" id="kobo.5.1">Controller</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">View</span></kbd><span class="koboSpan" id="kobo.8.1">, and so on. </span><span class="koboSpan" id="kobo.8.2">Most importantly, it has the entry point </span><kbd><span class="koboSpan" id="kobo.9.1">Startup.cs</span></kbd><span class="koboSpan" id="kobo.10.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.11.1">Business/Service Layer:</span></strong><span class="koboSpan" id="kobo.12.1"> Contains the </span><kbd><span class="koboSpan" id="kobo.13.1">Services</span></kbd><span class="koboSpan" id="kobo.14.1"> where we can include our business logic.</span></li>
<li><strong><span class="koboSpan" id="kobo.15.1">Data Access Layer:</span></strong><span class="koboSpan" id="kobo.16.1"> Contains </span><kbd><span class="koboSpan" id="kobo.17.1">Contexts</span></kbd><span class="koboSpan" id="kobo.18.1">, </span><kbd><span class="koboSpan" id="kobo.19.1">DbSets</span></kbd><span class="koboSpan" id="kobo.20.1">, and </span><kbd><span class="koboSpan" id="kobo.21.1">Repository</span></kbd><span class="koboSpan" id="kobo.22.1"> for data retrieval from the database.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.23.1">Let's have a quick look at the </span><kbd><span class="koboSpan" id="kobo.24.1">Visual Studio Solution</span></kbd><span class="koboSpan" id="kobo.25.1"> window:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="324" width="382" src="assets/5b265d83-5dbe-47be-acc9-6cc7b21a2e61.png"/></span></div>
<p><span class="koboSpan" id="kobo.27.1">We have organized our classes into different layers. </span><span class="koboSpan" id="kobo.27.2">Interestingly, we have introduced another layer named as </span><kbd><span class="koboSpan" id="kobo.28.1">Common Layer</span></kbd><span class="koboSpan" id="kobo.29.1">, where we have placed all common code related to </span><kbd><span class="koboSpan" id="kobo.30.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.31.1"> and </span><kbd><span class="koboSpan" id="kobo.32.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">A common project is referenced both by </span><kbd><span class="koboSpan" id="kobo.34.1">Business Layer</span></kbd><span><span class="koboSpan" id="kobo.35.1"> and </span></span><kbd><span class="koboSpan" id="kobo.36.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.37.1">.</span></p>
<p><span><span class="koboSpan" id="kobo.38.1">This common code will help us fetch the dependencies from assemblies related to different layers and package them into one (called </span></span><kbd><span class="koboSpan" id="kobo.39.1">ModuleLoader</span></kbd><span><span class="koboSpan" id="kobo.40.1">) so that the web app can call just one method to initiate everything. </span><span class="koboSpan" id="kobo.40.2">Let's understand each part one by one.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Introduction of IUser</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The goal is to remove the concrete class access from the </span><span class="packt_screen"><span class="koboSpan" id="kobo.3.1">UI layer</span></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">We started to move all common items into one central layer called </span><kbd><span class="koboSpan" id="kobo.5.1">Common</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">As we moved </span><kbd><span class="koboSpan" id="kobo.7.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.8.1"> to </span><kbd><span class="koboSpan" id="kobo.9.1">Common</span></kbd><span class="koboSpan" id="kobo.10.1">, we identified a </span><kbd><span class="koboSpan" id="kobo.11.1">GetUser</span></kbd><span class="koboSpan" id="kobo.12.1"> method, which is actually returning a concrete </span><kbd><span class="koboSpan" id="kobo.13.1">User</span></kbd><span class="koboSpan" id="kobo.14.1"> instance. </span><span class="koboSpan" id="kobo.14.2">Moreover, </span><kbd><span class="koboSpan" id="kobo.15.1">UserService</span></kbd><span class="koboSpan" id="kobo.16.1"> inside the </span><kbd><span class="koboSpan" id="kobo.17.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.18.1"> also has the same method as it implements </span><kbd><span class="koboSpan" id="kobo.19.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">The following code shows how the return type of </span><kbd><span class="koboSpan" id="kobo.22.1">GetUser</span></kbd><span class="koboSpan" id="kobo.23.1"> can be updated to </span><kbd><span class="koboSpan" id="kobo.24.1">IUser</span></kbd><span class="koboSpan" id="kobo.25.1"> type instead of </span><kbd><span class="koboSpan" id="kobo.26.1">User</span></kbd><span class="koboSpan" id="kobo.27.1"> type:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">    public </span><strong><span class="koboSpan" id="kobo.29.1">IUser</span></strong><span class="koboSpan" id="kobo.30.1"> GetUser(int userId) =&gt;</span><br/><span class="koboSpan" id="kobo.31.1">          _usersRepository.GetUser(userId);</span><br/><span class="koboSpan" id="kobo.32.1">   // Return type is changed from User to IUser.</span></pre>
<p><span class="koboSpan" id="kobo.33.1">We need to get rid of this </span><kbd><span class="koboSpan" id="kobo.34.1">User</span></kbd><span class="koboSpan" id="kobo.35.1"> class dependency, otherwise, </span><kbd><span class="koboSpan" id="kobo.36.1">Common Layer</span></kbd><span class="koboSpan" id="kobo.37.1"> has to again refer to the </span><kbd><span class="koboSpan" id="kobo.38.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.39.1"> because the </span><kbd><span class="koboSpan" id="kobo.40.1">User</span></kbd><span class="koboSpan" id="kobo.41.1"> resides in that, which is the same case for </span><kbd><span class="koboSpan" id="kobo.42.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.43.1"> to refer </span><kbd><span class="koboSpan" id="kobo.44.1">Data Access</span></kbd><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">Moreover, </span><kbd><span class="koboSpan" id="kobo.46.1">Common</span></kbd><span class="koboSpan" id="kobo.47.1"> is designed to be referred by other layers and not to get other layers references inside itself. </span><span class="koboSpan" id="kobo.47.2">It should be free from project dependencies. </span><span class="koboSpan" id="kobo.47.3">This is important.</span></p>
<p><span class="koboSpan" id="kobo.48.1">The solution is very easy. </span><span class="koboSpan" id="kobo.48.2">One </span><kbd><span class="koboSpan" id="kobo.49.1">IUser</span></kbd><span class="koboSpan" id="kobo.50.1"> interface can be added inside the </span><kbd><span class="koboSpan" id="kobo.51.1">Common/Entities/Users</span></kbd><span class="koboSpan" id="kobo.52.1"> directory, which will be used as a return type for the </span><kbd><span class="koboSpan" id="kobo.53.1">GetUser</span></kbd><span class="koboSpan" id="kobo.54.1"> method. </span><span class="koboSpan" id="kobo.54.2">So, </span><kbd><span class="koboSpan" id="kobo.55.1">GetUser</span></kbd><span class="koboSpan" id="kobo.56.1"> inside </span><kbd><span class="koboSpan" id="kobo.57.1">UsersService</span></kbd><span class="koboSpan" id="kobo.58.1"> and </span><kbd><span class="koboSpan" id="kobo.59.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.60.1"> can return the </span><kbd><span class="koboSpan" id="kobo.61.1">IUser</span></kbd><span class="koboSpan" id="kobo.62.1"> type instead of the </span><kbd><span class="koboSpan" id="kobo.63.1">User</span></kbd><span class="koboSpan" id="kobo.64.1"> instance. </span><span class="koboSpan" id="kobo.64.2">Now we can easily remove the coupling of </span><kbd><span class="koboSpan" id="kobo.65.1">Data Access</span></kbd><span class="koboSpan" id="kobo.66.1"> with the </span><kbd><span class="koboSpan" id="kobo.67.1">Common Layer</span></kbd><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">Also </span><kbd><span class="koboSpan" id="kobo.69.1">Data Access</span></kbd><span class="koboSpan" id="kobo.70.1"> coupling with the </span><kbd><span class="koboSpan" id="kobo.71.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.72.1">.</span></p>
<p><span class="koboSpan" id="kobo.73.1">The following diagram tells us what was wrong when we used </span><kbd><span class="koboSpan" id="kobo.74.1">User</span></kbd><span class="koboSpan" id="kobo.75.1"> class. </span><span class="koboSpan" id="kobo.75.2">We had references to the </span><kbd><span class="koboSpan" id="kobo.76.1">Common Layer</span></kbd><span class="koboSpan" id="kobo.77.1"> and </span><kbd><span class="koboSpan" id="kobo.78.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.79.1"> in the </span><kbd><span class="koboSpan" id="kobo.80.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.81.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.82.1"><img height="174" width="541" src="assets/fb81c646-ecdf-482b-86ca-6c67be4f09f6.png"/></span></div>
<p><span class="koboSpan" id="kobo.83.1">The following is the approach which is correct with an interface </span><kbd><span class="koboSpan" id="kobo.84.1">IUser</span></kbd><span class="koboSpan" id="kobo.85.1">, which allows us to reduce the coupling of layers:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.86.1"><img height="179" width="554" src="assets/f327c048-c7b6-4e4d-a3c2-f3097482ab56.png"/></span></div>
<p><span class="koboSpan" id="kobo.87.1">Now there is no need for a reference to the </span><kbd><span class="koboSpan" id="kobo.88.1">Data Layer</span></kbd><span class="koboSpan" id="kobo.89.1"> inside the </span><kbd><span class="koboSpan" id="kobo.90.1">Common Layer</span></kbd><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">On the contrary, the </span><kbd><span class="koboSpan" id="kobo.92.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.93.1"> and </span><kbd><span class="koboSpan" id="kobo.94.1">Data Layer</span></kbd><span class="koboSpan" id="kobo.95.1"> are dependent on </span><kbd><span class="koboSpan" id="kobo.96.1">Common</span></kbd><span class="koboSpan" id="kobo.97.1">, which is our intention. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The IModuleRegistrar interface</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">IModuleRegistrar</span></kbd><span class="koboSpan" id="kobo.4.1"> interface is responsible for adding the dependency into the service collection. </span><span class="koboSpan" id="kobo.4.2">Basically, the implementer of this interface will have an </span><kbd><span class="koboSpan" id="kobo.5.1">Add()</span></kbd><span class="koboSpan" id="kobo.6.1"> method with the signature mentioned, which does the job of the </span><kbd><span class="koboSpan" id="kobo.7.1">Add***</span></kbd><span class="koboSpan" id="kobo.8.1"> (</span><kbd><span class="koboSpan" id="kobo.9.1">AddTransient</span></kbd><span class="koboSpan" id="kobo.10.1">/</span><kbd><span class="koboSpan" id="kobo.11.1">AddScoped</span></kbd><span class="koboSpan" id="kobo.12.1">/</span><kbd><span class="koboSpan" id="kobo.13.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.14.1">) methods.</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    using Microsoft.Extensions.DependencyInjection;</span><br/><span class="koboSpan" id="kobo.16.1">    using System;</span><br/><span class="koboSpan" id="kobo.17.1">    namespace PacktDIExamples.Common</span><br/><span class="koboSpan" id="kobo.18.1">    {</span><br/><span class="koboSpan" id="kobo.19.1">      public interface IModuleRegistrar</span><br/><span class="koboSpan" id="kobo.20.1">      {</span><br/><span class="koboSpan" id="kobo.21.1">        void Add(Type serviceType, Type implementationType,</span><br/><span class="koboSpan" id="kobo.22.1">           ServiceLifetime lifetime);</span><br/><span class="koboSpan" id="kobo.23.1">      }</span><br/><span class="koboSpan" id="kobo.24.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.25.1">This is present inside the </span><kbd><span class="koboSpan" id="kobo.26.1">Common Layer</span></kbd><span class="koboSpan" id="kobo.27.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The ModuleRegistrar class</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">ModuleRegistrar</span></kbd><span class="koboSpan" id="kobo.3.1">, which implements the previously mentioned interface, will look something like the following. </span><span class="koboSpan" id="kobo.3.2">This basically behaves as a wrapper for the built-in IoC Container to register dependencies:</span></p>
<pre><span class="koboSpan" id="kobo.4.1">    using Microsoft.Extensions.DependencyInjection;</span><br/><span class="koboSpan" id="kobo.5.1">    using System;</span><br/><br/><span class="koboSpan" id="kobo.6.1">    namespace PacktDIExamples.Common</span><br/><span class="koboSpan" id="kobo.7.1">    {</span><br/><span class="koboSpan" id="kobo.8.1">      internal class ModuleRegistrar : IModuleRegistrar</span><br/><span class="koboSpan" id="kobo.9.1">      {</span><br/><span class="koboSpan" id="kobo.10.1">        private readonly IServiceCollection _serviceCollection;</span><br/><span class="koboSpan" id="kobo.11.1">        public ModuleRegistrar(</span><strong><span class="koboSpan" id="kobo.12.1">IServiceCollection serviceCollection</span></strong><span class="koboSpan" id="kobo.13.1">)</span><br/><span class="koboSpan" id="kobo.14.1">        {</span><br/>            <strong><span class="koboSpan" id="kobo.15.1">this._serviceCollection = serviceCollection;</span></strong><br/><span class="koboSpan" id="kobo.16.1">        }</span><br/><br/><span class="koboSpan" id="kobo.17.1">        public void Add(Type serviceType, Type implementationType,</span><br/><span class="koboSpan" id="kobo.18.1">            ServiceLifetime lifetime)</span><br/><span class="koboSpan" id="kobo.19.1">        {</span><br/>            <strong><span class="koboSpan" id="kobo.20.1">var descriptor = new ServiceDescriptor(serviceType, </span><br/><span class="koboSpan" id="kobo.21.1">              implementationType, lifetime);</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">            this._serviceCollection.Add(descriptor);</span></strong><br/><span class="koboSpan" id="kobo.23.1">        }</span><br/><span class="koboSpan" id="kobo.24.1">      }</span><br/><span class="koboSpan" id="kobo.25.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.26.1">Notice the two important aspects of this class:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.27.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.28.1"> is injected into the constructor</span></li>
<li><span class="koboSpan" id="kobo.29.1">Injected </span><kbd><span class="koboSpan" id="kobo.30.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.31.1"> used to add dependencies into the container using </span><kbd><span class="koboSpan" id="kobo.32.1">ServiceDescriptor</span></kbd><span class="koboSpan" id="kobo.33.1"> instance</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">This class is a part of the Common Library.</span></p>
<div class="packt_infobox"><strong><span class="koboSpan" id="kobo.35.1">Service Descriptor:</span></strong> <kbd><span class="koboSpan" id="kobo.36.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.37.1"> is the collection of the service descriptors. </span><span class="koboSpan" id="kobo.37.2">A Service Descriptor instance when created can provide full information about a service or dependency. </span><span class="koboSpan" id="kobo.37.3">We have different methods for different lifestyles such as </span><kbd><span class="koboSpan" id="kobo.38.1">AddTransient</span></kbd><span class="koboSpan" id="kobo.39.1">, </span><kbd><span class="koboSpan" id="kobo.40.1">AddScoped</span></kbd><span class="koboSpan" id="kobo.41.1">, and </span><kbd><span class="koboSpan" id="kobo.42.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.43.1"> to register dependencies. </span><span class="koboSpan" id="kobo.43.2">However, we can't write all three methods to manage the dependencies at a commonplace. </span><span class="koboSpan" id="kobo.43.3">That is where a Service Descriptor can help takes lifetime as a parameter and can be added directly to the </span><kbd><span class="koboSpan" id="kobo.44.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.45.1"> using the </span><kbd><span class="koboSpan" id="kobo.46.1">Add</span></kbd><span class="koboSpan" id="kobo.47.1"> method.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The IModule interface</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">IModule</span></kbd><span class="koboSpan" id="kobo.3.1"> is the main hero of the architecture because this is the first thing which will be used by a Loader to recognize what modules are required to be fetched from all the assemblies that are targeted. </span><span class="koboSpan" id="kobo.3.2">This interface exposes one method, </span><kbd><span class="koboSpan" id="kobo.4.1">Initialize()</span></kbd><span class="koboSpan" id="kobo.5.1"> which is invoked by the Loader to add dependencies into the container. </span><span class="koboSpan" id="kobo.5.2">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">    namespace PacktDIExamples.Common</span><br/><span class="koboSpan" id="kobo.7.1">    {</span><br/><span class="koboSpan" id="kobo.8.1">      public interface IModule</span><br/><span class="koboSpan" id="kobo.9.1">      {</span><br/><span class="koboSpan" id="kobo.10.1">        void Initialize(IModuleRegistrar registrar);</span><br/><span class="koboSpan" id="kobo.11.1">      }</span><br/><span class="koboSpan" id="kobo.12.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.13.1">This interface lies inside Common Library as well.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The ModuleInit class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's see how the preceding </span><kbd><span class="koboSpan" id="kobo.3.1">IModule</span></kbd><span class="koboSpan" id="kobo.4.1"> interface can be implemented inside the </span><kbd><span class="koboSpan" id="kobo.5.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    using Microsoft.Extensions.DependencyInjection;</span><br/><span class="koboSpan" id="kobo.8.1">    using PacktDIExamples.Common;</span><br/><span class="koboSpan" id="kobo.9.1">    using System.Composition;</span><br/><br/><span class="koboSpan" id="kobo.10.1">    namespace </span><strong><span class="koboSpan" id="kobo.11.1">PacktDIExamples.Business</span></strong><br/><span class="koboSpan" id="kobo.12.1">    {</span><br/><strong><span class="koboSpan" id="kobo.13.1">      [Export(typeof(IModule))] // Will be used by MEF to</span><br/><span class="koboSpan" id="kobo.14.1">         fetch the class.</span></strong><br/><span class="koboSpan" id="kobo.15.1">      public class ModuleInit : </span><strong><span class="koboSpan" id="kobo.16.1">IModule</span></strong><br/><span class="koboSpan" id="kobo.17.1">      {</span><br/><span class="koboSpan" id="kobo.18.1">        public void Initialize(</span><strong><span class="koboSpan" id="kobo.19.1">IModuleRegistrar registrar</span></strong><span class="koboSpan" id="kobo.20.1">) </span><strong><span class="koboSpan" id="kobo.21.1">// Registrar</span><br/><span class="koboSpan" id="kobo.22.1">            injected.</span></strong><br/><span class="koboSpan" id="kobo.23.1">        {</span><br/><strong><span class="koboSpan" id="kobo.24.1">           registrar.Add(typeof(IUsersService), typeof(UsersService),</span><br/></strong><strong><span class="koboSpan" id="kobo.25.1">              ServiceLifetime.Transient);</span><br/><span class="koboSpan" id="kobo.26.1">           // Adds the UserService instance </span><br/><span class="koboSpan" id="kobo.27.1">           // to the container with Transient Lifetime.</span></strong><br/><span class="koboSpan" id="kobo.28.1">        }</span><br/><span class="koboSpan" id="kobo.29.1">      }</span><br/><span class="koboSpan" id="kobo.30.1">    } </span></pre>
<p><kbd><span class="koboSpan" id="kobo.31.1">ModuleInit</span></kbd><span class="koboSpan" id="kobo.32.1"> is present inside both the </span><kbd><span class="koboSpan" id="kobo.33.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.34.1"> and </span><kbd><span class="koboSpan" id="kobo.35.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">This class helps us to add different dependencies in each layer such as </span><kbd><span class="koboSpan" id="kobo.37.1">UsersService</span></kbd><span class="koboSpan" id="kobo.38.1"> in </span><kbd><span class="koboSpan" id="kobo.39.1">Business</span></kbd><span class="koboSpan" id="kobo.40.1"> and </span><kbd><span class="koboSpan" id="kobo.41.1">UsersRepository</span></kbd><span class="koboSpan" id="kobo.42.1"> in </span><kbd><span class="koboSpan" id="kobo.43.1">Data Access</span></kbd><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">You can see how </span><kbd><span class="koboSpan" id="kobo.45.1">UserService</span></kbd><span class="koboSpan" id="kobo.46.1"> is added to the registrar inside </span><kbd><span class="koboSpan" id="kobo.47.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">I am skipping </span><kbd><span class="koboSpan" id="kobo.49.1">ModuleInit</span></kbd><span class="koboSpan" id="kobo.50.1"> of the </span><kbd><span class="koboSpan" id="kobo.51.1">DataAccess Layer</span></kbd><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">It's just a change of one line inside </span><kbd><span class="koboSpan" id="kobo.53.1">Initialize</span></kbd><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">The following line of code can be added for </span><kbd><span class="koboSpan" id="kobo.55.1">UserRepository</span></kbd><span class="koboSpan" id="kobo.56.1"> dependency registration inside </span><kbd><span class="koboSpan" id="kobo.57.1">ModuleInit</span></kbd><span class="koboSpan" id="kobo.58.1"> of </span><kbd><span class="koboSpan" id="kobo.59.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.60.1">:</span></p>
<pre><span class="koboSpan" id="kobo.61.1">    registrar.Add(typeof(IUsersRepository), typeof(UsersRepository),</span><br/><span class="koboSpan" id="kobo.62.1">      ServiceLifetime.Transient);</span></pre>
<p><span class="koboSpan" id="kobo.63.1">Just make a note of the bold part </span><kbd><span class="koboSpan" id="kobo.64.1">([Export(typeof(IModule))])</span></kbd><span class="koboSpan" id="kobo.65.1"> in the last-but-one code block, which is very important. </span><span class="koboSpan" id="kobo.65.2">This is the attribute, which helps MEF to grab the </span><kbd><span class="koboSpan" id="kobo.66.1">ModuleInit</span></kbd><span class="koboSpan" id="kobo.67.1"> classes in the specified assemblies, with the interface </span><kbd><span class="koboSpan" id="kobo.68.1">IModule</span></kbd><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">It can then easily call </span><kbd><span class="koboSpan" id="kobo.70.1">Initialize</span></kbd><span class="koboSpan" id="kobo.71.1"> to start the process of registering dependencies. </span><span><span class="koboSpan" id="kobo.72.1">We will very soon see the code, that does this task for us.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Wait! </span><span class="koboSpan" id="kobo.73.2">We have a Constructor Injection here. </span><span class="koboSpan" id="kobo.73.3">And what is that used for? </span><span class="koboSpan" id="kobo.73.4">Actually, the code for registering the dependency lies inside the registrar, so we definitely need the </span><kbd><span class="koboSpan" id="kobo.74.1">IModuleRegistrar</span></kbd><span class="koboSpan" id="kobo.75.1"> dependency in order to call </span><kbd><span class="koboSpan" id="kobo.76.1">Add()</span></kbd><span class="koboSpan" id="kobo.77.1"> of </span><kbd><span class="koboSpan" id="kobo.78.1">Registrar</span></kbd><span class="koboSpan" id="kobo.79.1">, which registers the required dependency, for example, </span><kbd><span class="koboSpan" id="kobo.80.1">UsersService</span></kbd><span class="koboSpan" id="kobo.81.1"> here inside </span><kbd><span class="koboSpan" id="kobo.82.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.83.1">.</span></p>
<p><span class="koboSpan" id="kobo.84.1">Check out the flow of controls during the process of dependency registrations. </span><span class="koboSpan" id="kobo.84.2">Typically the flow is like the following:</span></p>
<p><kbd><span class="koboSpan" id="kobo.85.1">ModuleLoader</span></kbd><span class="koboSpan" id="kobo.86.1"> | </span><kbd><span class="koboSpan" id="kobo.87.1">ModuleInit(IRegistrar)</span></kbd><span class="koboSpan" id="kobo.88.1"> | </span><kbd><span class="koboSpan" id="kobo.89.1">ModuleRegistrar</span></kbd><span class="koboSpan" id="kobo.90.1"> | </span><kbd><span class="koboSpan" id="kobo.91.1">Add()</span></kbd><span class="koboSpan" id="kobo.92.1"> (adds the dependency to collection):</span></p>
<p><span class="koboSpan" id="kobo.93.1">The following diagram visualizes the work of </span><strong><span class="koboSpan" id="kobo.94.1">Module Loader</span></strong><span class="koboSpan" id="kobo.95.1"> through the available layers as discussed:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.96.1"><img height="293" width="413" src="assets/64d3c9f2-a4db-427e-bc1b-a9bd16890fb0.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The ModuleLoader class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To work</span><span><span class="koboSpan" id="kobo.3.1"> with MEF, we need a Nuget package known as &lt;/span&gt;</span><kbd><span class="koboSpan" id="kobo.4.1">Microsoft.Composition.</span></kbd> <span><span class="koboSpan" id="kobo.5.1">This will install </span></span><kbd><span class="koboSpan" id="kobo.6.1">System.Composition</span></kbd><span><span class="koboSpan" id="kobo.7.1"> into the project. </span><span class="koboSpan" id="kobo.7.2">You need to add the package inside the </span></span><kbd><span class="koboSpan" id="kobo.8.1">Common Layer</span></kbd><span><span class="koboSpan" id="kobo.9.1">. </span></span><kbd><span class="koboSpan" id="kobo.10.1">ContainerConfiguration</span></kbd><span><span class="koboSpan" id="kobo.11.1"> is the class present inside the </span></span><kbd><span class="koboSpan" id="kobo.12.1">System.Composition.Hosting</span></kbd><span><span class="koboSpan" id="kobo.13.1"> namespace, which composes all assemblies and can provide us with a Container, from which we can easily</span></span><em><span class="koboSpan" id="kobo.14.1"> </span></em><span><span class="koboSpan" id="kobo.15.1">extract the required concrete implementations.</span></span></span></p>
<p><span><span class="koboSpan" id="kobo.16.1">The following screenshot is the </span><kbd><span class="koboSpan" id="kobo.17.1">NuGet</span></kbd><span class="koboSpan" id="kobo.18.1"> Package preview shown in the</span></span> <span class="packt_screen"><span class="koboSpan" id="kobo.19.1">NuGet Package Manager</span></span><span class="koboSpan" id="kobo.20.1"> win</span><span><span class="koboSpan" id="kobo.21.1">dow when you search:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img style="color: #333333;font-size: 14.6667px" src="assets/c8b5c02b-44b6-42f5-9f65-79fe3ef5a5f3.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">Finally the last, but not the least,  </span><kbd><span class="koboSpan" id="kobo.24.1">ModuleLoader</span></kbd><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">All that we have learned till now is managed by the Loader which is a static class with one method </span><kbd><span class="koboSpan" id="kobo.26.1">LoadContainer</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">This method is invoked by our MVC Web App </span><kbd><span class="koboSpan" id="kobo.28.1">Startup</span></kbd><span class="koboSpan" id="kobo.29.1"> to initialize the dependency registration process. </span><span class="koboSpan" id="kobo.29.2">Let's have a sneak peek at the codes:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">    namespace PacktDIExamples.Common</span><br/><span class="koboSpan" id="kobo.31.1">    {</span><br/><span class="koboSpan" id="kobo.32.1">     public static class ModuleLoader</span><br/><span class="koboSpan" id="kobo.33.1">     {</span><br/><span class="koboSpan" id="kobo.34.1">        public static void LoadContainer(IServiceCollection collection,</span><br/><span class="koboSpan" id="kobo.35.1">            string pattern)</span><br/><span class="koboSpan" id="kobo.36.1">        {</span><br/><span class="koboSpan" id="kobo.37.1">           // Gets the Assembly Location: The total path of the Web App</span><br/><span class="koboSpan" id="kobo.38.1">           assembly, which in our case is </span><br/><strong><span class="koboSpan" id="kobo.39.1">           "C:\\Users\\taditd\\Desktop\\Packt\\Codes\\PacktDIExamples\\</span><br/><span class="koboSpan" id="kobo.40.1">            PacktDIExamples\\bin\\Debug\\netcoreapp2.0\\</span><br/><span class="koboSpan" id="kobo.41.1">            PacktDIExamples.dll"</span></strong><span class="koboSpan" id="kobo.42.1">.</span><br/><span class="koboSpan" id="kobo.43.1">            var executableLocation = Assembly.GetEntryAssembly().Location;</span><br/><br/><span class="koboSpan" id="kobo.44.1">            // Get all assemblies inside the location with a pattern</span><br/><span class="koboSpan" id="kobo.45.1">              from </span><strong><span class="koboSpan" id="kobo.46.1">"bin\Debug\netcoreapp2.0"</span></strong><span class="koboSpan" id="kobo.47.1">.</span><br/><span class="koboSpan" id="kobo.48.1">            var assemblies = Directory</span><br/><span class="koboSpan" id="kobo.49.1">                .GetFiles(Path.GetDirectoryName(executableLocation),</span><br/>                   <strong><span class="koboSpan" id="kobo.50.1">pattern</span></strong><span class="koboSpan" id="kobo.51.1">, SearchOption.AllDirectories)</span><br/><span class="koboSpan" id="kobo.52.1">                .Select(AssemblyLoadContext.Default.LoadFromAssemblyPath)</span><br/><span class="koboSpan" id="kobo.53.1">                .ToList();</span><br/><br/>            <strong><span class="koboSpan" id="kobo.54.1">// Composes the assemblies.</span></strong><br/><span class="koboSpan" id="kobo.55.1">            var configuration = new ContainerConfiguration()</span><br/><span class="koboSpan" id="kobo.56.1">               .WithAssemblies(assemblies);</span><br/><span class="koboSpan" id="kobo.57.1">            using (var container = configuration.CreateContainer())</span><br/><span class="koboSpan" id="kobo.58.1">            {</span><br/><strong><span class="koboSpan" id="kobo.59.1">              // This is important.</span></strong> <strong><span class="koboSpan" id="kobo.60.1">The following line extracts</span><br/><span class="koboSpan" id="kobo.61.1">             all the IModule implementations from the</span><br/><span class="koboSpan" id="kobo.62.1">             assemblies we fetched.</span></strong><br/><span class="koboSpan" id="kobo.63.1">             IEnumerable&lt;IModule&gt; modules = container.GetExports&lt;IModule&amp;gt;();</span><br/><span class="koboSpan" id="kobo.64.1">             var registrar = new ModuleRegistrar(collection);</span><br/><br/><span class="koboSpan" id="kobo.65.1">             foreach (IModule module in modules)</span><br/><span class="koboSpan" id="kobo.66.1">             {</span><br/>           <strong><span class="koboSpan" id="kobo.67.1">   // Invoke Initialize for each module with the registrar</span><br/><span class="koboSpan" id="kobo.68.1">               as a dependency.</span></strong><br/><span class="koboSpan" id="kobo.69.1">              module.Initialize(registrar);</span><br/><span class="koboSpan" id="kobo.70.1">             }</span><br/><span class="koboSpan" id="kobo.71.1">           }</span><br/><span class="koboSpan" id="kobo.72.1">          }</span><br/><span class="koboSpan" id="kobo.73.1">        }</span><br/><span class="koboSpan" id="kobo.74.1">     }</span></pre>
<p><span class="koboSpan" id="kobo.75.1">I have added comments over each step so that it will be easy for you to analyze the steps. </span><span class="koboSpan" id="kobo.75.2">The steps can be defined as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.76.1">Get the </span><kbd><span class="koboSpan" id="kobo.77.1">Web App Assembly Location</span></kbd><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">As we are going to call this method from Web App and every other assembly is placed there, we need that location to find others.</span></li>
<li><span class="koboSpan" id="kobo.79.1">Find out, what other assemblies present in that particular location. </span><span class="koboSpan" id="kobo.79.2">However, we need to have DLLs of the layers we have in our app. </span><span class="koboSpan" id="kobo.79.3">For that reason, a pattern is necessary to recognize the assemblies of the layers. </span><span class="koboSpan" id="kobo.79.4">According to our layers, we only need to find all assembly names starting with </span><span class="packt_screen"><span class="koboSpan" id="kobo.80.1">PacktDIExamples</span></span><span class="koboSpan" id="kobo.81.1"> and ending with </span><kbd><span class="koboSpan" id="kobo.82.1">.dll</span></kbd><span class="koboSpan" id="kobo.83.1">, because the Layer names are like </span><kbd><span class="koboSpan" id="kobo.84.1">PacktDIExamples.Business.dll</span></kbd><span class="koboSpan" id="kobo.85.1"> and </span><kbd><span class="koboSpan" id="kobo.86.1">PacktDIExamples.DataAccess.dll</span></kbd><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">So, the pattern will be </span><kbd><span class="koboSpan" id="kobo.88.1">PacktDIExamples.*.dll</span></kbd><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">W</span><span><span class="koboSpan" id="kobo.90.1">e will see the code sends this pattern to</span></span><span class="koboSpan" id="kobo.91.1"> the </span><kbd><span class="koboSpan" id="kobo.92.1">LoadContainer</span></kbd><span class="koboSpan" id="kobo.93.1"> i</span><span><span class="koboSpan" id="kobo.94.1">n a moment. </span><span class="koboSpan" id="kobo.94.2">You can see the extracted modules shown in the Visual Studio tooltip while debugging, shown as follows:</span></span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><span><span class="koboSpan" id="kobo.95.1"><img height="184" width="524" src="assets/118fd71a-eb45-4c62-a0c7-ab68c473a375.png"/></span><br/></span></div>
<ol start="3">
<li><span class="koboSpan" id="kobo.96.1">Create a container to hold all the assemblies using the </span><kbd><span class="koboSpan" id="kobo.97.1">ContainerConfiguration</span></kbd><span class="koboSpan" id="kobo.98.1"> instance.</span></li>
<li><span class="koboSpan" id="kobo.99.1">Now </span><kbd><span class="koboSpan" id="kobo.100.1">container.GetExports&lt;IModule&gt;()</span></kbd><span class="koboSpan" id="kobo.101.1"> is used to extract the </span><kbd><span class="koboSpan" id="kobo.102.1">IModule</span></kbd><span class="koboSpan" id="kobo.103.1"> implementation from these assemblies.</span></li>
<li><span class="koboSpan" id="kobo.104.1">Execute the </span><kbd><span class="koboSpan" id="kobo.105.1">Initialize</span></kbd><span class="koboSpan" id="kobo.106.1"> method for each </span><kbd><span class="koboSpan" id="kobo.107.1">IModule</span></kbd><span class="koboSpan" id="kobo.108.1"> implementations with a registrar instance as a dependency because the </span><kbd><span class="koboSpan" id="kobo.109.1">Registrar</span></kbd><span class="koboSpan" id="kobo.110.1"> has the actual </span><kbd><span class="koboSpan" id="kobo.111.1">Add</span></kbd><span class="koboSpan" id="kobo.112.1"> method for dependency registration with the </span><kbd><span class="koboSpan" id="kobo.113.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.114.1">.</span></li>
</ol>
<div class="mce-root packt_tip"><span class="koboSpan" id="kobo.115.1">I would advise you to put </span><kbd><span class="koboSpan" id="kobo.116.1">try...catch</span></kbd><span class="koboSpan" id="kobo.117.1"> blocks in this method to handle the exceptions. </span><span class="koboSpan" id="kobo.117.2">Due to the space restrictions, I have not posted the </span><kbd><span class="koboSpan" id="kobo.118.1">try...catch</span></kbd><span class="koboSpan" id="kobo.119.1"> block. </span><span class="koboSpan" id="kobo.119.2">I just want to show the core logic of a </span><kbd><span class="koboSpan" id="kobo.120.1">ModuleLoader</span></kbd><span class="koboSpan" id="kobo.121.1">. </span><span class="koboSpan" id="kobo.121.2">I have also removed the </span><kbd><span class="koboSpan" id="kobo.122.1">usings</span></kbd><span class="koboSpan" id="kobo.123.1">, which were taking up a lot of space. </span><span class="koboSpan" id="kobo.123.2">You can figure out the </span><kbd><span class="koboSpan" id="kobo.124.1">usings</span></kbd><span class="koboSpan" id="kobo.125.1">, anyway; if not, use Visual Studio. </span><span class="koboSpan" id="kobo.125.2">Hover on the red lines and then follow the steps which will include the required libraries.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Executing the ModuleLoader.LoaderContainer() method from Web App</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This is the final step and the simplest one. </span><span class="koboSpan" id="kobo.2.2">See how we can call this Loader from the Web App inside the </span><kbd><span class="koboSpan" id="kobo.3.1">Startup</span></kbd><span class="koboSpan" id="kobo.4.1"> as follows:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    public void ConfigureServices(IServiceCollection services)</span><br/><span class="koboSpan" id="kobo.6.1">    {</span><br/><span class="koboSpan" id="kobo.7.1">      // Commented out codes because we now load dependencies from</span><br/><span class="koboSpan" id="kobo.8.1">          another layer.</span><br/><span class="koboSpan" id="kobo.9.1">      // services.AddTransient&lt;IUsersService, UsersService&gt;()</span><br/><span class="koboSpan" id="kobo.10.1">      //         .AddTransient&lt;IUsersRepository, UsersRepository&gt;();</span><br/><br/><span class="koboSpan" id="kobo.11.1">      ModuleLoader.LoadContainer(</span><strong><span class="koboSpan" id="kobo.12.1">services</span></strong><span class="koboSpan" id="kobo.13.1">, "PacktDIExamples.*.dll");</span><br/><span class="koboSpan" id="kobo.14.1">      services.AddMvc();</span><br/><span class="koboSpan" id="kobo.15.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.16.1">As I mentioned, we need to send a pattern to fetch the Assembly names from </span><kbd><span class="koboSpan" id="kobo.17.1">bin/debug/netcoreapp2.0</span></kbd><span class="koboSpan" id="kobo.18.1">; otherwise, it will fetch all assemblies, which is unnecessary.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Notice that we are sending the services to the </span><kbd><span class="koboSpan" id="kobo.20.1">LoadContainer</span></kbd><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">Now the previous code for registering the dependencies is commented, which got optimized by the </span><kbd><span class="koboSpan" id="kobo.22.1">ModuleLoader.LoadContainer</span></kbd><span class="koboSpan" id="kobo.23.1"> call.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">What have we achieved with MEF?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If you have not yet realized the benefits of refactoring the layered architecture with MEF, have a close look at the following screenshot with explanations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Layers are separated</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Layers were tightly coupled as the UI was referencing the </span><kbd><span class="koboSpan" id="kobo.3.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.4.1"> and the </span><kbd><span class="koboSpan" id="kobo.5.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">Now after MEF, the UI is not tied to the </span><kbd><span class="koboSpan" id="kobo.7.1">Data Access Layer</span></kbd><span class="koboSpan" id="kobo.8.1"> anymore. </span><span class="koboSpan" id="kobo.8.2">However, the UI has one </span><kbd><span class="koboSpan" id="kobo.9.1">Business Layer</span></kbd><span class="koboSpan" id="kobo.10.1"> assembly reference as shown in the following screenshot. </span><span class="koboSpan" id="kobo.10.2">But that is not used anywhere inside the project. </span><span class="koboSpan" id="kobo.10.3">It is there because the assembly should be inside the </span><kbd><span class="koboSpan" id="kobo.11.1">bin</span></kbd><span class="koboSpan" id="kobo.12.1"> folder so that the MEF Module is able to read it while initializing to export the </span><kbd><span class="koboSpan" id="kobo.13.1">IModule</span></kbd><span class="koboSpan" id="kobo.14.1"> implementations. </span><span class="koboSpan" id="kobo.14.2">The following is a quick comparison of Project Dependencies before and after MEF:</span></p>
<div class="CDPAlignCenter CDPAlign"><br/>
<span class="koboSpan" id="kobo.15.1"><img height="345" width="667" src="assets/a29dad10-90ff-43ba-b7a0-fd385789141e.png"/></span></div>
<p><span class="koboSpan" id="kobo.16.1">If you try to remove the Business reference from the UI and run the app, it will throw an exception, as follows. </span><span class="koboSpan" id="kobo.16.2">And this is for obvious reasons. </span><span class="koboSpan" id="kobo.16.3">Unless you have the reference, MEF won't be able to extract the </span><kbd><span class="koboSpan" id="kobo.17.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.18.1"> implementation and register to the DI Container, simple!</span></p>
<p><span class="koboSpan" id="kobo.19.1">Thus, the issue happens as soon as you hit the controller, as nothing has been registered to the </span><kbd><span class="koboSpan" id="kobo.20.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.21.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img src="assets/f3c845fb-67be-48ee-917b-ad6b5b5fc745.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">All classes inside layers are now internal</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Instead of having </span><kbd><span class="koboSpan" id="kobo.3.1">public</span></kbd><span class="koboSpan" id="kobo.4.1"> as the access specifiers for the classes, we can make them </span><kbd><span class="koboSpan" id="kobo.5.1">internal</span></kbd><span class="koboSpan" id="kobo.6.1"> so that they are only accessible inside the assembly (this means only internally inside the Layer):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1">&gt;</span><span class="koboSpan" id="kobo.8.1"><img height="210" width="345" src="assets/ffb885fe-c0ca-4295-8741-62720a46541f.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">No concrete class instantiation inside the UI Layer</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span><span class="koboSpan" id="kobo.2.1">Before MEF implementation, we saw how, inside the </span></span><kbd><span class="koboSpan" id="kobo.3.1">Edit</span></kbd><span><span class="koboSpan" id="kobo.4.1"> action method, we could directly reference the </span></span><kbd><span class="koboSpan" id="kobo.5.1">Data Access Layer</span></kbd><span><span class="koboSpan" id="kobo.6.1"> and </span></span><kbd><span class="koboSpan" id="kobo.7.1">Business Layer</span></kbd><span><span class="koboSpan" id="kobo.8.1"> classes. </span><span class="koboSpan" id="kobo.8.2">Now we won't be able to do this because the classes are not accessible anymore.</span></span></p>
<p class="mce-root"><span><span class="koboSpan" id="kobo.9.1">That is proved from the compiler errors inside </span></span><kbd><span class="koboSpan" id="kobo.10.1">UsersController</span></kbd><span><span class="koboSpan" id="kobo.11.1"> as shown in the following screenshot. </span><span class="koboSpan" id="kobo.11.2">Notice the tooltip preview, which indicates the unavailability of the UsersService. </span><span class="koboSpan" id="kobo.11.3">So, misusing classes of other layers is restricted even if you add the references:</span></span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="364" width="674" src="assets/1bf50224-e455-4124-bc5d-b38f56c0f499.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">More layers can be added to the architecture</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When, in the future, you add more layers for optimisation or any other business-related requirements, that assembly can be simply referred to by the UI; then every dependency will automatically get registered to the IoC Container. </span><span class="koboSpan" id="kobo.2.2">Remember, you need have to a </span><kbd><span class="koboSpan" id="kobo.3.1">ModuleInit</span></kbd><span class="koboSpan" id="kobo.4.1"> class implementing the interface </span><kbd><span class="koboSpan" id="kobo.5.1">IModule</span></kbd><span class="koboSpan" id="kobo.6.1"> to automate the process. </span><span class="koboSpan" id="kobo.6.2">The application is totally flexible now, allowing new modules to be attached easily with no hassle.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Conclusion</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Most modern applications follow a layered architecture. </span><span class="koboSpan" id="kobo.2.2">Having a Dependency Injection technique to manage the dependencies required inside the layers is something we should be following. </span><span class="koboSpan" id="kobo.2.3">Having said that, we need to be careful with layer designs. </span><span class="koboSpan" id="kobo.2.4">That is because we applied DI, thinking that it would resolve issues of tight coupling with the dependencies of a class. </span><span class="koboSpan" id="kobo.2.5">However, we did not realize that the layers are getting connected with each other through concrete dependencies (such as the </span><kbd><span class="koboSpan" id="kobo.3.1">User</span></kbd><span class="koboSpan" id="kobo.4.1"> instance return type).</span></p>
<p><em><span class="koboSpan" id="kobo.5.1">Managed Extensibility Framework</span></em><span class="koboSpan" id="kobo.6.1"> provided us with a few easy steps to dynamically bind the dependencies from different layers, package them into one, and then register it to the container for further use by the controllers in the </span><kbd><span class="koboSpan" id="kobo.7.1">UI Layer</span></kbd><span class="koboSpan" id="kobo.8.1">. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">After learning DI Techniques, Patterns, Anti-Patterns and so on, we still needed some pointers to deal with practical scenarios where DI comes into play.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We explored a few real-time application instances where DI can help eliminate coupling and introduce a cleaner dependency structure.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Tightly coupled systems are often seen when a developer tries to be lazy and instantiates the required dependencies directly inside the class using the </span><kbd><span class="koboSpan" id="kobo.5.1">new</span></kbd><span class="koboSpan" id="kobo.6.1"> operator. </span><span class="koboSpan" id="kobo.6.2">Keep in mind that new is glue. </span><span class="koboSpan" id="kobo.6.3">This not only instills a bad practice in you as a coder but also makes your code untestable. </span><span class="koboSpan" id="kobo.6.4">Unit testing becomes difficult. </span><span class="koboSpan" id="kobo.6.5">We learned the technique to deal with the problem of tight coupling by following DI techniques.</span></p>
<p><span><span class="koboSpan" id="kobo.7.1">Then we realized that layering in an application is a common approach with applications. </span><span class="koboSpan" id="kobo.7.2">Having DI is definitely going to help us in the long run for layered systems. </span><span class="koboSpan" id="kobo.7.3">However, there might be loose ends in the layered approach which should be addressed.</span></span></p>
<p><span><span class="koboSpan" id="kobo.8.1">MEF is the technique which we adopted to solve a couple of problems with layered architecture. </span><span class="koboSpan" id="kobo.8.2">By implementing MEF, the business or data layer implementations can be marked as internal so that they are not exposed to other layers. </span><span class="koboSpan" id="kobo.8.3">Also, layer architectural rules for the separation of concerns can remain intact with a DI container. </span><span class="koboSpan" id="kobo.8.4">Thus, the layers can breathe independently without any interference and decorate the architecture in such a way that the introduction of new modules into it becomes very smooth.</span></span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>