- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Best Practices for Minimal API Resiliency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化API弹性最佳实践
- en: Like any software system, minimal APIs can be built in many ways. By carefully
    choosing and applying different patterns and following some set practices, an
    application can be greatly enhanced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何软件系统一样，最小化API可以以多种方式构建。通过仔细选择和应用不同的模式和遵循一些既定实践，应用程序可以得到极大的增强。
- en: There are several good reasons to build patterns into the design of your minimal
    API, the first being readability. Since most of us are part of a team and may
    have other developers to delegate or hand over code, making it as accessible as
    possible is paramount. By ensuring that your endpoints are tidy, that code is
    as *self-documenting* as possible, and that the naming conventions are consistent,
    it will be relatively straightforward for another developer to support the maintenance
    of an API project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的最小化API设计中构建模式有多个很好的理由，首先是可读性。由于我们大多数人是团队的一部分，可能需要将代码委托给其他开发者或移交，因此尽可能使其易于访问至关重要。通过确保你的端点是整洁的，代码尽可能具有自文档性，以及命名约定一致，其他开发者将能够相对容易地支持API项目的维护。
- en: Next is scalability. If the volume of requests grows, so will the need to optimize
    an application. Consistency and good design make meeting demands simple. Whether
    adding a load balancer to manage traffic flow or changing the data storage method,
    it is essential to design APIs in such a way that modifications to the system—whether
    adding or removing components—do not break functionality across the application.away
    parts of the system does not break functionality across the application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是可扩展性。如果请求数量增加，那么优化应用程序的需求也会增加。一致性和良好的设计使得满足需求变得简单。无论是添加负载均衡器来管理流量，还是更改数据存储方法，设计API时必须确保对系统的修改——无论是添加还是删除组件——不会破坏应用程序的功能。
- en: Finally, security is equally important. By following best security practices
    such as encryption at rest and in transit, password hashing and salting, and scoped
    access, sensitive data can be managed securely, reducing the risk of a breach
    and the ensuing legal challenges that present themselves as a result.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安全性同样重要。通过遵循最佳安全实践，如静态和传输中的加密、密码散列和加盐，以及范围访问，可以安全地管理敏感数据，降低数据泄露风险以及随之而来的法律挑战。
- en: Ultimately, achieving these goals depends on applying practices that concern
    the way a code base is structured for readability, the way unexpected and fatal
    scenarios are dealt with in error handling, and the considerations applied from
    a cybersecurity perspective.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，实现这些目标取决于应用以下实践：关注代码库的结构以增强可读性，处理意外和致命场景的错误处理方式，以及从网络安全角度考虑的考量。
- en: Let’s realize some of these benefits in your minimal API projects by exploring
    some design practices and coding conventions that can improve the quality of your
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索一些可以提高代码质量的设计实践和编码约定，让我们在你的最小化API项目中实现一些这些好处。
- en: 'In this chapter, we’re going to cover the following main topics :'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Code organization and structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织和结构
- en: Error handling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Security considerations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性考虑
- en: Let’s get into it!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Visual Studio 2022 or the latest version of Visual Studio code is recommended
    to run the code from this chapter. The code examples for this chapter are available
    in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用Visual Studio 2022或最新版本的Visual Studio code来运行本章的代码。本章的代码示例可在GitHub存储库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)。
- en: One of the examples uses code from *Chapters 9* and *12* , both of which have
    a dependency on Entity Framework Core. It is recommended that you complete those
    chapters before this one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个示例使用了第9章和第12章的代码，这两章都依赖于Entity Framework Core。建议你在阅读本章之前完成这些章节。
- en: Code organization and structure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织和结构
- en: Perhaps the most important thing to understand about organizing and structuring
    code in any system is that there is no one correct way to do it. While there are
    some widely accepted structural patterns, this can be quite a personal topic,
    as a structure must serve the maintainer. However, as we have previously confirmed,
    most minimal API systems in a commercial or open-source setting will have multiple
    maintainers, so a consistent structure will make it as easy as possible for developers
    to collaborate on the code base.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在任何系统中组织和结构化代码，可能最重要的事情是要理解没有一种正确的方法。虽然有一些广泛接受的结构模式，但这可能是一个非常个人化的话题，因为结构必须服务于维护者。然而，正如我们之前所确认的，在商业或开源环境中，大多数最小API系统都会有多个维护者，因此一个一致的结构将使开发者尽可能容易地在代码库上协作。
- en: We will explore two examples of ways that a project can be organized, both sharing
    one key theme – modularity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种项目组织方式，它们都共享一个关键主题——模块化。
- en: '**Modularity** is the practice of organizing and structuring your code into
    smaller, self-contained, and reusable units or modules. Let’s break down some
    of the benefits of this practice:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化**是将你的代码组织成更小、自包含和可复用的单元或模块的实践。让我们分析一下这种实践的一些好处：'
- en: '**Separation of concerns** : By grouping together code containing similar functionality,
    we create contexts within the code base that mirror the business domains they
    serve. For example, code that is solely based on the context of managing users
    is separate from code that is solely based on managing products. Establishing
    clear boundaries between these contexts ensures that dependencies are minimized.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：通过将具有相似功能的代码分组在一起，我们在代码库中创建了反映它们所服务的业务域的上下文。例如，仅基于管理用户上下文的代码与仅基于管理产品的代码是分开的。在这些上下文之间建立清晰的边界可以确保依赖性最小化。'
- en: '**Reusability** : Adopting a modular design allows you to create components
    such as the ones we explored in this book – for example, services and middleware.
    In a system where separation of concerns is the aim, having reusable components
    can help bridge contexts as necessary in a way that reduces the creation of dependencies.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可复用性**：采用模块化设计允许你创建诸如我们在本书中探讨的组件——例如，服务和中间件。在一个以关注点分离为目标的系统中，拥有可复用组件可以帮助在必要时以减少依赖创建的方式连接上下文。'
- en: '**Ease of maintenance** : Modules can be developed and tested independently
    of each other, making parallel development between multiple developers easier.
    Modularization also supports the open-closed principle, which states, “ *Software
    entities (classes, modules, functions, etc.) should be open for extension, but
    closed* *for modification.* ”'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：模块可以独立于彼此开发和测试，这使得多个开发者之间的并行开发更容易。模块化还支持开放-封闭原则，该原则指出，“*软件实体（类、模块、函数等）应该对扩展开放，但对修改封闭*。”'
- en: This means that, in an ideal world, whenever we want to extend our minimal API
    with new functionality, we *do* not need to change the existing code base to enable
    the change.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在一个理想的世界里，每当我们想要通过新功能扩展我们的最小API时，我们*不需要*改变现有的代码库来启用这个变化。
- en: Effective organization of code is often dominated by architectural design patterns.
    While this is certainly important, simply reorganizing the folder structure of
    a project goes a long way to making code readable and simpler to maintain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的有效组织通常受架构设计模式的影响。虽然这确实很重要，但仅仅重新组织项目的文件夹结构就可以在很大程度上使代码更易于阅读和维护。
- en: Let’s explore some example folder structures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些示例文件夹结构。
- en: Exploring folder structures
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索文件夹结构
- en: Most of the time, simple consideration of the way a project’s folders are arranged
    within a project can significantly improve the readability and maintainability
    of a minimal API. We’re looking for a consistent system to lay out classes and
    interfaces. Let’s look at some specific folder structures that we can apply to
    our projects to achieve this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，简单地考虑项目文件夹在项目中的排列方式可以显著提高最小API的可读性和可维护性。我们正在寻找一个一致的系统来布局类和接口。让我们看看一些具体的文件夹结构，我们可以将这些结构应用到我们的项目中以实现这一点。
- en: Feature-based modular structure
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于功能的模块化结构
- en: 'In this structure, the minimal API project is organized by features, with each
    feature having its own folder, containing everything related to that feature,
    regardless of what kind of component is used. Here’s an example of such a structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构中，最小API项目按功能组织，每个功能都有自己的文件夹，包含与该功能相关的所有内容，无论使用哪种组件。以下是一个此类结构的示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this structure, the developer is expected to adopt a feature-based mindset.
    For example, if you want to add an endpoint relating to user management, you would
    head to a folder based on users rather than one dedicated to endpoints.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构中，期望开发者采用基于功能的心态。例如，如果你想添加一个与用户管理相关的端点，你会去一个基于用户的文件夹，而不是一个专门用于端点的文件夹。
- en: As mentioned earlier in the chapter, folder structures can be a personal and
    somewhat polarizing topic. Some may not prefer to mix component types under the
    banner of a feature set, while others enjoy the domain-based nature of this structure
    and are less concerned with what kind of component acts within each domain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，文件夹结构可能是一个个人化和有争议的话题。有些人可能不喜欢在功能集的旗帜下混合组件类型，而其他人则喜欢这种基于领域的结构特性，并且不太关心每个领域内哪种组件在起作用。
- en: Layered modular structure
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层模块结构
- en: This structure is the one I prefer personally because I tend to think about
    the type of component before I think about the feature or business domain. In
    a layered modular structure, the project is first grouped by components (e.g.,
    endpoints and services) and then further broken down into business modules/features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构是我个人偏好的，因为我倾向于在考虑功能或业务领域之前先考虑组件类型。在分层模块结构中，项目首先按组件（例如，端点和服务）分组，然后进一步细分为业务模块/功能。
- en: 'If you are like me and tend to think about the kind of class or file that I
    am looking to create or edit before I think about the domain in which it lives,
    this folder structure will work better for you. However, it’s important to note
    that while this kind of structure prioritizes component types when creating folders,
    there is still a dedicated **Domain** folder that exists to hold entity models
    and **Data Transfer Objects** ( **DTO** s), which describe the business domain.
    Here is an example of a layered modular file structure in a minimal API project:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，在考虑它所在的领域之前，倾向于先考虑我要创建或编辑的类或文件类型，这种文件夹结构将更适合你。然而，重要的是要注意，虽然这种结构在创建文件夹时优先考虑组件类型，但仍有一个专门的**领域**文件夹，用于存放实体模型和**数据传输对象**（**DTO**），这些对象描述了业务领域。以下是一个最小API项目中的分层模块文件结构示例：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we’ve explored some simple examples of how folders can be structured
    within a minimal API project, let’s look at some repeatable patterns that can
    be adopted when structuring a project’s code. These patterns are referred to as
    *design patterns* , and like folder structure, there is debate around which patterns
    constitute best practice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何在最小API项目中组织文件夹的一些简单示例，让我们看看在组织项目代码时可以采用的重复模式。这些模式被称为*设计模式*，就像文件夹结构一样，关于哪些模式构成最佳实践存在争议。
- en: Design patterns
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: This book is not designed to tell you which patterns are the best; rather, it
    is designed to give you some guidance on how you can structure your code consistently
    to create a consistent API system. Here are some example patterns.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是要告诉你哪些模式是最好的；相反，它旨在为你提供一些指导，告诉你如何一致地组织你的代码，以创建一个一致的API系统。以下是一些示例模式。
- en: The factory pattern
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: A **factory pattern** is designed to create objects without specifying the exact
    class of object that will be created. Earlier, I mentioned the open/closed principle,
    and factory patterns help minimal APIs adhere to this principle by closing the
    code for modification while making it open for extension.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂模式**旨在在不指定将要创建的确切对象类的情况下创建对象。之前我提到了开闭原则，工厂模式通过关闭代码以供修改，同时使其易于扩展，帮助最小API遵守这一原则。'
- en: Let’s consider an example use case in which you want to create logs in different
    locations. One location is via a database, and another is in a text file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例用例，在这个用例中，你想要在不同的位置创建日志。一个位置是通过数据库，另一个是在文本文件中。
- en: In the future, you may want to add more log sources, such as a Webhook or third-party
    API. A factory could help you retrieve the correct logger for your use case while
    making it simple to add new loggers without changing the old ones.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，你可能希望添加更多的日志源，例如Webhook或第三方API。工厂可以帮助你检索适用于你的用例的正确记录器，同时使添加新记录器变得简单，而无需更改旧记录器。
- en: 'Let’s look at an example of how we can improve logging by implementing a factory
    pattern:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过实现工厂模式来改进日志记录的一个例子：
- en: 'First, create an interface called **ILogger** , which will be implemented by
    all loggers, regardless of the specific log they execute when saving a log to
    their respective source. **ILogger** is an interface that will represent an object
    that implements logic for the purposes of writing logs to different sources:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为**ILogger**的接口，它将由所有记录器实现，无论它们在将日志保存到各自源时执行的具体日志是什么。**ILogger**是一个接口，它将代表一个实现将日志写入不同源逻辑的对象：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, create two classes that each implement **ILogger** . One of the classes,
    **FileLogger** , will be used to log to a file, and another, **DatabaseLogger**
    , will log to a database:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建两个实现**ILogger**的类。其中一个类，**FileLogger**，将用于将日志记录到文件，另一个类，**DatabaseLogger**，将记录到数据库：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These classes may have different names, but they are both an **ILogger** object
    meaning that they must implement the **Log()** method.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些类可能有不同的名称，但它们都是**ILogger**对象，这意味着它们必须实现**Log()**方法。
- en: 'Furthermore, we can create a function that returns **ILogger** , as shown here:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以创建一个函数，它返回**ILogger**，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we created a **LoggerFactory** class with a function that returns
    the relevant logger class, depending on the contents of a string that was entered
    by the caller. If the **loggerType** parameter is not valid, an exception is thrown,
    allowing the error to be handled.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个**LoggerFactory**类，其中包含一个根据调用者输入的字符串内容返回相关日志类函数。如果**loggerType**参数无效，则会抛出异常，以便处理错误。
- en: The main benefit to this is that to add another logger, we simply create a new
    class that implements **ILogger** before adding a new entry to the **switch**
    statement in **CreateLogger()** . We haven’t had to introduce any breaking changes
    to extend the types of loggers that are supported in the API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最大好处是，要添加另一个记录器，我们只需在**CreateLogger()**中的**switch**语句中添加新条目前创建一个新的实现**ILogger**的类。我们无需引入任何破坏性更改来扩展API中支持的记录器类型。
- en: The repository pattern
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储库模式
- en: This pattern creates an abstraction layer for data access logic, providing a
    more general API to access data from a database for the minimal API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式为数据访问逻辑创建了一个抽象层，为访问数据库数据提供了更通用的API，以最小的API实现。
- en: Earlier in the book, we explored Entity Framework Core to access data from a
    database. Simply by using Entity Framework Core, your code already uses a repository
    pattern because it provides an implementation of the repository pattern that utilizes
    the built-in **DBContext** .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书早期，我们探讨了Entity Framework Core以从数据库中访问数据。只需使用Entity Framework Core，你的代码就已经使用了存储库模式，因为它提供了一个利用内置**DBContext**的存储库模式实现。
- en: However, it is still worth implementing a custom repository pattern to handle
    data so that you further generalize the solution, meaning that Entity Framework
    Core could be swapped out of the minimal API application without affecting the
    overall data access logic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然值得实现一个自定义存储库模式来处理数据，这样你可以进一步泛化解决方案，这意味着Entity Framework Core可以从最小API应用程序中替换出来，而不会影响整体的数据访问逻辑。
- en: To create a repository pattern on top of Entity Framework Core, we can simply
    create a class for each entity in the database. Each repository class receives
    the Entity Framework context via dependency injection, and then the generic **Create,
    Read, Update, Delete** ( **CRUD** ) operations for this entity can be added. Following
    this, each repository can be also registered for dependency injection for use
    elsewhere in an application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Entity Framework Core之上创建存储库模式，我们可以简单地为数据库中的每个实体创建一个类。每个存储库类通过依赖注入接收Entity
    Framework上下文，然后可以添加针对此实体的通用**创建、读取、更新、删除**（**CRUD**）操作。随后，每个存储库也可以注册为依赖注入，以便在应用程序的其他地方使用。
- en: 'In the following example, **EmployeeRepository** reflects the available data
    operations available for an employee entity. As described, the Entity Framework
    context is injected as the data access layer to be used within the repository:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，**EmployeeRepository**反映了员工实体可用的数据操作。如描述，Entity Framework上下文被注入为在仓库中使用的数据访问层：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Going forward, if a decision is made to replace Entity Framework Core, the only
    thing that needs to change is the repository. The consumers of the repository
    would not be affected because the methods and functions they call within the repository
    would maintain their original signatures, despite their underlying logic changing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果决定替换Entity Framework Core，唯一需要改变的是仓库。仓库的消费者将不会受到影响，因为他们调用仓库中的方法和函数将保持其原始签名，尽管其底层逻辑发生了变化。
- en: The strategy pattern
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The **Strategy pattern** allows us to define a family of algorithms, each one
    represented by a class. This pattern is very powerful in situations where there
    are multiple ways of executing an operation, as you can seamlessly switch between
    them in a dynamic fashion.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略模式**允许我们定义一组算法，每个算法由一个类表示。在存在多种执行操作方式的情况下，这种模式非常强大，因为我们可以无缝地在它们之间动态切换。'
- en: Let’s look at an example involving a minimal API endpoint that calculates how
    much annual leave an employee has. In this example, there are different ways to
    calculate leave based on various factors, such as which country the employee is
    in, whether they are in their probationary period, and how many years they have
    served at the company.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个涉及最小API端点的示例，该端点计算员工有多少年假。在这个例子中，根据不同的因素（如员工所在的国家、他们是否处于试用期以及他们在公司服务了多少年）有不同的计算休假的方法。
- en: 'Here is an example outline of the logic to calculate leave (not related to
    any specific labor laws in any country!):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个计算休假的逻辑示例大纲（与任何国家的特定劳动法无关！）：
- en: 'If the employee is in their probationary period, the following applies:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果员工处于试用期，以下适用：
- en: The minimum amount of leave awarded is 10 days
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励的最少休假天数是10天
- en: If the employee is based in the United Kingdom, they get an extra three days
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果员工在英国，他们将额外获得三天
- en: 'If the employee is not on probation, the following applies:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果员工不在试用期，以下适用：
- en: The minimum amount of leave awarded is 16 days
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励的最少休假天数是16天
- en: If the employee is based in the United Kingdom, they get an extra three days
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果员工在英国，他们将额外获得三天
- en: For each year of service, an extra day is awarded
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一年服务，将额外奖励一天
- en: There are a lot of factors in play here, but to start with, we can narrow down
    the operations required to calculate leave based on whether the employee is or
    is not on probation. This means we have two strategies to calculate leave, which
    we can switch to automatically. How do we achieve this?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多因素在起作用，但首先，我们可以根据员工是否处于试用期来缩小计算休假的所需操作。这意味着我们有两种计算休假的策略，我们可以自动切换。我们如何实现这一点？
- en: 'First, we create an interface to represent a strategy. It stipulates that we
    require a **CalculateLeaveAllowance()** function taking a parameter of type **Employee**
    and returning an integer:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个接口来表示一个策略。它规定我们需要一个**CalculateLeaveAllowance()**函数，该函数接受一个类型为**Employee**的参数并返回一个整数：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we’ll create **ProbationaryAnnualLeaveStrategy** , which implements the
    interface. Within this class, **CalculateLeaveAllowance** will encapsulate the
    logic to calculate the total leave available for a probationary employee:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建**ProbationaryAnnualLeaveStrategy**，该类实现了接口。在这个类中，**CalculateLeaveAllowance**将封装计算试用期员工可用的总休假的逻辑：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the same can be done for an employee who is not on probation:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，同样可以为不在试用期的员工做同样的事情：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The two strategies should be registered for dependency injection in **Program.cs**
    :'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两种策略应在**Program.cs**中进行注册以供依赖注入：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, an endpoint can be created to calculate the annual leave for a given
    **Employee** ID. Within the endpoint, we create the strategy based on whether
    or not the employee is on probation. We then retrieve **Employee** using the ID
    sent by the client and call the **CalculateLeaveAllowance()** function to get
    the result. This way, the appropriate strategy is automatically used to execute
    the correct logic, based on the data that was sent by the client in the request:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以创建一个端点来计算给定**Employee** ID的年假。在端点内部，我们根据员工是否处于试用期来创建策略。然后我们使用客户端发送的ID检索**Employee**，并调用**CalculateLeaveAllowance()**函数来获取结果。这样，根据客户端在请求中发送的数据，自动使用适当的策略来执行正确的逻辑：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By separating logic into individual strategies, the Strategy pattern allows
    minimal APIs to conform to the open/closed principle. It does that by allowing
    us to extend the code base with new functionality, rather than alter the existing
    code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将逻辑分离成单独的策略，策略模式允许最小化API符合开闭原则。它是通过允许我们通过添加新功能来扩展代码库，而不是修改现有代码来实现的。
- en: It also offers self-containment, meaning that ways of performing similar tasks
    do not cross-contaminate each other, which reduces the potential for bugs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了自包含性，意味着执行类似任务的方式不会相互污染，这减少了出现错误的可能性。
- en: Design patterns alone do not make a resilient system. Resiliency is achieved
    through a good understanding of where and how errors occur.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的设计模式并不能构建一个健壮的系统。健壮性是通过良好地理解错误发生的位置和方式来实现的。
- en: Years of service property required
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要服务年数属性
- en: The example in this section will work with the original **Employee** object
    used in [*Chapter 9*](B20968_09.xhtml#_idTextAnchor143) if you add an **int**
    property, called **YearsOfService** . We assume that you will have done this before
    attempting to follow this strategy pattern example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在[*第9章*](B20968_09.xhtml#_idTextAnchor143)中使用的原始**Employee**对象上添加一个名为**YearsOfService**的**int**属性，本节中的示例将能够工作。我们假设你在尝试遵循这个策略模式示例之前已经完成了这项工作。
- en: With that in mind, let’s move on to explore good practices around error handling
    in minimal APIs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们继续探讨在最小化API中关于错误处理的最佳实践。
- en: Error Handling
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: When it comes to the topic of error handling and resilience, the first is the
    method and the second is the outcome. By implementing effective error handling,
    we achieve resilience.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到错误处理和健壮性的话题时，第一个是方法，第二个是结果。通过实施有效的错误处理，我们实现了健壮性。
- en: So, while using **try/catch** across the code base is important, a standardized
    manner of handling errors at the top level is still critical. For a minimal API,
    middleware is an effective way to handle errors from the top level. Let’s explore
    an example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然在整个代码库中使用**try/catch**很重要，但在顶层以标准化的方式处理错误仍然至关重要。对于最小化API，中间件是处理顶层错误的有效方式。让我们通过一个例子来探讨。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section assumes that you read [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094)
    or that you already have an in-depth understanding of how to write middleware
    in ASP.NET.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设你已经阅读了[*第5章*](B20968_05.xhtml#_idTextAnchor094)或者你已经对如何在ASP.NET中编写中间件有深入的了解。
- en: Implementing middleware ensures that we have a global solution to error handling
    in a minimal API. Think of it as a giant **try/catch** that wraps around all of
    your minimal API’s endpoints.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中间件确保我们在最小化API中有一个全局的错误处理解决方案。把它想象成一个巨大的**try/catch**，它围绕了所有最小化API的端点。
- en: As we explored middleware extensively in [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094)
    , we do not need to go through the specifics of how middleware is built, so we
    shall dive straight into an example of an error-handling middleware class, as
    shown in the upcoming code blocks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在[*第5章*](B20968_05.xhtml#_idTextAnchor094)中广泛探讨了中间件，我们不需要详细说明中间件是如何构建的，因此我们将直接进入一个错误处理中间件类的例子，如即将到来的代码块所示。
- en: 'First, we create a class for the middleware, along with a constructor and an
    **InvokeAsync** method that can be used to initiate the middleware’s logic:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为中间件创建一个类，包括一个构造函数和一个可以用来启动中间件逻辑的**InvokeAsync**方法：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Following this, we can add a method that takes in the current **HttpContext**
    to handle any detected errors:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以添加一个接受当前**HttpContext**的方法来处理任何检测到的错误：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is worth noting that this middleware example for error handling could easily
    replace the similar error handling example in [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094)
    .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个用于错误处理的中间件示例可以很容易地替换[*第5章*](B20968_05.xhtml#_idTextAnchor094)中的类似错误处理示例。
- en: This middleware will catch an exception thrown higher up in the request pipeline,
    ensuring that the error is returned to the requesting client via **HttpContext**
    . This ensures a consistent error response to the client regardless of the endpoint
    that was called.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件将捕获请求管道中更高层抛出的异常，确保错误通过**HttpContext**返回给请求客户端。这确保了无论调用的是哪个端点，客户端都能收到一致的错误响应。
- en: 'As you will be aware from earlier in the book, middleware, such as services
    for dependency injection, must be registered in **Program.cs** . Register this
    middleware class as the first piece of middleware to be registered, and then create
    an example endpoint that throws an exception:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本书前面的内容中了解到的，中间件，例如依赖注入服务，必须在**Program.cs**中进行注册。将此中间件类注册为第一个要注册的中间件，然后创建一个示例端点，该端点会抛出异常：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should find that not only the message from the exception is returned but
    also a generic message, consistently, like the one shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会发现，不仅异常的消息被返回，而且还有一个一致性的通用消息，就像这里显示的那样：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another practice that should be consistent when developing any API is that of
    secure development. Let’s explore some good security practices that you can apply
    when authorizing requests to your minimal API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何API时，还应保持一致的实践是安全开发。让我们探讨一些您可以在授权请求到您的最小化API时应用的良好安全实践。
- en: Security considerations
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性考虑
- en: There are two critical areas of security within a minimal API – authentication
    and authorization. Regardless of their differences, the attitude toward their
    implementation should be largely the same – *don’t roll* *your own* .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化API中，有两个关键的安全领域——身份验证和授权。无论它们之间的差异如何，对其实施的态度应该大致相同——**不要自行实现**。
- en: This mantra serves as a warning that a proven security framework will usually
    be safer than one you devise yourself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格言作为一个警告，表明一个经过验证的安全框架通常比你自己设计的更安全。
- en: Let’s first look at the difference between authentication and authorization,
    as well as how you can achieve a good degree of security using the well-known
    technology **JSON Web** **Tokens** ( **JWTs** ).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看身份验证和授权之间的区别，以及您如何使用知名技术**JSON Web Tokens**（**JWTs**）实现良好的安全级别。
- en: Authentication
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: '**Authentication** verifies the identity of users or systems accessing your
    API. It allows you to allow only legitimate requests to enter a system.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**验证访问您的API的用户或系统的身份。它允许您只允许合法请求进入系统。'
- en: JWTs are widely used for their stateless authentication capabilities in minimal
    APIs. Users authenticate once and receive a token, which is included in subsequent
    requests to access protected resources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JWT因其最小化API中的无状态身份验证功能而被广泛使用。用户进行一次身份验证并接收一个令牌，该令牌包含在随后的请求中以访问受保护资源。
- en: Authorization
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: '**Authorization** is a means of checking to see whether an authenticated user
    is accessing resources within their specific permissions. In JWT, these permissions
    are known as **claims** .'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权**是一种检查已验证用户是否在其特定权限内访问资源的手段。在JWT中，这些权限被称为**声明**。'
- en: 'A claim can be the name of a resource or type of user, or it can be a role.
    Either way, JWT has built-in functionality to define and validate claims against
    specific endpoints in a minimal API:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个声明可以是资源的名称或用户类型，也可以是一个角色。无论如何，JWT都内置了在最小化API中针对特定端点定义和验证声明的功能：
- en: 'To get started with this authorization framework, we first need to add the
    **Microsoft.AspNetCore.Authentication.JwtBearer** NuGet package. Do this via the
    NuGet Package Manager Console, accessible via **Tools** | **NuGet Package Manager**
    | **Package** **Manager Console** :'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用此授权框架，我们首先需要添加**Microsoft.AspNetCore.Authentication.JwtBearer** NuGet包。通过**工具**
    | **NuGet包管理器** | **包管理器控制台**进行此操作，该控制台可通过**工具**菜单访问：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then need to ensure that **Program.cs** has the relevant namespaces:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要确保**Program.cs**有相关的命名空间：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'JWT can be implemented as a middleware, so it should first be set up in **Program.cs**
    :'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT可以作为中间件实现，因此首先应在**Program.cs**中设置：
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This registration specifies how your tokens are validated. Next, we need to
    provide a means of generating a token. We can do this by creating a dedicated
    API endpoint:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此注册指定了如何验证您的令牌。接下来，我们需要提供一种生成令牌的方法。我们可以通过创建一个专门的API端点来实现：
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, now that we have a means of creating a JWT token, we can create an
    endpoint that requires it. Let’s again create a simple **GET** endpoint, but this
    time, we add an **[Authorize]** attribute and chain **RequireAuthorization()**
    to it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，既然我们已经有了创建JWT令牌的方法，我们可以创建一个需要它的端点。让我们再次创建一个简单的**GET**端点，但这次，我们添加一个**[Authorize]**属性并将**RequireAuthorization()**链接到它：
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test this, we can make a **GET** request to this endpoint and add the returned
    JWT token as a bearer token. With an example JWT token, the header would look
    something like this:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个，我们可以对这个端点发起一个**GET**请求，并将返回的JWT令牌作为承载令牌添加。使用一个示例JWT令牌，头部看起来可能如下所示：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ASP.NET core will then authenticate the request, based on the validation parameters
    you specified when you registered the JWT middleware.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ASP.NET core将根据你在注册JWT中件间时指定的验证参数对请求进行身份验证。
- en: 'Taking this further, if we wanted to create a more restricted endpoint, which
    can only be accessed by users with the role claim, **Admin** , we can add a parameter
    to the **[** **Authorize]** attribute:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步来说，如果我们想创建一个更受限制的端点，只有具有角色声明**Admin**的用户才能访问，我们可以在**[Authorize]**属性中添加一个参数：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using JWT tokens, our minimal APIs are provided with protection against unauthorized
    activity. However, this alone will not guarantee that authorized use is not abused.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT令牌，我们的最小API提供了对未经授权活动的保护。然而，仅此并不能保证授权使用不会被滥用。
- en: In truth, it is impossible to guarantee this, but an extra step you can take
    to ensure that a minimal API is not abused is to limit the number of requests
    that can be made during a specified period. This practice is called **rate limiting**
    .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是无法保证的，但你可以采取的一个额外步骤来确保最小API不会被滥用，就是在指定时间段内限制可以发出的请求数量。这种做法被称为**速率限制**。
- en: Rate limiting
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率限制
- en: By controlling the number of requests a client can make to your minimal API
    within a specific timeframe, rate limiting can help prevent a system from being
    overwhelmed by too many requests, whether the requests are legitimate or not.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制客户端在特定时间段内对最小API发出的请求数量，速率限制可以帮助防止系统因请求过多而超负荷，无论请求是否合法。
- en: Let’s explore a simple example of rate limiting in an ASP.NET core minimal API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个ASP.NET core最小API中速率限制的简单示例。
- en: 'First, add the **AspNetCoreRateLimit** package from NuGet via the Package Manager
    Console. You can open this in Visual Studio by clicking **Tools** | **Manage NuGet
    Packages** | **Package Manager Console** . This will open the console, in which
    you can type the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过NuGet包管理器控制台添加**AspNetCoreRateLimit**包。您可以通过在Visual Studio中点击**工具** | **管理NuGet包**
    | **包管理器控制台**来打开它。这将打开控制台，您可以在其中输入以下内容：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, add rate limiting (along with memory caching) via **Program.cs** :'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过**Program.cs**添加速率限制（以及内存缓存）：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This configuration will limit all endpoints to a maximum of 100 requests per
    minute, per IP address. If the limit is exceeded, the client will receive a **429
    Too Many** **Requests** response.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将限制所有端点每分钟每个IP地址最多100个请求。如果超过限制，客户端将收到一个**429 Too Many Requests**的响应。
- en: To try this example out, change the maximum number of requests per minute to
    **2** and see what the results look like.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个示例，将每分钟的请求数量最大值更改为**2**，看看结果如何。
- en: AspNetCoreRateLimit versus Microsoft.AspNetCore.RateLimiting
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**AspNetCoreRateLimit**与**Microsoft.AspNetCore.RateLimiting**'
- en: There is another option for rate limiting besides **AspNetCoreRateLimit** ,
    shown in the preceding example. **Microsoft.AspNetCore.RateLimiting** can also
    be used to manage the rate of allowed requests. **AspNetCoreRateLimit** is a third-party
    library, while **Microsoft.AspNetCore.RateLimiting** is built-in middleware. For
    configuration, **AspNetCoreRateLimit** uses JSON or programmatic configuration,
    whereas **Microsoft.AspNetCore.RateLimiting** uses programmatic configuration
    with **RateLimiterOptions** .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**AspNetCoreRateLimit**之外，还有另一种速率限制的选项，如前例所示。**Microsoft.AspNetCore.RateLimiting**也可以用来管理允许请求的速率。**AspNetCoreRateLimit**是一个第三方库，而**Microsoft.AspNetCore.RateLimiting**是一个内置的中件间。对于配置，**AspNetCoreRateLimit**使用JSON或程序性配置，而**Microsoft.AspNetCore.RateLimiting**使用带有**RateLimiterOptions**的程序性配置。
- en: '**AspNetCoreRateLimit** offers more flexibility with different strategies and
    distributed rate limiting, while **Microsoft.AspNetCore.RateLimiting** focuses
    on built-in algorithms and endpoint-specific policies.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**AspNetCoreRateLimit**提供了不同的策略和分布式速率限制的更多灵活性，而**Microsoft.AspNetCore.RateLimiting**则专注于内置算法和端点特定策略。'
- en: We’ve only scratched the surface of the practices that can be implemented to
    improve resilience in minimal APIs, but the examples we have explored are a good
    starting point to improve their design. Let’s recap the practices that we’ve seen
    in this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了可以实施以提高最小API弹性的一些实践，但我们所探讨的例子是改进它们设计的一个良好起点。让我们回顾一下本章中我们看到的实践。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started by observing the justification for implementing effective design
    practices – namely, for an increase in resiliency from a maintained scalability
    and security perspective.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先观察了实施有效设计实践的合理性——即，从维护的可扩展性和安全性角度来看，增加弹性。
- en: We then looked at folder structures, with personal preferences discussed and
    a couple of folder structure examples outlined for use in a fresh project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了文件夹结构，概述了几个文件夹结构示例，用于在新的项目中使用。
- en: We then explored three design patterns in the form of factory, repository, and
    strategy, providing a solid foundation to arrange minimal API code in a scalable
    manner.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后以工厂、仓库和策略三种设计模式的形式探讨了三个设计模式，为以可扩展的方式安排最小API代码提供了坚实的基础。
- en: Then, we briefly reviewed an example of how middleware can act as a “global
    catch,” standardizing the way error responses are returned to a client, before
    finally exploring some simple ways of authenticating requests and limiting the
    rate at which they can be processed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要回顾了一个示例，说明中间件如何充当“全局捕获”，标准化向客户端返回错误响应的方式，最后探索了一些简单的请求认证和限制它们处理速率的方法。
- en: We’re moving closer to the end of the book, which means we will need to learn
    how to manage a minimal API that is deployed and active in a user base. With that
    in mind, the next chapter will cover the things we need to consider most when
    making our minimal API available to the wider world – testing, deployment, and
    documentation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正接近本书的结尾，这意味着我们需要学习如何管理一个在用户群体中部署和活跃的最小API。考虑到这一点，下一章将涵盖在我们将最小API提供给更广泛的世界时需要考虑的最重要的事情——测试、部署和文档。
