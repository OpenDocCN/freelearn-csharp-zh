<html><head></head><body>
        

                            
                    <h1 class="header-title">Lights, Cameras, and Shadows</h1>
                
            
            
                
<p class="mce-root">In the previous chapter, we created our game's terrain and made several customizations to the terrain, based on our design mock-up in <a href="df7798e1-3730-4af7-8c04-857d71ac78d2.xhtml" target="_blank">Chapter 3</a>, <em>Designing the Game</em>. We used shaping tools, painted the terrain, and added water. We even created our own tree from scratch. In addition, we created a material and imported a texture file.</p>
<p class="mce-root">In this chapter, we will explore cameras and lighting in Unity. We will start with a look at cameras to include perspectives, frustums, and Skyboxes. Next, we will learn a few uses of multiple cameras to include mini-maps. We will also cover the different types of lighting, explore reflection probes, and conclude with a look at shadows.</p>
<p>Specifically, we will cover the following concepts:</p>
<ul>
<li>Working with cameras</li>
<li>Using multiple cameras</li>
<li>Working with lighting</li>
<li>Implementing reflection probes</li>
<li>Understanding shadows</li>
</ul>
<p>If you want to use the same Unity project featured in this chapter, you can download the <kbd>Starting-Chapter-05.zip</kbd> file from the publisher's companion site. Once you download the file, decompress it and then open the project in Unity. It contains the completed work from the previous chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with cameras</h1>
                
            
            
                
<p>Cameras render scenes so that the user can view them. Think about the hidden complexity in that statement. Our games are 3D, but people playing our games view them on 2D displays such as a televisions, computer monitors, or mobile devices. Fortunately for us, Unity makes implementing cameras easy work.</p>
<p>Cameras are GameObjects and can be edited using transform tools in the Scene view as well as in the Inspector panel. Every scene must have at least one camera. In fact, when a new scene is created, Unity creates a camera named Main Camera. As you will see later in this chapter, a scene can have multiple cameras.</p>
<p>In the Scene view, cameras are indicated with a white camera silhouette, as shown in the following screenshot:</p>
<div><img src="img/faa1fe2a-b7bc-4675-9c0d-8a32d1c5f608.png"/></div>
<p>When we click our Main Camera in the Hierarchy panel, we are provided with a Camera Preview in the Scene view. This gives us a preview of what the camera sees as if it were in game mode. We will change this in <a href="6a3fb463-b0c2-4145-9096-bc52d55cf905.xhtml" target="_blank">Chapter 7</a>, <em>Implementing Our Player Character</em>. We also have access to several parameters via the Inspector panel. The Camera component in the Inspector panel is shown here:</p>
<div><img height="315" width="335" src="img/da4c15dd-68d8-4608-bf05-6d17aac6bc79.png"/></div>
<p>Let's look at each of these parameters with relation to our <em>Cucumber Beetle</em> game:</p>
<ul>
<li>The Clear Flags parameter lets you switch between Skybox, Solid Color, Depth Only, and Don't Clear. The selection here informs Unity which parts of the screen to clear. We will leave this setting as Skybox. You will learn more about Skyboxes later in this chapter.</li>
<li>The Background parameter is used to set the default background fill (color) of your game world. This will only be visible after all game objects have been rendered and if there is no Skybox. Our <em>Cucumber Beetle</em> game will have a Skybox, so this parameter can be left with the default color.</li>
<li>The Culling Mask parameter allows you to select and deselect the layers you want the camera to render. The default selection options are Nothing, Everything, Default, TransparentFX, Ignore Raycast, Water, and UI. For our game, we will select Everything. If you are not sure which layer a game object is associated with, select it and look at the Layer parameter in the top section of the Inspector panel. There you will see the assigned layer. You can easily change the layer as well as create your own unique layers. This gives you finite rendering control.</li>
<li>The Projection parameter allows you to select which projection, perspective or orthographic, you want for your camera. We will cover both of those projections later in this chapter. When <em>perspective</em> projection is selected, we are given access to the Field of View parameter. This is for the width of the camera's angle of view. The value range is 1-179°. You can use the slider to change the values and see the results in the Camera Preview window. When orthographic projection is selected, an additional Size parameter is available. This refers to the viewport size. For our game, we will select perspective projection with the Field of View set to <kbd>60</kbd>. </li>
<li>The Clipping Planes parameters include Near and Far. These settings set the closest and furthest points, relative to the camera, that rendering will happen at. For now, we will leave the default settings of <kbd>0.3</kbd> and <kbd>1000</kbd> for the Near and Far parameters, respectively.</li>
<li>The Viewport Rect parameter has four components – X, Y, W, and H – that determine where the camera will be drawn on the screen. As you would expect, the X and Y components refer to horizontal and vertical positions, and the W and H components refer to width and height. You can experiment with these values and see the changes in the Camera Preview. For our game, we will leave the default settings.</li>
<li>The Depth parameter is used when we implement more than one camera. We can set a value here to determine the camera's priority in relation to others. Larger values indicate a higher priority. The default setting is sufficient for our game.</li>
<li>The Rendering Path parameter defines what rendering methods our camera will use. The options are Use Graphics Settings, Forward, Deferred, Legacy Vertex Lit, and Legacy Deferred (light prepass). We will use the Use Graphics Settings option for our game, which also uses the default setting.</li>
<li>The Target Texture parameter is not something we will use in our game. When a render texture is set, the camera is not able to render to the screen.</li>
<li>The Occlusion Culling parameter is a powerful setting. If enabled, Unity will not render objects that are occluded, or not seen by the camera. An example would be objects inside a building. If the camera can currently only see the external walls of the building, then none of the objects inside those walls can be seen. So, it makes sense to not render those. We only want to render what is absolutely necessary to help ensure our game has smooth gameplay and no lag. We will leave this as enabled for our game.</li>
<li>The Allow HDR parameter is a checkbox that toggles a camera's <strong>High Dynamic Range</strong> (<strong>HDR</strong>) rendering. We will leave the default setting of enabled for our game.</li>
<li>The Allow MSAA parameter is a toggle that determines whether our camera will use a <strong>Multisample Anti-Aliasing</strong> (<strong>MSAA</strong>) render target. MSAA is a computer graphics optimization technique and we want this enabled for our game.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding camera projections</h1>
                
            
            
                
<p>There are two camera projections used in Unity: perspective and orthographic. With perspective projection, the camera renders a scene based on the camera angle, as it exists in the scene. Using this projection, the further away an object is from the camera, the smaller it will be displayed. This mimics how we see things in the real world. Because of the desire to produce realistic games, or games that approximate the realworld, perspective projection is the most commonly used in modern games. It is also what we will use in our <em>Cucumber Beetle</em> game.</p>
<p>The other projection is orthographic. An orthographic perspective camera renders a scene uniformly without any perspective. This means that objects further away will not be displayed smaller than objects closer to the camera. This type of camera is commonly used for top-down games and is the default camera projection used in 2D and Unity's UI system.</p>
<p>We will use perspective projection for our <em>Cucumber Beetle</em> game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Orientating your frustum</h1>
                
            
            
                
<p>When a camera is selected in the Hierarchy view, its frustum is visible in the Scene view. A frustum is a geometric shape that looks like a pyramid that has had its top cut off, as illustrated here:</p>
<div><img height="119" width="181" src="img/62ef6855-c538-4da0-949d-806725dc3d31.png"/></div>
<p>The near, or top, plane is parallel to its base. The base is also referred to as the far plane. The frustum's shape represents the viable region of your game. Only objects in that region are rendered. Using the camera object in Scene view, we can change our camera's frustum shape. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Skybox </h1>
                
            
            
                
<p>When we create game worlds, we typically create the ground, buildings, characters, trees, and other game objects. What about the sky? By default, there will be a textured blue sky in your Unity game projects. That sky is sufficient for testing but does not add to an immersive gaming experience. We want a bit more realism, such as clouds, and that can be accomplished by creating a Skybox. </p>
<p>A Skybox is a six-sided cube visible to the player beyond all other objects. So, when a player looks beyond your objects, what they see is your Skybox. As we said, Skyboxes are six-sided cubes, which means you will need six separate images that can essentially be clamped to each other to form the cube. </p>
<p>The following screenshot shows the <strong>Default Skybox</strong> that Unity projects start with as well as the completed <strong>Custom Skybox</strong> you will create in this section:</p>
<div><img height="231" width="183" src="img/7773dbf4-8633-4200-a584-64c150d43ef4.png"/></div>
<p>To follow along, you will need the six images located in the <kbd>Chapter5-Skybox.zip</kbd> file on the publisher's companion site.</p>
<p>Perform the following steps to create a Skybox:</p>
<ol>
<li>In the Project panel, create a <kbd>Skybox</kbd> subfolder in the <kbd>Assets</kbd> folder. We will use this folder to store our textures and materials for the Skybox.</li>
</ol>
<p> </p>
<ol start="2">
<li>Drag the provided six Skybox images, or your own, into the new <kbd>Skybox</kbd> folder. </li>
<li>Ensure the <kbd>Skybox</kbd> folder is selected in the <kbd>Project</kbd> panel. </li>
<li>From the top menu, select Assets | Create | Material. In the Project panel, name the material <kbd>Skybox</kbd>.</li>
<li>With the Skybox material selected, turn your attention to the Inspector panel. </li>
<li>Select the Shader drop-down menu and select SkyBox | 6 Sided.</li>
<li>Use the Select button for each of the six images and navigate to the images you added in step 2. Be sure to match the appropriate texture to the appropriate cube face. For example, the <kbd>SkyBox_Front</kbd> texture matches the <kbd>Front[+Z]</kbd> cube face on the Skybox Material.</li>
<li>In order to assign our new Skybox to our scene, select Window | Lighting | Settings from the top menu. This will bring up the Lighting settings dialog window.</li>
<li>In the Lighting settings dialog window, click on the small circle to the right of the Skybox Material input field. Then, close the selection window and the Lighting window. Refer to the following screenshot:</li>
</ol>
<div><img height="341" width="331" src="img/d35925b2-1a99-424e-a187-5024c1d10830.png"/></div>
<p>You will now be able to see your Skybox in the Scene view. When you click on the Camera in the Hierarchy panel, you will also see the Skybox as it will appear from the camera's perspective.</p>
<p>Be sure to save your scene and your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using multiple cameras</h1>
                
            
            
                
<p>Our Unity games must have a least one camera, but we are not limited to using just one. As you will see in <a href="6a3fb463-b0c2-4145-9096-bc52d55cf905.xhtml" target="_blank">Chapter 7</a>, <em>Implementing Our Player Character</em>, we will attach our main camera, or primary camera, to our player character. It will be as if the camera is following the character around the game environment. This will become the eyes of our character. We will play the game through our character's view.</p>
<p>A common use of a second camera is to create a mini-map that can be seen in a small window on top of the game display. These mini-maps can be made to toggle on and off or be permanent/fixed display components. Implementations might consist of a fog-of-war display, a radar showing enemies, or a global top-down view of the map for orientation purposes. You are only limited by your imagination. In <a href="6e2e628c-4c81-4ec3-bd4f-2ae0f2a29aab.xhtml" target="_blank">Chapter 9</a>, <em>Adding a Heads-Up Display</em>, we will create a mini-map as a radar showing where beetles are in relation to the Cucumber Man's current position. </p>
<p>Another use of multiple cameras is to provide the player with the ability to switch between third-person and first-person views. You will remember from <a href="f4fba83f-4f23-4537-a130-ed8dab8f3815.xhtml" target="_blank">Chapter 1</a>, <em>Downloading and Installing Unity</em>, that the first-person view puts the player's arms in view, while in the third-person view, the player's entire body is visible. We can use two cameras in the appropriate positions to support viewing from either camera. In a game, you might make this a toggle—say, with the <em>C</em> keyboard key—that switches from one camera to the other. Depending on what is happening in the game, the player might enjoy this ability. </p>
<p>Some single-player games feature multiple playable characters. Giving the player the ability to switch between these characters gives them greater control over the game strategy. To achieve this, we would need to have cameras attached to each playable character and then give the player the ability to swap characters. We would do this through scripting. This is a pretty advanced implementation of multiple characters.</p>
<p>Another use of multiple cameras is adding specialty views in a game. These specialty views might include looking through a door's peep-hole, looking through binoculars at the top of a skyscraper, or even looking through a periscope. We can attach cameras to objects and change their viewing parameters to create unique camera use in our games. We are only limited by our own game designs and imagination.</p>
<p>We can also use cameras as cameras. That's right! We can use the camera game object to simulate actual in-game cameras. One example is implementing security cameras in a prison-escape game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with lighting</h1>
                
            
            
                
<p>In the previous sections, we explored the uses of cameras for Unity games. Just like in the real world, cameras need lights to show us objects. In Unity games, we use multiple lights to illuminate the game environment.</p>
<p>In Unity, we have both dynamic lighting techniques as well as light baking options for better performance. We can add numerous light sources throughout our scenes and selectively enable or disable an object's ability to cast or receive shadows. This level of specificity gives us tremendous opportunity to create realistic game scenes.</p>
<p>Perhaps the secret behind Unity's ability to so realistically render light and shadows is that Unity models the actual behavior of lights and shadows. Real-time global illumination gives us the ability to instantiate multiple lights in each scene, each with the ability to directly or indirectly impact objects in the scene that are within range of the light sources.</p>
<p>Indirect light refers to lights bouncing off objects and reflecting on other objects.</p>
<p>We can also add and manipulate ambient light in our game scenes. This is often done with Skyboxes, a tri-colored gradient, or even a single color. Each new scene in Unity has default ambient lighting, which we can control by editing the values in the the Lighting window. In that window, you have access to the following settings:</p>
<ul>
<li>Environment</li>
<li>Real-time Lighting</li>
<li>Mixed Lighting</li>
<li>Lightmapping Settings</li>
<li>Other Settings</li>
<li>Debug Settings</li>
</ul>
<p>No changes to these are required for our game at this time. We have already set the environmental lighting to our Skybox. In <a href="f7abb907-5397-4668-972e-e69acb441421.xhtml" target="_blank">Chapter 12</a>, <em>Adding Audio and Visual Effects to Our Game</em>, we will look at Fog, which is available under the Other Settings section of the Lighting window.</p>
<p>When we create our scenes in Unity, we have three options for lighting. We can use real-time dynamic light, use the baked lighting approach, or use a mixture of the two. Our games perform more efficiently with baked lighting, compared to real-time dynamic lighting, so if performance is a concern, try using baked lighting where you can.</p>
<p>In addition to ambient lighting, there are four types of light: directional, point, spot, and area. We will look at each of these in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directional lighting</h1>
                
            
            
                
<p>When we create a new scene in Unity, a directional light is automatically created for us. This emphasizes the importance of directional lights. This type of light provides illumination in a specific direction. Using transform tools, we have full control over the direction of these lights. </p>
<p>An example of directional lighting is generating sunlight in our scenes. Although the light from directional lights is similar to that of the sun, there is no actual sun-like object that the light comes from. As shown in the following screenshot, Directional Lights, when selected, indicate the direction of its illumination with yellow rays:</p>
<div><img height="219" width="234" src="img/2ae83abf-dfc6-4dca-b7fc-6a901b483150.png"/></div>
<p>One of the great aspects of using directional lighting is that illumination strength is not dependent on an object's distance from the Directional Light object. This type of lighting defines the direction of the light, and distance has no impact on the illumination. </p>
<p>With a Directional Light selected, you have access to several parameters in the Inspector panel. In addition to the Transform section, there is a Light section where you can change several settings to include the light color and intensity. The remaining parameters are worth exploring and no changes are required to complete our game.</p>
<p>To add additional directional lights, you would select, from the top menu, GameObject | Light | Directional Light.</p>
<p>For the <em>Cucumber Beetle</em> game, we will keep the default Directional Light. You can use the transform tools to modify the location, rotation, and light direction. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Point lighting</h1>
                
            
            
                
<p>Point lights get their name from the fact that they are lights sources emanating from a specific point. These light objects, as indicated in the following diagram, emit light in all directions:</p>
<div><img height="278" width="288" src="img/3a86bee4-295d-4e8f-838f-f023d65aca92.png"/></div>
<p>These lights are typically used to simulate fireballs or light bulbs. They can also be used to simulate some magic or special lighting effects. As you can see in the following screenshot, point lights have several properties that affect how they impact the game environment:</p>
<div><img height="137" width="295" src="img/efc38960-980e-4b4e-b690-362249b3e8c3.png"/></div>
<p>The Range is the distance between the center of the light to the outside arc of the light. We can also change the Color and Intensity to produce the results we desire.</p>
<p>To create a point light, we select GameObject | Light | Directional Light from the top menu.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spot lighting</h1>
                
            
            
                
<p>Spot lights are another type of lighting in Unity. They are meant to provide lighting on a specific spots. Common examples are flashlights and vehicle headlights. As you can see from the following screenshot, the light originates from the source in an outward cone shape:</p>
<div><img height="229" width="134" src="img/cca867e9-6bab-453f-a451-5dc20a4d9e6b.png"/></div>
<p>In the Inspector panel, we can change the Range, Spot Angle, Color and Intensity. Range, in this context, refers to the distance between the light source and the furthest point in the cone. The Spot Angle is the angle of the outward exterior edge of the cone shape. The Spot Angle range is 1-179°. The larger the value is, the larger the cone face will be.</p>
<p>To create a spotlight, we select GameObject | Light | Spot Light from the top menu.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Area lighting</h1>
                
            
            
                
<p>To use an area light, we define a rectangle using the transform tools or the Inspector panel. Area lights emit light from one side of their rectangle. The following screenshot shows what an area light object looks like in the Unity editor:</p>
<div><img height="283" width="348" src="img/42e8ea41-a204-4319-bce7-1ada809160e6.png"/></div>
<p>Area lights are unique from the other types of light as they can only be baked. This means that real-time rendering will not take place during gameplay. The reason for this is to conduct all the processing regarding area lights prior to gameplay. This processing, if accomplished in real time in a game, would likely result in sufficient lag.</p>
<p>As you can see in the following screenshot, the Type is set as Area (baked only) and cannot be changed:</p>
<div><img height="230" width="286" src="img/59474f91-f7c8-4f9f-9667-9e715f25310a.png"/></div>
<p>Area lights can be used instead of point lights when baked lighting is okay and you desire software shadows.</p>
<p>To create an area light, we select GameObject | Light | Area Light from the top menu.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing reflection probes</h1>
                
            
            
                
<p>Reflection probes capture a 360° spherical view of their surroundings. In this sense, it is somewhat like a camera. That captured image is used by nearby objects that have reflective materials.</p>
<p>To create a reflection probe, we select GameObject | Light | Reflection Probe from the top menu.</p>
<p>As you can see from the following screenshot, the reflection probe is a sphere and has captured the view of its surroundings. When objects are placed in close proximity to the reflection probe, the reflections will be visible on the object:</p>
<div><img height="252" width="233" src="img/869cbf2e-a76c-4ead-934b-0690abce3f28.png"/></div>
<p>A review of a reflection probe in the Inspector panel, shown as follows, reveals several settings that we can change to affect how the probe works and how it impacts our game environment:</p>
<div><img height="312" width="209" src="img/eb3bf621-160c-45a6-b05d-9ec934a0a8bf.png"/></div>
<p>The following list of properties highlights the ones you are most likely to change in the Unity games you create:</p>
<ul>
<li>Type: You can select Baked, Custom, or Realtime. Remember, we can improve game performance if we bake our lighting whenever possible.</li>
<li>Importance: When there are multiple rendering probes in the area, you can set the importance of each of them. The higher the value, the greater the importance.</li>
<li>Intensity: The lowest value is zero. You can experiment with the results of changing this setting.</li>
<li>Resolution: You can select 16, 32, 64, 128, 256, 512, 1024, or 2048 for the resolution of the captured image reflection.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding shadows</h1>
                
            
            
                
<p>As indicated earlier in this chapter, our game scenes can have numerous light sources, and we can enable or disable an object's ability to cast or receive shadows. We have shadows in the real world and it is important to consider, for our Unity games, what objects cast shadows and what objects receive shadows. </p>
<p>The following screenshot shows the Mesh Renderer component of an object in the Inspector panel. Let's review the key settings of this component:</p>
<div><img height="215" width="287" src="img/13a70f50-0219-4806-84bf-3b33d32695df.png"/></div>
<ul>
<li>Light Probes: It can be set to Blend Probes, Use Proxy Volume, or Off. You will most likely use the default Blend Probes for simple Unity games.</li>
<li>Reflection Probes: This setting can be turned off or set to Blend Probes, Blend Probes And Skybox, or Simple. </li>
<li>Cast Shadows: This setting can be set to On, Off, Two-Sided, or Shadows Only. The default is On, so you should disable this for all objects that do not need to cast shadows. </li>
<li>Receive Shadows: This setting is a toggle that tells Unity whether you want that object to receive shadows or not. As you would expect, this takes extra processing to display during the game. So, if you do not need an object to receive shadows, deselect this for greater performance.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we explored cameras and lighting. We started with a look at cameras that included perspectives, frustums, and Skyboxes. Next, we learned possible uses of multiple cameras in Unity games. We also covered the different types of lighting, explored reflection probes, and concluded with a look at shadows.</p>
<p>In the next chapter, we will create 3D objects using Unity's native toolset. We will also import several objects into our game to complete our game environment, including the tree we made in <a href="04be4d7b-8c85-4d9e-baf2-43965183f99f.xhtml" target="_blank">Chapter 4</a>, <em>Creating Our Terrain</em>. </p>


            

            
        
    </body></html>