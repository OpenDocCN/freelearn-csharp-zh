<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Game Loop and Update Method</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to explore the Game Loop and Update Method. Both are core game development patterns that are often confused with each other by beginners because they both can be associated with the concept of continuous looping sequences. But, as we are going to see, the Game Loop and Update Method might be related, but have very distinct responsibilities and are implemented on different layers of Unity's architecture.</p>
<p>If we want to understand the core principles behind the Game Loop and Update Method, then we need to consider what video games are in their most basic forms. The best definition I have encountered is that video games are simulations composed of interactive virtual spaces filled with objects and animated entities, with distinct behaviors. These virtual spaces are drawn frame by frame on a screen, while the continually-running system listens and reacts accordingly to a user's input.</p>
<p>But what exactly makes it possible for a video game to continually run a simulation and react to a user's input without any latency? The answer is the combination of the Game Loop, which can be described as the heartbeat of a running game, but also the Update Method, which can act as the ears of the system.</p>
<p>But as a Unity developer, you will never have to write a Game Loop or Update Method by hand, because they are already natively implemented in the engine. So, in the following sections, we are just going to explore the theory behind these patterns, so that we are of their presence when we are working in Unity.</p>
<p>The following topic will be covered in this chapter:</p>
<ul>
<li>A quick review of the core concepts behind the Game Loop and Update Method patterns</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will focus on theory instead of practice; a basic understanding of programming is enough for this material.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What makes a game run?</h1>
                </header>
            
            <article>
                
<p>As stated before, video games are simulations; a bullet buzzing through the air and then hitting an enemy combatant in <em>Call of Duty</em> is made possible because of a collection of systems interacting together to give the illusion that a 3D cylinder-shaped mesh traveling through space on a curved vector is being affected by gravity and wind resistance.</p>
<p>But the question we need to answer is, what is driving all these systems to run in perfect synchronization? Contrary to a spreadsheet or a browser, a video game is not event-driven; it's continuously processing, even when the player is not pressing any buttons. By implementing the Game Loop pattern, it's possible to have a system that cycles on itself at a constant rate, while calling sub-systems in perfect synchronicity, but still being able to react dynamically to a user's input.<br/></p>
<p>So, in this section, we will review two core concepts: the implementation of the main loop, and the importance of timing, because the primary purpose of the Game Loop is to simulate time, not just execute code over and over again.</p>
<div class="packt_tip">You might notice that game designers often talk about core game loops. They are usually referring to what we call experience or reward loops. This subject is beyond the scope of this book, but we could say that games are composed of loops at almost every level.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main loop</h1>
                </header>
            
            <article>
                
<p class="mce-root">Even during the early 1980s, when programmers wrote games in pure assembly language without the help of an engine such as Unity, the concept of Game Loops existed. During that time, the implementation of a Game Loop needed to be precise in its timing, because it had to synchronize correctly with the movement of a CRT's television electron gun, or the image on the screen would get distorted and the game would become unresponsive.</p>
<p class="mce-root"/>
<p>The following is an example of a game loop written in assembly for an Atari 2600. You can see the main routine calling a specific sequence of sub-routines cyclically. Each sub-routine runs at a particular phase of an analog television's screen drawing sequence. Between every step, you can do calculations, capture the player's input, or draw sprites:</p>
<pre class="mce-root">Main: <br/> jsr VSync ; Beginning of frame<br/> jsr VBlank ; Wait for electron gun to line up <br/> jsr Draw ; Draw sprites, UI and background<br/> jsr OverScan ; Ending frame<br/> jmp Loop ; Loop again</pre>
<p>The modern day implementations of a game loop are not that different, they might be more sophisticated, but the core principles and sequencing pattern are similar. Every game loop must gather the player's input data and calculate new transforms on the entities in the scene before calling the rendering pipeline (also known as the draw loop). You can't draw something before knowing where things are supposed to be related to the most recent input of the player.</p>
<p>In this section, we reviewed that one of the primary responsibilities of the Game Loop is to make sure that subroutines are called in the right order at every cycle. In other words, it's maintaining a continuous sequence of system calls. But in the next section, we are going to review another important responsibility of the Game Loop, which is keeping a degree of consistent timing.</p>
<div class="packt_tip">Always keep in mind that a Game Loop and the Update Method are related, but they're not the same. They're both sequential patterns, but are not implemented the same way, and don't have the same responsibilities.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">It's all about timing</h1>
                </header>
            
            <article>
                
<p>As with comedy, timing is key to game programming; complex physics calculations are executed while thousands of pixels are rendered on a screen in a matter of milliseconds. Being aware of what is being called at every frame is key to mastering optimization.</p>
<p>In an engine such as Unity, the core game loop and rendering pipeline are abstracted, and we can only hook into its sequencing mechanism by the Scripting API's magic functions, such as: <kbd>FixedUpdate()</kbd>, <kbd>Update()</kbd>, and <kbd>LateUpdate()</kbd>. This approach permits the engine to protect its internal clock and its established sequence of system calls, while giving us the ability to execute code at specific moments of the Game Loop safely.</p>
<p>But the trade-off is that we lose granular control over the exact moment a specific system is updated. In most cases, this is not an issue, but for massive AAA production, this limitation can be a deal-breaker. Often, complex CPU-intensive games need a more granular approach to managing the timing of precise calculations; when having a ticking mechanism, this becomes essential. Instead of relying on trying to synchronize with the CPU's internal clock, Game Loops have a ticking mechanism that's very similar to what an analog watch might have. Like a clock, the Game Loop doesn't cycle around, but ticks. The Game Loop manages the variation of time between these ticks instead, depending on available operating systems and hardware resources. This approach permits us to have a more granular control in the way we schedule the processing time of specific game systems between every frame.</p>
<p>In the game industry, the terms <em>frame</em> and <em>tick</em> are often used interchangeably, but be careful, because they're not necessarily synonyms. We could say a <strong>frame</strong> is a unit of time based on the delay it takes to generate and draw a new frame onto the screen. And a <strong>tick</strong> is a unit of time that's related to a game's internal clock, which is simulated by the execution of the main game loop; it's similar to an analog clock's second hand ticks as it goes around the clock.</p>
<p>In the previous sections, we examined a very high-level and simplified overview of the Game Loop pattern. Of course, the actual implementation details of a Game Loop in a modern AAA game engine is beyond the scope of this book. For those that want to dive deep into the subject matter, and have a more academic understanding of the subject matter, I recommend reading the listed books in the <em>Further reading</em> section.</p>
<p>In the next section, we are going to explore Unity's implementation of the Update method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Update Method</h1>
                </header>
            
            <article>
                
<p>If we all agree that the Game Loop pattern's main goal is to abstract a CPU's clock cycle by implementing a ticker so we can time the execution of our code on every frame, in a consistent manner, then we could say that the Update Method pattern simplifies this process by offering a way to encapsulate our game entities, and let them update themselves on each frame.</p>
<p class="mce-root"/>
<p>In the following section of this book, we are going to review the Update Method and its implementation inside the Unity engine.</p>
<div class="packt_tip"><span>Over the years, I've noticed that game programming consists mostly of manipulating data with perfect timing. So, knowing how to manage data, and time, is essential for mastery of game programming.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview</h1>
                </header>
            
            <article>
                
<p>One of the biggest challenges of implementing a Game Loop is keeping track of all the entities contained inside a scene, and how to update their states at every frame. But the Update Method offers a scalable, but straightforward solution, by having every object expose an <kbd>Update()</kbd> function that's called every frame.</p>
<p>The Game Loop is not aware of the content of the <kbd>Update()</kbd> function of each object, just that every object that has one should be called at every frame. So, we are basically encapsulating the updating process of each game object's state through a single interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenge</h1>
                </header>
            
            <article>
                
<p>As we can see in the following example, a basic Game Loop implementation looks simple, but can be very complicated to implement correctly:</p>
<pre>while (true)<br/>{<br/>    Capture();    // Listen and process the player's input. <br/>    Update();    // Update the scene entity's positions and states.<br/>    Render();   // Draw the frame.<br/>}</pre>
<p>Once we capture the player's controller inputs, we must update the transforms and states of our game's objects before drawing them on the screen. But to achieve this, we need to know what entities to update, and how to request them to do so. If these entities don't have a common object type or interface, we will need to manage them on a case-by-case basis:</p>
<pre>Update()<br/>{<br/>    sceneEntities = scene.getEntities();<br/><br/>    for each entity in sceneEntities<br/>    {   <br/>        switch (entity.type)<br/>        {<br/>            case Player:<br/>            MovePlayer()<br/>            break;<br/>            <br/>            case Camera:<br/>            MoveCamera()<br/>            break;<br/><br/>            // This switch case will get long. <br/>            // Let's find a better way to do this.<br/>            ..........<br/>    }<br/>}</pre>
<p>But our problems don't stop there; we also need to maintain a dynamic list of entities that will hold each object during their entire lifespan. As we can see, this type of approach doesn't scale well for larger games. So, the best solution would be to let the entities update themselves at every frame. In other words, let's have them encapsulate their behaviors, and the easiest to way to remind them to update themselves is to have a standard public function that we can call at every frame.</p>
<p>Let's see in the next section how we can resolve all these issues with the Update Method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solution</h1>
                </header>
            
            <article>
                
<p>Now that we have found a solution that offers a standard interface to our game's scene entities and encapsulates them, we still need to maintain a list. Games are dynamic software; entities explode and spawn in a matter of seconds, manually managing a list of objects is error-prone.</p>
<p>But, if we had a common type for all our game's objects, then it will be easy for us to dynamically maintain a list of entities, and walk through it at every frame. If we have a container that holds all our game's objects, such as a scene, then we could iterate through it to find all the objects of a specific type, and call their <kbd>Update()</kbd> method.</p>
<p>That's mostly what <kbd>MonoBehaviour</kbd> is in Unity; it offers a common parent type for objects that are in a scene that need to update themselves at every frame. So, any component that is a child of the <kbd>MonoBehaviour</kbd> parent class has a magic method named <kbd>Update()</kbd>, which is called at every frame. So, while Unity does all the heavy lifting under the hood, you can focus on implementing the behaviors that you want to <em>tick</em> (update) at every frame by writing them inside a script's <kbd>Update()</kbd> method.</p>
<p class="mce-root"/>
<p>In the next section, we will dive deeper into Unity's implementation of the Update Method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unity's Update Method</h1>
                </header>
            
            <article>
                
<p>As a Unity developer, we don't need to implement our Update Method; it's native to the engine's scripting API. But the Unity engineers expanded on the core concept and exposed several types of <kbd>Update()</kbd> methods; each one permits us to execute code at different moments in the period of a frame.</p>
<p><span>The following diagram is an example of the steps of execution during the time it takes to render a frame to the screen:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1f4bef2-9388-44b6-a310-2eea7f70b8a5.png"/></p>
<p>Each step in the diagram is completed in less than 1/30 of a second and in a constant order. But the Unity engineers had the foresight to know that having a singular <kbd>Update()</kbd> is not enough, because specific systems need to be processed in different moments of a frame. So they decided to expose three main types of <kbd>Update()</kbd> methods, which we'll review individually.</p>
<p>Take note that only objects that are active in a scene and that inherit from the <kbd>MonoBehaviour</kbd> parent class will have their various <kbd>Update()</kbd> methods called:</p>
<ul>
<li><strong>Update()</strong>: This method is called on at the same frequency as the game's frame rate, which might be inconsistent, but at least frequent. In it, you should only implement code that needs to be executed in correspondence with every rendered frame. Because of its higher call frequency, it's a good place to implement your input listeners.</li>
<li><strong>LateUpdate()</strong>: This method is called after <kbd>Update()</kbd>. It's for code that needs to be executed after the completion of a call to <kbd>Update()</kbd>. Useful for camera movement translations that are dependent on the movement of a character that is being controlled by the player.</li>
<li><strong>FixedUpdate()</strong>: This method is called each time the physics simulation is ticked (updated). The timing of the calls of the <kbd>FixedUpdate()</kbd> method offers stable delta times between each frame. This approach is necessary for physics calculations and the simulation of certain types of behaviors, such as accelerated motion.<br/>
The following segment showcases the intervals between an <kbd>Update()</kbd> and a <kbd>FixedUpdate()</kbd>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c21f590-324b-48fa-bcba-056a6aced3f8.png" style="width:23.92em;height:10.25em;"/></p>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 90px">As we can see, a <kbd>FixedUpdate()</kbd> call is consistent, while an <kbd>Update()</kbd> varies over time.</p>
<p>The following is what the various Update Methods look like inside a typical <kbd>MonoBehaviour</kbd> script:</p>
<pre><span>void FixedUpdate ()</span><br/><span>{</span><br/><br/><span>}</span><br/><br/><span>void Update ()</span><br/><span>{</span><br/><br/><span>}</span><br/><br/><span>void LateUpdate ()</span><br/><span>{</span><br/><br/><span>}</span></pre>
<p>The most important takeaway is that we always need to be aware of when our code will be executed. Unity simplifies this task for us by abstracting the inner ticking (updating) mechanisms of the engine and exposing it through the API in the form of various Update Methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we reviewed the Game Loop pattern and its core principles. Like many modern engines, Unity abstracts the inner working of its core game loop, instead of some API hooks, which permits us to control the timing of the execution of our code at each frame, without having to synchronize manually with the CPU's internal clock.</p>
<p>We also skated over the surface of the core concepts that encompass the Update Method pattern. As Unity programmers, we don't need to manually implement this pattern because it's native to the scripting API, but we still have to be aware of its purpose. A solid understanding of the timing and sequencing of Unity's update functions is essential. Even if we don't know what's happening under the hood, we can at least have control over the sequence of execution of our code.</p>
<p>In the next chapter, we will dive into practical design patterns and apply them to resolve real-life game architecture issues and challenges. Our first subject will be the <em>Prototype</em> pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Game Engine Architecture</em> by Jason Gregory:<strong><br/></strong><a href="http://www.gameenginebook.com">http://www.gameenginebook.com</a><strong><br/></strong></li>
<li><em><span>Racing the Beam</span></em> by Nick Montfort and Ian Bogost:<strong><br/></strong> <a href="https://mitpress.mit.edu/books/racing-beam">https://mitpress.mit.edu/books/racing-beam</a></li>
</ul>


            </article>

            
        </section>
    </body></html>