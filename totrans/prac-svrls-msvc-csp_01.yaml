- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying Serverless Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to software development, we are living in incredible times. With
    the evolution of cloud platforms and the rise of modern technologies, being a
    developer nowadays is both a wonderful way to live and a challenging profession
    to follow. There are so many ways to deliver an application and so many innovative
    technologies to explore that we may fall into a vicious circle where we focus
    more on the technologies rather than the actual solution.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to present the serverless architecture and explore how you
    can use this approach to implement a microservices application. To achieve this,
    it covers the theory behind serverless and provides an understanding of how it
    can be a viable alternative for microservices implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter also explores how Microsoft implements **Function as a Service
    (FaaS),** using Azure Functions as one of the options for building microservices.
    Two alternative development platforms will be presented: Visual Studio Code and
    Visual Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the different triggers available
    in Azure Functions and be ready to create your first function.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2022 free *Community edition* or Visual
    Studio Code. During the chapter, the details about how to debug Azure Functions
    for each development environment will be presented in the topics. You will also
    need an Azure account to create the sample environment. You can find the sample
    code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  prefs: []
  type: TYPE_NORMAL
- en: What is serverless?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When someone asks you to develop a solution, the last thing they usually care
    about is how the infrastructure will work. The truth is, even for developers,
    the most important thing about infrastructure is that it simply works well.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this reality, the possibility of having a cloud provider that dynamically
    manages server allocation and provisioning, leaving the underlying infrastructure
    to the provider, might be the best scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is what serverless architecture promises: a model we can use to build
    and run applications and services without having to manage the underlying infrastructure
    ourselves! This approach abstracts server management entirely, allowing developers
    to focus on their code.'
  prefs: []
  type: TYPE_NORMAL
- en: The first cloud solution provider that presented this concept was Amazon, with
    the launch of AWS Lambda in 2014\. After that, Microsoft and Google also provided
    similar solutions with Microsoft Azure Functions and Google Cloud Functions. As
    we mentioned before, the focus of this book will be Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are many advantages that we can consider for using serverless computing.
    The fact that you do not have to worry about scaling can be considered the main
    one. Additionally, the cloud solution provider maintains the reliability and security
    of the environment. Besides that, with this approach, you have the option to pay
    as you go, so you only pay for what you use, enabling a sustainable model of growth.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless can also be considered a good approach for accelerating software
    development since you only focus on the code needed to deliver that program. On
    the other hand, you may have difficulty overseeing a considerable number of functions,
    so this organization needs to be well handed to not cause problems while creating
    a solution with many functions.
  prefs: []
  type: TYPE_NORMAL
- en: Since the introduction of serverless, various kinds of functions have been created.
    These functions act as triggers that are used to start processing. As soon as
    the function is triggered, the execution can be done in different programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us check whether functions can be considered microservices or not.
  prefs: []
  type: TYPE_NORMAL
- en: Is serverless a way to deliver microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at the definition of microservices, you will find the concept of
    delivering an application as loosely coupled components that represent the implementation
    of a business capability. You can build something like that with a couple of functions,
    so yes, serverless is a way to deliver microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Some specialists even consider serverless architecture an evolution of microservices,
    since the focus of serverless architecture is to deliver scalability in a safe
    environment, enabling the possibility of a set of functions to independently be
    developed, tested, and deployed, which brings a lot of flexibility to the software
    architecture. That is exactly the main philosophy of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Let us imagine, as an example, a microservice responsible for authenticating
    users. You may create specific functions for registering, logging, and resetting
    passwords. Considering that this set of functions can be created in a single serverless
    project, you have both the flexibility of creating separated functions and the
    possibility of defining the purpose of the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless project will naturally support integration with databases, messaging
    queues, OpenAPI specifications, and other APIs, enabling the design patterns typically
    needed for a robust microservice architecture. It is also important to mention
    that keeping microservices isolated, small, and preferably reusable is a best
    practice worth following.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand that you can write microservices using serverless approaches,
    let us understand how Microsoft Azure presents serverless in its platform.
  prefs: []
  type: TYPE_NORMAL
- en: How does Microsoft Azure present serverless?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2016, Microsoft introduced Azure Functions as a Platform-as-a-Service (PaaS)
    offering designed to deliver FaaS capabilities. This option enables innovation
    at a scale for business transformation. Today, Azure Functions gives us the opportunity
    to power up applications using multiple programming languages, including C#, JavaScript,
    F#, Java, and Python.
  prefs: []
  type: TYPE_NORMAL
- en: One of the standout features of Azure Functions is its seamless integration
    with other Azure services and third-party APIs. For instance, it can easily connect
    to different Azure databases (from Azure SQL Server to Azure Cosmos DB), Azure
    Event Grid for event-based architecture, and Azure Logic Apps for workflow automation.
    This connectivity simplifies the process of building complex, enterprise-grade
    applications that leverage multiple services.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the possibilities with Azure Functions have evolved. Today,
    we can even manage stateful workflows and long-running operations, using Azure
    Durable Functions. With this, you can orchestrate complex processes that can be
    executed in multiple function executions.
  prefs: []
  type: TYPE_NORMAL
- en: But Microsoft has not only created an environment for coding functions. They
    have also created a complete pipeline for developers, following the DevSecOps
    process that’s now widely discussed and used in enterprise solutions. Developers
    can use tools such as Azure Pipelines, GitHub Actions, and other CI/CD services
    to automate the deployment process. You can also monitor and diagnose events in
    these functions using Azure Monitor and Application Insights, which facilitate
    troubleshooting and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PaaS solution also enables different setups to adjust scalability and security
    aspects. Depending on the hosting plan you decide to set, you can have different
    scaling opportunities, as you can check here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consumption plan: The basic and most cost-effective option to get started with
    Azure Functions. Ideal for event-driven workloads with automatic scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flex Consumption plan: Offers rapid, elastic scaling combined with support
    for private networking (VNet integration).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dedicated plan (App Service plan): Suitable for long-running functions and
    scenarios requiring more predictable performance and resource allocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Apps plan: A solid choice for microservices-based architectures
    that use multiple technology stacks or require greater flexibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Premium plan: Designed for high-performance scenarios with the ability to scale
    on demand, providing support for advanced features such as VNet, longer execution
    times, and pre-warmed instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, Microsoft Azure delivers serverless FaaS through Azure Functions,
    offering a powerful, flexible, and scalable platform that enhances the development
    and deployment of serverless applications. By using Azure Functions, developers
    can build and maintain responsive, cost-effective solutions. Now, let us explore
    how to create an Azure function in the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first serverless app in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are not many steps for creating your first serverless app in Azure. You
    can do it in a straightforward process when using the Azure portal. Follow these
    steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Azure portal. To do so, open your web browser and navigate to
    the Azure portal at [https://portal.azure.com/](https://portal.azure.com/). Sign
    in with your Azure account credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, click on the **Create a resource** button located in the
    upper-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1: Creating a resource in the Azure portal](img/B31916_01_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Creating a resource in the Azure portal'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Search services and marketplace** window, search for **Function App**
    and select it from the search results. This service will also be presented in
    the **Popular Azure services** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button to start the creation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ Figure 1.2: Selecting Function App for creation](img/B31916_01_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Selecting Function App for creation'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you select **Function App**, you will be prompted to select the required
    hosting plan. Today, we have five options for hosting plans using Azure Functions.
    These plans vary according to the scaling behavior, cold start, the possibility
    of usage of a virtual network, and, obviously, pricing. The *Consumption* plan
    is exactly what serverless is all about, where you have no idea of where and how
    your code is running, and you only pay for the execution of the code. On the other
    hand, when you select the *App Service* or *Container Apps environment* plans,
    you will have more control over the hardware and consumption of resources, which
    means you get the flexibility of using Azure Functions in your solution, along
    with the management needed for larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following screen will be presented to you as soon as you select to create
    an Azure function app. As we described previously, you will need to decide on
    the hosting plan according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Function App hosting plans](img/B31916_01_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Function App hosting plans'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this chapter, we will select the **Consumption** plan. Once
    you select this option, you will find a wizard to help you create the service.
    In this service, you will need to fill in the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basics**: Fill in the required fields such as **Subscription**, **Resource
    Group**, **Function App name**, **Region**, and **Operating System**. Ensure that
    the name you choose is unique. In **Runtime stack**, select the programming language
    of your functions. We will select **.NET 8 Isolated** worker model, but there
    are other options, as we presented before. It is worth mentioning that in-process
    models will be retired in 2026, so do not start projects using this approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: The function app needs an Azure storage account by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: This is where you will define whether the Azure function will
    be available for public access or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: Enable Application Insights to monitor your Function App for
    better diagnostics and performance tracking. Don’t forget that Azure Monitor logs
    will cause a cost increase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: It is also possible to initiate the setup of the deployment
    desired for the function app. This is interesting for enabling continuous deployment
    using GitHub Actions as default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tags**: Tagging the function app is considered a good practice for facilitating
    FinOps activity in professional environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038), *Demystifying Microservices
    Applications*, we will discuss the best way to interface microservices with the
    external world. For security reasons, it is not recommended that you provide functions
    directly to the public. You may decide to deliver them using an application gateway,
    such as Azure Application Gateway, or you can use Azure API Management as the
    entry for the APIs you develop using Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click on **Review and create**, you will be able to check all the
    settings. Review your configuration and click the **Create** button again to deploy
    your function app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Reviewing the function app setup](img/B31916_01_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Reviewing the function app setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the deployment is complete, navigate to your new function app by clicking
    on the **Go to resource** button. You will find the function app running properly
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Function app running](img/B31916_01_5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Function app running'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to understand the possibilities for development using Azure
    Functions and start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the triggers available in Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea of Azure Functions is that each function requires a trigger to
    start its execution. Once the trigger is fired, the execution of your code will
    start shortly afterward. However, the time it takes for execution to begin can
    vary depending on the selected hosting plan. For instance, in the Consumption
    plan, functions may experience cold starts – that is, a delay that occurs when
    the platform needs to initialize resources. It is also important to understand
    that the function can trigger more than once at the same time, which enables execution
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Functions offers a variety of triggers that allow developers to execute
    code in response to different events. Here we have the most used triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP Trigger: This trigger allows the function to be executed via an HTTP request.
    It is useful for creating APIs and webhooks, where the function can be called
    using standard HTTP methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timer Trigger: This trigger runs the function on a schedule based on the NCRONTAB
    model. It is ideal for tasks that need to be performed at regular intervals, such
    as cleanup operations, data processing, or sending out periodic reports. It is
    important to mention that the same timer trigger function does not run again until
    its first execution is done. This behavior helps prevent overlapping executions
    and potential conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blob Storage Trigger: This trigger runs the function when a new blob is created
    or updated in an Azure Blob Storage container. It is useful for processing or
    transforming files, such as images or logs, as they are uploaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Queue Storage Trigger: This trigger runs the function in response to messages
    added to Azure Queue Storage. It is useful for building scalable and reliable
    background processing systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event Grid Trigger: This trigger runs the function in response to events published
    to Azure Event Grid. It is useful for reacting to events from various Azure services,
    such as resource creation, modification, or deletion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service Bus Trigger: This trigger runs the function when messages are received
    in an Azure Service Bus queue or topic. It is ideal for handling inter-application
    messaging and building complex workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cosmos DB Trigger: This trigger runs the function in response to creation and
    updates in Azure Cosmos DB. It is useful for processing data changes in real time,
    such as updating a search index or triggering additional data processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These triggers offer flexibility and scalability, allowing developers to build
    event-driven applications that can respond to distinct types of events seamlessly.
    It is important to say that there are other triggers available in Azure Functions,
    and we will discuss them in more detail in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Coding with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this topic is to rapidly present some ways to develop Azure functions.
    During the other chapters of the book, we will present a use case related to car
    sharing. As you will see in detail in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038),
    *Demystifying Microservices Applications*, each microservice must have a health
    check endpoint. Let us develop a sample of this health check API.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Azure functions using VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an HTTP trigger Azure function using VS Code involves several well-defined
    steps. Here is a detailed guide to help you through the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some prerequisites to enable the development of Azure functions using
    VS Code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you have VS Code installed on your machine. The use of VS Code will help
    you not only develop the Azure functions needed but also manage your Azure account
    using the **Azure Tools** extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended that you sign in to your Azure account to create the new function.
    The **C# Dev Kit** may also be installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The GitHub Copilot extension** can also be installed to help you solve coding
    problems and, at the same time, guide you while writing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Azure Functions extension for VS Code. This VS Code extension will
    facilitate the development of functions, giving you wizards for each function
    trigger desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Azurite extension for VS Code. This VS Code extension is an open
    source Azure Storage API-compatible server for debugging Azure Functions locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you have the **Azure Functions Core Tools,** and the **.NET SDK**
    installed if you are using C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have set up your environment, you will have something like the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: VS Code ready to write Azure functions](img/B31916_01_6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: VS Code ready to write Azure functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the prerequisites are set, in the **Azure** tab, go to **WORKSPACE**
    and select **Create Function Project…**. Next, perform the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a location for your project and select your preferred programming language.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the prompts to create a new HTTP trigger function. You can name it `Health`
    and call the namespace `CarShare.Function.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to decide on the **access rights** for this function. For this
    example, you can choose **Anonymous**. We will discuss each of the security options
    later.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the newly created function file. You will see a template code for an HTTP
    trigger function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the function to meet your specific requirements, which, in this case,
    means to respond if the function is working properly. Notice that this is a `GET`
    and `POST` function. For the purpose we have defined, you can change the code
    to only be an HTTP `GET` function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For running and debugging locally, you just need to press *F5* or navigate to
    **Run** > **Start Debugging**. VS Code will start the Azure Functions host, and
    you will see the function URL in the output window. Then, you can use tools such
    as **Postman** or your browser to send HTTP requests to your function endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that for running Azure Functions locally, you will need
    to allow PowerShell scripts to run without being digitally signed. This can be
    a problem depending on the security policies provided by your company.
  prefs: []
  type: TYPE_NORMAL
- en: Once the function is running, you can consider it the same as when you work
    on other types of software projects, and even the debugging will work properly.
    The trigger will depend on the function you set. The following figure shows the
    code of the function program, where you can see the response to the caller with
    a status of `200` by using `OkObjectResult` with the message “Yes! The function
    is live!” and the UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7: Azure Functions running locally](img/B31916_01_7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Azure Functions running locally'
  prefs: []
  type: TYPE_NORMAL
- en: As you have created a function app connected to a GitHub repository with the
    deployment process handled by GitHub Actions, once you commit and pull the code
    to GitHub, GitHub Actions will automatically build the function and deploy it
    as a function app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: Function app deployed using GitHub Actions](img/B31916_01_8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Function app deployed using GitHub Actions'
  prefs: []
  type: TYPE_NORMAL
- en: It is not the purpose of this book to discuss CI/CD strategies, but you will
    certainly need to think about them when it comes to professional development.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this deployment can be checked in the Azure portal, where the
    function developed will be available in the list of functions. It is worth noting
    that a function app can handle more than one function at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: Health function available in the function app](img/B31916_01_9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Health function available in the function app'
  prefs: []
  type: TYPE_NORMAL
- en: The function can be executed as soon as it is published to Azure. As a result
    of the sample function, as this was developed as a `GET` HTTP trigger, we can
    check that the function is working by accessing the API in the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: Health function running properly](img/B31916_01_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: Health function running properly'
  prefs: []
  type: TYPE_NORMAL
- en: As you don’t have a live CI/CD pipeline, you can also publish your Azure function
    directly from the VS Code IDE. To do so, you may use the Azure Functions extension
    provided by VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few steps to follow in this case. The first one is to select the
    action to deploy the function in the VS Code prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: Deploying to Azure using VS Code](img/B31916_01_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Deploying to Azure using VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you will need to select the corresponding subscription and the
    name of the new function app you want to deploy, considering a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Creating a new function app](img/B31916_01_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Creating a new function app'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current process proposed by the extension is to deploy an Azure function
    in the Flex Consumption plan. There are some specific locations where this option
    is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Defining the location for the new function app](img/B31916_01_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Defining the location for the new function app'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the runtime stack is also important to get the most out of
    your Azure function. In the case of the Flex Consumption plan, you will also be
    asked for the memory usage in the instance and the maximum number of instances
    available for parallel calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: Defining the runtime stack for the new function app](img/B31916_01_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Defining the runtime stack for the new function app'
  prefs: []
  type: TYPE_NORMAL
- en: Once these sets are defined, your Azure function will be deployed correctly.
    You can also redeploy functions using the same technique later, without needing
    to recreate the Azure function app every single time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: Function app properly deployed](img/B31916_01_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Function app properly deployed'
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, the Azure portal also gives you the possibility to monitor
    and manage the functions deployed. Once this process is done, you can monitor
    your function’s performance and log. By using the **Monitoring** section of your
    function app, you can view execution details, track failures, and analyze performance
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Azure functions using Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio is one of the best options for developing Azure functions. To
    do so, you must set **Azure Development Workload**, which will help enable Azure
    functions development natively on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done this, the same project you created using VS Code will be
    available for you to use at Visual Studio. The difference between VS Code and
    Visual Studio in this case is that Visual Studio will provide an easier setup
    environment for debugging and a lot of visual dialogs that can facilitate your
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16: Creating a new Azure function for the function app](img/B31916_01_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Creating a new Azure function for the function app'
  prefs: []
  type: TYPE_NORMAL
- en: These dialogs simplify the development process, so if you have the opportunity
    to use Visual Studio, this will be the best option.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17: Defining the Azure function trigger type](img/B31916_01_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.17: Defining the Azure function trigger type'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, when you create a Function Apps project, you can add more than one
    function to this project, which is extremely useful for microservices solutions.
    In the following example, we have added a second HTTP trigger function called
    `Status` to help you understand this possibility and to let you see how these
    functions work together in a single function app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18: Function app with more than one function](img/B31916_01_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18: Function app with more than one function'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that the same code developed initially using VS Code
    can continue to be maintained using Visual Studio, and vice versa. This is great
    because you can have different developers in the same team using the two environments
    and this will not cause a problem, at least not with Function Apps projects.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio is an excellent option for developing Azure functions due to its
    comprehensive setup environment for debugging and integrated visual dialogs, which
    make development easier. Developers can switch between VS Code and Visual Studio
    without compatibility issues, facilitating team collaboration. Multiple functions,
    such as HTTP triggers, can be in a single Function Apps project, supporting microservices
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the evolution of cloud platforms and the rise of modern
    technologies, emphasizing the importance of focusing on solutions rather than
    just technologies. The chapter highlighted the advantages of serverless computing,
    such as scalability, reliability, security, and cost-effectiveness, while also
    addressing potential challenges. It discussed how serverless architecture can
    deliver microservices and the benefits of using Microsoft Azure Functions for
    building and deploying serverless applications. The chapter also provided practical
    guidance on creating and managing Azure functions using tools such as VS Code
    and Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how microservices applications can be defined
    and designed in enterprise scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the main advantages of using serverless computing as mentioned in the
    chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serverless computing provides several advantages, including automatic scaling,
    cost-efficiency through a pay-as-you-go model, and reduced infrastructure management.
    Developers do not need to worry about provisioning or maintaining servers, which
    allows them to focus on delivering solutions faster and more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: It also promotes software development acceleration by letting developers focus
    solely on the code. Additionally, the environment’s reliability and security are
    managed by the cloud provider, enabling scalable and sustainable solutions without
    sacrificing performance or safety.
  prefs: []
  type: TYPE_NORMAL
- en: How can serverless architecture be used to deliver microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serverless architecture supports the microservices model by allowing developers
    to create independent, small, and reusable functions that represent distinct business
    capabilities. These functions can be deployed, tested, and scaled independently,
    following the core principles of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter gave an example of a user authentication microservice, where separate
    functions such as registration, login, and password reset were implemented within
    a single serverless project. This flexibility enhances the modularity and maintainability
    of applications built using microservices principles.
  prefs: []
  type: TYPE_NORMAL
- en: What are the key triggers available in Azure Functions and their purposes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Functions can be triggered by a variety of events. The main triggers are
    HTTP trigger (for web requests), timer trigger (scheduled tasks), Blob Storage
    trigger (file uploads or changes), Queue Storage trigger (message processing),
    Event Grid trigger (event handling from Azure services), Service Bus trigger (messaging
    between applications), and Cosmos DB trigger (database change processing).
  prefs: []
  type: TYPE_NORMAL
- en: Each trigger allows developers to build event-driven applications with flexibility
    and scalability. For example, timer triggers are ideal for recurring tasks, while
    HTTP triggers are commonly used for APIs and webhooks. This variety of triggers
    supports the development of diverse and responsive solutions.
  prefs: []
  type: TYPE_NORMAL
- en: What steps are necessary to create a serverless application in the Azure portal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a serverless application in Azure, the developer must log in to the
    Azure portal and create a new Function App resource. During the setup, they need
    to choose the hosting plan (e.g., Consumption plan), define project details such
    as region, runtime stack, storage account, and networking options, and enable
    monitoring via Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing the configurations, the developer clicks **Create** to deploy
    the function app. Once deployed, they can navigate to the resource, start coding,
    and manage it directly from the portal or via development tools such as Visual
    Studio or VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How does Azure Functions integrate with other Azure services and third-party
    APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Functions integrates seamlessly with various Azure services such as Azure
    SQL, Cosmos DB, Event Grid, Service Bus, and Logic Apps. This enables developers
    to build complex workflows, automate tasks, and create highly responsive applications
    using existing Azure infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Azure Functions can connect to third-party APIs and services,
    supporting hybrid architectures. This integration capability allows developers
    to extend their applications across platforms, enhancing the flexibility and scalability
    of cloud-native solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions documentation: [https://learn.microsoft.com/en-us/azure/azure-functions/](https://learn.microsoft.com/en-us/azure/azure-functions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure API Management documentation: [https://learn.microsoft.com/en-us/azure/api-management/](https://learn.microsoft.com/en-us/azure/api-management/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Application Gateway documentation: [https://learn.microsoft.com/en-us/azure/application-gateway/overview](https://learn.microsoft.com/en-us/azure/application-gateway/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
