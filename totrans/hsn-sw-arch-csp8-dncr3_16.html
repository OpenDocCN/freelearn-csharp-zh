<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Presenting ASP.NET Core MVC</h1>
                </header>
            
            <article>
                
<p><span><span>In this chapter, you will learn how to implement an application presentation layer. More specifically, you will learn how to implement a web application based on ASP.NET Core MVC.</span></span></p>
<p>ASP.NET Core is a .NET framework for implementing web applications. ASP.NET Core has been partially described in previous chapters, so <span>t</span><span>his chapter focuses mainly on ASP.NET Core MVC. More specifically, the contribution of this chapter is as follows:</span></p>
<ul>
<li class="h1">Understanding the presentation layers of web applications</li>
<li class="h1">Understanding the ASP.NET Core MVC structure</li>
<li class="h1">What is new in .NET Core 3.0 for ASP.NET Core?</li>
<li class="h1">Understanding the connection between ASP.NET Core MVC and design principles</li>
<li class="h1">Use case – implementing a web app in ASP.NET Core MVC</li>
</ul>
<p>We will review and give further details on <span>the structure of the ASP.NET Core framework that, in part, was discussed in <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a>, <em>Applying Service-Oriented Architectures with .NET Core</em>, and <a href="049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml">Chapter 4</a>, <em>Deciding the Best Cloud-Based Solution</em>. Here, the main focus is on how to implement web-based presentation layers based on the so-called <strong>Model View Controller</strong> (<strong>MVC</strong>) architectural pattern.</span></p>
<p>We will also analyze all of the new features available in the last ASP.NET Core 3.0 version and the architectural patterns included in the ASP.NET Core MVC framework and/or used in typical ASP.NET Core MVC projects. Some of these patterns were discussed in <a href="a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml">Chapter 9</a>, <em>Design Patterns and .NET Core Implementation</em>, and <a href="2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml">Chapter 10</a>, <em>Understanding the Different Domains in Software Solutions</em>, whereas some others, such as the MVC pattern itself, are new.</p>
<p class="mce-root"/>
<p>You will learn how to implement an ASP.NET Core MVC application, and how to organize the whole Visual Studio solution with the practical example at the end of this chapter. This example describes a complete <span>ASP.NET Core MVC </span>application for editing the packages of the WWTravelClub book use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter requires Visual Studio 2017 or the 2019 free Community Edition or better with all database tools installed.</p>
<p><span>All concepts are clarified with practical examples based on the WWTravelClub book use case. </span>The code for this chapter is available at <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the presentation layers of web applications</h1>
                </header>
            
            <article>
                
<p>This chapter discusses an architecture for the implementation of presentation layers of web-based applications based on the ASP.NET Core framework.<span> </span>Presentation layers of web applications are based on three techniques:</p>
<ul>
<li>Mobile or desktop native applications that exchange data with servers through REST or SOAP services: We have not discussed them since they are strictly tied to the client device and its operating system, therefore, <span>analyzing them,</span> which would require a dedicated book, <span>is completely beyond the scope of this book</span>.</li>
<li><strong>Single Page Applications</strong> (<strong>SPA</strong>): These are HTML-based applications whose dynamic HTML is created on the client either in JavaScript or with the help of WebAssembly (a kind of cross-browser assembly that can be used as a high-performance alternative to JavaScript). Like native applications, SPAs exchange data with the server through REST or SOAP services, but they have the advantage of being independent of the device and its operating system since they run in a browser. SPA frameworks are complex subjects that require dedicated books, so they cannot be described in this book. Some related links are listed in the <em>Further reading</em> section.</li>
<li>HTML pages created by the server whose content depends on the data to be shown to the user: The ASP.NET Core MVC framework, which will be discussed in this chapter, is a framework for creating such dynamic HTML pages.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The remainder of this chapter focuses on how to create HTML pages on the server side and, more specifically, on ASP.NET Core MVC, which is introduced in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the ASP.NET Core MVC structure</h1>
                </header>
            
            <article>
                
<p>ASP.NET Core is based on the concept of the Generic Host explained in the <em>Using Generic Hosts</em> subsection of <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>. The basic architecture of ASP.NET Core is outlined in the <em>A short introduction to ASP.NET Core</em> subsection of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a><span>, <em>Applying Service-Oriented Architectures with .NET Core</em></span>.</p>
<p>It is worth reminding readers that the host configuration is delegated to the <kbd>Startup</kbd> class defined in the <kbd>Startup.cs</kbd> file by calling the <kbd>.UseStartup&lt;Startup&gt;()</kbd> method of the <kbd>IWebHostBuilder</kbd> interface. <kbd>ConfigureServices(IServiceCollection services)</kbd> of the <kbd>Startup</kbd> class defines all services that can be injected in object constructors through DI. DI is described in detail in the <em>Using Generic Hosts</em> subsection of <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a><span>, </span><em>Applying Microservice Architecture to Your Enterprise Application</em>.</p>
<p>The <kbd>Configure(IApplicationBuilder app, IHostingEnvironment env)</kbd> <span>startup method, instead, defines the so-called ASP.NET Core pipeline that was briefly described in <em>A short introduction to ASP.NET Core</em> subsection of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a>, <em>Applying Service-Oriented Architectures with .NET Core</em>, and that will be described in more detail in the next subsection.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How ASP.NET Core pipeline works</h1>
                </header>
            
            <article>
                
<p>ASP.NET Core furnishes a set of configurable modules you may assemble according to your needs. Each module takes care of functionality that you may need or not. Examples of functionalities are <span>authorization, authentication, static file processing, protocol negotiation, CORS handling, and so on. </span></p>
<p>You can put together all of the modules you need by inserting them into a common processing framework called the <strong>ASP.NET Core pipeline</strong>. </p>
<p class="mce-root"/>
<p>More specifically, ASP.NET Core requests are processed by pushing a context object through a pipeline of ASP.NET Core modules, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3dc434b8-b536-432f-b483-fc03f411b4ab.png"/></p>
<p>The object that is inserted in the pipeline is an <kbd>HttpContext</kbd> instance that contains the whole data of the incoming request. More specifically the <kbd>Request</kbd> property of <kbd>HttpContext</kbd> contains an <kbd>HttpRequest</kbd> object whose properties represent the incoming request in a structured way. There are properties for headers, cookies, request path, parameters, form fields, and the request body.</p>
<p>The various modules can contribute to the construction of the final response by writing in an <kbd>HttpResponse</kbd> object contained in the <kbd>Response</kbd> property of the <kbd>HttpContext</kbd> instance. The <kbd>HttpResponse</kbd> class is similar to the <kbd>HttpRequest</kbd> class, but its properties refer to the response being built.</p>
<p>Some modules can build an intermediate data structure that is then used by other modules in the pipeline. In general, such intermediary data can be stored in custom entries of <kbd>IDictionary&lt;object, object&gt;</kbd> contained in the <kbd>Items</kbd> property of the <kbd>HttpContext</kbd> object. However, there is a predefined property, <kbd>User</kbd>, which contains information on the currently logged user. The logged-in user is not computed automatically but must be computed by an authentication module. The <em>ASP.NET Core services authorization</em> subsection of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a><span>, <em>Applying Service-Oriented Architectures with .NET Core</em></span>, explains how to add the standard module that performs JWT token-based authentication to the ASP.NET Core pipeline.</p>
<p><kbd>HttpContext</kbd> has also a <kbd>Connection</kbd> property that contains information on the underlying connection established with the client and a <kbd>WebSockets</kbd> property that contains information on possible WebSocket-based connections established with the clients.</p>
<p><kbd>HttpContext</kbd> <span>also</span><span> </span><span>has a</span> <kbd>Features</kbd> <span>property that contains </span><kbd>IDictionary&lt;Type, object&gt;</kbd>, <span>which specifies the features supported by the web server that hosts the web application and by the modules of the pipeline. Features can be set with the</span> <kbd>.Set&lt;Type&gt;(Type o)</kbd> <span>method and can be retrieved with the</span> <kbd>.Get&lt;Type&gt;()</kbd> <span>method.</span></p>
<p><span>Web</span> <span>server features are automatically added by the framework, when all other features are added by pipeline modules while they process <kbd>HttpContext</kbd>. </span><span>Features are not specific for the incoming request but depend just on the application-hosting environment, and on the modules added to the ASP.NET Core pipeline. </span></p>
<p><kbd>HttpContext</kbd> gives access also to the dependency injection engine through its <kbd>RequestServices</kbd> property. You can get an instance of a type managed by the dependency engine by calling the <kbd>.RequestService.GetService(Type t)</kbd> method.</p>
<div class="packt_infobox">The<span> </span><kbd>HttpContext</kbd><span> </span>instance that is created for processing a web request is not available only to modules, but also to the application code through DI. It is enough to insert an<span> </span><kbd>IHttpContextAccessor</kbd><span> </span>parameter in the constructor of a class that is automatically dependency injected, such as a controller (see later on in this section), and then access its <kbd>HttpContext</kbd><span> </span>property.</div>
<p>A module is any class with the following structure:</p>
<pre>public class CoreMiddleware<br/>{<br/>    private readonly RequestDelegate _next;<br/>    public CoreMiddleware(RequestDelegate next, ILoggerFactory <br/>    loggerFactory)<br/>    {<br/>        ...<br/>        _next = next;<br/>        ...<br/>    }<br/><br/>    public async Task Invoke(HttpContext context)<br/>    {<br/>        /*<br/>            Insert here the module specific code that processes the <br/>            HttpContext instance<br/> <br/>        */<br/>             <br/>        await _next.Invoke(context);<br/>        /*<br/>            Insert here other module specific code that processes the <br/>            HttpContext instance<br/>        */<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In general, each module processes the <kbd>HttpContext</kbd> instance passed by the previous module in the pipeline, then calls <kbd>await _next.Invoke(context)</kbd> to invoke the modules in the remainder of the pipeline. When all other modules finish their processing and the response for the client has been prepared, each module can perform further post-processing of the response in the code that follows the <kbd>_next.Invoke(context)</kbd> call.</p>
<p>Modules are registered in the ASP.NET Core pipeline by calling the <kbd>UseMiddleware&lt;T&gt;</kbd> method in the <kbd>Startup.cs</kbd> file's <kbd>Configure</kbd> method, as shown here:</p>
<pre>public void Configure(IApplicationBuilder app, IHostingEnvironment env, <br/>IServiceProvider serviceProvider)<br/>{<br/>    ...<br/>    app.UseMiddleware&lt;MyCustomModule&gt;<br/>    ...<br/>}</pre>
<p>Modules are inserted in the pipeline in the same order when <kbd>UseMiddleware</kbd> is called. Since each functionality added to an application might require several modules and might require operations other than adding modules, <span><span>you </span></span>usually define an <kbd>IApplicationBuilder</kbd> extension such as <kbd>UseMyFunctionality</kbd>, as shown in the following code:</p>
<pre>public static class MyMiddlewareExtensions<br/>{<br/>    public static IApplicationBuilder UseMyFunctionality(this <br/>    IApplicationBuilder builder,...)<br/>    {<br/>        //other code            <br/>        ...<br/>        builder.UseMiddleware&lt;MyModule1&gt;();<br/>        builder.UseMiddleware&lt;MyModule2&gt;();<br/>        ...<br/>        //Other code<br/>        ...<br/>        return builder;<br/>    }<br/>}</pre>
<p>After that, the whole functionality can be added to the application by calling <kbd>app.UseMyFunctionality(...)</kbd>. For instance, the ASP.NET Core MVC functionality is added to the ASP.NET Core pipeline by calling <kbd>app.UseEndpoints(....)</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Often, functionalities added with each <kbd>app.Use...</kbd> require that some .NET types are added to the application DI engine. In these cases, we also define an <kbd>IServiceCollection</kbd> extension named <kbd>AddMyFunctionality</kbd> that must be called in the <kbd>Startup.cs</kbd> file's <kbd>ConfigureServices(IServiceCollection services)</kbd> method. For instance, ASP.NET Core MVC requires a call like the following:</p>
<pre>services.AddControllersWithViews(o =&gt;<br/>{<br/>    //set here MVC options by modifying the o option parameter<br/>} </pre>
<p>If you don't need to change the default MVC options, you can simply call <kbd>services.AddControllersWithViews()</kbd>.</p>
<p>The next subsection describes another important feature of the ASP.NET Core framework, namely, how to handle application configuration data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading configuration data and using it with the options framework</h1>
                </header>
            
            <article>
                
<p><span>When an ASP.NET Core application starts, it reads configuration information (such as a database connection string) from the <kbd>appsettings.json</kbd> and <kbd>appsettings.[EnvironmentName].json</kbd> files, where <kbd>EnvironmentName</kbd> is a string value that depends on where the application is deployed. Typical values for <kbd>EnvironmentName</kbd> are as follows:</span></p>
<ul>
<li><span><kbd>Production</kbd></span> is<span> used for production deployment.</span></li>
<li><span><kbd>Development</kbd> is used during development.</span></li>
<li><span><kbd>Staging</kbd> is used when the application is tested in staging.</span></li>
</ul>
<p>The two JSON trees extracted from the <span><kbd>appsettings.json</kbd> and <kbd>appsettings.[EnvironmentName].json</kbd> files are merged into a unique tree where values contained in</span> <kbd>[EnvironmentName].json</kbd> override the values contained in the corresponding paths of <kbd>appsettings.json</kbd>. This way, the application can be run with different configurations in different deployment environments. In particular, you may use a different database connection string, and hence, a different database instance in each different environment. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>The <kbd>[EnvironmentName]</kbd> string is taken from the <kbd>ASPNETCORE_ENVIRONMENT</kbd> operating system environment variable. In turn, <kbd>ASPNETCORE_ENVIRONMENT</kbd> can be automatically set during the application's deployment with Visual Studio in two ways:</span></p>
<ul>
<li>During Visual Studio deployment, Visual Studio publish wizard creates an XML publish profile.<span> If the publish wizard allows you to choose the <span><kbd>ASPNETCORE_ENVIRONMENT</kbd> from a drop-down list, you are done:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><span><span><img src="assets/accbb45b-1268-4812-8662-e57450fc2900.png" style="width:38.33em;height:31.42em;"/><br/></span></span></p>
<p style="padding-left: 60px"><span><span>Otherwise, you may proceed as follows:</span> </span></p>
<ol>
<li style="list-style-type: none">
<ol>
<li>Once you fill in the information in the wizard, save the publish profile without publishing.</li>
</ol>
</li>
</ol>
<ol start="2">
<li style="padding-left: 60px">Then, edit the profile with a text editor and add an XML property such as, <kbd>&lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;</kbd><span><span>. Since all already defined publish profiles can be selected during the application publication, you may define a different publish profile for each of your environments, and then, you may select the one you need during each publication.</span></span></li>
</ol>
<ul>
<li class="mce-root"><span>The value to set</span> <kbd>ASPNETCORE_ENVIRONMENT</kbd> to <span>during deployment can also be specified in the Visual Studio ASP.NET Core project file (</span><kbd>.csproj</kbd><span>) of your application by adding the following code:</span></li>
</ul>
<pre style="color: black">&lt;PropertyGroup&gt; <br/>    &lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;<br/>&lt;/PropertyGroup&gt;</pre>
<p>During development in Visual Studio, the value to give to <kbd>ASPNETCORE_ENVIRONMENT</kbd> when the application is run can be specified in the <kbd>Properties\launchSettings.json</kbd> file of the ASP.NET Core project. The <span><kbd>launchSettings.json</kbd> file contains several named groups of settings. These settings configure how to launch the web application when it is run from Visual Studio. You may choose to apply all settings of a group by selecting the group name with the drop-down list next to Visual Studio's run button:</span></p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/358b4f47-0e3f-42c5-8e6f-427bae29c0b0.png" style="width:7.17em;height:2.25em;"/> </span></p>
<p><span>Your selection in this drop-down list will be shown in the run button, the default selection being</span> <span class="packt_screen">IIS Express</span><span>.</span></p>
<p>The following code shows a typical <span><kbd>launchSettings.json</kbd> file in which you can either add a new group of settings or change the settings of the existing default groups:</span></p>
<pre>{<br/>  "iisSettings": {<br/>    "windowsAuthentication": false, <br/>    "anonymousAuthentication": true, <br/>    "iisExpress": {<br/>      "applicationUrl": "http://localhost:2575",<br/>      "sslPort": 44393<br/>    }<br/>  },<br/>  "profiles": {<br/>    "IIS Express": {<br/>      "commandName": "IISExpress",<br/>      "launchBrowser": true,<br/>      "environmentVariables": {<br/>        "ASPNETCORE_ENVIRONMENT": "Development"<br/>      }<br/>    },<br/>    ...<br/>    ...<br/>    }<br/>  }<br/>}</pre>
<p>The named groups of settings are under the <kbd>profiles</kbd> properties. There, you may choose where to host the application (<kbd>IISExpress</kbd>), to launch the browser, and the values of some environment variables.</p>
<p>The current environment loaded from the <kbd>ASPNETCORE_ENVIRONMENT</kbd> operating system environment variable can be tested through the <kbd>IHostingEnvironment</kbd> interface during the ASP.NET Core pipeline definition since an <span><kbd>IHostingEnvironment</kbd> instance is</span> passed as a parameter to the <kbd>Startup.cs</kbd> file's <kbd>Configure</kbd> method. <kbd>IHostingEnvironment</kbd><span> </span>is also available to the remainder of the user code through DI.</p>
<p><kbd>IHostingEnvironment.IsEnvironment(string environmentName)</kbd> checks whether the current value of <kbd><span>ASPNETCORE_ENVIRONMENT</span></kbd> is <span><kbd>environmentName</kbd>. There are also specific shortcuts for testing development (<kbd>.IsDevelopment()</kbd>), production (<kbd>.IsProduction()</kbd>), and staging (<kbd>.IsStaging()</kbd>). <kbd>IHostingEnvironment</kbd> also contains the current root directory of the ASP.NET Core application (<kbd>.WebRootPath</kbd>) and the directory reserved for static files (<kbd>.ContentRootPath</kbd>) that are served as they are by the web server (CSS, JavaScript, images, and so on).</span></p>
<p>Both <kbd>launchSettings.json</kbd> and all publish profiles can be accessed as children of the <span class="packt_screen">Properties</span> node in Visual Studio Explorer, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/235193fd-a520-44cf-b78f-bd62d4737dbf.png" style="width:13.00em;height:4.17em;"/></p>
<p><span>Once <kbd>appsettings.json</kbd> and <kbd>appsettings.[EnvironmentName].json</kbd></span><span> </span><span>are loaded, </span><span>the configuration tree resulting from their merge can be mapped to the properties of .NET objects. For example, let's suppose we have an</span> <kbd>Email</kbd> <span>section of the </span><kbd>appsettings</kbd> <span>files that contains all of the information needed to connect to an email server, as shown here:</span></p>
<pre>{<br/>    "ConnectionStrings": {<br/>        "DefaultConnection": "...."<br/>    },<br/>    "Logging": {<br/>        "LogLevel": {<br/>            "Default": "Warning"<br/>        }<br/>    },<br/>    "Email": {<br/>        "FromName": "MyName",<br/>        "FromAddress": "info@MyDomain.com",<br/>        "LocalDomain": "smtps.MyDomain.com",<br/>        "MailServerAddress": "smtps.MyDomain.com",<br/>        "MailServerPort": "465",<br/>        "UserId": "info@MyDomain.com",<br/>        "UserPassword": "mypassword"</pre>
<p>Then, the whole <kbd>Email</kbd> section can be mapped to an instance of the following class:</p>
<pre>    public class EmailConfig<br/>    {<br/>        public String FromName { get; set; }<br/>        public String FromAddress { get; set; }<br/>        public String LocalDomain { get; set; }<br/><br/>        public String MailServerAddress { get; set; }<br/>        public String MailServerPort { get; set; }<br/><br/>        public String UserId { get; set; }<br/>        public String UserPassword { get; set; }<br/>    }</pre>
<p>The code that performs the mapping must be inserted in the <kbd>ConfigureServices</kbd> method in the <span><kbd>Startup.cs</kbd> file</span> since the <kbd>EmailConfig</kbd> instance will be available through DI. The code we need is shown here: </p>
<pre>public Startup(IConfiguration configuration)<br/>{<br/>    Configuration = configuration;<br/>}<br/>....<br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    ...<br/>    services.Configure&lt;EmailConfig&gt;(Configuration.GetSection("Email"));<br/>    ..</pre>
<p>After the preceding settings, classes that need <kbd>EmailConfig</kbd> data must declare an <kbd>IOptions&lt;EmailConfig&gt; options</kbd> parameter that will be provided by the DI engine. An <kbd>EmailConfig</kbd> instance is contained in <kbd>options.Value</kbd>.</p>
<p>The next subsection describes the basic ASP.NET Core pipeline modules needed by an ASP.NET Core MVC application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the ASP.NET Core MVC pipeline</h1>
                </header>
            
            <article>
                
<p>If you create a new ASP.NET Core MVC project in Visual Studio, a standard pipeline is created in the <kbd>Startup.cs</kbd> file's <kbd>Configure</kbd> method. There, if needed, you may add further modules or change the configuration of the existing modules.</p>
<p>The initial code of the <kbd>Configure</kbd> method handles errors and performs basic HTTPS configuration:</p>
<pre> if (env.IsDevelopment())<br/>{<br/>    app.UseDeveloperExceptionPage();<br/>    app.UseDatabaseErrorPage();<br/>}<br/>else<br/>{<br/>    app.UseExceptionHandler("/Home/Error");<br/>    app.UseHsts();<br/>}<br/>app.UseHttpsRedirection();</pre>
<p>If there are errors, if the application is in a development environment, the module installed by <kbd>UseDeveloperExceptionPage</kbd> adds a detailed error report to the response, while the module installed by <kbd>UseDatabaseErrorPage</kbd> processes and adds details of Entity Framework database errors, if any, to the response. These modules are valuable debugging tools.</p>
<p class="mce-root"/>
<p>If an error occurs when the application is not in development mode, <kbd>UseExceptionHandler</kbd> restores the request processing from the path it receives as an argument, that is, from <kbd>/Home/Error</kbd>. In other words, it simulates a new request with the <kbd>/Home/Error</kbd> path. This request is pushed into the standard MVC processing until it reaches the endpoint associated with the <span><kbd>/Home/Error</kbd> path, where the developer is expected to place the custom code that handles the error.</span></p>
<p>When the application is not in development, <kbd>UseHsts</kbd> adds the <kbd>Strict-Transport-Security</kbd> header to the response that informs the browser that the application must be accessed only with HTTPS. After this declaration, compliant browsers should automatically convert any HTTP request to the application into an HTTPS request for the time specified in the <kbd>Strict-Transport-Security</kbd><span> header. As a default, <kbd>UseHsts</kbd> specifies 30 days as the time in the header, but you may specify a different time and other header parameters by adding an <kbd>options</kbd> object in the <kbd>ConfigureServices</kbd> method of <kbd>Startup.cs</kbd>:</span></p>
<pre><span>services.AddHsts(options =&gt;     {         <br/>    ...<br/></span><span>    options.MaxAge = TimeSpan.FromDays(</span><span class="hljs-number">60</span><span>); <br/>    ...</span><span>   <br/>});</span></pre>
<p class="mce-root"><kbd>UseHttpsRedirection</kbd> causes an automatic redirection to an HTTPS URL when an HTTP URL is received, in a way to force a secure connection. Once the first HTTPS secure connection is established, the <kbd>Strict-Transport-Security</kbd> header prevents future redirections that might be used to perform man-in-the-middle attacks.</p>
<p class="mce-root">The following code shows the remainder of the default pipeline:</p>
<pre>app.UseStaticFiles();<br/>app.UseCookiePolicy();<br/><br/>app.UseRouting();<br/><br/>app.UseAuthentication();<br/>app.UseAuthorization();<br/><br/>...</pre>
<p><kbd>UseStaticFiles</kbd> makes accessible from the web all files contained in the <kbd>wwwroot</kbd> folder of the project <span>(typically CSS,  JavaScript, images, and font files)</span> through their actual path.</p>
<p><kbd>UseCookiePolicy</kbd> ensures that cookies are processed by the ASP.NET Core pipeline only if the user has given consent for cookie usage. Consent to cookie usage is given through a consent cookie, that is, cookie processing is enabled only if this consent cookie is found among the request cookies. This cookie must be created by JavaScript when the user clicks a consent button. The whole string that contains both the consent cookie names and its contents can be retrieved from the <kbd>HttpContext.Features</kbd>, as shown in the following snippet:</p>
<pre>var consentFeature = context.Features.Get&lt;ITrackingConsentFeature&gt;();<br/>var showBanner = !consentFeature?.CanTrack ?? false;<br/>var cookieString = consentFeature?.CreateConsentCookie();</pre>
<p><kbd>CanTrack</kbd> is <kbd>true</kbd> only if consent is required and has not been given yet. When the consent cookie is detected, <kbd>CanTrack</kbd> is set to <kbd>false</kbd>. This way, <kbd>showBanner</kbd> is <kbd>true</kbd> only if consent is required and has not been given yet. Therefore, it tells us whether to ask the user<span> </span><span>for consent</span><span> or not.</span></p>
<p>Options of the consent module are contained in a <kbd>CookiePolicyOptions</kbd> instance that must be configured manually with the options framework. The following code snippet shows the default configuration code scaffolded by Visual Studio that configures <kbd>CookiePolicyOptions</kbd> in the code instead of using the configuration file:</p>
<pre>services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;<br/>{<br/>    options.CheckConsentNeeded = context =&gt; true;<br/>});</pre>
<p><kbd>UseAuthentication</kbd> enables authentication schemes. As a default, it only enables cookie-based authentication, that is, an authentication scheme where the authentication token is placed in a cookie. The authentication cookie is created during user login.</p>
<p>Cookies authorization options (such as the cookie name) and other authentication schemes can be enabled by configuring an options object in the <kbd>ConfigureServices</kbd> method, as shown here:</p>
<pre>services.AddAuthentication(o =&gt;<br/>{<br/>    o.DefaultScheme = <br/>    CookieAuthenticationDefaults.AuthenticationScheme;<br/>})<br/>.AddCookie(o =&gt;<br/>{<br/>    o.Cookie.Name = "my_cookie";<br/>})<br/>.AddJwtBearer(o =&gt;<br/>{<br/>    ...<br/>});</pre>
<p class="mce-root">The preceding code specifies a custom authentication cookie name and adds JWT-based authentication for the REST service contained in the application. Both <kbd>AddCookie</kbd> and <kbd>AddJwtBearer</kbd> have overloads that accept the name of the authentication scheme before the action where you can define the authentication scheme options. Since the authentication scheme name is necessary to refer to a specific authentication scheme, when it is not specified, a default name is used:</p>
<ul>
<li class="mce-root">The standard name contained in <kbd>CookieAuthenticationDefaults.AuthenticationScheme</kbd> for cookie authentication</li>
<li class="mce-root">The standard name contained in <kbd>JwtBearerDefaults.AuthenticationScheme</kbd> for JWT authentication</li>
</ul>
<p>The name passed in <kbd>o.DefaultScheme</kbd> selects the authentication scheme used for filling the <kbd>User</kbd> property of <kbd>HttpContext</kbd>.</p>
<div class="mce-root packt_tip">For more information about JWT authentication, please refer to the <em>ASP.NET Core services authorization</em> subsection of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a><span>, <em>Applying Service-Oriented Architectures with .NET Core</em></span>.</div>
<p><kbd>UseAuthorization</kbd> enables authorization based on the <kbd>Authorize</kbd> attribute. Options can be configured with an <kbd>AddAuthorization</kbd> method placed in the <kbd>ConfigureServices</kbd> method. These options allow the definition of policies for claims-based authorization.</p>
<div class="mce-root packt_tip">For more information on authorization, please refer to the <em>ASP.NET Core services authorization</em> subsection of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a><span>, <em>Applying Service-Oriented Architectures with .NET Core</em></span>.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>UseRouting</kbd> and <kbd>UseEndpoints</kbd> handle the so-called ASP.NET Core endpoints. <span>An endpoint is an abstraction of a handler that serves specific classes of URLs. URLs are transformed into an <kbd>Endpoint</kbd> instance by using patterns. When a pattern matches a URL, an <kbd>Endpoint</kbd> instance is created and filled with both the pattern name and data extracted from the URL as a consequence of matching URL parts with named parts of the pattern, as shown in the following code snippet:</span></p>
<pre>Request path: /UnitedStates/NewYork <br/>Pattern: Name="location", match="/{Country}/{Town}"<br/><br/>Endpoint: DisplayName="Location", Country="UnitedStates", Town="NewYork"</pre>
<p><kbd>UseRouting</kbd> adds a module that processes the request path to get the request <kbd>Endpoint</kbd> instance and adds it to the <kbd>HttpContext.Features</kbd> dictionary under the <kbd>IEndpointFeature</kbd> type. The actual <kbd>Endpoint</kbd> instance is contained in the <kbd>Endpoint</kbd> property of <kbd>IEndpointFeature</kbd>.  </p>
<p>Each pattern also contains the handler that should process all requests that match the pattern. This handler is passed to <kbd>Endpoint</kbd> when the <kbd>Endpoint</kbd> is created. </p>
<p><kbd>UseEndpoints</kbd> instead adds the middleware that invokes the handler associated with the request endpoint. It is placed at the end of the pipeline since the execution of the handler is expected to produce the final response. </p>
<p>As the following code snippet shows, patterns are processed in the <kbd>UseRouting</kbd> middleware but they are specified in the <kbd>UseEndpoints</kbd> method. This splitting is not necessary but is done for coherence with the previous ASP.NET Core versions that contained no method analogous to <kbd>UseRouting</kbd>, but a unique call at the end of the pipeline. In the new version, patterns are still defined in <kbd>UseEndpoints</kbd>, which is placed at the end of the pipeline, but <kbd>UseEndpoints</kbd> just creates a data structure containing all patterns, when the application starts. Then, this data structure is processed by the <kbd>UseRouting</kbd> middleware, as shown in the following code:</p>
<pre>app.UseRouting();<br/><br/>app.UseAuthentication();<br/>app.UseAuthorization();<br/><br/>app.UseEndpoints(endpoints =&gt;<br/>{<br/>    endpoints.MapControllerRoute(<br/>        name: "default",<br/>        pattern: "{controller=Home}/{action=Index}/{id?}");<br/>    <br/>    <br/>});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><kbd>MapControllerRoute</kbd> defines the patterns associated with the MVC engine that will be described in the next subsection. There are other methods that define other types of patterns. A call such as <kbd>.MapHub&lt;MyHub&gt;("/chat")</kbd> maps paths to hubs that handle WebSockets, whereas <kbd>.MapHealthChecks("/health")</kbd> maps paths to ASP.NET Core components that return application health data. You can also directly map a pattern to a custom handler with <kbd>.MapGet</kbd>, which intercepts GET requests, and <kbd>.MapPost</kbd>, which intercepts POST requests. The following in an example of <kbd>MapGet</kbd>:</p>
<pre>MapGet("hello/{country}", context =&gt; <br/>    context.Response.WriteAsync(<br/>    $"Selected country is {context.GetRouteValue("country")}"));</pre>
<p>Patterns are processed in the order in which they are defined until a matching pattern is found. <span>Since the authentication/authorization middleware is placed after the routing middleware, it can process the</span> <span><kbd>Endpoint</kbd></span> <span>request</span> <span>to verify whether the current user has the required authorizations to execute the</span> <kbd>Endpoint</kbd> <span>handler. Otherwise, a 401 (Unauthorized) or 403 (Forbidden) response is immediately returned. Only requests that survive authentication and authorization have their handlers executed by the </span><kbd>UseEndpoints</kbd> <span>middleware.</span></p>
<p>With the ASP.NET Core RESTful API described in <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a><span>, <em>Applying Service-Oriented Architectures with .NET Core</em></span>, ASP.NET Core MVC <span>also </span>uses attributes placed on controllers or on controller methods to specify authorization rules. However, an instance of <kbd>AuthorizeAttribute</kbd> can be also added to a pattern to apply its authorization constraints to all URLs matching that pattern, as shown in the following example:</p>
<pre>endpoints<br/> .MapHealthChecks("/healthz")<br/> .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });</pre>
<p>The preceding code makes the health check path available only to administrative users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining controllers and ViewModels</h1>
                </header>
            
            <article>
                
<p>The various <kbd>.MapControllerRoute</kbd> calls in <kbd>UseEndpoints</kbd> associate URL patterns to controllers and to methods of these controllers, where controllers are classes that inherit from the <kbd>Microsoft.AspNetCore.Mvc.Controller</kbd> class. Controllers are discovered by inspecting all of the application's <kbd>.dll</kbd> files and are added to the DI engine. This job is performed by the call to <kbd>AddControllersWithViews</kbd> in the <kbd>ConfigureServices</kbd> method of the <kbd>startup.cs</kbd> file.</p>
<p class="mce-root"/>
<p>The pipeline module added by <kbd>UseEndpoints</kbd> takes the controller name from the <kbd>controller</kbd> pattern variable, and the name of the controller method to invoke from the <kbd>action</kbd> pattern variable. Since, by convention, all controller names are expected to end with the <kbd>Controller</kbd> suffix, the actual controller type name is obtained from the name found in the <kbd>controller</kbd> variable by adding this suffix. Hence, for instance, if the name found in <kbd>controller</kbd> is <kbd>"Home"</kbd>, then the <kbd>UseEndpoints</kbd> module tries to get an instance of the <kbd>HomeController</kbd> type from the DI engine. All of the controller public methods can be selected by the routing rules. Use of a controller public method can be prevented by decorating it with the <kbd>[NonAction]</kbd> attribute. All controller methods available to the routing rules are called action methods.</p>
<p>MVC controllers work like the API controllers that we described in the <em>Implementing REST services with ASP.NET Core</em> subsection of <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a>, <em>Applying Service-Oriented Architectures with .NET Core</em>. The only difference is that API controllers are expected to produce JSON or XML, while MVC controllers are expected to produce HTML. For this reason, while API controllers inherit from the <kbd>ControllerBase</kbd> class, MVC controllers inherit from the <kbd>Controller</kbd> class, which, in turn, inherits from the <kbd>ControllerBase</kbd> class and adds its methods that are useful for HTML generation, such as invoking views, which are described in the next subsection, and creating a redirect response.</p>
<p>MVC controllers may use also a routing technique similar to one of the API controllers, that is, routing based on controllers and controller method attributes. This behavior is enabled by calling the <kbd>.MapDefaultControllerRoute()</kbd> method in <kbd>UseEndpoints</kbd>. If this call is placed before all <kbd>MapControllerRoute</kbd> calls, then controller routes have priority on <kbd>MapControllerRoute</kbd> patterns; otherwise, the converse is true.</p>
<p>All attributes we have seen for API controllers can be also used with MVC controllers and action methods (<kbd>HttpGet</kbd>, <kbd>HttpPost</kbd>, <kbd>...Authorize</kbd>, and so on). Developers can write their own custom attributes by inheriting from the <kbd>ActionFilter</kbd> class or other derived classes. I will not give details on this right now, but these details can be found in the official documentation referred to in the <em>Further reading</em> section.</p>
<p>When the <kbd>UseEndpoints</kbd> module invokes a controller, all of its constructor parameters are filled by the DI engine since the controller instance itself is returned by the DI engine, and since DI automatically fills constructor parameters with DI in a recursive fashion.</p>
<p>Action method parameters, instead, are taken from the following sources: </p>
<ul>
<li>Request headers</li>
<li>Variables in the pattern matched by the current request</li>
<li>Query string parameters</li>
<li>Form parameters (in the case of POST requests)</li>
<li><strong>Dependency injection</strong> (<strong>DI</strong>)</li>
</ul>
<p>While the parameters filled with DI are matched by type, all other parameters are matched by <em>name</em> ignoring the letter casing. That is, the action method parameter name must match the header, query-string, form, or pattern variable. When the parameter is a complex type, a match is searched for each property, using the property name for the match. In the case of nested complex types, a match is searched for each path and the name associated with the path is obtained by chaining all property names in the path and separating them with dots. For instance, the name associated with a path composed by <kbd>Property1</kbd>, <kbd>Property2</kbd>, ...., <kbd>Propertyn</kbd>, is <kbd>Property1.Property2.Property3...Propertyn</kbd>. The name obtained this way must match a header name, pattern variable name, query string parameter name, and so on.</p>
<p>By default, simple type parameters are matched with pattern variables and query string variables, while complex types parameters are matched with form parameters. However, the preceding defaults can be changed by prefixing the parameters with attributes as detailed here:</p>
<ul>
<li><kbd>[FromForm]</kbd> forces a match with form parameters.</li>
<li><kbd>[FromHeader]</kbd> forces a match with a request header.</li>
<li><kbd>[FromRoute]</kbd> forces a match with pattern variables.</li>
<li><kbd>[FromQuery]</kbd> forces a match with a query string variable.</li>
<li><kbd>[FromServices]</kbd> forces the use of DI.</li>
</ul>
<p>During the match, the string extracted from the selected source is converted into the type of the action method parameter using the current thread culture. If either a conversion fails or no match is found for a not nullable action method parameter, then the whole action method invocation process fails, and a 404 response is automatically returned. For instance, in the following example, the <kbd>id</kbd> parameter is matched with query string parameters or pattern variables since it is a simple type, while <kbd>myclass</kbd> properties and nested properties are matched with form parameters since <kbd>MyClass</kbd> is a complex type. Finally, <kbd>myservice</kbd> is taken from DI since it is prefixed with the <kbd>[FromServices]</kbd> attribute:</p>
<pre>    public class HomeController : Controller<br/>    {<br/>        public IActionResult MyMethod(<br/>            int id, <br/>            MyClass myclass, <br/>            [FromServices] MyService myservice)<br/>        {<br/>            ...</pre>
<p class="mce-root"/>
<p>If no match is found for the <kbd>id</kbd> parameter, a 404 response is automatically returned since integers are not nullable. If, instead, no <kbd>MyService</kbd> instance is found in the DI container, an exception is thrown because in this case the failure doesn't depend on a wrong request but a design error.</p>
<p>MVC controllers return an <kbd>IActionResult</kbd> interface or a <span><kbd>Task&lt;IActionResult&gt;</kbd> result if they are declared as <kbd>async</kbd>. <kbd>IActionResult</kbd> has a unique <kbd>ExecuteResultAsync(ActionContext)</kbd> method that, when invoked by the framework, produces the actual response.</span></p>
<p>For each different <kbd>IActionResult</kbd>, MVC controllers have methods that return them. The most commonly used <kbd>IActionResult</kbd> is <kbd>ViewResult</kbd>, which is returned by a <kbd>View</kbd> method:</p>
<pre>public IActionResult MyMethod(...)<br/>{<br/>   ...<br/>   return View("myviewName", MyViewModel)<br/>}</pre>
<p><kbd>ViewResult</kbd> is a very common way for a controller to create an HTML response. More specifically, the controller interacts with business/data layers to produce an abstraction of the data that will be shown in the HTML page. This abstraction is an object called a <strong>ViewModel</strong>. The ViewModel is passed as a second argument to the <kbd>View</kbd> method, while the first argument is the name of an HTML template called View that is instantiated with the data contained in the ViewModel.</p>
<p>Summing up, the MVC controllers' processing sequence is as follows:</p>
<ol>
<li>Controllers perform some processing to create the ViewModel, which is an abstraction of the data to show on the HTML page.</li>
<li>Then, controllers create <kbd>ViewResult</kbd> by passing a View name and ViewModel to the <kbd>View</kbd> method.</li>
<li>The MVC framework invokes <kbd>ViewResult</kbd> and causes the template contained in the View to be instantiated with the data contained in the ViewModel.</li>
<li>The result of the template instantiation is written in the response with adequate headers.</li>
</ol>
<p>This way, the controller performs the conceptual job of HTML generation by building a ViewModel, while the View, that is, the template, takes care of all the graphical details. </p>
<p class="mce-root"/>
<p>Views are described in greater detail in the next subsection, while the Model (ViewModel) View Controller pattern is discussed in more detail in the <em>Connection between ASP.NET Core MVC and design principles</em> section of this chapter. Finally, a practical example is given in the <em>Use case – web app in ASP.NET Core MVC</em> section of this chapter.</p>
<p>Another common <kbd>IActionResult</kbd> is <kbd>RedirectResult</kbd>, which creates a redirect response, hence forcing the browser to move to a specific URL. Redirects are often used after the user has successfully submitted a form that completes a previous operation. In this case, it is common to redirect the user to a page where they can select another operation. </p>
<p>The simplest way to return <kbd>RedirectResult</kbd> is by bypassing a URL to the <kbd>Redirect</kbd> method. This is the advised way to perform a redirect to a URL that is outside the web application. When the URL is within the web application, instead, it is advisable to use the <kbd>RedirectToAction</kbd> method, which accepts the controller name, the action method name, and the desired parameters for the target action method. The framework uses this data to compute a URL that causes the desired action method to be invoked with the provided parameters. This way, if the routing rules are changed during the application development or maintenance, the new URL is automatically updated by the framework with no need to modify all occurrences of the old URL in the code. The following code shows how to call <kbd>RedirectToAction</kbd>:</p>
<pre>return RedirectToAction("MyActionName", "MyControllerName",<br/>         new {par1Name=par1VAlue,..parNName=parNValue});</pre>
<p>Another useful <kbd>IActionResult</kbd> is <kbd>ContentResult</kbd>, which can be created by calling the <kbd>Content</kbd> method. <kbd>ContentResult</kbd> allows you to write any string to the response and to specify its MIME type, as shown in the following example:</p>
<pre>return Content("this is plain text", "text/plain");</pre>
<p>Finally, the <kbd>File</kbd> method returns <kbd>FileResult</kbd>, which writes binary data in the response. There are several overloads of this method that allow the specification of a byte array, a stream, or the path of a file, plus the MIME type of the binary data.</p>
<p>Now, let's move to describe how actual HTML is generated in Views.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Razor Views</h1>
                </header>
            
            <article>
                
<p>ASP.NET Core MVC uses a language called Razor to define the HTML templates contained in the Views. Razor views are files that are compiled into .NET classes either at their first usage, when the application is built, or when the application is published. As a default, both pre-compilation on each build and on publish are enabled, but this behavior can be changed by adding the following code to the web application project file:</p>
<pre>&lt;PropertyGroup&gt;<br/>  &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;<br/>  &lt;!-- add code below --&gt;<br/>  &lt;RazorCompileOnBuild&gt;false&lt;/RazorCompileOnBuild&gt;<br/>  &lt;RazorCompileOnPublish&gt;false&lt;/RazorCompileOnPublish&gt;<br/>  &lt;!-- end of code to add --&gt;<br/>    ...<br/>&lt;/PropertyGroup&gt;</pre>
<p>Views can also be precompiled into views libraries by choosing a Razor view library project in the windows that appear after you have chosen an ASP.NET Core project.</p>
<p>Also, after the compilation, views remain associated with their paths, which become their full names. Each controller has an associated folder under the <span class="packt_screen">Views</span> folder with the same name as the controller, which is expected to contain all the views used by that controller. The following screenshot shows the folder associated with the <kbd>HomeController</kbd> and its Views:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/518c957c-8d20-4875-86ce-d93a9df56ba0.png" style="width:18.17em;height:13.08em;"/></p>
<p>The preceding screenshot also shows the <span class="packt_screen">Shared</span> folder, which is expected to contain all the views used by several controllers. The controller refers to views in the <kbd>View</kbd> method through their paths without the <kbd>.cshtml</kbd> extension. If the path starts with <kbd>/</kbd>, the path is interpreted as relative to the application root. Otherwise, as a first attempt, the path is interpreted as relative to the folder associated with the controller and, if no view is found there, the view is searched in the <span class="packt_screen">Shared</span> folder.</p>
<p>Hence, for instance, the <kbd>Privacy.cshtml</kbd> View file in the <span>preceding screenshot</span> can be referred to from within <kbd>HomeController</kbd> as <kbd>View("Privacy", MyViewModel)</kbd>. If the name of the View is the same as the name of the action method, we can simply write <kbd>View(MyViewModel)</kbd>.</p>
<p>Razor views are a mix of HTML code with C# code, plus some Razor-specific statements. They all begin with a header that contains the type of ViewModel that the View is expected to receive:</p>
<pre>@model MyViewModel </pre>
<p>Each view may contain also some <kbd>using</kbd> statements whose effect is the same as the <kbd>using</kbd> statements of standard code files:</p>
<pre>@model MyViewModel <br/>@using MyApplication.Models</pre>
<p><kbd>@using</kbd> statements declared in the special <kbd>_ViewImports.cshtml</kbd> file, that is, in the root of the Views folder, are automatically applied to all views.</p>
<p>Each view can also require instances of types from the DI engine in its header with the syntax shown here:</p>
<pre>@model MyViewModel <br/>@using MyApplication.Models<br/>@inject IViewLocalizer Localizer</pre>
<p>The preceding code requires an instance of the <kbd>IViewLocalizer</kbd> interface and places it in the <kbd>Localizer</kbd> variable. The remainder of the View is a mix of C# code, HTML, and Razor control flow statements. Each area of a view can be either in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted as HTML, while t<span>he code in a View area that is </span>in C# mode is interpreted as C#. </p>
<p>The topic that follows explains Razor flow of control statements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning Razor flow of control statements</h1>
                </header>
            
            <article>
                
<p>If you want to write some C# code in an HTML area, you can create a C# area with the <kbd>@{..}</kbd> flow of control Razor statement, as shown here:</p>
<pre>@{<br/>    //place C# code here<br/>    var myVar = 5;<br/>    ...<br/>    &lt;div&gt;<br/>        &lt;!-- here you are in HTML mode again --&gt;<br/>        ...<br/>    &lt;/div&gt;<br/>    //after the HTML block you are still in C# mode<br/>    var x = "my string";<br/>}</pre>
<p>The preceding example shows that it is enough to write an HTML tag to create an HTML area inside of the C# area and so on recursively. As soon as the HTML tag closes, you are again in C# mode.</p>
<p>C# code produces no HTML, while HTML code is added to the response in the same order it appears. You can add te<span>xt computed with C# code while in HTML mode by prefixing any C# expression with <kbd>@</kbd>. If the expression is complex, composed of a c</span><span>hain of properties and method calls, it must be enclosed by parentheses. The following code shows some examples:</span></p>
<pre>&lt;span&gt;Current date is: &lt;/span&gt;<br/>&lt;span&gt;@DateTime.Today.ToString("d")&lt;/span&gt;<br/>...<br/>&lt;p&gt;<br/>  User name is: @(myName+ " "+mySurname)<br/>&lt;/p&gt;<br/>...<br/>&lt;input type="submit" value="@myUserMessage" /&gt;</pre>
<p>Types are converted into strings using the current culture settings (see the <em>Connection between ASP.NET Core MVC and design principles</em> section for details on how to set the culture of each request). Moreover, strings are automatically HTML encoded to avoid the <kbd>&lt;</kbd> and <kbd>&gt;</kbd> symbols that might interfere with the view HTML. HTML encoding can be prevented with the <kbd>@HTML.Raw</kbd> function, as shown here:</p>
<pre>@HTML.Raw(myDynamicHtml)</pre>
<p><span>In an HTML area, a</span>lternative HTML can be selected with the <kbd>@if</kbd> Razor statement:</p>
<pre>@if(myUser.IsRegistered)<br/>{<br/>    //this is a C# code area<br/>    var x=5;<br/>    ...<br/>    &lt;p&gt;<br/>     &lt;!-- This is an HTML area --&gt;<br/>    &lt;/p&gt;<br/>    //this is a C# code area again<br/>}<br/>else if(callType == CallType.WebApi)<br/>{<br/>    ...<br/>}<br/>else<br/>{<br/> ..<br/>}</pre>
<p>An HTML template can be instantiated several times with the <kbd>for</kbd>, <kbd>foreach</kbd>, and <kbd>while</kbd> Razor statements, as shown in the following examples:</p>
<pre>@for(int i=0; i&lt; 10; i++)<br/>{<br/><br/>}<br/><br/>@foreach(var x in myIEnumerable)<br/>{<br/><br/>}<br/><br/>@while(true)<br/>{<br/>    <br/>}</pre>
<p>Please do not confuse the statements described so far with the usual C# <kbd>if</kbd>, <kbd>for</kbd>, <kbd>foreach</kbd>, and <kbd>while</kbd> statements, since they are Razor-specific statements whose syntax is similar to their standard C# counterparts.</p>
<p>Razor views can contain comments that do not generate any code. Any text included within <kbd>@*...*@</kbd> is considered a comment and is removed when the page is compiled. The next topic describes properties that are available in all Views.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Razor View properties</h1>
                </header>
            
            <article>
                
<p class="mce-root">Some standard variables are predefined in each view. The most important variable is <kbd>Model</kbd>, which contains the ViewModel passed to the view. For instance, if we pass a <kbd>Person</kbd> model to a view, then <kbd>&lt;span&gt;@Model.Name&lt;/span&gt;</kbd><span> displays the name of the <kbd>Person</kbd> passed to the view.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>ViewData</kbd> variable contains <kbd>IDictionary&lt;string, object&gt;</kbd>, which is shared with the controller that invoked the view. That is, all controllers <span>also</span><span> </span><span>have a</span> <kbd>ViewData</kbd> <span>property containing</span> <kbd>IDictionary&lt;string, object&gt;</kbd><span>, and every entry that is set in the controller is available also in the</span> <kbd>ViewData</kbd> <span>variable of the invoked view. </span><kbd>ViewData</kbd> <span>is an alternative to the ViewModel for a controller to pass information to its invoked view.</span></p>
<p>The <kbd>User</kbd> variable contains the currently logged user, that is, the same instance contained in the current request's <kbd>Http.Context.User</kbd> property. The <kbd>Url</kbd> variable contains an instance of the  <kbd>IUrlHelper</kbd> interface whose methods are utilities for computing URLs of application pages. For instance, <kbd>Url.Action("action", "controller", new {par1=valueOfPar1,...})</kbd> computes the URL that causes the action method <em>action</em> of the <em>controller</em> to be invoked with all parameters specified in the anonymous object passed as its parameters.</p>
<p>The <kbd>Context</kbd> variable contains the whole request <kbd>HttpContext</kbd>. The <kbd>ViewContext</kbd> variable contains data about the context of the view invocation, included metadata about the action method that invoked the view.</p>
<p>The next topic describes how Razor enhances HTML tag syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Razor tag helpers</h1>
                </header>
            
            <article>
                
<p>In ASP.NET Core MVC, the developer can define the so-called tag helpers that either enhance existing HTML tags with new tag attributes or define new tags. While Razor views are compiled, any tag is matched against existing tag helpers. When a match is found, the source tag is replaced with HTML created by the tag helpers. Several tag helpers may be defined for the same tag. They <span>are</span><span> </span><span>all</span> <span>executed in an order that can be configured with a priority attribute associated with each tag helper.</span></p>
<p>All tag helpers defined for the same tag may cooperate during the processing of each tag instance because they are passed as a shared data structure where each of them may apply a contribution. Usually, the final tag helper that is invoked processes this shared data structure to produce the output HTML.</p>
<p>Tag helpers are classes that inherit from the <span><kbd>TagHelper</kbd> class. This topic doesn't discuss how to create new tag helpers but introduces the main predefined tag helpers that come with ASP.NET Core MVC. A complete guide on how to define tag helpers is available in the official documentation that is referenced in the <em>Further reading</em> section.</span></p>
<p class="mce-root"/>
<p>To use a tag helper, you must declare the <kbd>.dll</kbd> file containing it with a declaration like in the following:</p>
<pre>@addTagHelper *, Dll.Complete.Name</pre>
<p>If you would like to use just one of the tag helpers defined in the <kbd>.dll</kbd> file, you must replace <kbd>*</kbd> with the tag name.</p>
<p>The preceding declaration can be placed either in each view that uses the tag helpers defined in the library or, once and for all, in the <kbd>_ViewImports.cshtml</kbd> file in the root of the Views folder. As a default, <span><kbd>_ViewImports.cshtml</kbd> adds all predefined ASP.NET Core MVC tag helpers with the following declaration:</span></p>
<pre>@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers</pre>
<p>The anchor tag is enhanced with attributes that automatically compute the URL and that invoke a specific action method with given parameters, as shown here:</p>
<pre>&lt;a asp-controller="{controller name}"<br/>asp-action="{action method name}" <br/>asp-route-{action method parameter1}="value1"<br/>...<br/>asp-route-{action method parametern}="valuen"&gt; <br/>    put anchor text here<br/>&lt;/a&gt;</pre>
<p>A similar syntax is added to the <kbd>form</kbd> tags:</p>
<pre>&lt;form asp-controller="{controller name}"<br/>asp-action="{action method name}" <br/>asp-route-{action method parameter1}="value1"<br/>...<br/>asp-route-{action method parametern}="valuen"<br/>...<br/>&gt; <br/>    ...</pre>
<p>The <kbd>script</kbd> tag is enhanced with attributes that allow falling back to a different source if the download fails. Typical usage is to download scripts from some cloud service to optimize the browser cache and to fall back to a local copy of the script in case of failure. The following code uses the fallback technique to download the <kbd>bootstrap</kbd> JavaScript file:</p>
<pre>&lt;script src="https://stackpath.bootstrapcdn.com/<br/>bootstrap/4.3.1/js/bootstrap.bundle.min.js"<br/>asp-fallback-src="~/lib/bootstrap/dist/js/<br/>bootstrap.bundle.min.js"<br/>asp-fallback-test="window.jQuery &amp;&amp; window.jQuery.fn &amp;&amp; window.jQuery.fn.modal" crossorigin="anonymous"<br/>integrity="sha384-xrRywqdh3PHs8keKZN+8zzc5TX0GRTLCcmivcbNJWm2rs5C8PRhcEn3czEjhAO9o"&gt;<br/>&lt;/script&gt;</pre>
<p><kbd>asp-fallback-test</kbd> contains a JavaScript test that verifies whether the download succeeded. In the preceding example, the test verifies whether a JavaScript object has been created.</p>
<p>The <kbd>environment</kbd> tag can be used to select different HTML for different environments (development, staging, and production). Its typical usage is selecting the debug version of JavaScript files during development, as shown in this example:</p>
<pre>&lt;environment include="Development"&gt;<br/>        @*development version of JavaScript files*@<br/>&lt;/environment&gt;<br/>&lt;environment exclude="Development"&gt;<br/>        @*development version of JavaScript files *@<br/>&lt;/environment&gt;</pre>
<p>There is also a <kbd>cache</kbd> tag, which caches its content in memory to optimize rendering speed:</p>
<pre><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>&gt;<br/>    @* heavy to compute content to casche *@</span></span><span class="cs"><br/></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;<br/></span></span></pre>
<p>As a default, content is cached for 20 minutes, but the tag has attributes to define when the cache expires, such as <kbd><span class="xml"><span class="hljs-tag"><span class="hljs-attr">expires-on</span>=<span class="hljs-string">"{datetime}"</span></span></span></kbd>,<span class="xml"><span class="hljs-tag"> <kbd>expires-after="{timespan}"</kbd>, and </span></span><kbd>expires-sliding="{timespan}"</kbd><span class="xml"><span class="hljs-tag"><span>. Here, the difference between <kbd>expires-sliding</kbd> and <kbd>expires-after</kbd> is that, in the second attribute, the expiration time count is reset each time the content is requested. The <kbd>vary-by</kbd> attribute causes the creation of a different cache entry for each different value passed to <kbd>vary-by</kbd>. There are also attributes such as <kbd>vary-by-header</kbd>—which creates a different entry for each different value assumed by the request header specified in the attribute, <kbd>vary-by-cookie</kbd>, and so on.</span></span></span></p>
<p>All <kbd>input</kbd> tags, that is, <kbd>textarea</kbd>, <kbd>input</kbd>, and <kbd>select</kbd>, have an <kbd>asp-for</kbd> attribute that accepts a properties path rooted in the view ViewModel <span>as their value</span>. For instance, if the view has a <kbd>Person</kbd> ViewModel, we may have something like this:</p>
<pre>&lt;input type="text" asp-for"Address.Town"/&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first effect of the preceding code is to assign the value of the <kbd>Town</kbd> nested property to the <kbd>value</kbd> attribute of the <kbd>input</kbd> tag. In general, if the value is not a string, it is converted into a string using the current request culture.</p>
<p>However, it <span>also</span><span> </span><span>sets the name of the input field to</span> <kbd>Address.Town</kbd><span> and the ID of the input field to</span> <kbd>Address_Town</kbd><span> since dots are not allowed in tag IDs. </span></p>
<p>A prefix can be added to these standard names by specifying it in <kbd><span>ViewData.TemplateInfo.HtmlFieldPrefix</span></kbd>. For instance, if the previous property is set to <kbd>MyPerson</kbd>, the name becomes <span><kbd>MyPerson.</kbd></span><span><kbd>Address.Town</kbd></span>. </p>
<p>If the form is submitted to an action method that has the same <kbd>Person</kbd> class as one of its parameters, the name <kbd>Address.Town</kbd> given to the <kbd>input</kbd> field will cause the <kbd>Town</kbd> property of this parameter to be filled with the <kbd>input</kbd> field. In general, the string contained in the <kbd>input</kbd> field is converted into the type of the property they are matched with using the current request culture. Summing up, names of <kbd>input</kbd> fields are created in such a way that a complete <kbd>Person</kbd> model can be recovered in the action method when the HTML page is posted.</p>
<p>The same <kbd>asp-for</kbd> attribute can be used in a <kbd>label</kbd> tag to cause the label to refer to the input field with the same <kbd>asp-for</kbd> value. </p>
<p>The following code is an example of an <kbd>input</kbd>/<kbd>label</kbd> pair:</p>
<pre>&lt;label asp-for"Address.Town"&gt;&lt;/label<br/>&lt;input type="text" asp-for"Address.Town"/&gt;</pre>
<p>When no text is inserted in the label, the text shown in the label is taken from a <kbd>Display</kbd> attribute that decorates the property (<kbd>Town</kbd>, in the example), if any; otherwise, the name of the property is used.</p>
<p>If <kbd>span</kbd> or <kbd>div</kbd> contains a <kbd>data-valmsg-for="Address.Town"</kbd> error attribute, then validation messages concerning the  <kbd>Address.Town</kbd> input will be inserted automatically inside that tag. The validation framework is described in the <em>Connection between ASP.NET Core MVC and design principles</em> section.</p>
<p>It is also possible to automatically create a validation error summary by adding the attribute that follows to <kbd>div</kbd> or <kbd>span</kbd>:</p>
<pre>asp-validation-summary="ValidationSummary.{All, ModelOnly}"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>If the attribute is set to <kbd>ValidationSummary.ModelOnly</kbd>, only messages that are not associated with specific <kbd>input</kbd> fields will be shown in the summary, and if the value is <kbd>ValidationSummary.All</kbd>, all error messages will be shown.</p>
<p>The <kbd>asp-items</kbd> attribute allows specifying the options of <kbd>select</kbd> through <kbd>IEnumerable&lt;SelectListItem&gt;</kbd>, where each <kbd>SelectListItem</kbd> contains both the text and value of each option. <kbd>SelectListItem</kbd> contains also an optional <kbd>Group</kbd> property you can use to organize <span>into groups </span>the options shown in <kbd>select</kbd>.</p>
<p>The next topic shows how to reuse view code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reusing view code</h1>
                </header>
            
            <article>
                
<p>ASP.NET Core MVC includes several techniques for reusing view code. The most important is the layout page.</p>
<p>In each web application, several pages share the same structure, for instance, the same main menu or the same left or right bar. In ASP.NET Core, this common structure is factored out in views called layout pages/views.</p>
<p>Each view can specify the view to use as its layout page with the following code:</p>
<pre>@{<br/>    Layout = "_MyLayout";<br/>}</pre>
<p>If no layout page is specified, a default layout page, defined in the <kbd>_ViewStart.cshtml</kbd> file located in the <kbd>Views</kbd> folder, is used. The default content of <span><kbd>_ViewStart.cshtml</kbd> is as follows:</span></p>
<pre>@{<br/>    Layout = "_Layout";<br/>}</pre>
<p>Therefore, the default layout page in the files scaffolded by Visual Studio is <kbd>_Layout.cshtml</kbd>, which is contained in the <kbd>Shared</kbd> folder.</p>
<p class="mce-root"/>
<p>The layout page contains the HTML shared with all of its children pages, the HTML page headers, and the page references to CSS and JavaScript files. The HTML produced by each view is placed inside of its layout place, where the layout page calls the <kbd>@RenderBody()</kbd> method, as shown in the following example:</p>
<pre>...<br/>&lt;main role="main" class="pb-3"&gt;<br/>    ...<br/>    @RenderBody()<br/>    ...<br/>&lt;/main&gt;<br/>...</pre>
<p><kbd>ViewState</kbd> of each <kbd>View</kbd> is copied into <kbd>ViewState</kbd> of its layout page, so <kbd>ViewState</kbd> can be used to pass information to the view layout page. Typically, it is used to pass the view title to the layout page that use it to compose the page's title header, as shown here:</p>
<pre><span>@*In the view *@<br/><br/>@{<br/>    ViewData["Title"] = "Home Page";  <br/>}<br/><br/>@*In the layout view*@<br/>&lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    ...<br/>    &lt;title&gt;@ViewData["Title"] - My web application&lt;/title&gt;<br/>    ...<br/></span></pre>
<p>While the main content produced by each view is placed in a single area of its layout page, each layout page can also define several sections placed in different areas where each view can place further secondary contents.</p>
<p>For instance, suppose a layout page defines a <kbd>Scripts</kbd> section, as shown here:</p>
<pre>...<br/>&lt;script src="~/js/site.js" asp-append-version="true"&gt;&lt;/script&gt;<br/><br/>@RenderSection("Scripts", required: false)<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Then, the view can use the previously <span>defined</span><span> </span><span>section to pass some view specific JavaScript references, as shown here:</span></p>
<pre>.....<br/>@section scripts{<br/>    &lt;script src="~/js/pages/pageSpecificJavaScript.min.js"&gt;&lt;/script&gt;<br/>}<br/>.....</pre>
<p>If an action method is expected to return HTML to an Ajax call, it must produce an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout page must be used. This is achieved by calling the <kbd>PartialView</kbd> method instead of the <kbd>View</kbd> method in the controller action method. <span><kbd>PartialView</kbd> and <kbd>View</kbd> </span>have exactly the same overloads and parameters.</p>
<p>Another way to reuse view code is to factor out a view fragment that's common to several views into another view that is called by all previous views. A view can call another view with the <kbd>partial</kbd> tag, as shown here:</p>
<pre>&lt;partial name="_viewname" for="ModelProperty.NestedProperty"/&gt;</pre>
<p>The preceding code invokes <kbd>_viewname</kbd> and passes it to the object contained in <kbd>Model.ModelProperty.NestedProperty</kbd> as its <kbd>ViewModel</kbd>. When a view is invoked by the <kbd>partial</kbd> tag, no layout page is used since the called view is expected to return an HTML fragment.</p>
<p>The <kbd>ViewData.TemplateInfo.HtmlFieldPrefix</kbd> property of the called view is set to the <kbd>"ModelProperty.NestedProperty"</kbd><span> </span><span>string</span><span>. This way, possible input fields rendered in</span> <kbd>_viewname.cshtml</kbd> <span>will have the same name as if they were rendered directly by the calling view. </span></p>
<p>Instead of specifying the ViewModel of <kbd>_viewname</kbd> through a property of the caller view (ViewModel), you can also pass an object <span>directly </span>that is contained in a variable or returned by a C# expression by replacing <kbd>for</kbd> with <kbd>model</kbd>, as shown in this example:</p>
<pre>&lt;partial name="_viewname" model="new MyModel{...})" /&gt;</pre>
<p>In this case, <kbd>ViewData.TemplateInfo.HtmlFieldPrefix</kbd> of the called view keeps its default value, that is, the empty string.</p>
<p class="mce-root"/>
<p>A view can also call something more complex than another view, that is, another controller method that, in turn, renders a view. Controllers that are designed to be invoked by views are called <strong>view components</strong>. The following code is an example of component invocation:</p>
<pre>&lt;vc:[view-component-name] par1="par1 value" par2="parameter2 value"&gt;<br/>&lt;/vc:[view-component-name]&gt;</pre>
<p>Parameter names must match the ones used in the view component method. However, both component name and parameter names must be translated into kebab case, that is, all characters must be transformed into lowercase and all characters that in the original name were in uppercase and each word must be separated by a <kbd>-</kbd>. For instance, <kbd>MyParam</kbd> must be transformed into <kbd>my-param.</kbd></p>
<p>Actually, view components are classes that derive from the <kbd>ViewComponent</kbd> class. When a component is invoked, the framework looks for either an <kbd>Invoke</kbd> method or an <kbd>InvokeAsync</kbd> method and passes it to the parameters defined in the component invocation. <kbd>InvokeAsync</kbd> must be used if the method is defined as <kbd>async</kbd>; otherwise, we must use <kbd>Invoke</kbd>.</p>
<p>The following code is an example of a view component definition:</p>
<pre>public class MyTestViewComponent : ViewComponent<br/>    {<br/>        <br/>        public async Task&lt;IViewComponentResult&gt; InvokeAsync(<br/>        int par1, bool par2)<br/>        {<br/>            var model= ....<br/>            return View("ViewName", model);<br/>        }<br/>        <br/>    }</pre>
<p>The previously <span>defined</span><span> </span><span>component must be invoked with a call such as the following:</span></p>
<pre>&lt;vc:my-test par1="10" par2="true"&gt;&lt;/my-test&gt;</pre>
<p>If the component is invoked by a view of a controller called  <kbd>MyController</kbd>, <kbd>ViewName</kbd> is searched in the following paths:</p>
<ul>
<li><kbd>/Views/<span>MyController</span>/Components/MyTest/ViewName</kbd></li>
<li><kbd>/Views/Shared/<span>Components/</span><span>MyTest/</span><span>ViewName</span></kbd></li>
</ul>
<p>Now, let's look at the new features that came along with .NET Core 3.0.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is new in .NET Core 3.0 for ASP.NET Core?</h1>
                </header>
            
            <article>
                
<p>The main innovation introduced by ASP.NET 3.0 is that the routing engine was factored out of the MVC engine and is now available for other handlers. In previous versions, routes and routing were a part of the MVC handler added with <kbd>app.UseMvc(....)</kbd>; that now has been replaced by <kbd>app.UseRouting()</kbd> plus <kbd>UseEndpoints(...)</kbd>, which can route requests not only to controllers but also to other handlers. </p>
<p>Endpoints and their associated handlers are now defined in <kbd>UseEndpoints</kbd>, as shown here:</p>
<pre> app.UseEndpoints(endpoints =&gt;<br/>    {<br/>        ...<br/>        endpoints.MapControllerRoute("default", "<br/>        {controller=Home}/{action=Index}/{id?}");<br/>        ...<br/>    });</pre>
<p><kbd>MapControllerRoute</kbd> associates patterns with controllers, but we may use also something such as <kbd>endpoints.MapHub&lt;ChatHub&gt;("/chat")</kbd>, which associates a pattern with a hub that handles WebSocket connections. In the previous section, we have seen that patterns can be associated also with custom handlers using <kbd>MapPost</kbd> and <kbd>MapGet</kbd>.</p>
<p>An independent router also allows us to add authorizations not only to controllers but also to any handler, as shown here:</p>
<pre>MapGet("hello/{country}", context =&gt; <br/>    context.Response.WriteAsync(<br/>    $"Selected country is {context.GetRouteValue("country")}"))<br/>    .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin" });</pre>
<p>In the 3.0 version, ASP.NET Core has an independent JSON formatter and doesn't depend on the third-party Newtonsoft JSON serializer any more. However, <span>if you have more sophisticated needs,</span> you have still the option to replace the minimal ASP.NET Core JSON formatter with Newtonsoft JSON serializer by installing the <kbd>Microsoft.AspNetCore.Mvc.NewtonsoftJson</kbd> NuGet package and configuring controllers, as shown here:</p>
<pre><span>services.AddControllersWithViews()<br/>    .AddNewtonsoftJson();</span></pre>
<p class="mce-root"/>
<p>Here, <kbd>AddNewtonsoftJson</kbd> has also an overload that accepts configuration options for the Newtonsoft JSON serializer:</p>
<pre>.AddNewtonsoftJson(options =&gt;<br/>           options.SerializerSettings.ContractResolver =<br/>              new CamelCasePropertyNamesContractResolver());</pre>
<p>In previous versions, you were forced to add both controllers and views to the DI engine. In version 3, we can still inject both controllers and views with <kbd>services.AddControllersWithViews</kbd> but you can also add controllers with <kbd>AddControllers</kbd> if you are going to implement REST endpoints only.</p>
<p>In previous versions, ASP.NET Core had a custom implementation of <kbd>IWebHostBuilder</kbd>, which was completely independent of <kbd>HostBuilder</kbd><span>, which is the standard implementation of</span> <kbd>IHostBuilder</kbd><span> used to configure a generic host. The following code shows how the ASP.NET Core host was configured before version 3.0:<br/></span></p>
<pre>public class Program<br/>{<br/>    public static void Main(string[] args)<br/>    {<br/>        CreateWebHostBuilder(args).Build().Run();<br/>    }<br/><br/>    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;<br/>        WebHost.CreateDefaultBuilder(args)<br/>            .UseStartup&lt;Startup&gt;();<br/>}</pre>
<p>ASP.NET Core 3.0, instead, uses a type that inherits from <kbd>HostBuilder</kbd> and adds the methods of <kbd>IWebHostBuilder</kbd>, as shown here:</p>
<pre>public class Program<br/>{<br/>    public static void Main(string[] args)<br/>    {<br/>        CreateHostBuilder(args).Build().Run();<br/>    }<br/><br/>    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;<br/>        Host.CreateDefaultBuilder(args)<br/>            .ConfigureWebHostDefaults(webBuilder =&gt;<br/>            {<br/>                webBuilder.UseStartup&lt;Startup&gt;();<br/>            });<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As a first step, <kbd>Host.CreateDefaultBuilder</kbd> creates a standard <kbd>HostBuilder</kbd>, <kbd>ConfigureWebHostDefaults</kbd> copies data contained in this <kbd>HostBuilder</kbd> in a derived class that also implements <kbd>IWebHostBuilder</kbd> and lets the developer configure this <kbd>IWebHostBuilder</kbd> in the action that it receives as an argument. <kbd>IWebHostBuilder</kbd>, once configured, is returned as <kbd>IHostBuilder</kbd> so that all web-specific things remain hidden.</p>
<p>This way development paths of <kbd>HostBuilder</kbd> and <kbd>WebHostBuilder</kbd> have been merged, and new enhancements and extension methods of <kbd>IHostBuilder</kbd> are automatically available also for the ASP.NET Core host.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the connection between ASP.NET Core MVC and design principles</h1>
                </header>
            
            <article>
                
<p>The whole ASP.NET Core framework is built on top of the design principles and patterns that we analyzed in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml"/><a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a>, <em>Interacting with Data in C# - Entity Framework Core</em>, <a href="a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml">Chapter 9</a>, <em>Design Patterns and .NET Core Implementation</em>, <a href="2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml">Chapter 10</a>, <em>Understanding the Different Domains in Software Solutions</em>, and <a href="4e308a45-a1ff-4a45-bea9-ba648b1e9ccd.xhtml">Chapter 11</a>, <em>Implementing Code Reusability in C# 8</em>.</p>
<p>All functionalities are provided through DI so that each of them can be replaced without affecting the remainder of the code. However, providers needed by ASP.NET Core pipeline modules are grouped into option objects instead of being added individually to the <span>DI</span> engine to conform to the SOLID Single Responsibility Principle.</p>
<p>Moreover, configuration data, instead of being available from a unique dictionary created from a configuration file, is organized into option objects thanks to the options framework we described in the first section of this chapter. This is an application of the SOLID Interface Segregation Principle.</p>
<p>However, ASP.NET Core <span>also </span>applies other patterns that are specific instances of the general Separation of Concerns principle, which is a generalization of the Single Responsibility Principle. They are as follows:</p>
<ul>
<li>The middleware modules architecture (ASP.NET Core pipeline)</li>
<li>Factoring out validation and globalization from the application code</li>
<li>The MVC pattern itself</li>
</ul>
<p>We will analyze all of these in the various subsections that follow.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of the ASP.NET Core pipeline</h1>
                </header>
            
            <article>
                
<p>The ASP.NET Core pipeline architecture has two important advantages:</p>
<ul>
<li>All different operations performed on the initial request are factored out into different modules, according to the Single Responsibility Principle.</li>
<li>The modules that perform these different operations don't need to call each other because each module is invoked once and for all by the ASP.NET Core framework. This way, the code for each module is not required to perform any action that is connected with responsibilities assigned to other modules.</li>
</ul>
<p>This ensures maximum independence of functionalities and simpler code. For instance, once authorization and authentication modules are on, no other module needs to worry about authorization anymore. Each controller code can focus on application-specific business stuff.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side and client-side validation</h1>
                </header>
            
            <article>
                
<p>Validation logic has been completely factored out from the application code and has been confined in the definition of validation attributes. The developer needs to <span>just </span>specify the validation rule to apply to each model property by decorating the property with an adequate validation attribute.</p>
<p>Validation rules are checked automatically when action method parameters are instantiated. Both errors and paths in the model (where they occurred) are then recorded in a dictionary that is contained in the <kbd>ModelState</kbd> controller property. The developer has the responsibility to verify whether there are errors by checking <kbd>ModelState.IsValid</kbd>, in which case the <span>developer</span> must return the same ViewModel to the same view so that the user can correct all errors.</p>
<p>Error messages are automatically shown in the view with no action required to the developer. The developer is only required to do the following:</p>
<ul>
<li>Add <kbd>span</kbd> or <kbd>div</kbd> with <kbd>data-valmsg-for attribute</kbd> next to each input field that will be automatically filled with the possible error.</li>
<li>Add <kbd>div</kbd> with an <kbd>asp-validation-summary</kbd> attribute that will be automatically filled with the validation error summary. See the <em>Tag helpers</em> topic for more details.</li>
</ul>
<p class="mce-root"/>
<p>It is enough to add some JavaScript references by invoking the <kbd>_ValidationScriptsPartial.cshtml</kbd> view <span>with the</span> <span><span><kbd>partial</kbd></span></span> <span>tag to enable the same validation rules also on the client-side, so that errors are shown to the user before the form is posted to the server. Some predefined validation attributes are contained in the <kbd>System.ComponentModel.DataAnnotations</kbd> and <kbd>Microsoft.AspNetCore.Mvc</kbd> namespaces and include the following attributes:</span></p>
<ul>
<li><span>The <kbd>Required</kbd> attribute requires the user to specify a value for the property that it decorates. An implicit <kbd>Required</kbd> attribute is automatically applied to all non-nullable properties such as all floats, integers, and decimals since they can't have a <kbd>null</kbd> value.</span></li>
<li><span>The <kbd>Range</kbd> attribute constrains numeric quantities within a range.</span></li>
<li><span>They also include attributes that constrain string lengths.</span></li>
</ul>
<p><span>Custom error messages can be inserted directly in the attributes, or attributes can refer to the property of resource types containing them.</span></p>
<p><span>The developer can define its custom attributes by providing the validation code both in C# and in JavaScript for client-side validation.<br/></span></p>
<p>Attribute-based validation can be replaced by other validation providers, such as fluent validation that defines validation rules for each type using a fluent interface. It is enough to change a provider in a collection contained in the MVC options object that can be configured through an action passed to the <kbd>services.AddControllersWithViews</kbd> method. MVC options are configured as shown here:</p>
<pre>services.AddControllersWithViews(o =&gt; {<br/>    ...<br/>    // code that modifies o properties<br/>});</pre>
<p>The validation framework automatically checks whether numeric and date inputs are well formatted according to the selected culture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ASP.NET Core globalization</h1>
                </header>
            
            <article>
                
<p>In multicultural applications, pages must be served according to the language and culture preferences of each user. Typically, multicultural applications can serve their content in a few languages, and they can handle dates and numeric formats in several more languages. In fact, while the content in all supported languages must be produced manually, .NET Core has the native capability of formatting and parsing dates and numbers in all cultures.</p>
<p class="mce-root"/>
<p>For instance, a web application might support unique content for all English-based cultures (en),  but all known English-based cultures for numbers and dates formats (en-US, en-GB, en-CA, and so on).</p>
<p>The culture used for numbers and dates in a .NET thread is contained in the <kbd>Thread.CurrentThread.CurrentCulture</kbd> property. Hence, by setting this property to <kbd>new CultureInfo("en-CA")</kbd>, numbers and dates will be formatted/parsed according to the Canadian culture. <span><kbd>Thread.CurrentThread.CurrentUICulture</kbd>, instead, decides the culture of the resource files, that is, it selects a culture-specific version of each resource file or view. Accordingly, a multicultural application is required to set the two cultures associated to the request thread and to organize multilingual content into language dependent resource files and/or views.</span></p>
<p>According to the Separation of Concerns principle, the whole logic used to set the request culture according to the user preferences is factored out into a specific module of the ASP.NET Core pipeline. To configure this module, as a first step, we set the supported date/numbers cultures, as in the following example:</p>
<pre>var supportedCultures = new[]<br/>{<br/><br/>   new CultureInfo("en-AU"),<br/>   new CultureInfo("en-GB"),<br/>   new CultureInfo("en"),<br/>   new CultureInfo("es-MX"),<br/>   new CultureInfo("es"),<br/>   new CultureInfo("fr-CA"),<br/>   new CultureInfo("fr"),<br/>   new CultureInfo("it-CH"),<br/>   new CultureInfo("it")<br/>};</pre>
<p>Then, we set the languages supported for the content. Usually, a version of the language that is not specific for any country is selected to keep the number of translations small enough, as shown here:</p>
<pre>var supportedUICultures = new[]<br/>{<br/>    new CultureInfo("en"),<br/>    new CultureInfo("es"),<br/>    new CultureInfo("fr"),<br/>    new CultureInfo("it")<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then, we add the culture middleware to the pipeline, as shown here:</p>
<pre>app.UseRequestLocalization(new RequestLocalizationOptions<br/>{<br/>     DefaultRequestCulture = new RequestCulture("en", "en"),<br/><br/>     // Formatting numbers, dates, etc.<br/>     SupportedCultures = supportedCultures,<br/>     // UI strings that we have localized.<br/>     SupportedUICultures = supportedUICultures,<br/>     FallBackToParentCultures = true,<br/>     FallBackToParentUICultures = true<br/>});</pre>
<p>If the culture requested by the user is explicitly found among the ones listed in <kbd>supportedCultures</kbd> or <kbd>supportedUICultures</kbd>, it is used without modifications. Otherwise, since <kbd>FallBackToParentCultures</kbd> and <kbd>FallBackToParentUICultures</kbd> are <kbd>true</kbd>, the parent culture is tried, that is, for instance, if the required <kbd>fr-FR</kbd> culture is not found among those listed, then the framework searches for its generic version, <kbd>fr</kbd>. If this attempt also fails, the framework uses the cultures specified in <kbd>DefaultRequestCulture</kbd>.</p>
<p>By default, the <kbd>culture</kbd> middleware searches the culture selected for the current user with three providers that are tried in the order shown here:</p>
<ol>
<li>The middleware looks for the <kbd>culture</kbd> and <kbd>ui-culture</kbd> query string parameters.</li>
<li>If the previous step fails, the middleware looks for a cookie named <kbd>.AspNetCore.Culture</kbd>, the value of which is expected to be as in this example: <kbd>c=en-US|uic=en</kbd>.</li>
<li>If both previous steps fail, the middleware looks for the <kbd>Accept-Language</kbd> request header sent by the browser, which can be changed in the browser settings, and that is initially set to the operating system culture.</li>
</ol>
<p>With the preceding strategy, the first time a user requests an application page, the browser culture is taken (the provider listed in <em>step 3</em>). Then, if the user clicks a language-change link with the right query string parameters, a new culture is selected by provider 1. Usually, after a language link is clicked, the server <span>also</span><span> </span><span>generates a language cookie to remember the user's choice through provider 2.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The simplest way to provide content localization is to provide a different view for each language. Hence, if we would like to localize the <kbd>Home.cshtml</kbd> view for different languages, we must provide views named <span><kbd>Home.en.cshtml</kbd>, <kbd>Home.es.cshtml</kbd>, and so on. If no view specific for the <kbd>ui-culture</kbd> thread is found, the not localized <kbd>Home.cshtml</kbd> version of the view is chosen.</span></p>
<p>View localization must be enabled by calling the <kbd>AddViewLocalization</kbd> method, as shown here:</p>
<pre>services.AddControllersWithViews()<br/>    .AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix)</pre>
<p>Another option is to store simple strings or HTML fragments in resource files specific for all supported<span> languages. The usage of resource files must be enabled by calling the <kbd>AddLocalization</kbd> method in the configure services section, as shown here:</span></p>
<pre>services.AddLocalization(options =&gt; <br/>    options.ResourcesPath = "Resources");</pre>
<p><kbd>ResourcesPath</kbd> is the root folder where all resource files will be placed. If it is not specified, the empty string is assumed, and resource files will be placed in the web application root. Resource files for a specific view, say the <kbd>/Views/Home/Index.cshtml</kbd> view, must have a path like this:</p>
<pre>&lt;ResourcesPath &gt;/Views/Home/Index.&lt;culture name&gt;.resx</pre>
<p>Hence, if <kbd>ResourcesPath</kbd> is empty, resources must have the <kbd>/Views/Home/Index.&lt;culture name&gt;.resx</kbd><span> </span><span>path</span><span>, that is, they must be placed in the same folder as the view.</span></p>
<p>Once key-value pairs to all resource files associated with a view are <span>added</span>, localized HTML fragments can be added to the view as follows:</p>
<ul>
<li>Inject <kbd>IViewLocalizer</kbd> in the view with <kbd>@inject IViewLocalizer Localizer</kbd>.</li>
<li>Where needed, replace the text in the View with accesses to the <kbd>Localizer</kbd> dictionary, such as <kbd>Localizer["myKey"]</kbd>, where <kbd>"myKey"</kbd> is a key used in the resource files.</li>
</ul>
<p>The following code shows an example of the <kbd>IViewLocalizer</kbd> dictionary:</p>
<pre>@{<br/>    ViewData["Title"] = Localizer["HomePageTitle"];<br/>}<br/>&lt;h2&gt;@ViewData["MyTitle"]&lt;/h2&gt;</pre>
<p>If localization fails because the key is not found in the resource file, the key itself is returned. Strings used in data annotation, such as validation attributes, are used as a key in resource files if data annotation localization is enabled, as shown here:</p>
<pre> services.AddControllersWithViews()<br/>    .AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix)<br/>    .AddDataAnnotationsLocalization();</pre>
<p>Resource files for data annotations applied to a class whose full name is, say, <kbd>MyWebApplication.ViewModels.Account.RegisterViewModel</kbd>, must have the following path:</p>
<pre>&lt;ResourcesPath &gt;/ViewModels/Account/RegisterViewModel.&lt;culture name&gt;.resx</pre>
<p>It is worth to point out that the first segment of the namespace that corresponds to the <kbd>.dll</kbd> <span>application </span>name is replaced by <kbd>ResourcePath</kbd>. If <kbd>ResourcesPath</kbd> is empty and if you use the default namespaces created by Visual Studio, then resource files must be placed in the same folder of the classes they are associated with.</p>
<p>It is possible to localize strings and HTML fragments in controllers or wherever dependencies can be injected by associating each group of resource files with a type, such as <kbd>MyType</kbd>, and then injecting either <kbd>IHtmlLocalizer&lt;<span>MyType</span>&gt;</kbd> for HTML fragments or <kbd>IStringLocalizer&lt;<span>MyType</span>&gt;</kbd> for strings that need to be HTML encoded.</p>
<p>Their usage is identical to the usage of <kbd>IViewLocalizer</kbd>. The path of the resource files associated with <kbd>MyType</kbd> is computed as in the case of data annotations. If you would like to use a unique group of resource files for the whole application, a common choice is to use the <kbd>Startup</kbd> class as the reference type (<kbd>IStringLocalizer&lt;Startup<span> </span>&gt;</kbd> and <kbd>IHtmlLocalizer&lt;Startup<span> </span>&gt;</kbd>). Another common choice is the creation of various empty classes to use as reference types for various groups of resource files.</p>
<p>After having learned how to manage globalization in your ASP.NET Core projects, in the next subsection, we can move to the description of the more important pattern used by ASP.NET Core MVC to enforce the <em>Separation of Concerns</em>, the MVC pattern itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MVC pattern</h1>
                </header>
            
            <article>
                
<p>MVC is a pattern for the implementation of presentation layers of a web application. The basic idea is to apply a <em>Separation of Concerns</em> between the logic of the presentation layer and its graphics. Logic is taken care of by controllers, while graphics are factored out into views. Controllers and views communicate through the model, which is often called the ViewModel to distinguish it from the models of the business and data layers</p>
<p>However, what is the logic of a presentation layer? In <a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml">Chapter 1</a>, <em>Understanding the Importance of Software Architecture</em>, we saw that software requirements can be documented with use cases that describe the interaction between the user and the system. Roughly, the logic of the presentation layer consists of the management of use cases, hence, roughly, use cases are mapped to controllers and every single operation of a use case is mapped to an action method of those controllers. Hence, controllers take care of managing the protocol of interaction with the user and rely on the business layer for any business processing involved during each operation. </p>
<p>Each action method receives data from the user, performs some business processing and, depending on the results of this processing, decides what to show to the user and encodes it in the ViewModel. <span>Views receive ViewModels that describe what to show to the user and decide the graphics to use, that is, HTML to use.</span></p>
<p><span>What are the advantages of separating logic and graphics <span>into two different components</span>? The main advantages are listed here:</span></p>
<ul>
<li><span>Changes in graphics do not affect the remainder of the code, so you can experiment with various <span>graphic </span>options to optimize the interaction with the user without putting the reliability of the remainder of the code at risk.</span></li>
<li>The application can be tested by instantiating controllers and passing the parameters, with no need to use testing tools that operate on the browser pages. In this way, tests are easier to implement. Moreover, they do not depend on the way graphics are implemented, so they do not need to be updated each time graphic changes.</li>
<li>It is easier to split the job between developers that implements controllers and graphic designers that implements views. Often, graphical designers have difficulties with Razor, so they might just furnish an example HTML page that developers transform into Razor views that operate on the actual data.</li>
</ul>
<p>Now, let's look at how to create a web app in ASP.NET Core MVC.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case – implementing a web app in ASP.NET Core MVC</h1>
                </header>
            
            <article>
                
<p>In this section, as an example of the ASP.NET Core application, we will implement the administrative panel for managing destinations and packages of the <kbd>WWTravelClub</kbd> book use case. The application will be implemented with the <strong>Domain-Driven Design</strong> (<strong>DDD</strong>) approach described in <a href="2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml">Chapter 10</a><span>, <em>Understanding the Different Domains in Software Solutions</em></span>, therefore, a good understanding of that chapter is a fundamental prerequisite for reading this section. The subsections that follow describe, the overall application specifications and organization and then the various application parts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining application specifications</h1>
                </header>
            
            <article>
                
<p>The destinations and packages have been described in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a>, <em>Interacting with Data in C# - Entity Framework Core</em>. Here, we will use exactly the same data model, with the necessary modifications to adapt it to the DDD approach. The administrative panel must allow packages, a destinations listing, and CRUD operations on them. To simplify the application, the two listings will be quite simple: the application will show all destinations sorted according to their names and all packages sorted starting from the ones with a higher-end validity date.</p>
<p>Moreover, we suppose the following things:</p>
<ul>
<li>The application that shows destinations and packages to the user shares the same database used by the administrative panel. Since only the administrative panel application needs to modify data, there will be just one write copy of the database with several read-only replicas.</li>
<li>Price modifications and package deletions are immediately used to update the user shopping carts. For this reason, the administrative application must send asynchronous communications about price changes and package removals. We will not implement the whole communication logic, but we will just add all such events to an event table, which should be used as input to a parallel thread in charge of sending these events to all relevant microservices.</li>
</ul>
<p>Here, we will give the full code for <span>just</span><span> </span><span>the package management, while most of the code for destination management is left as an exercise for the reader. The full code is available in the</span> <kbd>chapter 13</kbd> <span>folder of the GitHub repository associated with this book. In the remainder of the section, we will describe the application overall organization and we will discuss some relevant samples of code.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the application architecture</h1>
                </header>
            
            <article>
                
<p>The application is organized along with the guidelines described in <a href="2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml">Chapter 10</a><span>, </span><em>Understanding Different Domains in a Software Solution</em>, considering the DDD approach and using SOLID principles to map your domain sections. That is, the application is organized within three layers, each implemented as a different project:</p>
<ul>
<li>There's a data layer that contains repository implementation and classes describing database entities. It is a .NET Core library project. However, since it needs some HTTP stack interfaces and classes, we must add a reference not only to the .NET Core SDK but also to the ASP.NET Core SDK. This can be done as follows:
<ol>
<li>Right-click on the project icon in the solution explorer and select <span class="packt_screen">Edit project file</span>.</li>
<li>In the edit window, replace <kbd>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</kbd> with <kbd>&lt;Project Sdk="Microsoft.NET.Sdk.web"&gt;</kbd> and save.</li>
<li>Since, after this modification, Visual Studio automatically turns this library project into an application project, please right-click on the project again and select <span class="packt_screen">Properties</span>. In the project property window, replace <span class="packt_screen">Console Application</span> with <span class="packt_screen">Class Library</span> in <span>the</span> <span class="packt_screen">Output Type</span><span> drop-down list.</span></li>
</ol>
</li>
<li>There's also a domain layer that contains repository specifications, that is, interfaces that describe repository implementations and DDD aggregates. In our implementation, we decided to implement aggregates by hiding forbidden operations/properties of root data entities behind interfaces. Hence, for instance, the <kbd>Package</kbd> data layer class, which is an aggregate root, has a corresponding <kbd>IPackage</kbd> interface in the domain layer that hides all the property setters of the <kbd>Package</kbd> entity. The domain layer also contains the definitions of all the domain events, while the corresponding event handlers are defined in the application layer.</li>
<li>Finally, there's the application layer, that is, the ASP.NET Core MVC application, where we define DDD queries, commands, command handlers, and event handlers. Controllers fill query objects and execute them to get ViewModels they can pass to views. They update storage by filling command objects and executing their associated command handlers. In turn, command handlers use <kbd>IRepository</kbd> interfaces and <kbd>IUnitOfWork</kbd> coming from the domain layer to manage and coordinate transactions. </li>
</ul>
<p>The application uses the Query Command Segregation pattern; therefore, it uses command objects to modify the storage and the query object to query it.</p>
<p class="mce-root"/>
<p>The query is simple to use and implement: controllers fill their parameters and then call their execution methods. In turn, query objects have direct LINQ implementations that project results directly on the ViewModels used by the controller Views with <kbd>Select</kbd> LINQ methods. You may also decide to hide the LINQ implementation behind the same repository classes used for the storage update operations. </p>
<p>However, since repositories don't know anything about ViewModels, which is presentation layer stuff, in this case, you are forced to use intermediate objects defined in the domain layer (DTOs), which must then be copied into ViewModels. This would make the definition of new queries and the modification of existing queries time-consuming operations since you are forced to modify several classes. In any case, it is good practice to hide query objects behind interfaces so their implementations can be replaced by fake implementations when you test controllers.</p>
<p>The chain of objects and calls involved in the execution of commands, instead, is more complex since it requires the construction and modification of aggregates and the definition of the interaction between several aggregates and between aggregates and other applications through domain events.</p>
<p>The following diagram is a sketch of how storage update operations are performed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/021af0cc-d971-4a14-8e91-bc4bd5998063.png"/></p>
<ol>
<li>A controller's action method receives one or more ViewModels and performs validation.</li>
<li>One or more ViewModels containing changes to apply are hidden behind interfaces defined in the domain layer. They are used to fill the properties of a command object.</li>
</ol>
<ol start="3">
<li>A command handler matching the previous command is retrieved via <span>DI</span> in the controller action method (through the<kbd>[FromServices]</kbd> parameter attribute we described in the <em>Controllers and ViewModels</em> subsection). Then, the handler is executed.</li>
<li>When creating the command<span> handler discussed in <em>step 3</em>,</span> the ASP.NET Core <span>DI</span> engine automatically injects all parameters declared in its constructor. In particular, it injects all <kbd>IRepostory</kbd> implementations needed to perform all command handler transactions. The command handler performs its job by calling the methods of these <kbd>IRepository</kbd> implementations received in its constructor to build aggregates and to modify the built aggregates. Aggregates either represent already-existing entities or newly created ones. Handlers use the <kbd>IUnitOfWork</kbd> interface contained in each <kbd>IRepository</kbd>, and the concurrency exceptions returned by the data layer to organize their operations as<span> transactions</span>. It is worth pointing out that each aggregate has its own <kbd>IRepository</kbd>, and that the whole logic for updating each aggregate is defined in the aggregate itself and not in its associated <kbd>IRepository</kbd> to keep the code more modular.</li>
<li>Behind the scenes, in the data layer, <kbd>IRepository</kbd> implementations use Entity Framework to perform their job. Aggregates are implemented by root data entities hidden behind interfaces defined in the domain layer, while <kbd>IUnitOfWork</kbd> methods that handle transactions and that pass changes to the database are implemented with <kbd>DBContext</kbd> methods. In other words, <kbd>IUnitOfWork</kbd> is implemented with the application's <kbd>DBContext</kbd>.</li>
<li>Domain events are generated during each aggregate processing and added to the aggregates themselves by calling their <kbd>AddDomainEvent</kbd> methods. However, they are not triggered immediately. Usually, they are triggered at the end of all the aggregates' processing and before changes are passed to the database; however, this is not a general rule.</li>
<li>The application handles errors by throwing exceptions. A more efficient approach would be to define a request-scoped object in the dependency engine where each application subpart may add its errors as domain events. However, while this approach is more efficient, it increases the complexity of the code and the application development time.</li>
</ol>
<p>The Visual Studio solution is composed of three projects:</p>
<ul>
<li>There's a project containing the domain layer called <kbd>PackagesManagementDomain</kbd>, which is a standard 2.0 library.</li>
<li>There's a project containing the whole data layer called <kbd>PackagesManagementDB</kbd>, which is a .NET Core 3.0 library.</li>
<li>Finally, there's an ASP.NET Core MVC 3.0 project called <kbd>PackagesManagement</kbd> that contains both application and presentation layers. When you define this project, select <span class="packt_screen">no authentication</span>, otherwise the user database will be added directly to the ASP.NET Core MVC project instead of adding it to the database layer. We will add the user database manually in the data layer.</li>
</ul>
<p>Let's start by creating the <kbd>PackagesManagement</kbd> ASP.NET Core MVC project so that the whole solution has the same name as the ASP.NET Core MVC project. Then, let's add the other two library projects to the same solution.</p>
<p>Finally, let the ASP.NET Core MVC project reference both projects, while <kbd>PackagesManagementDB</kbd> references <kbd>PackagesManagementDomain</kbd>. We suggest you define your own projects and then copy the code of this book's GitHub repository into them as you progress through reading this section.</p>
<p>The next subsection describes the code of the <kbd>PackagesManagementDomain</kbd> data layer project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the domain layer</h1>
                </header>
            
            <article>
                
<p><span>Once the </span><kbd>PackagesManagementDomain</kbd><span> standard 2.0 library project is added to the solution, l</span>et's add a <kbd>Tools</kbd> folder to the project root. Then, let's place there all <span><kbd>DomainLayer</kbd></span> <span>tools contained in the code associated with <kbd>chapter 10</kbd>. Since the code contained in this folder uses data annotations and defines DI extension methods, we must also add references to the <kbd>System.ComponentModel.Annotations</kbd> and <kbd>Microsoft.Extensions.DependencyInjection</kbd> NuGet packages.</span></p>
<p>Then, we need an <kbd>Aggregates</kbd> folder containing all the aggregate definitions (remember, we implemented aggregates as interfaces), namely, <kbd>IDestination</kbd>, <kbd>IPackage</kbd>, and <kbd>IPackageEvent</kbd>. Here, <kbd>IPackageEvent</kbd> is the aggregate associated with the table where we will place events to be propagated to other applications.</p>
<p>As an example, let's analyze <kbd>IPackage</kbd>:</p>
<pre>public interface IPackage : IEntity&lt;int&gt;<br/>{<br/>    void FullUpdate(IPackageFullEditDTO o);<br/>    string Name { get; set; }<br/><br/>    string Description { get;}<br/>    decimal Price { get; set; }<br/>    int DuratioInDays { get; }<br/>    DateTime? StartValidityDate { get;}<br/>    DateTime? EndValidityDate { get; }<br/>    int DestinationId { get; }<br/>        <br/>} </pre>
<p>It contains the same properties of the <kbd>Package</kbd> entity, which we saw in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a><span>, <em>Interacting with Data in C# - Entity Framework Core</em></span>. The only differences are the following:</p>
<ul>
<li>It inherits from <kbd>IEntity&lt;int&gt;</kbd>, which furnishes all basic functionalities of aggregates.</li>
<li>It has no <kbd>Id</kbd> property since it is inherited from <kbd>IEntity&lt;int&gt;</kbd>.</li>
<li>All properties are read-only, and it has an <kbd>Update</kbd> method since all aggregates can only be modified through update operations defined in the user domain (in our case, the <kbd>Update</kbd> method)</li>
</ul>
<p>Now, let's also add a <kbd>DTOs</kbd> folder. Here, we place all interfaces used to pass updates to the aggregates. Such interfaces are implemented by the application layer ViewModels used to define such updates. In our case, it contains <kbd>IPackageFullEditDTO</kbd>, which we can use to update existing packages. If you would like to add the logic to manage destinations, you must define an analogous interface for the <kbd>IDestination</kbd> aggregate.</p>
<p>An <kbd>IRepository</kbd> folder contains all repository specifications, namely <kbd>IDestinationRepository</kbd>, <kbd>IPackageRepository</kbd>, and <kbd>IPackageEventRepository</kbd>. Here, <span><kbd>IPackageEventRepository</kbd> is the repository associated with the <kbd>IPackageEvent</kbd> aggregate. As an example, let's have a look at the <kbd>IPackageRepository</kbd> repository:</span></p>
<pre>public interface IPackageRepository: <br/>        IRepository&lt;IPackage&gt;<br/>{<br/>    Task&lt;IPackage&gt; Get(int id);<br/>    IPackage New();<br/>    Task&lt;IPackage&gt; Delete(int id);<br/>}</pre>
<p>Repositories always contain just a few methods since all business logic should be represented as aggregate methods, in our case, just the methods to create a new package, to retrieve an existing package, and to delete an existing package. The logic to modify an existing package is included in the <kbd>Update</kbd> method of <kbd>IPackage</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, as with all domain layer projects, <kbd>PackagesManagementDomain</kbd> contains an event folder with all domain event definitions. In our case, the folder is named <kbd>Events</kbd> and contains the package-deleted event and the price-changed event:</p>
<pre>public class PackageDeleteEvent: IEventNotification<br/>{<br/>    public PackageDeleteEvent(int id, long oldVersion)<br/>    {<br/>        PackageId = id;<br/>        OldVersion = oldVersion;<br/>    }<br/>    public int PackageId { get; private set; }<br/>    public long OldVersion { get; private set; }<br/>        <br/>}<br/>{<br/>    public class PackagePriceChangedEvent: IEventNotification<br/>    {<br/>        public PackagePriceChangedEvent(int id, decimal price, <br/>        long oldVersion, long newVersion)<br/>        {<br/>            PackageId = id;<br/>            NewPrice = price;<br/>            OldVersion = oldVersion;<br/>            NewVersion = newVersion;<br/>        }<br/>        public int PackageId { get; private set; }<br/>        public decimal NewPrice { get; private set; }<br/>        public long OldVersion { get; private set; }<br/>        public long NewVersion { get; private set; }<br/>    }<br/>}</pre>
<p>When an aggregate sends all its changes to another application, it must have a version property. The application that receives the changes uses this version property to apply all changes in the right order. An explicit version number is necessary because changes are sent asynchronously, so the order they are received may differ from the order they were sent. For this purpose, events that are used to publish changes outside of the application have both <kbd>OldVersion</kbd> (the version before the change) and <kbd>NewVersion</kbd> (the version after the change) properties. Events associated with delete events have no <kbd>NewVersion</kbd>, since after being deleted, an entity can't store any versions.</p>
<p>The next subsection explains how all interfaces defined in the domain layer are implemented in the data layer.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the data layer</h1>
                </header>
            
            <article>
                
<p>The data layer project contains references to the <kbd>Microsoft.AspNetCore.Identity.EntityFrameworkCore</kbd> and <kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd> NuGet packages, since we use Entity Framework Core with SQL server. It references <kbd>Microsoft.EntityFrameworkCore.Tools</kbd> and <kbd>Microsoft.EntityFrameworkCore.Design</kbd>, which is needed to generate database migrations, as explained in the <em>Entity Framework Core migrations</em> section of <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a><span>,</span> <em>Interacting with Data in C# - Entity Framework Core</em>.</p>
<p>We have a <kbd>Models</kbd> folder that contains all database entities. They are similar to the ones in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a><span>,</span> <em>Interacting with Data in C# - Entity Framework Core</em>. The only differences are as follows:</p>
<ul>
<li>They inherit from <kbd>Entity&lt;T&gt;</kbd>, which contains all basic features of aggregates. Please notice that inheriting from <kbd>Entity&lt;T&gt;</kbd> is only needed for aggregate roots; all other entities must be defined as explained in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a><span>,</span> <em>Interacting with Data in C# - Entity Framework Core</em>. In our example, all entities are aggregate roots.</li>
<li>They have no <kbd>Id</kbd> since it is inherited from <kbd>Entity&lt;T&gt;</kbd>.</li>
<li>Some of them have an <kbd>EntityVersion</kbd> property that is decorated with the <kbd>[ConcurrencyCheck]</kbd> attribute. It contains the entity version that is needed for sending property all entity changes to other applications. The <kbd>ConcurrencyCheck</kbd> attribute is needed to prevent concurrency errors while updating the entity version without suffering the performance penalty implied by a transaction.</li>
</ul>
<p>More specifically, when saving entity changes, if the value of a field marked with the <kbd>ConcurrencyCheck</kbd> attribute is different from the one that was read when the entity was loaded in memory, a concurrency exception is thrown to inform the calling method that someone else modified this value after the entity was read but before we attempted to save its changes. This way, the calling method can repeat the whole operation with the hope that, this time, no-one will write the same entity in the database during its execution.</p>
<p>It is worth analyzing the <kbd>Package</kbd> entity:</p>
<pre>public class Package: Entity&lt;int&gt;, IPackage<br/>{<br/>    public void FullUpdate(IPackageFullEditDTO o)<br/>    {<br/>        if (IsTransient())<br/>        {<br/>            Id = o.Id;<br/>            DestinationId = o.DestinationId;<br/>        }<br/>        else<br/>        {<br/>            if (o.Price != this.Price)<br/>                this.AddDomainEvent(new PackagePriceChangedEvent(<br/>                        Id, o.Price, EntityVersion, EntityVersion+1));<br/>        }<br/>        Name = o.Name;<br/>        Description = o.Description;<br/>        Price = o.Price;<br/>        DuratioInDays = o.DuratioInDays;<br/>        StartValidityDate = o.StartValidityDate;<br/>        EndValidityDate = o.EndValidityDate;<br/>    }<br/>    [MaxLength(128), Required]<br/>    public string Name { get; set; }<br/>    [MaxLength(128)]<br/>    public string Description { get; set; }<br/>    public decimal Price { get; set; }<br/>    public int DuratioInDays { get; set; }<br/>    public DateTime? StartValidityDate { get; set; }<br/>    public DateTime? EndValidityDate { get; set; }<br/>    public Destination MyDestination { get; set; }<br/>    [ConcurrencyCheck]<br/>    public long EntityVersion{ get; set; }<br/><br/>    public int DestinationId { get; set; }<br/>}</pre>
<p>The <kbd>FullUpdate</kbd> method is the only way to update the <kbd>IPackage</kbd> aggregate when the price changes add <kbd>PackagePriceChangedEvent</kbd> to the entity list of events.</p>
<p>The <kbd>MainDBContext.cs</kbd> file contains the data layer database context definition. It doesn't inherit from <kbd>DBContext</kbd> but from the following predefined context class:</p>
<pre>IdentityDbContext&lt;IdentityUser&lt;int&gt;, IdentityRole&lt;int&gt;, int&gt;</pre>
<p>This context defines the user's tables needed for the authentication. In our case, we opted for the <kbd>IdentityUser&lt;T&gt;</kbd> <span>standard </span>and the <kbd>IdentityRole&lt;S&gt;</kbd> respectively for users and roles and used integers for both the <kbd>T</kbd> and <kbd>S</kbd> Entity keys. However, we may also use classes that inherit from <kbd>IdentityUser</kbd> and <kbd>IdentityRole</kbd> and add then further properties.</p>
<p>In the <kbd>OnModelCreating</kbd> method, we must call <kbd>base.OnModelCreating(builder)</kbd> in order to apply the configuration defined in <kbd>IdentityDbContext</kbd>.</p>
<p class="mce-root"/>
<p><kbd>MainDBContext</kbd> implements <kbd>IUnitOfWork</kbd>. The following code shows the implementation of all methods that start, rollback, and commit a transaction:</p>
<pre>public async Task StartAsync()<br/>{<br/>    await Database.BeginTransactionAsync();<br/>}<br/><br/>public async Task CommitAsync()<br/>{<br/>    Database.CommitTransaction();<br/>}<br/><br/>public async Task RollbackAsync()<br/>{<br/>    Database.RollbackTransaction();<br/>}</pre>
<p>However, they are rarely used by command classes in a distributed environment since retrying the same operation until no concurrency exception is returned usually ensures better performance than transactions.</p>
<p>It is worth analyzing the implementation of the method that passes all changes applied to <kbd>DBContext</kbd> to the database:</p>
<pre>public async Task&lt;bool&gt; SaveEntitiesAsync()<br/>{ <br/>    try<br/>    {<br/>        return await SaveChangesAsync() &gt; 0;<br/>    }<br/>    catch (DbUpdateConcurrencyException ex)<br/>    {<br/>        foreach (var entry in ex.Entries)<br/>        {<br/><br/>            entry.State = EntityState.Detached; <br/>                         <br/>        }<br/>        throw ex;<br/>    }          <br/>}</pre>
<p>The preceding implementation just calls the <kbd>SaveChangesAsync DBContext</kbd> <span>context </span>method that saves all changes to the database, but then it intercepts all concurrency exceptions and detaches from the context all entities involved in the concurrency error. This way, next time a command retries the whole failed operation, their updated versions will be reloaded from the database. </p>
<p class="mce-root"/>
<p>The <kbd>Repositories</kbd> folder contains all repository implementations. It is worth analyzing the implementation of the <kbd>IPackageRepository.Delete</kbd> method:</p>
<pre>public async Task&lt;IPackage&gt; Delete(int id)<br/>{<br/>    var model = await Get(id);<br/>    if (model == null) return null;<br/>    context.Packages.Remove(model as Package);<br/>    model.AddDomainEvent(<br/>        new PackageDeleteEvent(<br/>            model.Id, (model as Package).EntityVersion));<br/>    return model;<br/>}</pre>
<p>It reads the entity from the database and formally removes it from the <kbd>Packages</kbd> dataset. This will force the entity to be deleted in the database when changes are saved to the database. Moreover, it adds <kbd>PackageDeleteEvent</kbd> to the aggregate list of events.</p>
<p>The <kbd>Extensions</kbd> folder contains the <kbd>DBExtensions</kbd> static class that, in turn, defines two extension methods to be added to the application <span>DI</span> engine and the ASP.NET Core pipeline <span>respectively</span>. Once added to the pipeline, these two methods will connect the database layer to the application layer.</p>
<p>The <kbd>IServiceCollection</kbd><span> extension</span> of <kbd>AddDbLayer</kbd> accepts (as its input parameters) the database connection string and the name of the <kbd>.dll</kbd> file that contains all migrations. Then, it does the following:</p>
<pre>services.AddDbContext&lt;MainDBContext&gt;(options =&gt;<br/>                options.UseSqlServer(connectionString, <br/>                b =&gt; b.MigrationsAssembly(migrationAssembly)));</pre>
<p>That is, it adds the database context to the <span>DI</span> engine and defines its options, namely, that it uses SQL Server, the database connection string, and the name of the <kbd>.dll</kbd> that contains all migrations.</p>
<p>Then, it does the following:</p>
<pre>services.AddIdentity&lt;IdentityUser&lt;int&gt;, IdentityRole&lt;int&gt;&gt;()<br/>                .AddEntityFrameworkStores&lt;MainDBContext&gt;()<br/>                .AddDefaultTokenProviders();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>That is, it adds and configures all the types needed to handle database-based authentication. In particular, it adds the <kbd>UserManager</kbd> and <kbd>RoleManager</kbd> types, which the application layer can use to manage users and roles. <kbd>AddDefaultTokenProviders</kbd> adds the provider that creates the authentication tokens using data contained in the database when users log in.</p>
<p>Finally, it discovers and adds to the <span>DI</span> engine all repository implementations by calling the <kbd>AddAllRepositories</kbd> method that is defined in the DDD tools we added to the domain layer project.</p>
<p>The <kbd>UseDBLayer</kbd> extension method ensures migrations are applied to the database by calling <kbd>context.Database.Migrate()</kbd> and then populates the database with some initial objects. In our case, it uses <kbd><span>RoleManager</span></kbd> and <kbd><span>UserManager</span></kbd> to create an administrative role and an initial administrator. Then, it creates some sample destinations and packages.</p>
<p>To create migrations, we must add the aforementioned extension methods to the ASP.NET Core MVC <kbd>Startup.cs</kbd> file, as shown here:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    ...<br/>    services.AddRazorPages();<br/>    services.AddDbLayer(<br/>        Configuration.GetConnectionString("DefaultConnection"),<br/>        "PackagesManagementDB");<br/><br/>___________________________<br/><br/>public void Configure(IApplicationBuilder app, <br/>    IWebHostEnvironment env, IServiceProvider serviceProvider)<br/>    ...<br/>    app.UseAuthentication();<br/>    app.UseAuthorization();<br/>    ...<br/>    app.UseDBLayer(serviceProvider);<br/>}</pre>
<p>Please be sure that both the authorization and authentication modules have been added to the ASP.NET Core pipeline, otherwise, the authentication/authorization engine will not work.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Then, we must add the connection string to the <kbd>appsettings.json</kbd> file, as shown here:</p>
<pre>{<br/>   "ConnectionStrings": {<br/>        "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=package-                                 management;Trusted_Connection=True;MultipleActiveResultSets=true"<br/>        <br/>    },<br/>    ...<br/>}</pre>
<p>Finally, let's add <kbd>Microsoft.EntityFrameworkCore.Design</kbd> to the ASP.NET Core project. </p>
<p>We are forced to configure all database stuff in the startup project because migration tools use the startup project <span>DI</span> engine to create and apply migrations.</p>
<p>At this point, let's open Visual Studio Package Manager Console and select <kbd>PackageManagementDB</kbd> as the default project and then launch the following command:</p>
<pre>Add-Migration Initial -Project PackagesManagementDB</pre>
<p>The preceding command will scaffold the first migration. We may apply it to the database with the <kbd>Update-Database</kbd> command. Please note that if you copy the project from GitHub, you don't need to scaffold migrations since they have already been created, but you <span>just</span><span> </span><span>need to update the database.</span></p>
<p>The next subsection describes the application layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the application layer</h1>
                </header>
            
            <article>
                
<p>As a first step, for simplicity, let's freeze the application culture to <kbd>en-US</kbd> by adding the code that follows to the ASP.NET Core pipeline:</p>
<pre>app.UseAuthorization();<br/><br/>// Code to add: configure the Localization middleware            <br/>var ci = new CultureInfo("en-US"); <br/>app.UseRequestLocalization(new RequestLocalizationOptions<br/>{<br/>    DefaultRequestCulture = new RequestCulture(ci),<br/>    SupportedCultures = new List&lt;CultureInfo&gt;<br/>    {<br/>        ci,<br/>    },<br/>     = new List&lt;CultureInfo&gt;<br/>    {<br/>        ci,<br/>    }<br/>});</pre>
<p>Then, let's create a <kbd>Tools</kbd> folder and place the <kbd>ApplicationLayer</kbd> code there, which you may find in the <kbd>chapter 10</kbd> code of the GitHub repository associated with this book. With these tools in place, we can add the code that automatically discovers and adds all queries, command handlers, and event handlers <span>to the DI engine,</span> as shown here:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    ...<br/>    ...<br/>    services.AddAllQueries(this.GetType().Assembly);<br/>    services.AddAllCommandHandlers(this.GetType().Assembly);<br/>    services.AddAllEventHandlers(this.GetType().Assembly);<br/>}</pre>
<p>Then, we must add a <kbd>Queries</kbd> folder to place all queries and their associated interfaces. As an example, let's have a look at the query that lists all packages:</p>
<pre>public class PackagesListQuery:IPackagesListQuery<br/>{<br/>    MainDBContext ctx;<br/>    public PackagesListQuery(MainDBContext ctx)<br/>    {<br/>        this.ctx = ctx;<br/>    }<br/>    public async Task&lt;IEnumerable&lt;PackageInfosViewModel&gt;&gt; GetAllPackages()<br/>    {<br/>        return await ctx.Packages.Select(m =&gt; new PackageInfosViewModel<br/>        {<br/>            StartValidityDate = m.StartValidityDate,<br/>            EndValidityDate = m.EndValidityDate,<br/>            Name = m.Name,<br/>            DuratioInDays = m.DuratioInDays,<br/>            Id = m.Id,<br/>            Price = m.Price,<br/>            DestinationName = m.MyDestination.Name,<br/>            DestinationId = m.DestinationId<br/>        })<br/>            .OrderByDescending(m=&gt; m.EndValidityDate)<br/>            .ToListAsync();<br/>    }<br/>}</pre>
<p>The query object is automatically injected in the application DB context. The <kbd>GetAllPackages</kbd> method uses LINQ to <span>project</span> <span>all of the required information into</span> <kbd>PackageInfosViewModel</kbd> <span>and sorts all results in descending order on the</span> <kbd>EndValidityDate</kbd> <span>property.</span></p>
<p><kbd>PackageInfosViewModel</kbd> is placed in the <kbd>Models</kbd> folder together with all other ViewModels. It is good practice to organize ViewModels in folders, by defining a different folder for each controller. It is worth analyzing the ViewModel used for editing packages:</p>
<pre>public class PackageFullEditViewModel: IPackageFullEditDTO<br/>    {<br/>        public PackageFullEditViewModel() { }<br/>        public PackageFullEditViewModel(IPackage o)<br/>        {<br/>            Id = o.Id;<br/>            DestinationId = o.DestinationId;<br/>            Name = o.Name;<br/>            Description = o.Description;<br/>            Price = o.Price;<br/>            DuratioInDays = o.DuratioInDays;<br/>            StartValidityDate = o.StartValidityDate;<br/>            EndValidityDate = o.EndValidityDate;<br/>        }<br/>        ...<br/>        ...</pre>
<p>It has a constructor that accepts an <kbd>IPackage</kbd> aggregate. This way, package data is copied into the ViewModel that is used to populate the edit view. It implements the <kbd>IPackageFullEditDTO</kbd> DTO interface defined in the domain layer. This way, it can be directly used to send <kbd>IPackage</kbd> updates to the domain layer.</p>
<p>All properties contain validation attributes that are automatically used by client-side and server-side validation engines. Each property contains a <kbd>Display</kbd> attribute that defines the label to give to the input field that will be used to edit the property. It is better to place the field labels in the ViewModels than placing them directly in the views since, this way, the same names are automatically used in all views that use the same ViewModel. The following code block lists all its properties:</p>
<pre>public int Id { get; set; }<br/>[StringLength(128, MinimumLength = 5), Required]<br/>[Display(Name = "name")]<br/>public string Name { get; set; }<br/>[Display(Name = "package infos")]<br/>[StringLength(128, MinimumLength = 10), Required]<br/>public string Description { get; set; }<br/>[Display(Name = "price")]<br/>[Range(0, 100000)]<br/>public decimal Price { get; set; }<br/>[Display(Name = "duration in days")]<br/>[Range(1, 90)]<br/>public int DuratioInDays { get; set; }<br/>[Display(Name = "available from"), Required]<br/>public DateTime? StartValidityDate { get; set; }<br/>[Display(Name = "available to"), Required]<br/>public DateTime? EndValidityDate { get; set; }<br/>[Display(Name = "destination")]<br/>public int DestinationId { get; set; }</pre>
<p>The <kbd>Commands</kbd> folder contains all commands. As an example, let's have a look at the command used to modify packages:</p>
<pre>public class UpdatePackageCommand: ICommand<br/>{<br/>    public UpdatePackageCommand(IPackageFullEditDTO updates)<br/>    {<br/>        Updates = updates;<br/>    }<br/>    public IPackageFullEditDTO Updates { get; private set; }<br/>}</pre>
<p>Its constructor must be invoked with an implementation of the <kbd>IPackageFullEditDTO</kbd> DTO interface, that, in our case, is the edit ViewModel we described before. Command handlers are placed in the <kbd>Handlers</kbd> folder. It is worth analyzing the command that updates packages:</p>
<pre>IPackageRepository repo;<br/>IEventMediator mediator;<br/>public UpdatePackageCommandHandler(IPackageRepository repo, IEventMediator mediator)<br/>{<br/>    this.repo = repo;<br/>    this.mediator = mediator;<br/>}</pre>
<p>Its constructor has automatically injected the <kbd>IPackageRepository</kbd> repository and an <kbd>IEventMediator</kbd> instance needed to triggers events handler. The following code also shows the implementation of the standard <kbd>HandleAsync</kbd> command handler method:</p>
<pre>public async Task HandleAsync(UpdatePackageCommand command)<br/>{<br/>    bool done = false;<br/>    IPackage model = null;<br/>    while (!done)<br/>    {<br/>        try<br/>        {<br/>            model = await repo.Get(command.Updates.Id);<br/>            if (model == null) return;<br/>            model.FullUpdate(command.Updates);<br/>            await mediator.TriggerEvents(model.DomainEvents);<br/>            await repo.UnitOfWork.SaveEntitiesAsync();<br/>            done = true;<br/>        }<br/>        catch (DbUpdateConcurrencyException)<br/>        {<br/><br/>        }<br/>    }<br/>}</pre>
<p>Command operations are repeated until no concurrency exception is returned. <kbd>HandleAsync</kbd> uses the repository to get an instance of the entity to modify. If the entity is not found (it has been deleted), the commands stop its execution. Otherwise, all changes are passed to the retrieved aggregate. Immediately after the update, all events contained in the aggregate are triggered. In particular, if the price has changed, the event handler associated with the price change is executed. The concurrency check ensures that the package version is updated properly (by incrementing its previous version number by 1) and that the price changed event is passed the right version numbers.</p>
<p>Also, event handlers are placed in the <kbd>Handlers</kbd> folder. As an example, let's have a look at the price changed event handler:</p>
<pre>public class PackagePriceChangedEventHandler :<br/>    IEventHandler&lt;PackagePriceChangedEvent&gt;<br/>{<br/>    IPackageEventRepository repo;<br/>    public PackagePriceChangedEventHandler(IPackageEventRepository repo)<br/>    {<br/>        this.repo = repo;<br/>    }<br/>    public async Task HandleAsync(PackagePriceChangedEvent ev)<br/>    {<br/>        repo.New(PackageEventType.CostChanged, ev.PackageId, <br/>            ev.OldVersion, ev.NewVersion, ev.NewPrice);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>The constructor has automatically injected t</span>he <kbd>IPackageEventRepository</kbd> repository that handles the database table with all events to send to other applications. The <kbd>HandleAsync</kbd> implementation simply calls the repository method that adds a new record to this table.</p>
<p>All records in the table handled by <kbd>IPackageEventRepository</kbd>, which can be retrieved and sent to all interested microservices by a parallel task defined in the <span>DI</span> engine with a call such as <kbd>services.AddHostedService&lt;MyHostedService&gt;();</kbd> as detailed in the <em>Using Generic Hosts</em> subsection of <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a><span>, </span><em>Applying Microservice Architecture to Your Enterprise Application</em>. However, this parallel task is not implemented in the GitHub code associated with this chapter.</p>
<p>The next subsection describes how controllers and views are designed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controllers and views</h1>
                </header>
            
            <article>
                
<p>We need to add two more controllers to the one automatically scaffolded by Visual Studio, namely, <kbd>AccountController</kbd>, which takes care of user login/logout and registration, and <kbd>ManagePackageController</kbd> to handle all package-related operations. It is enough to right-click on the <kbd>Controllers</kbd> folder and then select <span class="packt_screen">Add | Controller</span>. Then, choose the controller name and select the empty MVC controller to avoid that Visual Studio might scaffold code you don't need.</p>
<p>For simplicity, <kbd>AccountController</kbd> <span>just </span>has login and logout methods, so you can log in just with the initial administrator user. However, you can add further action methods that use the <kbd>UserManager</kbd> class to define, update, and delete users. The <kbd>UserManager</kbd> class can be provided through <span>DI</span>, as shown here:</p>
<pre>private readonly UserManager&lt;IdentityUser&lt;int&gt;&gt; _userManager;<br/>private readonly SignInManager&lt;IdentityUser&lt;int&gt;&gt; _signInManager;<br/><br/>public AccountController(<br/>    UserManager&lt;IdentityUser&lt;int&gt;&gt; userManager,<br/>    SignInManager&lt;IdentityUser&lt;int&gt;&gt; signInManager)<br/>{<br/>    _userManager = userManager;<br/>    _signInManager = signInManager;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>SignInManager</kbd> takes care of login/logout operations. The <kbd>Logout</kbd> action method is quite simple and is shown here:</p>
<pre>[HttpPost]<br/>public async Task&lt;IActionResult&gt; Logout()<br/>{<br/>    await _signInManager.SignOutAsync();<br/>    return RedirectToAction(nameof(HomeController.Index), "Home");<br/>}</pre>
<p>It just calls the <kbd>signInManager.SignOutAsync</kbd> method and then redirects the browser to the home page. To avoid it being called by clicking a link it is decorated with <kbd>HttpPost</kbd>, so it can only be invoked via a form submit.</p>
<p>Login instead requires two action methods. The first one is invoked via <kbd>Get</kbd> and shows the login form, where the user must place their username and password. It is shown here:</p>
<pre>[HttpGet]<br/>public async Task&lt;IActionResult&gt; Login(string returnUrl = null)<br/>{<br/>    ViewData["ReturnUrl"] = returnUrl;<br/>    return View();<br/>}</pre>
<p>It receives <kbd>returnUrl</kbd> as its parameter when the browser is automatically redirected to the login page by the authorization module. This happens when an unlogged user tries to access a protected page. <kbd>returnUrl</kbd> is stored in the <kbd>ViewState</kbd> dictionary that is passed to the login view. The form in the login view passes it back, together with the username and password, to the controller when it is submitted, as shown in this code:</p>
<pre>&lt;form asp-route-returnurl="@ViewData["ReturnUrl"]" method="post"&gt;<br/>...<br/>&lt;/form&gt;</pre>
<p>The form post is intercepted by an action method with the same <kbd>Login</kbd> name but decorated with the <kbd>[HttpPost]</kbd> attribute, as shown here:</p>
<pre>[ValidateAntiForgeryToken]        public async Task&lt;IActionResult&gt; Login(<br/>            LoginViewModel model,<br/>           string returnUrl = null)<br/>        {<br/>            ...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding method receives the <kbd>Login</kbd> model used by the login view together with the <kbd>returnUrl</kbd> query string parameter. The <kbd>ValidateAntiForgeryToken</kbd> attribute verifies a token (called an anti-forgery token) that MVC forms automatically add to a hidden field to prevent cross-site attacks.</p>
<p>As a first step, the action method logs the user out if they are already logged in:</p>
<pre>if (User.Identity.IsAuthenticated)<br/>{<br/>      await _signInManager.SignOutAsync();<br/>      return View(model);<br/>}</pre>
<p>Otherwise, it verifies whether there are validation errors, in which case, it shows the same view filled with the data of the ViewModel to let the user correct their errors:</p>
<pre>if (ModelState.IsValid)            <br/>{<br/>     ...<br/>}<br/>else<br/> // If we got this far, something failed, redisplay form<br/> return View(model);</pre>
<p>If the model is valid, <kbd>_signInManager</kbd> is used to log in the user:</p>
<pre>var result = await _signInManager.PasswordSignInAsync(<br/>    model.UserName, <br/>    model.Password, model.RememberMe, <br/>    lockoutOnFailure: false);</pre>
<p>If the result returned by the operation is successful, the action method redirects the browser to <kbd>returnUrl</kbd>, if not null, otherwise to the home page:</p>
<pre>if (result.Succeeded)<br/>{<br/>    if (!string.IsNullOrEmpty(returnUrl))<br/>        return LocalRedirect(returnUrl);<br/>    else<br/>        return RedirectToAction(nameof(HomeController.Index), "Home");<br/>}<br/>else<br/>{<br/>    ModelState.AddModelError(string.Empty, <br/>        "wrong username or password");<br/>    return View(model);<br/>}</pre>
<p class="mce-root"/>
<p>If, the login fails, it adds an error to <kbd>ModelState</kbd> and shows the same form to let the user try again.</p>
<p><kbd>ManagePackagesController</kbd> contains an <kbd>Index</kbd> method that shows all packages in table format: </p>
<pre>[HttpGet]<br/>public async Task&lt;IActionResult&gt; Index(<br/>    [FromServices]IPackagesListQuery query)<br/>{<br/> var results = await query.GetAllPackages();<br/> var vm = new PackagesListViewModel { Items = results };<br/> return View(vm);<br/>}</pre>
<p>This action method is injected into the proper query object by <span>DI</span>, invokes it, and inserts the resulting <kbd>IEnumerable</kbd> in the <kbd>Items</kbd> property of a <kbd>PackagesListViewModel</kbd> instance. It is a good practice to include <kbd>IEnumerables</kbd> in ViewModels, so if necessary, other properties can be added without modifying the existing view code. Results are shown in a Bootstrap 4 table since Bootstrap 4 CSS is automatically scaffolded by Visual Studio.</p>
<p>The result is shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/48ba7e1c-5f3d-487f-9bde-cc4e5097e872.png"/></p>
<p>The <span class="packt_screen">New package</span> link (it is shaped like a <span class="packt_screen">Bootstrap 4</span> button, but it is a link) invokes a controller <kbd>Create</kbd> action method, while the <span class="packt_screen">delete</span> and <span class="packt_screen">edit</span> links in each row invoke a <kbd>Delete</kbd> and <kbd>Edit</kbd> action method and pass them the ID of the package shown in the row. Here is the implementation of the two-row links:</p>
<pre>@foreach(var package in Model.Items)<br/>{<br/>&lt;tr&gt;<br/>    &lt;td&gt;<br/>        &lt;a asp-controller="ManagePackages"<br/>            asp-action="@nameof(ManagePackagesController.Delete)"<br/>            asp-route-id="@package.Id"&gt;<br/>            delete<br/>        &lt;/a&gt;<br/>    &lt;/td&gt;<br/>    &lt;td&gt;<br/>        &lt;a asp-controller="ManagePackages"<br/>            asp-action="@nameof(ManagePackagesController.Edit)"<br/>            asp-route-id="@package.Id"&gt;<br/>            edit<br/>        &lt;/a&gt;<br/>    &lt;/td&gt;<br/>    ...<br/>    ...</pre>
<p>It is worth describing the code of the <kbd>HttpGet</kbd> and <kbd>HttpPost</kbd> <kbd>Edit</kbd> action methods:</p>
<pre>[HttpGet]<br/>public async Task&lt;IActionResult&gt; Edit(<br/>    int id,<br/>    [FromServices] IPackageRepository repo)<br/>{<br/>    if (id == 0) return RedirectToAction(<br/>        nameof(ManagePackagesController.Index));<br/>    var aggregate = await repo.Get(id);<br/>    if (aggregate == null) return RedirectToAction(<br/>        nameof(ManagePackagesController.Index));<br/>    var vm = new PackageFullEditViewModel(aggregate);<br/>    return View(vm);<br/>}</pre>
<p>The <kbd>Edit</kbd> method of <kbd>HttpGet</kbd> uses <kbd>IPackageRepository</kbd> to retrieve the existing package. If the package is not found, that means it has been deleted by some other user, and the browser is redirected again to the list page to show the updated list of packages. Otherwise, the aggregate is passed to the <kbd>PackageFullEditViewModel</kbd> ViewModel that is rendered by the <kbd>Edit</kbd> view.</p>
<p class="mce-root">The view used to render the package must render <kbd>select</kbd> with all possible package destinations, so it needs an instance of the <kbd>IDestinationListQuery</kbd> query that was implemented to assist with the destination selection HTML logic. This query is injected directly in the view since it is a view responsibility to decide how to enable the user to select a destination. The code that injects the query and uses it is shown here:</p>
<pre>@inject PackagesManagement.Queries.IDestinationListQuery destinationsQuery<br/>@{<br/>    ViewData["Title"] = "Edit/Create package";<br/>    var allDestinations = <br/>        await destinationsQuery.AllDestinations();<br/>}</pre>
<p>The action method that processes the post of the view form is given here:</p>
<pre>[HttpPost]<br/>public async Task&lt;IActionResult&gt; Edit(<br/>    PackageFullEditViewModel vm,<br/>    [FromServices] ICommandHandler&lt;UpdatePackageCommand&gt; command)<br/>{<br/>    if (ModelState.IsValid)<br/>    {<br/>        await command.HandleAsync(new UpdatePackageCommand(vm));<br/>        return RedirectToAction(<br/>            nameof(ManagePackagesController.Index));<br/>    }<br/>    else<br/>        return View(vm);<br/>}</pre>
<p>If <kbd>ModelState</kbd> is valid, <kbd>UpdatePackageCommand</kbd> is created and its associated handler is invoked; otherwise, the View is displayed again to the user to enable them to correct all the errors.</p>
<p>The new links to the package list page and login page must be added to the main menu, which is in the <kbd>_Layout</kbd> view, as shown here:</p>
<pre>&lt;li class="nav-item"&gt;<br/>    &lt;a class="nav-link text-dark" <br/>        asp-controller="ManagePackages" <br/>            asp-action="Index"&gt;Manage packages&lt;/a&gt;<br/>&lt;/li&gt;<br/>@if (User.Identity.IsAuthenticated)<br/>{<br/>    &lt;li class="nav-item"&gt;<br/>        &lt;a class="nav-link text-dark"<br/>            href="javascript:document.getElementById('logoutForm').submit()"&gt;<br/>            Logout<br/>        &lt;/a&gt;<br/>    &lt;/li&gt;<br/>}<br/>else<br/>{<br/>    &lt;li class="nav-item"&gt;<br/>        &lt;a class="nav-link text-dark" <br/>            asp-controller="Account" asp-action="Login"&gt;Login&lt;/a&gt;<br/>    &lt;/li&gt;<br/>}</pre>
<p><kbd>logoutForm</kbd> is an empty form whose only purpose is to send a post to the <kbd>Logout</kbd> action method. It has been added at the end of the body, as shown here:</p>
<pre>@if (User.Identity.IsAuthenticated)<br/>{<br/>    &lt;form asp-area="" asp-controller="Account" <br/>            asp-action="Logout" method="post" <br/>            id="logoutForm" &gt;&lt;/form&gt;<br/>}</pre>
<p>Now, the application is ready! You can run it, log in, and start to manage packages. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we analyzed the ASP.NET Core pipeline and various modules that compose an ASP.NET Core MVC application in detail, such as authentication/authorization, the options framework, and routing. Then, we described how controllers and Views map requests to response HTML. We also analyzed all the improvements introduced in version 3.0.</p>
<p>Finally, we analyzed all the design patterns implemented in the ASP.NET Core MVC framework, and, in particular, the importance of the <span>Separation of Concerns principle </span>and how ASP.NET Core MVC implements it with the ASP.NET Core pipeline and in its validation and globalization modules. Finally, we focused in more detail on the importance of <span>Separation of Concerns</span> between the presentation layer logic and graphics and how the MVC pattern ensures it.</p>
<p><span>The next chapter discusses best practices that will help you to program safe, simple, and maintainable software. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET Core project? </li>
<li>Does the ASP.NET Core pipeline module need to inherit from a base class or implement some interface?</li>
<li>Is it true that a tag must have just one tag helper defined for it or an exception is thrown?</li>
</ol>
<ol start="4">
<li>Do you remember how to test in a controller if validation errors occurred?</li>
<li>What is the instruction in a layout view to include the output of the main view called?</li>
<li>How are secondary sections of the main view invoked in a layout view?</li>
<li>How does a controller invoke a view?</li>
<li>As a default, how many providers are installed in the globalization module?</li>
<li>Are ViewModels the only way for controllers to communicate with their invoked views?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>More details on the ASP.NET MVC framework are available in its official documentation at <a href="https://docs.microsoft.com/en-US/aspnet/core/">https://docs.microsoft.com/en-US/aspnet/core/.</a> More details on Razor syntax can be found at <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.0&amp;tabs=visual-studio">https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.0&amp;tabs=visual-studio</a>.</p>
<p>Documentation on the creation custom tag helpers that were not discussed in this chapter can be found at <a href="https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring">https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring</a>. Documentation on the creation of custom controller attributes can be found at <a href="https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters">https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters.</a></p>
<p>The definition of custom validation attributes is discussed in this article: <a href="https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/">https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/</a>.</p>
<p>For alternative approaches to the construction of presentation layers for web applications, the official documentation of Blazor is at<a href="https://dotnet.microsoft.com/apps/aspnet/web-apps/client"><span> </span>https://dotnet.microsoft.com/apps/aspnet/web-apps/client</a>. A good introduction to all the techniques and tools needed to implement a modern JavaScript-based Single Page Application is found in this book: <a href="https://www.packtpub.com/application-development/hands-typescript-c-and-net-core-developers">https://www.packtpub.com/application-development/hands-typescript-c-and-net-core-developers</a>, which describes TypeScript, advanced JavaScript features, WebPack, and the Angular SPA framework.</p>


            </article>

            
        </section>
    </body></html>