- en: Using WPF Standard Controls
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WPF标准控件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Using the `TextBlock` control to add plain text
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TextBlock` 控件添加纯文本
- en: Using `Label` to add other controls in text
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Label` 在文本中添加其他控件
- en: Providing a user option to input text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用户输入文本的选项
- en: Adding images in your application UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序UI中添加图像
- en: Working with ready-to-use 2D shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现成的2D形状一起工作
- en: Adding tooltips to show additional information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加工具提示以显示附加信息
- en: Adding a standard menu to the WPF application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向WPF应用程序添加标准菜单
- en: Providing extra functionalities using the context menu
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文菜单提供额外功能
- en: Adding user options with radio buttons and checkboxes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单选按钮和复选框添加用户选项
- en: Working with the progress bar control
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与进度条控件一起工作
- en: Using the `Slider` control to pick a numeric value
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Slider` 控件选择数值
- en: Using the calendar control in your application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用日历控件
- en: Listing items in a `ListBox` control
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ListBox` 控件中列出项目
- en: Providing options to select from a ComboBox
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供从ComboBox中选择选项
- en: Adding a status bar to your window
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向窗口添加状态栏
- en: Adding a toolbar panel to perform quick tasks
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向窗口添加工具栏面板以执行快速任务
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Every UI Framework must provide the standard controls to design the application
    UI and **Windows Presentation Foundation** (**WPF**) is one of them. WPF provides
    a set of standard controls and UI elements such as `TextBlock`, `TextBox`, `Button`,
    `Image`, various shapes, `ProgressBar`, `Slider`, various menus, `Toolbar`, `ListBox`,
    `ComboBox`, `DataGrid`, and more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UI框架都必须提供标准控件来设计应用程序UI，**Windows Presentation Foundation**（**WPF**）就是其中之一。WPF提供了一套标准控件和UI元素，例如
    `TextBlock`、`TextBox`、`Button`、`Image`、各种形状、`ProgressBar`、`Slider`、各种菜单、`Toolbar`、`ListBox`、`ComboBox`、`DataGrid`
    以及更多。
- en: 'As you can see from the following diagram, UI controls can be of two types—**ItemsControl**
    and **ContentControl**, which inherit from `Control` class. All the panels available
    in WPF share the same base class `Panel`. The `Control` and `Panel` class have
    the base **FrameworkElement**, which again inherits from the **UIElement**. It
    has the base class as the **DependencyObject** and the superbase as the **Object**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，UI控件可以分为两种类型——**ItemsControl** 和 **ContentControl**，它们继承自 `Control` 类。WPF中所有可用的面板都共享相同的基类
    `Panel`。`Control` 和 `Panel` 类都有基 **FrameworkElement**，它再次继承自 **UIElement**。它以
    **DependencyObject** 为基类，以 **Object** 为超基类：
- en: '![](img/e83d2e8a-1116-4709-be6b-2f19213d7589.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e83d2e8a-1116-4709-be6b-2f19213d7589.png)'
- en: Every control has some common set of properties exposed. This includes `FontFamily`,
    `FontSize`, `FontStyle`, `Foreground`, `Background`, `BorderBrush`, `BorderThickness`,
    and more. Every framework element exposes additional properties such as `Width`,
    `MaxWidth`, `MinWidth`, `ToolTip`, `Height`, `Name`, `Language`, `Margin`, and
    more. When using any element in the UI, you will use these common properties to
    set the UIElement's style and other parameters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控件都有一组常见的属性可供使用。这包括 `FontFamily`、`FontSize`、`FontStyle`、`Foreground`、`Background`、`BorderBrush`、`BorderThickness`
    以及更多。每个框架元素都公开了额外的属性，例如 `Width`、`MaxWidth`、`MinWidth`、`ToolTip`、`Height`、`Name`、`Language`、`Margin`
    以及更多。当在UI中使用任何元素时，您将使用这些常见属性来设置UIElement的样式和其他参数。
- en: Using the TextBlock control to add plain text
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `TextBlock` 控件添加纯文本
- en: The `TextBlock` control in WPF is a lightweight UI element, which is used to
    display text content to the screen. Almost everywhere, you will use this element
    in your application UI to display plain text in a single line or a multiline format.
    To add simple plain text, you can either write `<TextBlock Text="Text message"
    />` or `<TextBlock>Text message</TextBlock>` in your XAML page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中的 `TextBlock` 控件是一个轻量级UI元素，用于在屏幕上显示文本内容。几乎在应用程序UI的任何地方，你都会使用这个元素来显示单行或多行格式的纯文本。要添加简单的纯文本，你可以在XAML页面中写入
    `<TextBlock Text="Text message" />` 或 `<TextBlock>Text message</TextBlock>`。
- en: In this recipe, we will explore more about this UI element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将更深入地探索这个UI元素。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open your Visual Studio IDE, and create a new WPF project called
    `CH02.TextBlockDemo`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开您的 Visual Studio IDE，并创建一个名为 `CH02.TextBlockDemo` 的新 WPF 项目。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Now open the `MainWindow.xaml`, and follow these steps to add `TextBlock` control
    with various formatting options:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 `MainWindow.xaml`，按照以下步骤添加具有各种格式化选项的 `TextBlock` 控件：
- en: First, change the pre-existing `Grid` panel to a `StackPanel`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将现有的 `Grid` 面板更改为 `StackPanel`。
- en: 'Now add the following two `TextBlock` controls to it, which will have plain
    text in them:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向其中添加以下两个 `TextBlock` 控件，它们将包含纯文本：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following XAML to have a few more `TextBlock` controls, with some basic
    text formatting applied to them:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 XAML 以添加更多 `TextBlock` 控件，并对其应用一些基本的文本格式化：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's build the project and run it. You will see the following UI on the screen:![](img/b3cc071e-0e83-4da9-a642-65145fa8a9ec.png)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建项目并运行它。你将在屏幕上看到以下 UI：![图片](img/b3cc071e-0e83-4da9-a642-65145fa8a9ec.png)
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For the first two `TextBlock` controls, the UI will have a plain text on it.
    The third `TextBlock` control will have **Bold**, **Italic**, and **Underline**
    applied to it, by specifying the `FontWeight`, `FontStyle`, and `TextDecoration`
    properties of the control. Also, the foreground color of it has been set to *red*,
    by specifying the `Foreground` property.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两个 `TextBlock` 控件，UI 上将显示纯文本。第三个 `TextBlock` 控件将应用 **Bold**、**Italic** 和
    **Underline**，通过指定控件的 `FontWeight`、`FontStyle` 和 `TextDecoration` 属性来实现。此外，它的前景色已被设置为
    *红色*，通过指定 `Foreground` 属性。
- en: You can also set a different font to your `TextBlock` control. Use the `FontFamily`
    property to set it. As you can see, the fourth `TextBlock` control has a **Lucida
    Handwriting** font applied to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为 `TextBlock` 控件设置不同的字体。使用 `FontFamily` 属性来设置。正如你所见，第四个 `TextBlock` 控件应用了
    **Lucida Handwriting** 字体。
- en: When you have a long text, which is not viewable in a single line, you can either
    wrap it to multiline or trim it, based on the available space. `TextWrapping="Wrap"`,
    in the fifth `TextBlock` spans it to multiline. Try making the window bigger or
    smaller, and you will see that the `TextBlock` automatically adjusts itself to
    match the available space, whereas, the text of the sixth `TextBlock` control
    trims with the `TextTrimming` property set to character ellipsis (three dots at
    the end). This says that more text is available but it has been `cropped.`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个长文本，它不能在单行中查看时，你可以根据可用空间将其换行或截断。`TextWrapping="Wrap"` 在第五个 `TextBlock`
    中将其换行。尝试调整窗口的大小，你会看到 `TextBlock` 会自动调整以匹配可用空间，而第六个 `TextBlock` 控件的文本则通过将 `TextTrimming`
    属性设置为字符省略号（末尾的三个点）进行截断。这意味着还有更多文本可用，但它已经被 `裁剪`。
- en: As an alternative to `CharacterEllipsis`, you may use `WordEllipsis`, which
    will trim the text at the end of the last possible word, instead of the last possible
    character.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `CharacterEllipsis` 的替代，你可以使用 `WordEllipsis`，它将在最后一个可能的单词的末尾截断文本，而不是最后一个可能的字符。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `TextBlock` control also supports inline formatting. Just like HTML tags,
    you can surround a text content with `Bold`, `Italic`, and `Underline` tags to
    format it, as shown in the following XAML code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBlock` 控件也支持内联格式化。就像 HTML 标签一样，你可以用 `Bold`、`Italic` 和 `Underline` 标签包围文本内容来格式化它，如下面的
    XAML 代码所示：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also add a line break to a text content, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在文本内容中添加换行符，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following XAML code demonstrates how to add a hyperlink element to a `TextBlock`
    control that matches the style of your Windows theme:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 XAML 代码演示了如何向 `TextBlock` 控件添加一个匹配 Windows 主题风格的超链接元素：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `NavigateUri` property is used to define the URL that you wish to navigate
    to.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigateUri` 属性用于定义你希望导航到的 URL。'
- en: 'You can use the `Span` element to set the style of individual text content
    that includes font style, size, foreground color, and so on. It also allows you
    to specify other inline elements inside it. The `Run` element allows you to style
    a text content using all the available properties of the `Span` element. The following
    example demonstrates how easy it is to use the `Span` and `Run` elements inside
    a `TextBlock` control:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Span` 元素来设置单个文本内容的样式，包括字体样式、大小、前景色等。它还允许你在其中指定其他内联元素。`Run` 元素允许你使用 `Span`
    元素的全部可用属性来设置文本内容样式。以下示例演示了在 `TextBlock` 控件中使用 `Span` 和 `Run` 元素是多么简单：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Span` element may contain other inline elements, but a `Run` element can
    contain only plain text.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span` 元素可以包含其他内联元素，但 `Run` 元素只能包含纯文本。'
- en: 'Running the preceding example will result in the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例将产生以下输出：
- en: '![](img/ac786411-589f-4d00-a3dd-aeb3f4f9b488.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac786411-589f-4d00-a3dd-aeb3f4f9b488.png)'
- en: Using Label to add other controls in text
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签添加文本中的其他控件
- en: The `Label` control is another way of representing text in WPF application.
    It looks like what `TextBlock` control offers, but instead of having only text
    support, it can also host any kind of other controls. It exposes the `Content`
    property to host text and other controls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label` 控件是 WPF 应用程序中表示文本的另一种方式。它看起来像 `TextBlock` 控件提供的外观，但它不仅可以支持文本，还可以托管任何类型的其他控件。它公开了
    `Content` 属性以托管文本和其他控件。'
- en: In this recipe, we will explore how to use the `Label` control in a WPF.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何在 WPF 中使用 `Label` 控件。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this control, open Visual Studio to create an application
    based on the WPF project template and call it `CH02.LabelDemo`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用此控件，打开 Visual Studio 以创建基于 WPF 项目模板的应用程序，并将其命名为 `CH02.LabelDemo`。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the project gets created, follow these simple steps to add text in your
    application UI, using the `Label` control:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，请按照以下简单步骤使用 `Label` 控件在应用程序 UI 中添加文本：
- en: Open the `MainWindow.xaml` file to change the application UI.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件以更改应用程序 UI。
- en: 'Replace the existing `Grid` panel with the following XAML code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Grid` 面板替换为以下 XAML 代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now build and run the application. You will see the following output on the
    screen:![](img/c1e62b20-d3d3-47ca-8ed6-12bd94fed2ce.png)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序。你将在屏幕上看到以下输出：![](img/c1e62b20-d3d3-47ca-8ed6-12bd94fed2ce.png)
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first control added in the `StackPanel` is a very basic label, which has
    plain text as its `Content` property. The second `Label` control also contains
    plain text, but has various formatting (such as, `FontWeight`, `Foreground`, and
    `FontStyle`) applied to it to give it a bold, italic, and red color look to its
    style.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StackPanel` 中添加的第一个控件是一个非常基本的标签，其 `Content` 属性包含纯文本。第二个 `Label` 控件也包含纯文本，但对其应用了各种格式（例如，`FontWeight`、`Foreground`
    和 `FontStyle`），使其样式看起来加粗、斜体和红色。
- en: As the `Label` control derives from `System.Windows.Controls.ContentControl`,
    it also supports adding other controls to its content. The third label added to
    the UI is a little different than the previous two examples. It not only contains
    text, but also other controls, such as `StackPanel`, `TextBlock`, and a `Rectangle`,
    owing to its `Content` property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Label` 控件继承自 `System.Windows.Controls.ContentControl`，它也支持向其内容添加其他控件。添加到
    UI 的第三个标签与前面的两个示例略有不同。它不仅包含文本，还包含其他控件，如 `StackPanel`、`TextBlock` 和一个 `Rectangle`，这要归功于它的
    `Content` 属性。
- en: In the preceding example, for the third label, the `TextBlock` control is used
    to hold the actual text content, and `StackPanel` is used as a panel control to
    hold both the `TextBlock` and the `Rectangle`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，对于第三个标签，使用 `TextBlock` 控件来保存实际的文本内容，而 `StackPanel` 被用作面板控件来保存 `TextBlock`
    和 `Rectangle`。
- en: A point to remember is that `Label` is heavier than a `TextBlock`. So, when
    you need to render a plain text on the UI, prefer `TextBlock` only.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个点是 `Label` 比一个 `TextBlock` 更重。所以，当你需要在 UI 上渲染纯文本时，最好只使用 `TextBlock`。
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In Windows and other operating systems, it's a widespread practice to access
    the controls in a window by holding the *Alt* key and then pressing a character
    defined as its access key. For example, to open the File menu of any Windows application,
    we use *Alt* + *F*. Here, the character *F* is the access key, which gets invoked
    when we press *Alt*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 和其他操作系统中，通过按住 *Alt* 键然后按下一个定义为访问键的字符来访问窗口中的控件是一种普遍的做法。例如，要打开任何 Windows
    应用程序的文件菜单，我们使用 *Alt* + *F*。在这里，字符 *F* 是访问键，当我们按下 *Alt* 时会被调用。
- en: 'Let''s learn how to add an access key to labels in the WPF application, using
    the `Label` control. Create a new project called `CH02.LabelAccessKeyDemo`, open
    the `MainWindow.xaml` page, and replace the default `Grid` by a `StackPanel`.
    Now add two labels and two textboxes inside the `StackPanel`, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在 WPF 应用程序中使用 `Label` 控件给标签添加访问键。创建一个名为 `CH02.LabelAccessKeyDemo` 的新项目，打开
    `MainWindow.xaml` 页面，并将默认的 `Grid` 替换为 `StackPanel`。现在在 `StackPanel` 内添加两个标签和两个文本框，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now run the application. Press *Alt* + *U* to activate the access key for the
    first label, and place the focus on the `txbUsername` field. Press *Alt* + *P*
    to automatically focus on the `txbPassword` field:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序。按 *Alt* + *U* 激活第一个标签的访问键，并将焦点放在 `txbUsername` 字段上。按 *Alt* + *P* 自动将焦点放在
    `txbPassword` 字段上：
- en: '![](img/2e48a981-b8a1-4b6d-b84a-5c9a13596a5a.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e48a981-b8a1-4b6d-b84a-5c9a13596a5a.png)'
- en: The Windows Form application uses "`&`" as its access key specifier, but in
    the WPF application it's a little different, as it uses XML notation to create
    the UI. So, in the WPF application, if you want to add an access key specifier
    to labels, you need to specify `_` (underscore) before the character which you
    want to highlight.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Windows窗体应用程序使用"`&`"作为其访问键指定符，但在WPF应用程序中略有不同，因为它使用XML标记来创建UI。因此，在WPF应用程序中，如果你想向标签添加访问键指定符，你需要在想要突出显示的字符前指定`_`（下划线）。
- en: For example, adding `_` before the `U` in Username, activates the said label
    when *Alt* + *U* is pressed. It's a similar case for the Password field, in the
    preceding example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在用户名中的`U`前添加`_`，当按下*Alt* + *U*时激活该标签。前一个示例中的密码字段也是类似的情况。
- en: The frequently used practice is to use the first character that's not already
    used as an access key of another control. But, on a need basis, you can specify
    any character part of the label content.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的做法是使用尚未用作其他控件访问键的第一个字符作为访问键。但在需要的情况下，你可以指定标签内容中的任何字符。
- en: The `Target` property of the `Label` control passes the instruction to the designated
    control to activate automatically when the access key gets triggered by the user.
    The `ElementName` property, which is present in the binding (`Target="{Binding
    ElementName=txbPassword}"`), tells the name of the control where you want to send
    the activation instruction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`控件的`Target`属性将指令传递给指定的控件，当用户触发访问键时，该控件会自动激活。存在于绑定中的`ElementName`属性（`Target="{Binding
    ElementName=txbPassword}"`）告诉了你想发送激活指令的控件名称。'
- en: Providing a user option to input text
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供用户输入文本的选项
- en: The `TextBox` control in WPF is used to allow the user to input plain text in
    a single line or multiline format. A single-line textbox is the commonly used
    control for form inputs; whereas the multiline textbox is used like an editor.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中的`TextBox`控件用于允许用户以单行或多行格式输入纯文本。单行文本框是常用的表单输入控件；而多行文本框则用作编辑器。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE, and create a new project named `CH02.TextBoxDemo`,
    based on the WPF application template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Visual Studio IDE，创建一个名为`CH02.TextBoxDemo`的新项目，基于WPF应用程序模板。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the project gets created, follow the mentioned steps to play with some
    of the `TextBox` properties:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，按照以下步骤操作来尝试一些`TextBox`属性：
- en: Open the `MainWindow.xaml` page, and replace the default `Grid` with a `StackPanel`
    so that we can add the controls in a stacked fashion.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`页面，将默认的`Grid`替换为`StackPanel`，这样我们就可以以堆叠的方式添加控件。
- en: 'Now add five `TextBox` controls inside the `StackPanel`, and set various properties,
    as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`StackPanel`中添加五个`TextBox`控件，并设置以下各种属性：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the application so that it has the following UI on the screen:![](img/693d146f-aec0-4187-bd03-d11145e6e1ad.png)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，使其在屏幕上显示以下UI：![图片](img/693d146f-aec0-4187-bd03-d11145e6e1ad.png)
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first `TextBox` control, which we added to the `StackPanel`, is the simplest
    one, and when it is rendered in the UI, it contains empty text. The user can enter
    any plain text here. You can also specify text from code, by using the `Text`
    property, as shown in the second control.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`StackPanel`中的第一个`TextBox`控件是最简单的一个，当它在UI中渲染时，它包含空文本。用户可以在此处输入任何纯文本。你也可以通过使用`Text`属性从代码中指定文本，如第二个控件所示。
- en: You can also define a range of styles for the text of the `TextBox` control.
    As shown in the second control, we specified `FontSize`, `Foreground`, `FontWeight`.
    You can specify other properties too, as part of any control.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为`TextBox`控件的文本定义一系列样式。如第二个控件所示，我们指定了`FontSize`、`Foreground`、`FontWeight`。你也可以指定其他属性，作为任何控件的一部分。
- en: The third one is a `ReadOnly` textbox, which you can define by setting the `IsReadOnly`
    property value to `True`. When you want to disable a `TextBox`, set its `IsEnabled`
    property to `False`, as shown in the fourth example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个是一个`ReadOnly`文本框，你可以通过将`IsReadOnly`属性值设置为`True`来定义它。当你想要禁用`TextBox`时，将其`IsEnabled`属性设置为`False`，如第四个示例所示。
- en: The fifth example demonstrates how easy it is to define a multiline textbox.
    Just set its `AcceptsReturn` property to `True` and `TextWrapping` to `Wrap`.
    The control will behave like a multiline text editor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个示例演示了定义多行文本框有多简单。只需将其`AcceptsReturn`属性设置为`True`和`TextWrapping`设置为`Wrap`，控件就会像多行文本编辑器一样运行。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you are using `TextBox` as a multiline text-input control, don't forget
    to set its `VerticalScrollBarVisibility`. This will allow your user to scroll
    the text content. As shown in the last example, set it to `Auto` to make it enabled
    on demand, based on its content.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`TextBox`作为多行文本输入控件时，别忘了设置其`VerticalScrollBarVisibility`。这将允许用户滚动文本内容。正如最后一个示例所示，将其设置为`Auto`以根据其内容按需启用。
- en: Windows Clipboard support
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows剪贴板支持
- en: The `TextBox` control automatically supports the **Windows Clipboard**. Right-click
    on it to see the context menu pop up in the screen with common clipboard functions,
    such as Select all, Cut, Copy, and Paste. Along with these functions, it also
    supports the common keyboard shortcuts for clipboard operations, undo/redo, by
    default.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`控件自动支持**Windows剪贴板**。右键单击它，可以在屏幕上弹出带有常见剪贴板功能的上下文菜单，例如全选、剪切、复制和粘贴。除了这些功能外，它还默认支持剪贴板操作的常见键盘快捷键，如撤销/重做。'
- en: Adding spellcheck support
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加拼写检查支持
- en: 'The attached `SpellCheck.IsEnabled` property allows you to add spellcheck support
    to the `TextBox` control. Set it to `True` to enable it. Let''s add a multiline
    textbox in the UI with this feature enabled:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的`SpellCheck.IsEnabled`属性允许你向`TextBox`控件添加拼写检查支持。将其设置为`True`以启用它。让我们在UI中添加一个带有此功能的多行文本框：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now run the application to have a window with a multiline text-input field in
    the UI. Enter some text with some spelling mistakes. You will see that the wrongly
    spelled words get highlighted with red underline. Right-click on it to see a context
    menu, which suggests words from the dictionary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，你将在UI中看到一个带有多行文本输入字段的窗口。输入一些带有拼写错误的文本。你会看到拼写错误的单词被红色下划线突出显示。右键单击它，可以看到一个上下文菜单，其中建议来自词典的单词。
- en: 'As shown in the following screenshot, select the one that is best suited in
    this context:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，选择最适合此上下文的一个：
- en: '![](img/19d967d7-39fe-4348-8165-c31aa4f066fd.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19d967d7-39fe-4348-8165-c31aa4f066fd.png)'
- en: Adding images to your application UI
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向应用程序UI添加图片
- en: Images are used to create a UI that looks good, with a background, icons, and
    thumbnails, and they convey more information to the user. In WPF, the `Image`
    element is used to display images. Let's take a look at this.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图片用于创建具有背景、图标和缩略图的UI，并向用户传达更多信息。在WPF中，使用`Image`元素来显示图片。让我们看看这个。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with images in WPF, launch your Visual Studio IDE and create
    a WPF project called `CH02.ImageDemo`, and add an image called `demoImage.jpg`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用WPF中的图片，启动你的Visual Studio IDE，创建一个名为`CH02.ImageDemo`的WPF项目，并添加一个名为`demoImage.jpg`的图片。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s follow these steps to add images in the `MainWindow.xaml` page:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤在`MainWindow.xaml`页面中添加图片：
- en: Open the `MainWindow.xaml` page, and replace the existing `Grid` with a `StackPanel`.
    Set its `Orientation` property to `Horizontal` so that the items added to this
    panel stack themselves horizontally.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`页面，并将现有的`Grid`替换为`StackPanel`。将其`Orientation`属性设置为`Horizontal`，以便添加到该面板的项目水平堆叠。
- en: Add four images to the `StackPanel`, and set their `Source` property to `demoImage.jpg`,
    which is available within the project directory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四张图片添加到`StackPanel`中，并将它们的`Source`属性设置为`demoImage.jpg`，该图片位于项目目录中。
- en: Set the width and the height of each image to `100`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每张图片的宽度和高度设置为`100`。
- en: For the first image, set its `Stretch` property to `None`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一张图片，将其`Stretch`属性设置为`None`。
- en: For the second image, set its `Stretch` property to `Fill`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二张图片，将其`Stretch`属性设置为`Fill`。
- en: For the third and fourth images, set their `Stretch` property to `Uniform` and
    `UniformToFill`, respectively.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第三张和第四张图片，分别将它们的`Stretch`属性设置为`Uniform`和`UniformToFill`。
- en: 'Here''s the complete XAML code, to which you can refer:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是完整的XAML代码，你可以参考：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's build and run the application. You will see the following output in the
    application UI:![](img/3f2a1bb2-785d-412a-98fd-61b871504c94.png)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序。你将在应用程序UI中看到以下输出![图片](img/3f2a1bb2-785d-412a-98fd-61b871504c94.png)
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In XAML, the `Source` property of the `Image` control is the path of the image
    file that you want to display. When you access the same from code, it's a `BitmapImage`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中，`Image`控件的`Source`属性是你想要显示的图片文件的路径。当你从代码中访问它时，它是一个`BitmapImage`。
- en: The `Stretch` property of an image describes how it should be stretched to fill
    the destination. For the first image, that we set as `Stretch= "None"`, it preserves
    the original size of the image. When you set it as `Fill`, for the second image
    in the example, the content is resized to fill the destination dimensions without
    preserving its aspect ratio.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的`Stretch`属性描述了它应该如何拉伸以填充目标。对于第一个图像，我们将其设置为`Stretch="None"`，它保留了图像的原始大小。当您将其设置为`Fill`时，例如示例中的第二个图像，内容将调整大小以填充目标尺寸，而不保留其宽高比。
- en: For the third and fourth image, setting it to `Uniform` and `UniformToFill`,
    respectively, set its content resized to fit in the destination dimensions while
    preserving its native aspect ratio. But for the fourth case, if the aspect ratio
    of the destination image differs from the source, the source content is clipped
    to fit in the destination dimensions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三和第四个图像，分别将其设置为`Uniform`和`UniformToFill`，将内容调整大小以适应目标尺寸，同时保留其原始宽高比。但对于第四种情况，如果目标图像的宽高比与源图像不同，源内容将被裁剪以适应目标尺寸。
- en: The default value of the image `Stretch` property is `Uniform`. That means,
    when you add an image to the UI, by default, it sets its content resized to fit
    in the destination dimensions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图像`Stretch`属性的默认值是`Uniform`。这意味着，当您将图像添加到UI中时，默认情况下，它会将内容调整大小以适应目标尺寸。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also set an image in XAML by creating a `BitmapImage` instance and
    assigning it to its `Source` property. The `BitmapImage` instance exposes the
    `UriSource` property to set the image path. Here''s an example of how to set the
    image source in XAML, using the `BitmapImage` element:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过创建`BitmapImage`实例并将其分配给其`Source`属性来在XAML中设置图像。`BitmapImage`实例公开了`UriSource`属性来设置图像路径。以下是如何在XAML中使用`BitmapImage`元素设置图像源的示例：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also rotate an image by setting the `Rotation` property of `BitmapImage`.
    It contains four values `Rotate0`, `Rotate90`, `Rotate180`, and `Rotate270`. Here''s
    an example to demonstrate how to rotate an image by 180 degrees:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过设置`BitmapImage`的`Rotation`属性来旋转图像。它包含四个值：`Rotate0`、`Rotate90`、`Rotate180`和`Rotate270`。以下是一个如何将图像旋转180度的示例：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Additionally, you can also use the `StretchDirection` property of an `Image`
    control. The value indicates how the image is scaled. There are three values `UpOnly`,
    `DownOnly`, and `Both`. The content scales upward, downward, or in both directions,
    based on the size of the image content.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用`Image`控件中的`StretchDirection`属性。该值表示图像如何缩放。有三个值：`UpOnly`、`DownOnly`和`Both`。内容根据图像内容的大小向上、向下或双向缩放。
- en: Working with ready-to-use 2D shapes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现成的2D形状进行操作
- en: 'In WPF, a `Shape` is an `UIElement` that enables you to draw a 2D shape in
    your application. There are a couple of ready-to-use shapes already provided by
    WPF, and they are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，`Shape`是一个`UIElement`，它允许您在应用程序中绘制2D形状。WPF已经提供了一些现成的形状，如下所示：
- en: Rectangle
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Ellipse
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆
- en: Line
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直线
- en: Polyline
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形
- en: Polygon
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形
- en: Path
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径
- en: All of these `UIElements` expose some common properties to draw the shape. The
    `Stroke` and `StrokeThickness` properties describe the color and the thickness
    to draw the shape's outline. The `Fill` property describes the color used to decorate
    the interior of the shape.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`UIElements`都公开了一些共同属性来绘制形状。`Stroke`和`StrokeThickness`属性描述了绘制形状轮廓的颜色和厚度。`Fill`属性描述了用于装饰形状内部的颜色。
- en: In this recipe, we will learn how to create various shapes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何创建各种形状。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin with creating a new project. Open your Visual Studio, and create
    a WPF project called `CH02.ShapesDemo`. As we will be creating multiple shapes,
    we will be using the `UniformGrid` panel to host the shapes in this demonstration.
    You can learn more about this panel in the next chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的项目开始。打开您的Visual Studio，创建一个名为`CH02.ShapesDemo`的WPF项目。由于我们将创建多个形状，我们将使用`UniformGrid`面板来在本次演示中托管形状。您可以在下一章中了解更多关于此面板的信息。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create various shapes in your application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在您的应用程序中创建各种形状：
- en: Open your `MainWindow.xaml` file, and replace the existing `Grid` panel with
    `UniformGrid`. Set its maximum columns count to `3`, by setting its `Column` property.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的`MainWindow.xaml`文件，并将现有的`Grid`面板替换为`UniformGrid`。通过设置其`Column`属性，将其最大列数设置为`3`。
- en: 'Let''s add our first shape, a `Rectangle`. Add the following XAML code inside
    the `UniformGrid`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加第一个形状，一个`Rectangle`。在`UniformGrid`内添加以下XAML代码：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s add an `Ellipse`, which you can change to a circle by setting the
    same value to its `Height` and `Width` properties. Add the following code to create
    the ellipse:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个 `Ellipse`，你可以通过设置相同的值到其 `Height` 和 `Width` 属性来将其更改为一个圆。添加以下代码来创建椭圆：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To add a `Line` in the panel, add the following XAML:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板中添加 `Line`，请添加以下 XAML：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Polyline` is a series of connected straight lines. Add the following XAML
    to easily create a polyline shape, where the line is being drawn based on the
    data points provided in the `Points` property:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Polyline` 是一系列连接的直线。添加以下 XAML 以轻松创建多段线形状，其中线条是根据 `Points` 属性中提供的点绘制的：'
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, you can add a `Polygon` shape to the UI. Add the following code
    inside the `UniformGrid` to draw the shape:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，你可以在 UI 中添加 `Polygon` 形状。在 `UniformGrid` 内添加以下代码来绘制形状：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To add a `Path` shape control, add the following XAML code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加 `Path` 形状控件，请添加以下 XAML 代码：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now let's build your project and run the application. You will see the following
    shapes on the screen, as we have added the preceding code:![](img/ab6686d8-03b9-4a1d-a145-0a8b80cdd096.png)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建你的项目并运行应用程序。你将在屏幕上看到以下形状，因为我们已经添加了前面的代码！![图片](img/ab6686d8-03b9-4a1d-a145-0a8b80cdd096.png)
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A rectangular shape is being drawn by setting the `Height` and `Width` properties
    of the `Rectangle` class, along with the stroke color and the thickness of it.
    To create a square, you can use this shape by setting its dimension properly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 `Rectangle` 类的 `Height` 和 `Width` 属性以及其轮廓颜色和粗细来绘制矩形形状。要创建一个正方形，你可以通过设置其维度来使用此形状。
- en: In the second example, a circular shape has been drawn using the `Ellipse` control.
    It uses the same property sets to create the shape. To make it a complete circle,
    set its `Height` and `Width` to the same value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，使用 `Ellipse` 控件绘制了一个圆形形状。它使用相同的属性集来创建形状。要使其成为一个完整的圆，请将其 `Height` 和 `Width`
    设置为相同的值。
- en: If you want to draw a straight line in the UI, use the `Line` class. It exposes
    four properties to draw the line. Set the `X1` and `Y1` properties to mark the
    starting point; set `X2` and `Y2` properties to mark the ending point of the line.
    In the preceding example, a line has been drawn from the (`10`,`80`) coordinate
    point to the (`190`,`20`) coordinate point.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 UI 中绘制一条直线，请使用 `Line` 类。它公开了四个属性来绘制线条。将 `X1` 和 `Y1` 属性设置为标记起点；将 `X2` 和
    `Y2` 属性设置为标记线的终点。在上一个示例中，一条线从 (`10`,`80`) 坐标点绘制到 (`190`,`20`) 坐标点。
- en: In the fourth example, we have seen how to create a series of connected straight
    lines using the `Polyline` shape control. You need to set the (*X*, *Y*) coordinate
    points of the lines in its `Points` property. In the preceding example, it creates
    the shape connecting the following coordinate points (`10`,`60`), (`60`,`180`),
    (`100`,`20`), (`180`,`80`), and (`120`,`140`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个示例中，我们看到了如何使用 `Polyline` 形状控件创建一系列连接的直线。你需要设置线条的 (*X*, *Y*) 坐标点在其 `Points`
    属性中。在上一个示例中，它创建了连接以下坐标点 (`10`,`60`), (`60`,`180`), (`100`,`20`), (`180`,`80`),
    和 (`120`,`140`) 的形状。
- en: '`Polygon` also uses the same concept to draw a series of lines, but it completes
    the connected series of lines to draw a closed shape.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon` 也使用相同的概念来绘制一系列线条，但它将连接的线条系列完成以绘制一个封闭形状。'
- en: Using the `Path` control, in the sixth example, you can draw a series of connected
    lines and curves. The `Data` property is used to set the geometry that specifies
    the shape to be drawn. The data points always start with `M` to begin drawing
    the lines. In any part, if you want to create a curve, prefix the character `C`
    at that point.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Path` 控件，在第六个示例中，你可以绘制一系列连接的线条和曲线。`Data` 属性用于设置指定要绘制的形状的几何形状。数据点始终以 `M`
    开头，以开始绘制线条。在任何部分，如果你想创建一个曲线，在该点前缀字符 `C`。
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `PathGeometry` objects are used to draw lines, curves, arcs, and complex
    shapes. WPF provides two classes to describe the geometric paths using the mini
    language **Path Markup Syntax**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathGeometry` 对象用于绘制线条、曲线、弧和复杂形状。WPF 提供了两个类来使用迷你语言 **Path Markup Syntax**
    描述几何路径。'
- en: 'You can learn more about it here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多信息：
- en: '[http://bit.ly/path-markup-syntax](http://bit.ly/path-markup-syntax)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/path-markup-syntax](http://bit.ly/path-markup-syntax)'
- en: If you want to draw simple shapes, you can use the `EllipseGeometry`, `LineGeometry`,
    and `RectangleGeometry` objects. Composite geometries are created by `GeometryGroup`
    and to create combine geometries, use the `CombineGeometry`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要绘制简单的形状，你可以使用 `EllipseGeometry`、`LineGeometry` 和 `RectangleGeometry` 对象。复合几何形状是通过
    `GeometryGroup` 创建的，要创建组合几何形状，请使用 `CombineGeometry`。
- en: 'Let''s take the following example to demonstrate a complex path geometry using
    a `PathSegmentCollection` of three segments:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来演示使用三个段落的 `PathSegmentCollection` 的复杂路径几何形状：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The collection consists of one `ArcSegment` and two `BeizerSegments` to set
    the geometry points to draw the following shape, but you can also add additional
    segments, such as `LineSegment`, `PolyBeizerSegment`, `PolyLineSegment`, `PolyQuadraticBeizerSegment`,
    and `QuadraticBeizerSegment` to create a more complex path:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该集合包含一个 `ArcSegment` 和两个 `BeizerSegments`，用于设置绘制以下形状的几何点，但你也可以添加额外的段，例如 `LineSegment`、`PolyBeizerSegment`、`PolyLineSegment`、`PolyQuadraticBeizerSegment`
    和 `QuadraticBeizerSegment` 以创建更复杂的路径：
- en: '![](img/a66c8f25-8bc5-43b5-89da-aa953de19b19.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a66c8f25-8bc5-43b5-89da-aa953de19b19.png)'
- en: Note that all shapes are stretchable. You can use the `Stretch` property to
    define a shape's stretching behavior. If you set it to `None`, the `Shape` object
    will not be stretchable. If you set it to `Fill`, `Uniform`, or `UniformToFill`,
    the `Shape` content will be stretched to fill the space with or without preserving
    the aspect ratio.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有形状都是可拉伸的。你可以使用 `Stretch` 属性来定义形状的拉伸行为。如果你将其设置为 `None`，则 `Shape` 对象将不可拉伸。如果你将其设置为
    `Fill`、`Uniform` 或 `UniformToFill`，则 `Shape` 内容将被拉伸以填充空间，或者在不保留纵横比的情况下填充空间。
- en: Adding tooltips to show additional information
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具提示以显示附加信息
- en: Tooltips are used to show additional information about a specific control or
    a link when hovering your mouse over it. The `FrameworkElement` class exposes
    a property named `Tooltip`, which you can find on all the controls available in
    WPF.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示用于在鼠标悬停在特定控件或链接上时显示有关该控件或链接的附加信息。`FrameworkElement` 类公开了一个名为 `Tooltip` 的属性，你可以在
    WPF 中找到所有可用的控件。
- en: In this recipe, we will learn how to work with the tooltips in WPF. We will
    also cover how to design a tooltip using other controls.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在 WPF 中使用工具提示。我们还将介绍如何使用其他控件设计工具提示。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE and create a new WPF application project called
    `CH02.TooltipDemo`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Visual Studio IDE，创建一个名为 `CH02.TooltipDemo` 的新 WPF 应用程序项目。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open the `MainWindow.xaml` page, and then follow these steps to add simple
    tooltips to the UI:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，然后按照以下步骤添加简单的工具提示到 UI：
- en: First, replace the default `Grid` with a `StackPanel`, and set its `Orientation`
    property to `Horizontal` to have some horizontally stacked items.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将默认的 `Grid` 替换为 `StackPanel`，并将其 `Orientation` 属性设置为 `Horizontal` 以水平堆叠一些项目。
- en: 'Add three buttons to the `StackPanel`, and set their `ToolTip` property. To
    add a show duration of the tooltip, set its `ToolTipService.ShowDuration` attached
    property to a value in milliseconds. You can use the following XAML as a reference:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `StackPanel` 添加三个按钮，并设置它们的 `ToolTip` 属性。要添加工具提示的显示持续时间，请将其 `ToolTipService.ShowDuration`
    附加属性设置为毫秒值。以下 XAML 可以作为参考：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the application, and hover over the buttons to see the tooltip pop up on
    the screen, as shown in the following screenshot:![](img/8d2ddd15-8dd4-447a-8b81-f3a657b88836.png)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，并将鼠标悬停在按钮上以在屏幕上看到弹出的工具提示，如下面的截图所示![图片](img/8d2ddd15-8dd4-447a-8b81-f3a657b88836.png)
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ToolTip` property, when set in any WPF control, gets visible when you hover
    over the control. Apart from this, the `ToolTipService` class has a bunch of attached
    properties to help you set various behaviors of the tooltip.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolTip` 属性，当在任何 WPF 控件中设置时，当你悬停在控件上时变得可见。除此之外，`ToolTipService` 类有一系列附加属性来帮助你设置工具提示的各种行为。'
- en: Like the second example, as shown earlier, if you hover over the `Open` button,
    the `Tooltip` property will be visible on screen for 2 seconds. This is because
    we set the `ShowDuration` property of the `ToolTipService` to `2000` milliseconds
    (2 seconds).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的第二个示例，如果你将鼠标悬停在 `Open` 按钮上，屏幕上的 `Tooltip` 属性将可见 2 秒。这是因为我们将 `ToolTipService`
    的 `ShowDuration` 属性设置为 `2000` 毫秒（2 秒）。
- en: You can also use the `ToolTipService.ShowOnDisabled` property to show or hide
    a `Tooltip` on an element that is disabled. The `HasDropShadow` property of the
    class ensures whether the `Tooltip` will have a shadow on it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `ToolTipService.ShowOnDisabled` 属性来显示或隐藏一个禁用元素上的 `Tooltip`。该类中的 `HasDropShadow`
    属性确保 `Tooltip` 是否会有阴影。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: As the `ToolTip` property is of `object` type, you can assign anything to it,
    including various UI controls. Hence, it helps you to customize the UI of the
    tooltip with a much richer experience.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ToolTip` 属性是 `object` 类型，您可以将其分配给任何内容，包括各种 UI 控件。因此，它帮助您通过更丰富的体验来自定义工具提示的
    UI。
- en: 'Let''s modify the `Tooltip` property of the third button in the preceding example.
    Place a few `TextBlock` and `Border` controls in a `StackPanel` to design the
    UI, as shared in the following XAML code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改先前列出的示例中第三个按钮的 `Tooltip` 属性。在 `StackPanel` 中放置几个 `TextBlock` 和 `Border`
    控件来设计 UI，如下面的 XAML 代码片段所示：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you run the application, hover over the third button to see the customized
    UI of the tooltip for that button, as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，将鼠标悬停在第三个按钮上，可以看到该按钮定制的工具提示 UI，如下面的屏幕截图所示：
- en: '![](img/7fc67f6d-3aa2-4225-8c13-26b74a759b48.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fc67f6d-3aa2-4225-8c13-26b74a759b48.png)'
- en: The `ToolTipService` class also exposes a few additional properties, such as
    `HorizontalOffset` and `VerticalOffset` to position `Tooltip` in a specific position
    on the screen.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolTipService` 类还公开了一些额外的属性，例如 `HorizontalOffset` 和 `VerticalOffset`，用于在屏幕上的特定位置定位
    `Tooltip`。'
- en: Adding a standard menu to the WPF application
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标准菜单添加到 WPF 应用程序中
- en: One of the most common parts of WPF applications is the menu, as it gives various
    options within a very little space. WPF comes with a control named `Menu`, to
    hold items named `MenuItem`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 应用程序中最常见的部分之一是菜单，因为它在很小的空间内提供了各种选项。WPF 提供了一个名为 `Menu` 的控件来容纳名为 `MenuItem`
    的项。
- en: Let's learn more about this menu control and how to add it to Windows applications.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解这个菜单控件以及如何将其添加到 Windows 应用程序中。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio, and create a new WPF project called `CH02.MenuDemo`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 Visual Studio，创建一个名为 `CH02.MenuDemo` 的新 WPF 项目。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to add menus to your WPF application:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将菜单添加到您的 WPF 应用程序中：
- en: Open the `MainWindow.xaml` page, and replace the default `Grid` with a `DockPanel`.
    We will discuss more about this panel in the next chapter.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，并将默认的 `Grid` 替换为 `DockPanel`。我们将在下一章中更详细地讨论这个面板。
- en: Now add the `Menu` control inside the `DockPanel`. This will create the base
    to hold all the menu items.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将 `Menu` 控件添加到 `DockPanel` 内部。这将创建一个基础，用于容纳所有菜单项。
- en: 'You can then add root-level menu items and sub-menu items in a hierarchical
    fashion, as shown in the following code snippet:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以以分层的方式添加根级菜单项和子菜单项，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the application to see the following window containing the added menu items:![](img/87d60ca0-d2a4-4bad-94e6-b5de9b81b094.png)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序以查看包含添加的菜单项的以下窗口：![图片](img/87d60ca0-d2a4-4bad-94e6-b5de9b81b094.png)
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you add the first menu item under the `<Menu>` tag, it creates the root-level
    menu item; for example, File menu, Edit menu. Each root menu item can contain
    one or more hierarchical sub-menu items. In the preceding example, the File menu
    contains four sub-menu items.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 `<Menu>` 标签下添加第一个菜单项时，它将创建根级菜单项；例如，文件菜单，编辑菜单。每个根菜单项可以包含一个或多个分层子菜单项。在先前的示例中，文件菜单包含四个子菜单项。
- en: The header property of the `MenuItem` is used to add the label of each item.
    When you want to add a separator, you can do so by adding the `<Separator />`
    tag, as shown in the preceding example. A separator does not need any `Header`
    content.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItem` 的标题属性用于添加每个项目的标签。当您想添加分隔符时，可以通过添加 `<Separator />` 标签来实现，如先前的示例所示。分隔符不需要任何
    `Header` 内容。'
- en: There's more...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can further customize a menu entry to have an icon, a check-mark, a shortcut
    key, or a keyboard access specifier. Let's discuss each of them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步自定义菜单项，以包含图标、勾选标记、快捷键或键盘访问指定符。让我们讨论每个选项。
- en: Adding an access key to menus
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将访问键添加到菜单中
- en: It's a general practice to access application menus by holding the *Alt* key
    and then pressing the character defined as its access key. For example, to open
    the File menu of any Windows application, we use *Alt* + *F*, and to access the
    File | New menu, we use *Alt* + *F*, *N*. Here, the character *F* and *N* are
    used as access keys that are invoked when we press *Alt*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规做法，通过按住 *Alt* 键然后按定义为其访问键的字符来访问应用程序菜单。例如，要打开任何 Windows 应用程序的文件菜单，我们使用 *Alt*
    + *F*，要访问文件 | 新建菜单，我们使用 *Alt* + *F*，*N*。在这里，字符 *F* 和 *N* 被用作访问键，当我们按 *Alt* 时被调用。
- en: 'In the WPF application, you need to specify `_` (underscore) before the character
    you want to highlight as the access key. For example, adding `_` before the `F`
    in File menu header content activates the said menu when *Alt* + *F* is pressed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF应用程序中，您需要在要突出显示为访问键的字符之前指定下划线`_`。例如，在文件菜单标题内容中在`F`之前添加下划线`_`，当按下*Alt* +
    *F*时激活该菜单：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The frequently used practice is to use the first character that's not already
    used as an access key of another control. But, on a need basis, you can specify
    any character part of the label content.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的做法是使用尚未用作其他控件访问键的第一个字符作为访问键。但是，根据需要，您可以指定标签内容中的任何字符。
- en: Adding icons to menus
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图标添加到菜单
- en: You can add icons to menus to give a better look to the application's menu items.
    The `MenuItem` element contains a property named `Icon` to add an image icon or
    a Unicode character as an icon to it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向菜单添加图标，以使应用程序的菜单项看起来更好。`MenuItem`元素包含一个名为`Icon`的属性，可以将其添加为图像图标或Unicode字符作为图标。
- en: 'Let''s add a Unicode character to add an icon for the Open and Save menu items:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个Unicode字符，为打开和保存菜单项添加一个图标：
- en: '![](img/6bda3a86-7da1-4640-a4e6-db3e65fc6d4a.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6bda3a86-7da1-4640-a4e6-db3e65fc6d4a.png)'
- en: 'Run the application now to see the icons added to the said menus, as shown
    in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，查看已添加到相应菜单中的图标，如下截图所示：
- en: '![](img/5b0694bb-2137-483a-b028-5184ac645a9b.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/5b0694bb-2137-483a-b028-5184ac645a9b.png)'
- en: Adding checkable menu items
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加可复选菜单项
- en: You can add checkable menu items too. The WPF menu item exposes two properties
    to handle this. The `IsCheckable` property tells the menu item that it can handle
    check/uncheck options. When `IsCheckable` is set to `True`, it sets to the check/uncheck
    icon on an alternate click of that menu item.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以添加可复选菜单项。WPF菜单项公开了两个属性来处理此功能。`IsCheckable`属性告诉菜单项它可以处理勾选/取消勾选选项。当`IsCheckable`设置为`True`时，它会在该菜单项的交替单击上设置勾选/取消勾选图标。
- en: 'You can also programmatically check/uncheck a menu item. Set its `IsChecked`
    property to `True` or `False`. Make sure to set `IsCheckable="True"`. Let''s add
    the following menu item, under the Edit menu:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过编程方式勾选/取消勾选菜单项。将其`IsChecked`属性设置为`True`或`False`。确保设置`IsCheckable="True"`。让我们在编辑菜单下添加以下菜单项：
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding click-event handlers to menus
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将点击事件处理程序添加到菜单
- en: 'Menus are not just to add to the application; you need to perform some actions
    on the menu with a click by adding the `Click` event handler, as shown in the
    following code snippet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单不仅仅是添加到应用程序；您需要通过添加`Click`事件处理程序在菜单上执行一些操作，如下所示代码片段：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the code behind, implement the handler, as shown in the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码背后实现处理程序，如下所示：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will first show a message box and then exit the application when the user
    clicks on the Exit menu item.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击退出菜单项时，这将首先显示一个消息框，然后退出应用程序。
- en: Providing extra functionalities using the context menu
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文菜单提供额外功能
- en: The context menu provides a vital role in any Windows applications offering
    additional functionalities to the user, within that context. This is often done
    relevant to a single control or a window.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文菜单在提供额外功能的任何Windows应用程序中都发挥着至关重要的作用，这些功能与上下文相关。这通常与单个控件或窗口相关。
- en: When you right-click on a control or a window, you can provide a popup context
    menu to the user, to perform single-click actions. WPF provides a `ContextMenu`
    property to all framework elements to hold a `ContextMenu`, having hierarchical
    `MenuItems`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在控件或窗口上右键单击时，您可以向用户提供一个弹出上下文菜单，以执行单击操作。WPF为所有框架元素提供了一个`ContextMenu`属性，以持有具有分层`MenuItems`的`ContextMenu`。
- en: Consider this recipe to learn more about adding a context menu in your WPF application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考此配方以了解如何在您的WPF应用程序中添加上下文菜单。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project named `CH02.ContextMenuDemo`, using the WPF application
    project template of Visual Studio.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio的WPF应用程序项目模板创建一个名为`CH02.ContextMenuDemo`的新项目。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to add a context menu to a `TextBlock` control. The same
    steps can be followed to add a context menu to any of the controls inheriting
    `FrameworkElement`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将上下文菜单添加到`TextBlock`控件。相同的步骤也可以用于将上下文菜单添加到继承自`FrameworkElement`的任何控件：
- en: Open the `MainWindow.xaml` file to modify the application UI.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件以修改应用程序UI。
- en: 'Replace the entire `Grid` block with the following XAML code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个`Grid`块替换为以下XAML代码：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the application. You will see a text saying Right-click on me to open Context
    Menu!.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将看到一个文本，提示您右键单击以打开上下文菜单！。
- en: Right-click on the window. You will see the following context menu pop up on
    the screen:![](img/c711319d-e3e4-4b76-8f6f-ac764520cb7f.png)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击窗口。你将在屏幕上看到以下上下文菜单弹出![img/c711319d-e3e4-4b76-8f6f-ac764520cb7f.png]
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you see from the preceding example, each `FrameworkElement` exposes a property
    named `ContextMenu`, which can hold a `ContextMenu` item. Just like the menu,
    as we learnt in the previous recipe, the context menu can also hold multiple items
    as `MenuItem`, and each menu item can again hold one or more menu items to make
    the context menu hierarchical.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，每个 `FrameworkElement` 都公开了一个名为 `ContextMenu` 的属性，它可以包含一个 `ContextMenu`
    项。就像我们在前面的菜谱中学到的菜单一样，上下文菜单也可以包含多个项作为 `MenuItem`，并且每个菜单项又可以包含一个或多个菜单项以使上下文菜单具有层次结构。
- en: Labels of menu items are assigned by setting its `Header` property. You can
    also set icons for each menu item, by assigning an image or a Unicode character
    to its `Icon` property. If you have binded a command to the menu, you can assign
    the shortcut key text as `InputGestureText` property.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项的标签是通过设置其 `Header` 属性来分配的。你还可以为每个菜单项设置图标，通过将其 `Icon` 属性分配给图像或 Unicode 字符。如果你已将命令绑定到菜单，则可以将快捷键文本分配为
    `InputGestureText` 属性。
- en: Additionally, you can create checkable context menu items. As shown in the Menu
    item 3, you can set the `IsCheckable` property to `True`, to make the menu checkable.
    Then you can use the `IsCheck` property to show/hide the check mark on it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以创建可勾选的上下文菜单项。如图菜单项 3 所示，你可以将 `IsCheckable` 属性设置为 `True`，使菜单可勾选。然后你可以使用
    `IsCheck` 属性来显示/隐藏其上的勾选标记。
- en: To add a separator between a group of context menu items, you can use the `<Separator
    />` tag, as shown in the preceding example.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一系列上下文菜单项之间添加分隔符，你可以使用 `<Separator />` 标签，如前例所示。
- en: Adding user options with radio buttons and checkboxes
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单选按钮和复选框添加用户选项
- en: Radio buttons and check boxes have a vital role in Windows Application Development.
    They are mostly used to provide the user an option to select from a group of items.
    Radio buttons allow you to select one from a group of options, whereas a checkbox
    allows you to toggle an option.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮和复选框在 Windows 应用程序开发中起着至关重要的作用。它们主要用于向用户提供从一组项目中选择选项的功能。单选按钮允许你从一组选项中选择一个，而复选框允许你切换选项。
- en: In this recipe, we will learn how to use `RadioButton` and `CheckBox` controls
    in the WPF application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在 WPF 应用程序中使用 `RadioButton` 和 `CheckBox` 控件。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open your Visual Studio IDE, and create a new project named
    `CH02.OptionSelectorsDemo`. Make sure you select the WPF application project template.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开你的 Visual Studio IDE，并创建一个名为 `CH02.OptionSelectorsDemo` 的新项目。确保你选择 WPF
    应用程序项目模板。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the `MainWindow.xaml` page, and follow these steps to add a set of radio
    buttons and checkbox controls to it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，按照以下步骤向其中添加一组单选按钮和复选框控件：
- en: First, replace the default `Grid` panel with a `StackPanel` to hold items stacked
    vertically.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将默认的 `Grid` 面板替换为 `StackPanel` 以垂直堆叠项目。
- en: 'Now add the following `StackPanel` with a set of radio buttons with a `GroupName="rdoGroup1"`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加以下具有一组单选按钮的 `StackPanel`，其 `GroupName="rdoGroup1"`：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add another set of radios, with the `GroupName="rdoGroup2"`, in a horizontally
    placed `StackPanel`, and add it to the root `StackPanel`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在水平放置的 `StackPanel` 中添加另一组单选按钮，其 `GroupName="rdoGroup2"`，并将其添加到根 `StackPanel`：
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now place the following `CheckBox` controls in a horizontal `StackPanel` and
    add it to the root:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下 `CheckBox` 控件放置在水平 `StackPanel` 中，并将其添加到根：
- en: '[PRE30]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the application, which will give you the following output on screen:![](img/34fdcd90-9735-4fe5-9315-6f5121fdd8ce.png)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，屏幕上将显示以下输出![img/34fdcd90-9735-4fe5-9315-6f5121fdd8ce.png]
- en: Select a few of the radio and checkbox controls to feel the behavior.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择几个单选按钮和复选框控件来感受其行为。
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first set of radio button controls are placed in a group with the same name
    `rdoGroup1`. When a group name is set to a set of radio buttons, the selection
    follows that. The first radio button in that group is by default selected, by
    setting its `IsChecked` property to `True`. If you select any other radio button
    within that group, the previous selection resets to unchecked status.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组单选按钮控件放置在与同一名称 `rdoGroup1` 的组中。当组名称设置为单选按钮的一组时，选择将遵循该组。该组中的第一个单选按钮默认选中，通过将其
    `IsChecked` 属性设置为 `True`。如果你选择该组中的任何其他单选按钮，则之前的选中状态将重置为未选中状态。
- en: The same is true for the second group too, but selection of one group does not
    affect the other group. So, when you check one radio button from the first group,
    it will not uncheck the radio buttons from the other group.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组也是如此，但选择一个组不会影响另一个组。因此，当你从第一组检查一个单选按钮时，它不会取消选中另一组的单选按钮。
- en: This is not the same for `CheckBox` controls. `Checkbox` controls allow you
    to have many checked items. When you select a checkbox, it can just toggle from
    one state to another.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复选框控件来说，情况并非如此。复选框控件允许你拥有多个选中的项。当你选择一个复选框时，它可以从一个状态切换到另一个状态。
- en: Both the radio button and checkbox control expose the `IsChecked` property to
    return a Boolean value to tell whether the control is checked or unchecked.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮和复选框控件都暴露了`IsChecked`属性，以返回一个布尔值来指示控件是被选中还是未选中。
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To disable the radio button or the checkbox control, set its `IsEnabled` property
    to `False`. Both the controls expose two events—`Checked` and `Unchecked`. When
    you register the events, the `Checked` event of the control will trigger when
    you check that. Similarly, the `Unchecked` event will trigger when you uncheck
    that.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用单选按钮或复选框控件，将其`IsEnabled`属性设置为`False`。这两个控件都暴露了两个事件——`Checked`和`Unchecked`。当你注册这些事件时，当检查该控件时，控件的`Checked`事件将被触发。同样，当取消选中该控件时，`Unchecked`事件将被触发。
- en: Working with the progress bar control
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与进度条控件一起工作
- en: When you perform a lengthy task in the background, you probably would like to
    add a progress indicator in your application UI to give a visual indication that
    some work is in progress. WPF provides us with a control name, `ProgressBar`,
    to show a percentage value of the work between 0% to 100%, in general.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在后台执行长时间任务时，你可能想在应用程序UI中添加一个进度指示器，以提供一些工作正在进行中的视觉指示。WPF为我们提供了一个名为`ProgressBar`的控件，以显示0%到100%之间的工作百分比，通常是。
- en: In this recipe, we will learn about the progress bar control and its various
    properties.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解进度条控件及其各种属性。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's open the Visual Studio and create a new WPF application project. Name
    it `CH02.ProgressBarDemo`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Visual Studio并创建一个新的WPF应用程序项目。将其命名为`CH02.ProgressBarDemo`。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the project gets created, follow these steps to add a progress indicator
    to the application''s UI:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，请按照以下步骤将进度指示器添加到应用程序的UI中：
- en: Open the `MainWindow.xaml`, and replace the existing `Grid` panel with a `StackPanel`,
    so that, we can add our controls stacked vertically.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`，并将现有的`Grid`面板替换为`StackPanel`，这样我们就可以垂直堆叠添加我们的控件。
- en: 'As shown in the following code snippet, add three `ProgressBar` controls in
    the `StackPanel`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，在`StackPanel`中添加三个`ProgressBar`控件：
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Set the `Minimum` and `Maximum` properties of both the three controls to `0`
    (zero) and `100` (hundred) respectively.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个控件的`Minimum`和`Maximum`属性分别设置为`0`（零）和`100`（百）。
- en: As shared in the preceding XAML code snippet, set the `Value` of the first progress
    bar to `20`, and the second progress bar to `70`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前述XAML代码片段所示，将第一个进度条的`Value`设置为`20`，第二个进度条的`Value`设置为`70`。
- en: Set the `IsIndeterminate` property of the third progress bar to `True`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第三个进度条的`IsIndeterminate`属性设置为`True`。
- en: Now run the application. You will see the following output for the XAML code
    we shared earlier:![](img/e4d047ef-e99a-4c8e-8021-b1abe517703d.png)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。你将看到我们之前分享的XAML代码的以下输出！![图片](img/e4d047ef-e99a-4c8e-8021-b1abe517703d.png)
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The value of the first progress indicator is set to `20`, whereas the second
    progress indicator is set to `70`. This denotes that the 20% and 70% job is done
    respectively. As and when you progress with the task, you can just increment the
    value to have the visual indication of the progress in the UI, with the `ProgressBar`
    control.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首个进度指示器的值设置为`20`，而第二个进度指示器的值设置为`70`。这表示分别完成了20%和70%的工作。随着你任务的进展，你可以增加值以在UI中的`ProgressBar`控件上获得进度视觉指示。
- en: For the third `ProgressBar` control, in the preceding example, it's a bit different.
    When you are unsure about the total job to be done, you can set its `IsIndeterminate`
    property to `True`, as shown in the preceding screenshot. When your job is done,
    you can stop the indeterminate state and set its `Value` to 100.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个`ProgressBar`控件，在先前的示例中，它略有不同。当你不确定要完成的总工作量时，你可以将其`IsIndeterminate`属性设置为`True`，如先前的截图所示。当你的工作完成时，你可以停止不确定状态并将其`Value`设置为100。
- en: Using the Slider control to pick a numeric value
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滑动条控件选择数值
- en: The `Slider` control is used to pick a numeric value by dragging a thumb button
    along a horizontal or vertical line. This is often used to provide a visualization
    of a playing video and as a volume indicator.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Slider` 控件用于通过拖动滑块按钮沿水平或垂直线选择一个数值。这通常用于提供播放视频的可视化以及音量指示器。'
- en: WPF provides us a control named `Slider` to quickly implement this in your application
    UI, and, with a lot of properties for various configurations. Let's learn more
    about it, in this recipe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 为我们提供了一个名为 `Slider` 的控件，可以快速在应用程序 UI 中实现此功能，并且提供了许多属性以进行各种配置。让我们在本食谱中了解更多关于它的信息。
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, create a project named `CH02.SliderDemo`, based on the WPF application
    template.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `CH02.SliderDemo` 的项目，基于 WPF 应用程序模板。
- en: How to do it...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Integration of the slider in WPF is very easy. Just place `<Slider />` in your
    XAML page, and it will start working. But to customize it further, let''s follow
    these steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中集成滑块非常简单。只需在 XAML 页面中放置 `<Slider />`，它就会开始工作。但为了进一步自定义它，让我们遵循以下步骤：
- en: Open the `MainWindow.xaml` page, and replace the default `Grid` with a `StackPanel`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，并将默认的 `Grid` 替换为 `StackPanel`。
- en: 'Now add a `Slider` and a `TextBlock` control inside the `StackPanel`, as shown
    in the following XAML snippet:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 `StackPanel` 中添加一个 `Slider` 和一个 `TextBlock` 控件，如下面的 XAML 片段所示：
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run the application. You will see a `Slider` control in the UI, along with a
    text that shows the current value, which is set to `25`. Move the slider thumb
    to right, and it will show you the currently selected value. In our demonstration,
    it's now `65`, as shown in the following screenshot:![](img/3a973d7c-a749-4983-99f3-0789b373ba4d.png)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将在 UI 中看到一个 `Slider` 控件，以及显示当前值的文本，该值设置为 `25`。将滑块滑块向右移动，它将显示当前选定的值。在我们的演示中，它现在是
    `65`，如下面的截图所示![图片](img/3a973d7c-a749-4983-99f3-0789b373ba4d.png)
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: It works based on the current value. The property named `Value`, provides us
    with an integer, which denotes the current position. You can programmatically
    set it to move the slider thumb to a smaller or larger value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于当前值工作。名为 `Value` 的属性为我们提供一个整数，表示当前位置。您可以通过编程方式将其设置为将滑块滑块移动到较小的或较大的值。
- en: The `Minimum` and `Maximum` properties denote the minimum and maximum value
    that the slider can accept. In our example, we set it to `0` (zero) and `100`
    (hundred), respectively.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Minimum` 和 `Maximum` 属性表示滑块可以接受的最小和最大值。在我们的例子中，我们将其分别设置为 `0`（零）和 `100`（百）。'
- en: The other control, `TextBlock`, in our example code, has a data binding to the
    `Value` property of the slider that we have in the XAML. It displays the current
    value of the slider in a plain text format.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，其他控件 `TextBlock` 与滑块的 `Value` 属性进行数据绑定，该属性在 XAML 中。它以纯文本格式显示滑块的当前值。
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can also enable the tick display in a slider control, to provide a better
    indication of the thumb placement. Use the `TickPlacement` property to turn on
    the tick markers. It has four values `None`, `TopLeft`, `BottomRight`, and `Both`.
    Let's add `TickPlacement="BottomRight"` in our previous slider control.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在滑块控件中启用刻度显示，以提供更好的滑块位置指示。使用 `TickPlacement` 属性打开刻度标记。它有四个值 `None`、`TopLeft`、`BottomRight`
    和 `Both`。让我们在我们的上一个滑块控件中添加 `TickPlacement="BottomRight"`。
- en: 'The `TickFrequency` property is used to set the range of possible values between
    `0` and `100`. Let''s add `TickFrequency="20"` to our code and then run the application
    again. You will see the following screen:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`TickFrequency` 属性用于设置 `0` 和 `100` 之间可能值的范围。让我们在我们的代码中添加 `TickFrequency="20"`
    并再次运行应用程序。您将看到以下屏幕：'
- en: '![](img/2a495a98-7121-427d-974e-17f4c3e648ef.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a495a98-7121-427d-974e-17f4c3e648ef.png)'
- en: As shown in the preceding screenshot, you can see that some dots are added to
    the bottom of the slider. They represent the tick. As we have added `TickFrequency`
    as `20`, it divided the entire slider range to `100/20 = 5` sections.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，您可以看到在滑块的底部添加了一些点。它们代表刻度。由于我们已将 `TickFrequency` 设置为 `20`，它将整个滑块范围划分为
    `100/20 = 5` 个部分。
- en: In general, moving the slider will not snap to the tick. Thus, you will observe
    the thumb placed between ticks. Use the `IsSnapToTickEnabled` property and set
    it to `True`, to make sure that the thumb always stays on the tick marker only.
    In this case, dragging the slider will move the thumb based on the tick frequency
    count.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，移动滑块不会自动对齐到刻度。因此，您将观察到滑块位于刻度之间。使用 `IsSnapToTickEnabled` 属性并将其设置为 `True`，以确保滑块始终仅位于刻度标记上。在这种情况下，拖动滑块将根据刻度频率计数移动滑块。
- en: Using the Calendar control in your application
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用日历控件
- en: The `Calendar` control, part of the `System.Windows.Controls` namespace, allows
    you to create a visual calendar in WPF applications. It allows you to select a
    date or a collection of dates. As it inherits from the `Control` class, all common
    properties and events from `Control` class are available to it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar` 控件是 `System.Windows.Controls` 命名空间的一部分，它允许您在 WPF 应用程序中创建一个可视化的日历。它允许您选择一个日期或一组日期。由于它继承自
    `Control` 类，因此 `Control` 类的所有常见属性和事件都对它可用。'
- en: In this recipe, we will learn more about `Calendar` control and how to use that.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将了解更多关于 `Calendar` 控件及其使用方法。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, let's create a WPF application project named
    `CH02.CalendarDemo`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用此配方，让我们创建一个名为 `CH02.CalendarDemo` 的 WPF 应用程序项目。
- en: How to do it...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to add the basic controls to the main window:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将基本控件添加到主窗口：
- en: Open the `MainWindow.xaml` page.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面。
- en: Inside the default `Grid` panel, add the tag `<Calendar />` to create the basic
    calendar control in the application UI.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认的 `Grid` 面板内部，添加 `<Calendar />` 标签以在应用程序 UI 中创建基本的日历控件。
- en: 'To retrieve the date selected by the user, register the `SelectedDatesChanged`
    event to it, as shown in the following code snippet:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索用户选择的日期，将 `SelectedDatesChanged` 事件注册到它，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the associated event handler (`OnSelectedDateChanged`) in the code-behind
    class (`MainWindow.xaml.cs`), as shown in the following code, to retrieve the
    selected date and show it in a message box:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码后置类 (`MainWindow.xaml.cs`) 中添加相关的事件处理程序 (`OnSelectedDateChanged`)，如下所示，以检索所选日期并在消息框中显示：
- en: '[PRE34]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's run the application. You will see the following UI on the screen:![](img/6faaf605-cc79-453c-8efb-ed6b7a45dc60.png)
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。您将在屏幕上看到以下 UI：![图片](img/6faaf605-cc79-453c-8efb-ed6b7a45dc60.png)
- en: Once you select a date from the calendar, the selected date will be shown in
    a message box, like this:![](img/02bf24de-b18e-408e-91f1-38da3fcb53d3.png)
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦从日历中选择了一个日期，所选日期将在消息框中显示，如下所示：![图片](img/02bf24de-b18e-408e-91f1-38da3fcb53d3.png)
- en: Select a different date. This will show the message to the UI with the newly
    selected date.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不同的日期。这将向 UI 显示新选定的日期的消息。
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WPF `Calendar` control provides you with the basic UI to begin the calendar
    integration in your application. The top two arrow-heads, allow you to navigate
    back and forth to other months and select the desired date from the calendar.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: WPF `Calendar` 控件为您提供了基本的 UI，以便在应用程序中开始日历集成。顶部两个箭头允许您在月份之间导航并从日历中选择所需的日期。
- en: The navigation also supports year view and decade view, so, you can select the
    desired year and month very easily. Click on the month name (in our case, it's
    August 2017) present at the top, to navigate to the year view. When you are in
    the year view, it will show you the Jan–Dec month range, and clicking on the year
    will navigate you to the decade view where you can select the desired year.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 导航还支持年视图和十年视图，因此您可以非常容易地选择所需的年份和月份。点击顶部显示的月份名称（在我们的例子中是 2017 年 8 月），以导航到年视图。当您处于年视图时，它将显示
    Jan–Dec 的月份范围，点击年份将导航到十年视图，在那里您可以选择所需的年份。
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Calendar` control exposes many properties and events for you to customize
    the behavior and look of the control. Let's discuss this further.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar` 控件公开了许多属性和事件，供您自定义控件的行为和外观。让我们进一步讨论这个问题。'
- en: The SelectionModes property
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SelectionModes 属性
- en: 'The `SelectionMode` property allows you to get or set the value indicating
    what kind of selections are allowed on the calendar. There are four values available,
    named `None`, `SingleDate`, `SingleRange`, and `MultipleRange`. The `enum` value
    `SingleDate` is default, and allows you to select only a single date. But when
    you want multi-selection, set it as `MultipleRange`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionMode` 属性允许您获取或设置表示在日历上允许哪种选择的值。有四个可用的值，分别命名为 `None`、`SingleDate`、`SingleRange`
    和 `MultipleRange`。默认的 `enum` 值 `SingleDate` 允许您仅选择单个日期。但是，当您想要多选时，将其设置为 `MultipleRange`：'
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The DisplayDate property
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DisplayDate 属性
- en: The `Calendar` control allows you to set the start and end display dates. The
    `DisplayDate` property represents the current date to display; whereas, setting
    the `DisplayDateStart` and `DisplayDateEnd` properties limits you to select only
    the dates from the period ranging from the start date to the end date.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar`控件允许你设置起始和结束显示日期。`DisplayDate`属性表示要显示的当前日期；而设置`DisplayDateStart`和`DisplayDateEnd`属性则限制你只能选择从起始日期到结束日期的日期范围内的日期。'
- en: 'The following XAML code demonstrates how to set the `DisplayDate`, `DisplayDateStart`,
    and `DisplayDateEnd` properties in `Calendar` control:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下XAML代码演示了如何在`Calendar`控件中设置`DisplayDate`、`DisplayDateStart`和`DisplayDateEnd`属性：
- en: '[PRE36]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the application now to see the following output:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序以查看以下输出：
- en: '![](img/810c4ae3-71da-430f-be41-ae9a57dc53b6.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/810c4ae3-71da-430f-be41-ae9a57dc53b6.png)'
- en: The DisplayMode property
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示模式属性
- en: 'The `DisplayMode` property allows you to select the format of the calendar,
    which can be a month, a year, or a decade. When you launch a basic calendar, by
    default, it shows the month view:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayMode`属性允许你选择日历的格式，可以是月份、年份或十年。当你启动一个基本的日历时，默认情况下，它显示月份视图：'
- en: '![](img/bea06995-55f1-4e70-a9e8-de56c0d77db6.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bea06995-55f1-4e70-a9e8-de56c0d77db6.png)'
- en: But a user can easily navigate from month to year to decade by clicking the
    header text of the `Calendar` control.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 但是用户可以通过点击`Calendar`控件的头文字轻松地从月份导航到年份再到十年。
- en: 'To change the display mode from code, you can set the `DisplayMode` property
    to `Month`, `Year`, or `Decade`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要从代码中更改显示模式，可以将`DisplayMode`属性设置为`Month`、`Year`或`Decade`：
- en: '[PRE37]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The user can initiate the downward transitions by clicking any of the calendar
    cells, and they can easily navigate from decade to year to month and select the
    correct date.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过点击任何日历单元格来启动向下转换，并且他们可以轻松地从十年导航到年份再到月份并选择正确的日期。
- en: The BlackoutDates property
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黑名单日期属性
- en: You can choose ranges of dates to be non-selectable despite being displayed.
    You can implement the same by using the calendar's `BlackoutDates` property, which
    takes a collection of `CalendarDateRange` objects.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管显示，你可以选择不选择某些日期范围。你可以通过使用日历的`BlackoutDates`属性来实现，它接受一个`CalendarDateRange`对象的集合。
- en: 'The following `Calendar` control will block the date range from August 1^(st),
    2017 to August 8^(th), 2017, and August 21^(st), 2017 to August 31^(st), 2017:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Calendar`控件将阻止从2017年8月1日到2017年8月8日以及从2017年8月21日到2017年8月31日的日期范围：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All non-selection dates are marked by a cross, as shown in the following screenshot:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非选择日期都由一个十字标记，如下面的截图所示：
- en: '![](img/20a6f4fa-8982-412d-aab4-754c42ae1736.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20a6f4fa-8982-412d-aab4-754c42ae1736.png)'
- en: Listing items in a Listbox control
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Listbox控件中列出项目
- en: In WPF, the `ListBox` control is used to display a list of items. Users can
    select one or more items from the list, depending on the `SelectionMode` specified.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，`ListBox`控件用于显示项目列表。用户可以根据指定的`SelectionMode`从列表中选择一个或多个项目。
- en: In this recipe, we are going to learn how to create a `ListBox` control and
    use it in WPF applications.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建`ListBox`控件并在WPF应用程序中使用它。
- en: Getting ready
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE and create a new WPF application project, called
    `CH02.ListBoxDemo`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Visual Studio IDE并创建一个新的WPF应用程序项目，命名为`CH02.ListBoxDemo`。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Adding a `ListBox` control in the UI is as easy as writing a `<ListBox />`
    tag in any XAML page. But to hold the data in it, you will have to use its properties
    properly. Follow these steps to add a `ListBox` control with some static data:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中添加`ListBox`控件就像在任何XAML页面中编写`<ListBox />`标签一样简单。但要存储其中的数据，您必须正确使用其属性。按照以下步骤添加带有一些静态数据的`ListBox`控件：
- en: Open the `MainWindow.xaml` page of the WPF project.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开WPF项目的`MainWindow.xaml`页面。
- en: Under the default `Grid` panel, add the `<ListBox></ListBox>` tag to add the
    control.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认的`Grid`面板下，添加`<ListBox></ListBox>`标签以添加控件。
- en: 'Add a few `ListBoxItem` inside the control, as shared here:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控件内部添加几个`ListBoxItem`，如下所示：
- en: '[PRE39]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add two buttons labelled `+` and `-` to perform the `add` and `delete` operations
    on the said `Listbox` control. Register the `Click` event of both the buttons:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控件添加两个按钮，分别标记为`+`和`-`以执行对所述`Listbox`控件的`add`和`delete`操作。注册两个按钮的`Click`事件：
- en: '[PRE40]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the code-behind file, `MainWindow.xaml.cs`, implement the button-click event
    handler as shown here:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码隐藏文件`MainWindow.xaml.cs`中，实现如下所示的按钮点击事件处理程序：
- en: '[PRE41]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now run the application. You will see the following UI in the screen:![](img/217b3d74-43b9-4416-add8-c85ded5b4d5d.png)
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。你将在屏幕上看到以下UI：![图片](img/217b3d74-43b9-4416-add8-c85ded5b4d5d.png)
- en: How it works...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding example, the `ListBox` control contains five items as `ListBoxItem`.
    When you launch the application, by default, the second item is selected due to
    its property `IsSelected` being set to `True`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`ListBox`控件包含五个作为`ListBoxItem`的项目。当您启动应用程序时，默认情况下，第二个项目被选中，因为其`IsSelected`属性被设置为`True`。
- en: The two buttons are used to `add` or `delete` items in the `Listbox` control.
    Click on the `+` button to trigger the `OnAddItemClicked` event, which will create
    a new instance of the `ListBoxItem` and add it to the `ListBox` control. Scroll
    the list to see the newly added entry. As the `SelectedItem` property of the `ListBox`
    is assigned with the latest item, it will now get selected, removing the previous
    selection.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个按钮用于在`Listbox`控件中`添加`或`删除`项目。点击`+`按钮将触发`OnAddItemClicked`事件，这将创建一个新的`ListBoxItem`实例并将其添加到`ListBox`控件中。滚动列表以查看新添加的条目。由于`ListBox`的`SelectedItem`属性被分配了最新的项目，它现在将被选中，从而取消之前的选中。
- en: Click on the `-` button to trigger the `OnDeleteItemClicked` event. This will
    get the current selected item, and, if it is not `null`, it will be removed from
    the `ListBox` control. The property `SelectedIndex` will set to `0` (zero), to
    select the first element after deletion.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`-`按钮以触发`OnDeleteItemClicked`事件。这将获取当前选中的项目，如果它不是`null`，它将被从`ListBox`控件中删除。`SelectedIndex`属性将设置为`0`（零），以便在删除后选择第一个元素。
- en: There's more...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`ListBox` has numerous properties to perform specific actions. Let''s learn
    a few of them. Later in this section, we will also cover how to add a customized
    `ListBoxItem` having additional UI controls.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListBox`有许多属性可以执行特定操作。让我们学习其中的一些。在本节的后面，我们还将介绍如何添加具有附加UI控件的定制`ListBoxItem`。'
- en: Implementing multi selection
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现多选
- en: '`ListBox` supports multi selection. By default, when the `SelectionMode` property
    is set to `Single`, it only accepts a single selection of items. If you set `SelectionMode`
    to `Multiple`, it will accept multi selection. The `Extended` mode allows you
    to perform single selection, but if you press the *Ctrl* key while selecting items,
    it will act as a multi selection.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListBox`支持多选。默认情况下，当`SelectionMode`属性设置为`Single`时，它只接受单个项目的选择。如果您将`SelectionMode`设置为`Multiple`，它将接受多选。`Extended`模式允许您执行单选，但如果在选择项目时按下*Ctrl*键，它将作为多选操作。'
- en: Customizing the ListBoxItem with multiple controls
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个控件自定义ListBoxItem
- en: 'You can easily customize the `ListBoxItem`, by adding additional UI controls
    to it. Consider the following XAML code snippet, where we have added a `ListBox`,
    which has four `ListBoxItem`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向其中添加额外的UI控件轻松地自定义`ListBoxItem`。考虑以下XAML代码片段，其中我们添加了一个`ListBox`，它包含四个`ListBoxItem`：
- en: '[PRE42]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you see the preceding code snippet, each `ListBoxItem` has a `StackPanel`
    to hold a `Rectangle` control and a `TextBlock` control. If you run the preceding
    code, you will see the following UI:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到前面的代码片段，每个`ListBoxItem`都有一个`StackPanel`来容纳一个`Rectangle`控件和一个`TextBlock`控件。如果您运行前面的代码，您将看到以下UI：
- en: '![](img/5b1ef087-c85a-4fb9-a882-c73d1ad90c1f.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b1ef087-c85a-4fb9-a882-c73d1ad90c1f.png)'
- en: In the preceding screenshot, notice the way the items have been listed. Each
    item consists of a rectangle to preview the color that is listed as an item. This
    is more useful when displaying information on an entity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，注意项目是如何列出的。每个项目都包含一个矩形来预览作为项目列出的颜色。这在显示实体信息时更有用。
- en: Generally, this is done using the `DataTemplate` property of `ListBox` control,
    which we will learn in the later chapters of this book.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是通过使用`ListBox`控件的`DataTemplate`属性来完成的，我们将在本书的后续章节中学习。
- en: Providing options to select from a ComboBox
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供从ComboBox中选择选项
- en: A `ComboBox` control is an items control and works like `ListBox`, but only
    one item from the list is selectable. A `ListBox` control by default lists multiple
    items on screen, but `ComboBox` control displays the scrollable list only on a
    user click. Thus, it takes up a lot less space.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComboBox`控件是一个项目控件，其工作方式类似于`ListBox`，但列表中只有一个项目可选中。`ListBox`控件默认情况下在屏幕上列出多个项目，但`ComboBox`控件仅在用户点击时显示可滚动的列表。因此，它占用的空间要小得多。'
- en: This recipe will talk about `ComboBox` control and how to use it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将讨论`ComboBox`控件及其使用方法。
- en: Getting ready
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Begin with creating a new WPF application project, called `CH02.ComboBoxDemo`,
    using your Visual Studio IDE.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 开始创建一个新的WPF应用程序项目，使用您的Visual Studio IDE，命名为`CH02.ComboBoxDemo`。
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these simple steps to add a `ComboBox` control in your application UI:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤将`ComboBox`控件添加到您的应用程序UI中：
- en: Replace the default `Grid` with a `StackPanel` to host UI controls horizontally
    stacked.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的`Grid`替换为`StackPanel`以水平堆叠托管UI控件。
- en: 'Add the following XAML code, inside the `StackPanel`, to have a simple `ComboBox`
    control with some items in it:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StackPanel`内部添加以下XAML代码，以创建一个包含一些项目的简单`ComboBox`控件：
- en: '[PRE43]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add another `ComboBox` to have customized items, as shown in the following
    example code:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个`ComboBox`以具有自定义项目，如下面的示例代码所示：
- en: '[PRE44]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now run the application, which will look like the following screenshot, with
    an expandable pop up menu:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序，它将看起来如下截图所示，具有可展开的弹出菜单：
- en: '![](img/6d69e062-04c5-425e-be18-71c0c25a84b9.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d69e062-04c5-425e-be18-71c0c25a84b9.png)'
- en: How it works...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Though a `ComboBox` control is like `ListBox`, it does not show the list of
    items by default. A user intervention is required to display the items. The UI
    of a `ComboBox` is a combination of three controls:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个`ComboBox`控件类似于`ListBox`，但它默认不显示项目列表。需要用户干预才能显示项目。`ComboBox`的UI是三个控制器的组合：
- en: A **TextBox**, which displays the selected item
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**TextBox**，用于显示选定的项目
- en: A **Button**, which is used to show or hide available items
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**Button**，用于显示或隐藏可用项目
- en: A **Popup**, which displays a list of items inside a scrollable pane and gives
    the user the option to select one item from the available list
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**Popup**，在可滚动的面板内显示项目列表，并给用户选择一个可用列表项的选项
- en: '`ComboBox` contains a collection of `ComboBoxItem`. You can add those to its
    `Items` property. When you click on the arrow-head, the list of items will pop
    up in the screen, as demonstrated in the preceding screenshot. To preselect an
    item from code, set its `IsSelected` property to `True`.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComboBox`包含一个`ComboBoxItem`集合。您可以将这些添加到其`Items`属性中。当您点击箭头时，项目列表将在屏幕上弹出，如前一张截图所示。要从代码中预选一个项目，将其`IsSelected`属性设置为`True`。'
- en: You can also add custom contents to a `ComboBoxItem` to represent a better UI
    component. The second `ComboBox` in the preceding example, demonstrates how easy
    it is to customize the UI.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以向`ComboBoxItem`添加自定义内容，以表示更好的UI组件。前一个示例中的第二个`ComboBox`演示了如何轻松自定义UI。
- en: Just like `ListBox`, it also exposes `SelectedItem`, `SelectedIndex`, `SelectedValue`
    properties to help you to easily set or get the selected item.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`ListBox`一样，它也公开了`SelectedItem`、`SelectedIndex`、`SelectedValue`属性，以帮助您轻松设置或获取选定的项目。
- en: There's more...
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The `ComboBox` control is not editable by default. But you can control this
    behavior to provide the user with the option to manually enter the desired value,
    directly in the `ComboBox` control. The `IsEditable` property is used to add this
    functionality. Set it to `True`, to change it to an editable `ComboBox`. Consider
    the following code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComboBox`控件默认情况下不可编辑。但您可以控制此行为，为用户提供在`ComboBox`控件中手动输入所需值的选项。`IsEditable`属性用于添加此功能。将其设置为`True`，将其更改为可编辑的`ComboBox`。考虑以下代码：'
- en: '[PRE45]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you run the preceding code, you can see the following UI, where the control
    now allows you to enter text to it:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的代码，您可以看到以下UI，其中控件现在允许您向其中输入文本：
- en: '![](img/185b9bbd-49e8-47a8-94b9-010674e662c0.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/185b9bbd-49e8-47a8-94b9-010674e662c0.png)'
- en: Adding a status bar to your window
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向窗口添加状态栏
- en: The status bar is used to show various information about the current state of
    the application. You can use this to show cursor position, word counts, progress
    of tasks, and more. Generally, a status bar is placed at the bottom of the window
    whereas the menus, toolbars are placed at the top.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 状态栏用于显示有关应用程序当前状态的各项信息。您可以使用此功能显示光标位置、单词计数、任务进度等。通常，状态栏放置在窗口底部，而菜单、工具栏放置在顶部。
- en: In this recipe, we will learn how to add a status bar in a WPF window.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在WPF窗口中添加状态栏。
- en: Getting ready
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: To get started with the status bar, let's create a WPF application project called
    `CH02.StatusBarDemo`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用状态栏，让我们创建一个名为`CH02.StatusBarDemo`的WPF应用程序项目。
- en: How to do it...
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Once you create the WPF project, open the `MainWindow.xaml` page and follow
    these steps to add the `StatusBar` control to the window:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建WPF项目，打开`MainWindow.xaml`页面，按照以下步骤将`StatusBar`控件添加到窗口中：
- en: Inside the `Grid` panel, add a `StatusBar` tag and set its `Height` to `26`
    and `VerticalAlignment` to `Bottom`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`面板内部，添加一个`StatusBar`标签，并将其`Height`设置为`26`，`VerticalAlignment`设置为`Bottom`。
- en: 'Now change its items panel template to host a `Grid` with five columns (we
    will discuss more about grid columns in the next chapter), as shown here:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改其项目面板模板以托管一个具有五列的`Grid`（我们将在下一章中讨论更多关于网格列的内容），如下所示：
- en: '[PRE46]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, inside the `StatusBar` tag, add the controls that you want to show. Let''s
    add two `StatusBarItem`; one having a plain text content and the other with a
    `ProgressBar` control. Place two separators in between, as shown in the following
    XAML snippet:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`StatusBar`标签内添加您想要显示的控件。让我们添加两个`StatusBarItem`；一个包含纯文本内容，另一个包含`ProgressBar`控件。在它们之间放置两个分隔符，如下面的XAML代码片段所示：
- en: '[PRE47]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here''s the complete XAML code, which you need to place inside the default
    `Grid` panel:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是完整的XAML代码，您需要将其放置在默认的`Grid`面板中：
- en: '[PRE48]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once your UI is ready, let's run the application. You will see the following
    screen:![](img/d61f4392-43fa-4873-8663-81289c776b9c.png)
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的UI准备就绪后，让我们运行应用程序。您将看到以下屏幕：![图片](img/d61f4392-43fa-4873-8663-81289c776b9c.png)
- en: How it works...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the preceding example, we have placed a plain text content Running Process...
    as a `StatusBarItem` inside the first column of the `Grid`. The second and fourth
    columns of the `Grid` contain a `Separator` control, having one pixel width. The
    fifth column contains a `ProgressBar` control, having an indeterminate state.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将纯文本内容“正在运行进程...”作为`StatusBarItem`放置在`Grid`的第一个列中。`Grid`的第二列和第四列包含一个宽度为一像素的`Separator`控件。第五列包含一个具有不确定状态的`ProgressBar`控件。
- en: When you resize the window, the status bar will follow its parent to resize
    itself automatically and position it to the bottom of the window. Instead of `Grid`,
    you can also use `DockPanel` to dock the status bar at the bottom.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调整窗口大小时，状态栏将跟随其父级自动调整大小并定位到窗口底部。除了`Grid`之外，您还可以使用`DockPanel`将状态栏停靠到底部。
- en: Adding a toolbar panel to perform quick tasks
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具栏面板以执行快速任务
- en: In any windows-based application, you can find a toolbar, usually placed just
    below the main menu of a window. It contains a set of controls to provide easy
    access to common functions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何基于Windows的应用程序中，您都可以找到一个工具栏，通常位于窗口主菜单的下方。它包含一组控件，提供对常用功能的便捷访问。
- en: WPF offers you a `ToolBarTray` element to host one or more `ToolBar` controls,
    containing various UI controls. It provides you with some extra features, such
    as an automatic overflowing mechanism and a manual repositioning feature.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: WPF提供了一个`ToolBarTray`元素来托管一个或多个`ToolBar`控件，包含各种UI控件。它为您提供了额外的功能，例如自动溢出机制和手动重新定位功能。
- en: In this recipe, we will learn how to work with toolbars in a WPF application.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在WPF应用程序中处理工具栏。
- en: Getting ready
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin with, open your Visual Studio IDE and create a new WPF application
    project called `CH03.ToolBarDemo`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开您的Visual Studio IDE并创建一个新的WPF应用程序项目，命名为`CH03.ToolBarDemo`。
- en: How to do it...
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the project gets created, follow these steps to add a toolbar in the application
    window:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，按照以下步骤在应用程序窗口中添加工具栏：
- en: Open the `MainWindow.xaml` page from the Solution Explorer.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器打开`MainWindow.xaml`页面。
- en: Now, replace the existing `Grid` with a `DockPanel` so that we can host the
    toolbar docking to the top of the window.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将现有的`Grid`替换为`DockPanel`，以便我们可以将工具栏停靠到窗口顶部。
- en: Add a `ToolBarTray` element inside the `DockPanel` and dock it to `Top`.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DockPanel`中添加一个`ToolBarTray`元素并将其停靠到`Top`。
- en: 'Add a `ToolBar` control inside the `ToolBarTray` and then add a few buttons
    inside it, as shown in the following XAML markup:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ToolBarTray`中添加一个`ToolBar`控件，然后在其内部添加几个按钮，如下面的XAML标记所示：
- en: '[PRE49]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Add a `TextBox` control inside the `DockPanel`, just below the `ToolBarTray`,
    so that, it can cover the remaining space of the window. Give it the following
    name `txtBox`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DockPanel`中添加一个`TextBox`控件，位于`ToolBarTray`下方，以便它可以覆盖窗口剩余的空间。给它命名为`txtBox`。
- en: 'You can add a multiple toolbar inside a `ToolBarTray`. You can also add other
    controls inside a `ToolBar`. Let''s add the following `ToolBar` with a `ComboBox`
    inside it. Place it just after the first `ToolBar` control:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在`ToolBarTray`中添加多个工具栏。您还可以在`ToolBar`中添加其他控件。让我们添加以下包含`ComboBox`的`ToolBar`。将其放置在第一个`ToolBar`控件之后：
- en: '[PRE50]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here''s the complete XAML code to take as a reference:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是完整的XAML代码，供您参考：
- en: '[PRE51]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As we have associated a click event of the first button of the first toolbar,
    we need to write the event body. Open the `MainWindow.xaml.cs` file, and add the
    following button-click event implementation inside the class:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已将第一个工具栏的第一个按钮的点击事件与类相关联，我们需要编写事件主体。打开`MainWindow.xaml.cs`文件，并在类中添加以下按钮点击事件实现：
- en: '[PRE52]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Once you run the application, you will see the following UI containing two toolbars
    inside a toolbar panel:![](img/2f71918f-75d8-4677-997c-f811c8b63b30.png)
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行应用程序，你将看到以下 UI，其中包含一个工具栏面板内的两个工具栏：![图片](img/2f71918f-75d8-4677-997c-f811c8b63b30.png)
- en: Click on the first button (denoted by the character B). You will see that the
    text Sample Text becomes bold. If you click the same button again, the text will
    change the font weight to normal:![](img/18536de1-fec6-4eb6-ac9c-b2c4f968544d.png)
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第一个按钮（用字符 B 表示）。你会看到文本 Sample Text 变得加粗。如果你再次点击相同的按钮，文本的字体重量将变为正常！![图片](img/18536de1-fec6-4eb6-ac9c-b2c4f968544d.png)
- en: How it works...
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `ToolBarTray` can contain one or more `ToolBar` controls. Each `ToolBar` control
    can contain one or more controls inside it. A `ToolBar` control can also remain
    empty. When you start adding other controls to it, the toolbar starts changing
    its size and position, based on the available space.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolBarTray` 可以包含一个或多个 `ToolBar` 控件。每个 `ToolBar` 控件可以包含一个或多个控件。`ToolBar` 控件也可以保持为空。当你开始向其中添加其他控件时，工具栏开始根据可用空间改变其大小和位置。'
- en: The controls placed inside a `ToolBar` can have its associated events registered.
    If you want, you can also use command bindings to have a more granular association
    between the view and the code.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 放置在 `ToolBar` 内部的控件可以注册其相关的事件。如果你想的话，你也可以使用命令绑定来在视图和代码之间建立更精细的关联。
- en: In the preceding example, the first button, denoted by the character B, stands
    for applying `Bold` weightage to the associated `TextBox`. When you click it for
    the first time, the `FontWeight` property of the text will set it to `Bold`. When
    you click it again, it will set to `Normal`. By following the same logic, you
    can add a `Click` event for other buttons and a `SelectionChange` event for the
    combobox, as shown in the preceding example.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个按钮，用字符 B 表示，代表为相关的 `TextBox` 应用 `Bold` 加权。当你第一次点击它时，文本的 `FontWeight`
    属性将被设置为 `Bold`。当你再次点击它时，它将被设置为 `Normal`。按照相同的逻辑，你可以为其他按钮添加 `Click` 事件，并为组合框添加
    `SelectionChange` 事件，如前面的例子所示。
