["```cs\n    using System;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    static async Task ProcessAsynchronously()\n    {\n      var unsafeState = new UnsafeState();\n      Task[] tasks = new Task[4];\n\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(unsafeState));\n      }\n      await Task.WhenAll(tasks);\n      WriteLine(\" --------------------------- \");\n\n      var firstState = new DoubleCheckedLocking();\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(firstState));\n      }\n\n      await Task.WhenAll(tasks);\n      WriteLine(\" --------------------------- \");\n\n      var secondState = new BCLDoubleChecked();\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(secondState));\n      }\n\n      await Task.WhenAll(tasks);\n      WriteLine(\" --------------------------- \");\n\n      var lazy = new Lazy<ValueToAccess>(Compute);\n          var thirdState = new LazyWrapper(lazy);\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(thirdState));\n      }\n\n      await Task.WhenAll(tasks);\n      WriteLine(\" --------------------------- \");\n\n      var fourthState = new BCLThreadSafeFactory();\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(fourthState));\n      }\n\n      await Task.WhenAll(tasks);\n      WriteLine(\" --------------------------- \");\n\n    }\n\n    static void Worker(IHasValue state)\n    {\n      WriteLine($\"Worker runs on thread id {CurrentThread.ManagedThreadId}\");\n      WriteLine($\"State value: {state.Value.Text}\");\n    }\n\n    static ValueToAccess Compute()\n    {\n      WriteLine(\"The value is being constructed on a thread \" +\n            $\"id {CurrentThread.ManagedThreadId}\");\n      Sleep(TimeSpan.FromSeconds(1));\n      return new ValueToAccess(\n                $\"Constructed on thread id {CurrentThread.ManagedThreadId}\");\n    }\n\n    class ValueToAccess\n    {\n      private readonly string _text; \n      public ValueToAccess(string text)\n      {\n        _text = text;\n      }\n\n      public string Text => _text;\n    }\n\n    class UnsafeState : IHasValue\n    {\n      private ValueToAccess _value;\n\n      public ValueToAccess Value =>_value ?? (_value = Compute());\n    }\n\n    class DoubleCheckedLocking : IHasValue\n    {\n      private readonly object _syncRoot = new object();\n      private volatile ValueToAccess _value;\n\n      public ValueToAccess Value\n      {\n        get\n        {\n          if (_value == null)\n          {\n            lock (_syncRoot)\n            {\n              if (_value == null) _value = Compute();\n            }\n          }\n          return _value;\n        }\n      }\n    }\n\n    class BCLDoubleChecked : IHasValue\n    {\n      private object _syncRoot = new object();\n      private ValueToAccess _value;\n      private bool _initialized;\n\n      public ValueToAccess Value => LazyInitializer.EnsureInitialized(\n        ref _value, ref _initialized, ref _syncRoot, Compute);\n    }\n\n    class BCLThreadSafeFactory : IHasValue\n    {\n      private ValueToAccess _value;\n\n      public ValueToAccess Value => LazyInitializer.EnsureInitialized(ref _value, Compute);\n    }\n\n    class LazyWrapper : IHasValue\n    {\n      private readonly Lazy<ValueToAccess> _value;\n\n      public LazyWrapper(Lazy<ValueToAccess> value )\n      {\n        _value = value;\n      }\n\n      public ValueToAccess Value => _value.Value;\n    }\n\n    interface IHasValue\n    {\n      ValueToAccess Value { get; }\n    }\n    ```", "```cs\n    var t = ProcessAsynchronously();\n    t.GetAwaiter().GetResult();\n    ```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Globalization;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    private const int CollectionsNumber = 4;\n    private const int Count = 5;\n\n    static void CreateInitialValues(BlockingCollection<int>[] sourceArrays, CancellationTokenSource cts)\n    {\n      Parallel.For(0, sourceArrays.Length*Count, (j, state) =>\n      {\n          if (cts.Token.IsCancellationRequested)\n          {\n              state.Stop();\n          }\n\n          int number = GetRandomNumber(j);\n          int k = BlockingCollection<int>.TryAddToAny(sourceArrays, j);\n          if (k >= 0)\n          {\n              WriteLine(\n                  $\"added {j} to source data on thread \" +\n                  $\"id {CurrentThread.ManagedThreadId}\");\n              Sleep(TimeSpan.FromMilliseconds(number));\n          }\n      });\n      foreach (var arr in sourceArrays)\n      {\n          arr.CompleteAdding();\n      }\n    }\n\n    static int GetRandomNumber(int seed)\n    {\n      return new Random(seed).Next(500);\n    }\n\n    class PipelineWorker<TInput, TOutput>\n    {\n      Func<TInput, TOutput> _processor;\n      Action<TInput> _outputProcessor;\n      BlockingCollection<TInput>[] _input;\n      CancellationToken _token;\n      Random _rnd;\n\n      public PipelineWorker(\n          BlockingCollection<TInput>[] input,\n          Func<TInput, TOutput> processor,\n          CancellationToken token,\n          string name)\n      {\n        _input = input;\n        Output = new BlockingCollection<TOutput>[_input.Length];\n        for (int i = 0; i < Output.Length; i++)\n          Output[i] = null == input[i] ? null\n            : new BlockingCollection<TOutput>(Count);\n\n        _processor = processor;\n        _token = token;\n        Name = name;\n        _rnd = new Random(DateTime.Now.Millisecond);\n      }\n\n      public PipelineWorker(\n          BlockingCollection<TInput>[] input,\n          Action<TInput> renderer,\n          CancellationToken token,\n          string name)\n      {\n        _input = input;\n        _outputProcessor = renderer;\n        _token = token;\n        Name = name;\n        Output = null;\n        _rnd = new Random(DateTime.Now.Millisecond);\n        }\n\n      public BlockingCollection<TOutput>[] Output { get; private set; }\n\n      public string Name { get; private set; }\n\n      public void Run()\n      {\n        WriteLine($\"{Name} is running\");\n        while (!_input.All(bc => bc.IsCompleted) && \n          !_token.IsCancellationRequested)\n        {\n          TInput receivedItem;\n          int i = BlockingCollection<TInput>.TryTakeFromAny(\n              _input, out receivedItem, 50, _token);\n          if (i >= 0)\n          {\n            if (Output != null)\n            {\n              TOutput outputItem = _processor(receivedItem);\n            BlockingCollection<TOutput>.AddToAny(\n                Output, outputItem);\n            WriteLine($\"{Name} sent {outputItem} to next, on \" +\n            $\"thread id {CurrentThread.ManagedThreadId}\");\n            Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));\n            }\n            else\n            {\n              _outputProcessor(receivedItem);\n            }\n          }\n          else\n          {\n            Sleep(TimeSpan.FromMilliseconds(50));\n          }\n        }\n        if (Output != null)\n        {\n          foreach (var bc in Output) bc.CompleteAdding();\n        }\n      }\n    }\n    ```", "```cs\n    var cts = new CancellationTokenSource();\n\n    Task.Run(() =>\n    {\n      if (ReadKey().KeyChar == 'c') cts.Cancel();\n    }, \n    cts.Token);\n\n    var sourceArrays = new BlockingCollection<int>[CollectionsNumber];\n\n    for (int i = 0; i < sourceArrays.Length; i++)\n    {\n      sourceArrays[i] = new BlockingCollection<int>(Count);\n    }\n\n    var convertToDecimal = new PipelineWorker<int, decimal>\n    (\n      sourceArrays,\n      n => Convert.ToDecimal(n*100),\n      cts.Token,\n      \"Decimal Converter\"\n    );\n\n    var stringifyNumber = new PipelineWorker<decimal, string>\n    (\n      convertToDecimal.Output,\n      s => $\"--{s.ToString(\"C\", CultureInfo.GetCultureInfo(\"en-us\"))}--\",\n      cts.Token,\n      \"String Formatter\"\n      );\n\n    var outputResultToConsole = new PipelineWorker<string, string>\n    (\n      stringifyNumber.Output,\n      s => WriteLine($\"The final result is {s} on thread \" +\n                $\"id {CurrentThread.ManagedThreadId}\"),\n      cts.Token,\n      \"Console Output\"\n      );\n\n    try\n    {\n      Parallel.Invoke(\n        () =>\n        CreateInitialValues(sourceArrays, cts),\n        () => convertToDecimal.Run(),\n        () => stringifyNumber.Run(),\n        () => outputResultToConsole.Run()\n      );\n    }\n    catch (AggregateException ae)\n    {\n      foreach (var ex in ae.InnerExceptions)\n        WriteLine(ex.Message + ex.StackTrace);\n    }\n\n    if (cts.Token.IsCancellationRequested)\n    {\n      WriteLine(\"Operation has been canceled! Press ENTER to exit.\");\n    }\n    else\n    {\n      WriteLine(\"Press ENTER to exit.\");\n    }\n    ReadLine();\n    ```", "```cs\n    using System;\n    using System.Globalization;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using System.Threading.Tasks.Dataflow;\n    using static System.Console;\n    using static System.Threading.Thread;\n    ```", "```cs\n    async static Task ProcessAsynchronously()\n    {\n      var cts = new CancellationTokenSource();\n      Random _rnd = new Random(DateTime.Now.Millisecond);\n\n      Task.Run(() =>\n      {\n        if (ReadKey().KeyChar == 'c')\n          cts.Cancel();\n      }, cts.Token);\n\n      var inputBlock = new BufferBlock<int>(\n        new DataflowBlockOptions { BoundedCapacity = 5, CancellationToken = cts.Token });\n\n      var convertToDecimalBlock = new TransformBlock<int, decimal>(\n        n =>\n        {\n          decimal result = Convert.ToDecimal(n * 100);\n          WriteLine($\"Decimal Converter sent {result} to the next stage on \" +\n                  $\"thread id {CurrentThread.ManagedThreadId}\");\n          Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));\n          return result;\n        }\n        , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });\n\n      var stringifyBlock = new TransformBlock<decimal, string>(\n        n =>\n        {\n          string result = $\"--{n.ToString(\"C\", CultureInfo.GetCultureInfo(\"en-us\"))}--\";\n          WriteLine($\"String Formatter sent {result} to the next stage on thread id {CurrentThread.ManagedThreadId}\");\n          Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));\n          return result;\n        }\n        , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });\n\n      var outputBlock = new ActionBlock<string>(\n        s =>\n        {\n          WriteLine($\"The final result is {s} on thread id {CurrentThread.ManagedThreadId}\");\n        }\n        , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });\n\n      inputBlock.LinkTo(convertToDecimalBlock, new DataflowLinkOptions { PropagateCompletion = true });\n      convertToDecimalBlock.LinkTo(stringifyBlock, new DataflowLinkOptions { PropagateCompletion = true });\n      stringifyBlock.LinkTo(outputBlock, new DataflowLinkOptions { PropagateCompletion = true });\n\n      try\n      {\n        Parallel.For(0, 20, new ParallelOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token }\n        , i =>\n        {\n          WriteLine($\"added {i} to source data on thread id {CurrentThread.ManagedThreadId}\");\n          inputBlock.SendAsync(i).GetAwaiter().GetResult();\n        });\n        inputBlock.Complete();\n        await outputBlock.Completion;\n        WriteLine(\"Press ENTER to exit.\");\n      }\n      catch (OperationCanceledException)\n      {\n        WriteLine(\"Operation has been canceled! Press ENTER to exit.\");\n      }\n\n      ReadLine();\n    }\n    ```", "```cs\n    var t = ProcessAsynchronously();\n    t.GetAwaiter().GetResult();\n    ```", "```cs\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Linq;\n    using System.Net.Http;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    using Newtonsoft.Json;\n\n    using static System.Console;\n    ```", "```cs\n    static char[] delimiters = { ' ', ',', ';', ':', '\\\"', '.' };\n\n    async static Task<string> ProcessBookAsync(\n        string bookContent, string title, HashSet<string> stopwords)\n    {\n        using (var reader = new StringReader(bookContent))\n        {\n            var query = reader.EnumLines()\n                .AsParallel()\n                .SelectMany(line => line.Split(delimiters))\n                .MapReduce(\n                    word => new[] { word.ToLower() },\n                    key => key,\n                    g => new[] { new { Word = g.Key, Count = g.Count() } }\n                )\n                .ToList();\n\n            var words = query\n                .Where(element =>\n                    !string.IsNullOrWhiteSpace(element.Word)\n                    && !stopwords.Contains(element.Word))\n                .OrderByDescending(element => element.Count);\n\n            var sb = new StringBuilder();\n\n            sb.AppendLine($\"'{title}' book stats\");\n            sb.AppendLine(\"Top ten words used in this book: \");\n            foreach (var w in words.Take(10))\n            {\n                sb.AppendLine($\"Word: '{w.Word}', times used: '{w.Count}'\");\n            }\n\n            sb.AppendLine($\"Unique Words used: {query.Count()}\");\n\n            return sb.ToString();\n        }\n    }\n\n    async static Task<string> DownloadBookAsync(string bookUrl)\n    {\n      using (var client = new HttpClient())\n      {\n          return  await client.GetStringAsync(bookUrl);\n      }             \n    }\n\n    async static Task<HashSet<string>> DownloadStopWordsAsync()\n    {\n      string url = \n            \"https://raw.githubusercontent.com/6/stopwords/master/stopwords-all.json\";\n\n      using (var client = new HttpClient())\n      {\n          try\n          {\n              var content = await client.GetStringAsync(url);\n              var words =\n                  JsonConvert.DeserializeObject\n                      <Dictionary<string, string[]>>(content);\n              return new HashSet<string>(words[\"en\"]);\n          }\n          catch\n          {\n              return new HashSet<string>();\n          }\n\n      }\n    }\n    ```", "```cs\n    var booksList = new Dictionary<string, string>()\n    {\n        [\"Moby Dick; Or, The Whale by Herman Melville\"] \n        = \"http://www.gutenberg.org/cache/epub/2701/pg2701.txt\",\n\n        [\"The Adventures of Tom Sawyer by Mark Twain\"]\n        = \"http://www.gutenberg.org/cache/epub/74/pg74.txt\",\n\n        [\"Treasure Island by Robert Louis Stevenson\"]\n        = \"http://www.gutenberg.org/cache/epub/120/pg120.txt\",\n\n        [\"The Picture of Dorian Gray by Oscar Wilde\"]\n        = \"http://www.gutenberg.org/cache/epub/174/pg174.txt\"\n    };\n\n    HashSet<string> stopwords = DownloadStopWordsAsync().GetAwaiter().GetResult();\n\n    var output = new StringBuilder();\n\n    Parallel.ForEach(booksList.Keys, key =>\n    {\n        var bookContent = DownloadBookAsync(booksList[key])\n            .GetAwaiter().GetResult();\n\n        string result = ProcessBookAsync(bookContent, key, stopwords)\n            .GetAwaiter().GetResult();\n\n      output.Append(result);\n      output.AppendLine();\n    });\n\n    Write(output.ToString());\n    ReadLine();\n    ```", "```cs\n    static class Extensions\n    {\n      public static ParallelQuery<TResult> MapReduce<TSource, TMapped, TKey, TResult>(\n        this ParallelQuery<TSource> source,\n        Func<TSource, IEnumerable<TMapped>> map,\n        Func<TMapped, TKey> keySelector,\n        Func<IGrouping<TKey, TMapped>, IEnumerable<TResult>> reduce)\n      {\n        return source.SelectMany(map)\n        .GroupBy(keySelector)\n        .SelectMany(reduce);\n      }\n\n        public static IEnumerable<string> EnumLines(this StringReader reader)\n        {\n            while (true)\n            {\n                string line = reader.ReadLine();\n                if (null == line) yield break;\n\n                yield return line;\n            }\n        }\n    }\n    ```"]