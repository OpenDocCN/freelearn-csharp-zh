<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Regular Expressions</h1></div></div></div><p>
<strong>Regular Expressions</strong> (<strong>regex</strong>) are somewhat of a mystery for many developers. We admit that they are something that we use often enough to warrant a deeper understanding of how they work. On the flip side, there are so many tried and tested regex patterns on the Internet that just reusing one that already exists is most times easier than trying to create one yourself. The subject of regex is much larger than what can be explained in a single chapter in this book.</p><p>Therefore, in this chapter, we will merely introduce some of the concepts of regex. For a deeper understanding of regex, further study is needed. For the purpose of this book, however, we will take a closer look at how regex are created and how they can be applied to some common programming problems. In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting started with regex</li><li class="listitem" style="list-style-type: disc">Matching a valid date</li><li class="listitem" style="list-style-type: disc">Sanitizing input</li><li class="listitem" style="list-style-type: disc">Dynamic regex matching</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Introduction</h1></div></div></div><p>A regex is a <a class="indexterm" id="id666"/>pattern that describes a string through the use of special characters that denote a specific bit of text to match. The use of regex is not a new concept in programming. For regex to work, they need to use a regex engine that does all the heavy lifting.</p><p>In the .NET Framework, Microsoft has provided for the use of regex. To use regex, you will need to import the <code class="literal">System.Text.RegularExpressions</code> assembly to your project. This will allow the compiler to use your regex pattern and apply it to the specific text you need to match.</p><p>Secondly, regex have a specific set of metacharacters that hold special meaning to the Regex engine. These characters are <code class="literal">[ ]</code>, <code class="literal">{ }</code>, <code class="literal">( )</code>, <code class="literal">*</code>, <code class="literal">+</code>, <code class="literal">\</code>, <code class="literal">?</code>, <code class="literal">|</code>, <code class="literal">$</code>, <code class="literal">.</code> and, <code class="literal">^</code>.</p><p>The use of the<a class="indexterm" id="id667"/> curly brackets <code class="literal">{ }</code>, for example, enables developers to specify the number of times a specific set of characters need to occur. Using square brackets, on the other hand, defines exactly what needs to be matched.</p><p>If we, for example, specified <code class="literal">[abc]</code>, the pattern would look for lowercase As, Bs, and Cs. Regex, therefore, also allows you to define a range, for example, <code class="literal">[a-c]</code>, which is interpreted in exactly the same way as the <code class="literal">[abc]</code> pattern.</p><p>Regex then also allow you to define characters to exclude by using the <code class="literal">^</code> character. Therefore, typing <code class="literal">[^a-c]</code> would find lowercase D through Z because the pattern is telling the regex engine to exclude lowercase As, Bs, and Cs.</p><p>Regex also define <code class="literal">\d</code> and <code class="literal">\D</code> as types of shortcut for <code class="literal">[0-9]</code> and <code class="literal">[^0-9]</code>, respectively. Therefore, <code class="literal">\d</code> matches all numeric values, and <code class="literal">\D</code> matches all non-numeric values. Another shortcut is <code class="literal">\w</code> and <code class="literal">\W</code>, which match any character from lowercase A to Z, irrespective of the case, all numeric values from 0 to 9, and the underscore character. Therefore, <code class="literal">\w</code> is <code class="literal">[a-zA-Z0-9_]</code>, while <code class="literal">\W</code> is <code class="literal">[^a-zA-Z0-9_]</code>.</p><p>The basics of regex are rather easy to understand, but there is a lot more that you can do with regex.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Getting started with regex</h1></div></div></div><p>We will be<a class="indexterm" id="id668"/> create a new class in C# called <code class="literal">Chapter9</code>. Here, we will create various methods to illustrate the use of regex.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec167"/>Getting ready</h2></div></div></div><p>For the purpose of this book, we will create a simple console application to illustrate the use of regex. In reality, you would probably not have this logic mixed in with your production code, because this would result in code being rewritten. The best place to add something like regex is in a helper class within an extension method.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec168"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start by right-clicking the solution, going to <strong>Add</strong>, and then to <strong>New Project</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_09_01.jpg"/></div></li><li class="listitem">The <a class="indexterm" id="id669"/><strong>Add New Project</strong> window opens up. Select the <strong>Class Library</strong> project type and call the project <code class="literal">Chapter9</code>:<div><img alt="How to do it…" src="img/B05391_09_02.jpg"/></div></li><li class="listitem">After the<a class="indexterm" id="id670"/> new class file has been added, your <strong>Solution Explorer</strong> should look like this:<div><img alt="How to do it…" src="img/B05391_09_03.jpg"/></div></li><li class="listitem">Right-click<a class="indexterm" id="id671"/> the <code class="literal">Class1.cs</code> file and select <strong>Rename</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_09_04.jpg"/></div></li><li class="listitem">Rename<a class="indexterm" id="id672"/> the <code class="literal">Class1.cs</code> file to <code class="literal">Recipes.cs</code> and select <strong>Yes</strong> from the confirmation dialog:<div><img alt="How to do it…" src="img/B05391_09_05.jpg"/></div></li><li class="listitem">In the <a class="indexterm" id="id673"/>console application, click on the <strong>References</strong> section and select <strong>Add Reference</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_09_06.jpg"/></div></li><li class="listitem">In <strong>Reference</strong><a class="indexterm" id="id674"/><strong> Manager</strong> for the console application, select <code class="literal">Chapter9</code> and click on <strong>OK</strong> to add it as a reference to the console application:<div><img alt="How to do it…" src="img/B05391_09_07.jpg"/></div></li><li class="listitem">In the<a class="indexterm" id="id675"/> <code class="literal">Recipes</code> class, add the following <code class="literal">using</code> statement so that we can use the regex assembly in .NET:<div><pre class="programlisting">using System.Text.RegularExpressions;</pre></div></li><li class="listitem">After you have done all this, your <code class="literal">Chapter9</code> class should look like this:<div><pre class="programlisting">using System.Text.RegularExpressions;
namespace Chapter9
{
    public class Recipes
    {
    }
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec169"/>How it works…</h2></div></div></div><p>We have added a basic class file that will be used to validate regex patterns, which is called from our console application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec71"/>Matching a valid date</h1></div></div></div><p>We will create a regex<a class="indexterm" id="id676"/> to validate a date pattern of yyyy-mm-dd, yyyy/mm/dd, or yyyy.mm.dd. At first, the regex will look daunting, but bear with me. When you have completed the code and run the application, we will dissect the regex. Hopefully, the expression logic will become clear.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec170"/>Getting ready</h2></div></div></div><p>Ensure that you have added the correct assembly to your class. At the top of your code file, add the following line of code if you haven't already done so:</p><div><pre class="programlisting">using System.Text.RegularExpressions;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec171"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new method called <code class="literal">ValidDate()</code> that takes a string as the parameter. This string will be the date pattern we want to validate:<div><pre class="programlisting">public void ValidDate(string stringToMatch)
{

}</pre></div></li><li class="listitem">Add the following regex pattern to your method, to a variable in the method:<div><pre class="programlisting">string pattern = $@"^(19|20)\d\d[-./](0[1-9]|1[0-2])[- ./](0[1-9]|[12][0-9]|3[01])$";</pre></div></li><li class="listitem">Finally, add the regex to match the supplied string parameter:<div><pre class="programlisting">if (Regex.IsMatch(stringToMatch, pattern))
    Console.WriteLine($"The string {stringToMatch} contains a valid date.");
else
    Console.WriteLine($"The string {stringToMatch} DOES NOT contain a valid date.");</pre></div></li><li class="listitem">When you have done this, your method should look like this:<div><pre class="programlisting">public void ValidDate(string stringToMatch)
{
    string pattern = $@"^(19|20)\d\d[-./](0[1-9]|1[0-2])[- ./](0[1-9]|[12][0-9]|3[01])$";

    if (Regex.IsMatch(stringToMatch, pattern))
        Console.WriteLine($"The string {stringToMatch} contains a valid date.");
    else
        Console.WriteLine($"The string {stringToMatch} DOES NOT contain a valid date.");            
}</pre></div></li><li class="listitem">Going back to your console application, add the following code and debug your application by clicking on Start:<div><pre class="programlisting">Chapter9.Recipes oRecipe = new Chapter9.Recipes();
oRecipe.ValidDate("1912-12-31");
oRecipe.ValidDate("2018-01-01");
oRecipe.ValidDate("1800-01-21");
            oRecipe.ValidDate($"{DateTime.Now.Year}.{DateTime.Now.Month }.{DateTime.Now.Day}");
oRecipe.ValidDate("2016-21-12"); 
Read();</pre></div><div><div><h3 class="title"><a id="note33"/>Note</h3><p>You will notice that <code class="literal">Read()</code> is used in the preceding code example instead of <code class="literal">Console.Read()</code>. This is because <code class="literal">using static System.Console</code>; is added to the console application's <code class="literal">using</code> statements. Doing this will allow you to omit the <code class="literal">Console</code> keyword.</p></div></div></li><li class="listitem">The date <a class="indexterm" id="id677"/>strings are passed to the regex, and the pattern is matched against the date string in the parameter. The output is displayed in the console application:<div><img alt="How to do it…" src="img/B05391_09_08.jpg"/></div></li><li class="listitem">If you look at the output carefully, you will notice that there is a mistake. We are validating the date string in the format yyyy-mm-dd, yyyy/mm/dd, and yyyy.mm.dd. If we use this logic, our regex has incorrectly flagged a valid date as invalid. This is the date <code class="literal">2016.4.10</code>, which is 10 April, 2016, and is in fact quite valid.<div><div><h3 class="title"><a id="note34"/>Note</h3><p>We will explain shortly why the date <code class="literal">1800-01-21</code> is invalid.</p></div></div></li><li class="listitem">Go back to your <code class="literal">ValidDate()</code> method and change the regular expression to read as follows:<div><pre class="programlisting">string pattern = $@"^(19|20)\d\d[-./](0[1-9]|1[0-2]|[1- 9])[-./](0[1-9]|[12][0-9]|3[01])$";</pre></div></li><li class="listitem">Run the console application again and look at the output:<div><img alt="How to do it…" src="img/B05391_09_09.jpg"/></div></li></ol></div><p>This time the regex <a class="indexterm" id="id678"/>worked for all the given date strings. But what exactly did we do? This is how it works.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec172"/>How it works…</h2></div></div></div><p>Let's take a closer look at the two expressions used in the previous code example. Comparing them with each other, you can see the change we made in yellow:</p><div><img alt="How it works…" src="img/B05391_09_10.jpg"/></div><p>Before we get to what that change means, let's break up the expression and view the individual components. Our regex is basically saying that we must match all string dates that start with 19 or 20 and have the following separators:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dash (<code class="literal">-</code>)</li><li class="listitem" style="list-style-type: disc">Decimal (<code class="literal">.</code>)</li><li class="listitem" style="list-style-type: disc">Forward slash (<code class="literal">/</code>)</li></ul></div><p>To understand the expression better, we need to understand the following format of the expression <em>&lt;Valid Years&gt;&lt;Valid Separators&gt;&lt;Valid Months&gt;&lt;Valid Separators&gt;&lt;Valid Days&gt;</em>.</p><p>We also need to be<a class="indexterm" id="id679"/> able to tell the regex engine to consider one OR another pattern. The word OR is symbolised by the <code class="literal">|</code> metacharacter. To make the regex engine consider the word OR without splitting up the whole expression, we wrap it in parenthesis <code class="literal">()</code>.</p><p>Here are the symbols used in the regex:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="2" style="text-align: center" valign="bottom">
<p>The conditional OR </p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">|</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This denotes the <a class="indexterm" id="id680"/>OR metacharacter.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>The year portion</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">(19|20)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Only allow 19<a class="indexterm" id="id681"/> or 20.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">\d\d</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match two single digits between 0 and 9. To match only one digit between 0 and 9, you would use <code class="literal">\d</code>.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>The valid separator character set</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[-./]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any <a class="indexterm" id="id682"/>of the following characters in the character set. These are our valid separators. To match a space date separator, you would change this to <code class="literal">[- ./]</code>, where you add a space anywhere in the character set. We added the space between the dash and the decimal.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>Valid digits for months and days</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">0[1-9]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any<a class="indexterm" id="id683"/> part starting with zero followed by any digit between 1 and 9. This will match 01, 02, 03, 04, 05, 06, 07, 08, and 09.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">1[0-2]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any part starting with 1 followed by any digit between 0 and 2. This will match 10, 11, or 12.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[1-9]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any digit between 1 and 9.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[12][0-9]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any part starting with 1 or 2, followed by any digit between 0 and 9. This will match all number strings between 10 and 29.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">3[01]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any part starting with 3 and followed by 0 or 1. This will match 30 or 31.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>Start and end of string</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">^</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tells the<a class="indexterm" id="id684"/> regex engine to start at the beginning of the given string to match.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tells the regex engine to stop at the end of the given string to match.</p>
</td></tr></tbody></table></div><p>The first regex we <a class="indexterm" id="id685"/>created, interprets as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">^</code>: Start at the beginning of the string to match</li><li class="listitem" style="list-style-type: disc"><code class="literal">(19|20)</code>: Check whether the string starts with 19 or 20</li><li class="listitem" style="list-style-type: disc"><code class="literal">\d\d</code>: After the check, follows two single digits between 0 and 9</li><li class="listitem" style="list-style-type: disc"><code class="literal">[-./]</code>: The year portion ends followed by a date separator</li><li class="listitem" style="list-style-type: disc"><code class="literal">(0[1-9]|1[0-2])</code>: Find the month logic by looking for digits starting with 0, followed by any digit between 1 and 9, or digits starting with 1, followed by any digit between 0 and 2</li><li class="listitem" style="list-style-type: disc"><code class="literal">[-./]</code>: The month logic ends, followed by a date separator</li><li class="listitem" style="list-style-type: disc"><code class="literal">(0[1-9]|[12][0-9]|3[01])</code>: Then, find the day logic by looking for digits starting with 0, followed by a digit between 1 and 9, or digits starting with 1 or 2, followed by any digit between 0 and 9, or a digit matching 3, followed by any digit between 0 and 1</li><li class="listitem" style="list-style-type: disc"><code class="literal">$</code>: Do this until the end of the string</li></ul></div><p>Our first regex was incorrect because our month logic was incorrect. Our month logic dictates to find the month logic by looking for digits starting with a 0 followed by any digit between 1 and 9, or digits starting with a 1 followed by any digit between 0 and 2 <code class="literal">(0[1-9]|1[0-2])</code>.</p><p>This will then find 01, 02, 03, 04, 05, 06, 07, 08, 09 or 10, 11, 12. The date that it didn't match was <code class="literal">2016.4.10</code> (the date separators don't make a difference here). This is because our month came through as a single digit, and we were looking for months where the single digits started with a zero. To fix this, we had to modify the expression of the month logic to include single digits between 1 and 9. We did this by adding <code class="literal">[1-9]</code> to the expression at the end.</p><p>The modified regex then reads as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">^</code>: Start at the beginning of the string to match.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(19|20)</code>: Check whether the string starts with 19 or 20.</li><li class="listitem" style="list-style-type: disc"><code class="literal">\d\d</code>: After the check, follows two single digits between 0 and 9.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[-./]</code>: The year portion ends, followed by a date separator</li><li class="listitem" style="list-style-type: disc"><code class="literal">(0[1-9]|1[0-2])</code>: Find the month logic by looking for digits starting with 0, followed by any digit between 1 and 9, or digits starting with 1, followed by any digit between 0 and 2, or any single digits between 1 and 9</li><li class="listitem" style="list-style-type: disc"><code class="literal">[-./]</code>: The month logic ends, followed by a date separator</li><li class="listitem" style="list-style-type: disc"><code class="literal">(0[1-9]|[12][0-9]|3[01])</code>: Then, find the day logic by looking for digits starting with 0, followed by a digit between 1 and 9, or digits starting with 1 or 2, followed by any digit between 0 and 9, or a digit matching 3, followed by any digit between 0 and 1</li><li class="listitem" style="list-style-type: disc"><code class="literal">$</code>: Do this until the end of the string</li></ul></div><p>This is a basic regex, and<a class="indexterm" id="id686"/> we say basic because there is a lot more we can do to make the expression better. We can include logic to consider alternative date formats such as mm-dd-yyyy or dd-mm-yyyy. We can add logic to check February and validate that it contains only 28 days, unless it is a leap year, in which case we need to allow the twenty-ninth day of February. Furthermore, we can also extend the regex to check that January, March, May, July, August, October, and December have 31 days while April, June, September, and November contain only 30 days.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Sanitizing input</h1></div></div></div><p>Sometimes, you will<a class="indexterm" id="id687"/> need to sanitize input. This could be to prevent SQL injections or ensure that an entered URL is valid. In this recipe, we will look at replacing the bad words in a string with asterisks. We are sure that there are more elegant and code-efficient methods of writing sanitation logic using regex (especially when we have a large collection of blacklist words), but we want to illustrate a concept here.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec173"/>Getting ready</h2></div></div></div><p>Ensure that you have added the correct assembly to your class. At the top of your code file, add the following line of code if you haven't done so already:</p><div><pre class="programlisting">using System.Text.RegularExpressions;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec174"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new method in your <code class="literal">Recipes.cs</code> class called <code class="literal">SanitizeInput()</code> and let it accept a string parameter:<div><pre class="programlisting">public string SanitizeInput(string input)
{
                
}</pre></div></li><li class="listitem">Add a list of type <code class="literal">List&lt;string&gt;</code> to the method that contains the bad words we want to remove from the input:<div><pre class="programlisting">List&lt;string&gt; lstBad = new List&lt;string&gt;(new string[] { "BadWord1", "BadWord2", "BadWord3" });</pre></div><div><div><h3 class="title"><a id="note35"/>Note</h3><p>In reality, you might make use of a database call to read the blacklisted words from a table in the database. You would usually not hardcode them in a list like this.</p></div></div></li><li class="listitem">Start constructing<a class="indexterm" id="id688"/> the regex that we will use to look for the blacklisted words. Concatenate the words with the <code class="literal">|</code> (OR) metacharacter so that the regex will match any of the words. When the list is complete, you can append the <code class="literal">\b</code> expression to either side of the regex. This denotes a word boundary and, therefore, will only match whole words:<div><pre class="programlisting">string pattern = "";
foreach (string badWord in lstBad)
    pattern += pattern.Length == 0 ? $"{badWord}" : $"|{badWord}";

pattern = $@"\b({pattern})\b";</pre></div></li><li class="listitem">Finally, we will add the <code class="literal">Regex.Replace()</code> method that takes the input and looks for the occurrence of the words defined in the pattern, while ignoring case and replacing the bad words with <code class="literal">*****</code>:<div><pre class="programlisting">return Regex.Replace(input, pattern, "*****", RegexOptions.IgnoreCase);</pre></div></li><li class="listitem">When you have completed this, your <code class="literal">SanitizeInput()</code> method will look like this:<div><pre class="programlisting">public string SanitizeInput(string input)
{
    List&lt;string&gt; lstBad = new List&lt;string&gt;(new string[] { "BadWord1", "BadWord2", "BadWord3" });
    string pattern = "";
    foreach (string badWord in lstBad)
        pattern += pattern.Length == 0 ? $"{badWord}" : $"|{badWord}";

    pattern = $@"\b({pattern})\b";

    return Regex.Replace(input, pattern, "*****", RegexOptions.IgnoreCase);            
}</pre></div></li><li class="listitem">In the console application, add the following code to call the <code class="literal">SanitizeInput()</code> method and run your application:<div><pre class="programlisting">string textToSanitize = "This is a string that contains a badword1, another Badword2 and a third badWord3";
Chapter9.Recipes oRecipe = new Chapter9.Recipes();
textToSanitize = oRecipe.SanitizeInput(textToSanitize);
WriteLine(textToSanitize);
Read();</pre></div></li><li class="listitem">When you run<a class="indexterm" id="id689"/> your application, you will see the following in the console window:<div><img alt="How to do it…" src="img/B05391_09_11.jpg"/></div></li></ol></div><p>Let's take a closer look at the regular expression generated.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec175"/>How it works…</h2></div></div></div><p>Let's step through the code to understand what is happening. We need to get a regex that looks like this: <code class="literal">\b(wordToMatch1|wordToMatch2|wordToMatch3)\b</code>.</p><p>What this basically says is find me any of the words and only whole words that are denoted by <code class="literal">\b</code>. When we look at the list we created, we will see the words we want to remove from the input string:</p><div><img alt="How it works…" src="img/B05391_09_12.jpg"/></div><p>We then created a<a class="indexterm" id="id690"/> simple loop that will create the list of words to match using the OR metacharacter. We ended up with a <code class="literal">BadWord1|BadWord2|BadWord3</code> pattern after the <code class="literal">foreach</code> loop has completed. However, this is still not a valid regex:</p><div><img alt="How it works…" src="img/B05391_09_13.jpg"/></div><p>To complete the pattern resulting in the valid regex, we need to add the <code class="literal">\b</code> expression on either side of the pattern to tell the regex engine to only match whole words. As you can see, we are using string interpolation. String interpolation is covered in detail in <a class="link" href="ch01.html" title="Chapter 1. New Features in C# 6.0">Chapter 1</a>, <em>New Features in C#6</em>.</p><p>It is here, however, that we need to be very careful. Start off by writing the code to complete the pattern without the <code class="literal">@</code> sign, as follows:</p><div><pre class="programlisting">pattern = $"\b({pattern})\b";</pre></div><p>If you run your console <a class="indexterm" id="id691"/>application, you will see that the bad words are not matched and filtered out. This is because we have not escaped the <code class="literal">\</code> character before <code class="literal">b</code>. The compiler, therefore, interprets this line of code:</p><div><img alt="How it works…" src="img/B05391_09_17.jpg"/></div><p>The generated expression <code class="literal">[](BadWord1| BadWord2| BadWord3)[]</code> is not a valid expression and will therefore not sanitize the input string.</p><p>To correct this, we need to add the <code class="literal">@</code> symbol before the string to tell the compiler to treat the string as a literal. This means any escape sequences are ignored. The correctly formatted line of code looks like this:</p><div><pre class="programlisting">pattern = $@"\b({pattern})\b";</pre></div><p>Once you do this, the string for the pattern is interpreted literally by the compiler, and the correct regex pattern generated:</p><div><img alt="How it works…" src="img/B05391_09_14.jpg"/></div><p>With our correct regex<a class="indexterm" id="id692"/> pattern, we called the <code class="literal">Regex.Replace()</code> method. It takes the input to check, the regex to match, the text to replace the matched words with, and optionally allows for the ignoring of case:</p><div><img alt="How it works…" src="img/B05391_09_15.jpg"/></div><p>When the string<a class="indexterm" id="id693"/> returns to the calling code in the console application, the string will be sanitized properly:</p><div><img alt="How it works…" src="img/B05391_09_16.jpg"/></div><p>Regex can become quite<a class="indexterm" id="id694"/> complex and can be used to perform a multitude of tasks to format and validate input and other text.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Dynamic regex matching</h1></div></div></div><p>What does dynamic regex matching<a class="indexterm" id="id695"/> even mean? Well, it isn't an official term, but it is a term we use to explain a Regex that uses variables at runtime to generate a specific expression. Assume for a minute that you are working on a document-management system that needs to implement versioning of documents for a company called Acme Corporation. To do this, the system validates that the document has a valid file name.</p><p>A business rule states that the file name of any file uploaded on a specific day must be prefixed with <code class="literal">acm</code> (for Acme) and today's date in the yyyy-mm-dd format. There can be only text files, Word documents (only <code class="literal">.docx</code>), and Excel documents (only <code class="literal">.xlsx</code>). Any documents not conforming to this file format are processed by another method that takes care of archive and invalid documents.</p><p>The only task that your method needs to perform is to process fresh documents as version one documents.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>In a production system, further logic will probably be needed to determine whether the same document has been uploaded previously on the same day. This, however, is beyond the scope of this chapter. We are just trying to set the scene.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec176"/>Getting ready</h2></div></div></div><p>Ensure that you have<a class="indexterm" id="id696"/> added the correct assembly to your class. At the top of your code file, add the following line of code if you haven't already done so:</p><div><pre class="programlisting">using System.Text.RegularExpressions;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec177"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">A really nice way to do this<a class="indexterm" id="id697"/> is to use an extension method. This way, you can call the extension method directly on the file name variable and have it validated. In your <code class="literal">Recipes.cs</code> file, start off by adding a new class called <code class="literal">CustomRegexHelper</code> with the <code class="literal">public static</code> modifier:<div><pre class="programlisting">public static class CustomRegexHelper
{
    

}</pre></div></li><li class="listitem">Add the usual extension method code to the <code class="literal">CustomRegexHelper</code> class and call the <code class="literal">ValidAcmeCompanyFilename</code> method:<div><pre class="programlisting">public static bool ValidAcmeCompanyFilename(this String value)
{
        
}</pre></div></li><li class="listitem">Inside your <code class="literal">ValidAcmeCompanyFilename</code> method, add the following regex. We will explain the makeup of this regex in the <em>How it works…</em> section of this recipe:<div><pre class="programlisting">return Regex.IsMatch(value, $@"^acm[_]{DateTime.Now.Year}[_]({DateTime.Now.Month}|0[{Da teTime.Now.Month}])[_]({DateTime.Now.Day}|0[{DateTime.Now.D ay}])(.txt|.docx|.xlsx)$");</pre></div></li><li class="listitem">When you have completed this, your extension method should look like this:<div><pre class="programlisting">public static class CustomRegexHelper
{
    public static bool ValidAcmeCompanyFilename(this String value)
    {
        return Regex.IsMatch(value, $@"^acm[_]{DateTime.Now.Year}[_] ({DateTime.Now.Month}|0[{DateTime.Now.Month}]) [_]({DateTime.Now.Day}|0[{DateTime.Now.Day}]) (.txt|.docx|.xlsx)$");
    }
}</pre></div></li><li class="listitem">Back in the <code class="literal">Recipes</code> class, create a method with the <code class="literal">void</code> return type called <code class="literal">DemoExtendionMethod()</code>:<div><pre class="programlisting">public void DemoExtendionMethod()
{
    
}</pre></div></li><li class="listitem">Add some output<a class="indexterm" id="id698"/> text to show the current date and the valid file name types:<div><pre class="programlisting">Console.WriteLine($"Today's date is: {DateTime.Now.Year}- {DateTime.Now.Month}-{DateTime.Now.Day}");
Console.WriteLine($"The file must match: acm_{DateTime.Now.Year}_{DateTime.Now.Month}_{DateTime.Now. Day}.txt including leading month and day zeros");
Console.WriteLine($"The file must match: acm_{DateTime.Now.Year}_{DateTime.Now.Month}_{DateTime.Now. Day}.docx including leading month and day zeros");
Console.WriteLine($"The file must match: acm_{DateTime.Now.Year}_{DateTime.Now.Month}_{DateTime.Now. Day}.xlsx including leading month and day zeros");</pre></div></li><li class="listitem">Then, add the file name checking code:<div><pre class="programlisting">string filename = "acm_2016_04_10.txt";
if (filename.ValidAcmeCompanyFilename())
    Console.WriteLine($"{filename} is a valid file name");
else
    Console.WriteLine($"{filename} is not a valid file name");

filename = "acm-2016_04_10.txt";
if (filename.ValidAcmeCompanyFilename())
    Console.WriteLine($"{filename} is a valid file name");
else
    Console.WriteLine($"{filename} is not a valid file name");</pre></div></li><li class="listitem">You will notice that the <code class="literal">if</code> statement contains the call to the extension method on the variable that contains the file name:<div><pre class="programlisting">filename.ValidAcmeCompanyFilename()</pre></div></li><li class="listitem">If you have completed this, your method should look like this:<div><pre class="programlisting">public void DemoExtendionMethod()
{
    Console.WriteLine($"Today's date is: {DateTime.Now.Year}-{DateTime.Now.Month}- {DateTime.Now.Day}");
    Console.WriteLine($"The file must match: acm_{DateTime.Now.Year}_{DateTime.Now.Month}_ {DateTime.Now.Day}.txt including leading month and day zeros");
    Console.WriteLine($"The file must match: acm_{DateTime.Now.Year}_{DateTime.Now.Month}_ {DateTime.Now.Day}.docx including leading month and day zeros");
    Console.WriteLine($"The file must match: acm_{DateTime.Now.Year}_{DateTime.Now.Month} _{DateTime.Now.Day}.xlsx including leading month and day zeros");

    string filename = "acm_2016_04_10.txt";
    if (filename.ValidAcmeCompanyFilename())
        Console.WriteLine($"{filename} is a valid file name");
    else
        Console.WriteLine($"{filename} is not a valid file name");

    filename = "acm-2016_04_10.txt";
    if (filename.ValidAcmeCompanyFilename())
        Console.WriteLine($"{filename} is a valid file name");
    else
        Console.WriteLine($"{filename} is not a valid file name");
}</pre></div></li><li class="listitem">Going back to the <a class="indexterm" id="id699"/>console application, add the following code that simply just calls the <code class="literal">void</code> method. This is just to simulate the versioning method talked about earlier:<div><pre class="programlisting">Chapter9.Recipes oRecipe = new Chapter9.Recipes();
oRecipe.DemoExtendionMethod();
Read();</pre></div></li><li class="listitem">When you are done, run your console application:<div><img alt="How to do it…" src="img/B05391_09_18.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec178"/>How it works…</h2></div></div></div><p>Let's have a closer look<a class="indexterm" id="id700"/> at the regex generated. The line of code we are looking at is the <code class="literal">return</code> statement in the extension method:</p><div><pre class="programlisting">return Regex.IsMatch(value, $@"^acm[_]{DateTime.Now.Year}[_]({DateTime.Now.Month}|0[{DateTime. Now.Month}])[_]({DateTime.Now.Day}|0[{DateTime.Now.Day}])(.txt|.do cx|.xlsx)$");</pre></div><p>To appreciate what is happening, we need to break this expression up into the different components:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="2" style="text-align: center" valign="bottom">
<p>The conditional OR </p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">|</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This denotes the OR metacharacter.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>The file prefix and separator</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">acm</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The file must begin with the text <code class="literal">acm</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[_]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The only valid separator between the date components and the prefix in the file name is an underscore.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>The date parts</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">{DateTime.Now.Year}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The interpolated year part of the date for the file name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">{DateTime.Now.Month}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The interpolated month part of the date for the file name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">0[{DateTime.Now.Month}]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The interpolated month part of the date with a leading zero for the file name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">{DateTime.Now.Day}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The interpolated day part of the date for the file name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">0[{DateTime.Now.Day}]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The interpolated day part of the date with a leading zero for the file name.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>Valid file formats</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">(.txt|.docx|.xlsx)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Match any of these file extensions for text documents, Word documents, or Excel documents.</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<strong>Start and end of string</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">^</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tells the regex engine to start at the beginning of the given string to match.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tells the regex engine to stop at the end of the given string to match.</p>
</td></tr></tbody></table></div><p>Creating the regex in this<a class="indexterm" id="id701"/> manner allows us to always have it stay up to date. As we have to always match the current date to the file being validated, this creates a unique challenge that is easily overcome using string interpolation, <code class="literal">DateTime</code>, and regex OR statements.</p><p>Having a look at some of the more useful bits of regex, you will see that this chapter has not even begun to scratch the surface of what can be accomplished. There is a whole lot more to explore and learn. There are many resources on the Internet, as well as some free (some online) and commercial tools that will assist you in creating regex.</p></div></div></body></html>