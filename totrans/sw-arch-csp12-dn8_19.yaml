- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Client Frameworks: Blazor'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement presentation layers based on
    client technologies. Applications based on server technologies, like ASP.NET Core
    MVC, run all application layers on the server, thus also creating on the server
    the HTML that encodes the whole UI. Applications based on client technologies,
    instead, run the whole presentation layer on the client machine (mobile device,
    desktop computer, laptop, etc.) thus interacting with a server just to exchange
    data with the web API.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, in an application based on client technology, the whole UI is
    created by code that runs on the user device, which also controls the whole user-application
    interaction. Both the business layer and the domain layer, instead, run on server
    machines to prevent users from violating business rules and authorization policies
    by hacking the code that runs on their devices.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, applications based on client technologies can be classified as single-page
    applications, which benefit from web standards, or as native applications, which
    are tied to specific operating systems and the advantages of specific device peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: Single-page applications are based on JavaScript or WebAssembly and run in any
    browser. As an example of a single-page application, we will analyze the Blazor
    WebAssembly framework
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly applications are developed in C# and use many technologies
    we already analyzed in *Chapter 17*, *Presenting ASP.NET Core*, such as dependency
    injection and Razor. Therefore, we strongly recommend studying *Chapter 17*, *Presenting
    ASP.NET Core*, and *Chapter 18*, *Implementing Frontend Microservices with ASP.NET
    Core*, before reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of native technologies, we will analyze native .NET MAUI Blazor,
    which is completely analogous to Blazor WebAssembly but instead of using browser
    WebAssembly, it uses .NET, which is compiled just in time into the assembly of
    the target device. Not being limited by browser restrictions, .NET MAUI Blazor
    can access all device features through adequate .NET libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of the various types of client technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor WebAssembly architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor pages and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor forms and validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor advanced features, such as JavaScript interoperability, globalization,
    authentication, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party tools for Blazor WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET MAUI Blazor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there is also server-side Blazor, which runs on the server like ASP.NET
    Core MVC, this chapter discusses just Blazor WebAssembly and .NET MAUI Blazor,
    since the main focus of the chapter is client-side technology. Moreover, server-side
    Blazor can’t provide a performance that is comparable with other server-side technologies,
    like ASP.NET Core MVC, which we analyzed in *Chapter 17*, *Presenting ASP.NET
    Core*.
  prefs: []
  type: TYPE_NORMAL
- en: The first section summarizes and compares the various kinds of client technologies,
    while the remainder of the chapter discusses in detail Blazor WebAssembly and
    .NET MAUI Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2022 Community edition or better
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: All concepts are clarified with simple example applications based on the WWTravelClub
    book use case you can find in the *Using client technologies* section of *Chapter
    21*, *Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of the various types of client technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section discusses the various types of client technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-page applications, which run in the browser with all browser restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive applications, which run in the browser but can be installed like
    usual applications and can overcome some browser restrictions (after user permission
    is granted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native applications, which are tied to a specific device/operating system but
    can take full advantage of all device/operating system features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform technologies, which, like native applications, can take full
    advantage of all device features but are compatible with several devices/operating
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-page applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many reasons why web development has increased in recent decades,
    but the most basic one is the ability to deploy any new version of the application
    to many users at the same time. Moreover, the security policies that are automatically
    enforced by all browsers encourage the usage and diffusion of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: So, a good question here would be, why is web development not used today? The
    best answer would be a lack of connectivity. As a software architect, you need
    to be alert to this, as we discussed in *Chapter 2*, *Non-Functional Requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is not only a matter of having connectivity or not. Sometimes,
    a big problem is instability, and don’t forget the difficulties you will encounter
    from unexpected scenarios that web apps will generate once they’re out in the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the WWTravelClub case, there is a first user story that says:
    *“As a common user, I want to view promotional packages on the home page, so that
    I can easily find my next vacation.”* At first sight, you may determine that a
    web app is the only option, especially because there is also a system requirement
    that says: *“The system will run on the Windows, Linux, iOS, and Android platforms.”*'
  prefs: []
  type: TYPE_NORMAL
- en: However, imagine that a user browsed a lot of destinations and packages to find
    their perfect vacation, and they are going to reserve it when suddenly, the web
    application crashes because of a lack of web connectivity. In this situation,
    the user would lose all their browsing effort and would be forced to start searching
    for the package from scratch once web connectivity is restored. The issue can
    be overcome just with an application that is able to save its state instead of
    crashing when there are web connectivity issues. This way, the user can complete
    their task as soon as web connectivity is restored, without wasting whatever effort
    they had already put in before the web connectivity issue.
  prefs: []
  type: TYPE_NORMAL
- en: So maybe, for some parts of the solution, a native application with some data
    already downloaded would be a better option. However, the issue can also be solved
    with a particular kind of modern web application, progressive applications, which
    we will analyze in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Progressive web applications are single-page applications that run in the browser
    but can be installed like native applications. Moreover, they can run offline.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive applications are a new web standard that is supported by all mainstream
    browsers. If you require all the advantages of web applications, but you also
    need the ability to work offline like a native application, progressive web applications
    are the right choice for you.
  prefs: []
  type: TYPE_NORMAL
- en: However, keep in mind that progressive web applications can’t ensure the same
    performance and flexibility as native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly, as we will describe in the next sections of this chapter,
    supports progressive web applications. Check the **Progressive Web Application**
    checkbox that appears when you create a Blazor WebAssembly project. This is all
    you need to do to create a Blazor progressive web application.
  prefs: []
  type: TYPE_NORMAL
- en: If you ship your Blazor application as a progressive application, you overcome
    the problem of the initial download time (4-8 seconds), which is the main disadvantage
    of Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: While progressive web applications are installed applications, they automatically
    update to the last available version, because each time they are launched, they
    verify if a more recent version is available, and if there is one, they automatically
    download it before running. That is, they have the advantage of automatically
    running the most recent available version that characterizes all classical web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The option to install the Blazor progressive web application is not available
    during development because this would interfere with the usual modification test
    cycle. Therefore, you need to publish your application to test its progressive
    application peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that progressive applications must be organized to
    take full advantage of their ability to work offline. Therefore, following repeated
    communication errors, the application should save all the data to be sent to the
    server in the browser’s local storage while waiting for a connection to be established
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to maintain the whole application state in a centralized
    service so that the user can serialize and save it to local storage before quitting
    the application. This way, when the application is offline, data to be sent to
    the server is not lost because it remains in the application state that is saved
    to disk.
  prefs: []
  type: TYPE_NORMAL
- en: When a progressive web application doesn’t fulfill your requirements because
    it is not able to use the specific device features you need, but you must support
    several different devices, you should consider cross-platform native applications,
    which have full access to all device features but can still support several hardware/software
    platforms. We will discuss them in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Native applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Native development can be considered the beginning of UI development. There
    was no concept of sharing code between machines with diverse hardware when the
    idea of assigning software production to another person/company originally emerged.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first good answer as to why we have good performance on native applications.
    We cannot forget that native apps run better just because they are near the hardware,
    most of the time connected to the OS directly or by using a framework, such as
    .NET. Be careful; we are not only talking about native mobile apps, but we are
    also discussing apps delivered in Windows, Linux, Mac, Android, or any other OS
    that can run apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering this scenario, the big question is – when do I have to use a native
    app? There are some cases where this would be a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to deploy on different platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a huge connection to the hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance provided by a web client is not acceptable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application needs device resources that can’t be accessed through a browser
    because of a browser’s security policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The place where the application will run has connectivity problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The worst case is the one where you need two things at the same time: better
    performance than a web client and different platforms. In this scenario, you will
    probably have to deliver two applications, and the way you have designed the backend
    of this solution will be extremely important for reducing maintenance and costs
    as regards development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision between developing native or not can be difficult to take without
    a **proof of concept** (**POC**). As a software architect, you should be the one
    to recommend this kind of POC.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of native applications that you can develop with C# are the classical
    Windows Forms and Windows Presentation Foundation, which are specific to the Windows
    operating system. Also, there is Xamarin, a platform that allows for the development
    of applications that can be published on both Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although performance can be a difficult requirement to achieve, in many scenarios,
    due to the simplicity of the solution, this is not the Achilles’ heel of the application.
    Considering WWTravelClub, although it would be useful to have the offline experience
    mentioned before, the performance itself is not the most difficult one to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: In these scenarios, cross-platform technologies make total sense. Among them,
    it is worth mentioning Xamarin.Forms and the new .NET MAUI, which can be published
    on Android, iOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The advised choice of cross-platform application is .NET MAUI. However, at the
    moment, MAUI supports Windows and all main mobile platforms but not Linux. Uno
    Platform ([https://platform.uno/](https://platform.uno/)) also supports Linux
    together with all main mobile platforms but is not a Microsoft product maintained
    by Microsoft. Anyway, it can be downloaded as a Visual Studio extension.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will not analyze Uno or all the options offered by .NET
    MAUI but just .NET MAUI Blazor since it is very similar to Blazor WebAssembly.
    So, learning Blazor enables us to develop single-page applications, progressive
    applications, and cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI Blazor is described in the *.NET MAUI Blazor* section of this chapter,
    while the next section describes the basics of Blazor WebAssembly architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor WebAssembly uses the new WebAssembly browser feature to execute the .NET
    runtime in the browser. This way, it enables all developers to use the whole .NET
    code base and ecosystem in the implementation of applications capable of running
    in any WebAssembly-compliant browser. WebAssembly was conceived as a high-performance
    alternative to JavaScript. It is an assembly capable of running in a browser and
    obeying the same limitations as JavaScript code. This means that WebAssembly code,
    like JavaScript code, runs in an isolated execution environment that has very
    limited access to all machine resources.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly differs from similar options from the past, like Flash and Silverlight,
    since it is an official W3C standard. More specifically, it became an official
    standard on December 5, 2019, so it is expected to have a long life. As a matter
    of fact, all mainstream browsers already support it.
  prefs: []
  type: TYPE_NORMAL
- en: However, WebAssembly doesn’t bring just performance with it; it also creates
    the opportunity to run whole code bases associated with modern and advanced object-oriented
    languages such as C++ (direct compilation), Java (bytecode), and C# (.NET) in
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, Microsoft offers two frameworks that run .NET on top of WebAssembly,
    Blazor WebAssembly and Unity WebAssembly, which is the WebAssembly port of the
    Unity 3D graphic framework. Unity WebAssembly’s main purpose is the implementation
    of online video games that run in the browser, while Blazor WebAssembly is a **single-page
    application** framework that uses .NET instead of JavaScript or TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Before WebAssembly, presentation layers running in a browser could only be implemented
    in JavaScript, with all the problems associated with the maintenance of big code
    bases implemented in a language that is not strictly typed. However, we must consider
    that on one hand, the usage of TypeScript in part solves JavaScript’s lack of
    strict typing, and on the other hand, .NET brings with it the problem of the binary
    compatibility of modules implemented with different .NET versions.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, with Blazor C#, developers can now implement complex applications in
    their favorite language, with all the comforts offered to this language by the
    C# compiler and Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, with Blazor, all .NET developers can use the full power of the .NET
    framework, with the only limitations imposed by the browser security policies,
    for the implementation of presentation layers that run in the browser and that
    share libraries and classes with all other layers that run on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The subsections that follow describe all the Blazor architectures. The first
    subsection explores the general concept of a single-page application, describing
    Blazor’s peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: What is a single-page application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **single-page application** (**SPA**) is an HTML-based application, where
    the HTML is changed by code that runs in the browser instead of issuing a new
    request to the server and rendering a new HTML page from scratch. SPAs can simulate
    a multi-page experience by replacing complete page areas with new HTML.
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks are frameworks explicitly designed for implementing SPAs. Before
    WebAssembly, all SPA frameworks were based on JavaScript. The most famous JavaScript-based
    SPA frameworks are Angular, React.js, and Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: All SPA frameworks provide ways to transform data into HTML to show to the user
    and rely on a module called *router* to simulate page changes. Typically, data
    fills in the placeholders of HTML templates and selects which parts of a template
    to render (`if-like` constructs) and how many times to render it (`for-like` constructs).
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor template language is Razor, which we described in *Chapter 17*, *Presenting
    ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to increase modularity, code is organized into components, which are
    a kind of virtual HTML tag that, once rendered, generates actual HTML markup.
    Like HTML tags, components have attributes, which are usually called parameters,
    and custom events. It is up to the developer to ensure that each component uses
    its parameters to create proper HTML and to ensure that it generates adequate
    events. Components can be used inside other components in a hierarchical fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Components can be associated with URLs in the application web domain, in which
    case they are called pages. These URLs can be used in the usual HTML links and
    following them leads to the upload of the page into an application area thanks
    to framework services called routers.
  prefs: []
  type: TYPE_NORMAL
- en: Some SPA frameworks also provide a predefined dependency injection engine in
    order to ensure better separation between components on one side and general-purpose
    services plus business code that runs in the browser on the other. Among the frameworks
    listed in this subsection, only Blazor and Angular have an out-of-the-box dependency
    injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: In order to reduce the overall application file size, SPA frameworks based on
    JavaScript usually compile all JavaScript code in a few JavaScript files and then
    perform so-called tree-shaking, that is, the removal of all unused code. This
    technique sensibly reduces the application load time.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, instead, Blazor keeps all DLLs referenced by the main application
    separate and performs tree-shaking on each of them separately.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the Blazor architecture. We challenge you to create
    a Blazor WebAssembly project called `BlazorReview`, so you can inspect the code
    and the constructs explained throughout the chapter. To do this, select the **Blazor
    WebAssembly Standalone Application**option when creating a new project. Make sure
    to select **Individual Accounts** as the authentication type and ensure that the
    **Include sample pages** checkbox is checked, as shown in the picture below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_19_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.1: Creating the BlazorReview application'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start the application, the application works properly, but if you try
    to log in, the following error message will appear: “There was an error trying
    to log you in: ‘Network Error’.” This is because you need to configure an identity-provider-authenticated
    user. As the default, the application is configured to use an OAuth-based identity
    provider web application. You need to just add the provider configuration data
    in a configuration file. We will look at this in more detail in the *Authentication
    and authorization* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading and starting the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The folder structure of a Blazor WebAssembly application always includes an
    `index.html` static HTML page. In our `BlazorReview` project, `index.html` is
    in `BlazorReview->wwwroot->index.html`. This page is the container where the Blazor
    application will create its HTML. It contains an HTML header with a `viewport
    meta` declaration, the title, and CSS for the application’s overall styling. The
    Visual Studio default project template adds an application-specific CSS file and
    Bootstrap CSS, with a neutral style. You can replace the default Bootstrap CSS
    either with a customized style or a completely different CSS framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body contains the code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The initial `div` with the `app` `id` is where the application will place the
    code it generates. Any markup placed inside this `div` will appear just while
    the Blazor application is loading and starting, then it will be replaced by the
    application-generated HTML. As the default, it contains an `svg` image and text
    that shows the loading progress, which are both controlled by the JavaScript code
    that takes care of loading the framework. The loading animation is based on a
    CSS animation contained in the `css/app.css` main application CSS file. However,
    you can replace both the default content and the CSS animation.
  prefs: []
  type: TYPE_NORMAL
- en: The second `div` is normally invisible and appears only when Blazor intercepts
    an unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`blazor.webassembly.js` contains the JavaScript part of the Blazor framework.
    Among other things, it takes care of downloading the .NET runtime, together with
    all application DLLs. More specifically, `blazor.webassembly.js` downloads the
    `blazor.boot.json` file, which lists all application files with their hashes.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, `blazor.webassembly.js` downloads all resources listed in this file and
    verifies their hashes. All resources downloaded by `blazor.webassembly.js` are
    created when the application is built or published. Loading `blazor.webassembly.js`
    periodically updates the `--blazor-load-percentage` and `--blazor-load-percentage-text`
    CSS variables with the loading percentage in numeric format and as text, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthenticationService.js` is added only when the project enables authentication
    and takes care of the `OpenID Connect` protocol used by Blazor to exploit other
    identity providers, to get bearer tokens, which are the preferred authentication
    credentials for clients that interact with a server through web APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is discussed in more detail in the *Authentication and authorization*
    subsection later on in this chapter, while bearer tokens are discussed in the
    *REST service authorization and authentication* section of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blazor application entry point is in the `BlazorReview->Program.cs` file.
    This file doesn’t contain a class but just the code that must be executed when
    the application is launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the new Blazor WebAssembly project template takes advantage of this
    new way to define the application entry point that was introduced starting from
    .NET 7.
  prefs: []
  type: TYPE_NORMAL
- en: '`WebAssemblyHostBuilder` is a builder for creating a `WebAssemblyHost`, which
    is a WebAssembly-specific implementation of the generic host discussed in the
    *Using generic hosts* subsection of *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application* (you are encouraged to review that subsection).
    The first builder configuration instruction declares the Blazor root component
    (`App`), which will contain the whole component tree, and specifies in which HTML
    tag of the `index.html` page to place it (`#app`). More specifically, `RootComponents.Add`
    adds a hosted service that takes care of handling the whole Blazor component tree.
    We can run several Blazor WebAssembly user interfaces on the same HTML page by
    calling `RootComponents.Add` several times, each time with a different HTML tag
    reference.'
  prefs: []
  type: TYPE_NORMAL
- en: As the default, just another root component is added, `HeadOutlet`, and is placed
    immediately after the `HTML Head` tag. It is used to dynamically change the `index.html`
    title (the text shown in the browser tab). For more information on the `HeadOutlet`
    component, see the *Modifying HTML <head> content from Blazor component*s subsection.
  prefs: []
  type: TYPE_NORMAL
- en: '`builder.Services` contains all the usual methods and extension methods to
    add services to the Blazor application dependency engine: `AddScoped`, `AddTransient`,
    `AddSingleton`, and so on. Like in ASP.NET Core MVC applications (*Chapter 17*,
    *Presenting ASP.NET Core*, and *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core*), services are the preferred places to implement business logic
    and store shared state. While in ASP.NET Core MVC services were usually passed
    to controllers, in Blazor WebAssembly, they are injected into components.'
  prefs: []
  type: TYPE_NORMAL
- en: The default project scaffolded by Visual Studio contains just two services,
    one for communicating with the server and the other for handling OAuth-based authentication.
    We will discuss both of them later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how the root `App` component simulates page changes.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The root `App` class referenced by the host-building code is defined in the
    `BlazorReview ->App.razor` file. `App` is a Blazor component, and like all Blazor
    components, it is defined in a file with a `.razor` extension and uses Razor syntax
    enriched with component notation, that is, with HTML-like tags that represent
    other Blazor components. It contains the whole logic for handling application
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All tags in the preceding code represent either components or particular component
    parameters, called templates. Components will be discussed in detail throughout
    the chapter. For the moment, imagine them as a kind of custom HTML tags that we
    can somehow define with C# and Razor code. Templates, instead, are parameters
    that accept Razor markup as values. Templates are discussed in the *Templates
    and cascading parameters* subsection later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The `CascadingAuthenticationState` component only has the function of passing
    authentication and authorization information to all components of the component
    tree that is inside of it. The Blazor project template generates it only if one
    chooses to add authorization during project creation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Router` component is the actual application router. It scans the assembly
    passed in the `AppAssembly` parameter looking for components containing routing
    information, that is, for components that can work as pages. In the Blazor project
    template, the `Router` component is passed the assembly that contains the class
    of the `App` component, that is, the main application. Pages contained in other
    assemblies can be added through the `AdditionalAssemblies` parameter, which accepts
    an `IEnumerable` of assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the router intercepts all page changes performed either by code
    or through the usual `<a>` HTML tags that point to an address inside of the application
    base address. Navigation can be handled by code by requiring a `NavigationManager`
    instance from dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Router` component has two templates, one for the case where a page for
    the requested URI is found (`Found`), and the other for the case where it is not
    found (`NotFound`). When the application uses authorization, the `Found` template
    consists of the `AuthorizeRouteView` components, which further distinguish whether
    the user is authorized to access the selected page or not. When the application
    doesn’t use authorization, the `Found` template consists of the `RouteView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`RouteView` takes the selected page and renders it inside the layout page specified
    by the `DefaultLayout` parameter. This specification acts as a default since each
    page can override it by specifying a different layout page. In the Blazor project
    template, the default layout page is in the `BlazorReview->Layout->MainLayout.razor`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor layout pages work similarly to ASP.NET Core MVC layout pages, described
    in the *Reusing view code* subsection of *Chapter 17*, *Presenting ASP.NET Core*,
    the only difference being that the place to add the page markup is specified with
    `@Body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application uses authorization, `AuthorizeRouteView` works like `RouteView`,
    but it also allows the specification of a template for a case where the user is
    not authorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the user is not authenticated, the `RedirectToLogin` component uses a `NavigationManager`
    instance to move to the login logic page; otherwise, it informs the users that
    they haven’t got enough privileges to access the selected page.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly also allows the lazy loading of assemblies to reduce the
    initial application loading time, but we will not discuss it here for lack of
    space. The *Further reading* section contains references to the official Blazor
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: As we will discuss in more detail later on in this chapter, the `PageTitle`
    component enables the developer to set the page title that appears in the browser
    tabs. The `FocusOnNavigate` component, instead, sets the HTML focus on the first
    HTML element that satisfies the CSS selector passed in its `Selector` parameter,
    immediately after a page is navigated.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor pages and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn the fundamentals of Blazor components, including
    how to construct a component, the structure of components, how to attach events
    to HTML tags, how to specify the components’ characteristics, and how to use other
    components within your components. We have divided the content into several subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: Component structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates and cascading parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Blazor updates HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are the core of all main client frameworks. They are the key ingredient
    to building modular UI, whose parts are easily modifiable and reusable. In a few
    words, they are the graphical counterpart of classes. In fact, just like classes,
    they allow encapsulation and code organization. Moreover, the component architecture
    allows the formal definition of efficacious UI update algorithms, as we will see
    in the *How Blazor updates HTML* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Components are defined in files with a `.razor` extension. Once compiled, they
    become classes that inherit from `ComponentBase`. Like all other Visual Studio
    project elements, Blazor components are available through the **Add New Item**
    menu. Usually, components to be used as pages are defined in the `Pages` folder,
    or in its subfolders, while other components are organized in different folders.
    Default Blazor projects add all their non-page components inside the `Shared`
    folder, but you can organize them differently.
  prefs: []
  type: TYPE_NORMAL
- en: By default, pages are assigned a namespace that corresponds to the path of the
    folder they are in. Thus, for instance, in our example project, all pages that
    are in the `BlazorReview->Pages` path are assigned to the `BlazorReview.Pages`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can change this default namespace with an `@namespace` declaration
    placed in the declaration area that is at the top of the file. This area may also
    contain other important declarations. The following is an example that shows all
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two directives make sense only for components that must work as pages,
    while all others may appear in any component. Below is a detailed explanation
    of each declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@layout` directive, when specified, overrides the default layout page with
    another component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `@page` directive defines the path of the page (**route**) within the application
    base URL. Thus, for instance, if our application runs at `https://localhost:5001`,
    then the URL of this page will be `https://localhost:5001/counter`. Page routes
    can also contain parameters, like in this example: `/orderitem/{customer}/{order}`.
    Parameter names must match public properties defined as parameters by the components.
    The match is case-insensitive. Parameters will be explained later on in this subsection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The string that instantiates each parameter is converted into the parameter
    type, and if this conversion fails, an exception is thrown. This behavior can
    be prevented by associating a type with each parameter, in which case, if the
    conversion to the specified type fails, the match with the page URL fails. Only
    elementary types are supported: `/orderitem/{customer:int}/{order:int}`. As a
    default, parameters are obligatory; that is, if they are not found, the match
    fails and the router tries other pages. However, you can make parameters optional
    by post-fixing them with a question mark: `/orderitem/{customer?:int}/{order?:int}`.
    If an optional parameter is not specified, the default for its type is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From version 6, parameters can also be extracted from the query string: `/orderitem/{customer:int}?order=123`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@namespace` overrides the default namespace of the component, while `@using`
    is equivalent to the usual C# `using`. The `@using` declared in the special `{project
    folder}->_Imports.razor` folder is automatically applied to all components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@inherits` declares that the component is a subclass of another component,
    while `@implements` declares that it implements an interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@typeparam` is used if the component is a generic class and declares the name
    of the generic parameter. `@typeparam` also allows the specification of generic
    constraints with the same syntax used in classes: `@typeparam T where T: class`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@attribute` declares any attribute applied to the component class. Property-level
    attributes are applied directly to properties defined in the code area, so they
    don’t need special notation. The `[Authorize]` attribute, applied to a component
    class used as a page, prevents unauthorized users from accessing the page. It
    works exactly in the same way as when it is applied to a controller or to an action
    method in ASP.NET Core MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `@inject` directive requires a type instance to the dependency
    injection engine and inserts it in the field declared after the type name; in
    the previous example, in the `navigation` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle part of the component file contains the HTML that will be rendered
    by the component with Razor markup, enriched with the possible invocation of child
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom part of the file is enclosed by an `@code` construct and contains
    fields, properties, and methods of the class that implements the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Public properties decorated with the `[Parameter]` attribute work as component
    parameters; that is, when the component is instantiated into another component,
    they are used to pass values to the decorated properties, and those values are
    passed to HTML elements in HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Values can also be passed to component parameters by page route parameters,
    or query string parameters that match the property name in a case-invariant match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the match with query string parameters is enabled only if the property
    is also decorated with the `SupplyParameterFromQuery` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Component parameters can also accept complex types and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If components are generic, they must be passed type values for each generic
    parameter declared with `typeparam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, often, the compiler is able to infer generic types from the types of
    other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the code enclosed in the `@code` directive can also be declared in
    a partial class with the same name and namespace as the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Usually, these partial classes are declared in the same folder as the component
    and with a filename equal to the component’s filename with a `.cs` postfix added.
    Thus, for instance, the partial class associated with the `counter.razor` component
    will be `counter.razor.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: Each component may also have an associated CSS file, whose name must be the
    name of the component file plus the `.css` postfix. Thus, for instance, the CSS
    file associated with the `counter.razor` component will be `counter.razor.css`.
    The CSS contained in this file is applied only to the component and has no effect
    on the remainder of the page. This is called CSS isolation, and at the moment,
    it is implemented by adding a unique attribute to all component HTML roots. Then,
    all selectors of the component CSS file are scoped to this attribute so that they
    can’t affect other HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can also use global application CSS, and in fact, the Blazor template
    creates the `wwwroot/css/app.css` file for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Blazor application is packaged, either during a build or during its
    publication, all isolated CSS is processed and placed in a unique CSS file called
    `<assembly name>.Client.styles.css`. That’s why the `index.html` page of our `BlazorReview`
    application contains the following CSS reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that isolated CSS can also be obtained with pure CSS
    techniques, or using the **Sass** language, which compiles with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a component decorates an `IDictionary<string, object>` parameter with
    `[Parameter(CaptureUnmatchedValues = true)]`, then all unmatched parameters inserted
    into the tag, that is, all parameters without a matching component property, are
    added to the `IDictionary` as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature provides an easy way to forward parameters to HTML elements or
    ­other child components contained in the component markup. For instance, if we
    have a `Detail` component that displays a detail view of the object passed in
    its `Value` parameter, we can use this feature to forward all usual HTML attributes
    to the root HTML tag of the component, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, usual HTML attributes added to the component tag, for instance, `class`,
    are forwarded to the root `div` of the components and used to style the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection explains how to pass markup-generating functions to components.
  prefs: []
  type: TYPE_NORMAL
- en: Templates and cascading parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor works by building a data structure called a **render tree**, which is
    updated as the UI changes. At each change, Blazor locates the part of the HTML
    that must be rendered and uses the information contained in the **render tree**
    to update it.
  prefs: []
  type: TYPE_NORMAL
- en: The `RenderFragment` delegate defines a function that is able to add further
    markup to a specific position of the **render tree**. There is also `RenderFragment<T>`,
    which accepts a further argument you can use to drive the markup generation. For
    instance, you can pass a `Customer` object to `RenderFragment<T>` so that it can
    render all the data for that specific customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define `RenderFragment` or `RenderFragment<T>` with C# code, but the
    simplest way is to define it in your components with Razor markup. The Razor compiler
    will take care of generating the proper C# code for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The information on the location to add the markup is passed in the `RenderTreeBuilder`
    argument it receives as an argument. You can use `RenderFragment` in your component
    Razor markup by simply invoking it as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The position where you invoke `RenderFragment` defines the location where it
    will add its markup, since the component compiler is able to generate the right
    `RenderTreeBuilder` argument to pass to it. `RenderFragment<T>` delegates are
    invoked as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Being functions, render fragments can be passed to component parameters like
    all other types. However, Blazor has a specific syntax to make it easier to simultaneously
    define and pass render fragments to components: the **template** syntax. First,
    you define the parameters in your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when you call the customer, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each `RenderFragment` parameter is represented by a tag with the same name as
    the parameter. You can place the markup that defines `RenderFragment` inside of
    it. For the `CustomerTemplate` that has a parameter, the `Context` keyword defines
    the parameter name inside the markup. In our example, the chosen parameter name
    is `customer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a component has just one render fragment parameter, if it is named `ChildContent`,
    the template markup can be enclosed directly between the opening and closing tags
    of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In order to familiarize ourselves with component templates, let’s modify the
    `Pages->Weather.razor` page so that, instead of using `foreach`, it uses a `Repeater`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s right-click on the `Layout` folder, select **Add** and then **Razor Component**,
    and add a new `Repeater.razor` component. Then, replace the existing code with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The component is defined with a generic parameter so that it can be used with
    any `IEnumerable`. Now let’s replace the markup in the `tbody` of the `Weather.razor`
    component with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Repeater` component has just one template, and since we named it
    `ChildContent`, we can place our template markup directly within the component
    open and close tags. Run it and verify that the page works properly. You have
    learned how to use templates and that markup placed inside a component defines
    a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important predefined templated Blazor component is the `CascadingValue`
    component. It renders the content placed inside of it with no changes, but passes
    a type instance to all its descendant components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All components placed inside of the `CascadingValue` tag and all their descendant
    components can now capture the instance of `MyOptionsInstance` passed in the `CascadingValue`
    parameter. It is enough that the component declares a public or private property
    with a type that is compatible with `MyOptionsInstance` and that decorates it
    with the `CascadingParameter` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Matching is performed by type compatibility. If there’s ambiguity with other
    cascaded parameters with a compatible type, we can specify the `Name` optional
    parameter of the `CascadingValue` component and pass the same name to the `CascadingParameter`
    attribute: `[CascadingParameter("myUnique name")]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `CascadingValue` tag also has an `IsFixed` parameter that should be set
    to `true` whenever possible for performance reasons. In fact, propagating cascading
    values is very useful for passing options and settings, but it has a very high
    computational cost.
  prefs: []
  type: TYPE_NORMAL
- en: When `IsFixed` is set to `true`, propagation is performed just once, the first
    time that each piece of content involved is rendered, and then no attempt is made
    to update the cascaded value during the content’s lifetime. Thus, `IsFixed` can
    be used whenever the pointer of the cascaded object is not changed during the
    content’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a cascading value is the `CascadingAuthenticationState` component
    we encountered in the *Routing* subsection, which cascades authentication and
    authorization information to all rendered components.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the default, when an error in a component occurs, the exception is intercepted
    by the .NET runtime, which automatically makes visible the error code contained
    in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, component errors can be intercepted and handled locally by enclosing
    the component inside an `ErrorBoundary` component. Below, the code of the `Repeater`
    example in the previous subsection has been modified to locally handle errors
    that might occur in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The standard code is placed in the `ChildContent` template, while the `ErrorContent`
    template is shown if there’s an error.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both HTML tags and Blazor components use attributes/parameters to get input.
    HTML tags provide output to the remainder of the page through events, and Blazor
    allows C# functions to be attached to HTML `on{event name}` attributes. The syntax
    is shown in the `Pages->Counter.razor` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The function can also be passed inline as a lambda. Moreover, it accepts the
    C# equivalent of the usual `event` argument. The *Further reading* section contains
    a link to the Blazor official documentation page that lists all supported events
    and their arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Since Blazor components are designed as enhanced versions of HTML elements—with
    added capabilities—they can also have events. However, unlike standard HTML elements,
    both the features and implementations of these events in Blazor components are
    defined by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor events enable components to return output, too. Component events are
    defined as parameters whose type is either `EventCallBack` or `EventCallBack<T>`.
    `EventCallBack` is the type of component event with no arguments while `EventCallBack<T>`
    is the type of component event with an argument of type `T`. In order to trigger
    an event, say `MyEvent`, the component calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These calls execute the handlers bound to the events or do nothing if no handler
    has been bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, component events can be used exactly in the same way as HTML
    element events, the only difference being that there is no need to prefix the
    event name with an `@`, since `@` in HTML events is needed to distinguish between
    the HTML attribute and the Blazor-added parameter with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Actually, HTML element events are also `EventCallBack<T>` events. That is why
    both event types behave in exactly the same way. `EventCallBack` and `EventCallBack<T>`
    are structs, not delegates, since they contain a delegate, together with a pointer
    to the entity that must be notified that the event has been triggered. Formally,
    this entity is represented by a `Microsoft.AspNetCore.Components.IHandleEvent`
    interface. Needless to say, all components implement this interface. The notification
    informs `IHandleEvent` that a state change took place. State changes play a fundamental
    role in the way Blazor updates the page HTML. We will analyze them in detail in
    the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For HTML elements, Blazor also provides the possibility to stop the event’s
    default action and the event bubbling by adding the `:preventDefault` and `:stopPropagation`
    directives to the attribute that specifies the event, like in these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, a component parameter value must be kept synchronized with an external
    variable, property, or field. The typical application of this kind of synchronization
    is an object property being edited in an input component or HTML tag. Whenever
    the user changes the input value, the object property must be updated coherently,
    and vice versa. The object property value must be copied into the component as
    soon as the component is rendered so that the user can edit it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar scenarios are handled by parameter-event pairs. More specifically, from
    one side, the property is copied in the input component parameter. From the other
    side, each time the input changes value, a component event that updates the property
    is triggered. This way, property and input values are kept synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is so common and useful that Blazor has a specific syntax for
    simultaneously defining the event and copying the property value into the parameter.
    This simplified syntax requires that the event has the same name as the parameter
    involved in the interaction but with a `Changed` postfix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for instance, that a component has a `Value` parameter. Then, the
    corresponding event must be `ValueChanged`. Moreover, each time the user changes
    the component value, the component must invoke the `ValueChanged` event by calling
    `await ValueChanged.InvokeAsync(arg)`. With this in place, a property called `MyObject.MyProperty`
    can be synchronized with the `Value` property with the syntax shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax is called `binding`. Blazor takes care of automatically
    attaching an event handler that updates the `MyObject.MyProperty` property to
    the `ValueChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bindings of HTML elements work in a similar way, but since the developer can’t
    decide the names of parameters and events, a slightly different convention must
    be used. First of all, there is no need to specify the parameter name in the binding,
    since it is always the HTML input `value` attribute. Therefore, the binding is
    written simply as `@bind="object.MyProperty"`. By default, the object property
    is updated on the `change` event, but you can specify a different event by adding
    the `@bind-event: @bind-event="oninput"` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, bindings of HTML inputs try to automatically convert the input string
    into the target type. If the conversion fails, the input reverts to its initial
    value. This behavior is quite primitive since, in the event of errors, no error
    message is provided to the user, and the culture settings are not taken into account
    properly (HTML5 inputs use invariant culture but text input must use the current
    culture). We advise binding inputs only to string target types. Blazor has specific
    components for handling dates and numbers that should be used whenever the target
    type is not a string. We will describe these components in the *Blazor forms and
    validation* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to familiarize ourselves with events, let’s write a component that
    synchronizes the content of an input-type text when the user clicks a confirmation
    button. Let’s right-click on the `Layout` folder and add a new `ConfirmedText.razor`
    component. Then replace its code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `ConfirmedText` component exploits the button-click event to trigger the
    `ValueChanged` event. Moreover, the component uses `@bind` to synchronize its
    `Value` parameter with the HTML input. It is worth pointing out that the component
    uses `CaptureUnmatchedValues` to forward all HTML attributes applied to its tag
    to the HTML input. This way, users of the `ConfirmedText` component can style
    the input field by simply adding `class` and/or `style` attributes to the component
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use this component in the `Pages->Index.razor` page by placing the
    following code at the end of `Home.razor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you run the project and play with the input and its **Confirm** button, you
    will see that each time the **Confirm** button is clicked, not only are the input
    values copied in the `textValue` page property but also the content of the paragraph
    that is behind the component is coherently updated.
  prefs: []
  type: TYPE_NORMAL
- en: We explicitly synchronized `textValue` with the component with `@bind-Value`,
    but what takes care of keeping `textValue` synchronized with the content of the
    paragraph? The answer can be found in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: How Blazor updates HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we write the content of a variable, property, or field in Razor markup
    with something like `@model.property`, Blazor not only renders the actual value
    of the variable, property, or field when the component is rendered but tries also
    to update the HTML each time that this value changes, with a process called **change
    detection**. Change detection is a feature of all the main SPA frameworks, but
    the way Blazor implements it is very simple and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that once all HTML has been rendered, changes may occur only
    because of code executed inside of events. That is why `EventCallBack` and `EventCallBack<T>`
    contain a reference to an `IHandleEvent`. When a component binds a handler to
    an event, the Razor compiler creates an `EventCallBack` or `EventCallBack<T>`,
    passing its struct constructor the function bound to the event, and the component
    where the function was defined (`IHandleEvent`).
  prefs: []
  type: TYPE_NORMAL
- en: Once the code of the handler has been executed, the Blazor runtime is notified
    that the `IHandleEvent` might have changed. In fact, the handler code can only
    change the values of variables, properties, or fields of the component where the
    handler was defined. In turn, this triggers a change detection process rooted
    in the component. Blazor verifies which variables, properties, or fields used
    in the component Razor markup changed and updates the associated HTML.
  prefs: []
  type: TYPE_NORMAL
- en: If a changed variable, property, or field is an input parameter of another component,
    then the HTML generated by that component might also need updates. Accordingly,
    another change detection process rooted in that component is recursively triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm sketched previously discovers all relevant changes only if the
    following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: No component references data structures belonging to other components in an
    event handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All inputs to a component arrive through its parameters and not through method
    calls or other public members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is a change that is not detected because of the failure of one of
    the preceding conditions, the developer must manually declare the possible change
    of the component. This can be done by calling the `StateHasChanged()` component
    method. Since this call might result in changes to the page’s HTML, its execution
    cannot take place asynchronously but must be queued in the HTML page’s UI thread.
    This is done by passing the function to be executed to the `InvokeAsync` component
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, the instruction to execute is `await InvokeAsync(StateHasChanged)`.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection concludes the description of components with an analysis
    of their lifecycle and the associated lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: Component lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each component lifecycle event has an associated method. Some methods have both
    synchronous and asynchronous versions, some have just an asynchronous version,
    and some others have just a synchronous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component lifecycle starts with parameters passed to the component being
    copied in the associated component properties. You can customize this step by
    overriding the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Typically, customization consists of the modification of additional data structures,
    so the base method is called to also perform the default action of copying parameters
    in the associated properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, there is the component initialization that is associated with the
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: They are called once in the component lifetime, immediately after the component
    has been created and added to the render tree. Please place any initialization
    code there, and not in the component constructor, as this will improve component
    testability. This is because there, you have all parameters set and future Blazor
    versions might pool and reuse component instances.
  prefs: []
  type: TYPE_NORMAL
- en: If the initialization code subscribes to some events or performs actions that
    need a cleanup when the component is destroyed, implement `IDisposable`, and place
    all the cleanup code in its `Dispose` method. Whenever a component implements
    `IDisposable`, Blazor calls its `Dispose` method before destroying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the component has been initialized, and each time a component parameter
    changes, the following two methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: They are the right place to update data structures that depend on the values
    of the component parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the component is rendered or re-rendered. You can prevent component
    re-rendering after an update by overriding the `ShouldRender` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Letting a component re-render only if you are sure its HTML code will change
    is an advanced optimization technique used in the implementation of component
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component rendering stage also involves the invocation of its children
    components. Therefore, component rendering is considered complete only after all
    its descendant components have completed their rendering too. When rendering is
    complete, the following methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since when the preceding methods are called, all component HTML has been updated
    and all children components have executed all their lifetime methods, the preceding
    methods are the right places for performing the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling JavaScript functions that manipulate the generated HTML. JavaScript
    calls are described in the JavaScript interoperability subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing information attached to parameters or cascaded parameters by descendant
    components. In fact, tab-like components and other components might need to register
    some of their subparts in the root component, so the root component typically
    cascades a data structure where some children components can register. Code written
    in `AfterRender` and `AfterRenderAsync` can rely on the fact that all the parts
    have completed their registration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section describes Blazor tools for collecting user input.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor forms and validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to all major SPA frameworks, Blazor offers specific tools for processing
    user input while providing valid feedback to the user with error messages and
    immediate visual clues.
  prefs: []
  type: TYPE_NORMAL
- en: In classic HTML websites, HTML forms are used to collect input, validate it,
    and send it to the server. In client frameworks, data is not sent to the server
    by submitting forms, but forms retain their validation purpose. More specifically,
    they act as validation units, that is, as a container for inputs that must be
    validated together because they belong to a unique task. Accordingly, when a submit
    button is clicked, an overall validation is performed, and the system notifies
    of the result via events. This way, the developer can define what to do in case
    of errors and what actions to take when the user has successfully completed their
    input.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that validation performed on the client side doesn’t
    ensure data integrity because a malicious user could easily hack all client validation
    rules because they have full access to the client-side code in their browser.
    The purpose of client-side validation is just to provide immediate feedback to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, the validation step must be repeated on the server side to enforce
    data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Both server-side and client-side validation can be performed with the same code
    shared between the Blazor client and the server. In fact, both the ASP.NET Core
    REST API and Blazor support validation based on validation attributes, so it is
    enough to share the same ViewModels equipped with validation attributes between
    the Blazor and server projects by putting them in a library that is referenced
    by both projects. ASP.NET Core validation is discussed in the *Server-side and
    client-side validation* section of *Chapter 17*, *Presenting ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: The whole toolset is known as **Blazor Forms** and consists of a form component
    called `EditForm`, various input components, a data annotation validator, a validation
    error summary, and validation error labels.
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` takes care of orchestrating the state of all input components through
    an instance of the `EditContext` class that is cascaded inside of the form. The
    orchestration comes from the interaction of both input components and the data
    annotation validator with this `EditContext` instance. A validation summary and
    error message labels don’t take part in the orchestration but register to some
    `EditContext` events to be informed about errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` must be passed the object whose properties must be rendered in its
    `Model` parameter. It is worth pointing out that input components bound to nested
    properties are not validated, so `EditForm` must be passed a flattened ViewModel.
    `EditForm` creates a new `EditContext` instance, passes the object received in
    its `Model` parameter in its constructor, and cascades it so it can interact with
    the form content.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also directly pass an `EditContext` custom instance in the `EditContext`
    parameter of `EditForm` instead of passing the object in its `Model` parameter,
    in which case `EditForm` will use your custom copy instead of creating a new instance.
    Typically, you do this when you need to subscribe to the `EditContext` `OnValidationStateChanged`
    and `OnFieldChanged` events.
  prefs: []
  type: TYPE_NORMAL
- en: When `EditForm` is submitted with a **Submit** button and there are no errors,
    the form invokes its `OnValidSubmit` callback, where you can place the code that
    uses and processes the user input. If instead there are validation errors, they
    are displayed, and the form invokes its `OnInvalidSubmit` callback.
  prefs: []
  type: TYPE_NORMAL
- en: The state of each input is reflected in some CSS classes that are automatically
    added to them, namely `valid`, `invalid`, and `modified`. You can use these classes
    to provide adequate visual feedback to the user. The default Blazor template already
    provides some CSS for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The label is a standard HTML label, while `InputNumber` is a Blazor-specific
    component for number properties. `ValidationMessage` is the error label that appears
    only in the event of a validation error. By default, it is rendered with a `validation-message`
    CSS class. The property associated with the error message is passed in the `for`
    parameter with a parameterless lambda, as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: The `DataAnnotationsValidator` component adds a validation based on the usual
    .NET validation attributes, such as `RangeAttribute`, `RequiredAttribute`, and
    so on. You can also write your custom validation attributes by inheriting from
    the `ValidationAttribute` class.
  prefs: []
  type: TYPE_NORMAL
- en: You can provide custom error messages in the validation attributes. If they
    contain a `{0}` placeholder, this will be filled with the property display name
    declared in a `DisplayAttribute`, if one is found, otherwise with the property
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Together with the `InputNumber` component, Blazor also supports an `InputText`
    component for `string` properties, an `InputTextArea` component for `string` properties
    to be edited in an HTML `textarea`, an `InputCheckbox` component for `bool` properties,
    and an `InputDate` component that renders `DateTime` and `DateTimeOffset` as dates.
    They all work in exactly the same way as the `InputNumber` component. No component
    is available for other HTML5 input types. In particular, no component is available
    for rendering time or date and time, or for rendering numbers with a `range` widget.
  prefs: []
  type: TYPE_NORMAL
- en: If you need HTML5 inputs that are not available as Blazor input form components,
    you are left with the option of implementing them yourself or of using a third-party
    library that supports them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement rendering time or date and time by inheriting from the `InputBase<TValue>`
    class and overriding the `BuildRenderTree`, `FormatValueAsString`, and `TryParseValueFromString`
    methods. The sources of the `InputNumber` component show how to do this: [https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputNumber.cs).
    You can also use the third-party libraries described in the *Third-party tools
    for Blazor WebAssembly* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor also has a specific component for rendering a `select`, which works
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Starting from .NET 6, `InputSelect` can also be bound to `IEnnumerable<T>` properties,
    in which case it is rendered as a multi-select.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can also render enumerations with a radio group thanks to the `InputRadioGroup`
    and `InputRadio` components, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Finally, Blazor also offers an `InputFile` component together with all the tools
    for processing and uploading the file. We will not cover this here, but the *Further
    reading* section contains links to the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes Blazor tools for modifying the host page `<head>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying HTML <head> content from Blazor components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the whole component tree is placed inside the body of the `index.html`
    host page, the components markup has no direct access to the `index.html` host
    page `<head>` tag. Modifying the content of the `<head>` tag is necessary when
    the developer would like to adapt the title shown in the browser tab to the actual
    Blazor page that is being displayed. In fact, this title is contained within the
    `<head>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, the .NET 6 version of Blazor introduced specific constructs
    for modifying the host page `<head>` tag from inside Blazor components.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we must inform the Blazor application about how to reach the
    `<head>` tag content. This is done in `Program.cs` with the same technique used
    to specify the Blazor application root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, each component can replace the HTML title by specifying the new
    string inside a `PageTitle` component instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, each component can append other HTML content to the `<head>` tag
    by placing it inside a `HeadContent` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you learned all that is needed to write a simple Blazor application
    that doesn’t exchange data with a server. The next section analyzes some advanced
    features and will enable you to interact with a server to handle authentication,
    authorization, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides short descriptions of various Blazor advanced features
    organized into subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: References to components and HTML elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globalization and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOT compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of a lack of space, we can’t give all the details of each feature, but
    the details are covered by links in the *Further reading* section. We start with
    how to reference components and HTML elements defined in Razor markup.
  prefs: []
  type: TYPE_NORMAL
- en: References to components and HTML elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we might need a reference to a component in order to call some of
    its methods. This is the case, for instance, for a component that implements a
    modal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding example shows, references are captured with the `@ref` directive.
    The same `@ref` directive can also be used to capture references to HTML elements.
    HTML references have an `ElementReference` type and are typically used to call
    JavaScript functions on HTML elements, as explained in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Blazor doesn’t expose all JavaScript features to C# code, and since it
    is convenient to take advantage of the huge JavaScript code base, sometimes it
    is necessary to invoke JavaScript functions. Blazor allows this through the `IJSRuntime`
    interface that can be injected into a component via dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have an `IJSRuntime` instance, a JavaScript function that returns a
    value can be called as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that do not return any argument can be invoked as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Arguments can be either basic types or objects that can be serialized in JSON,
    while the name of the JavaScript function is a string that can contain dots that
    represent access to properties, sub-properties, and method names, such as the
    `"myJavaScriptObject.myProperty.myMethod"` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, for instance, we can save a string in the browser’s local storage with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Arguments can also be `ElementReference` instances captured with the `@ref`
    directive, in which case they are received as HTML elements on the JavaScript
    side.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript functions invoked must be defined either in the `Index.html`
    file or in JavaScript files referenced in `Index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing a component library with a Razor library project, JavaScript
    files can be embedded together with CSS files as resources in the DLL library.
    You just need to add a `wwwroot` folder in the project root and place the needed
    CSS and JavaScript files in that folder or some subfolder of it. After that, these
    files can be referenced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, if the filename is `myJsFile.js`, the DLL name is `MyCompany.MyLibrary`,
    and the file is placed in the `js` folder inside `wwwroot`, then its reference
    will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth pointing out that all CSS files added to components (CSS isolation)
    we mentioned earlier in this chapter are compiled into a unique CSS file that
    is added as a DLL resource. This file must be referenced in the `index.html` page
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If your JavaScript files are organized as ES6 modules, you can avoid referencing
    them in `Index.html` and can load the modules directly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, instance methods of C# objects can be called from JavaScript code,
    by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Say the C# method is called `MyMethod`. Decorate the `MyMethod` method with
    the `[JSInvokable]` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enclose the C# object in a `DotNetObjectReference` instance and pass it to
    JavaScript with a JavaScript call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the JavaScript side, say the C# object is in a variable called `dotnetObject`.
    Then, we just need to invoke:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **Awesome Blazor** project ([https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor))
    lists a lot of open-source projects that use JavaScript’s interoperability to
    build .NET wrappers for well-known JavaScript libraries. There, you can find wrappers
    for 3D graphics JavaScript libraries, plot JavaScript libraries, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to handle contents and number/date localization.
  prefs: []
  type: TYPE_NORMAL
- en: Globalization and localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as the Blazor application starts, both the application culture and the
    application UI culture are set to the browser culture. However, the developer
    can change both of them by assigning the chosen cultures to `CultureInfo.DefaultThreadCurrentCulture`
    and `CultureInfo.DefaultThreadCurrentUICulture`. Typically, the application lets
    the user choose one of its supported cultures, or it accepts the browser culture
    only if it is supported; otherwise, it falls back to a supported culture. In fact,
    it is possible to support just a reasonable number of cultures because all application
    strings must be translated into all supported cultures.
  prefs: []
  type: TYPE_NORMAL
- en: If the application must support a single culture, this culture can be set once
    and for all in `program.cs` after the host has been built but before the host
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by replacing await `builder.Build().RunAsync()` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If the application must support several languages, the code is similar, but
    the culture information must be taken from the browser’s local storage, where
    the user must be given the option to store it in some applications option page.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `CurrentCulture` is set, dates and numbers are automatically formatted
    according to the conventions of the chosen culture. For the UI culture, the developer
    must manually provide resource files with the translations of all application
    strings in all supported cultures. Blazor uses the same localization/globalization
    techniques, so please refer to the *ASP.NET Core globalization* section of *Chapter
    17*, *Presenting ASP.NET Core*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to use resource files. With the first option, you create
    a resource file, say, `myResource.resx`, and then add all language-specific files:
    `myResource.it.resx`, `myResource.pt.resx`, and so on. In this case, Visual Studio
    creates a static class named `myResource` whose static properties are the keys
    of each resource file. These properties will automatically contain the localized
    strings corresponding to the current UI culture. You can use these static properties
    wherever you like, and you can use pairs composed of a resource type and a resource
    name to set the `ErrorMessageResourceType` and `ErrorMessageResourceName` properties
    of validation attributes or similar properties of other attributes. This way,
    the attributes will use an automatically localized string.'
  prefs: []
  type: TYPE_NORMAL
- en: With the second option, you add only language-specific resource files (`myResource.it.resx`,
    `myResource.pt.resx`, and so on). In this case, Visual Studio doesn’t create any
    class associated with the resource file, and you can use resource files together
    with `IStringLocalizer` and `IStringLocalizer<T>` injected in components as you
    use them in ASP.NET Core MVC views (see the *ASP.NET Core globalization* section
    of *Chapter 17*, *Presenting ASP.NET Core*).
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Routing* subsection, we discussed how the `CascadingAuthenticationState`
    and `AuthorizeRouteView` components prevent unauthorized users from accessing
    pages protected with an `[Authorize]` attribute. Let’s go deeper into the details
    of how page authorization works.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET applications, authentication and authorization information is usually
    contained in a `ClaimsPrincipal` instance. In server applications, this instance
    is built when the user logs in, taking the required information from a database.
    In Blazor WebAssembly, such information must be provided by some remote server
    that takes care of SPA authentication too. Since there are several ways to provide
    authentication and authorization to a Blazor WebAssembly application, Blazor defines
    the `AuthenticationStateProvider` abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization providers inherit from the `AuthenticationStateProvider`
    abstract class and override its `GetAuthenticationStateAsync` method, which returns
    `Task<AuthenticationState>`, where `AuthenticationState` contains the authentication
    and authorization information. Actually, `AuthenticationState` contains just a
    `User` property with a `ClaimsPrincipal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve defined a concrete implementation of `AuthenticationStateProvider`,
    we must register it in the dependency engine container in the application’s `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We will return to the predefined implementations of `AuthenticationStateProvider`
    offered by Blazor after having described how Blazor uses authentication and authorization
    information provided by a registered `AuthenticationStateProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CascadingAuthenticationState` component calls the `GetAuthenticationStateAsync`
    method of the registered `AuthenticationStateProvider` and cascades the returned
    `Task<AuthenticationState>`. You can intercept this cascading value with a `[CascadingParameter]`
    defined as follows in your components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: However, Blazor applications typically use `AuthorizeRouteView` and `AuthorizeView`
    components to control user access to content.
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorizeRouteView` prevents access to pages if the user doesn’t satisfy the
    prescriptions of the page’s `[Authorize]` attribute; otherwise, the content in
    the `NotAuthorized` template is rendered. `AuthorizeRouteView` also has an `Authorizing`
    template that is shown while user information is being retrieved.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorizeView` can be used within components to show the markup it encloses
    only to authorized users. It contains the same `Roles` and `Policy` parameters
    of the `[Authorize]` attribute that you can use to specify the constraints the
    user must satisfy to access the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthorizeView` can also specify `NotAuthorized` and an `Authorizing` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If one adds authorization while creating a Blazor WebAssembly project, the
    following method call is added to the application dependency engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This method adds an `AuthenticationStateProvider` that extracts the user information
    from the authentication cookie of an OAuth provider. The OAuth protocol with the
    OAuth provider is performed with the help of the `AuthenticationService.js` JavaScript
    file we saw in the *Loading and starting the application* subsection of this chapter.
    The OAuth provider endpoint returns user information in the form of a bearer token
    that can, then, also be used to authenticate communications with the server’s
    web API. Bearer tokens are described in detail in the *REST service authorization
    and authentication* and *ASP.NET Core service authorization* sections of *Chapter
    15*, *Applying Service-Oriented Architectures with .NET*. Blazor WebAssembly communication
    is described in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code takes the OAuth parameters from a configuration file you
    must add as `wwwroot/appsettings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you use Google as the authentication provider, `AUTHORITY` is `https://accounts.google.com/`,
    while `CLIENT ID` is the client ID you receive when you register your Blazor application
    with the Google Developers program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google needs some more parameters, namely the return URL to return once the
    authentication process is completed and the page to return to after a logout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Where `https://localhost:5001` must be replaced with the actual domain of the
    Blazor application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before any authentication or if the authentication fails, an unauthenticated
    `ClaimsPrincipal` is created. This way, when the user tries to access a page that
    is protected by an `[Authorize]` attribute, the `AuthorizeRouteView` component
    invokes the `RedirectToLogin` component, which, in turn, navigates to the `Authentication.razor`
    page, passing it a login request in its `action` route parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `RemoteAuthenticatorView` acts as an interface with the usual ASP.NET Core
    user login/registration system, and whenever it receives an “action” to perform,
    it redirects the user from the Blazor application to the proper ASP.NET Core server
    page (login, registration, logout, and user profile).
  prefs: []
  type: TYPE_NORMAL
- en: Once the user logs in, they are redirected to the Blazor application page that
    caused the login request. The redirect URL is computed by the `BlazorReview.Layout->RedirectToLogin.razor`
    component, which extracts it from the `NavigationManager` and passes it to the
    `RemoteAuthenticatorView` component. This time, the `AuthenticationStateProvider`
    is able to get the user information from the authentication cookie that has been
    created by the login operation.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible both to design a custom OAuth provider for your Blazor application
    or to design a completely custom way to get a bearer token with an internal login
    Blazor page without leaving the Blazor application. In this last case, you must
    provide a custom implementation of the `AuthenticationStateProvider`. More details
    on these advanced custom scenarios are available in the official documentation
    reference in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to authenticate with an external OAuth provider and how to
    handle authorization within the Blazor application, we are ready to learn how
    to exchange data and how to authenticate with a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes a Blazor WebAssembly-specific implementation of
    the `HttpClient` class and related types.
  prefs: []
  type: TYPE_NORMAL
- en: Communication with the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor WebAssembly supports the same .NET `HttpClient` and `HttpClientFactory`
    classes described in the *.NET HTTP clients* section of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*. However, due to the communication limitations
    of browsers, their implementations are different and rely on the browser’s **fetch
    API**.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, for security reasons, all browsers, do not allow direct opening of
    generic **TCP/IP** connections but force all server communications to pass either
    through **Ajax** or through the **fetch API**.
  prefs: []
  type: TYPE_NORMAL
- en: This way, when you attempt a communication toward a URL that differs from the
    domain where the browser downloaded the SPA, the browser automatically switches
    to the CORS protocol, thus informing the server that the communication was started
    by a browser application that was downloaded by a different domain and that might
    potentially be a phishing website.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, the server accepts CORS communications just from well-known domains
    that are pre-listed in its code. This way, the server is sure that the request
    can’t come from a phishing website.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 15*, *Applying Service-Oriented Architectures with .NET*, we analyzed
    how to take advantage of `HttpClientFactory` to define typed clients. You can
    also define typed clients in Blazor with exactly the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since an authenticated Blazor application needs to send the bearer
    token created during the authentication process in each request to the application
    server, it is common to define a named client as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`AddHttpMessageHandler` adds a `DelegatingHandler`, that is, a subclass of
    the `DelegatingHandler` abstract class. Implementations of `DelegatingHandler`
    override its `SendAsync` method in order to process each request and each relative
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If this bearer token is expired or is not found at all, it tries to get a new
    bearer token by using the authentication cookie received when the user manually
    logged in with the OAuth provider. This way, it can obtain a fresh bearer token
    without requesting a new manual login. If this attempt also fails, an `AccessTokenNotAvailableException`
    is thrown. Typically, this exception is captured and used to trigger a redirection
    to the login page by calling its `Redirect` method, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If both the Blazor application and the Web API are deployed in different subfolders
    of the same domain, Blazor requests are issued without the CORS protocol, so they
    are automatically accepted by the server. Otherwise, the ASP.NET Core server must
    enable CORS requests, and must list the Blazor application URL among the allowed
    CORS domains with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Then, you must also place the `app.UseCors()` middleware in the ASP.NET Core
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example data shown on the `Weather` page of the `ReviewBlazor` application
    are downloaded from a static file located in the `wwwroot/sample-data` folder
    of the same Blazor application, so a normal, not-CORS request is issued and no
    bearer token is needed to request. Accordingly, the `Weather`page uses a default
    `HttpClient` defined in `Program.cs` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection explains how to improve the performance of computation-intensive
    applications with Blazor AOT compilation.
  prefs: []
  type: TYPE_NORMAL
- en: AOT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once uploaded in the browser, .NET assemblies are not compiled **Just in Time**
    (**JIT**) at their first execution as is the case for other platforms. Instead,
    they are interpreted by a very fast interpreter. Just the .NET runtime is pre-compiled
    and uploaded in the browser directly in WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: JIT compilation is avoided since it would considerably increase the application
    start time, which is already quite high because of the high application download
    size (about 10 MB). In turn, the download size is high due to the .NET libraries
    that any Blazor application needs to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: In order to reduce download size, during the compilation in release mode, Blazor
    .NET assemblies are tree-shaken to remove all unused types and methods. However,
    notwithstanding this tree-shaking, the typical download size remains quite high.
    A good download improvement is achieved with the default caching of the .NET runtime,
    which reduces the download size to 2-4 MB. However, the download size still remains
    high the first time a Blazor application is visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from .NET 6, Blazor offers an alternative to JIT compilation: **Ahead-of-Time**
    (**AOT**) compilation. With AOT, all application assemblies are compiled into
    a unique WebAssembly file during the application publication.'
  prefs: []
  type: TYPE_NORMAL
- en: AOT compilation is very slow and may last something like 10-30 minutes, even
    in the case of small applications. On the other hand, it must be executed only
    once when the application is published, so the compilation time doesn’t impact
    the application start time.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, AOT compilation more than doubles the download size, since the
    compiled code is more verbose than the source .NET code. Therefore, AOT should
    be adopted only in performance-critical applications that can trade a higher start
    time for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET WebAssembly AOT compilation requires an additional build tool that must
    be installed as an optional .NET SDK workload in order to use it. The first time,
    you can install it with the following shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, when a new .NET version is installed, we just need to launch the following
    command to update all previously installed workloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the AOT workload has been installed, AOT compilation can be enabled on
    a per-project basis by adding the `<RunAOTCompilation>true</RunAOTCompilation>`
    declaration to the Blazor project file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The next section briefly discusses some of the most relevant third-party tools
    and libraries that complete Blazor’s official features and help increase productivity
    in Blazor projects.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party tools for Blazor WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notwithstanding Blazor being a young product, its third-party tool and product
    ecosystem is already quite rich. Among the open source, free products, it is worth
    mentioning the **Blazorise** project ([https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)),
    which contains various free basic Blazor components (inputs, tabs, modals, and
    so on) that can be styled with various CSS frameworks, such as Bootstrap and Material.
    It also contains a simple editable grid and a simple tree view.
  prefs: []
  type: TYPE_NORMAL
- en: Also worth mentioning is **BlazorStrap** ([https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)),
    which contains pure Blazor implementations of all Bootstrap 4 components and widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Among all the commercial products, it is worth mentioning **Blazor Controls
    Toolkit** ([https://blazorct.azurewebsites.net/](https://blazorct.azurewebsites.net/)),
    which is a complete toolset for implementing commercial applications. It contains
    all input types with their fallbacks in case they are not supported by the browser;
    all Bootstrap components; other basic components; a complete, advanced drag-and-drop
    framework; and advanced customizable and editable components, like detail views,
    detail lists, grids, and a tree-repeater (a generalization of the tree view).
    All components are based on a sophisticated metadata representation system that
    enables the user to design the markup in a declarative way using data annotations
    and inline Razor declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it contains additional sophisticated validation attributes, tools
    for undoing user input, tools for computing changes to send to the server, sophisticated
    client-side and server-side query tools based on the OData protocol, and tools
    to maintain and save the whole application state.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning the **bUnit** open-source project ([https://github.com/egil/bUnit](https://github.com/egil/bUnit)),
    which provides all the tools for testing Blazor components.
  prefs: []
  type: TYPE_NORMAL
- en: The **Awesome Blazor** project ([https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor))
    lists thousands of open-source and commercial Blazor resources, such as tutorials,
    posts, libraries, and example projects.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example of a Blazor WebAssembly application based on the WWTravelClub
    book use case can be found in the *Using client technologies* section of *Chapter
    21, Case Study.* The next section explains how to use Blazor to implement cross-platform
    applications. The actual code is contained in the folder associated with this
    chapter in the GitHub repository of the book.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI Blazor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET MAUI is Microsoft’s advised choice to implement cross-platform applications.
    In fact, .NET MAUI applications can be just-in-time compiled for all Windows,
    Android, iOS, and other Linux-based devices. .NET MAUI contains a common abstraction
    of all target devices, and at the same time takes advantage of each device’s peculiarities
    by offering platform-specific libraries each containing platform-specific features
    of a target platform.
  prefs: []
  type: TYPE_NORMAL
- en: We will not describe .NET MAUI in detail, but after a short introduction to
    .NET MAUI, we will focus just on .NET MAUI Blazor. This way, by learning just
    Blazor, you will be able to develop single-page applications, progressive applications,
    and cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is .NET MAUI?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET MAUI extends Xamarin.Forms’ cross-platform capabilities from Android and
    iOS to also include Windows and macOS. Thus, .NET MAUI is a cross-platform framework
    for creating both native mobile and desktop apps with C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basis of .NET MAUI is Xamarin.Forms. In fact, Microsoft has provided a
    guide for migrating original Xamarin.Forms apps to .NET MAUI, as can be seen at
    the following link: [https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate](https://docs.microsoft.com/en-us/dotnet/maui/get-started/migrate).
    However, .NET MAUI has been conceived to be the new-generation framework for any
    native/desktop app development in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interface gráfica do usuário, Site  Descrição gerada automaticamente](img/B19820_19_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.2: .NET MAUI high-level architecture'
  prefs: []
  type: TYPE_NORMAL
- en: There is a specific difference between Xamarin.Forms and .NET MAUI. In Xamarin.Forms,
    there is a specific native project for any kind of device we would like to publish
    to on the app, while in .NET MAUI, this approach is based on as single project
    targeting multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to use .NET MAUI to run a Blazor application as
    a native application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing native applications with Blazor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET MAUI is not installed by default when you install Visual Studio 2022, but
    you need to select the .NET MAUI workload in the Visual Studio installer. Therefore,
    if you don’t see MAUI projects when you start a new project in your Visual Studio
    installation, you need to run the Visual Studio installer and modify your existing
    installation with the addition of the .NET MAUI workload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the MAUI workload installed, in the project creation wizard,
    you should be able to select **C#/All platforms/MAUI**, and then select **.NET
    MAUI Blazor Hybrid App**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_19_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.3: Creating a .NET MAUI Blazor application'
  prefs: []
  type: TYPE_NORMAL
- en: Create a MAUI Blazor project and call it `MAUIBlazorReview`. The MAUI Blazor
    application contains the usual `Layout` and `Pages` folders where you can place
    your Blazor components and pages, but they are placed inside a `Components` folder.
    It also contains a `wwwroot` folder containing the usual `index.html` page and
    all the CSS and JavaScript you might need. Finally, it also contains the usual
    `_Imports.razor` page where you can place all your default `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: A MAUI Blazor application also uses layout pages that you can place in the `Shared`
    folder and may reference Razor libraries containing CSS components and JavaScript
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_19_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.4: .NET MAUI Blazor project'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference is that services, instead of being declared in `Program.cs`
    files, are declared in `MauiProgram.cs` together with MAUI-specific code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Attention must be paid when using an `HttpClient` class to communicate with
    a server. Blazor web applications may use URLs relative to the domain where they
    were downloaded, while MAUI Blazor applications must use absolute URLs since they
    are not associated with any default URL. Therefore, an `HttpClient` definition
    is added to the services with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `Platforms` folder contains a subfolder for each platform supported by the
    application, where each subfolder contains platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_19_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.5: Platforms folder'
  prefs: []
  type: TYPE_NORMAL
- en: 'Supported folders can be changed by editing the `TargetFrameworks` element
    of the `MAUIBlazorReview.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You can select the platform to run the application from using the dropdown next
    to the green Visual Studio run button. On a Windows machine, you can select just
    Windows and Android. If you select Android, an Android device simulator is launched.
  prefs: []
  type: TYPE_NORMAL
- en: In order to debug for iOS/Mac platforms on a Windows machine, you need to connect
    an iOS/Mac device to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: When you build the project, the build may ask you to install an Android SDK
    version. If this is the case, please follow the simple instructions in the error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about client-side technologies. In particular,
    you learned what an SPA is and how to build one based on the Blazor WebAssembly
    framework. The chapter first described the Blazor WebAssembly architecture, and
    then explained how to exchange input/output with Blazor components and the concept
    of binding.
  prefs: []
  type: TYPE_NORMAL
- en: After having explained Blazor’s general principles, the chapter focused on how
    to get user input while providing the user with adequate feedback and visual clues
    in the event of errors. Then, the chapter provided a short description of advanced
    features, such as JavaScript interoperability, globalization, authentication with
    authorization, and client-server communication.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last section explained how to use Blazor to implement cross-platform
    applications based on Microsoft MAUI and how to transform a Blazor WebAssembly
    project into a .NET MAUI Blazor project.
  prefs: []
  type: TYPE_NORMAL
- en: Complete examples of Blazor applications based on the WWTravelClub book use
    case can be found in the *Using client technologies* section of *Chapter 21*,
    *Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an SPA?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the Blazor `router` component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Blazor page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `@namespace` directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `EditContext`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the right place to initialize a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the right place to process the user input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `IJSRuntime` interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of `@ref`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Blazor official documentation is available at [https://docs.microsoft.com/en-us/aspnet/core/blazor](https://docs.microsoft.com/en-us/aspnet/core/blazor).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading assemblies is described at [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All HTML events supported by Blazor together with their event arguments are
    listed at [https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling#event-arguments-1](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling#event-arguments-1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blazor supports the same validation attributes as ASP.NET MVC, with the exception
    of `RemoteAttribute`: [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A description of the `InputFile` component, and how to use it, can be found
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on Blazor localization and globalization are available here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on Blazor authentication and all its related URLs are available
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Blazorise project: [https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BlazorStrap: [https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blazor Controls Toolkit: [https://blazorct.azurewebsites.net/](https://blazorct.azurewebsites.net/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bUnit: [https://github.com/egil/bUnit](https://github.com/egil/bUnit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Awesome Blazor project: [https://github.com/AdrienTorris/awesome-blazor](https://github.com/AdrienTorris/awesome-blazor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
