- en: Chapter 4. Advanced Thread Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。高级线程处理
- en: 'In this chapter, we will continue to learn about the `Thread` class and thread
    processing. In the previous chapter, we began discussing the `Thread` class and
    how to create and use threads. Now that we have begun learning about the `Thread`
    class, in this chapter we will take the discussion to the next level. We''ll study
    new ways to keep control over concurrent threads and will continue to improve
    our parallel programming capabilities working with more challenging problems to
    solve. After following the instructions in this chapter, we will be able to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续学习`Thread`类和线程处理。在前一章中，我们开始讨论`Thread`类以及如何创建和使用线程。现在我们已经开始学习`Thread`类，在本章中，我们将讨论提升到下一个层次。我们将研究新的方法来控制并发线程，并将继续通过解决更具挑战性的问题来提高我们的并行编程能力。遵循本章中的说明后，我们将能够：
- en: Break down a problem into pieces that can be run concurrently
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题分解为可以并发运行的片段
- en: Create highly independent blocks of code to run in multiple threads avoiding
    many concurrency problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建高度独立的代码块以在多个线程中运行，避免许多并发问题
- en: Use flags in multiple threads for coordination
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个线程中使用标志进行协调
- en: Use techniques to have complete control over asynchronous and synchronous execution
    of threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用技术来完全控制线程的异步和同步执行
- en: Use techniques to use multithreading in non-thread-safe components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用技术来在非线程安全组件中使用多线程
- en: Perform error handling in a multithreaded application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程应用程序中执行错误处理
- en: Pipelining
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流水线
- en: Pipelining is a common design pattern used in multithreaded applications. In
    [Chapter 9](ch09.html "Chapter 9. Pipeline and Producer-consumer Design Patterns"),
    *Pipeline and Producer-consumer Design Patterns*, we will cover this in detail.
    But I wanted to briefly introduce it here, because we will use it in the examples
    in this chapter. Pipelining is a technique to solve a problem using concurrency.
    First, you divide the problem into parts that have to be executed in sequence
    with parts that can be executed in parallel. Then you implement the parallel parts
    using threads or tasks and run them concurrently to improve performance instead
    of running all of the functionality in sequence.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线是在多线程应用程序中常用的一个设计模式。在[第9章](ch09.html "第9章。流水线和生产者-消费者设计模式")中，我们将详细讲解这一点。但我想在这里简要介绍它，因为我们将在本章的示例中使用它。流水线是一种使用并发来解决问题的技术。首先，你将问题分解为必须按顺序执行的片段和可以并行执行的片段。然后，你使用线程或任务实现并行部分，并并发运行它们以提高性能，而不是按顺序运行所有功能。
- en: So far, we have worked with the `BackgroundWorker` component and the `Thread`
    class to create multithreaded applications. Parallel programming allowed us to
    achieve incredible performance enhancements and better UI feedback. How can we
    use threading and the `Thread` class to divide image-processing algorithms into
    many concurrent blocks of code? In this design pattern, we will take a problem,
    divide it into multiple pieces that we can tackle concurrently, and then assemble
    the pieces in the end to a final result.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`BackgroundWorker`组件和`Thread`类来创建多线程应用程序。并行编程使我们能够实现令人难以置信的性能提升和更好的UI反馈。我们如何使用线程和`Thread`类将图像处理算法分解为许多并发代码块？在这个设计模式中，我们将取一个问题，将其分解为多个我们可以并发解决的问题，然后在最后将片段组装成最终结果。
- en: 'In [Chapter 9](ch09.html "Chapter 9. Pipeline and Producer-consumer Design
    Patterns"), *Pipeline and Producer-consumer Design Patterns*, we will learn different
    common design patterns for tackling common problems in a multithreaded approach.
    But without going into too much detail, in this chapter, we will perform a simple
    form of pipelining to accomplish our task:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。流水线和生产者-消费者设计模式")，*流水线和生产者-消费者设计模式*中，我们将学习处理多线程方法中常见问题的不同常见设计模式。但不会深入细节，在这一章中，我们将执行一种简单的流水线形式来完成我们的任务：
- en: '![Pipelining](img/8321EN_04_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![流水线](img/8321EN_04_01.jpg)'
- en: C# offers many techniques for working with images and bitmaps. However, many
    of them are not thread-safe. We cannot run many concurrent threads changing pixels
    in the same instance of the `Bitmap` (`System.Drawing.Bitmap`) class. Nevertheless,
    as we learned in the previous chapters, in order to apply parallel algorithms,
    we can avoid the problems instead of finding difficult solutions to them by using
    different design patterns such as **pipelining**. We can split the original bitmap
    into a number of completely independent bitmaps. Each thread can work with its
    independent bitmap instance safely. We can develop an algorithm that performs
    image manipulation of bitmap pixels and then, with great performance improvements
    over the single-threaded one, perform this algorithm in parallel on many bitmaps.
    Besides, we can also add code to pause and then restart the threads. The performance
    results will depend upon the number of cores or processors available in the computer
    (which we discussed in [Chapter 1](ch01.html "Chapter 1. Understanding Multiprocessing
    and Multiple Cores"), *Understanding Multiprocessing and Multiple Cores*) in which
    we run the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了许多处理图像和位图的技巧。然而，其中许多都不是线程安全的。我们无法在 `Bitmap` (`System.Drawing.Bitmap`)
    类的同一实例中运行多个并发线程来更改像素。尽管如此，正如我们在前面的章节中学到的，为了应用并行算法，我们可以通过使用不同的设计模式，如**流水线**，来避免这些问题，而不是寻找解决它们的困难方法。我们可以将原始位图分成多个完全独立的位图。每个线程都可以安全地处理其独立的位图实例。我们可以开发一个执行位图像素图像处理的算法，然后，通过在多个位图上并行执行此算法，与单线程版本相比，实现显著的性能提升。此外，我们还可以添加代码来暂停线程，然后重新启动。性能结果将取决于计算机中可用的核心或处理器的数量（我们已在[第1章](ch01.html
    "第1章. 理解多处理和多核心")中讨论过，*理解多处理和多核心*），其中我们运行应用程序。
- en: By using the `Thread` class and the pipelining design pattern, we can achieve
    incredible performance improvements, an impressive user experience, and great
    scalability with reasonable programming efforts. The application we will build
    will be scalable to any size bitmap image and will be able to increase performance
    automatically as more core processors are added to the hardware without any coding
    changes!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Thread` 类和流水线设计模式，我们可以实现令人难以置信的性能提升、令人印象深刻的用户体验以及合理的编程努力下的良好可扩展性。我们将构建的应用程序将能够扩展到任何大小的位图图像，并且能够在硬件中添加更多核心处理器时自动提高性能，而无需任何代码更改！
- en: Explaining pipelining using an image processing application
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用图像处理应用程序解释流水线技术
- en: For our example in this chapter, we will use a Windows Forms application to
    perform image processing. We can do this in a **Windows Presentation Foundation**
    (**WPF**) application, but I find that doing bitmap and pixel-level manipulation
    is more straightforward in the GDI-based `System.Drawing` library than the WPF-based
    System, Windows Media library. This same application can be redone using the `BitmapImage`
    and `CroppedBitmap` classes using the same core logic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们将使用 Windows Forms 应用程序来执行图像处理。我们也可以在 **Windows Presentation Foundation**
    (**WPF**) 应用程序中这样做，但我发现，在基于 GDI 的 `System.Drawing` 库中执行位图和像素级别的操作比基于 WPF 的 System、Windows
    Media 库更为直接。使用相同的核心逻辑，相同的程序也可以使用 `BitmapImage` 和 `CroppedBitmap` 类重新实现。
- en: Image processing on large image files is a good candidate for a multithreaded
    solution because you can break the image into pieces and process each piece concurrently
    and then reassemble the pieces. In this example, we will take a bitmap image from
    NASA, break it into smaller bitmap files, search each bitmap for "old star", and
    then reassemble the bitmaps back into one large bitmap image file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型图像文件上执行图像处理是采用多线程解决方案的良好候选，因为你可以将图像分割成块，并发地处理每个块，然后将这些块重新组装。在这个例子中，我们将从 NASA
    获取一个位图图像，将其分割成更小的位图文件，在每个位图中搜索“旧星”，然后将这些位图重新组装成一个大的位图图像文件。
- en: 'You will use your parallel programming skills to develop an application that
    has to detect the older stars from huge infrared portraits obtained by NASA''s
    Spitzer Space Telescope. In the following screenshot, you can see a wispy star-forming
    region, called **W5**:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用你的并行编程技能开发一个应用程序，该应用程序必须从美国宇航局斯皮策太空望远镜获取的大量红外图像中检测到较老恒星。在下面的屏幕截图中，你可以看到一个被称为**W5**的稀薄恒星形成区域：
- en: '![Explaining pipelining using an image processing application](img/8321EN_04_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![使用图像处理应用程序解释流水线技术](img/8321EN_04_02.jpg)'
- en: Image by NASA/JPL-Caltech/Harvard-Smithsonian CfA
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由NASA/JPL-Caltech/Harvard-Smithsonian CfA提供
- en: In this portrait, the oldest stars can be seen as blue dots, especially in the
    center of the two hollow cavities. The white knotty areas are where the youngest
    stars are forming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这幅肖像中，最老的恒星可以看作是蓝色的小点，尤其是在两个空洞的中心。白色结块区域是年轻恒星形成的地方。
- en: This image contains some of the best evidence yet for the triggered star formation
    theory. Scientists analyzing the photo have been able to show that the ages of
    the stars become progressively and systematically younger with distance from the
    center of the cavities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像包含了迄今为止对触发恒星形成理论的最好证据。分析这张照片的科学家已经能够表明，随着距离洞穴中心的距离增加，恒星的年龄逐渐且系统地变得年轻。
- en: You have to work on a very fast and efficient algorithm for detection of old
    stars, capable of changing the pixel colors of the old stars in the huge image
    to make them more visible to the scientists. They want you to use a fine-tuned,
    multithreading application that is capable of working with as many threads as
    the number of cores available in the computer where the star detection algorithm
    is being executed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须工作在一个非常快速且高效的算法，用于检测老星，能够将大图像中老星的像素颜色改变，使其对科学家更可见。他们希望您使用一个经过微调的多线程应用程序，能够与在执行星检测算法的计算机上可用的核心数量一样多的线程一起工作。
- en: How to do it
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'To do this, we are going to build a new C# application and put the program
    logic into methods to detect old stars in any bitmap and prepare the bitmap input
    for many threads:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将构建一个新的C#应用程序，并将程序逻辑放入方法中以检测任何位图中老星，并为多个线程准备位图输入：
- en: Create a new C# project using the Windows Application template in Visual Studio.
    Use `OldStarsFinder` as the project's name.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio中的Windows应用程序模板创建一个新的C#项目。使用`OldStarsFinder`作为项目的名称。
- en: 'Add the following lines of code at the beginning of the form class definition
    (as we are going to use the `System.Threading.Thread` and `System.Drawing.Imaging`
    classes):'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单类定义的开始处添加以下代码行（因为我们将要使用`System.Threading.Thread`和`System.Drawing.Imaging`类）：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following lines in the form class definition to declare three new private
    variables:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义中添加以下行以声明三个新的私有变量：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following function, `CropBitmap`. It will crop the bitmap received
    as a parameter and return the portion of the original defined by the `Rectangle`
    instance, `proRectangle`. This will allow us to split up any large image into
    a set of smaller images. The number in the set will correspond to the number of
    cores in the machine the application is running. This way we can maximize performance
    by using every core simultaneously to process the large image:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，`CropBitmap`。它将裁剪接收到的位图，并返回由`Rectangle`实例`proRectangle`定义的原部分。这将使我们能够将任何大图像分割成一系列较小的图像。集合中的数字将与应用程序运行的机器上的核心数相对应。这样，我们可以通过同时使用每个核心来最大化性能，以处理大图像：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following function, `IsOldStar`. It will compare the pixel hue, saturation,
    and brightness to determine if their levels correspond to the typical color range
    offered by an old star in the infrared portraits:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，`IsOldStar`。它将比较像素色调、饱和度和亮度，以确定它们的级别是否与红外肖像中老星提供的典型颜色范围相符：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following procedure, `ThreadOldStarsFinder`. It will iterate through
    each pixel in the corresponding bitmap for the thread that launches it and count
    the old stars:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`ThreadOldStarsFinder`。它将为启动它的线程遍历相应的位图中每个像素，并计算老星的数量：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The code required to find and count the potential old stars in any large bitmap
    portrait is now held in named functions and procedures, already prepared for dynamically
    created concurrent threads. We have laid the groundwork to implement this function
    in a Pipeline design pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查找和计数任何大位图肖像中潜在老星所需的代码现在包含在命名的函数和过程中，已经为动态创建的并发线程准备好了。我们已经为在管道设计模式中实现此函数奠定了基础。
- en: Why do we have to create a `CropBitmap` function? That is because we cannot
    access a single `Bitmap` instance pixel matrix from many different concurrent
    threads. If we do so, we will get an `InvalidOperationException`, as GDI+ is not
    prepared for multithreaded access.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们必须创建一个`CropBitmap`函数？那是因为我们无法从许多不同的并发线程中访问单个`Bitmap`实例的像素矩阵。如果我们这样做，我们将得到一个`InvalidOperationException`，因为GDI+没有为多线程访问做好准备。
- en: We must split the original `Bitmap` into as many independent portions as the
    number of concurrent threads that will be working on it. The `CropBitmap` function
    will allow us to obtain a specific portion of a `Bitmap` instance and generate
    a list of new `Bitmap` instances (`prloBitmapList`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将原始的`Bitmap`分割成与将要同时处理它的并发线程数量一样多的独立部分。`CropBitmap`函数将允许我们获取`Bitmap`实例的特定部分，并生成一系列新的`Bitmap`实例（`prloBitmapList`）。
- en: As we have learned so far, there are many problems related to multithreaded
    applications and parallel algorithms. Since there are many threads running concurrently,
    we must be very careful when changing the values of variables in different threads.
    The best solution to such concurrency problems is *avoiding them* or preventing
    them via **synchronization mechanisms**. However, synchronization mechanisms have
    to be used very carefully, because they can decrease performance and generate
    too many context switches. Also, using them can introduce potential bugs that
    can be very difficult to debug.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到与多线程应用程序和并行算法相关的问题有很多。由于有许多线程同时运行，我们在更改不同线程中变量的值时必须非常小心。解决此类并发问题的最佳方案是*避免*它们或通过**同步机制**来预防。然而，同步机制必须非常小心地使用，因为它们可能会降低性能并产生过多的上下文切换。此外，使用它们可能会引入潜在的难以调试的bug。
- en: How can we avoid the concurrency problems? It is very simple. As much as possible,
    we have to make each thread independent of the other concurrent threads working
    in the same global portion of resources. As we will see in later chapters, the
    Task Parallel Library is convenient for defining tasks and then running the tasks
    in parallel. In this case, the processing of each bitmap can be a task.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免并发问题？非常简单。尽可能多地，我们必须使每个线程独立于在相同全局资源部分工作的其他并发线程。正如我们将在后面的章节中看到的，任务并行库（Task
    Parallel Library）非常适合定义任务，然后并行运行这些任务。在这种情况下，每个位图的处理可以是一个任务。
- en: Splitting the original bitmap using the simple `CropBitmap` function avoids
    many conflicts related to concurrency that would have otherwise been very complex
    to troubleshoot. As each thread is going to work with its own bitmap, we are avoiding
    a potentially dangerous problem. This is one of the keys to developing multithreaded
    applications—properly segmenting work into pieces that can run in parallel. Dividing
    the bitmap image is a perfect example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的`CropBitmap`函数分割原始位图可以避免许多与并发相关的冲突，否则这些问题将非常复杂且难以调试。由于每个线程都将使用自己的位图，我们避免了潜在的危险问题。这是开发多线程应用程序的关键之一——正确地将工作分割成可以并行运行的片段。分割位图图像是一个完美的例子。
- en: Another potential problem is counting the total number of old stars detected
    in the huge infrared bitmap portrait. If we used a shared member variable, we
    might have locking problems. If we have many threads concurrently changing the
    same variable value (at the same time), we will have to lock that variable each
    time its value is incremented. Locking a variable implies context switches and
    hence reduced performance. For this reason, we use the `long` list `prliOldStarsCount`.
    There is one counter for each thread, and we will obtain the total sum adding
    the *n* long values (`prliOldStarsCount`) to a new variable (where *n* is the
    number of star finder threads).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在问题是统计在巨大的红外位图肖像中检测到的总星数。如果我们使用共享成员变量，可能会遇到锁定问题。如果我们有多个线程同时更改相同的变量值（同时进行），每次变量值增加时，我们都需要锁定该变量。锁定变量意味着上下文切换，从而降低性能。因此，我们使用`long`类型的列表`prliOldStarsCount`。每个线程都有一个计数器，我们将通过将*n*个`long`值（`prliOldStarsCount`）相加到一个新变量中（其中*n*是星系搜索线程的数量）来获得总数。
- en: This way, we avoid locks as each thread has its own independent counter and
    we achieve a better performance compared to a solution that would use the confusing
    and complex locks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以避免使用锁，因为每个线程都有自己的独立计数器，与使用令人困惑且复杂的锁的解决方案相比，我们能够实现更好的性能。
- en: In order to process an image in many concurrent threads, we must divide it into
    as many independent portions as the number of threads that will be running. As
    we have seen earlier, the `CropBitmap` function offers this utility.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在许多并发线程中处理图像，我们必须将其分割成与将要运行的线程数量一样多的独立部分。正如我们之前所看到的，`CropBitmap`函数提供了这种功能。
- en: This change in the image processing algorithm has its costs, and is not free.
    In this case, we will be counting stars on a per-pixel basis. However, when we
    must apply other more complex algorithms, we must consider many important additional
    changes to the basic code. We will continue with this topic later in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图像处理算法的改变有其成本，并不是免费的。在这种情况下，我们将按像素计数星星。然而，当我们必须应用其他更复杂的算法时，我们必须考虑许多重要的额外更改到基本代码。我们将在本章的后面继续讨论这个话题。
- en: Once each image part is processed, we must collect the results and recompose
    the original image with the changes made to its pixels.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完每个图像部分，我们必须收集结果，并使用对像素所做的更改重新组合原始图像。
- en: Understanding the pixels' color compositions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解像素的颜色组成
- en: The infrared bitmap portrait does not have an exact blue (red = 0, green = 0,
    and blue = 255) color for an old star. There is a complex technique used to determine
    a star's age according to color ranges. This is easy to understand for human beings,
    but difficult for computers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 红外位图肖像中，一个老星没有确切的蓝色（红色 = 0，绿色 = 0，蓝色 = 255）颜色。有一种复杂的技术用于根据颜色范围确定星星的年龄。这对人类来说很容易理解，但对计算机来说很难。
- en: 'However, it is simple to generate an algorithm obtaining the following three
    components of a `Color` (`System.Drawing.Color`) instance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，生成一个获取 `Color` (`System.Drawing.Color`) 实例的以下三个组件的算法很简单：
- en: '**Hue**: This is obtained by the `GetHue()` method'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色调**: 这是由 `GetHue()` 方法获得的'
- en: '**Saturation**: This is obtained by the `GetSaturation()` method (from 0.01
    to 1.00)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**饱和度**: 这是由 `GetSaturation()` 方法获得的（从 0.01 到 1.00）'
- en: '**Brightness**: This is obtained by the `GetBrightness()` method (from 0.01
    to 1.00)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亮度**: 这是由 `GetBrightness()` 方法获得的（从 0.01 到 1.00）'
- en: 'Using these color components, we can apply the following rules to determine
    whether a pixel in the infrared bitmap portrait corresponds to a potential old
    star or not:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些颜色组件，我们可以应用以下规则来确定红外位图肖像中的像素是否对应一个潜在的旧星：
- en: Hue is between 150 and 258
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 色调介于 150 和 258 之间
- en: Saturation is more than 10% (0.10)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饱和度超过 10%（0.10）
- en: Brightness is more than 90% (0.90)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亮度超过 90%（0.90）
- en: It is easier to work with hue, saturation, and brightness values than with red,
    green, and blue values in order to determine an old star.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与红色、绿色和蓝色值相比，使用色调、饱和度和亮度值来确定一个旧星更容易。
- en: 'The `IsOldStar` function receives a `Color` instance as a parameter and returns
    the results of applying the aforementioned rules to its hue, saturation, and brightness,
    as shown in the following lines of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsOldStar` 函数接收一个 `Color` 实例作为参数，并返回根据其色调、饱和度和亮度应用上述规则的结果，如下面的代码行所示：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function is called for each pixel in the infrared bitmap portrait, and
    it returns a `bool` value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对红外位图肖像中的每个像素都进行调用，并返回一个 `bool` 值。
- en: Pausing and restarting threads
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和重新启动线程
- en: It is important in a lot of cases to coordinate and wait on threads. Take, for
    example, a pipelining design. Once we start a group of concurrent threads, we
    then need to wait on them all to finish, collate their results, and move onto
    the nonconcurrent section. We need to know when threads finish and what their
    results are, so we can determine how to proceed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，协调和等待线程是很重要的。以流水线设计为例。一旦我们启动了一组并发线程，我们就需要等待它们全部完成，汇总它们的结果，然后进入非并发部分。我们需要知道线程何时完成以及它们的结果，以便确定如何继续。
- en: There are several ways to coordinate and wait between threads. In the following
    example, we will show how you can check to see if a thread is still alive and
    processing and then wait on all of the threads to complete their bitmap processing
    work before we continue the rest of the application and reassemble the bitmap
    pieces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程之间协调和等待有几种方法。在下面的例子中，我们将展示如何检查一个线程是否仍在运行并处理，然后在继续应用程序的其余部分和重新组装位图片段之前，等待所有线程完成它们的位图处理工作。
- en: In this example, we will use the `IsAlive` method to check the thread and then
    pause the main thread with the `Sleep` method for a period of time before checking
    again. This is a common design pattern to coordinate work between threads and
    monitor threads to know when they are finished.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 `IsAlive` 方法检查线程，然后在再次检查之前，使用 `Sleep` 方法暂停主线程一段时间。这是一种常见的线程间协调工作并监控线程何时完成的模式。
- en: How to do it
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, we are going to create the UI and make some changes to create multiple
    threads dynamically to process each portion of a bitmap. In order to accomplish
    this, we must share data between the various threads, as we learned in the previous
    chapters. Perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建UI并对创建多个线程进行一些更改，以动态处理位图的每个部分。为了完成这项任务，我们必须在各个线程之间共享数据，正如我们在前面的章节中学到的。执行以下步骤：
- en: Stay in the project, `OldStarsFinder`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持项目，`OldStarsFinder`。
- en: Open Windows Form, `Form1` (`frmStarsFinder`), in the form designer; add the
    following controls and align them as shown in the following screenshot:![How to
    do it](img/8321EN_04_03.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单设计器中打开Windows表单`Form1`（`frmStarsFinder`），添加以下控件，并按以下截图所示对齐：![如何操作](img/8321EN_04_03.jpg)
- en: 'The following are the controls:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一些控件：
- en: One picture box (`picStarsBitmap`) showing one of the infrared portraits obtained
    by NASA's Spitzer Space Telescope (you can find many of them at [www.nasa.gov](http://www.nasa.gov)
    or [http://www.nasa.gov/multimedia/imagegallery/](http://www.nasa.gov/multimedia/imagegallery/)),
    with its `SizeMode` property set to `StretchImage`.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示由NASA的Spitzer太空望远镜获得的红外肖像的图片框（你可以在[www.nasa.gov](http://www.nasa.gov)或[http://www.nasa.gov/multimedia/imagegallery/](http://www.nasa.gov/multimedia/imagegallery/)找到许多这样的图片），其`SizeMode`属性设置为`StretchImage`。
- en: One button showing a star and its `Text` property set to `Find old star` (`butFindOldStars`).
    This button will start multiple old stars finder threads.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示星星并设置其`Text`属性为`Find old star` (`butFindOldStars`)的按钮。此按钮将启动多个旧星星查找线程。
- en: 'Add the following lines in the form''s class definition to declare two new
    private variables:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单的类定义中添加以下行以声明两个新的私有变量：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following procedure, `WaitForThreadsToDie`. It will make the main thread
    sleep in order to wait until the many concurrent threads finish their work:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`WaitForThreadsToDie`。它将使主线程暂停，以便等待许多并发线程完成工作：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following procedure, `ShowBitmapWithOldStars`. It will rebuild the
    bitmap adding each previously separated portion:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下过程，`ShowBitmapWithOldStars`。它将重建位图，添加之前分离的每个部分：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `Click` event in the button, `butFindOldStars`, and enter the following
    code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮的`Click`事件`butFindOldStars`中打开，并输入以下代码：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Build and run the application.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Click on the **Old Star Finder** button. After a few seconds (depending on the
    parallel processing capabilities of the computer) in the W5 wispy star-forming
    region, a huge infrared portrait will be shown with its probable old stars in
    pure blue, as shown in the following screenshot:![How to do it](img/8321EN_04_04.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Old Star Finder**按钮。几秒钟后（取决于计算机的并行处理能力），在W5 wispy星形成区域将显示一个巨大的红外肖像，其中包含纯蓝色的可能旧星星，如下面的截图所示：![如何操作](img/8321EN_04_04.jpg)
- en: How it works
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'When the user clicks on the **Old Star Finder** button, the process executes
    in the following manner:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**Old Star Finder**按钮时，过程将按以下方式执行：
- en: The original image is divided into many independent bitmaps. Each portion will
    be assigned to a different thread.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始图像被分割成许多独立的位图。每个部分将被分配给不同的线程。
- en: Many threads are created and then started (executed asynchronously) with a parameter
    so that they know which bitmap belongs to them.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动了许多线程（异步执行），并带有参数，以便它们知道哪个位图属于它们。
- en: The main thread waits until all the star finder threads finish their work, sleeping
    100 milliseconds in each query of the threads' state.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程等待所有星星查找线程完成工作，在查询线程状态时每次暂停100毫秒。
- en: Once all the threads finish their work, the main thread (the only one capable
    of touching the UI) rebuilds the divided bitmap and shows it in the picture box
    control.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有线程完成工作，主线程（唯一能够触摸UI的线程）将重建分割的位图，并在图片框控件中显示它。
- en: Each thread works in its independent block, without disturbing or interfering
    with the other threads.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程在其独立的块中工作，不会干扰或影响其他线程。
- en: The code used to divide the original bitmap dynamically into many smaller bitmaps
    is a bit complex. That is the price we have to pay for the performance enhancement
    and scalability of our application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将原始位图动态分割成许多更小位图的代码有点复杂。这是我们为了提高应用程序的性能和可扩展性所必须付出的代价。
- en: 'This line obtains a `Bitmap` instance from the `picStarsBitmap` picture box
    (we begin decoupling the UI, as we cannot touch it from independent threads):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码从`picStarsBitmap`图片框中获取一个`Bitmap`实例（我们开始解耦UI，因为我们不能从独立线程中触摸它）：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These lines create the thread list, the `long` numbers list, and the bitmap
    list in order to let them grow dynamically at runtime depending on the number
    of available cores in the computer where the application runs:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行创建了线程列表、`long`数字列表和位图列表，以便它们在应用程序运行的计算机中根据可用的核心数动态增长：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We must create bitmaps corresponding to the the number of cores available. We
    use the rows to select a similar number of rows for each bitmap portion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建与可用核心数相对应的位图。我们使用行来选择每个位图部分的相似数量的行。
- en: 'We define a variable `liStartRow` of type `int` as the starting row from where
    we will begin cropping the original bitmap:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个名为`liStartRow`的`int`类型变量，作为我们将开始裁剪原始位图的起始行：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we must determine the approximate number of rows for each bitmap:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须确定每个位图的近似行数：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, depending on the number of cores and the original bitmap height, the
    result of this division might not be exact. That is another problem. Therefore,
    we use another `int` variable to calculate the height to be added to each iteration
    to solve that problem:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据核心数和原始位图的高度，这个除法的结果可能不是精确的。这是另一个问题。因此，我们使用另一个`int`变量来计算要添加到每个迭代的长度，以解决这个问题：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, the algorithm is simple; for each iteration of `liThreadNumber` do the
    following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，算法很简单；对于`liThreadNumber`的每一次迭代，执行以下操作：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the height calculated for each bitmap is greater than the height to be added
    (this could happen in the last bitmap portion to be cropped), we reduce this number
    from the height to be added, which is the result of this line in each iteration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为每个位图计算的高度大于要添加的高度（这可能在要裁剪的最后一位图部分发生），我们就从要添加的高度中减去这个数字，这是每次迭代中这一行的结果：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Besides, in each iteration, the starting row increases the height calculated
    for each bitmap.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在每次迭代中，起始行增加了每个位图计算的高度。
- en: 'The following screenshot shows the results of applying this algorithm to the
    infrared portraits obtained by NASA''s Spitzer Space Telescope with four threads:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了将此算法应用于美国宇航局斯皮策太空望远镜通过四个线程获得的红外人像的结果：
- en: '![How it works](img/8321EN_04_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_04_05.jpg)'
- en: Using our classic C# programming skills, we can generate smart algorithms to
    split the work into many independent blocks of safe concurrent code. Again, mastering
    the lists is indeed necessary in parallel programming.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们经典的C#编程技能，我们可以生成智能算法，将工作分割成许多独立的、安全的并发代码块。再次强调，在并行编程中掌握列表确实是必要的。
- en: Signals between threads
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程间的信号
- en: To help in coordinating the activity between the multiple threads, we can create
    variables accessible to the whole class and hence each thread. Then the threads
    can write to and read from these variables to help them coordinate activity and
    to keep overall track of what is happening between all of the threads.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助协调多个线程之间的活动，我们可以创建整个类都可以访问的变量，因此每个线程都可以写入和读取这些变量，以帮助它们协调活动并跟踪所有线程之间发生的事情的整体情况。
- en: 'We use threads with parameters, as we learned in the previous chapters, and
    start them with an asynchronous execution using the following loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用带参数的线程，如我们之前章节中学到的，并使用以下循环异步启动它们：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Nevertheless, we must wait until the concurrent star finder threads finish their
    work in order to show the final modified bitmap in the UI. We do not want to use
    the `BackgroundWorker` component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须等待并发星系寻找线程完成它们的工作，以便在UI中显示最终的修改后的位图。我们不希望使用`BackgroundWorker`组件。
- en: For this reason, we created the `WaitForThreadsToDie` procedure, which is called
    synchronously by the main application's thread. When this method returns, we can
    safely show the resulting bitmap in the UI because all the threads have finished
    their work. Of course, to achieve the same goal, we can also use the `BackgroundWorker`
    component combined with the threads created as instances of the `Thread` class,
    as we learned in the previous chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了`WaitForThreadsToDie`过程，它由主应用程序线程同步调用。当这个方法返回时，我们可以安全地在UI中显示结果位图，因为所有线程都已经完成了它们的工作。当然，为了达到同样的目的，我们也可以使用`BackgroundWorker`组件，结合我们之前章节中学到的作为`Thread`类实例创建的线程，来使用。
- en: The code in the `WaitForThreadsToDie` procedure is complex because we have to
    check for each created thread and we know the number of threads at runtime, as
    they are dynamically aligned with the number of available cores. We use a `bool`
    flag to determine whether the `while` loop must go on running or not. However,
    in this case, we did not change the value of the flag, but there are other cases
    in which this code pattern could be useful to modify the value of this variable
    used as a flag.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitForThreadsToDie`过程中的代码很复杂，因为我们必须检查每个创建的线程，并且我们知道线程的数量是在运行时确定的，因为它们与可用核心的数量动态对齐。我们使用一个`bool`标志来确定`while`循环是否必须继续运行。然而，在这种情况下，我们没有更改标志的值，但还有其他情况下，这种代码模式可以用来修改用作标志的变量的值。'
- en: 'Once in the `while` loop (`lbContinue`), we must check for each thread to finish
    its work. We use the well-known `IsAlive` property:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入`while`循环（`lbContinue`），我们必须检查每个线程是否完成其工作。我们使用众所周知的`IsAlive`属性：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If one thread is alive, we will exit the `for` loop. If all the threads are
    not alive, `liDeadThreads` will equal the total number of created threads. Hence,
    we will exit the outer loop:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个线程是活跃的，我们将退出`for`循环。如果所有线程都不是活跃的，`liDeadThreads`将等于创建的线程总数。因此，我们将退出外层循环：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `break;` statement could be replaced by `lbContinue = false;` and we would
    achieve the same result.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`break;`语句可以被替换为`lbContinue = false;`，我们将达到相同的结果。'
- en: 'If there is still a thread running, we call the `Sleep` method for the main
    thread and make it sleep for 100 milliseconds (0.1 seconds), and then reset the
    `liDeadThreads` variable:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仍有线程正在运行，我们将对主线程调用`Sleep`方法，并使其休眠100毫秒（0.1秒），然后重置`liDeadThreads`变量：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The line with the call to the `Sleep` method is indispensable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 包含调用`Sleep`方法的行是必不可少的。
- en: Using methods like these, and flags, we can have complete control over independent
    threads, without causing the classic problems related to concurrency and the loss
    of control over the independent threads.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法和标志，我们可以完全控制独立的线程，而不会引起与并发和失去对独立线程控制相关的经典问题。
- en: As mentioned earlier, when the call to the `WaitForThreadsToDie` method returns,
    we can safely show the resulting bitmap in the UI because all the threads have
    finished their work. Hence, we call the `ShowBitmapWithOldStars` procedure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当调用`WaitForThreadsToDie`方法返回时，我们可以安全地在UI中显示结果位图，因为所有线程都已完成其工作。因此，我们调用`ShowBitmapWithOldStars`过程。
- en: This method reproduces the work done when dividing the original bitmap into
    several independent portions, but in the reverse order.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法重现了将原始位图分成几个独立部分时所做的操作，但顺序相反。
- en: 'We repeat the height calculation process explained previously. Then, we must
    create a new bitmap with the whole width and height. This bitmap must hold the
    different portions aligned as they were extracted from the original bitmap:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复之前解释的高度计算过程。然后，我们必须创建一个新的位图，具有整个宽度和高度。这个位图必须保持从原始位图中提取的不同部分的对齐方式：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Therefore, we use the `Bitmap` constructor passing the original bitmap width
    and height as parameters to define its size. Then, we create a `Graphics` instance
    from the `Bitmap` typecast to an `Image` (the `Bitmap` class is a descendant of
    the `Image` class).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`Bitmap`构造函数，通过传递原始位图的宽度和高度作为参数来定义其大小。然后，我们从`Bitmap`类型转换为`Image`实例化一个`Graphics`对象（`Bitmap`类是`Image`类的子类）。
- en: 'Once we have the `Graphics` instance, we must draw each bitmap image processed
    by each thread in its corresponding row (`liStartingRow`), which is calculated
    the same way we did when separating the bitmap portions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Graphics`实例，我们必须在每个线程处理并计算出的对应行（`liStartingRow`）中绘制每个位图图像，其计算方式与我们分离位图部分时相同：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Besides, in each iteration, the starting row increases the height calculated
    for each bitmap. Then, we are ready to show the rebuilt bitmap in the picture
    box, `picStarsBitmap`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在每次迭代中，起始行增加为每个位图计算的高度。然后，我们就准备好在图片框`picStarsBitmap`中显示重建的位图。
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Decoupling the UI, we can generate impressive performance improvements changing
    basic linear programming algorithms.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦UI，我们可以通过更改基本线性规划算法来生成令人印象深刻的性能改进。
- en: 'The following screenshot shows the results of applying this algorithm to the
    infrared portraits obtained by NASA''s Spitzer Space Telescope processed by four
    threads:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了将此算法应用于由NASA的斯皮策太空望远镜获得的红外人像，并通过四个线程处理的结果：
- en: '![Signals between threads](img/8321EN_04_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![线程间的信号](img/8321EN_04_06.jpg)'
- en: The screenshot shows a clear independency achieved by each thread.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了每个线程实现的清晰独立性。
- en: Run the application changing the value of the `priProcessorCount` private variable
    from 1 to the number of available cores in your computer, and then compare the
    results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，将`priProcessorCount`私有变量的值从1更改为计算机中可用的核心数，然后比较结果。
- en: How to do it
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, we are going to make some changes to the code in order to use the event
    wait handles instead of using a loop to check for the threads that are alive:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对代码进行一些修改，以便使用事件等待句柄而不是使用循环来检查活动的线程：
- en: Stay in the project, `OldStarsFinder`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持项目，`OldStarsFinder`。
- en: Open the code for `Program.cs`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`的代码。
- en: 'Replace the line `[STAThread]` with the following line (before the `Main` method
    declaration):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`[STAThread]`行替换为以下行（在`Main`方法声明之前）：
- en: '[PRE24]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the code for the Windows Form, `Form1` (`frmStarsFinder`).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Windows表单的代码，`Form1`（`frmStarsFinder`）。
- en: 'Add the following private variable:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下私有变量：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Replace the code in the `WaitForThreadsToDie` method with the following line:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WaitForThreadsToDie`方法中的代码替换为以下行：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following line of code in the local variables declaration of the `ShowBitmapWithOldStars`
    method, before the line `int liStartRow = 0;` (we must create the array according
    to the number of available cores):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShowBitmapWithOldStars`方法的局部变量声明中添加以下行，在`int liStartRow = 0;`行之前（我们必须根据可用的核心数量创建数组）：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following line of code in the thread creation loop in the `ShowBitmapWithOldStars`
    method, before the line `prloThreadList.Add(new Thread(new ParameterizedThreadStart(ThreadOldStarsFinder)));`
    (we must create an `AutoResetEvent` instance with a false initial state for each
    thread):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShowBitmapWithOldStars`方法中的线程创建循环中添加以下行，在`prloThreadList.Add(new Thread(new
    ParameterizedThreadStart(ThreadOldStarsFinder)));`行之前（我们必须为每个线程创建一个初始状态为假的`AutoResetEvent`实例）：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following line of code at the end of the `ThreadOldStarsFinder` method
    (we must signal that the work item has finished):'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ThreadOldStarsFinder`方法末尾添加以下行（我们必须指示工作项已完成）：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Build and run the application.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Click on the **Old Star Finder** button. After a few seconds (depending on the
    parallel processing capabilities of the computer), the W5 wispy star-forming region
    will be shown in the huge infrared portrait with the probable old stars shown
    in pure blue. You will not notice any changes in the application.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**旧星查找器**按钮。几秒钟后（取决于计算机的并行处理能力），W5稀薄星形成区域将以纯蓝色显示在巨大的红外肖像中，可能的老星将被显示。你不会在应用程序中注意到任何变化。
- en: How it works
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'When the user clicks on the **Old Star Finder** button:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**旧星查找器**按钮时：
- en: The original image is divided into many independent bitmaps. Each portion will
    be assigned to a different thread.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始图像被分割成许多独立的位图。每个部分将被分配给不同的线程。
- en: Many threads and their auto-reset event handlers are created to allow communication
    between the threads.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了许多线程及其自动重置的事件处理程序，以便线程之间进行通信。
- en: The threads are started (executed asynchronously) with a parameter so that they
    know which bitmap belongs to them.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程以参数启动（异步执行），这样它们就知道哪个位图属于它们。
- en: Once each thread finishes its work, it signals that the work is done, setting
    the auto-reset event.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦每个线程完成其工作，它将发出工作已完成信号，设置自动重置事件。
- en: The main thread waits until all the star finder threads finish their work, waiting
    for all the necessary signals from the multiple auto-reset events.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程等待所有星查找线程完成工作，等待来自多个自动重置事件的必要信号。
- en: Once all the threads finish their work, the main thread (the only one capable
    of touching the UI) rebuilds the divided bitmap and shows it in the picture box
    control.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有线程完成工作，主线程（唯一能够触摸UI的线程）将重建分割的位图，并在图片框控件中显示它。
- en: The code used to wait for all the threads to finish their work is easier and
    more elegant.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 等待所有线程完成工作的代码更简单、更优雅。
- en: Using the AutoResetEvent class to handle signals between threads
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`AutoResetEvent`类处理线程间的信号
- en: An `AutoResetEvent` instance allows us to notify a waiting thread that an event
    has occurred. It is a subclass of the `WaitHandle` and `EventWaitHandle` classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoResetEvent`实例允许我们通知等待的线程事件已发生。它是`WaitHandle`和`EventWaitHandle`类的子类。'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Event wait handles** encapsulate operating-system-specific objects that wait
    for exclusive access to shared resources. Using them, it is easier to wait for
    the threads'' signals to continue working when their jobs are done.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件等待句柄**封装了操作系统特定的对象，这些对象等待对共享资源的独占访问。使用它们，在任务完成后等待线程的信号以继续工作变得更容易。'
- en: 'First, we have to create event wait handles corresponding to the number of
    threads. We do it in the following line, in the `FindOldStarsAndShowResult` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建与线程数量相对应的事件等待句柄。我们在以下行中这样做，在`FindOldStarsAndShowResult`方法中：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We use an array because the `WaitAll` method receives an array of wait handles
    as a parameter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组，因为`WaitAll`方法接收一个等待句柄数组作为参数。
- en: 'Before creating each new instance of the `Thread` class, we create a new `AutoResetEvent`
    instance for each thread, with its initial state (a `bool` state) set to `false`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建每个新的`Thread`类实例之前，我们为每个线程创建一个新的`AutoResetEvent`实例，并将其初始状态（一个`bool`状态）设置为`false`：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Thus, each independent thread can access its own `AutoResetEvent` instance.
    Once the thread finishes its work, it signals that the job is done calling the
    `Set` method, as shown in the following line, at the end of the `ThreadOldStarsFinder`
    procedure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个独立的线程都可以访问它自己的`AutoResetEvent`实例。一旦线程完成其工作，它将通过调用`Set`方法来发出工作完成的信号，如以下行所示，在`ThreadOldStarsFinder`过程的末尾：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The event wait handle's initial state was `false`; now it is `true`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 事件等待句柄的初始状态是`false`；现在它是`true`。
- en: Using the WaitHandle class to check for signals
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`WaitHandle`类检查信号
- en: On the other side, the main UI thread has to wait until all the concurrent star
    finder threads finish their work in order to show the final modified bitmap in
    the UI. Thus, it must wait for all the event handles to have their state set to
    `true`, instead of the initial `false`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，主UI线程必须等待所有并发星系查找线程完成其工作，以便在UI中显示最终的修改后的位图。因此，它必须等待所有事件句柄的状态设置为`true`，而不是初始的`false`。
- en: This happens when all the threads have finished their work and have called the
    `Set` method for their corresponding `AutoResetEvent` instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在所有线程都完成其工作并为其对应`AutoResetEvent`实例调用`Set`方法之后。
- en: 'We can check that using a single line of code in the `WaitForThreadsToDie`
    method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`WaitForThreadsToDie`方法中使用一行代码来检查这一点：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `WaitAll` method will monitor all the event handles, waiting for their signals
    to change (the threads' completion). It receives an array of event handles as
    a parameter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitAll`方法将监视所有事件句柄，等待它们的信号改变（线程的完成）。它接收一个事件句柄数组作为参数。'
- en: We must change the application's threading model to a multithreaded apartment
    in order to be able to use the `WaitHandle.WaitAll` method. If we do not do so,
    the method call will fail and generate an exception. Therefore, we have to replace
    the line `[STAThread]`, before the `Main` method declaration, with `[MTAThread]`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用`WaitHandle.WaitAll`方法，我们必须将应用程序的线程模型更改为多线程公寓。如果我们不这样做，方法调用将失败并生成异常。因此，我们必须将位于`Main`方法声明之前的`[STAThread]`行替换为`[MTAThread]`。
- en: Joining threads
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程合并
- en: We have already examined *joining* a thread in the previous chapter. When you
    join a thread, you tell the current thread to wait on the thread, which you are
    joining, to complete. This allows you to coordinate work between two threads.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中检查了如何**合并**线程。当你合并一个线程时，你告诉当前线程等待你正在合并的线程完成。这允许你在两个线程之间协调工作。
- en: This was very handy in the example where we wanted to know when one piece is
    complete before we start the next piece.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要在开始下一部分之前知道某一部分何时完成的情况下，这非常方便。
- en: For our application, let's say we want to examine how the performance changes
    if all of the bitmap processing threads run sequentially instead of concurrently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，假设我们想检查如果所有位图处理线程都是顺序运行而不是并发运行，性能会如何变化。
- en: How to do it
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'If we want all of our bitmap processing threads to run sequentially, then right
    after we start a thread, we will join the thread. This will halt execution of
    the main thread until the bitmap processing thread we just started has finished.
    To do this, change the bottom `for` loop in the `butFindOldStars_Click` event
    handler and add the following line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让所有位图处理线程顺序运行，那么在我们启动一个线程后，我们将合并该线程。这将使主线程的执行暂停，直到我们刚刚启动的位图处理线程完成。为此，更改`butFindOldStars_Click`事件处理程序中的底部`for`循环并添加以下行：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, now the `for` loop looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`for`循环看起来是这样的：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Now, run the application and click on the **Old Star Finder** button. Comment
    the line out and rerun the application. What do you see?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并点击**旧星星查找器**按钮。取消注释该行并重新运行应用程序。你看到了什么？
- en: You will notice that the time to process the image and complete the process
    is much slower with the extra line of code versus without the extra line of code.
    As we mentioned previously, this is because we are pausing the main thread each
    time we execute a new thread to process part of the bitmap image. So, we are not
    processing the image concurrently but sequentially.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，与没有额外代码相比，使用额外代码处理图像和完成过程的时间要慢得多。正如我们之前提到的，这是因为每次我们执行一个新线程来处理位图图像的一部分时，我们都会暂停主线程。因此，我们不是并发处理图像，而是顺序处理。
- en: For our application, this is not very practical, but for many problems there
    is a reason why you might want to do this. The main lesson here is that the `Thread`
    class has several ways to control processing, so you, the developer, can have
    complete control over how threads are created, executed, and coordinated. This
    is also why this is referred to as **heavyweight concurrency** because it takes
    extra effort and work by the developer to accomplish the exact behavior that you
    want.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用来说，这并不非常实用，但对于许多问题来说，你可能会有想要这样做的原因。这里的主要教训是，`Thread`类有几种控制处理的方式，因此，作为开发者，你可以完全控制线程的创建、执行和协调方式。这也是为什么这被称为**重量级并发**，因为它需要开发者付出额外的努力和劳动来实现你想要的确切行为。
- en: Locking resources to ensure thread-safe data
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定资源以确保线程安全的数据
- en: So far we have chosen to design our application in a manner so that there is
    no need to lock resources to protect them from being "stomped" on by other threads,
    thereby causing race conditions and other unexpected behavior.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们选择以这种方式设计我们的应用程序，以至于没有必要锁定资源来保护它们免受其他线程“践踏”，从而引起竞态条件和其它意外行为。
- en: 'The lock syntax is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的语法如下：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code between the brackets is executed in a thread-safe manner and will not
    let other threads operate on the object being locked until the lock execution
    is completed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号之间的代码以线程安全的方式执行，并且直到锁执行完成，不会让其他线程操作被锁定的对象。
- en: Other threads that try to perform an operation on an object that is locked will
    wait until the lock is freed before they continue their operation on the object.
    This is important to note because it can create "locking" issues where one thread
    is waiting on a resource locked by another thread. This can be self-defeating
    when trying to gain performance improvements with multithreading code if the multiple
    threads are constantly waiting on each other to let go of a resource. This is
    one of the reasons we have designed the code to use a separate list of long values
    to count old stars with one item in the list for each thread instead of one variable
    total that all of the threads update.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对一个被锁定的对象执行操作的其它线程将等待锁被释放后，才会继续在对象上执行它们的操作。这一点很重要，因为它可能会创建“锁定”问题，其中一个线程正在等待另一个线程锁定的资源。如果在多线程代码中，多个线程不断等待对方释放资源以获得性能提升，这可能会适得其反。这也是我们设计代码使用单独的长整型值列表来计数旧星星，列表中的每个条目代表一个线程，而不是所有线程更新的一个总变量，的原因之一。
- en: On a separate note, when using locks, you need to be careful not to create a
    deadlock situation. This occurs when one thread is waiting on an object locked
    by another thread and that thread is waiting on an object locked by the first
    thread. Hence, each thread is waiting on the other thread and neither can proceed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用锁时，你需要小心不要创建死锁情况。这种情况发生在当一个线程正在等待另一个线程锁定的对象，而那个线程正在等待第一个线程锁定的对象时。因此，每个线程都在等待另一个线程，并且都无法继续。
- en: 'It is also worthwhile noting that locks are handled differently in between
    C# 3.0 and C# 4.0\. In 3.0, the following is how a lock is translated into code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，C# 3.0和C# 4.0之间在处理锁方面有所不同。在3.0中，锁被转换为代码如下：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In C# 4.0, it is handled as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 4.0中，它被处理如下：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, in C# 4.0, if the lock is not taken on an object, nothing different
    happens to the object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在C# 4.0中，如果没有在对象上获取锁，对象不会有任何不同。
- en: How to do it
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: Now, let's look at our code and make a simple change to use a single variable
    to hold our old star count. Let's do it with and without the lock and see the
    different behaviors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的代码，并对其进行简单修改，使用单个变量来保存我们的旧星星计数。让我们在有锁和无锁的情况下都做一下，看看不同的行为。
- en: 'First, let''s add the following to the top of our class in the declaration
    statements:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将以下内容添加到类的声明语句的顶部：
- en: '[PRE39]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Also, add a label control and set the `Text` property to `Old Stars Count` and
    add a textbox control and set the `Name` property to `tbCount`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要添加一个标签控件，并将`Text`属性设置为`Old Stars Count`，然后添加一个文本框控件，并将`Name`属性设置为`tbCount`。
- en: This variable will hold our old star count and all of the threads will update
    this one variable. You will notice that we are using a string instead of an integer.
    This is because an integer is a base type of the language and not an object. Because
    of this, it is thread-safe by default and does not need to be locked. So, to demonstrate
    our point, we will use a `String` object as a counter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量将保存我们的旧星计数，并且所有线程都将更新此一个变量。您会注意到我们使用的是字符串而不是整数。这是因为整数是语言的基本类型，而不是对象。由于这个原因，它默认是线程安全的，不需要锁定。因此，为了说明我们的观点，我们将使用
    `String` 对象作为计数器。
- en: 'Now, in the `ThreadOldStarsFinder` method, add the following code to the end
    (and inside) of the nested `for` loop:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `ThreadOldStarsFinder` 方法中，在嵌套 `for` 循环的末尾（和内部）添加以下代码：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: As you can see from this example, each time one of the processing threads updates
    the count, it will lock the resource, update `prsOldStarsCount`, and then unlock
    it. This protects its integrity but will slow down the overall processing because
    of the extra context switching that the lock will cause.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本例中看到的，每次处理线程更新计数时，它将锁定资源，更新`prsOldStarsCount`，然后解锁它。这保护了其完整性，但由于锁引起的额外上下文切换，这会减慢整体处理速度。
- en: Error handling with threads
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程进行错误处理
- en: In this section, we will discuss various ways of using the `try..catch` block
    to perform error handling and coordination of multiple threads.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用 `try..catch` 块执行错误处理和多个线程协调的多种方法。
- en: In this example, we are going to write a simple console application that demonstrates
    a typical producer-consumer model. We will also demonstrate using a `try..catch`
    to coordinate activities as well as the join and lock mechanism previously discussed.
    This exercise will cement everything we have learned in this chapter so far.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将编写一个简单的控制台应用程序，演示典型的生产者-消费者模型。我们还将演示使用 `try..catch` 协调活动以及之前讨论的合并和锁定机制。这项练习将巩固我们到目前为止在本章中学到的所有内容。
- en: Also, as we will see in future chapters the producer-consumer design pattern
    is one of the most commonly used design patterns in multithreaded problem solving
    and is used a lot with the Task Parallel Library. It describes a design where
    one thread (or a group of threads) "produces" some output, and a second thread
    (or group of threads) "consumes" that output and performs some logic on it. Typically,
    you will multithread the "production" of some results into a queue, and then will
    multithread the "consumption" of the produced results from the queue.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们将在未来的章节中看到的，生产者-消费者设计模式是解决多线程问题中最常用的设计模式之一，并且与任务并行库一起使用得很多。它描述了一种设计，其中一个线程（或一组线程）"生产"一些输出，而第二个线程（或一组线程）"消费"这些输出并对它进行一些逻辑处理。通常，你将多线程化某些结果的生产到队列中，然后多线程化从队列中消费产生的结果。
- en: How to do it
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Perform the following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open up Visual Studio and create a new project called `ProducerConsumer`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个名为 `ProducerConsumer` 的新项目。
- en: Let's create three classes, a `Producer` class, a `Consumer` class, and a `Cell`
    class. The `Producer` class will produce cells, and the consumer class will consume
    cells. In the `Main` method, we will start a producer and a consumer thread and
    then join them.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建三个类，一个`Producer`类，一个`Consumer`类和一个`Cell`类。`Producer`类将生产细胞，而消费者类将消费细胞。在`Main`方法中，我们将启动一个生产者和一个消费者线程，然后等待它们完成。
- en: 'Add the following code in the `Program.cs` file so it looks like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下代码，使其看起来像这样：
- en: '[PRE41]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's run this console application. In Visual Studio, make sure that you are
    displaying the **Output** window. You can do this by going to the **View** menu
    and selecting **Output**. Once you run the application, you should see something
    like the following in your **Output** window:![How to do it](img/8321EN_04_07.jpg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这个控制台应用程序。在 Visual Studio 中，确保您正在显示 **输出** 窗口。您可以通过转到 **视图** 菜单并选择 **输出**
    来做到这一点。一旦运行应用程序，您应该在您的 **输出** 窗口中看到以下内容：![如何做](img/8321EN_04_07.jpg)
- en: As you can see in our application, we coordinate between the producer and the
    consumer, and using the `try..catch` block and locks, we are able to produce one
    item and then consume that item.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们的应用程序中看到的那样，我们在生产者和消费者之间进行协调，并使用`try..catch`块和锁，我们能够生产一个项目，然后消费该项目。
- en: How it works
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Here, in this example, we show how synchronization is done using locks and a
    `Monitor` object. The `Pulse` method notifies a thread, which is in the waiting
    queue, of a change in the object's state.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了如何使用锁和`Monitor`对象来实现同步。`Pulse`方法通知等待队列中的线程对象状态的变化。
- en: In this example, we create a `Cell` object that has two methods, `Read` and
    `Write`. Two other objects are created from the `Producer` and `Consumer` classes.
    These objects have a method `ThreadRun` whose job is to call `Cell.Read` and `Cell.Write`.
    The synchronization is done by waiting for "pulses" from the `Monitor` object.
    These pulses will come in the order they are received.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个具有两个方法`Read`和`Write`的`Cell`对象。还创建了两个其他对象，分别来自`Producer`和`Consumer`类。这些对象有一个名为`ThreadRun`的方法，其任务是调用`Cell.Read`和`Cell.Write`。同步是通过等待`Monitor`对象的“脉冲”来完成的。这些脉冲将按照接收的顺序到来。
- en: So, first an item is produced (the consumer at this point is waiting for a pulse),
    then a pulse occurs, and then the consumer "consumes" what was produced. Meanwhile
    the producer is waiting for a pulse. This is then repeated until we reach the
    limit we set when we created the `Producer` and `Consumer` objects.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先生产一个项目（此时消费者正在等待脉冲），然后发生脉冲，然后消费者“消费”所生产的项目。同时，生产者在等待脉冲。然后重复这个过程，直到我们达到在创建`Producer`和`Consumer`对象时设定的限制。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a deeper dive into working with the `Thread` class.
    Through our examples, we learned how to coordinate threads in a more advanced
    way. We learned how to use the `try..catch` block, the `Monitor` object, locks,
    `Join`, `IsAlive`, and `Sleep` methods to coordinate activities between threads.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了与`Thread`类一起工作。通过我们的示例，我们学习了如何以更高级的方式协调线程。我们学习了如何使用`try..catch`块、`Monitor`对象、锁、`Join`、`IsAlive`和`Sleep`方法在线程之间协调活动。
- en: We also introduced two common design patterns that we will explore in much more
    detail in the later chapters—the pipelining and the producer-consumer patterns.
    These are commonly used to solve problems in a parallel application. They are
    good ways to segment the work that can be done in parallel from the work that
    cannot be done in parallel.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了两种常见的设计模式，这些模式将在后面的章节中更详细地探讨——管道和生产者-消费者模式。这些模式通常用于解决并行应用程序中的问题。它们是分割可以并行执行的工作和不能并行执行的工作的好方法。
- en: As we have discussed, this type of parallel programming is called heavyweight
    concurrency because the heavy lifting is done by you, the programmer. You have
    to manage and control the different threads to achieve the behavior you intended.
    You have to track which threads run and when and which threads are waiting and
    why. This does create complexity and work for the programmer but it also allows
    for very tight control of the execution. There are times when this is the best
    way to ensure proper behavior of your application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，这种类型的并行编程被称为重量级并发，因为繁重的工作是由程序员你来完成的。你必须管理和控制不同的线程以实现你期望的行为。你必须跟踪哪些线程在运行以及何时运行，哪些线程在等待以及为什么等待。这确实为程序员创造了复杂性和工作量，但它也允许对执行有非常紧密的控制。有时这是确保应用程序正确行为的最佳方式。
- en: Next, in [Chapter 5](ch05.html "Chapter 5. Lightweight Concurrency – Task Parallel
    Library (TPL)"), *Lightweight Concurrency – Task Parallel Library (TPL)*, we will
    start to examine lightweight concurrency and the Task Parallel Library. This allows
    you to let .NET handle some of this coordination for you. It is important that
    you have full understanding of the `Thread` class before moving on to the Task
    library and lightweight concurrency.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在[第5章](ch05.html "第5章。轻量级并发 – 任务并行库 (TPL)")中，*轻量级并发 – 任务并行库 (TPL)*，我们将开始探讨轻量级并发和任务并行库。这允许你让.NET为你处理一些这种协调工作。在继续学习任务库和轻量级并发之前，你对`Thread`类的全面理解是非常重要的。
