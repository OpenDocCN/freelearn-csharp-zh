- en: '*Chapter 5*: Dependency Injection in .NET 6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big issue that an enterprise application can face is the complexity of wiring
    different elements together and managing their lifetimes. To address this, we
    use the **inversion of control** (**IoC**) principle, which recommends removing
    the dependency between objects. By delegating the flow of control, IoC makes the
    program extensible and increases the modularity. Events, callback delegates, the
    observer pattern, and **dependency injection** (**DI**) are some of the ways to
    achieve IoC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI in ASP.NET Core 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing application services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a good idea about DI and how it's leveraged
    in .NET 6 applications, the types of scopes provided in ASP.NET Core 6, and how
    to leverage them in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is a technique in which an object receives objects that it depends on. The
    DI pattern fulfills the DI principle covered as part of the **single-responsibility
    principle, open-closed principle, Liskov substitution principle, interface segregation
    principle, and dependency inversion principle** (**SOLID**) design principles
    in [*Chapter 1*](B18507_01_Epub.xhtml#_idTextAnchor020), *Designing and Architecting
    the Enterprise Application*. With the use of DI, code will be more maintainable,
    readable, testable, and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: 'DI is one of the most well-known methods to help achieve better maintainable
    code. DI has three entities involved, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – DI relationship'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – DI relationship
  prefs: []
  type: TYPE_NORMAL
- en: The `IOrderRepository` is responsible for `Order` entity. .NET IoC container
    (`IOrderRepository` (`OrderController` (client).
  prefs: []
  type: TYPE_NORMAL
- en: '**IoC container** (also known as **DI Container**) is a framework for implementing
    automatic DI. In *Figure 5.1*, this is referred to as **Injector**. It is responsible
    for creating or referencing a dependency and injecting it into **Client**.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned what DI is, let's learn about the types of DI.
  prefs: []
  type: TYPE_NORMAL
- en: Types of DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple ways a service can be injected into a dependency. Based
    on the way a service is injected into the client object, DI is categorized into
    three types, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IWeatherProvider` dependency is injected through the constructor parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, `WeatherService` is dependent on `IWeatherProvider`,
    which is injected via a constructor parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For an implementation of the `WeatherProvider` service, refer to the sample
    code from GitHub, which can be found at the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: '`IWeatherProvider` dependency is not set while initializing `WeatherService2`.
    It is set via the `WeatherProvider` property post object initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`IWeatherProvider` dependency is injected as a method parameter wherever required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `IWeatherProvider` service is injected into
    `WeatherService` via the `GetForecast` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some suggestions to help in choosing the type of DI:'
  prefs: []
  type: TYPE_NORMAL
- en: Use constructor injection when the class has a dependency without which the
    functionality won't work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use constructor injection when the dependency is used in multiple functions
    in the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use property injection when the dependency can change after the class is instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use method injection when the implementation of the dependency changes with
    every call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, constructor injection will be used for clean and decoupled code,
    but depending on the need, we will also leverage method and property injection
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned the concepts of DI. Let's dive into what .NET 6 offers to
    achieve DI.
  prefs: []
  type: TYPE_NORMAL
- en: DI in ASP.NET Core 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET 6 comes with a built-in IoC container framework, which simplifies DI.
    This comes with the `Microsoft.Extensions.DependencyInjection` NuGet package and
    the ASP.NET Core 6 framework itself relies heavily on this. To support DI, a container
    needs to support three basic actions on objects/services, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registering**: The container should have provisions to register dependencies.
    This will help to map the correct type to a class so that it can create the right
    dependency instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolving**: The container should resolve dependencies by creating a dependency
    object and injecting it into the dependent instance. IoC container manages the
    creation of registered objects by passing in all the required dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disposing**: The container is responsible for managing the lifetime of dependencies
    created through it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In .NET 6, the following terms are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service**: Refers to a dependency managed by a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IConfiguration`, `ILoggerFactory`, `IWebHostEnvironment`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IWeatherProvider` service that we used in the previous section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the application to start, the ASP.NET Core 6 framework injects a few dependencies,
    which are referred to as `WebApplicationBuilder` is injected with the required
    framework services such as `IConfiguration` and `IWebHostEnvironment`. When you
    try printing the registered services, as shown in the following code snippet (refer
    to the code from [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16)),
    we can list the framework services registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In ASP.NET Core 6.0, the `IWebHostEnvironment` framework service is available
    from the `builder.Environment` property. Similarly, the configuration is available
    from the `builder.Configuration` property.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 6 Runtime instantiates all the required framework services and
    registers them with IoC container. Starting with ASP.NET Core 6, they are available
    through properties of `WebApplication` and `WebApplicationBuilder` in `Program.cs`.
    These framework services can be injected into controllers and other services through
    any of the DI types we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application services are services injected into the container by the developer.
    These services will be registered using the `Services` property of `WebApplicationBuilder`.
    The following code snippet shows how to register the `IWeatherProvider` application
    service with the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn about the lifetime of these services and
    how they are managed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an
    ASP.NET Core 6 Web API*, to learn about the code present in the `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding service lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you register a service with a specified lifetime, the container will automatically
    dispose of the object according to the lifetime specified. There are three types
    of lifetimes available to use with Microsoft DI Container, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddTransient` extension method is used to register with this lifetime, as
    illustrated in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A transient lifetime is normally used for stateless, lightweight services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ServiceProvider` is disposed of on application shutdown. The `AddSingleton`
    extension method is used to register with this lifetime, as illustrated in the
    following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DbContext` are registered with a scoped lifetime. The `AddScoped` extension
    method is used to register with the scoped lifetime scope, as illustrated in the
    following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The lifetime type needs to be chosen wisely in application development. A service
    should not depend on a service that has a shorter life span than its own; for
    example, a service registered as a singleton should not depend on a service that
    is registered as transient. The following table shows which lifetimes can safely
    depend on which other lifetime scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – DI relationship'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 – Lifetime dependency
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you need not worry about scope validation. Built-in scope validation
    is done in ASP.NET Core 6 when the environment is set to `InvalidOperationException`
    is thrown while building the application. This can be explicitly turned on by
    enabling `ValidateScopes` options for all environment configurations while registering
    `ServiceProvider`, as shown in the following code snippet. Here, while creating
    a host builder, `ValidateScopes` is set to `true` to turn on the scope validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an ASP.NET Core 6 web application to understand the service lifetime.
    We will be creating different services and registering them with the singleton,
    scoped, and transient lifetime scopes and observing how they behave. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new ASP.NET Core web application (`DISampleWeb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new project folder with the name `Services` and add three classes:
    `ScopedService`, `SingletonService`, and `TransientService`. Add the following
    code (all these services will be the same without any real code in them; we just
    register them with different lifetime scopes as per their name):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SingletonService.cs`: This class will be registered with the singleton lifetime
    scope, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TransientService.cs`: This class will be registered with the transient lifetime
    scope, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, register these services in `Program.cs` with `IServiceCollection`, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The collection of service descriptors, `IServiceCollection`, is exposed via
    the `Services` property of `WebApplicationBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `HomeViewModel` model class under the `Models` folder, which will
    be used to show data retrieved from the services registered previously. The following
    code snippet illustrates how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we registered `ScopedService`, `SingletonService`, and `TransientService`
    with ASP.NET Core 6 IoC container, we will get these services via constructor
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add code to get these services in `HomeController` and `Views`
    to show data retrieved from these objects on the home page. Modify the home controller
    to get two instances of `ScopedService` and `TransientService` and set `ViewModel`
    with the object hash code of the service object. The solution structure is shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Solution structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Solution structure
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `GetHashCode` method returns the hash code of the object. This will change
    per instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the constructor of `HomeController` to accept the registered services
    and define private fields to reference service instances, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, modify the `Index` method under `HomeController` to set `HomeViewModel`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, modify `Index.cshtml` under the `~/Views/Home` folder to show `HomeViewModel`
    on the page, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the application. You will see an output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Sample output on the first run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Sample output on the first run
  prefs: []
  type: TYPE_NORMAL
- en: If we observe the output, the `ScopedService` are the same. This is because
    only one object for `IScopedService` is created per request scope. Please note
    the IDs may be different when you run the code as they are generated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The IDs of the transient service are different for both services. As we learned,
    this is because a new instance is created for every request to IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, refresh the page again. You''ll see an output that looks something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Sample output on the second run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Sample output on the second run
  prefs: []
  type: TYPE_NORMAL
- en: If we compare the outputs in both *Figure 5.3* and *Figure 5.4*, we will notice
    that the ID of `SingletonService` did not change—this is because only one object
    is created for a singleton object per lifetime of the application. Up until now,
    we have seen how the service lifetime is managed based on the registration. It
    is also important to understand when objects are to be disposed of. In the next
    section, we will learn about the disposal of services.
  prefs: []
  type: TYPE_NORMAL
- en: Disposal of services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned earlier in this chapter, the disposal of objects is the responsibility
    of the IoC container framework. The container calls the `Dispose` method on those
    services that implement `IDisposable`. Services created by the container should
    never be disposed of by the developer explicitly. Similarly, developers are responsible
    for disposing of instances created by them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, where the `SingletonService` instance
    is registered with the singleton scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple implementation of `DisposableSingletonService`, refer to the code
    at the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, we created an object of `DisposableSingletonService`
    and registered it with IoC container. The service instance is not created by the
    container. In this case, IoC Container does not dispose of the object; it is the
    developer''s responsibility to dispose of it. We can dispose of objects when an
    `ApplicationStopping` event is fired from `IHostApplicationLifetime`, which is
    exposed through the `Lifetime` property of `WebApplication`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `IHostApplicationLifetime` is injected by the
    runtime into `WebApplication`. This interface allows consumers to be notified
    of `ApplicationStarted`, `ApplicationStopped`, and `ApplicationStopping` application
    lifetime events. To dispose of the singleton object, we will call a Dispose()
    method by registering to the `ApplicationStopping` lifetime event.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new addition in .NET 6 to DI is the support of `IAsyncDisposable` for scopes.
    A new `CreateAsyncScope` extension method is added to `IServiceProvider` to support
    the creation of an asynchronous service scope, and an `AsyncServiceScope` wrapper
    is added, which implements `IAsyncDisposable`. The following code disposes of
    the scopes asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Going forward, if the dependency `CreateAsyncScope` wherever you are creating
    scopes manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following Microsoft documentation to learn more about DI guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines)'
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have looked at service lifetimes and how they are disposed
    of in .NET 6\. In the next section, we will learn about managing application services.
  prefs: []
  type: TYPE_NORMAL
- en: Managing application services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ASP.NET Core 6, when a request is received by `MvcMiddleware`, routing is
    used to select a controller and action method. `IControllerActivator` creates
    an instance of the controller and loads constructor arguments from DI Container.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Understanding service lifetimes* section, we saw how application services
    are registered and how their lifetimes are managed. In the example, the services
    were injected through a constructor, which is known as constructor injection.
    In this section, we will see how to achieve method injection and go through different
    ways application services can be registered and accessed in ASP.NET Core 6 IoC
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing registered services via method injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, we saw how the dependency service is injected into
    the controller constructor and the reference is stored in a local field that is
    used to call a method/**application programming interface** (**API**) of the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we don''t want the dependency service to be available in all actions
    of the controller. In such scenarios, the service can be injected via method injection.
    This is done by making a parameter with the `[FromServices]` attribute, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Minimal APIs introduced in ASP.NET Core 6 allow us to request DI services in
    route handlers without explicitly marking them with the `[FromServices]` attribute,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering how the runtime differentiates injected services from
    other parameters. To achieve that, .NET6 introduced a new `IServiceProviderIsService`
    interface, which helps to identify that a given service type is registered in
    the DI container without creating an instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see the registration of multiple instances for
    the same service type and how to access them.
  prefs: []
  type: TYPE_NORMAL
- en: Registering multiple instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a given interface, we can register multiple implementations with the IoC
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If more than one implementation is registered with the same service type, the
    last registration will take precedence over all previous registrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following service registration, where the `IWeatherForecastService`
    service is registered with two implementations—`WeatherForecastService` and `WeatherForecastServiceV2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when there is a request for an instance of `IWeatherForecastService` from
    the controller, an instance of `WeatherForecastServiceV2` will be served, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, it might appear that the registration of `WeatherForecastV2`
    is overwriting the previous registration of `WeatherForecastService`. However,
    ASP.NET Core 6 IoC container will have all registrations of `IWeatherForecastService`.
    To get all registrations, fetch the service as `IEnumerable`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This may be useful in scenarios such as executing a `Services` property of `WebApplicationBuilder`.
    So, in the future, when there is an addition of a rule or the removal of an existing
    rule, the change will only be to inject a new service into the `Services` property.
  prefs: []
  type: TYPE_NORMAL
- en: Using TryAdd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will learn about how we can avoid accidentally overriding
    already registered services.
  prefs: []
  type: TYPE_NORMAL
- en: The `TryAdd` extension method registers services only when no registration exists
    for the same service. The `TryAdd` extension method is available for all lifetime
    scopes (`TyrAddScoped`, `TryAddSingleton`, and `TryAddTransient`).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the service registration shown in the following code snippet, when there
    is a request for `IWeatherForecastService`, IoC container serves `WeatherForecastService`,
    not `WeatherForecastServiceV2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To overcome side effects that might occur with duplicate registrations, it is
    always recommended to use `TryAdd` extension methods to register a service.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to replace an already registered service.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing an existing registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ASP.NET Core 6 IoC container provides a way to replace existing registrations.
    In the following example, `IWeatherForecastService` is initially registered with
    `WeatherForecastService`. It is then replaced with `WeatherForecastServiceV2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `Replace` instance of `WeatherForecastServiceV2`, an implementation
    is served to the constructor of `WeatherForecastController`. In the following
    code snippet, unlike in the *Registering multiple instances* section, we will
    only see one object in the `weatherForecastService` constructor variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Till now in this section, we have learned about registering and replacing services
    with the IoC container. There may be times when we need to delete current registrations.
    Consider a scenario where you wish to utilize services and registrations from
    a library but you don't have access to its source code. If you reimplement some
    of the interfaces from that library and reregister them with the container, you
    might see some unexpected behavior. In the next section, we will see how to remove
    a registered service.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an existing registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove an existing registration, ASP.Net Core 6 IoC container provides the
    `Remove` extension. You can use the `RemoveAll` method to remove all registrations
    related to a service, as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, the `Remove` method removes the registration
    of the `WeatherForecastService` implementation from the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Up until now, we have seen how we work with complex services, but when it comes
    to generic open types, it will be difficult to register every generic constructed
    type. In the next section, we will learn how to deal with generic open-type services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about generic types, you can refer to the following website:
    [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types).'
  prefs: []
  type: TYPE_NORMAL
- en: Registering generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will introduce you to dealing with generic-type services with DI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of generic types, it does not make sense to register the service
    for each type of implementation that is in use. ASP.NET Core 6 IoC container provides
    a way to simplify the registration of the generic type. One such type that is
    already provided by the framework itself is `ILogger`, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For your reference, you may visit the following link: [https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: Another use case for generics is with a generic repository pattern used with
    the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: With all the registrations we have, the `ConfigureServices` method can grow
    big and can no longer be readable. The next section will help you learn how to
    address that.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods for code readability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pattern that is followed in the ASP.NET Core 6 framework to make code look
    more readable is to create an extension method with a logical grouping of service
    registrations. The following code tries to group and register notification-related
    services using an extension method. General practice is to use the `Microsoft.Extensions.DependencyInjection`
    namespace to define service registration extension methods. This will make the
    developer use all the functionality related to DI just by using the `Microsoft.Extensions.DependencyInjection`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, notification-related services were registered
    with `AddNotificationServices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the extension method is created, we can use the `AddNotificationServices`
    method to register notification services under `ConfigureServices`. This will
    make `ConfigureServices` become more readable. The code is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We have seen how to inject services into controllers and other classes. In the
    next section, we will learn how to inject services into views.
  prefs: []
  type: TYPE_NORMAL
- en: DI in Razor Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of views in MVC is to display data. Most of the time, data displayed
    in views is passed from the controller. Passing all required data from controllers
    is recommended considering the **separation of concerns** (**SoC**) principle,
    but there may be cases where we want to view specific services from pages such
    as localization and telemetry services. Using DI supported by Razor views, we
    can inject such services into views.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about injecting services into views, let''s modify the `DISampleWeb`
    application that we created in previous chapters. We will be modifying the `DISampleWeb`
    application to display additional content on the home page if a flight flag is
    set. Add the `isFlightOn` configuration, as shown in the following code snippet,
    to `appsettings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify the index view under `Home` to display the content under `Flight`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Iconfiguration` service, which provides the functionality of reading
    the configuration file, is injected into the Razor view using the `@inject` keyword.
    The injected configuration service is used to get the configuration and display
    additional content based on the settings. We can inject any service registered
    with `IserviceCollection` into Razor views using the `@inject` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have seen how we can leverage the .NET 6 built-in IoC container.
    In the next section, we will learn about leveraging third-party containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the built-in container is sufficient for most of our scenarios, .NET
    6 provides a way to integrate with third-party containers that can be leveraged
    if need be.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a closer look at how the framework wires up the services. When the
    `Startup` class is registered with `HostBuilder` in `Program.cs`, .NET Framework
    uses reflection to identify and call the `Configure` and `ConfigureServices` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a snippet from the `LoadMethods` method of the `StartupLoader` class
    in ASP.NET Core 6 (refer to the code from [https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippet, we can see that the first two methods, `FindConfigureDelegate`
    and `FindConfigureServicesDelegate`, are to find the `Configure` and `ConfigureServices`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The last line is for `ConfigureContainer`. We can define a `ConfigureContainer`
    method in the `Startup` class to configure the services into a third-party container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the popular DI frameworks available for ASP.NET Core 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity**: Unity was initially built by Microsoft and is currently open sourced.
    This is one of the oldest DI containers for .NET. The documentation is available
    at the following link: [http://unitycontainer.org/](http://unitycontainer.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autofac**: This is one of the most popular DI containers. It has comprehensive
    documentation available at the following link: [https://autofaccn.readthedocs.io/en/latest/index.html](https://autofaccn.readthedocs.io/en/latest/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Injector**: This is one of the late entrants on the list. The documentation
    can be found at the following link: [https://simpleinjector.readthedocs.io/en/latest/index.html](https://simpleinjector.readthedocs.io/en/latest/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Castle Windsor**: This is one of the oldest DI frameworks available for .NET.
    See its documentation at the following link: [http://www.castleproject.org/projects/windsor/](http://www.castleproject.org/projects/windsor/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though there are a few differences between these frameworks, there is generally
    feature parity. It is mostly the developer's experience that determines the choice
    of framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's see how to leverage the Autofac third-party IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Autofac IoC container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Autofac is one of the most popular IoC containers among the developer community.
    As with any other IoC container, it manages dependencies between classes so that
    applications remain easy to change as they grow in complexity and size. Let''s
    learn how to use Autofac to register the same `WeatherProvider` service that we
    used earlier in this chapter. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using the ASP.NET Core web API template and name it `AutofacSample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Autofac.Extensions.DependencyInjection` NuGet package reference to
    the `AutofacSample` project, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to register `AutofacServiceProviderFactory` with `ConfigureHostBuilder`
    so that the runtime will use the Autofac IoC container. In `Program.cs`, register
    the Autofac SP factory, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s register the `IWeatherProvider` service that we used in the *Types
    of DI* section with the Autofac container. Call the `ConfigureContainer` method
    on the `ConfigureHostBuilder` property of `WebApplicationBuilder` in `Program.cs`
    to register `IWeatherProvider` with the `WeatherProvider` implementation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similar to the default .NET IoC container, we get the `IWeatherForecast` service
    injected into the `WeatherForecastController` controller, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you run the project and navigate to the `https://localhost:7184/WeatherForecast`
    **Uniform Resource Identifier** (**URI**), you will see the output in the browser,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Final output for the container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Final output for the container
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we have seen the use of the third-party Autofac IoC
    container in place of the default container provided by .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the concepts of DI, which helps to write loosely
    coupled, more testable, and more readable code. This chapter covered the types
    of DI and how they are supported in ASP.NET Core 6\. We have also seen how object
    lifetime is managed with different types of registrations. This chapter also introduced
    you to some of the popular third-party IoC containers available to further explore.
    We will be using the concepts learned in this chapter to build our e-commerce
    application. In [*Chapter 15*](B18507_15_Epub.xhtml#_idTextAnchor1803), *Testing*,
    we will also see how DI can help with testability.
  prefs: []
  type: TYPE_NORMAL
- en: As recommended in [*Chapter 1*](B18507_01_Epub.xhtml#_idTextAnchor020), *Designing
    and Architecting the Enterprise Application*, under the *Separation of concerns/single
    - responsibility architecture* section, we always try to have services registered
    via interfaces. This will help with changing the concrete implementation at any
    time without changing the client implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to configure .NET 6 and understand the
    different configurations while learning how to build a custom one.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following is not a framework service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `IConfiguration`
  prefs: []
  type: TYPE_NORMAL
- en: b. `IApplicationBuilder`
  prefs: []
  type: TYPE_NORMAL
- en: c. `IWeatherService`
  prefs: []
  type: TYPE_NORMAL
- en: d. `IWebHostEnvironment`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: DI is one of the mechanisms to achieve IoC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: An injected service can depend on a service that has a shorter
    life span than its own.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is not a valid lifetime scope of ASP.NET Core 6 IoC container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Scoped
  prefs: []
  type: TYPE_NORMAL
- en: b. Singleton
  prefs: []
  type: TYPE_NORMAL
- en: c. Transient
  prefs: []
  type: TYPE_NORMAL
- en: d. Dynamic
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  prefs: []
  type: TYPE_NORMAL
