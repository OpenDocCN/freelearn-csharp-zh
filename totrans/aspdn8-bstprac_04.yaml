- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Security from the Start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next to performance, security should always be a top priority when building
    web applications. The ability to create secure web applications continues to be
    a problem with the evolving landscape of internet threats such as **cross-site
    scripting** (**XSS**) and injection techniques. While the best developer can safeguard
    an application against even the worst threat, most attacks succeed through human
    interaction and environmental issues. The best approach for developers to protect
    their applications is to start from the ground up and create as many roadblocks
    as possible to deter even the most vigilant attackers from gaining access to their
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll learn how to identify highly sensitive data and how to secure access.
    We’ll then move on to common security practices and provide various ASP.NET Core
    features that you can apply to your applications. Finally, we’ll review the top
    three security threats according to the **Open Worldwide Application Security
    Project** (**OWASP**) and how to safeguard your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Security Practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguarding Against the Top 3 Security Threats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand what is considered sensitive data,
    a variety of common security practices in the industry, and how to safeguard yourself
    against the top three threats according to the OWASP Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we will talk about security in this chapter, most of the discussion will
    contain small snippets of code that you can include in your projects. Access to
    a code editor isn’t necessary for this chapter to understand the essentials of
    security at a developer level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll examine terms and concepts regarding how to identify
    the data you need to secure and explain three extremely important ways to secure
    your website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Too often, when developers start to build an ASP.NET web project, security
    is usually applied at the end of a project as opposed to being proactive and aware
    of security measures. One approach for implementing security is to examine your
    applications and look for these types of highly sensitive data throughout:'
  prefs: []
  type: TYPE_NORMAL
- en: Name and location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usernames and passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact information (phone number, email address, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social security number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Financials (customer plans, credit cards, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the intent of the web application, other types might be involved,
    such as specific access to a section where permissions are implied. Other types
    of data could be considered sensitive based on industry or even government regulations.
  prefs: []
  type: TYPE_NORMAL
- en: Security in your application should be examined based on the criteria discussed
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Do I have any sensitive data to protect?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on your application and the list in the previous section, ask yourself,
    “If any of the data is leaked and made public, would there be a problem?”
  prefs: []
  type: TYPE_NORMAL
- en: Exposing any data from the aforementioned sources would be a disaster. Keep
    sensitive information contained using encryption, access controls, and secure
    coding practices, and use it only when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Am I exposing anything through the application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When moving from one web page to another, am I passing something sensitive when
    maneuvering through the site? Is the application using primary keys in the URL?
    How is data passed to the next page?
  prefs: []
  type: TYPE_NORMAL
- en: Be mindful of visible clues to the users that contain information such as primary
    keys or sensitive information. We’ll discuss this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Am I sanitizing user input?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When requesting input from a user, it’s always a good practice to sanitize the
    data. Sanitization, or scrubbing, is the process of taking user input and confirming
    it’s not malicious content that could compromise the system. One philosophy is
    to never trust submitted data.
  prefs: []
  type: TYPE_NORMAL
- en: It’s extremely important to use light validation with JavaScript/HTML on the
    client side, along with heavy validation and sanitization of data on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Light validation would include ensuring the required fields are populated and
    contain the minimum and maximum length of data, and that certain fields meet a
    particular format (such as phone numbers, credit cards, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Heavier validation would reaffirm the light validation but also confirm various
    scenarios, such as that a user has access to something, referenced entities exist,
    or data disguised to cause malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a website, it’s best to think about whether a user is required
    to log in to your site or not. If you’re creating a blog, there wouldn’t be a
    need to have users log in to view a post. They would just view it anonymously.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you require a user to log in to your website, there is a minimum
    of three mandatory requirements you must understand to *begin* to secure your
    application. We’ll look at them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When authenticating a user, you are *identifying and validating who they are*
    when they log in to your system.
  prefs: []
  type: TYPE_NORMAL
- en: This is the primary concept of Microsoft’s Identity framework. It offers various
    methods to authenticate a user using either username/password, the ability to
    use third-party social networks (such as Facebook, Google, or Twitter), use **two-factor
    authentication** (**2FA**), or even use third-party authenticators.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already experienced this on a website where you have to enter your
    username and password. That is step one in authenticating a user. Once verified,
    you are then asked to enter the code that’s been sent to your email or the authenticator
    app on your phone. That is step two.
  prefs: []
  type: TYPE_NORMAL
- en: Many websites use a username and password to log in. While this is the bare
    minimum to secure a website, it may help to implement additional security measures
    when authenticating a user.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it’s a better approach to create as many additional roadblocks to protect
    your application from attackers as possible. The more obstacles, the less likely
    your site will be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the user has authenticated, what can they do in the system? This is where
    authorization enters the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is the *process of granting permission to do something in a system
    or on a website*. For example, authors of a blog are permitted to update their
    articles when they log in, but they are not allowed to edit other articles unless
    they are authorized to do so by an administrator. An authorization system would
    need to be in place for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the *Authentication* section, Microsoft’s Identity framework
    contains various techniques for implementing role-based and user-based claims
    throughout the system. In our previous example, we mentioned that authors are
    only allowed to update their own articles. In a role-based system, the authors
    could be grouped into an “Authors” role, allowing them to create and update their
    own articles. In a user-based system, special privileges could be assigned at
    the user level, such as editing other authors’ articles.
  prefs: []
  type: TYPE_NORMAL
- en: While Microsoft Identity is flexible enough to incorporate any kind of authorization
    mechanism, developers should think about how to structure application-level authorizations
    from the very beginning before writing one line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizations are extremely important when you’re identifying what a logged-in
    user can (and can’t) do on your website.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Sockets Layer (SSL)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re building a website, SSL is *absolutely required*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The necessity to have an SSL-enabled website protects you for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You want your visitors to know they are on a secure website.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prevents others on the same network viewing your login credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTPS helps prevent a **Man-in-the-Middle** (**MITM**) attack, where an attacker
    inserts themselves into a conversation between two users, possibly altering the
    exchange of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search Engine Optimization** (**SEO**). Google and other search engines use
    HTTPS as a ranking signal (reference: https://developers.google.com/search/blog/2014/08/https-as-ranking-signal).
    If you wanted to increase your chances of reaching number one in the search results,
    you should make your site SSL-enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most hosting companies *include* an SSL certificate free of charge for your
    sites. That’s how important SSL is to a website.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we identified what is considered sensitive data and learned
    about how to secure access using three critical concepts when building an ASP.NET
    Core application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look over some common security practices you can
    immediately start using in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Common Security Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, security seems to be a black box sometimes. You always hear
    about incidents where websites have been hacked, but you might think to yourself,
    “That couldn’t happen to me,” until it happens to you. When you witness a website
    you built being attacked first-hand, it’s a humbling experience.
  prefs: []
  type: TYPE_NORMAL
- en: While the techniques we’re about to cover only scratch the surface for ASP.NET
    websites, they encourage developers to become more *proactive* in their coding
    as opposed to finding out they were hacked and immediately becoming *reactive*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review common security practices in the industry you
    can use to protect yourself so that you know what your system is doing and are
    not exposing too much to the world. We’ll learn about the different types of logs,
    how to update libraries and frameworks, and how to remove header information.
    We’ll finish this chapter by learning how to encrypt Entity Framework Core database
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve created your website, some extra features are required before you
    can roll out the red carpet for everyone to enjoy it.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know what’s going on with your website? How will you know when someone
    deletes a post? How about a transaction? How long does it take for your Web API
    to make a full trip to present data? These questions should be answered by creating
    audit trails and enabling general logging for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Audit trails are a type of logging where you keep track of every action a user
    has executed in your system. Microsoft Identity should already be in place with
    logging code to sprinkle throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIS Logs are a type of audit trail. Every user accessing your system, including
    anonymous users, is logged through IIS. A simple log entry is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard data used in an audit trail would contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Date/time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address/port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action taken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user who executed the action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An entity state before and after the action was executed (*optional*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General logging is carried out more at an application level as opposed to a
    system level. Most general logging includes data such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: Date/time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log type (informational, warning, or error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comment about the action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method/action/section name performing the action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration of the process (*optional*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types of logs are essential in the API world. These logs are created by
    the developer and stored on a disk or in a database. Once you create a Web API,
    there will be moments when you’ll wonder what it’s doing and why it’s taking so
    long to complete a request. Logs are windows to the system. What exactly is happening
    there?
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to security, your logs are gold. If someone impersonates another
    user, you can immediately examine the logs, identify the user and IP, and take
    the necessary actions to prevent it from happening again. This could be done by
    resetting a password, disconnecting or disabling a user from logging in, or even
    removing the user from the system overall.
  prefs: []
  type: TYPE_NORMAL
- en: Without logging, you’ll be unaware of events occurring in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your Framework and Libraries Current
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every developer has their favorite libraries and frameworks. With .NET, there
    are times when the framework requires an update to prevent possible security threats.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are aware of these security updates, it’s your responsibility to update
    the framework and/or libraries or notify someone who *can* perform the update
    (in case developers are not allowed to update servers) to protect against any
    type of threat based on the update’s vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Twice in my career, a .NET version had a security issue and a security update
    was released to be applied to the framework. The patch wasn’t applied immediately.
    Two weeks later, there was a breach and it was concluded the breach could’ve been
    prevented if the patch was applied two weeks earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It was a bad day for the company.
  prefs: []
  type: TYPE_NORMAL
- en: To see whether there is a security patch for .NET, refer to the Microsoft Update
    Catalog at https://www.catalog.update.microsoft.com/home.aspx.
  prefs: []
  type: TYPE_NORMAL
- en: Always Force SSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a visitor arrives through an HTTP URL and not HTTPS, it’s best to redirect
    them over to the secure portion of your site.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Strict Transport Security Protocol** (**HSTS**) is a security enhancement
    specified by the web application through a response header. When the browser receives
    an HSTS header, it prevents the user from using untrusted or invalid certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are limitations to using this:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern clients must support HSTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HSTS must establish one HTTPS connection to establish an HSTS policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web application must examine every HTTP request and redirect or reject the
    HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement this in your code, you must revisit the middleware and add the
    HSTS extension to a production environment. If you’ve just created a new web app,
    this is automatically added by default. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `app.UseHttpsRedirection()` method must appear after the `app.UseHsts()`
    extension method for the redirect to occur. This ensures your users will be visiting
    an SSL-enabled website.
  prefs: []
  type: TYPE_NORMAL
- en: Never Trust the Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve always likened this approach with the old saying, “Wearing suspenders with
    a belt.” At least you wouldn’t be caught with your pants down (as I use this as
    a security metaphor).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned near the beginning of this chapter, the intent here is to validate
    and sanitize data that’s been submitted by the client as best you can with JavaScript
    and HTML and then follow up with additional validation using C# when a form is
    submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, HTML 5 is now available in almost every browser, with the ability
    to apply a certain type to a text input, such as `type="number"` or `type="date"`.
    A welcome addition to this collection of input types is the ability to add a regex
    pattern to make validation even easier on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern allows for either 740 or 614 area codes to be in a phone number.
    If the pattern doesn’t match, you will receive a tooltip message stating why it’s
    not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The effect of a failed validation on an input](img/Figure_4.01_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The effect of a failed validation on an input
  prefs: []
  type: TYPE_NORMAL
- en: However, this does not justify neglecting validation on the server. For every
    field where a user inputs data, this same effort regarding validation should be
    applied when the server receives the data.
  prefs: []
  type: TYPE_NORMAL
- en: Always Encode User Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the easiest methods of sanitizing user input on the server is **encoding**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a user enters data and the data will be displayed on a page at any time,
    it’s best to encode the data to prevent XSS. The easiest way to encode user input
    is to dependency inject `HtmlEncoder` into a method to perform the encoding, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: .NET has various injectable services already defined. `HtmlEncoder` is one such
    service and is injected automatically by adding a `[FromServices]` attribute.
    Once we have our encoder, we can encode the string that’s been passed in and safely
    perform the action that’s been requested.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to encode user input from the client, making
    your site safe from malicious data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to hide what your servers are telling
    the world and how to make a reusable middleware component.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Your Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, several headers are added to HTTP requests to identify a server,
    the version used, what technology stack you’re using, and what powers your website.
    While these default headers are helpful, some of them aren’t required, while others
    can make your site more secure.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll focus on securing the recommended header changes through
    ASP.NET’s Middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Server Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s generally not a good idea to announce to the world what server you’re running
    and its version to an anonymous user. This exposes the type of web server you’re
    running and allows attackers to find IIS-specific techniques to gain access to
    your web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET, you can disable the server header for Kestrel (which is the open
    source server used in ASP.NET) in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we set `AddServerHeader` to `false`, the header doesn’t display the type
    and version of the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the server header, we also need to remove the `X-Powered-By`
    header to avoid exposing too much information. This can be achieved through middleware,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you’ll also have to add it to `web.config`, which should exist in
    the root of your project. Here are the only reasons `web.config` should exist
    in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Compression configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing specific IIS headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom MIME mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it doesn’t exist, add it to your project and add the following path to remove
    the `X-Powered-By` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Other header values to remove include `X-Aspnet-Version` and `X-AspnetMvc-Version`.
    The reason you should remove these headers is that they provide detailed information
    about what technology you’re running on your server. If there is a security flaw
    specifically for ASP.NET or ASP.NET Core MVC, these headers would make your site
    easier for attackers to narrow down their attacks and cause an inevitable security
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove these two headers, add the following two lines to the middleware
    in your `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: No Sniffing Allowed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you include `X-Content-Type-Options` in a header, this tells the browser
    to adhere to the MIME types registered in the `Content-Type` headers. These shouldn’t
    be changed or followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This marker tells the browser that these MIME types were intentionally configured
    to avoid MIME-type sniffing. This helps prevent attacks based on MIME-type confusion,
    where non-MIME types could be considered valid MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: No Framing Either
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the browser sees an `X-Frame-Options` header response, it indicates whether
    or not the browser should render the web page in `<frame>`, `<iframe>`, `<embed>`,
    or `<object>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `X-Frame-Options` header prevents clickjacking attacks, where someone could
    embed your content into other sites using frames, embeds, or objects. Setting
    this to `DENY` protects you from such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a security middleware component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To finalize this section, we’ll create a simple middleware component we can
    reuse in our .NET Core web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we created our middleware skeleton in [*Chapter 3*](B19493_03.xhtml#_idTextAnchor070),
    we can reuse the code for our `RemoveInsecureHeadersMiddleware` component, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget our extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use newly created security extension in our `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While we’ve added the most obvious headers, the good news is that you can update
    this component by adding additional headers to increase the security of your site
    even further.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to secure your headers and create a reusable
    middleware component for all of your web applications. In the next section, you’ll
    learn how to secure Entity Framework by encrypting your data, using stored procedures,
    and using parameterized queries.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Entity Framework Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entity Framework Core is one of those technologies that continues to amaze me.
    Every version of Entity Framework Core that’s released provides some new performance
    enhancement, a better approach to a technique, or some other method to make our
    lives a little bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn about how we can encrypt our data at the database
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting Your Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most valuable things to a company is data. To prevent an attack,
    one of the security measures you can take is to encrypt the data in the table.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we explained the types of data that require
    special attention, such as phone numbers, email addresses, and credit card data.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach is to apply security at the database level by using the database’s
    encryption technology, whether it’s SQL Server or a similar database.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server encrypts specific columns by using the **Encrypt Columns…** option
    in **SQL Server Management Studio** (**SSMS**), as shown in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The Encrypt Columns… option in SQL Server Management Studio](img/Figure_4.02_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The Encrypt Columns… option in SQL Server Management Studio
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Entity Framework, generating a DbContext will take the secure
    columns into account. Again, when creating encryption at the database level, it
    would be another roadblock to dissuade attackers from accessing sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we examined the best approach to protecting your data – that
    is, by encrypting your data using SQL Server’s **Encrypt Columns…** feature. In
    the next section, we’ll look at how to protect your pages from a **cross-site
    request forgery** (**XSRF**) attack.
  prefs: []
  type: TYPE_NORMAL
- en: Use Microsoft Entra for Securing Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, when logging into a website, it’s best to protect the
    database from intruders by encrypting the database. This means using existing
    methods as opposed to writing custom encryption algorithms. Creating a custom
    encryption algorithm should be avoided since most algorithms are easily broken
    through hacker tools. It’s best to use an existing framework like Microsoft Identity
    (now called Entra).
  prefs: []
  type: TYPE_NORMAL
- en: With Blazor and SPAs (Single-Page Applications) all the rage, it can be hard
    to secure an application using APIs. Previously, using Microsoft Identity through
    an API required a lot of effort making it harder to implement secure applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the latest .NET 8, Microsoft Entra introduces API-based calls for every
    aspect of security for web applications for **Single-Page Applications** (**SPAs**).
    When creating a new application, the following code adds an Entra-enabled REST-based
    API to an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates our web application and defines a JwtBearerDefault
    authentication scheme and adds a Web API specifically for Microsoft Identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'If JWT Tokens are not an option, .NET 8 also introduces Bearer Tokens as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The ability to write fast APIs along with simple authentication and authorization
    gives web developers more options when writing web applications using Blazor and
    SPAs. We’ll cover Microsoft Entra more in [*Chapter 9*](B19493_09.xhtml#_idTextAnchor207)
    when looking at creating better web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Your Pages with Anti-Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-site request forgery, or XSRF, is where an attack occurs, tricking a user
    to execute unwanted actions in a web application in which they’re currently authenticated.
    For example, a user could be tricked into using their credit card on a different
    site without them even knowing it.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent an XSRF attack through your web forms, the recommended approach is
    to use anti-forgery tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add some to our Middleware, we will add them to our pipeline, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When an HTML form is created, anti-forgery tokens are automatically generated
    when a `<form>` tag contains `method="post"` and one of the following conditions
    is true:'
  prefs: []
  type: TYPE_NORMAL
- en: The action attribute is empty (`action=""`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action attribute isn’t supplied (`<``form method="post">`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have other attributes attached to the form tag, you can explicitly add
    an `HtmlHelper` called `AntiForgeryToken()` inside the form tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a hidden input with an arbitrary value. If the value that
    comes back from the client is not the same as when the server originally sent
    it, the request will be denied.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about audit trails and general logging, how to
    keep your frameworks and libraries current, how to always force SSL to make your
    connections secure, and to never trust the client’s input. You also learned that
    every user input should be encoded when received by the server, how to secure
    your headers, how to secure your database by using Entity Framework Core, and,
    finally, how to protect your forms from cross-site request forgery attacks by
    using the `.AddAntiForgery()` Middleware service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at some real-world issues and how to solve the
    top three threats according to OWASP.
  prefs: []
  type: TYPE_NORMAL
- en: Safeguarding Against the Top 3 Security Threats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Open Worldwide Application Security Project, or OWASP, is a non-profit
    foundation dedicated to improving the security of software. Since new threats
    are emerging all the time, they keep a list called the OWASP Top 10, which is
    meant to keep software developers up to date regarding the latest security threats
    and how to prevent them. The Top 10 list includes the following security threats:'
  prefs: []
  type: TYPE_NORMAL
- en: Broken Access Control
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cryptographic Failures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insecure Design
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security Misconfiguration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vulnerable and Outdated Components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identification and Authentication Failures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software and Data Integrity Failures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security Logging and Monitoring Failures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Server-Side Request** **Forgery** (**SSRF**)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we’ll cover the top three threats and how to safeguard your
    ASP.NET Core application from these threats – that is, Broken Access Control,
    Cryptographic Failures, and Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Broken Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broken access control is when a user can perform a particular act in the system
    outside of their intended permissions. Permission checks could be missing in the
    software, or the correct permissions might not have been checked in the software.
  prefs: []
  type: TYPE_NORMAL
- en: The key word to focus on here is **authorization**. Authorizing users into your
    system is a big responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to get better at access control.
  prefs: []
  type: TYPE_NORMAL
- en: Denying Access by Default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When someone visits a site, consider them anonymous and restricted from the
    administrative area. When an administrator adds someone to the system, they are
    now authenticated and should be able to log in to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Your authorization system should be thoroughly tested. Even though a user is
    allowed to log in, they shouldn’t be able to do anything unless an administrator
    authorizes them.
  prefs: []
  type: TYPE_NORMAL
- en: “Deny by default” means that when a user uses the system, they should be denied
    access until permissions are granted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Razor Pages, you can use the `.AddRazorPages()` Middleware component configuration
    to authorize certain pages and folders, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `AddRazorPages` method, we are only allowing authenticated users into
    the `Admin` area; anonymous users can only go to the root of the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'For controller-based pages such as ASP.NET MVC, you can use the `[Authorize]`
    attribute to allow authenticated users to view the page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Index` page isn’t available to the authenticated
    user because the `[Authorize]` attribute is on `MySecretController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want the `Index` page to be available to authenticated users, put
    the `[Authorize]` attribute on the `Index()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These techniques deny anonymous users by default, which should be the proper
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Exposing Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you’re building a blog, it’s best to have a URL without a post ID as an
    integer. When I’ve written blog posts, I’ve seen hits on my page before the page
    was public. It was great to see people were interested in looking at my latest
    post, but how were they getting to it? They would go to my blog, pull up the latest
    post, and add `1` to the post ID. There it was – an unfinished post in all its
    unfinished glory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this type of scenario on a bank website. A user logs in to their account
    and they see the following URL: https://www.bobsbank.com/view/accountid=511324.'
  prefs: []
  type: TYPE_NORMAL
- en: A curious user could add `1` to the account ID and view another person’s account.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid exposing accounts or primary keys to users and, if a user does guess an
    account number, confirm the authenticated user is the owner of their account before
    viewing it.
  prefs: []
  type: TYPE_NORMAL
- en: Final Notes on Broken Access Controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some other things you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Audit trails and logs are gold. They will help you identify risks and patterns
    with users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm your authorization system works by running unit tests and integration
    tests. We’ll cover unit and integration tests in a later chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned how to protect ourselves from broken access controls
    by denying users by default, hiding primary keys, and protecting certain pages
    by confirming users are allowed to view that page, as well as how to implement
    audit trails and logs and battle-test our authorization system.
  prefs: []
  type: TYPE_NORMAL
- en: In this next section, we’ll look at how to protect against cryptographic failures.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic Failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OWASP considers cryptographic failures as sensitive data that is unencrypted,
    failed security measures that use invalid access control, and even stale server
    environments, such as servers that don’t contain the latest security patches.
    This includes using industry-proven encryption algorithms which are already included
    in Microsoft Entra.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections detail more common incidents in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting Clear Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are transmitting sensitive data across the wire, it should be encrypted
    by using an SSL connection.
  prefs: []
  type: TYPE_NORMAL
- en: A general rule of thumb is that the client should be the one sending sensitive
    data to the server, not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to send sensitive data back to the client for approval, it’s best
    to mask the data somehow for display purposes (for example, using XXXX-XXXX-XXXX-9999
    for credit cards) and, when updated, confirm this by having the authenticated
    user re-enter their password or providing some way to authenticate them again.
  prefs: []
  type: TYPE_NORMAL
- en: Invalid/Expired SSL Certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once your code gets to a server, its primary job is to deliver the data as fast
    and as securely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates are required for SSL to create secure connections that have an
    expiration date. There should be some reminder or notification letting administrators
    know when a certificate expires. It’s not recommended to continue using an expired
    certificate on your site.
  prefs: []
  type: TYPE_NORMAL
- en: Unencrypted Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, if your database contains sensitive information, it’s best to be proactive
    and encrypt the database using the database’s recommended encryption method.
  prefs: []
  type: TYPE_NORMAL
- en: Final Notes on Cryptographic Failures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at some final notes:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid weak algorithms such as MD5, SHA1, or PKCS number 1 v1.5, which are easy
    algorithms to break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid sending sensitive data to the client. If this is necessary, mask the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use proper access key management, storing keys in safe locations such as Microsoft’s
    Key Vault, Google’s Cloud Key Management, or Amazon’s Key Management Service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned how to avoid cryptographic failures by avoiding
    sending clear text, updating stale or invalid SSL certificates, and always encrypting
    the database if it contains sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section, we’ll look at how injection can impact your application.
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2017, OWASP reported SQL injection was the top threat when writing code for
    the web. Now, their Top 10 includes simply “injection,” which is an umbrella term
    covering SQL injection and XSS as well.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already mentioned that you should never trust the client and always sanitize
    and encode user input, but it bears repeating since it is still considered a threat,
    even if it did move down two spots to number three.
  prefs: []
  type: TYPE_NORMAL
- en: The great news is that Entity Framework Core supports parameterized queries
    to help you avoid SQL injection. However, this feature doesn’t mean you don’t
    have to sanitize input from users.
  prefs: []
  type: TYPE_NORMAL
- en: Script Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Script injection is when someone enters a script tag in a text box and the value
    is accepted and saved in the database. When the data is displayed on the page,
    the script is triggered and performs a particular action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple extension method that searches for and destroys malicious
    tags from HTML using regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While this `.Sanitize()` extension method removes any malicious tags from a
    string, if you are passing in HTML-formatted text, it also removes any tag using
    any JavaScript events on tags (such as `onclick='alert("gotcha");'`). It then
    returns the sanitized string for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this extension method like any other extension method with a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You could even extend the method further so that it includes other safeguards,
    such as encoding the string before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: Always validate, filter, and sanitize input from the user. No matter what.
  prefs: []
  type: TYPE_NORMAL
- en: Final Notes on Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some final things you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The further you can keep users (and users with malicious intent) away from the
    database, the better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm you have a `maxlength` attribute on single-line inputs to minimize how
    many characters are acceptable and limit the ability to allow scripts in HTML
    input fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injection continues to be a credible threat and has always been listed on OWASP’s
    Top 10 list.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to safeguard our code by understanding what
    sensitive data is and how to secure it using authentication, authorization, and
    SSL-enabled connections.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we reviewed some common standards in the
    industry, such as logging, keeping our frameworks and libraries up-to-date, and
    always redirecting to SSL-enabled sites. After that, we learned to never trust
    client data and that we should validate, filter, and sanitize it and always encode
    it, and not announce to the world what server and version we’re running by adding
    or removing security headers. We even created a reusable security middleware component.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched on encrypting database columns with SQL Server and how it’s
    important to protect fields by being proactive, and why creating a custom encryption
    algorithm should be avoided.. We also learned how to avoid cross-site request
    forgery by using anti-forgery tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined the top three threats as determined by the OWASP Foundation
    and how to properly protect ourselves from Broken Access Control, Cryptographic
    Failures, and Injection of all types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll pick up the discussion of Entity Framework Core once
    more and learn how to optimize data access using Entity Framework Core by using
    some intuitive techniques.
  prefs: []
  type: TYPE_NORMAL
