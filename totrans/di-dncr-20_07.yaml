- en: Interception
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截
- en: We have already discussed two pillars of the DI ecosystem in the previous two
    chapters. Those pillars provided us with ways to identify dependencies, register
    them and then manage their lifetimes as required. In this chapter, we are going
    to cover something different which addresses the architectural problem of DI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们已经讨论了 DI 生态系统的两个支柱。这些支柱为我们提供了识别依赖项、注册它们以及根据需要管理它们的生命周期的途径。在本章中，我们将介绍一些不同的事情，它解决了
    DI 的架构问题。
- en: An application without security, logging, caching, transaction management, and
    so on seems very incomplete. When we write codes to cover up all these functionalities
    for the app, we might end up writing repetitive codes in each module all around
    the application. Even if Dependency Injection has an existence in our application,
    solving the purpose of managing the requirements of a class and trying to provide
    all the types needed for logging, or others as mentioned previously, violates
    SRP and DRY. Thus, we need a different approach to solve this problem and that
    is **Interception**. Simply put, Interception will help us dynamically inject
    blocks of code wherever required.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有安全、日志记录、缓存、事务管理等功能的程序似乎很不完整。当我们编写代码来覆盖所有这些功能时，我们可能会在应用程序的每个模块中编写重复的代码。即使我们的应用程序中存在依赖注入，试图管理类的需求并提供之前提到的日志记录或其他类型，也违反了
    SRP 和 DRY 原则。因此，我们需要一种不同的方法来解决这个问题，那就是 **拦截**。简单来说，拦截将帮助我们动态地在需要的地方注入代码块。
- en: Now, you might have a question regarding when and how we can inject this code.
    Let's hold on to the *how* for now and focus on the *when*. We will discuss the
    *how* soon. To answer *when*, the injection can be done before or after, or it
    can even totally replace the actual method execution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会有一个关于何时以及如何注入此代码的问题。现在我们先保留“如何”这个问题，专注于“何时”。我们很快会讨论“如何”。为了回答“何时”，注入可以在执行之前或之后进行，甚至可以完全替换实际的方法执行。
- en: In this chapter, we will understand what Interception is and how it can be implemented.
    We will find out possible techniques to interrupt the flow of execution. Definitely,
    we will discuss why we even need *Interception*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解拦截是什么以及如何实现它。我们将找出可能的干扰执行流程的技术。当然，我们还会讨论为什么我们需要拦截。
- en: Patterns and principles of Interception in .NET Core is the next thing we are
    going to illustrate. We will even extend the concept of Interception in ASP.NET
    MVC Core using filters and middleware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 中拦截的模式和原则是我们接下来要说明的内容。我们甚至将扩展 ASP.NET MVC Core 中使用过滤器和中件间的拦截概念。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Cross-cutting concerns and aspects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横切关注点和方面
- en: '**Aspect-oriented programming** (**AOP**): Its types, advantages, disadvantages,
    and process'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向切面编程**（**AOP**）：其类型、优点、缺点和过程'
- en: Demos of each type of AOP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种类型 AOP 的演示
- en: Interception adoption in ASP.NET Core MVC using filters and middleware
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器和中件间在 ASP.NET Core MVC 中实现拦截
- en: Introducing Interception
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍拦截
- en: In this section, I will introduce you to *Interception* along with the connection
    it has with the *Dependency Injection*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您介绍 *拦截* 以及它与 *依赖注入* 的联系。
- en: Interception is another important pillar. Interception is the process through
    which we can easily intercept the call between a consumer and a service in order
    to execute certain codes before or after the service is invoked.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截是另一个重要的支柱。拦截是通过它可以轻松拦截消费者和服务之间的调用，以便在服务被调用之前或之后执行某些代码的过程。
- en: 'The following diagram shows what happens with and without the Interception
    process:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了有和无拦截过程时会发生什么：
- en: '![](img/280c7e04-d3e5-4578-b67b-515d13b3436c.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/280c7e04-d3e5-4578-b67b-515d13b3436c.png)'
- en: If we consider the preceding request as a call that comes to the index action
    of a controller named `CompanyController` and before the company details are served
    to the client, we can run a few bookkeeping tasks such as *Who requested the company
    details?*, *When was the call **made?*, *I**s the user authorized* *to receive
    the company details?*, and so on. For all these tasks, we have to stop the flow
    in the controller to do all these operations, and after we are done, we can again
    resume the main task of returning data. But all these tasks can't be written inside
    the controller action, because the main responsibility of the action is to return
    the company details. If we write everything inside the action method, it would
    violate SRP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的请求视为一个名为`CompanyController`的控制器索引操作的调用，并且在将公司详细信息提供给客户端之前，我们可以运行一些账目任务，例如*谁请求了公司详细信息？*，*何时进行的调用**？*，*用户是否有权接收公司详细信息？*等等。对于所有这些任务，我们必须在控制器中停止流程以执行所有这些操作，完成后，我们再次恢复主要任务，即返回数据。但是，所有这些任务都不能写在动作方法中，因为动作的主要责任是返回公司详细信息。如果我们把所有东西都写在动作方法中，就会违反SRP。
- en: The decorator
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Let's find out by a class that requires basic logging as a part of its operations.
    A `CompanyRepository` might have a method to assign a `User` to a `Company`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个需要基本日志记录作为其操作一部分的类来找出答案。`CompanyRepository`可能有一个将`User`分配给`Company`的方法。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, a client asks you to log some important information while this operation
    takes place, just for bookkeeping and future reference. The information could
    be the start time of the operation, end time of the operation, who requested for
    the operation, exceptions if any, and so on. The instant solution that comes to
    your mind might look something like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个客户端要求你在执行此操作时记录一些重要信息，仅用于账目和未来参考。这些信息可能是操作的开始时间、操作的结束时间、谁请求了操作、是否有异常等。你脑海中浮现出的即时解决方案可能看起来像以下这样：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the bold lines. `ILogger` can be injected to the repository through a
    constructor for log operations. We can also put `try...catch` block and log exceptions.
    Everything looks good, but don't you think the class is doing more than what it
    is intended for and that we are violating the **Single Responsibility Principle**
    (**SRP**). Therefore, let's think of another solution. How about the following?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意粗体线条。`ILogger`可以通过构造函数注入到存储库中，以进行日志操作。我们还可以放置`try...catch`块并记录异常。一切看起来都很好，但你难道不认为这个类做得比它打算的更多，并且我们违反了**单一职责原则**（**SRP**）吗？因此，让我们考虑另一个解决方案。以下是一个例子？
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We introduced a decorated `CompanyRepository` named as `LoggingCompanyRepository`,
    which is managing the logging part. It is initialized by taking repository and
    logger dependencies and executing the method as needed with log entries. Following
    the Decorator Pattern, the new class tries to coordinate the work between the
    repository and logger.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个名为`LoggingCompanyRepository`的装饰`CompanyRepository`，它负责管理日志部分。它通过接受存储库和日志记录依赖项并在需要时执行带有日志条目的方法进行初始化。遵循装饰器模式，新类试图协调存储库和记录器之间的工作。
- en: 'The final task would be to compose the decorator, which has the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务是组合装饰器，以下步骤如下：
- en: We can create the instances of `SqlCompanyRepository` and `SqlLogger` which
    derive from related abstractions.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建`SqlCompanyRepository`和`SqlLogger`的实例，它们源自相关抽象。
- en: Then, we create the instance of the decorator by injecting these dependencies.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过注入这些依赖项来创建装饰器的实例。
- en: We return the `CompanyService` instance with the decorated repository.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回带有装饰存储库的`CompanyService`实例。
- en: 'Refer to the following code for these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码以获取这些步骤：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is what Interception is all about. We are able to interrupt the call made
    to `AssignUserToCompany` of the concrete class `SqlCompanyRepository` because
    the `Service` is now composed of a decorator with the concrete class, instead
    of the direct code block. When you call the method, it would first go to the decorator's
    method and then call the concrete class method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是截获的全部内容。我们能够中断对具体类`SqlCompanyRepository`的`AssignUserToCompany`方法的调用，因为`Service`现在由一个装饰器与具体类组合而成，而不是直接代码块。当你调用方法时，它首先会调用装饰器的方法，然后调用具体类的方法。
- en: 'The following diagram explains the flow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图解说明了流程：
- en: '![](img/216a1091-ff1a-4ed5-8bc4-65a81ac9da54.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/216a1091-ff1a-4ed5-8bc4-65a81ac9da54.png)'
- en: Patterns and principles for Interception
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截获模式和原则
- en: You must be getting a hint that I want you to taste the DI from the perspective
    of not only injecting dependencies, but also managing and maintaining code for
    a good architecture. We explored the Decorator Pattern in the last section, which
    enabled us to decorate the concrete implementation with a little additional code
    without even touching any classes in the application. This forms the basis of
    Interception.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经察觉到，我想让你从不仅注入依赖，还管理并维护代码以构建良好架构的角度来体验依赖注入（DI）。在上一个章节中，我们探讨了装饰器模式，这使得我们能够在不触及应用中任何类的情况下，用一点额外的代码来装饰具体的实现。这构成了拦截的基础。
- en: With Interception, we clearly followed SOLID principles of Software Design.
    The moment we started designing the decorator class, that class played a vital
    role in the SRP. `CompanyRepository` is managing the database part and the `LoggingCompanyRepository`
    takes the responsibility for logging.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拦截，我们清楚地遵循了软件设计的SOLID原则。当我们开始设计装饰器类时，这个类在SRP中扮演了至关重要的角色。`CompanyRepository`
    负责数据库部分，而 `LoggingCompanyRepository` 负责日志记录。
- en: The **Liskov Substitution Principle** (**LSP**) demands that the consumer should
    not feel the change of any implementations of the dependency. We achieved this
    by the decorator implementing the same abstraction that the `Service` demanded,
    which is `CompanyRepository` so that we would be able to replace the original
    one `SqlCompanyRepository` with the decorator one `LoggingCompanyRepository`,
    without any breakage to the service codes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**里氏替换原则（Liskov Substitution Principle，LSP**）要求消费者不应该感觉到依赖任何实现的变化。我们通过装饰器实现了
    `Service` 所要求的相同抽象，即 `CompanyRepository`，这样我们就可以在不破坏服务代码的情况下，用装饰器 `LoggingCompanyRepository`
    替换原始的 `SqlCompanyRepository`。'
- en: As we were doing all the preceding steps, we did not change any class for implementing
    the decorator. Instead, we extended, which strongly followed the Open/Closed Principle.
    There is no such necessity to touch the `Service` class or the consumer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行所有前面的步骤时，我们没有更改任何类来实现装饰器。相反，我们进行了扩展，这强烈遵循了开放/封闭原则。没有必要触及 `Service` 类或消费者。
- en: The principles behind the Interception following SOLID gives us a hint as to
    how the Decorator Pattern is closely related to DI, since DI supports Interception.
    The Decorator Pattern is the fundamental building block of the concept, but the
    way we implemented it does not solve the architectural problems in hand. Let's
    analyze the associated benefits and problems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循SOLID原则的拦截背后的原则让我们了解到装饰器模式与DI密切相关，因为DI支持拦截。装饰器模式是这一概念的基本构建块，但我们的实现方式并没有解决手头的架构问题。让我们分析相关的利益和问题。
- en: Benefits of the Decorator approach
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式的好处
- en: 'With the Decorator approach, we achieved many benefits. Refer to the following
    list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器模式，我们获得了许多好处。请参考以下列表：
- en: The `Service` does not know what repository it is receiving. Notice that `CompanyRepository`
    and `LoggingCompanyRespository` are both declared as `CompanyRepository` instances.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service` 不了解它接收的是哪个仓库。请注意，`CompanyRepository` 和 `LoggingCompanyRespository`
    都被声明为 `CompanyRepository` 实例。'
- en: Just because the types are the same, there is no need to do any changes to the `Service`
    class. Moreover, we added logging behavior to the `CompanyRepository` class without
    even changing it. It supports the Open/Closed principle. All classes are intact.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就因为类型相同，没有必要对 `Service` 类进行任何更改。此外，我们在不更改 `CompanyRepository` 类的情况下添加了日志行为。这支持了开放/封闭原则。所有类都保持完好。
- en: We were able to intercept the concrete `SqlCompanyRepository` methods in order
    to have log entries. Thus, we did not violate the SRP of the repository.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够拦截具体的 `SqlCompanyRepository` 方法以实现日志条目。因此，我们没有违反仓库的单一职责原则（SRP）。
- en: However, we did not realize a few problems with this approach. This structure
    would lead us to a bad architecture in the long run. Let's find out why.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有意识到这种方法存在的一些问题。这种结构从长远来看会引导我们走向糟糕的架构。让我们找出原因。
- en: Instead of dealing with the instances manually, always use DI Container to resolve
    the dependencies. We will see how we can work with DI Container for Interception
    in a while.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是手动处理实例，始终使用DI容器来解析依赖。我们很快就会看到如何使用DI容器进行拦截。
- en: Problems of the Decorator approach
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式的问题
- en: 'In a typical project, we will have many of these repositories and services.
    We will definitely encounter the following problems:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的项目中，我们将拥有许多这样的仓库和服务。我们肯定会遇到以下问题：
- en: Imagine the number of lines of codes you would have to write to compose the
    decorators in order to do Interceptions for hundreds of classes
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，你需要编写多少行代码来编写装饰器，以便为数百个类进行拦截。
- en: The next thing is very important, which is actually the basis of our topic in
    discussion. What if you have to log in a thousand methods of those hundred classes.
    This is common and we need it in almost every method. Think of the work involved
    and the size of your app.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的一件事非常重要，这实际上是讨论主题的基础。如果你需要在那些一百个类的一千个方法中记录日志，这是常见的，我们几乎在每个方法都需要它。想想涉及的工作量和你的应用程序的大小。
- en: Due to all these, we will end up going for a different approach for intercepting
    calls to methods using Aspects. DI Containers make it easy for us to design aspects
    and attach Interceptors. Let's move on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些，我们将最终采用不同的方法来使用切面拦截方法调用。依赖注入容器使我们能够轻松设计切面并附加拦截器。让我们继续前进。
- en: Aspect-oriented programming
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向切面编程
- en: '**Object-oriented programming** (**OOP**) deals with techniques to solve real-world
    problems with underlying object models. To design a software, we need to adopt
    OOP along with good design methodologies in order to make it maintainable, consistent
    and reliable. There are many such patterns or problems we will encounter during
    the application development which are of design decisions, that can neither be
    solved by OOP practices nor with procedural approaches.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）处理使用底层对象模型解决现实世界问题的技术。为了设计软件，我们需要采用OOP以及良好的设计方法，以便使其可维护、一致和可靠。在应用程序开发过程中，我们会遇到许多这样的模式或问题，它们是设计决策，既不能通过OOP实践解决，也不能通过过程式方法解决。'
- en: In this chapter, we will address one design decision that can be managed easily
    by Aspects. To clarify, we can consider a simple example which is very often seen
    in codes and that is **logging**. We do logging in almost every method. This means
    you are repeating codes everyday violating the **DRY** (**Don't Repeat Yourself**)
    principle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一个可以通过切面轻松管理的设计决策。为了澄清，我们可以考虑一个在代码中非常常见的简单示例，那就是**日志记录**。我们在几乎每个方法中都进行日志记录。这意味着你每天都在重复代码，违反了**DRY**（**不要重复自己**）原则。
- en: 'The following diagram shows you the repeated codes of logging commonly found
    in your codes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了在您的代码中常见的大量重复日志代码：
- en: '![](img/3d5d05ef-62f3-4930-99ba-0d81f67aec70.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d5d05ef-62f3-4930-99ba-0d81f67aec70.png)'
- en: If I tell you that we can package those logging lines into one modular piece
    of code and just ask all the methods that need logging, to just import that while
    running, what would be your reaction? Yes, that is what an aspect is all about.
    So, we can write an aspect to manage logging. The pattern we follow in order to
    implement an aspect in our app is known as **Aspect-oriented programming** (**AOP**)*.*
    Itaims to separate or modularise these repeated codes from the core functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，我们可以将这些日志行打包成一个模块化的代码块，并要求所有需要日志记录的方法在运行时只需导入它，你会怎么反应？是的，这就是切面的全部意义。因此，我们可以编写一个切面来管理日志。我们在应用中实现切面时遵循的图案被称为**面向切面编程**（**AOP**）*。它旨在将这些重复代码从核心功能中分离或模块化。
- en: 'The following is a sneak peak of the solution with an aspect called `LoggingAspect`,
    which packages all the logging codes inside it and is attached to the methods
    as an attribute above the method (written like `[LoggingAspect]`). Don''t worry
    about the rules for how the logging lines are applied to the methods at the particular
    location such as *start* or *end* for now. We will learn all these soon, which
    are the concepts behind AOP:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为`LoggingAspect`的切面的解决方案预览，它将所有日志代码打包在其中，并作为方法属性附加到方法之上（写作 `[LoggingAspect]`）。现在不必担心日志行如何应用于特定位置的方法，例如*开始*或*结束*。我们很快就会学习所有这些，这些都是面向方面编程（AOP）背后的概念：
- en: '![](img/1715faca-ea25-4ace-bdbb-b785b0910fab.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1715faca-ea25-4ace-bdbb-b785b0910fab.png)'
- en: When we follow AOP in our application, we can easily attach these modules automatically
    to our methods. Thus, developers have all the freedom to only focus on the business
    logic or core concerns inside the methods, instead of worrying about all the repetitive
    code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中遵循AOP时，我们可以轻松地将这些模块自动附加到我们的方法上。因此，开发者可以完全专注于方法内的业务逻辑或核心关注点，而无需担心所有重复的代码。
- en: Cross-cutting concerns
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横切关注点
- en: 'A **concern** can be defined as a part of a system providing some specific
    functionality. If you consider a typical example of saving a user in your system,
    it may have a business logic something like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点**可以定义为系统的一部分，提供一些特定的功能。如果你考虑一个典型的例子，在你的系统中保存用户，它可能有一个类似以下的业务逻辑：'
- en: Validate all fields of user for proper datatype, `null` values, and so on.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证用户的所有字段，以确保正确的数据类型、`null`值等。
- en: Check for the user existence in the system by a unique value such as `Email`
    or `UserName`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过唯一值（如`Email`或`UserName`）检查系统中是否存在用户。
- en: If a user does not exist, create the user, otherwise update the user.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户不存在，则创建用户，否则更新用户。
- en: All these steps are denoted as **Business Logic**, which might be different
    in different applications since it depends on your requirements and design. So,
    our `SaveUser` method's principal duty is to perform all these steps, which can
    be defined as a **Main Concern**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都被标记为**业务逻辑**，这可能在不同的应用程序中不同，因为它取决于你的需求和设计。因此，我们的`SaveUser`方法的主要职责是执行所有这些步骤，这可以定义为**主要关注点**。
- en: 'However, in a typical application, these are not the only things that happen
    inside a `SaveUser` method. You might have to do the following during saving a
    user:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一个典型的应用程序中，这些并不是`SaveUser`方法中发生的唯一事情。在保存用户的过程中，你可能必须做以下事情：
- en: Check whether the logged-in user is authorized to save the user.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查登录用户是否有权限保存用户。
- en: Log in text/database that `SaveUser` started.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本/数据库中记录`SaveUser`开始。
- en: '[Perform the *Business Logic* (all the steps previously defined) ] - Main Concern.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[执行*业务逻辑*（所有之前定义的步骤）] - 主要关注点。'
- en: Log in text/database that the `SaveUser` method succeeded.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本/数据库中记录`SaveUser`方法成功。
- en: Steps 1, 2, and 3 are the steps which are secondary and don't align with the
    Main Concern. But these steps can't be ignored. Moreover, these particular steps
    are performed in almost every method of the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1、2和3是次要步骤，与主要关注点不匹配。但这些步骤不能被忽略。此外，这些特定的步骤几乎在应用程序的每个方法中都会执行。
- en: 'While our method is trying to run the Main Concern, these guys try to interfere
    and cut the execution and do something else. That''s why they are known as **Cross-Cutting
    Concerns**. These concerns are located throughout the application and affect the
    entire architecture. Have a look at the following diagram where the arrows indicate
    the Main Concern and the rectangular areas represent the Cross-Cutting Concerns:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的方法试图运行主要关注点时，这些家伙试图干扰执行并做其他事情。这就是为什么它们被称为**横切关注点**。这些关注点位于整个应用程序中，影响整个架构。看看以下图表，其中箭头表示主要关注点，矩形区域表示横切关注点：
- en: '![](img/ae91997c-b0ae-47a3-b12b-9fee783f0f59.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae91997c-b0ae-47a3-b12b-9fee783f0f59.jpg)'
- en: Aspect
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aspect
- en: In simple words, when we see some repetitive patterned codes throughout our
    app, that's the clue for us to consider them as Cross-Cutting Concerns. These are
    the code patches, which do not fit with the Main Concern inside the method in
    execution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当我们看到应用程序中存在一些重复的模式代码时，这就是我们将其视为横切关注点的线索。这些是代码补丁，它们与执行方法中的主要关注点不匹配。
- en: When I say *aspect* in the programming paradigm, it basically states the behavioral
    pattern independent of the actual task/concern at hand. So, when you package the
    Cross-Cutting Concerns into one modular piece that can be injected to the methods,
    you actually design an aspect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在编程范式中说*aspect*时，它基本上是指独立于实际任务/关注点的行为模式。因此，当你将横切关注点打包成一个可以注入到方法中的模块化部分时，你实际上设计了一个方面。
- en: 'For instance, we want to log at certain lines inside many methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望在许多方法中的某些行进行日志记录：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clearly, `Log` class methods help us to log debug steps and exceptions inside
    a method. This particular pattern can be seen often at many places in the app.
    That is what a Cross-Cutting Concern is. The actual task at hand for the `SaveUser`
    method is to update the user details such as `UserName`, `Email`, `Password`,
    and so on, but this method also takes the responsibility to log some lines into
    files, which violates the SRP. Also, when these kinds of patterns are repeated
    across the project, it does not follow the DRY principle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`Log`类方法帮助我们记录方法内部的调试步骤和异常。这种特定的模式在应用程序的许多地方都可以看到。这就是所谓的**横切关注点**。`SaveUser`方法实际的任务是更新用户详情，例如`UserName`、`Email`、`Password`等，但此方法还承担记录一些行到文件的责任，这违反了SRP原则。此外，当这些模式在项目中重复出现时，它并不遵循DRY原则。
- en: 'Look at the following diagram, which depicts logging as a common paradigm across
    layers of the application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23be4d3a-508f-4637-b303-3d1741f67b18.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: So, here, AOP comes to our rescue which encapsulates this pattern to log the
    start, log the end, and log the exception, and then wrap it around the `SaveUser`
    method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Another common scenario is wrapping our database operations with a `Transaction`
    block consisting of `Begin Transaction`, and `Commit/Rollback Transaction`. How
    about having someone else handling that part for us, while we concentrate on the
    core codes to operate on the database?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns can be commonly found in the application where you log
    steps, handle exceptions, manage cache, access control, and so on. For example,
    while handling exceptions, you wrap your code using a `try..catch` block so that
    you are able to operate on that exception found (log to text file/database or
    send email to admin, and so on). This particular pattern is needed inside every
    method. Now we need to find out a way to ask (more specifically wrap) every method
    that we need for exception handling, instead of adding the `try..catch` lines
    inside it. Thus, that wrapped modular piece can be termed as an aspect, which
    eventually wraps all methods instructed to it to perform the exception handling,
    instead of the methods themselves doing the same.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Aspect characteristics
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we try to encapsulate these Cross-Cutting Concerns to create aspects,
    we actually make sure they follow some characteristics:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrapper:** All these aspects will be a wrapper around some business functionalities.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle (SRP): **The wrapper is concerned only about
    one particular task. For example, logging will only do the task of logging and
    nothing else.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator Pattern: **The aspect then attached with the existing functions
    with the Decorator Pattern.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Close Principle: **When these repetitive codes were in business functions
    and we if needed any change in them in the future, then we would have to change
    the business function as it contains those pieces, which violates the Open Close
    Principle. Now, when we isolated those pieces to a module, the business functions
    became *Open* for extension, but *Close* to change.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the following diagram for a pictorial explanation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b1bffb1-1fbd-416e-8c42-fd5c4b1815b5.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: AOP is not a competitor of OOP. Both are totally different. One is not a replacement
    for the other. With all these characteristics, AOP helps us to maintain a good
    structure for the project, hence resulting in a good OOP practice.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me summarise the important advantages of AOP:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Increases modularity:** Common functionality is centralized into independent
    modules and is attached those modules or aspects at many places in the app.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manages Cross-Cutting Concerns:** The concerns which are scattered comes
    to one place which can be managed easily without making any code change to the
    actual business codes.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better architecture: **Separation of these concerns into singly responsible
    aspects helps us to architect and organise business needs without unnecessarily
    repeating ourselves in the codes.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的架构：**将这些关注点分离到单一责任方面有助于我们构建和整理业务需求，而无需在代码中不必要地重复自己。'
- en: Aspect attached locations
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方面附加位置
- en: 'There are basically three locations where an Aspect can be attached to a method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，方面可以附加到方法的基本有三个位置：
- en: '**On Start:** When we want an aspect to execute immediately before the underlying
    function execution.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时：**当我们希望方面在底层函数执行之前立即执行。'
- en: '**On Error: **Obviously, an aspect at this location will run only if an exception
    occurs in the method.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理：**显然，只有当方法中发生异常时，此位置的方面才会运行。'
- en: '**On Success:** Runs immediately after the method execution. However, it is
    limited to the functions which don''t throw exceptions.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功时：**在方法执行后立即运行。然而，它仅限于不抛出异常的函数。'
- en: Types of AOP
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP类型
- en: 'There are two techniques in AOP:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: AOP中有两种技术：
- en: '**Interceptors:** Dynamic, which attaches the interceptors during runtime'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拦截器：动态的，在运行时附加拦截器**'
- en: '**IL Code Weaving:** Static, which runs after compilation and inserts code
    into the assembly'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IL代码织入：**静态的，在编译后运行并插入代码到程序集'
- en: Static (post-compilation) ones include Fody, SheepAspect, Mono.Cecil, and PostSharp.
    Static might be faster, but we get more flexibility in a dynamic one, as we can
    change the code dynamically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 静态（编译后）的包括Fody、SheepAspect、Mono.Cecil和PostSharp。静态可能更快，但在动态的拦截器中我们获得更多的灵活性，因为我们可以在运行时动态地更改代码。
- en: Applying the aspects to the code depends on the framework used. There are different
    techniques to attach the aspects such as writing attributes, XML configuration,
    and fluent interfaces.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将方面应用于代码取决于所使用的框架。有不同的技术来附加方面，例如编写属性、XML配置和流畅接口。
- en: Investigating Interception
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查拦截
- en: To intercept means to prevent something or someone from reaching an intended destination.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截意味着阻止某物或某人达到预期的目的地。
- en: Interception (a programming paradigm), helps us to design aspects and inject
    cross-cutting concerns wherever demanded at the runtime. Using an Interceptor,
    we can easily intercept the calls to methods and properties in a class. To achieve
    this, we usually end up using an **Inversion Of Control** (**IoC**) container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截（一种编程范式），帮助我们设计方面，并在运行时根据需要注入横切关注点。使用拦截器，我们可以轻松拦截类中方法和对属性的调用。为了实现这一点，我们通常最终使用**控制反转**（**IoC**）容器。
- en: IoC provides the class functionality and then wraps it with our requested interceptor.
    Suppose somewhere in the code you ask for a class (say `Student`) to the IoC container
    of a specific type (say `IStudent`), which has an aspect for logging, then the
    IoC container would be able to provide the class (`Student`) with an interceptor
    decorated with it for the aspect demanded.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: IoC提供类功能，然后将其包装为我们请求的拦截器。假设在代码的某个地方，你向特定类型的IoC容器（例如`IStudent`）请求一个类（例如`Student`），该容器有一个用于记录的方面，那么IoC容器就能够提供带有该方面装饰的拦截器来满足所需。
- en: Interceptors are managed by external components that create dynamic decorators
    dealing with wrapping the aspects around your existing business components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器由外部组件管理，这些组件创建动态装饰器，用于围绕现有的业务组件包装方面。
- en: The main advantage of Interceptors is that they are not bound by the compilation
    process and don't modify our assemblies post-build. In other words, it's just
    the configurations for IoC containers, which you can easily take to another project
    instead of taking the DLLs and compiling them again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器的主要优势是它们不受编译过程的限制，并且不会在构建后修改我们的程序集。换句话说，这只是IoC容器的配置，你可以轻松地将其带到另一个项目中，而不是携带DLL并再次编译它们。
- en: However, Interceptors are configurable to work either at runtime or compile
    time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拦截器可以配置为在运行时或编译时工作。
- en: Unity, Ninject, Spring.NET, Castle Windsor, LinFu, Autofac, LOOM.NET, Seasar,
    and so on are some IoC containers that allow injecting Interception at compile
    time or runtime.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unity、Ninject、Spring.NET、Castle Windsor、LinFu、Autofac、LOOM.NET、Seasar等是一些允许在编译时或运行时注入拦截器的IoC容器。
- en: These IoC containers use a Dynamic Proxy to create in-memory decorators that
    wrap your existing code. Those Dynamic Proxies are responsible for code execution.
    Thus, it allows execution of the wrapper aspect as well as the underlying code
    being wrapped.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 IoC 容器使用动态代理创建内存中的装饰器，这些装饰器包装了你的现有代码。这些动态代理负责代码执行。因此，它允许执行包装方面以及被包装的底层代码。
- en: The Interception process
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截过程
- en: 'The Interception process can be depicted as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截过程可以描述如下：
- en: '![](img/8dfd86a3-37b0-4b8c-abab-fd43c45fcb5e.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dfd86a3-37b0-4b8c-abab-fd43c45fcb5e.png)'
- en: 'Here is what happens:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是具体发生的情况：
- en: The calling code asks IoC container about the type it is looking for. For example,
    the `IExampleInterface` type.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用代码询问 IoC 容器它正在寻找的类型。例如，`IExampleInterface` 类型。
- en: IoC container now tries to match the concrete implementation of the type requested,
    which it can return back to the calling code that is `Example` class. While it
    is doing this, it recognizes that the type is already configured to use an interceptor.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IoC 容器现在尝试匹配请求的类型的具体实现，它可以将其返回给调用代码，即 `Example` 类。在这个过程中，它认识到该类型已经配置为使用拦截器。
- en: Instead of directly returning to the calling code, the IoC container now sends
    the Interceptor and the implementation class for the requested type to the Dynamic
    Proxy.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，IoC 容器不是直接返回到调用代码，而是将拦截器和请求类型的实现类发送给动态代理。
- en: The Dynamic Proxy now takes the concrete class and wraps it with the interceptor.
    Then it generates a class implementing the type initially requested with an instance
    of the concrete class given by the IoC container and the interceptor. After that,
    it returns back that implementation of the requested type to the IoC container.
    That is the `Interceptor` class.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态代理现在将具体类包装起来，并使用拦截器。然后，它生成一个实现最初请求的类型，并使用 IoC 容器提供的具体类实例和拦截器。之后，它将请求类型的实现返回给
    IoC 容器。这就是 `Interceptor` 类。
- en: The IoC container now sends back the `Interceptor` class generated by Dynamic
    Proxy to the calling code.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，IoC 容器将动态代理生成的 `Interceptor` 类发送回调用代码。
- en: Calling code executes the returned class which in turn runs the interceptor
    and the underlying code of the concrete class `Example`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用代码执行返回的类，该类随后运行拦截器和具体类 `Example` 的底层代码。
- en: Castle Windsor
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Castle Windsor
- en: Castle Windsor is an Inversion of Control Container. This library is a part
    of the open source project known as the **Castle Project**. The Castle Project
    ([http://www.castleproject.org/](http://www.castleproject.org/)) provides reusable
    libraries for many purposes. Castle has many components and Windsor is the DI
    CONTAINER component of the Castle Project. However, it can be used independently
    of other Castle components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Castle Windsor 是一个控制反转容器。这个库是开源项目 **Castle Project** 的一部分。Castle Project ([http://www.castleproject.org/](http://www.castleproject.org/))
    提供了许多用途的可重用库。Castle 有许多组件，Windsor 是 Castle Project 的依赖注入容器组件。然而，它可以独立于其他 Castle
    组件使用。
- en: We have many other libraries available on the market such as Microsoft Unity,
    Autofac, Ninject, and so on. Each framework offers slightly different advantages
    and features. However, at the bottom, they implement the same for most of the
    core concepts, including Type Registration, Resolution, and Injection. You can,
    no doubt use any of these to apply Interception in your application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上还有许多其他库，如 Microsoft Unity、Autofac、Ninject 等。每个框架都提供了一些不同的优点和功能。然而，在底层，它们对大多数核心概念（包括类型注册、解析和注入）的实现是相同的。你可以无疑地使用这些中的任何一个来在你的应用程序中应用拦截。
- en: There is no such logic as to why we are going to use Castle Windsor though.
    Using this tool, we can easily attach Interceptors to our codes. We will see that
    in a moment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们使用 Castle Windsor 的逻辑并不存在。使用这个工具，我们可以轻松地将拦截器附加到我们的代码上。我们稍后会看到这一点。
- en: Demonstration for using the Castle Windsor
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Castle Windsor 的演示
- en: 'Let''s start to implement one Interceptor using the `Nuget` package Castle
    Windsor. First of all, create a Console App, go to Nuget Package Manager and install
    the Castle Windsor package. After successful installation, your Project Reference
    will look like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 `Nuget` 包 Castle Windsor 实现一个拦截器。首先，创建一个控制台应用程序，进入 Nuget 包管理器并安装 Castle
    Windsor 包。安装成功后，你的项目引用将如下所示：
- en: '![](img/bb4c6919-282d-4667-869f-45ff7e086a2f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb4c6919-282d-4667-869f-45ff7e086a2f.png)'
- en: So, it installs `Castle.Core` and `Castle.Windsor`. Now we are ready to create
    an Interceptor.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它安装了 `Castle.Core` 和 `Castle.Windsor`。现在我们准备好创建一个拦截器了。
- en: Creating an Interceptor
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个拦截器
- en: We will do a simple Logging Interceptor which will log steps as well as exceptions
    for us. Let's name that `LoggingInterceptor.cs`. To qualify as an Interceptor,
    the class should implement the `Interceptor` interface. The only method inside
    this interface is `Intercept` which takes `IInvocation` as an argument.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做一个简单的日志拦截器，它将为我们记录步骤以及异常。让我们称它为 `LoggingInterceptor.cs`。要成为拦截器，类应该实现 `Interceptor`
    接口。这个接口中只有一个方法，即 `Intercept`，它接受 `IInvocation` 作为参数。
- en: 'The following code block illustrates what I said:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了我说的话：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The call `invocation.Proceed()` just calls the underlying method which is supposed
    to be intercepted. That means, when any method which is registered to use this
    interceptor, it will come to this method, which in turn, calls the same method
    from here with the `Proceed()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `invocation.Proceed()` 只是调用应该被拦截的底层方法。这意味着，当任何注册使用此拦截器的注册方法时，它将来到这个方法，然后从这个方法中调用相同的
    `Proceed()` 方法。
- en: 'To investigate the actual benefit of having an interceptor, we will add more
    codes here in the following block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查拥有拦截器的实际好处，我们将在以下代码块中添加更多代码：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next is to design an interface and a concrete class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是设计一个接口和一个具体类：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, the `PrintName()` method prints the name using `FirstName` and `LastName`.
    We will intercept this method and try to add log steps using an interceptor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`PrintName()` 方法使用 `FirstName` 和 `LastName` 打印名字。我们将拦截这个方法并尝试使用拦截器添加日志步骤。
- en: Attaching an Interceptor
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加拦截器
- en: The most important part now is `ExampleRegistration`, which implements the interface
    `IRegistration` of `Castle.MicroKernel.Registration` namespace.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最重要的部分是 `ExampleRegistration`，它实现了 `Castle.MicroKernel.Registration` 命名空间中的
    `IRegistration` 接口。
- en: 'This is the place where we register `LoggingInterceptor` (refer to the first
    comment in the following code block) and then declare that `Example`, class which
    will be intercepted by `LoggingInterceptor` (refer to the second comment):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们注册 `LoggingInterceptor`（参考以下代码块中的第一条注释）并声明将被 `LoggingInterceptor` 拦截的 `Example`
    类（参考第二条注释）的地方：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Last but not the least, the `main` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`main` 方法：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We take an `IWindsorContainer` instance. First, we register our `ExampleRegistration`
    class which contains our target method and interceptor configurations. Then, `_container.Resolve()`
    helps us to get the required instance implementing `IExample`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取一个 `IWindsorContainer` 实例。首先，我们注册包含我们的目标方法和拦截器配置的 `ExampleRegistration`
    类。然后，`_container.Resolve()` 帮助我们获取实现 `IExample` 的所需实例。
- en: As we have already defined that `Example` is the class implementing `IExample`
    in the `Register()` method of the `ExampleRegistration` class, one instance of
    `Example` class is created. Then, we have a `PrintName()` call inside the `try`
    block.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `ExampleRegistration` 类的 `Register()` 方法中已经定义的那样，`Example` 是实现 `IExample`
    的类，因此创建了一个 `Example` 类的实例。然后，我们在 `try` 块中有一个 `PrintName()` 调用。
- en: 'Time to run the app and see the output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序并查看输出：
- en: '![](img/6d2113fb-eda5-4e43-ac81-c3c26325555b.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d2113fb-eda5-4e43-ac81-c3c26325555b.png)'
- en: Clearly, before printing the name, the first thing that executes is the log
    Starts message. Secondly, the actual method execution which prints the name. After
    that, as we expected, the Success and Exit messages. Exit means it exited from
    the interceptor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在打印名字之前，首先执行的是日志开始消息。其次，实际的方法执行，打印名字。之后，正如我们所预期的，是成功和退出消息。退出意味着它已从拦截器中退出。
- en: Obviously, we did not get any exception, so that message got skipped.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们没有得到任何异常，所以那条消息被跳过了。
- en: 'Now, let''s try to see that. The modified `Example` class will be like the
    following with a `throw new Exception()` code line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试看看。修改后的 `Example` 类将如下所示，包含 `throw new Exception()` 代码行：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Forcefully, we are throwing one exception before the `Console.WriteLine`. We
    will see the following output when we run this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 强制性地，我们在 `Console.WriteLine` 之前抛出一个异常。当我们运行这个程序时，我们会看到以下输出：
- en: '![](img/5317171d-e369-4988-a854-624bf766e51a.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5317171d-e369-4988-a854-624bf766e51a.png)'
- en: Interestingly, we don't see the Success log message, but the Exit message is
    printed and the actual execution of the method which was printing the name did
    not happen either. That is because the Exit message will definitely get printed
    no matter what happens to the calling code as that is inside the `finally` block
    of the interceptor.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们没有看到成功日志消息，但打印了退出消息，并且打印名字的方法的实际执行也没有发生。这是因为无论调用代码发生什么，退出消息都一定会打印，因为那是在拦截器的
    `finally` 块中。
- en: We manually threw an exception before the actual code execution to print the
    name, which resulted in printing the exception log message along with Start and
    Exit.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实际代码执行之前手动抛出一个异常来打印名称，这导致打印出异常日志消息以及 Start 和 Exit。
- en: 'Multiple Interceptors can be attached to a single class. There are two types
    of interceptor registrations, coded as follows. You can use either the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多个拦截器附加到单个类。有两种类型的拦截器注册，如下所示。您可以使用以下任一种：
- en: '`     kernel.Register(        Component.For()       .ImplementedBy()      
    .Interceptors<LoggingInterceptor,           AnotherInterceptor>());`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`     kernel.Register(        Component.For()       .ImplementedBy()      
    .Interceptors<LoggingInterceptor,           AnotherInterceptor>());`'
- en: 'Or you can use this one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用这个：
- en: '`    kernel.Register(      Component.For<IExample>()      .ImplementedBy<Example>()
         .Interceptors(new InterceptorReference[] {      InterceptorReference.ForType<LoggingInterceptor>(),
         InterceptorReference.ForType<AnotherInterceptor>() }).Anywhere);`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`    kernel.Register(      Component.For<IExample>()      .ImplementedBy<Example>()
         .Interceptors(new InterceptorReference[] {      InterceptorReference.ForType<LoggingInterceptor>(),
         InterceptorReference.ForType<AnotherInterceptor>() }).Anywhere);`'
- en: Intermediate Language (IL) Weaving
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间语言 (IL) 线程
- en: In this type of AOP, the aspects are attached to the underlying code after the
    application has been compiled. This post-compilation process alters the assemblies
    at the IL level so that the aspect hook points are called where they are configured.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的 AOP 中，方面是在应用程序编译之后附加到底层代码的。这个编译后过程在 IL 级别修改程序集，以便在配置的位置调用方面钩子点。
- en: If I explain in simple words, it is a process by which the aspect codes are
    interjected into the original code after compilation, but that happens only to
    the IL code (original source code remains intact) and packaged into the assemblies.
    Your original code will be intact. However, along with your code, the aspect blocks
    will be included and the assembly gets the modified code. Unlike Interception,
    where the codes are interjected at the runtime, this process is static and codes
    are included beforehand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用简单的话来解释，这是一个在编译后将方面代码插入到原始代码中的过程，但这只发生在 IL 代码（原始源代码保持不变）中，并将其打包到程序集中。您的原始代码将保持不变。然而，除了您的代码之外，方面块也将被包含，程序集将获得修改后的代码。与拦截不同，拦截是在运行时插入代码，这个过程是静态的，代码是在之前包含的。
- en: The most widely used tool for weaving is PostSharp, which we will demo in a
    while. Others include LOOM.NET, Fody, SheepAspect, Mono.Cecil, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的线程工具是 PostSharp，我们稍后将演示它。其他包括 LOOM.NET、Fody、SheepAspect、Mono.Cecil 等等。
- en: IL Weaving process
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IL 线程过程
- en: 'Since I explained the process, let''s see that in action in the following diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我已经解释了过程，让我们在以下图中看看它是如何实际操作的：
- en: '![](img/3600f40b-ce25-455e-9e7a-3c1e55138211.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3600f40b-ce25-455e-9e7a-3c1e55138211.png)'
- en: Simple, isn't it! Now that we understand how the process goes along, it's time
    to get our hands dirty on some real code and try it out.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，不是吗！现在我们了解了这个过程是如何进行的，是时候动手做一些真正的代码并尝试一下了。
- en: Creating an aspect
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个方面
- en: Before starting up, we need to add the `Nuget` package named as PostSharp to
    the project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动之前，我们需要将名为 PostSharp 的 `Nuget` 包添加到项目中。
- en: 'To create an aspect, we need to design the class which would inherit from the `OnMethodBoundaryAspect`
    aspect class, which is an abstract class inside the `PostSharp.Aspects` namespace.
    This can be seen in the following code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个方面，我们需要设计一个类，该类将继承自 `OnMethodBoundaryAspect` 方面类，这是一个位于 `PostSharp.Aspects`
    命名空间内的抽象类。这可以在以下代码块中看到：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`OnMethodBoundaryAspect` helps to write code which can execute before or after
    a method execution or in the case of an exception. As you can see from the previous
    class, we are overriding the `OnEntry`, `OnExit`, `OnException` and `OnSucess`
    methods. There are other aspect classes which can solve the different purposes.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMethodBoundaryAspect` 方面有助于编写可以在方法执行前后或异常情况下执行的代码。正如您从前一个类中看到的那样，我们正在重写
    `OnEntry`、`OnExit`、`OnException` 和 `OnSucess` 方法。还有其他方面类可以解决不同的目的。'
- en: 'Update the `main` method as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `main` 方法：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when you run the app, nothing happens. We get a confirmation if we can
    see the generated assembly codes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行应用程序时，没有任何事情发生。我们可以通过查看生成的程序集代码来得到确认。
- en: ILSpy is the open-source .NET assembly browser and decompiler. You can download
    it from [http://ilspy.net/](http://ilspy.net/). This will help us see the actual
    codes packaged inside the assemblies.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ILSpy 是开源的 .NET 程序集浏览器和反编译器。您可以从 [http://ilspy.net/](http://ilspy.net/) 下载它。这将帮助我们查看程序集中打包的实际代码。
- en: 'When you run the ILSpy application and then select the assembly of our app,
    it will look something like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 ILSpy 应用程序并选择我们的应用程序的程序集时，它看起来会像以下这样：
- en: '![](img/c9afb9af-a342-460e-a017-2037ad8ce301.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9afb9af-a342-460e-a017-2037ad8ce301.png)'
- en: You can see the `Example` class has code intact. No other code got inserted
    into the assembly. That's because we have not yet attached the Weaver with our
    `Example` class. Let's do that next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `Example` 类中的代码保持完整。没有其他代码被插入到程序集中。这是因为我们还没有将编织器与我们的 `Example` 类关联起来。让我们接下来这样做。
- en: If you encounter a PostSharp license error while building the app, that means
    you have to purchase one license. You can also use the free license, which has
    certain limitations. You can find the download page at [https://www.postsharp.net/essentials](https://www.postsharp.net/essentials).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在构建应用程序时遇到 PostSharp 许可证错误，这意味着你必须购买一个许可证。你也可以使用免费许可证，它有一定的限制。你可以在 [https://www.postsharp.net/essentials](https://www.postsharp.net/essentials)
    找到下载页面。
- en: Attaching the aspect
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定方面
- en: Attaching the aspect is very easy. You can simply add the weaver as an attribute
    to the classes you want to wrap the aspect to.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定方面非常简单。你只需将编织器作为属性添加到你想包装方面的类中即可。
- en: 'Notice the bold line above the `PrintName` method in the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码片段中 `PrintName` 方法上方的粗体行：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We attributed the `[LoggingWeaverAspect]` around the `Example` class. Now,
    let''s run it and see the output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Example` 类周围使用了 `[LoggingWeaverAspect]` 属性。现在，让我们运行它并查看输出：
- en: '![](img/14e6bbc1-bd8f-4254-baa1-d27cc33bd5ff.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14e6bbc1-bd8f-4254-baa1-d27cc33bd5ff.png)'
- en: 'Have a look at the assembly code as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下程序集代码：
- en: '![](img/02849973-1275-4e45-9366-8391ef64d4da.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02849973-1275-4e45-9366-8391ef64d4da.png)'
- en: The red boxes here indicate the code which was inserted into the assembly after
    you built the application. Since we had one `OnException` in the weaver aspect,
    the `PrintName()` method now contains a `try...catch` block. Finally, `OnEntry` is
    at the beginning and `OnExit` is inside. After the `Console.Writeline()`, we can
    see the `OnSuccess` call.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里红色的方框表示在构建应用程序后插入到程序集中的代码。由于我们在编织器方面有一个 `OnException`，因此 `PrintName()` 方法现在包含一个
    `try...catch` 块。最后，`OnEntry` 在开始处，而 `OnExit` 在 `Console.WriteLine()` 之内。在 `Console.WriteLine()`
    之后，我们可以看到 `OnSuccess` 的调用。
- en: 'If we get an exception before the actual execution of the method (before `Console.WriteLine()`
    in this case), we will see the following output without the success message:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在方法实际执行之前（在本例中为 `Console.WriteLine()` 之前）发生异常，我们将看到以下输出，而没有成功消息：
- en: '![](img/e1e66995-aca1-4118-b724-0d483ae8322e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1e66995-aca1-4118-b724-0d483ae8322e.png)'
- en: Now that we've had a sneak peek at the concepts, let's explore how Interception
    is implemented in .NET Core.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对概念有了初步的了解，让我们来探讨如何在 .NET Core 中实现拦截。
- en: Interception in ASP.NET Core
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的拦截
- en: ASP.NET Core implements the concept of Interception to interrupt the calls to
    controller actions and request-response pipeline. We can do this by different
    techniques known as filters and middleware. We will discuss each one with examples
    next.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 实现了拦截的概念，用于中断对控制器操作和请求-响应管道的调用。我们可以通过不同的技术来实现，这些技术被称为过滤器和中件。接下来，我们将通过示例逐一讨论。
- en: Filters
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: Filters allow ASP.NET Core to intercept action methods. You can configure one
    global filter which would run every time one controller action is requested, or
    have individual unique filters for some action methods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器允许 ASP.NET Core 拦截动作方法。你可以配置一个全局过滤器，每次请求控制器动作时都会运行，或者为某些动作方法配置独特的过滤器。
- en: 'The filters would implement one of the filter interface residing in the `Microsoft.AspNet.Mvc.Filters`
    namespace. Let''s see a simple filter skeleton as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器将实现 `Microsoft.AspNet.Mvc.Filters` 命名空间中驻留的一个过滤器接口。让我们看看以下简单的过滤器框架：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the preceding example, `SomeFilter` implements `IActionFilter`.
     `OnActionExecuting` and  `OnActionExecuted`, as the names suggest, would run
    when an action is being executed and completes execution respectively.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`SomeFilter` 实现了 `IActionFilter`。正如其名称所暗示的，`OnActionExecuting` 和 `OnActionExecuted`
    分别在动作执行时和执行完成后运行。
- en: If you recall the principle of Interception (which says that the *process by
    which we can run some code before or after the method which is being executed
    or totally replace that*), you will notice that these `IActionFilter` methods
    also follow the principle and are intended to intercept the calls to a controller
    action method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得拦截（拦截原则，即“我们可以运行一些代码在执行方法之前或之后，或者完全替换该方法的*过程*”），你会注意到这些 `IActionFilter`
    方法也遵循该原则，并且旨在拦截对控制器动作方法的调用。
- en: Global filter
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局过滤器
- en: Suppose you want to create an interceptor which would intercept all the action
    methods. Sounds like a common or globally declared code block that can be termed
    as a **Global filter**. Registering a filter to the MVC filters using the service
    collection inside `ConfigureServices` would make a filter globally executable
    or interceptable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个拦截器，它会拦截所有动作方法。听起来像是一个常见的或全局声明的代码块，可以被称为 **全局过滤器**。使用 `ConfigureServices`
    中的服务集合将过滤器注册到 MVC 过滤器中会使过滤器全局可执行或可拦截。
- en: 'Refer to the following code, which is the only line to convert a normal filter
    to a Global filter except the definition of the filter, which of course you need
    to code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码，这是将普通过滤器转换为全局过滤器（除了过滤器定义外，当然你需要编写代码）的唯一一行：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`SomeGlobalFilter` can also be injected with dependencies. The following code
    block can be considered as a Global filter, where `ISomeService` is injected using
    the most popular Constructor Injection Pattern:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SomeGlobalFilter` 也可以注入依赖项。以下代码块可以被视为全局过滤器，其中 `ISomeService` 使用最流行的构造函数注入模式进行注入：'
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Did you notice one thing? The parameterized constructor in `SomeGlobalFilter`
    is injected with the dependency of type `ISomeService`. Not optional though, but
    it can be done if we need any of the required dependency in filters. Imagine,
    if we need to add a log entry in the database whenever an action starts execution,
    something like a bookkeeping of what events occur in what sequence. To achieve
    this, we can inject a service and then use its methods to operate on the database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到一件事吗？在 `SomeGlobalFilter` 中的参数化构造函数注入了类型为 `ISomeService` 的依赖。虽然不是可选的，但如果我们在过滤器中需要任何必需的依赖项，则可以进行此操作。想象一下，如果我们需要在动作开始执行时在数据库中添加日志条目，就像记录事件发生的顺序一样。为了实现这一点，我们可以注入一个服务，然后使用其方法对数据库进行操作。
- en: Attributes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Another way to attach filters is to write attributes for required actions.
    When you do global, it applies to all the actions. However, if we want to attach
    to certain actions only, then we can write attributes. Let''s take a look at an
    action method which is attributed with `SomeFilter`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种附加过滤器的方法是为所需操作编写属性。当你全局应用时，它适用于所有操作。然而，如果我们只想将属性附加到某些操作上，则可以编写属性。让我们看看一个带有
    `SomeFilter` 属性的动作方法：
- en: '![](img/e7f41471-53db-4914-bf27-962f70922f23.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7f41471-53db-4914-bf27-962f70922f23.png)'
- en: 'The compiler is complaining. If you hover, it will say SomeFilter is not an
    attribute class. It actually expects the `SomeFilter` like as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在抱怨。如果你悬停，它会说 `SomeFilter` 不是一个属性类。实际上，它期望 `SomeFilter` 如下所示：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice the name of the filter which was changed to `SomeFilterAttribute` and
    derived from `Attribute` abstract class. This is by syntax. Also, attributes require
    parameterless constructors. But to intercept, we need to implement some filter
    interface like `IActionFilter`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意过滤器名称已更改为 `SomeFilterAttribute` 并从 `Attribute` 抽象类派生。这是通过语法实现的。此外，属性需要无参构造函数。但为了拦截，我们需要实现一些过滤器接口，如
    `IActionFilter`。
- en: 'To overcome this, we can take the help of the  `TypeFilterAttribute` class
    which derives from the `Attribute` class and takes a type through its constructor.
    Thus, the following code shows the correct pattern to use a filter as an attribute:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，我们可以借助从 `Attribute` 类派生并通过其构造函数接受类型的 `TypeFilterAttribute` 类。因此，以下代码显示了使用过滤器作为属性的正确模式：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A couple of important things to note here are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的事项需要注意：
- en: We have not registered `SomeFilter` in the entry point of the app; still, it
    works
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有在应用程序的入口点注册 `SomeFilter`；然而，它仍然可以工作
- en: The `TypeFilter` attribute helps to create an instance of `SomeFilter`
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeFilter` 属性有助于创建 `SomeFilter` 的实例'
- en: 'As we are playing with .NET Core, we should get the filter instance from the
    service registrations, instead of creating it dynamically through `TypeFilter`.
    That is where the `ServiceFilterAttribute` class comes onto the scene. Let''s
    see how we can modify the code to use `ServiceFilter`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在玩.NET Core，我们应该从服务注册中获取过滤器实例，而不是通过`TypeFilter`动态创建它。这就是`ServiceFilterAttribute`类出现的地方。让我们看看我们如何修改代码以使用`ServiceFilter`：
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Are you sure this change will work? No, it won''t. When you run the app, you
    will see the error captured as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你确定这个更改会工作吗？不，它不会。当你运行应用程序时，你会看到以下错误：
- en: '![](img/c9824fd1-d0dc-45fd-8f93-65851f826231.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9824fd1-d0dc-45fd-8f93-65851f826231.png)'
- en: Ah, I know! Now you got what we missed. This is a very familiar exception when
    you are working with DI. As I said, `ServiceFilter` finds the filter instance
    from the service collection; if you don't register it, it will definitely throw
    an exception.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，我知道了！现在你知道我们遗漏了什么。当你使用DI工作时，这是一个非常熟悉的异常。正如我所说，`ServiceFilter`从服务集合中找到过滤器实例；如果你没有注册它，它肯定会抛出异常。
- en: 'The following code is what you need to make it work. It is not mandatory to
    make it transient though, it depends on your scenario:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使它工作所需的内容。虽然这不是必须的，使其变为瞬时的，但它取决于你的场景：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Middleware
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: Middleware, what it is known for, intercepts the pipeline of execution, and
    the developer can do anything before the response is served to the client. We
    will see how exactly we can implement Middlewares to intercept in the next section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件，它所知名的是，拦截执行管道，开发者可以在响应发送到客户端之前做任何事情。我们将在下一节中看到如何具体实现中间件以进行拦截。
- en: 'Middleware in ASP.NET core follows the Interception technique to interject
    aspects between request and response. It''s basically some block of code which
    is registered with the application pipeline. The following diagram shows how Request
    goes through Middlewares one by one before Response comes out:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core中的中间件遵循拦截技术，在请求和响应之间插入方面。它基本上是一段与应用程序管道注册的代码块。以下图表显示了请求如何逐个通过中间件，直到响应出来：
- en: '![](img/933025b8-e773-4af0-9cbf-f34f38b955cb.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/933025b8-e773-4af0-9cbf-f34f38b955cb.png)'
- en: A large amount of Middleware can be inserted into the pipeline. Each Middleware
    decides whether to pass the execution to the next one and can perform some logic
    before and after the invocation of the next component. These components are designed
    to solve specific purposes like logging, exception handling, authorizing, and
    so on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将大量的中间件插入到管道中。每个中间件决定是否将执行传递给下一个中间件，并在调用下一个组件之前和之后执行一些逻辑。这些组件被设计来解决特定的目的，如日志记录、异常处理、授权等。
- en: Registration
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: 'The `IApplicationBuilder` interface helps us register the Middleware using
    the `app.Use` inside the `Configure()`. Let''s check a simple code block:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`IApplicationBuilder`接口帮助我们使用`Configure()`中的`app.Use`注册中间件。让我们检查一个简单的代码块：'
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Execution
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行
- en: 'We have two Middlewares and then `app.Run`. When we run this, we will see the
    following one:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个中间件然后是`app.Run`。当我们运行这个时，我们会看到以下内容：
- en: '![](img/b6ccb1b3-9b7d-4664-9e8d-964b2ce97a62.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6ccb1b3-9b7d-4664-9e8d-964b2ce97a62.png)'
- en: 'There is a catch here. If you refresh the page, without building the code,
    the following is what you see next:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题。如果你刷新页面，而不构建代码，你将看到以下内容：
- en: '![](img/ce483d01-0a7a-4828-a190-ce4deb8b1637.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce483d01-0a7a-4828-a190-ce4deb8b1637.png)'
- en: The reason is I have concatenated the string and when you refresh the page,
    it directly comes to the Middleware 1 followed by Middleware 2 and then `app.Run`.
    As the variable got initialised inside the `Configure`, it has an application
    scope. It will be appended henceforth. If you refresh the page again, you will
    see another set of the same messages getting appended to what you see in the preceding
    screenshot.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是我将字符串连接在一起，当你刷新页面时，它直接跳到中间件1，然后是中间件2，最后是`app.Run`。因为变量在`Configure`内部初始化，它具有应用程序作用域。因此，它将被附加。如果你再次刷新页面，你将看到另一组相同的消息被附加到前一个截图中的内容上。
- en: 'This is the way Middlewares hijack the application pipeline and execute before
    the response is delivered to the client. Let''s consider another code block:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是中间件劫持应用程序管道并在响应发送到客户端之前执行的方式。让我们考虑另一个代码块：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What do you think the output will be? Check it out:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为输出会是什么？检查一下：
- en: '![](img/276333d2-1a54-42ed-89b6-7feaf2824c53.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/276333d2-1a54-42ed-89b6-7feaf2824c53.png)'
- en: Middleware 2 got missed. That is because we wrote `app.Run` before Middleware
    2\. `app.Run` is the exit point which terminates the pipeline. Anything after
    that won't be considered by the runtime.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件 2 被遗漏了。这是因为我们在 Middleware 2 之前写了 `app.Run`。`app.Run` 是退出点，它终止了管道。在那之后的所有内容都不会被运行时考虑。
- en: 'You can, definitely, code before and after invoke is called, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以在调用 invoke 之前和之后进行编码，如下所示：
- en: '`   app.Use(async (context, next) =>     {     // Do something before the next
    middleware is         invoked.          await next.Invoke();     // Do something
    after next middleware invocation.    });`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`   app.Use(async (context, next) =>     {     // 在调用下一个中间件之前做一些事情        
     await next.Invoke();     // 在调用下一个中间件之后做一些事情    });`'
- en: Ordering
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: There is a simple rule that the order in which they are registered is the order
    in which they will be executed. The ordering plays an important role while one
    component depends on another. The exception is something which may occur anytime,
    anywhere, within the app. So, we need to register it first before everything else,
    so that we can easily capture the exceptions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一条简单的规则，即它们注册的顺序就是它们将被执行的顺序。当某个组件依赖于另一个组件时，排序扮演着重要的角色。例外情况是可能在应用程序的任何时间、任何地方发生的事情。因此，我们需要在所有其他事情之前先注册它，这样我们就可以轻松地捕获异常。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We explored what aspects are and how to determine Cross-Cutting Concerns in
    a typical programming scenario. There are specific locations where aspects can
    be tagged, which we illustrated next.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了在典型编程场景中哪些方面是跨切面关注点以及如何确定它们。有一些特定的位置可以标记方面，我们将在下面进行说明。
- en: Aspect-oriented programming helps us to run custom logic before, after, or even
    replacing the method completely, where it is registered. We saw static as well
    as dynamic techniques to attach aspects with IL Weaving and Interceptors respectively.
    Interception is the technique which is more preferred over IL Weaving as it dynamically
    runs the registered block of code (otherwise called an aspect). On the other hand,
    IL Weaving deals with assembly update after the build process is over to insert
    aspect codes into the methods registered.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面编程帮助我们运行自定义逻辑，在方法注册之前、之后，甚至完全替换方法，其中注册了它。我们看到了使用 IL Weaving 和拦截器分别附加方面的静态和动态技术。拦截是一种比
    IL Weaving 更受欢迎的技术，因为它可以动态运行注册的代码块（通常称为方面）。另一方面，IL Weaving 处理在构建过程完成后更新程序集，将方面代码插入到已注册的方法中。
- en: We then got into a thorough discussion on how Interception is adopted in ASP.NET
    Core in the form of filters and Middlewares.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入讨论了在 ASP.NET Core 中如何以过滤器和中件间的形式采用拦截。
- en: Filters can intercept the path of action method execution, which can be either
    be attributed to the method as required, or can be registered with service collection
    to label it as a Global filter.  One line of registration of a filter can make
    the filter intercept all action methods easily.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以拦截动作方法执行的路径，这可以是按需将属性分配给方法，或者将其注册到服务集合中，以将其标记为全局过滤器。注册一个过滤器的单行代码可以使过滤器轻松拦截所有动作方法。
- en: Middleware is a technique in ASP.NET Core which allows us to insert built-in/custom
    code chunks into the request-response pipeline.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是 ASP.NET Core 中的一种技术，它允许我们在请求-响应管道中插入内置/自定义代码块。
- en: Now that we have learned all the fundamental concepts of DI, in [Chapter 8](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml),
    *Patterns - Dependency Injection*, we are going to discover different techniques/patterns
    to inject dependencies into the clients.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了 DI 的所有基本概念，在 [第 8 章](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml) *模式
    - 依赖注入* 中，我们将发现不同的技术/模式来向客户端注入依赖。
