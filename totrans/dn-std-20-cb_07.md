# 网络编程

在本章中，我们将探讨以下食谱：

+   使用套接字显示IP地址和名称的库

+   创建一个用于使用库的经典Windows应用程序

+   创建一个发送邮件的库

+   创建一个用于使用库的WPF应用程序

+   创建一个用于调用REST API的库

+   创建一个用于使用库的ASP.NET MVC应用程序

# 技术要求

读者应具备基本的C#知识。他们还应了解如何使用Visual Studio，使用NuGet安装包，以及在其他项目中引用项目中的库。

本章的代码文件可以在GitHub上找到：

[https://github.com/PacktPublishing/DotNET-Standard-2-Cookbook/tree/master/Chapter07](https://github.com/PacktPublishing/DotNET-Standard-2-Cookbook/tree/master/Chapter07)

查看以下视频以查看代码的实际运行情况：

[https://goo.gl/Wj2VD9](https://goo.gl/Wj2VD9)

# 简介

Microsoft .NET Framework为您提供了一套类库，使您能够轻松地与互联网服务一起工作。这些库允许您轻松地将服务集成到您的应用程序中。在本章中，我们将使用System.Net命名空间中的几个这些类。我们将探讨如何将这些类放入.NET Standard 2.0库中，并在不同的.NET应用程序版本中使用它。

# 使用套接字显示IP地址和名称的库

在本食谱中，我们将构建一个.NET Standard 2.0类库，该类库可以显示当前机器的IP地址。然后，我们将创建一个使用该库的应用程序。

# 准备工作

在开始构建库之前，请确保已安装并配置了最新的Visual Studio 2017，用于创建.NET Standard 2.0库。

# 如何操作...

1.  打开Visual Studio 2017。

1.  点击“文件”|“项目”以创建项目。

1.  在“新建项目”对话框中，展开左侧窗格中的“其他项目类型”节点，并选择“Visual Studio解决方案”。在右侧窗格中，选择“空白解决方案”。

1.  在“名称”文本框中，键入`Chapter7.Networking`，并在“位置”文本框中选择下拉框中的路径或单击“浏览...”按钮定位路径：

![](img/2b9e3189-dc93-40b8-9d4e-caf36033eb12.png)

1.  点击“确定”。

1.  现在，您的解决方案资源管理器（*Ctrl* + *Alt* + *L*）应如下所示：

![](img/838c1674-4e35-4551-94fd-6e6f5d7d6164.png)

1.  现在，在解决方案资源管理器中右键单击`Chapter7.Networking`标签，并选择“添加”|“新建项目”。

1.  在“新建项目”对话框中，展开“Visual C#”节点。

1.  在左侧窗格中选择.NET Standard，在右侧窗格中选择类库 (.NET Standard)：

![](img/21c4f4da-9275-4c60-8a5b-5142ed401e7a.png)

1.  在“名称”文本框中，键入`Chapter7.Networking.ReadIPLib`，保留其他默认设置，然后单击“确定”：

![](img/77cd7188-bea5-46f5-b06a-e64fa211d5e4.png)

1.  现在，解决方案资源管理器（*Ctrl* + *Alt* + *L*）应如下所示：

![](img/a3be1d0b-3751-454c-98fe-19073dd02b04.png)

1.  现在，在解决方案资源管理器中选择`Class1.cs`，并按*F2*将文件重命名为`IPReader.cs`。

1.  确认对话框中询问是否重命名类名时，请回答“是”。

1.  在解决方案资源管理器中双击`IPReader.cs`标签。

1.  让我们在代码窗口中向上滚动并添加以下`using`指令：

[PRE0]

1.  现在，让我们在`IPReader`类中创建这个`public`方法：

[PRE1]

1.  按*Ctrl* + *Shift* + *B*进行快速构建以检查语法。

# 它是如何工作的...

在步骤1到11中，我们添加了一个空白解决方案，并将一个.NET Standard 2.0类库添加到解决方案中。在这些步骤中，我们已为解决方案和项目赋予了适当的名称。然后，在第12步中，我们将Visual Studio生成的默认`Class1.cs`的名称进行了更改。在第15步中，我们向代码中添加了所需的`using`指令。我们主要使用了`System.Net`和`System.Net.Sockets`来访问所需的类并读取IP地址，然后添加了`System.Collections.Generic`命名空间以创建一个通用的`string List`来存储IP地址。

在第16步中，我们添加了一个公共方法，该方法将读取您所在本地计算机上的所有可用IP地址。在第一行中，我们将系统主机名存储在一个变量中，在第二行中，我们使用它来获取主机地址。然后，我们创建了一个空列表来存储IP地址。

之后，我们使用`foreach`循环遍历所有找到的IP地址，并在检查是否为内部网络上的IP地址后，将它们存储在列表中。最后，我们返回存储的IP地址列表。

在第17步中，我们进行了快速构建以检查语法。

# 创建一个经典Windows应用程序以使用库

在这个配方中，我们将创建一个经典Windows应用程序来使用库。我们将使用Visual Studio设计器创建UI，添加代码以使用库，并显示从库本身选择的IP地址列表。

# 准备工作

确保您拥有Visual Studio 2017的最新版本，并且已经完成了前面的配方。我们将使用前面配方中构建的解决方案。

# 如何操作...

1.  打开Visual Studio 2017。

1.  现在打开前面配方中的解决方案。点击 文件 | 打开 | 打开项目/解决方案 或按 *Ctrl* + *Shift* + *O* 并选择`Chapter7.Networkings`解决方案。

1.  按*Ctrl* + *Shift* + *B*进行快速构建以检查一切是否正常。

1.  现在，点击`Chapter7.Networking`解决方案标签。点击 文件 | 添加 | 新项目。

1.  在“添加新项目”模板对话框中，展开左侧窗格中的Visual C#节点。

1.  在右侧窗格中，选择Windows经典桌面，并选择Windows窗体应用程序(.NET Framework)：

![图片](img/2857fe40-c3c8-4da0-9238-566772d8e242.png)

1.  在“名称：”文本框中，将项目名称输入为`Chapter7.Networking.IPListWindows`。其余字段可以保留默认值：

![图片](img/f1a83087-173a-46b6-8a26-000f925c4c92.png)

1.  点击“确定”。

1.  现在，解决方案资源管理器（按*Ctrl* + *Alt* + *L*）应该看起来像这样：

![图片](img/1aad3cd0-98bf-4ea6-985d-b94f311704f2.png)

1.  在`Chapter7.Networking.IPListWindows`中的“引用”标签上点击鼠标右键。

1.  选择“添加引用”。

1.  在引用管理器中，点击右侧面板中的“项目”标签：

![图片](img/ad375516-6a63-4fac-8ea3-555df7fdecca.png)

1.  在左侧面板中检查`Chapter7.Networking.ReadIPLib`项目。

1.  点击“确定”。

1.  现在点击项目列表中的`Form1.cs`并将其重命名为`MainForm.cs`。

1.  对确认对话框回答“是”。

1.  现在点击“MainForm.cs[设计]”选项卡。

1.  从工具箱中，将一个按钮控件和一个列表框控件添加到MainWindow窗体：

![图片](img/4c3b684b-5859-46da-8353-f7f9fb3d5ccd.png)

1.  选择按钮并按*F4*加载属性窗口。

1.  现在更改以下属性：

    | **控件** | **属性** | **值** |
    | --- | --- | --- |
    | 表单 | 文本 | `IP 列表` |
    | 按钮 | 名称 | `ShowButton` |
    | 按钮 | 文本 | `显示IP列表` |
    | 列表框 | 名称 | `IPListBox` |

1.  双击“显示IP列表”按钮以到达代码窗口。

1.  向上滚动，直到你到达`using`指令。

1.  将以下`using`指令添加到指令的最后一行：

[PRE2]

1.  现在，再次向下滚动，直到你到达`ShowButton_Click()`方法。

1.  在方法内部输入以下代码：

[PRE3]

1.  现在按*F5*调试代码。

1.  点击“显示IP列表”按钮。

1.  你应该看到如下输出：

![图片](img/02f98440-554a-4201-bbbb-59898822dd99.png)

1.  关闭窗口。

# 它是如何工作的...

在步骤1到10中，我们打开了之前构建的解决方案并快速构建以检查一切是否完好。然后，我们向解决方案中添加了一个经典Windows窗体应用程序。在步骤11到14中，我们添加了对我们在上一个菜谱中构建的.NET Standard 2.0类库的引用。在步骤15到20中，我们重命名了主窗口并添加了UI。最后，我们以有意义的方式更改了控件属性。

在步骤23中，我们在代码中引用了类库。在步骤25中，我们创建了一个`IPReader`类的实例，然后使用了`GetMyIPAddress()`方法。在同一行中，我们将返回的`List<string>`作为数组输出，并使用`ListBox`和`AddRange`方法填充列表框。

在步骤26到29中，我们执行了代码并测试了结果。

# 创建一个发送邮件的库

在这个菜谱中，我们将探讨`System.Net`命名空间中的另一个区域。我们将使用它来创建和发送电子邮件。主要，我们将查看`SmtpClient`类来为我们做艰苦的工作。

# 准备工作

确保您已安装Visual Studio 2017的最新版本和所有更新。我们将构建一个.NET Standard 2.0库来发送电子邮件。

# 如何做到这一点...

1.  打开Visual Studio 2017。

1.  点击文件 | 新建 | 项目 以创建一个项目。

1.  在“新建项目”对话框中，展开左侧面板中的“其他项目类型”节点，并选择Visual Studio解决方案。在右侧面板中，选择空白解决方案。

1.  在“名称”文本框中，键入`Chapter7.MailBox`，并在“位置”文本框中选择下拉框中的路径或单击“浏览...”按钮以定位路径：

![图片](img/93cddef5-a4c6-4865-b65a-94eb88d7dd2e.png)

1.  点击“确定”。

1.  现在，你的解决方案资源管理器（*Ctrl* + *Alt* + *L*）应该看起来像这样：

![图片](img/d5cd10dd-f7bd-49f3-827a-f8acf459cbb8.png)

1.  现在，在解决方案资源管理器中的`Chapter7.MailBox`标签上右击，然后选择“添加”|“新建项目”。

1.  在“新建项目”对话框中，展开 Visual C# 节点。

1.  在左侧面板中选择.NET Standard，在右侧面板中选择类库 (.NET Standard)：

![图片](img/0f43fcd3-fcb5-4047-8fff-49de0e96d419.png)

1.  在“名称”文本框中，键入`Chapter7.MailBox.MailerLib`，保留其他默认设置，然后单击“确定”：

![图片](img/5af711fc-96d5-4897-be09-8e4001ea0741.png)

1.  现在，解决方案资源管理器（*Ctrl* + *Alt* + *L*）应该看起来像这样：

![图片](img/b99018d5-a3eb-45eb-9804-a1ddfb0f9ce8.png)

1.  现在，在解决方案资源管理器中选择`Class1.cs`，然后按*F2*键将文件重命名为`SendMail.cs`。

1.  对确认对话框中的问题回答“是”，以将类名也重命名。

1.  现在，在解决方案资源管理器中双击`SendMail.cs`标签。

1.  让我们在代码窗口中向上滚动并添加以下`using`指令：

[PRE4]

1.  将以下四个属性添加到`SendMail`类中：

[PRE5]

1.  最后，添加以下`public`方法以创建和发送邮件：

[PRE6]

1.  让我们按*Ctrl* + *Shift* + *B*进行快速构建。

# 它是如何工作的...

在步骤 1 到 11 中，我们创建了一个空白解决方案，并向其中添加了一个 .NET Standard 2.0 类库项目。然后，我们正确地命名了解决方案及其项目。在步骤 12 到 14 中，我们将 Visual Studio 生成的默认类重命名。在步骤 15 中，我们在 `using` 指令部分添加了必要的命名空间以发送邮件。在步骤 16 中，我们在主类中添加了四个属性。这些属性将存储邮件地址、主题和邮件正文。

在步骤 17 中，我们编写了准备和发送邮件的实际代码。在前两行中，我们使用了发件人和收件人地址，并将它们转换为`MailAddress`类型。然后，我们创建了一个`MailMessage`，并附加了正文和主题，以及地址。然后，我们创建了访问给定 SMTP 服务器的网络凭证。

然后，我们创建了一个`SmtpClient`对象，附加了凭证并发送了邮件。最后，我们快速构建以检查语法。

# 创建一个 WPF 应用程序以使用库

在本食谱中，我们将创建一个 Windows 表单应用程序来使用我们创建的库。我们将创建一个用户界面，使用库发送电子邮件。

# 准备工作

确保你已经完成了发送电子邮件的先前食谱。如果你已经完成，请打开它并快速构建以检查一切是否正常工作。

# 如何操作...

1.  打开 Visual Studio 2017。

1.  现在打开上一个菜谱中的解决方案。点击 文件 | 打开 | 打开项目/解决方案 或按 *Ctrl* + *Shift* + *O* 并选择 `Chapter7.MailBox` 解决方案。

1.  按 *Ctrl* + *Shift* + *B* 进行快速构建以检查一切是否正常。

1.  点击 `Chapter7.MailBox` 解决方案标签。点击 文件 | 添加 | 新项目。

1.  在 添加新项目 模板对话框中，展开左侧窗格中的 Visual C# 节点。

1.  在右侧窗格中选择 Windows Classic Desktop 并选择 WPF 应用 (.NET Framework)：

![](img/bb2b6901-75b8-4ee1-9fa1-81519d178fa5.png)

1.  现在，在 名称：文本框中输入 `Chapter7.MailBox.WPFMail` 作为项目的名称。其余字段可以保留默认值：

![](img/82fb0d48-1ada-4117-946f-012ea816ac81.png)

1.  点击确定。

1.  现在，解决方案资源管理器（按 *Ctrl* + *Alt* + *L*）应该看起来像这样：

![](img/1fb688fa-0973-4347-9a75-36dfdb59b54a.png)

1.  在 `Chapter7.MailBox.WPFMail` 上的 引用 标签上单击鼠标右键。

1.  选择添加引用。

1.  在引用管理器中，点击右侧窗格中的 项目 标签：

![](img/574883d9-dcd3-4406-90ff-e5d2a36efa34.png)

1.  在左侧窗格中检查 `Chapter7.MailBox.MailerLib` 项目。

1.  点击确定。

1.  现在，点击 `MainWindow.xaml` 选项卡。

1.  从工具箱中，向 MainWindow 表单添加四个文本框控件和一个按钮控件。按照以下方式排列：

![](img/58afb945-b867-48b4-bfc4-d8c2a4efca3b.png)

1.  选择文本框并按 *F4* 加载属性窗口。

1.  现在更改以下属性（按照上一个 UI 中的顺序从顶部开始）：

    | **控件** | **属性** | **值** |
    | --- | --- | --- |
    | 文本框 | 名称 | `FromTextBox` |
    | 文本框 | 文本 | `发件人地址` |
    | 文本框 | 名称 | `ToTextBox` |
    | 文本框 | 文本 | `收件人地址` |
    | 文本框 | 名称 | `SubjectTextBox` |
    | 文本框 | 文本 | `主题` |
    | 文本框 | 名称 | `BodyTextBox` |
    | 文本框 | 文本 | `正文` |
    | 文本框 | 接受回车 (*开启此属性将使文本框多行*) | 是 |
    | 按钮 | 名称 | `SendButton` |
    | 按钮 | 文本 | `发送` |

1.  现在，你的 UI 应该看起来像这样：

![](img/fcb61820-7c21-481e-b69e-becef42cf0c5.png)

1.  双击发送按钮以打开代码窗口。

1.  向上滚动，直到你到达 `using` 指令。

1.  将以下 `using` 指令添加到指令的最后一行：

[PRE7]

1.  滚动到 `SendButton_Click()` 方法，并添加以下代码：

[PRE8]

1.  确保您已更改库中 SMTP 服务器所需的凭据。

1.  通过按 *F5* 来测试我们的应用程序：

![](img/1c961489-ef1a-4231-9c84-34e124f7920b.png)

1.  点击确定并关闭窗口。

# 它是如何工作的...

在步骤 1 到 14 中，我们打开了带有库的解决方案。然后，我们将 WPF 应用程序项目添加到解决方案中。稍后，我们添加了对类库的引用。在步骤 16 到 20 中，我们构建了 UI 并更改了一些属性。在步骤 22 中，我们在代码级别创建了到库的引用。

最后，我们添加了按钮点击的代码，这是直接的，创建了一个`SendMail`类的实例，然后从UI本身填充了属性。最后，在步骤24和25中测试了输出。

# 创建一个库来调用REST API

在这个菜谱中，我们将查看一个调用REST API的.NET Standard 2.0库。RESTful API是允许你通过HTTP访问其功能的服务。我们将在库中使用`System.Net.Http`命名空间向API发送消息并获取结果。

# 准备工作

确保你有Visual Studio 2017的最新版本。同时确保你有一个基本的了解，如何访问Web服务，什么是`GET`方法，什么是`POST`方法等等。我们将使用由`JSONPlaceHolder`提供的测试API服务。它是一个简单的REST API测试平台，供开发者使用。

# 如何操作...

1.  打开Visual Studio 2017。

1.  点击“文件 | 新建 | 项目”来创建一个项目。

1.  在“新建项目”对话框中，展开左侧窗格中的“其他项目类型”节点，并选择“Visual Studio解决方案”。在右侧窗格中，选择“空白解决方案”。

1.  在“名称：”文本框中输入`Chapter7.RestAPI`，在“位置：”文本框中选择下拉框中的路径或点击“浏览...”按钮定位路径：

![图片](img/e66020c2-8865-4489-b4af-ae36a24d6f68.png)

1.  点击“确定”。

1.  现在，你的解决方案资源管理器（*Ctrl* + *Alt* + *L*）应该看起来像这样：

![图片](img/da4df78c-8fa1-4e53-9303-e29983c2f6c9.png)

1.  现在，在解决方案资源管理器中的`Chapter7.RestAPI`标签上右击鼠标，然后选择“添加 | 新建项目”。

1.  在“新建项目”对话框中，展开“Visual C#”节点。

1.  在左侧窗格中选择.NET Standard，在右侧窗格中选择类库(.NET Standard)：

![图片](img/59a03e8e-44af-4782-a237-64e336b958eb.png)

1.  现在，在“名称：”文本框中输入`Chapter7.RestAPI.RestLib`，保留其他默认设置，然后点击“确定”：

![图片](img/85f42896-0ce2-43ad-87c6-be4f6161438b.png)

1.  现在，解决方案资源管理器（*Ctrl* + *Alt* + *L*）应该看起来像这样：

![图片](img/2b97c05d-429c-4c5a-9158-ed5bbacf5b1b.png)

1.  现在，在解决方案资源管理器中选择`Class1.cs`，然后按*F2*将文件重命名为`PostsReader.cs`。

1.  对确认对话框中的将类名重命名的问题回答“是”。

1.  现在，在解决方案资源管理器中双击`PostsReader.cs`标签。

1.  让我们在代码窗口中向上滚动并添加以下`using`指令：

[PRE9]

1.  现在，创建一个用于存储URL的类级`private`变量：

[PRE10]

1.  让我们创建默认构造函数来更新之前的变量：

[PRE11]

1.  最后，让我们添加从REST服务读取的方法：

[PRE12]

1.  按*Ctrl* + *Shift* + *B*进行快速构建以检查语法。

# 它是如何工作的...

在步骤 1 到 11 中，我们创建了一个空解决方案。然后我们向该解决方案添加了一个 .NET Standard 2.0 库。再次，作为一个好的实践，我们正确地命名了解决方案和类库项目。在步骤 12 和 13 中，我们更改了 Visual Studio 默认创建的 `Class1.cs` 的名称。在步骤 15 中，我们添加了执行任务所需的 `using` 指令。在步骤 16 中，我们创建了一个类级别的私有变量来保存服务 URL。然后，在步骤 16 中，我们创建了一个带有 `string` 参数的默认构造函数，该参数更新了步骤 15 中的私有变量。

在步骤 18 中，我们创建了执行读取 RESTful API 实际工作的 `public` 方法。在代码的第一行，我们创建了一个 `string` 变量，用于保存服务的输出。然后，我们在 `using` 语句内部创建了一个 `HttpClient` 类的实例。这是一个好的实践，它将确保在退出 `using` 语句后销毁该类。

然后，我们将 **通用资源标识符** (**URI**) 填充到服务中。之后，我们实际调用服务，并将结果存储在 `HttpResponseMessage` 变量中。最后，我们从响应中获取输出并返回输出。

# 创建一个用于使用库的 ASP.NET MVC 应用程序

在这个菜谱中，我们将创建一个 ASP.NET MVC 应用程序来使用我们创建的库。

# 准备中

确保你已经完成了上一个菜谱。如果没有，你需要在此之前完成它。如果你已经完成了，请打开它，在我们开始之前进行快速构建。

# 如何操作...

1.  打开 Visual Studio 2017。

1.  现在，打开上一个菜谱中的解决方案。点击“文件”|“打开”|“打开项目/解决方案”或按 *Ctrl* + *Shift* + *O* 并选择 `Chapter7.RestAPI` 解决方案。

1.  按 *Ctrl* + *Shift* + *B* 进行快速构建以检查一切是否正常。

1.  现在，单击`Chapter7.RestAPI`解决方案标签。点击“文件”|“添加”|“新建项目”。

1.  在“添加新项目”模板对话框中，展开左侧窗格中的“Visual C#”节点。

1.  在右侧窗格中选择 Web，然后选择 ASP.NET Web 应用程序 (.NET Framework)：

![](img/faf4537a-9012-4a0b-90b3-6d565ab89c6a.png)

1.  现在，在“名称：”文本框中输入 `Chapter7.RestAPI.RestMVC` 作为名称，并将“位置：”文本框保留为其默认值：

![](img/5198b734-2d06-44ed-867f-cb7ca9c4d757.png)

1.  在“新建 ASP.NET Web 应用程序”对话框中，从模板列表中选择“空”。

1.  选择“MVC”作为“添加文件夹和核心引用”选项：

![](img/2536cab0-2ef4-4409-9fb6-b89acef01432.png)

1.  保持其他设置不变，然后点击“确定”以创建默认的 ASP.NET MVC Web 应用程序模板。

1.  现在，解决方案资源管理器应该看起来像这样：

![](img/9812b404-a8a7-46c2-a28a-4ec6f9e397e0.png)

1.  现在，右键单击 `Chapter7.RestAPI.RestMVC` 项目下的“引用”标签，并选择“添加引用”。

1.  在“引用管理器”对话框中，在左侧窗格中选择“项目”，并在右侧窗格中选择 `Chapter7.RestAPI.RestLib`：

![](img/c72f1dd8-5969-4779-a36d-7bd41ffe9ce7.png)

1.  点击“确定”。

1.  现在，在`Chapter7.RestAPI.RestMVC`项目中的`Controllers`文件夹内，右键单击`Controllers`文件夹。

1.  选择“添加”|“控制器”。

1.  在“添加Scaffold”对话框中，从模板列表中选择“MVC 5 Controller - Empty”并点击“添加”：

![图片](img/57bc63dd-4140-4a3e-9d76-35f34aa6fdd8.png)

1.  现在，在“添加控制器”对话框中，在“控制器名称”文本框中输入`HomeController`：

![图片](img/5b6a25b8-c003-4ece-b956-5cdfa3410f68.png)

1.  点击“添加”。

1.  双击`Controllers`文件夹下的`HomeController.cs`标签。

1.  在代码窗口中，右键单击`Index()`方法名称，并选择“添加视图”。

1.  在“添加视图”对话框中保留默认设置，然后点击“添加”：

![图片](img/68ce1334-981b-46ac-a75b-5da006e03360.png)

1.  在代码窗口中点击`HomeController.cs`标签页。

1.  在代码顶部，紧邻所有指令的最后一行旁边添加此`using`指令：

[PRE13]

1.  现在将`default Index()`动作更改为以下内容：

[PRE14]

1.  在`Index()`方法内部添加以下代码：

[PRE15]

1.  现在，让我们打开`Index.cshtml`文件，并在`<h2>Index</h2>`标签下方添加以下代码：

[PRE16]

1.  现在，确保您已将MVC项目设置为默认项目。

1.  按*F5*键，你应该会看到如下输出：

![图片](img/ed71174e-1108-42fb-ad57-bb4071e63887.png)

# 工作原理...

在步骤1到11中，我们打开了解决方案并添加了一个ASP.NET MVC项目。然后，我们为项目命名。在步骤12和13中，我们添加了之前食谱中构建的库的引用。在步骤16到18中，我们向项目中添加了一个空控制器。然后，在步骤21和22中，我们在`HomeController`中添加了一个视图到`Index()`动作。

在步骤23中，我们添加了对库本身的代码级引用，并添加了两个我们任务所需的更多命名空间。在步骤24中，我们将`Index()`动作更改为`async`方法。这是必需的，因为我们将从库本身使用`async`方法。在步骤26中，我们为测试床创建了服务URL。然后，我们创建了一个`PostsReader`类的实例。在第三行中，我们使用`GetPostById()`方法从服务中获取结果。再次，在代码的第四行中，我们使用`JavaScriptSerializer`类的一个方法将来自服务的结果反序列化为字典。

最后，我们将结果存储在`ViewBag`中，并将其传递给`Index`视图。在第27步中，我们从`ViewBag`中获取了字典，并使用`Razor`语法显示内容。

最后，我们在第29步测试了输出。
