- en: Logging and Health Checking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和健康检查
- en: One of the essential aspects of building web services is logging and health
    checks. Nowadays, it is preferred to have services with a small scope. This kind
    of approach provides enormous benefits, but it makes it hard for us to verify
    whether a service behaves in the right way. Logging helps us to track the actions
    and the information processed by the web service on the other side, the health
    check mechanisms provide a way to verify that the service is healthy and all the
    required dependencies are satisfied. The chapter goes through some of the logging
    parts of ASP.NET Core, and it shows how to implement health checks using the tools
    provided by the framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建网络服务的一个重要方面是日志和健康检查。如今，人们更倾向于拥有范围较小的服务。这种方法提供了巨大的好处，但它使得我们难以验证服务是否以正确的方式运行。日志帮助我们跟踪网络服务另一侧的操作和处理的信息，而健康检查机制提供了一种验证服务是否健康以及所有必需的依赖是否满足的方法。本章将介绍
    ASP.NET Core 的一些日志部分，并展示如何使用框架提供的工具实现健康检查。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Logging in ASP.NET Core
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中登录
- en: Implementing logging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现日志
- en: Implementing logging providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现日志提供者
- en: Implementing custom logging in tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中实现自定义日志
- en: Web service health check
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务健康检查
- en: Logging in ASP.NET Core
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中登录
- en: 'We will start this chapter by providing an overview of the different logging
    components of ASP.NET Core. The framework provides different interfaces that support
    logging:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，提供 ASP.NET Core 不同日志组件的概述。该框架提供了不同的接口，支持日志记录：
- en: '`ILoggerProvider` is used to define a specific type of logging bind with an
    output channel'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILoggerProvider` 用于定义与输出通道绑定的一种特定类型的日志'
- en: '`ILoggerFactory` takes an `ILoggerProvider` interface and initializes it'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILoggerFactory` 接收一个 `ILoggerProvider` 接口并对其进行初始化'
- en: The `ILogger` interface is a particular instance of the logging component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILogger` 接口是日志组件的一个特定实例'
- en: 'The logging interface structure of ASP.NET Core can be described using the
    following schema:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的日志接口结构可以用以下架构来描述：
- en: '![](img/86e0d6bc-3ac4-474f-bda7-eb95785ea19f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86e0d6bc-3ac4-474f-bda7-eb95785ea19f.png)'
- en: In short, the `ILoggerProvider` interface represents the output of the logs,
    `ILoggerFactory` creates the right type of instance, and `ILogger` is the actual
    instance of the logger.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`ILoggerProvider` 接口代表日志的输出，`ILoggerFactory` 创建正确的实例类型，而 `ILogger` 是实际的日志实例。
- en: This kind of approach guarantees secure isolation between the `ILogger` interface
    consumer and the logging provider part. Furthermore, we may choose to add the
    calls to the `ILogger` interface in the development phase; then, during the release
    phase, we can decide which provider to use to output our logging data. Moreover,
    our logging code becomes very flexible, and we can change the output based on
    the type of environment our service runs in. Let's proceed by learning about the
    different characteristics of the logging system of ASP.NET Core.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法保证了 `ILogger` 接口消费者和日志提供者部分之间的安全隔离。此外，我们可以在开发阶段选择添加对 `ILogger` 接口的调用；然后在发布阶段，我们可以决定使用哪个提供者来输出我们的日志数据。此外，我们的日志代码变得非常灵活，我们可以根据服务运行的环境类型来更改输出。让我们通过了解
    ASP.NET Core 日志系统的不同特性来继续前进。
- en: The key characteristics of logging
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志的关键特性
- en: The ASP.NET Core logging system is characterized by some key attributes that
    are always present in each log record. Furthermore, it is essential to keep logs
    as coherent as possible. The crucial components of the ASP.NET Core logging system
    are the *log category*, the *log level*, the *log event id*, and the *log message*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 日志系统以一些始终存在于每个日志记录中的关键属性为特征。此外，保持日志尽可能一致是非常重要的。ASP.NET Core 日志系统的关键组件是
    *日志类别*、*日志级别*、*日志事件 ID* 和 *日志消息*。
- en: 'The *log category* is specified when the `ILogger<T>` interface is initialized.
    It is an essential part of the logging process because it identifies the component
    that is emitting the log record. The *log category* usually corresponds to the
    type or class that''s firing the log records. Let''s use the `ItemController`
    class of the catalog service as an example. The *log category* is defined during
    the `ILogger` interface injection process:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化 `ILogger<T>` 接口时，会指定 *日志类别*。它是日志过程的一个重要部分，因为它标识了发出日志记录的组件。*日志类别*通常对应于触发日志记录的类型或类。让我们以目录服务的
    `ItemController` 类为例。*日志类别*是在 `ILogger` 接口注入过程中定义的：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ItemController` class uses the widespread technique of constructor injection
    to initialize the `ILogger<ItemController>` type. Therefore, the log category
    is implicitly defined in the signature of the `_logger` property. Although the
    *log category* helps us identify which component is firing that specific log message,
    we also need to define the importance of that message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemController` 类使用构造函数注入的广泛技术来初始化 `ILogger<ItemController>` 类型。因此，日志类别在 `_logger`
    属性的签名中被隐式定义。尽管 *日志类别* 帮助我们识别哪个组件正在触发特定的日志消息，但我们还需要定义该消息的重要性。'
- en: 'The *log level* provides information that indicates the severity or importance
    of the log record. ASP.NET Core provides a helpful extension method that offers
    some abstraction over the log level:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*日志级别* 提供了指示日志记录严重性或重要性的信息。ASP.NET Core 提供了一个有用的扩展方法，它对日志级别提供了一些抽象：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each of these methods is an abstraction that''s provided by the `Microsoft.Extensions.Logging`
    namespace. For example, if we examine the `_logger.LogInformation` method implementation,
    under the hood, it merely calls the generic `logger.Log` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都是 `Microsoft.Extensions.Logging` 命名空间提供的抽象。例如，如果我们检查 `_logger.LogInformation`
    方法的实现，底层实际上只是调用了通用的 `logger.Log` 方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `LogInformation` extension method wraps the `logger.Log` method calls by
    implicitly defining the level of information provided by the framework. The `LogLevel`
    attribute is an `enum` structure that''s exposed by the `Microsoft.Extension.Logging`
    namespace, which provides the following out of the box logging levels:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogInformation` 扩展方法通过隐式定义框架提供的信息级别来包装 `logger.Log` 方法调用。`LogLevel` 属性是一个由
    `Microsoft.Extension.Logging` 命名空间暴露的 `enum` 结构，它提供了以下开箱即用的日志级别：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code describes the different log levels that are provided by the
    `LogLevel` enumerator. The log levels go from `Trace`, which describes detailed
    information about the system, to the `Critical` level, which means that the service
    is unable to work correctly and is shutting down. The `LogLevel` attribute is
    essential because it is usually used to filter the log messages which tells us
    of the priority of a logging message.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了由 `LogLevel` 枚举提供的不同日志级别。日志级别从描述系统详细信息的 `Trace` 级别，到表示服务无法正确工作并正在关闭的
    `Critical` 级别。`LogLevel` 属性是必不可少的，因为它通常用于过滤日志消息，告诉我们日志消息的优先级。
- en: 'Once we''ve identified the level of severity of a specific log message, we
    need to provide the *log event id*, which helps us identify a specific event in
    the logging output. While the *log category* usually represents the full path
    of the class, the *log event id* is useful if we wish to express the method that
    is currently generating the logging output. Let''s use the action methods contained
    in the `ItemController` class as an example (`Get`, `GetById`, `Create`, `Update`,
    and `Delete`). It is possible to create a log event class that maps each action
    method to a specific event id:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了特定日志消息的严重性级别，我们需要提供 *日志事件 ID*，这有助于我们在日志输出中识别特定事件。虽然 *日志类别* 通常代表类的完整路径，但
    *日志事件 ID* 在我们希望表达当前生成日志输出的方法时非常有用。让我们以 `ItemController` 类中包含的操作方法（`Get`、`GetById`、`Create`、`Update`
    和 `Delete`）为例。我们可以创建一个将每个操作方法映射到特定事件 ID 的日志事件类：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Therefore, we can pass the corresponding log event id when we call the `ILogger`
    interface in an action method of the `ItemController` class. By doing this, it
    is possible to identify and group events:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们调用 `ItemController` 类的操作方法中的 `ILogger` 接口时，可以传递相应的日志事件 ID。通过这样做，我们可以识别和分组事件：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, another essential part of logging records is the message associated
    with the log record. The logging system of ASP.NET Core also provides a templating
    system that''s analogous to the C# string interpolation feature. Therefore, it
    is possible to use the templating system in the following way:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，日志记录的另一个重要部分是与日志记录相关的消息。ASP.NET Core 的日志系统还提供了一个类似于 C# 字符串插值的模板系统。因此，可以使用以下方式使用模板系统：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code logs a message about *information* severity using the `LoggingEvents.GetById`
    event id and adds the message `"GetById {id} "`. Now that we have looked at the
    different logging characteristics provided by ASP.NET Core, we will look at a
    concrete implementation that's been applied to the *catalog service* project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`LoggingEvents.GetById`事件ID记录了一条关于*信息*严重性的消息，并添加了消息`"GetById {id} "`。现在我们已经了解了ASP.NET
    Core提供的不同日志特性，我们将查看一个具体的应用实例，该实例已被应用于*目录服务*项目。
- en: Implementing the logging part
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现日志部分
- en: 'In this section, we will learn how to perform logging in the *catalog web service*.
    Let''s start by choosing a layer where we''ll execute the logging statements.
    Since the logic is encapsulated in the `Catalog.Domain` layer project, we will
    continue by implementing the logging part on the service classes defined in the
    project. First of all, let''s start by defining a new logging class, which contains
    the corresponding *event id* for each operation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在*目录网络服务*中执行日志记录。让我们首先选择一个我们将执行日志语句的层。由于逻辑封装在`Catalog.Domain`层项目中，我们将继续在项目中定义的服务类上实现日志部分。首先，让我们定义一个新的日志类，其中包含每个操作的相应*事件ID*：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have established a corresponding *log event id* for each activity,
    we need to define the logging messages that will be used by the `ILogger` interface.
    For now, we can determine the following messages:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为每个活动建立了相应的*日志事件ID*，我们需要定义`ILogger`接口将使用的日志消息。目前，我们可以确定以下消息：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first one refers to the number of records affected by a change, while the
    second is the entity that''s been changed. Finally, the third one provides a message
    for the target entity of the handler. It is essential to note that both constants
    follow a naming convention: the first part of their name refers to the content
    of the message; after the first underscore, we have the parameters that will be
    replaced by values when we use the logging templating system.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指的是受变更影响记录的数量，而第二个是指被更改的实体。最后，第三个为处理器的目标实体提供一条消息。重要的是要注意，这两个常量遵循一个命名约定：它们名称的第一部分指的是消息的内容；在第一个下划线之后，我们有在日志模板系统中将被值替换的参数。
- en: 'Furthermore, we can proceed by changing the `IItemService` methods by implementing
    logging. Let''s start with the `AddItemAsync` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过更改`IItemService`方法并通过实现日志记录来继续进行。让我们从`AddItemAsync`方法开始：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code tracks the information about the number of affected records
    and the id of the added record. We can do the same with the other methods of the
    `ItemService` class. In the case of read-only operations, we can add the id of
    the target record; for example, in the case of the `GetItemAsync` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码跟踪受影响记录的数量和添加记录的ID信息。我们也可以用`ItemService`类的其他方法做同样的事情。在只读操作的情况下，我们可以添加目标记录的ID；例如，在`GetItemAsync`方法的情况下：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code logs the information related to the id that was retrieved
    by the service by using the `Event.GetById` field. It uses the `Messages` type
    to specify the event message. In the next section, we will learn how to log exceptions
    by enhancing the exception handling implementation of logs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`Event.GetById`字段记录了服务检索到的ID相关的信息。它使用`Messages`类型来指定事件消息。在下一节中，我们将学习如何通过增强日志记录的异常处理实现来记录异常。
- en: Exception logging
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常日志记录
- en: 'What if part of the service throws an exception? Handling exceptions is a crucial
    part of the development process of services. As we saw in [Chapter 7](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml),
    *Filter Pipeline*, it is possible to use them to catch exceptions using a filter.
    Filters are one of the crucial parts of the MVC stack: they act before and after
    action methods, and they can be used to log exceptions in a single implementation.
    Let''s have a look at `JsonExceptionAttribute` in `Catalog.API`again*:*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务的一部分抛出异常怎么办？处理异常是服务开发过程中的关键部分。正如我们在[第7章](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml)“过滤器管道”中看到的，可以使用它们通过过滤器来捕获异常。过滤器是MVC堆栈的关键部分：它们在操作方法之前和之后执行，并且可以用于在单个实现中记录异常。让我们再次看看`Catalog.API`中的`JsonExceptionAttribute`：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The class tracks and returns exceptions using the analog pattern, which can
    be seen in the implementation of the handler: the `ILogger<T>` interface is injected
    into the constructor using dependency injection and the `_logger.LogError` method.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通过类似模式跟踪和返回异常，这可以在处理器的实现中看到：`ILogger<T>` 接口通过依赖注入注入到构造函数中，并使用 `_logger.LogError`
    方法。
- en: In the next section, we will learn how to verify logging in our test using `Moq`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用 `Moq` 在我们的测试中验证日志记录。
- en: Verifying logging using Moq
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Moq 验证日志记录
- en: 'Let''s learn how to verify our implemented logging. The dependency injection
    system of the `ILogger` interface helps us to mock the logging mechanism and validate
    the resulting implementation. It is essential to note that our handlers are using
    the extension methods of the `ILogger` interface. Let''s use the ASP.NET Core
    implementation of the `LogInformation` extension method in the `Microsoft.Extensions.Logging`
    namespace as an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何验证我们实现的日志记录。`ILogger` 接口的依赖注入系统帮助我们模拟日志机制并验证结果实现。重要的是要注意，我们的处理器正在使用 `ILogger`
    接口的扩展方法。以下以 `Microsoft.Extensions.Logging` 命名空间中 `LogInformation` 扩展方法的 ASP.NET
    Core 实现为例：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Extension methods are *not* a mock-oriented construct. They are static methods
    and, by definition, it is not possible to mock a static construct in C#'s runtime.
    Thus, we need to provide an *abstraction* over the `ILogger` factory that allows
    us to inject and mock the interface that's used in our tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法**不是**面向模拟的结构。它们是静态方法，根据定义，在 C# 的运行时中不可能模拟静态结构。因此，我们需要提供一个对 `ILogger` 工厂进行抽象的机制，允许我们注入和模拟测试中使用的接口。
- en: In general, it isn't possible to test static methods. Moreover, mock libraries
    typically create mocks by dynamically creating classes at runtime. Typically,
    they override the behavior of types by extending them. Since the static methods
    cannot be overridden, it isn't possible to mock them. Therefore, when we need
    to mock a static element, it is suggested that we abstract them and encapsulate
    them into classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，无法测试静态方法。此外，模拟库通常通过在运行时动态创建类来创建模拟。通常，它们通过扩展类型来覆盖类型的行为。由于静态方法不能被覆盖，因此无法模拟它们。因此，当需要模拟一个静态元素时，建议我们抽象它们并将它们封装到类中。
- en: 'Let''s look at the declaration of the `LoggerAbstraction` class in the `Catalog.Fixture`
    project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Catalog.Fixture` 项目中 `LoggerAbstraction` 类的声明：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`LoggerAbstraction` is a generic class that implements the `ILogger<T>` interface.
    More specifically, the abstract class defines the `Log<TState>` method by executing
    an overloaded version of the `void Log` method. Both the `Log` method and the
    `LoggerAbstraction` class are abstract, which means we can mock their behavior.
    Thus, it is possible to mock the behavior of the logging class, as shown in the
    following modified version of the `ItemServiceTests` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggerAbstraction` 是一个实现 `ILogger<T>` 接口的泛型类。更具体地说，抽象类通过执行 `void Log` 方法的重载版本来定义
    `Log<TState>` 方法。`Log` 方法和 `LoggerAbstraction` 类都是抽象的，这意味着我们可以模拟它们的行为。因此，可以模拟日志记录类的行为，如下面修改后的
    `ItemServiceTests` 类所示：'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ItemServiceTests` class initializes the `LoggerAbstraction<IItemService>`
    type as a class attribute. The constructor of the class uses `ITestOutputHelper`
    to mock the logging system that''s used by the service layer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemServiceTests` 类将 `LoggerAbstraction<IItemService>` 类型初始化为一个类属性。类的构造函数使用
    `ITestOutputHelper` 模拟服务层使用的日志系统：'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`ITestOutputHelper` is an interface that''s exposed by the `Xunit.Abstractions`
    namespace and resolved by the `Xunit` runtime. It allows us to write in the test
    console of the test runner. Finally, the test class implements the `additem_should_log_information`
    test method. The test method calls the `AddItemAsync` method that we implemented
    in the `ItemService` class. Finally, it is possible to verify the `ILogger` interface
    using the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITestOutputHelper` 是由 `Xunit.Abstractions` 命名空间公开并由 `Xunit` 运行时解析的一个接口。它允许我们在测试运行器的测试控制台中编写代码。最后，测试类实现了
    `additem_should_log_information` 测试方法。测试方法调用我们在 `ItemService` 类中实现的 `AddItemAsync`
    方法。最后，可以使用以下代码片段验证 `ILogger` 接口：'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding snippet verifies that the `Log` method is called two times. It
    also outputs the resulting log as part of the logging system that's defined by
    the `ITestOutputHelper` interface. Now that we have implemented the logging mechanism
    in the service layer of the `Catalog.Domain` project, we will examine and implement
    the necessary logging providers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段验证了 `Log` 方法被调用了两次。它还将结果日志作为由 `ITestOutputHelper` 接口定义的日志系统的一部分输出。现在我们已经实现了
    `Catalog.Domain` 项目服务层的日志机制，我们将检查和实现必要的日志提供者。
- en: Implementing logging providers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现日志提供者
- en: So far, we have defined *what* to log in our application; in this section, we
    will illustrate *how* to do this. In ASP.NET Core, the logging provider is initialized
    using dependency injection. Moreover, it is possible to conditionally initialize
    it, depending on the environment or other startup options.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了在应用程序中要记录的内容；在本节中，我们将说明如何实现这一点。在 ASP.NET Core 中，日志提供者是通过依赖注入初始化的。此外，根据环境或其他启动选项，我们可以有条件地初始化它。
- en: 'ASP.NET Core provides some *built-in* logging providers, as shown in the following
    table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一些内置的日志提供者，如下表所示：
- en: '| **Providers** | **Namespace** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **提供者** | **命名空间** | **描述** |'
- en: '| `Console` | `Microsoft.Extensions.Logging.Console` | Sets the console of
    the running application as the output of the logs. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Console` | `Microsoft.Extensions.Logging.Console` | 将运行应用程序的控制台设置为日志的输出。|'
- en: '| `Debug` | `Microsoft.Extensions.Logging.Debug` | Writes messages in the debug
    output window when a debugger is attached. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Debug` | `Microsoft.Extensions.Logging.Debug` | 当附加调试器时，在调试输出窗口中写入消息。|'
- en: '| `EventSource` | `Microsoft.Extensions.Logging.EventSource` | Sets the Windows
    ETW as the main log''s output. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `EventSource` | `Microsoft.Extensions.Logging.EventSource` | 将 Windows ETW
    设置为主要日志的输出。|'
- en: '| `EventLog` | `Microsoft.Extensions.Logging.EventLog` | Sets the Windows event
    log as the main log''s output. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `EventLog` | `Microsoft.Extensions.Logging.EventLog` | 将 Windows 事件日志设置为主要日志的输出。|'
- en: '| `TraceSource` | `Microsoft.Extensions.Logging.TraceSource` | To use this
    provider, ASP.NET Core needs to run on the .NET Framework. The application will
    use the listeners that are provided by the trace source. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `TraceSource` | `Microsoft.Extensions.Logging.TraceSource` | 要使用此提供者，ASP.NET
    Core 需要在 .NET Framework 上运行。应用程序将使用由跟踪源提供的监听器。|'
- en: 'It is crucial to note that all the logging providers are complementary. Furthermore,
    it is possible to add many of them so that we can perform trace logging in more
    sources. We can configure the provider in the `Startup` class and in the `Program`
    class. Let''s take a look at the `Program` class of `Catalog.API`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，所有日志提供者都是互补的。此外，我们可以添加许多提供者，以便在更多源中进行跟踪日志记录。我们可以在 `Startup` 类和 `Program`
    类中配置提供者。让我们看看 `Catalog.API` 的 `Program` 类：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, the `Program` class uses `WebHost.CreateDefaultBuilder` to create the
    `WebHostBuilder` instance of the service. If we go further into the method, we
    will see that it uses the following syntax to define the log''s provider:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Program` 类使用 `WebHost.CreateDefaultBuilder` 来创建服务的 `WebHostBuilder` 实例。如果我们进一步查看该方法，我们会看到它使用以下语法来定义日志的提供者：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the `Program` class defines three built-in providers by default.
    Also, it uses the `Configuration` instance to pass the configurations that are
    described in the `appsettings.json` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Program` 类默认定义了三个内置提供者。此外，它使用 `Configuration` 实例来传递在 `appsettings.json`
    文件中描述的配置。
- en: 'Moreover, it is possible to override the default provider by explicitly calling
    the `ConfigureLogging` extension method in the `Program` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过在 `Program` 类中显式调用 `ConfigureLogging` 扩展方法来覆盖默认提供者：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding snippet is useful if we want to add a custom logging provider
    to our application. ASP.NET Core also provides us with a convenient way to configure
    the logging provider in the `Startup` class: it is possible to use the `AddLogging`
    extension method in `ConfigureServices`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在应用程序中添加自定义日志提供者，前面的代码片段非常有用。ASP.NET Core 还为我们提供了一个方便的方法来在 `Startup` 类中配置日志提供者：在
    `ConfigureServices` 中可以使用 `AddLogging` 扩展方法：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding snippet initializes the logging services on the execution of `ConfigureServices`
    in the `Startup` class. The initialization of the logging provider at the `Startup`
    level is useful when we want to initialize the log provider in terms of the environment
    or a specific configuration flag. Let's proceed by learning how to implement a
    custom logging provider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段在`Startup`类的`ConfigureServices`执行时初始化日志服务。在`Startup`级别初始化日志提供程序对于我们需要根据环境或特定的配置标志初始化日志提供程序时非常有用。让我们通过学习如何实现自定义日志提供程序来继续前进。
- en: Implementing a custom log provider in tests
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试中实现自定义日志提供程序
- en: 'As we already have seen, the logging system of ASP.NET Core is designed for
    maximum extensibility. In this section, we will learn how to implement a custom
    logging provider that we can use in our tests. All the test classes that are present
    in the `Catalog.API.Tests` project use `InMemoryApplicationFactory<T>` to run
    a web server and provide `HttpClient` to call the API. As you may have noticed,
    the tests don''t return an explicit error when one of the tests fails. For example,
    let''s examine the following test method in the `ItemControllerTests` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，ASP.NET Core的日志系统旨在提供最大的可扩展性。在本节中，我们将学习如何实现一个自定义日志提供程序，我们可以在测试中使用它。`Catalog.API.Tests`项目中的所有测试类都使用`InMemoryApplicationFactory<T>`来运行Web服务器并提供`HttpClient`来调用API。如您所注意到的，当其中一个测试失败时，测试不会返回显式的错误。例如，让我们检查`ItemControllerTests`类中的以下测试方法：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If for any reason, the call returns an error, we will receive the following
    message on the test side:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因调用返回错误，测试端将收到以下消息：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we don''t know *why* the API has returned an `InternalServerError`. Here,
    we can use the `ITestOutputHelper` interface provided by `Xunit` to create a new
    logger provider and use it in our tests. To declare a logger in ASP.NET Core,
    we need the following structure and components:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不知道*为什么*API返回了`InternalServerError`。在这里，我们可以使用`Xunit`提供的`ITestOutputHelper`接口来创建一个新的日志提供程序，并在我们的测试中使用它。要在ASP.NET
    Core中声明一个日志记录器，我们需要以下结构和组件：
- en: '![](img/5dfecc86-0882-4390-82df-2e36edc66afb.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dfecc86-0882-4390-82df-2e36edc66afb.png)'
- en: 'The preceding schema describes two main components: the `TestOutputLoggerProvider`
    type and the `TestOutputLogger` type. The `TestOutputLoggerProvider` type''s purpose
    is to manage a list of logger instances. The `TestOutputLogger` class describes
    the actual implementation of the logging mechanism. Let''s start by defining the
    custom `ILogger` component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的架构描述了两个主要组件：`TestOutputLoggerProvider`类型和`TestOutputLogger`类型。`TestOutputLoggerProvider`类型的目的是管理日志实例的列表。`TestOutputLogger`类描述了实际的日志机制实现。让我们首先定义自定义的`ILogger`组件：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ITestOutputClass` implements the methods provided by the `ILogger` interface.
    First of all, it declares an `ITestOutputHelper` field in the constructor. Then,
    it uses the `_output` attribute inside the concrete implementation of the `Log`
    method by calling the `_output.WriteLine` method. The class also implements the
    `IsEnabled` method to check whether the log level corresponds to the `LogLevel.Error`
    field. If the log record doesn''t do this, `LogLevel.Error` is written in the
    console''s output. To finalize this implementation, we need a logger provider
    to initialize the custom logger. Let''s continue by creating another class called
    `TestOutputLoggerProvider`, which extends the `ILoggerProvider` interface:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITestOutputClass`实现了`ILogger`接口提供的方法。首先，它在构造函数中声明了一个`ITestOutputHelper`字段。然后，它通过调用`_output.WriteLine`方法在`Log`方法的具体实现中使用`_output`属性。该类还实现了`IsEnabled`方法来检查日志级别是否对应于`LogLevel.Error`字段。如果日志记录不这样做，`LogLevel.Error`将被写入控制台输出。为了完成此实现，我们需要一个日志提供程序来初始化自定义日志记录器。让我们继续创建另一个名为`TestOutputLoggerProvider`的类，该类扩展了`ILoggerProvider`接口：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`TestOutputLoggerProvider` defines a `ConcurrentDictionary`, which contains
    a pair of `string` and `TestOutputLogger`; it also accepts the `ITestOutputHelper`
    interface as an interface, which is used in the `CreateLogger` method to add the
    logger to the logging pipeline. By doing this, we can integrate the custom logger
    into our tests. We will use the `InMemoryApplicationFactory<T>` class, which is
    implemented in the `Catalog.Fixtures` project, to add the custom logger, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestOutputLoggerProvider`定义了一个`ConcurrentDictionary`，其中包含一个`string`和`TestOutputLogger`的键值对；它还接受`ITestOutputHelper`接口作为接口，该接口在`CreateLogger`方法中使用，以将日志记录器添加到日志管道中。通过这样做，我们可以将自定义日志记录器集成到我们的测试中。我们将使用在`Catalog.Fixtures`项目中实现的`InMemoryApplicationFactory<T>`类来添加自定义日志记录器，如下所示：'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding class declares a new `ITestOutputHelper` attribute type and defines
    a setter. It is possible to add our custom logger by calling the `AddProvider`
    extension method inside the `ConfigureTestService` class by creating a new instance
    of `TestOutputLoggerProvider`. After making these changes, we can proceed by integrating
    the custom logger into the `ItemControllerTests` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类声明了一个新的 `ITestOutputHelper` 属性类型，并定义了一个设置器。我们可以在 `ConfigureTestService`
    类内部通过调用 `AddProvider` 扩展方法来添加我们的自定义日志记录器，创建 `TestOutputLoggerProvider` 的新实例。在做出这些更改后，我们可以通过将自定义日志记录器集成到
    `ItemControllerTests` 类中继续操作：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, `ItemControllerTests` calls `_factory.SetTestOutputHelper` in
    the constructor by setting the injected `ITestOutputHelper` interface. Now, we'll
    get detailed error messages every time a test throws an error. It is essential
    to note that the `ITestOutputHelper` interface is assigned in the test class,
    which means this is the only point where it is possible to obtain the interface
    using dependency injection. In the next section, we will learn how to implement
    health checks related to web service dependencies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`ItemControllerTests` 在构造函数中通过设置注入的 `ITestOutputHelper` 接口来调用 `_factory.SetTestOutputHelper`。现在，每次测试抛出错误时，我们都会得到详细的错误信息。重要的是要注意，`ITestOutputHelper`
    接口是在测试类中分配的，这意味着这是唯一可能通过依赖注入获取该接口的点。在下一节中，我们将学习如何实现与网络服务依赖相关的健康检查。
- en: Web service health check
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务健康检查
- en: Another essential feature that's always present in web services is the *health
    checking process* for dependencies. In general, the health check processes are
    used by the CI/CD pipeline to check whether a service is healthy after its deployment
    or to perform the feature check-in a monitoring dashboard. Health checks are usually
    performed by calling HTTP routes to detect whether there are any ongoing issues
    in the web service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个始终存在于网络服务中的关键特性是对依赖项的 *健康检查过程*。通常，健康检查过程由 CI/CD 管道用于检查服务在部署后是否健康，或者在监控仪表板中执行功能检查。健康检查通常通过调用
    HTTP 路由来检测网络服务中是否存在任何正在进行的问题。
- en: Note that these services expose the health check routes. The monitoring of these
    health checks is implemented in an independent and separate application. Furthermore,
    this practice allows us to keep the services independent from the monitoring logic.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些服务暴露了健康检查路由。这些健康检查的监控是在一个独立且分开的应用中实现的。此外，这种做法使我们能够保持服务与监控逻辑的独立性。
- en: ASP.NET Core provides some out-of-the-box implementations to help developers
    add health check processes to their services. These features are implemented using
    a *middleware-oriented approach.* Furthermore, the health checks are exposed as
    HTTP endpoints, and they can be used to check the status of third-party services,
    databases, and data storage systems. Thus, we can test the dependencies of the
    service to confirm their availability and functionality.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一些开箱即用的实现，以帮助开发者将健康检查过程添加到他们的服务中。这些功能是通过一种 *面向中间件的方法* 实现的。此外，健康检查作为
    HTTP 端点暴露，可以用来检查第三方服务、数据库和数据存储系统的状态。因此，我们可以测试服务的依赖项，以确认它们的可用性和功能。
- en: The health checks feature was introduced with the *ASP.NET Core 2.2.0-preview1*
    version in August 2018\. This feature introduced the `IHealthCheck` interface*.*
    In the future, it will be integrated with the `Polly` library to provide better
    resilience when users perform logging checks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查功能是在 2018 年 8 月的 *ASP.NET Core 2.2.0-preview1* 版本中引入的。这个功能引入了 `IHealthCheck`
    接口*.* 在未来，它将与 `Polly` 库集成，以提供更好的弹性，当用户执行日志检查时。
- en: Implementing health checks on databases
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据库上实现健康检查
- en: 'Databases are usually one of the main dependencies of a web service. Therefore,
    it is always essential to check the connection between the service and the database.
    Let''s start by learning how to implement health checks using the `AspNetCore.HealthChecks.SqlServer`
    ([https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/](https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/))
    and `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore` ([https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/](https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/))
    packages. We are going to apply these changes to the *catalog service* project.
    Let''s start by adding this package to the `Catalog.API`project:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常是网络服务的主要依赖之一。因此，始终需要检查服务与数据库之间的连接。让我们先学习如何使用`AspNetCore.HealthChecks.SqlServer`
    ([https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/](https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/))
    和 `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore` ([https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/](https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/))
    包来实现健康检查。我们将将这些更改应用到 *目录服务* 项目中。让我们首先将此包添加到 `Catalog.API` 项目中：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `AspNetCore.HealthChecks.SqlServer` package allows us to perform health
    checks on SQL Server instances. Let''s proceed by registering the following services
    in the `Startup` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`AspNetCore.HealthChecks.SqlServer` 包允许我们对 SQL Server 实例执行健康检查。让我们继续在 `Startup`
    类中注册以下服务：'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the code configures the *health check middleware* using the
    `AddHealthChecks` extension method, which returns an `IHealthChecksBuilder` interface;
    it calls the `AddSqlServer` extension method provided by the builder to bind the
    health check with the SQL Server database. Finally, the code adds the middleware
    by calling the `UseHealthChecks` method and passing in the health check route.
    If we can call our service at the `https://<hostname>:<port>/health` route, we
    will receive the `Healthy`/`Unhealthy` response, depending on the connection to
    our data source.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码使用 `AddHealthChecks` 扩展方法配置了 *健康检查中间件*，该方法返回一个 `IHealthChecksBuilder`
    接口；它调用由构建器提供的 `AddSqlServer` 扩展方法来绑定健康检查与 SQL Server 数据库。最后，通过调用 `UseHealthChecks`
    方法并传入健康检查路由来添加中间件。如果我们可以在 `https://<hostname>:<port>/health` 路由上调用我们的服务，我们将根据与数据源的连接收到
    `Healthy`/`Unhealthy` 响应。
- en: Implementing custom health checks
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义健康检查
- en: 'ASP.NET Core''s health check feature is not only suitable for the data source
    of our service; it can also be used to perform sophisticated and custom health
    checks. The framework provides the `IHealthCheck` interface so that we can implement
    our health check. Let''s create a new class called `RedisCacheHealthCheck` in
    the `HealthCheck` folder, inside the `Catalog.API` project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的健康检查功能不仅适用于我们服务的数据源；它还可以用于执行复杂和自定义的健康检查。框架提供了 `IHealthCheck` 接口，以便我们可以实现我们的健康检查。让我们在
    `Catalog.API` 项目的 `HealthCheck` 文件夹中创建一个名为 `RedisCacheHealthCheck` 的新类：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `RedisCacheHealthCheck` class uses the `StackExchange.Redis` package to
    create a connection with the Redis instance specified in the setting's connection
    string. The core part of this class is the `CheckHealthAsync` method; it returns
    `HealthCheckResult.Healthy` or `HealthCheckResult.Unhealthy`, depending on the
    response time of the Redis instance. If a ping takes less than five seconds to
    come back, it means that the instance is healthy; otherwise, it isn't. The class
    is part of the ASP.NET Core stack, and it can use the dependency injection engine
    of the framework to solve dependencies.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisCacheHealthCheck` 类使用 `StackExchange.Redis` 包通过设置连接字符串中指定的Redis实例创建连接。这个类的核心部分是
    `CheckHealthAsync` 方法；它根据Redis实例的响应时间返回 `HealthCheckResult.Healthy` 或 `HealthCheckResult.Unhealthy`。如果ping响应时间少于五秒，则表示实例是健康的；否则，它不是。该类是
    ASP.NET Core 堆栈的一部分，并且可以使用框架的依赖注入引擎来解决依赖关系。'
- en: 'Therefore, it is possible to add the class to the health check stack by adding
    the following snippet to the `ConfigureServices` method of the `Startup` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过向`Startup`类的`ConfigureServices`方法中添加以下代码片段来将类添加到健康检查堆栈中：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This approach will add the check for the SQL Server connection and the custom
    check we implemented in the `RedisCacheHealthCheck` class to the middleware pipeline.
    If both of them succeed, the service will be classed as healthy. Futhermore it
    will be possible to run the catalog containers using the `docker-compose up --build`
    command and verify the status of the dependencies of the catalog web service by
    calling the `http://<hostname:port>/health` route.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将 SQL Server 连接的检查以及我们在 `RedisCacheHealthCheck` 类中实现的自定义检查添加到中间件管道中。如果两者都成功，则该服务将被归类为健康状态。此外，还可以使用
    `docker-compose up --build` 命令运行目录容器，并通过调用 `http://<hostname:port>/health` 路由来验证目录网络服务的依赖项状态。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to track the state of our services using logging.
    We also learned how to customize a logger provider and how to integrate it with
    an ASP.NET Core application. Furthermore, we dealt with the new health checking
    feature of ASP.NET Core and learned how to build a custom health check.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用日志来跟踪我们服务的状态。我们还学习了如何自定义日志提供程序以及如何将其与 ASP.NET Core 应用程序集成。此外，我们还处理了
    ASP.NET Core 的新健康检查功能，并学习了如何构建自定义健康检查。
- en: Now, you know how to implement logging in an ASP.NET Core application and create
    a custom logger provider. You will be able to use these skills to keep track of
    the data that's exposed by your services and monitor the status of your web service
    instance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何在 ASP.NET Core 应用程序中实现日志记录并创建自定义日志提供程序。你将能够使用这些技能来跟踪你的服务暴露的数据并监控你的网络服务实例的状态。
- en: In the next chapter, we will learn how to bring our web service to the cloud
    using Azure.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Azure 将我们的网络服务迁移到云端。
