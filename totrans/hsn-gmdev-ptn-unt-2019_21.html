<html><head></head><body>
        

                            
                    <h1 class="header-title">Event Bus</h1>
                
            
            
                
<p class="mce-root">For our first subject in the <em>Decoupling</em> section of this book, we are going to review the Event Bus pattern. But first, we need to address the confusion that often arises between the definition of an Event Bus and its close cousin, the Event Queue. We can quickly boil down the core difference between both from their names.</p>
<p class="mce-root">A bus permits data to flow between different components, while a queue collects a list of data that needs processing at sequential intervals. And by this high-level definition of a bus, we can conclude that an Event Bus will focus on serving as a central hub for the publishing and broadcasting of events, and not as a queue of those events.</p>
<p class="mce-root">So, in this chapter, we will be focusing on building an Event Bus that will optimize the way we decouple listeners and consumers of events in Unity.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Reviewing the basics of the Event Bus pattern</li>
<li>Implementing a global messaging system that can be adapted to any game</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The Event Bus is an extension of the Observer pattern, so I recommend revisiting <a href="b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml"/><a href="b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml">Chapter 10</a>, <em>Observer</em>, before starting this one.</p>
<p>We will also be using the following specific Unity engine API features:</p>
<ul>
<li><kbd>UnityEvents</kbd></li>
<li><kbd>UnityActions</kbd></li>
</ul>
<p class="mce-root"/>
<p>If you're unfamiliar with these, please review their official Unity API documentation, but note that we will be reviewing them in the <em>Code example</em> section of this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2OxHxto">http://bit.ly/2OxHxto</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Event Bus Pattern</h1>
                
            
            
                
<p>There's a possible point of confusion around the Event Bus pattern. It's sometimes referred to as a <strong>Messaging System</strong> or the <strong>Publish-Subscribe</strong> pattern, the latter being the most accurate name for what we are implementing in this chapter. But because we are taking a very hands-on approach to this book, we are going to refer to this pattern's design as an Event Bus, which is a more high-level and system-oriented name for it.</p>
<p>As we have seen in <a href="b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml"/><a href="b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml"/><a href="b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml">Chapter 9</a>, <em>Observer</em>, C# has native implementations that simplify the process of integrating events by offering an event-driven mechanism that permits Subjects and Observers to communicate with each other. But C#'s native event system does have a drawback – observers need to be <em>aware</em> of the presence of potential subjects, or unexpected behaviors can occur.</p>
<p>This, therefore, is why we are going to learn how to use the Event Bus—with this pattern, we are going to eliminate this dependency and make it possible for any object to publish events and subscribe to them without any direct dependencies between each other. Consequently, we will shift from an observer/subject arrangement to a more flexible publisher/subscriber approach.</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/4fdc7d33-f5cd-485c-a783-15093ddb647a.png"/></p>
<p>Let's review the following diagram of the Event Bus and examine its elements:</p>
<p class="CDPAlignCenter CDPAlign"/>
<p>As we can see, there are three main ingredients:</p>
<ul>
<li><strong>Publishers</strong>:<strong> </strong>These objects can request the hub to manage specific events and broadcast them to the right listeners</li>
<li><strong>Event Hub</strong>: This object is responsible for coordinating the communication of events between the <strong>Publishers</strong> and <strong>Subscribers</strong></li>
<li><strong>Subscribers</strong>: These objects subscribe themselves to the hub's event broadcast channel so they can listen for specific events</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>The benefits and drawbacks of the Event Bus are quite moderate—it's a pattern that permits the implementation of an event management system without asking for significant architectural changes in your code base:</p>
<p class="mce-root"/>
<p>The <strong>benefits</strong> are as follows:</p>
<ul>
<li><strong>Decouples systems</strong>: Because publishers and subscribers only communicate through the Event Bus, it reduces direct references and decouples objects from each other<q><br/></q></li>
<li><strong>Broadcast channels</strong>: Similar to a TV or radio broadcast system, you can use the Event Bus as a way to transmit messages through specific channels that listeners can subscribe to at their discretion<q><br/></q></li>
</ul>
<p>The <strong>drawbacks</strong> to be aware of are as follows:</p>
<ul>
<li><strong>Memory overhead</strong>: Under the hood of any event system, there's a lot of low-level memory mechanisms that are being triggered to manage the communication between objects, so it might not be the best choice if you need to squeeze milliseconds of processing out of every frame</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">An example use case</h1>
                
            
            
                
<p class="mce-root">Unlike other patterns in this book, the Event Bus is a functional and complete system in itself. This fact means that we can implement it without having to map it into a specific in-game system, and it will still become an instrumental component of our game's architecture.</p>
<p class="mce-root">We could almost view the Event Bus as a global service that offers a way for all our components to message each other on specific channels. So, in the <em>Code example</em> section, we are going to implement the Event Bus in its native form, and make sure that it's globally accessible as a service for all our components.</p>
<p>Before starting the <em>Code example</em> section, I recommend reviewing <a href="b8d60568-5961-4e57-b722-36028db5d1a9.xhtml">Chapter 6</a>, <em>Singleton</em>, because we are going to use it as a base for our Event Bus class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>As mentioned in the <em>An example use case</em> section, we are going to implement the Event Bus as a service that all our components will be able to use when they need to broadcast events to other objects.</p>
<p>So, let's start by implementing the core of the system by writing our Event Bus class:</p>
<pre>using UnityEngine.Events;<br/>using System.Collections.Generic;<br/><br/>public class EventBus : Singleton&lt;EventBus&gt;<br/>{<br/>    private Dictionary&lt;string, UnityEvent&gt; m_EventDictionary;<br/><br/>    public override void Awake()<br/>    {<br/>        base.Awake();<br/>        Instance.Init();<br/>    }<br/><br/>    private void Init()<br/>    {<br/>        if (Instance.m_EventDictionary == null)<br/>        {<br/>            Instance.m_EventDictionary = new Dictionary&lt;string, UnityEvent&gt;();<br/>        }<br/>    }<br/><br/>    public static void StartListening(string eventName, UnityAction listener)<br/>    {<br/>        UnityEvent thisEvent = null;<br/>        if (Instance.m_EventDictionary.TryGetValue(eventName, out thisEvent))<br/>        {<br/>            thisEvent.AddListener(listener);<br/>        }<br/>        else<br/>        {<br/>            thisEvent = new UnityEvent();<br/>            thisEvent.AddListener(listener);<br/>            Instance.m_EventDictionary.Add(eventName, thisEvent);<br/>        }<br/>    }<br/><br/>    public static void StopListening(string eventName, UnityAction listener)<br/>    {<br/>        UnityEvent thisEvent = null;<br/>        if (Instance.m_EventDictionary.TryGetValue(eventName, out thisEvent))<br/>        {<br/>            thisEvent.RemoveListener(listener);<br/>        }<br/>    }<br/><br/>    public static void TriggerEvent(string eventName)<br/>    {<br/>        UnityEvent thisEvent = null;<br/>        if (Instance.m_EventDictionary.TryGetValue(eventName, out thisEvent))<br/>        {<br/>            thisEvent.Invoke();<br/>        }<br/>    }<br/>}</pre>
<p>As we can see, we are making our class into a Singleton; this will permit our <kbd>EventBus</kbd> instance to be globally accessible. But the most critical element that we need to notice is that we are using two new specific Unity API features: <kbd>UnityEvent</kbd> and <kbd>UnityAction</kbd>. </p>
<p><kbd>UnityEvent</kbd> and <kbd>UnityAction</kbd> are API wrappers over the .NET native delegate type. They behave almost exactly like regular delegates under the hood, but they offer extra features that are custom to Unity, such as the following, for example:</p>
<ul>
<li>Inspector access</li>
<li>Persistent callbacks</li>
</ul>
<p>We are using them in our example for reasons of simplicity while making sure we exploit Unity API's features to the fullest.</p>
<p>For more detailed information on the specific features that <kbd>UnityEvent</kbd> offers, please refer the official API documentation in the <em>Further reading</em> section.</p>
<p>If we break down the class even further, we can see that four core functions make the Event Hub function:</p>
<ul>
<li><kbd>Init()</kbd>: This initializes a dictionary that will hold in memory events to which <kbd>Subscribers</kbd> register</li>
<li><kbd>StartListening()</kbd>: This is a function that <kbd>Listeners</kbd> uses to register themselves to listen to a specific event</li>
<li><kbd>StopListening()</kbd>: This function permits <kbd>Listeners</kbd> to stop listening to a specific event</li>
<li><kbd>TriggerEvent()</kbd>: This function will trigger an event and broadcast it to all its <kbd>Listeners</kbd></li>
</ul>
<p>In theory, our work is done—with one class, we were able to implement an Event Bus that's globally accessible and ready to manage the communication of events between objects. So now, the only thing to do is to write ourselves an example of a Publisher object, along with a couple of Subscribers to test our new Event Bus service.</p>
<p>Let's start with the Publisher, as without one, our <kbd>Listeners</kbd> will have nothing to listen to except silence. We are going to implement a straightforward Publisher that triggers a broadcast of specific events depending on user input:</p>
<pre>using UnityEngine;<br/><br/>public class EventPublisher : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown("s"))<br/>        {<br/>            EventBus.TriggerEvent("Shoot");<br/>        }<br/><br/>        if (Input.GetKeyDown("l"))<br/>        {<br/>            EventBus.TriggerEvent("Launch");<br/>        }<br/>    }<br/>}</pre>
<p>Our <kbd>EventPublisher</kbd> class is elementary—it asks the Event Hub to broadcast the <kbd>Launch</kbd> and <kbd>Shoot</kbd> events depending on user input. This implementation means that any <kbd>Listeners</kbd> that are listening for events named <kbd>Launch</kbd> or <kbd>Shoot</kbd> will be triggered.</p>
<p>To validate this functionality, let's implement two Listeners, each with different responsibilities:</p>
<ul>
<li><kbd>Rocket</kbd>: This class listens for a <kbd>Launch</kbd> command event, and when it receives it, it triggers a launch sequence:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Rocket : MonoBehaviour<br/>{<br/>    private bool m_IsQuitting;<br/>    private bool m_IsLaunched = false;<br/><br/>    void OnEnable()<br/>    {<br/>        EventBus.StartListening("Launch", Launch);<br/>    }<br/><br/>    void OnApplicationQuit()<br/>    {<br/>        m_IsQuitting = true;<br/>    }<br/><br/>    void OnDisable()<br/>    {<br/>        if (m_IsQuitting == false)<br/>        {<br/>            EventBus.StopListening("Launch", Launch);<br/>        }<br/>    }<br/><br/>    void Launch()<br/>    {<br/>        if (m_IsLaunched == false)<br/>        {<br/>            m_IsLaunched = true;<br/>            Debug.Log("Received a launch event : rocket launching!");<br/>        }<br/>    }<br/>}</pre>
<ul>
<li><kbd>Cannon</kbd>: Similar to the <kbd>Rocket</kbd> class, <kbd>Cannon</kbd> listens for a <kbd>Shoot</kbd> command and then triggers the shooting mechanism at the reception of the message:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Cannon : MonoBehaviour<br/>{<br/>    private bool m_IsQuitting;<br/><br/>    void OnEnable()<br/>    {<br/>        EventBus.StartListening("Shoot", Shoot);<br/>    }<br/><br/>    void OnApplicationQuit()<br/>    {<br/>        m_IsQuitting = true;<br/>    }<br/><br/>    void OnDisable()<br/>    {<br/>        if (m_IsQuitting == false)<br/>        {<br/>            EventBus.StopListening("Shoot", Shoot);<br/>        }<br/>    }<br/><br/>    void Shoot()<br/>    {<br/>        Debug.Log("Received a shoot event : shooting cannon!");<br/>    }<br/>}</pre>
<p>Listeners only need to register themselves as listeners of a specific event by calling the <kbd>StartListening()</kbd> function and specifying the name of the event they want to listen to, along with the callback function. The Event Bus will take responsibility for coordinating the broadcast of events to the right Listeners and trigger their respective callback function when required.</p>
<p>There's something else we need to address. Notice that we are checking if the application is quitting with <kbd>OnApplicationQuit()</kbd> and validating the Boolean value of <kbd>m_IsQuitting</kbd> for <kbd>false</kbd> before calling the <kbd>EventBus.StopListening()</kbd> function. This approach is to avoid calling objects that might not be in memory anymore once the application is quitting.</p>
<p>In conclusion, the Event Bus almost performs a similar function to a motherboard bus in the sense that it's acting like a system of communication between separate components. But even a simple Event Bus, like the one we just implemented, can be extended into a more complex system, such as an Event Queue or a multi-channel Messaging System, if need be.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we reviewed and implemented the Event Bus, a pattern with a focus on decoupling the relationship between the objects that broadcast events and those that listen to them. By exploiting new native Unity API features such as <kbd>UnityEvents</kbd>, we were able to implement this pattern with the minimum amount of code quickly.</p>
<p class="mce-root"/>
<p><br/>
In the next chapter, we will be reviewing the Service Locator, another pattern that focuses on decoupling complex relationships between dependencies, but this time by offering a way for objects to locate services.</p>
<p>I encourage any Unity programmer to take the time to read the engine's entire API documentation, currently available on Unity's official website, and to memorize as much of it as you can. This exercise will make you more aware of the features it offers, and may even make you a faster coder. The detailed knowledge of this API will also impress your colleagues or potential future interviewers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p class="mce-root">As indicated at the beginning of this chapter, we decided to focus on the Event Bus pattern, and not its cousin, the Event Queue. But a bus mechanism can be converted to a queue. So, as a practical exercise, I would recommend to converting the Event Bus example we just completed, and instead of just having it forwarding triggered events to subscribers, it should hold them in a queue so they can be handled sequentially.</p>
<p>You can refer to the material indicated in the <em>Further reading</em> section of this chapter for inspiration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Unity - Manual: UnityEvents:</em><strong><br/></strong><a href="https://docs.unity3d.com/Manual/UnityEvents.html">https://docs.unity3d.com/Manual/UnityEvents.html</a></li>
<li><em>Unity - Scripting API Documentation:</em><br/>
<strong><a href="https://docs.unity3d.com/ScriptReference/">https://docs.unity3d.com/ScriptReference/</a></strong><a href="https://docs.unity3d.com/Manual/UnityEvents.html"/></li>
<li><em>Game Programming Patterns</em> by <em>Robert Nystrom</em>:<strong><br/></strong><a href="http://gameprogrammingpatterns.com/">http://gameprogrammingpatterns.com</a></li>
</ul>


            

            
        
    </body></html>