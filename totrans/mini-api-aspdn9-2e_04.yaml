- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling HTTP Methods and Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B20968_02.xhtml#_idTextAnchor033) , we discussed ways that
    you can define endpoints and use routing within a minimal API. That was from a
    high level.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this chapter, we will discuss in more detail how routes and endpoints
    can be configured for the handling of incoming requests. We will go into more
    detail about how you can use route parameters to be more specific about the required
    parameters received by each endpoint, and we will also explore examples of request
    validation, wherein we ensure that the request is properly formed, issuing the
    relevant response as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, no API can be deemed reliable if its endpoints do not adequately recover
    from receiving invalid data so we will also explore ways in which validation errors
    can be handled gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: To gain a better understanding of these topics, we will use an example application
    for managing tasks. The application is part of a productivity suite, which has
    an API for managing to-do lists and projects. By building elements of this API,
    you will gain a more in-depth understanding of how requests are received by minimal
    APIs and how they are handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, this chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining endpoints in the Todo API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request validation and error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: You can of course follow along and write the code yourself as you read the chapter
    if you have Visual Studio 2022 / Visual Studio Code installed with . NET 9.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle incoming requests, we first need a set of minimal API endpoints for
    those requests to be sent to. Let’s recap what we explored in [*Chapter 2*](B20968_02.xhtml#_idTextAnchor033)
    , around creating minimal API endpoints with varying HTTP methods ( **GET** ,
    **POST** , **PUT** , **DELETE** , and **PATCH** ). We can refresh our memories
    by creating some static *mock* data that will represent the task entities our
    API is handling. Then, we can define some simple endpoints that manipulate or
    query that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the mock data first. We’ll do this by creating a simple **TodoItem**
    class, and a static list for instances of this class to reside in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The **TodoItem** class can stay quite simple for the time being. It can be
    expanded upon later with more specific properties as we understand our needs further.
    The same approach can be taken with the next piece of code, which for now will
    be a list of **TodoItem** , simply called **ToDoItems** . In this list, we store
    instances of **TodoItem** to be handled by endpoints during requests. Let’s place
    this list in **Program.cs** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our temporary data storage solution in the form of a list,
    we can focus on creating endpoints for handling requests and managing todo items.
  prefs: []
  type: TYPE_NORMAL
- en: Defining endpoints in the Todo API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s advisable to start as simple as possible in creating a minimal API. After
    all, the name *minimal API* connotes simplicity. This isn’t just simplicity for
    simplicity’s sake though. For now, our API only needs to cover one area: todo
    items. Sure, the scope might expand further in the future, and minimal APIs can
    still be crafted in such a way that they are expandable and therefore somewhat
    future-proofed, but until more requirements become apparent (for example, assigning
    to-do items to users, adding to-do items to specific projects, etc.), the aim
    is minimalism. With this in mind, we will, for now, keep our endpoints in **Program.cs**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now ask ourselves a simple question: *What do I want to do in* *this
    API?*'
  prefs: []
  type: TYPE_NORMAL
- en: By this, I mean the actions that the API will need to facilitate. For example,
    fetching todo items, updating todo items, deleting todo items, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In understanding the *verbs* that are part of the actions of your API, we can
    identify the required HTTP methods. Consider the basic actions required for todo
    items. We will certainly want to *retrieve* todo items. That will require an HTTP
    **GET** method. Moreover, we will also want to *create* a **TodoItem** object.
    This will require an HTTP **POST** method. Let’s start with the first example,
    retrieving some todo items, and then build up from there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve read through [*Chapter 2*](B20968_02.xhtml#_idTextAnchor033) , you
    will have already seen examples of how an HTTP **GET** method can be created as
    an endpoint in minimal APIs. For this project, we will first create an endpoint
    that simply retrieves the contents of **List<TodoItem>** , which we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to *map* an HTTP **GET** method onto the instance
    of **WebApplication** on which our minimal API is running. There are several functions
    within **WebApplication** that achieve this. Each of them is prefixed with the
    word **Map** and followed by the relevant method verb. In this example, we’ll
    use **MapGet()** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, an HTTP **GET** method has been mapped to the **/todoitems** route,
    meaning that should a user request the API’s base URL, followed by **/todoitems**
    , this endpoint would be reached.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if our URL is hosted at [https://example.org/reallysimpletodoapi](https://example.org/reallysimpletodoapi)
    , accessing [https://example.org/reallysimpletodoapi/todoitems](https://example.org/reallysimpletodoapi/todoitems)
    will reach this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can get to the handling of the request, which happens in the function
    body. Notice that the endpoint we’ve created has a lambda expression after the
    route definition. The expression body is currently empty. It is within this expression
    body that we will handle the request by retrieving the requested data and responding
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, because we are simply returning the contents of the **ToDoItems**
    list, the data is readily available, but how do we get that data back to the client?
    ASP.NET provides us with a helper object in the form of **IResult** , whose **Results**
    object exposes various methods for responding to requests. This takes care of
    the fundamental aspects of returning a response, such as the status code, response
    body, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this simple HTTP **GET** method, we can return an HTTP **200 OK** response
    along with the requested data by simply returning the result of **Results.OK(ToDoItems)**
    . This function generates the relevant status code and takes an argument of type
    **object** , representing the data that should be returned to the client. Once
    added, the endpoint should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So far, the focus has been on routing requests into the API for the purposes
    of retrieving data. We will also need to create new data in the system; so, let
    us turn our attention to the creation of todo items.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now look at another critical operation for APIs: creating an entity.
    To create a new **TodoItem** , we would use an HTTP **POST** method.'
  prefs: []
  type: TYPE_NORMAL
- en: The mapping of an HTTP **POST** method is similar to the code we’ve just written
    for mapping a **GET** method. Once again, we use a method prefixed with the word
    **Map** . This method is **MapPost()** . However, there is a slight difference
    in the syntax compared to our **GET** method, as we now need to receive a data
    structure. In the case of creating a **TodoItem** , we will require the client
    to send an object of type **TodoItem** , represented in JSON format on the client-side.
    ASP.NET will then take care of parsing the JSON into a strongly typed instance
    of **TodoItem** , which we can use whilst handling the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the method to receive an object as part of the incoming request, we
    can take the parentheses at the beginning of the lambda expression within the
    endpoint’s body and add the object to it. For example, notice how the previous
    endpoint we created, which retrieves a **TodoItem** , has these empty parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The handling of our minimal API endpoints is represented by a lambda expression.
    Lambda expressions open with an input in the form of parameters, which are passed
    in through these empty parentheses, as shown in the following code. This means
    that for our HTTP **POST** endpoint, we can add a parameter of type **TodoItem**
    to the **MapPost()** method we are adding, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have an HTTP **POST** endpoint, sitting on the **/todoitems** route,
    just like our HTTP **GET** endpoint. The difference is that not only does it respond
    to a different HTTP verb, but it also requires the client to send a JSON payload
    mirroring the structure of **TodoItem** .
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t yet have anything inside the lambda expression within the endpoint,
    meaning that nothing will happen when a client sends a request. Let’s finally
    handle the request by adding the incoming **TodoItem** to the list and then returning
    the relevant response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the **GET** example, we are using **Results** to form a response
    and send it back to the client. However, we have opted for a slightly different
    response in this case. As the request is intended to create an entity, it is appropriate
    to return an **HTTP 201 CREATED** status code on successful creation, hence the
    use of **Results.Created();** .
  prefs: []
  type: TYPE_NORMAL
- en: Updating existing Todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to updating a **Todoitem** , we have a couple of HTTP methods
    at our disposal. Let’s start with an HTTP **PUT** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP **PUT** requires the client to send a full copy of the entity being
    updated. It will then replace the entity with the copy. It is a *full update*
    . Therefore, we need to create an endpoint that receives a **TodoItem** as part
    of the request, before finding the relevant item in our list and then replacing
    it with the incoming **TodoItem** . First, we’ll create an empty **PUT** endpoint
    sitting on the **/todoitems** route that expects the item as an object parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, the request should be handled by finding the **TodoItem** that we intend
    to update. We can do this using a **Language Integrated Query** ( **LINQ** ) query
    to find the item by its unique ID, with **FindIndex();** .
  prefs: []
  type: TYPE_NORMAL
- en: LINQ queries
  prefs: []
  type: TYPE_NORMAL
- en: A LINQ query with lambda expressions in C# lets you easily search and manipulate
    data in collections such as lists. You start by defining your data source, then
    use methods such as **Where** to filter the data and **Select** ” to choose what
    you want from the data. Each method takes a lambda expression, which is a simple
    function that defines your criteria. In our example, we’re using a LINQ query
    to find the index of an item in a list that shares the same ID as a given item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once found, **TodoItem** can be replaced with the incoming item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we did not return **Results.OK** again in this example. Because we’re
    simply updating a resource, the client is not expecting content to be returned;
    so, we indicate success by returning an **HTTP 204 NO CONTENT** status code using
    **Results.NoContent();** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating **TodoItem** via HTTP **PATCH** is handled slightly differently. Unlike
    **PUT** , we handle the request by once again finding the relevant item, but this
    time, we only change specific properties of the item, as dictated by the request
    parameters. This is usually used in scenarios where you want to create an endpoint
    on a route that is for a specific update. So, in this case, we will no longer
    create the endpoint on the **/todoitems** route. Instead, we will be specific
    about what we want to change by mapping the **PATCH** method to the **/updateTodoItemDueDate**
    route. In this example, we are creating an endpoint intended for a single purpose
    – to change the due date on the target **TodoItem** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code looks like the **PUT** method we created, but you can see that the
    parameters are quite different. Instead of requiring the full **ToDoItems** object
    to be sent in by the client, we instead ask for two parameters, an **int** parameter
    (to find the target item by ID) and a **DateTime** parameter containing the new
    due date. It is then possible to find the target item with another LINQ query,
    and then only update its **DueDate** property.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve handled scenarios wherein we need to get all items, create an
    item, and update items. We will next look at scenarios in which we intend to get
    single items and delete items. However, to do this, we first need to explore the
    concept of route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Managing route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Route parameters** give us the ability to capture values from the URL of
    an API endpoint. This is useful in many scenarios where we need to target specific
    entities, such as when requesting a **TodoItem** by its ID.'
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters are quite simple to add, and work using curly braces to define
    the parameters to be captured from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a **GET** request as an example. In this request, the client requests
    a **TodoItem** with the ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Like the generic **GET** request we created to fetch all todo items, this endpoint
    is sitting on the **/todoitems** route. However, it has an extra section appended
    to this route in the URL. The client is expected to also add an ID value as an
    extra URL section. This is shown by the presence of **{id}** in the route.
  prefs: []
  type: TYPE_NORMAL
- en: This use of parameters within curly braces is how ASP.NET handles dynamic content
    in the route URL. Using a form of templating, it can replace the section of the
    URL where we added **{id}** with the value specified by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of this can be seen in an HTTP **DELETE** endpoint. Again,
    when deleting **TodoItem** , we want to delete a specific item so we will once
    again need to pass in an ID for the target to be deleted. Let’s write the code
    for this in which we will map a new HTTP **DELETE** method to the **/todoitems**
    route. On the route, we’ll add a route parameter to pass the ID for the **TodoItem**
    to be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On receiving a **DELETE** request on the **/todoitems** route, if an **int**
    has been appended to the URL, it will be stripped out and used within the request
    as a parameter. The subject of parameter data type is an important one. In the
    **DELETE** example, we passed an **int** as an ID parameter because that is the
    data type used on the ID property of the **TodoItem** class ( our model).
  prefs: []
  type: TYPE_NORMAL
- en: 'What if someone sends a different data type as the parameter, such as a string?
    We would need to handle this of course, but we shouldn’t have to ensure that the
    incoming ID is an **int** within the code. There is a better way of ensuring that
    the request only hits the route if the parameters being sent are of the correct
    data type: **route** **parameter constraints** .'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a constraint to a route parameter makes it so that the incoming parameter
    must be formed in a particular way for the route to be found and the request received.
    In our **DELETE** endpoint, we can use a parameter constraint to dictate that
    the parameter must be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a constraint to the parameter is very simple. We just append a **:**
    character to the parameter, followed by the constraint. Let’s add a constraint
    to our **DELETE** endpoint to ensure the route is only used when the **id** parameter
    is of type **int** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the constraint in place, if a request was received that could
    not be treated as an **int** , the API would return a **404 NOT FOUND** response.
    It does this because the constraint stops ASP.NET from attempting to use the parameter
    as an ID, because it has already evaluated the data type thanks to the constraint.
    The result is that no other suitable route is found. (Unless there is a route
    on the **/todoitems** URL that can receive a string and is also an HTTP **DELETE**
    method.)
  prefs: []
  type: TYPE_NORMAL
- en: Parameter constraints are not limited to data types. Parameters can be constrained
    by string length, numerical ranges, regex patterns; the list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s constrain the **DELETE** range even further by adding a range constraint.
    We’ll make it so that the route can only delete the first 100 IDs. We can add
    multiple constraints to a single route like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By chaining another constraint onto the existing one, we have now enforced that
    the **Id** parameter must be an **int** and that its value must be between **1**
    and **100** .
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.1* shows some other constraint examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constraint Type** | **Route Example** | **Constraint Detail** |'
  prefs: []
  type: TYPE_TB
- en: '| Length | **/** **users/{username:length(3,20)}** | The username string must
    be between three and twenty characters long |'
  prefs: []
  type: TYPE_TB
- en: '| Length | **/** **users/{username:length(8)}** | The username string must
    be exactly eight characters long |'
  prefs: []
  type: TYPE_TB
- en: '| Min Length | **/** **users/{username:minlength(5)}** | The username string
    must be at least five characters long |'
  prefs: []
  type: TYPE_TB
- en: '| Max Length | **/** **users/{username:maxlength(30)}** | The username string
    must be no more than thirty characters long |'
  prefs: []
  type: TYPE_TB
- en: '| Regular Expression | **/** **addNewCreditCard/{cardNumber:regex(^3[47][0-9]{{13}}$)}**
    | The credit card number must conform to the pattern of an American Express card
    number |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Examples of parameter constraints in minimal APIs'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more focused on how parameters are passed into our requests,
    we can focus our attention on the request body, in which we do the main handling
    of the request. A major part of handling any request is validation. Minimal APIs,
    like any other API, will receive data within requests, which must suit the conditions
    needed to handle the request. Let’s look at some validation techniques we can
    use to manage the request flow and handle any errors that may arise as a result
    of any violations of validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Request validation and error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several different methods of validation at our disposal. We’re going
    to look at two of them in this section: **manual validation** and **data annotation**
    and **model** **binding validation** .'
  prefs: []
  type: TYPE_NORMAL
- en: Manual validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of validation is the simplest, as you are writing code inside the
    route handler (the body of the lambda expression within an endpoint) that validates
    the request and decides on the appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already applied manual validation in some parts of the todo items API.
    For example, the **PATCH** method we created to update the due date on items first
    checks for the **Todo** item with the target ID. It *could* just assume that **TodoItem**
    exists in the list, but instead, we check first to see if it exists and then return
    a **404 NOT FOUND** status code if this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By adding this manual check, we are actively validating and handling an exceptional
    scenario. Having validation in an API endpoint is not just best practice, it is
    critical. Manual validation is the most basic form of validation. The problem
    is it relies on the intuition of a human; the developer writing the code. This
    is a subject of some debate because a lot of validation methods have gaps, but
    relying solely on manual validation can result in fragile APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate this, we can also adopt a more standardized framework for validation,
    one provided by ASP.NET: validation with data annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: Validation with data annotations and model binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As demonstrated by the simple API example we’ve built in this chapter, models
    are an important aspect of minimal APIs. They allow us to represent the entities
    that incoming requests retrieve, move, and transform. In the todo items API, we
    created a **TodoItem** class as a model, and then stored the entities in **List<TodoItem>**
    .
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to validate a request’s data by the way it binds to specific
    models. For example, in the **TodoItem** model, it is reasonable to expect that
    the **Title** field should be populated when **TodoItem** is created.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify a field’s requirements by annotating it with an attribute. Attributes
    are handy pieces of metadata that allow us to apply constraints to code. One of
    the most common uses of attributes in this case is the **[** **Required]** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes we need are part of the **System.ComponentModel.DataAnnotations**
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Required namespace for validation
  prefs: []
  type: TYPE_NORMAL
- en: As in the **Todo** class, **System.ComponentModel.DataAnnotations** must also
    be added to **Program.cs** for validation to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this namespace to the top of the **TodoItem** class, followed by the **[Required]**
    attribute above the **Title** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a **[Required]** attribute is not enough on its own to trigger validation.
    We still need to invoke validation within our requests. However, we can do this
    once within the request, and then all items requiring validation will be validated,
    according to the attributes we applied. Here’s how we can invoke validation of
    our model from the **POST** request we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have initialized a new collection, a list of **ValidationResult**
    . This will contain information about the success or failure of validation. We
    will return this collection to the client if validation fails.
  prefs: []
  type: TYPE_NORMAL
- en: We also create a new **ValidationContext** , passing in the item that is to
    be validated. Because we want to validate the **TodoItem** instance that is sent
    as a payload, we pass this into **ValidationContext** .
  prefs: []
  type: TYPE_NORMAL
- en: We can then invoke validation by calling **Validator.TryValidateObject()** ,
    passing in the item as the validation target, the context we created that will
    be validated against, and the collection into which results will be saved, followed
    by a Boolean value of **true** , to state that all properties should be validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when a request is sent that omits a **Title** field from the payload,
    the following error JSON is automatically generated and sent back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This validation and error handling all happen automatically, thanks to the use
    of attributes and the built-in validator.
  prefs: []
  type: TYPE_NORMAL
- en: The error message shown is automatically generated because of the **[Required]**
    attribute. This can be overridden by adding a parameter to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated code on the **TodoItem** model, with a custom error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the custom error message in the generated error response JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**[Required]** is just one of many validation attributes that data annotations
    have to offer. There are many other constraints you can add. Some examples of
    these include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[EmailAddress]** : This ensures the value conforms to the format of an email
    address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[AllowedValues]** : This forces the use of specific values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[DeniedValues]** : This is the opposite of **[AllowedValues]** , denying
    the use of specific values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[StringLength(x)]** : This requires that a string value be of a certain length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[CreditCard]** : The annotated value must be a valid credit card format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of the many attributes that can be used to validate incoming
    responses, returning appropriate errors as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Managing HTTP methods and handling requests are critical aspects of minimal
    APIs, as it is in any API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Validation with filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also apply more specific validation rules with filters. **IEndpointFilter**
    is an interface that can be implemented to perform validation of the incoming
    request information before it hits the logic within an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: There is a handy extension method, **AddEndPointFilter<T>** , which allows you
    to attach a class implementing **IEndpointFilter** to an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore an example of this against a **POST** endpoint on our todo API.
    We’ll create a rule where a todo item cannot be assigned to anyone named Joe Bloggs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class that implements **IEndpointFilter** . This class will be required
    to define a function called **Invoke** , returning **ValueTask<object?>** . The
    function takes **EndPointFilterInvocationContext** and **EndpointFilterDelegate**
    as parameters in order to carry out the validation logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**EndPointFilterInvocationContext** will contain the incoming **TodoItem**
    , as it represents the context of the endpoint we are validating. Inside **InvokeAsync**
    , define logic to gain access to the incoming **TodoItem** from the endpoint’s
    context and then validate that we are not attempting to assign it to Joe Bloggs.
    If we are, return the appropriate response so that validation fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, for validation that passes, we want to pass the flow of execution
    back to the original endpoint (or any other chained logic attached to it, a bit
    like we do for a middleware pipeline). Do this by returning a call to **EndpointFilterDelegate**
    , which we received as a parameter, passing in the endpoint context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the filter validation to the endpoint as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, if you want to define the endpoint filter inline, you can do
    so by passing in an anonymous function instead of a type after **AddEndpointFilter**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you’ve gained some insight into the various ways we can achieve validation
    for different API endpoints, let’s recap the things we’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a high-level view of HTTP methods and how they are
    handled. We explored in further detail the way in which requests can be routed,
    allowing essential parameters to be lifted out of route definitions with routing
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into the basics of validation, firstly by placing constraints
    on our API routes to ensure that the data received is formatted in an appropriate
    manner. Following this, we learned how to handle validation in different ways,
    including manual validation, and the use of data annotations in models to invoke
    validation in a centralized fashion within the endpoint body.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we saw examples of how errors can be captured through
    validation techniques, and how informative error responses should be handed back
    to clients to inform their debugging strategies.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be capable of putting together a basic yet functional minimal
    API project. In the next chapter, we will learn how to introduce custom functionalities
    to our application pipelines in the form of middleware.
  prefs: []
  type: TYPE_NORMAL
