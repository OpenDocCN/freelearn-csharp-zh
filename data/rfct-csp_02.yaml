- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introduction to Refactoring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构简介
- en: The best way to learn refactoring is to look at an example. In this chapter,
    we’ll explore a sample refactoring scenario using C# and Visual Studio and see
    firsthand how refactoring can transform the maintainability of code without altering
    its functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习重构的最佳方式是查看示例。在本章中，我们将使用C#和Visual Studio探索一个示例重构场景，并亲眼看到重构如何在不改变其功能的情况下改变代码的可维护性。
- en: 'In this chapter, we’re going to cover the following main areas:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Refactoring a baggage price calculator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新整理行李价格计算器
- en: Refactoring in other editors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他编辑器中进行重构
- en: Along the way, we’ll cover refactorings around introducing locals, constants,
    and parameters, extracting methods, and removing unreachable/unused code, as well
    as touching upon the importance of testing in any refactoring endeavor.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将介绍引入局部变量、常量和参数、提取方法和删除不可达/未使用代码的重构，以及讨论在重构工作中的测试的重要性。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow along with this chapter, you can clone this book’s code
    from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随本章，可以从GitHub克隆本书的代码：[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)。
- en: The starting code for this chapter can be found in the `Chapter02/Ch2BeginningCode`
    folder after cloning the repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可以在克隆存储库后，在`Chapter02/Ch2BeginningCode`文件夹中找到。
- en: Refactoring a baggage price calculator
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新整理行李价格计算器
- en: We’ll start by examining a baggage price calculator used by the staff of Cloudy
    Skies Airline during baggage checks to determine the amount an individual customer
    must pay.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查Cloudy Skies航空公司工作人员在行李检查时使用的行李价格计算器，以确定单个客户必须支付的金额。
- en: 'The rules for baggage pricing are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 行李定价规则如下：
- en: All carry-on baggage costs $30 per bag
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有托运行李每件费用为30美元
- en: The first checked bag a passenger checks costs $40
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘客检查的第一个行李费用为40美元
- en: Each subsequent checked bag costs $50
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每件随后的托运行李费用为50美元
- en: If the travel occurs during the holidays, a 10% surcharge is applied
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果旅行发生在假期期间，将应用10%的附加费
- en: 'This code lives in a C# `BaggageCalculator` class that we’ll review in a few
    blocks of code, starting with the class definition, field, and full property:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码位于一个C# `BaggageCalculator`类中，我们将在接下来的几个代码块中对其进行审查，从类定义、字段和完整属性开始：
- en: 'BaggageCalculator.cs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BaggageCalculator.cs：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a simple class with an older style of property definition setting `holidayFeePercent`
    to a `decimal` value (identified by the `M` suffix) of `0.1` or 10%.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，使用较旧的属性定义样式将`holidayFeePercent`设置为`decimal`值（由`M`后缀标识）为`0.1`或10%。
- en: 'The class also has a `CalculatePrice` method that returns a `decimal` value
    indicating the total cost of baggage fees:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包含一个`CalculatePrice`方法，该方法返回一个表示行李费用总金额的`decimal`值：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That logic has some complexity to it, but it matches up with the business rules
    described earlier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该逻辑有些复杂，但它与之前描述的业务规则相匹配。
- en: 'Finally, the class ends with a `CalculatePriceFlat` method that was introduced
    in an earlier version of the application and is no longer used (which we’ll discuss
    later):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该类以一个`CalculatePriceFlat`方法结束，该方法是在应用程序的早期版本中引入的，现在不再使用（我们将在后面讨论）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this code isn’t the worst in the world by any stretch, this is a class
    that is slowly growing in complexity and becoming harder to understand and maintain
    as new rules are added to the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码在世界上并不是最糟糕的，但这是一个随着新规则添加到应用程序中而逐渐增加复杂性、变得难以理解和维护的类。
- en: Fortunately, this class is supported by a series of passing unit tests and is
    generally agreed to calculate the correct amount by all users.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个类由一系列通过单元测试支持，并且所有用户都普遍认为它能够正确计算金额。
- en: Over the course of the chapter, we’ll apply a series of targeted refactorings
    to improve this code to prevent it from being an issue in the future.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将应用一系列有针对性的重构来改进此代码，以防止其在未来成为问题。
- en: Converting properties to auto properties
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将属性转换为自动属性
- en: 'The class starts with the declaration of the `HolidayFeePercent` property as
    shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类的声明从以下`HolidayFeePercent`属性开始，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is fine and has no issues whatsoever. However, C# is a language that
    continues to evolve and developers generally prefer to write and maintain fewer
    lines of code when given the choice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是好的，没有任何问题。然而，C#是一种不断发展的语言，开发者通常在可以选择的情况下更喜欢编写和维持更少的代码行。
- en: Because of this, Microsoft gave us the ability to write *automatically implemented
    properties* (commonly called **auto properties**) that automatically generate
    their own field with a getter and setter when the code is compiled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Microsoft给了我们编写*自动实现属性*（通常称为**自动属性**）的能力，当代码编译时，它会自动生成自己的字段以及获取器和设置器。
- en: While we could delete the property and its field and redeclare it, there’s a
    possibility that we could make a spelling or capitalization mistake when doing
    so. Instead, let’s take a look at how Visual Studio can do this for us automatically.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可能删除属性及其字段并重新声明时，存在一种可能性，即我们可能会在这样做时犯拼写或大小写错误。相反，让我们看看Visual Studio如何能自动为我们完成这项工作。
- en: 'In Visual Studio, if you move your typing cursor onto a property name, either
    by using the arrow keys or by clicking on the name of the property, you’ll see
    a light bulb appear in the margin as shown in *Figure 2**.1*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，如果你通过使用箭头键或点击属性名称将输入光标移到属性名称上，你会在边缘看到一个轻 bulb，如图*图2.1*所示：
- en: '![Figure 2.1 – The light bulb Quick Actions icon](img/B21324_02_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 轻 bulb 快速操作图标](img/B21324_02_01.jpg)'
- en: Figure 2.1 – The light bulb Quick Actions icon
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 轻 bulb 快速操作图标
- en: If you click on this light bulb (or press *Ctrl* + *.* by default), the **Quick
    Actions** menu will appear and list several refactorings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击这个轻 bulb（或默认按*Ctrl* + *.*），将出现**快速操作**菜单，并列出几个重构选项。
- en: The refactoring choices are context-sensitive, so only those that Visual Studio
    believes are relevant to the code you have currently selected will appear.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重构选择是上下文相关的，因此只有Visual Studio认为与你当前选择的代码相关的那些才会出现。
- en: 'In this case, the first option, **Use auto property**, is the refactoring action
    we want. See *Figure 2**.2*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个选项，**使用自动属性**，是我们想要的重构操作。见图*图2.2*：
- en: '![Figure 2.2 – Previewing the Use auto property refactoring](img/B21324_02_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 预览使用自动属性的重构](img/B21324_02_02.jpg)'
- en: Figure 2.2 – Previewing the Use auto property refactoring
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 预览使用自动属性的重构
- en: When this option is selected, the pane on the right will display a preview of
    the change this will make to your code. Here it lists the lines it will remove
    in red and the line it adds in green.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择此选项时，右侧面板将显示此更改将如何影响你的代码的预览。这里列出了它将用红色删除的行和用绿色添加的行。
- en: 'Clicking **Use auto property** or pressing *Enter* on the keyboard will accept
    the suggestion and replace your code with the auto property version:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**使用自动属性**或在键盘上按*Enter*键将接受建议，并用自动属性版本替换你的代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Admittedly this is a simple refactoring, but there are a couple of things I
    want to stress about the refactoring process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个简单的重构，但我想要强调重构过程中的几个要点：
- en: Visual Studio took care of making the change and did so in an automated way
    that was free of potential typos or other mistakes a human might make.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio负责进行更改，并以自动化方式完成，这种方式避免了人类可能犯的潜在错误或拼写错误。
- en: If you didn’t know that you could move a full property to an auto property,
    this **Quick Action** helped you discover that. These **Quick Actions** can actually
    *teach* you a lot about the C# programming language as it continues to evolve
    and change every year.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不知道可以将整个属性移动到自动属性中，这个**快速操作**帮助你发现了这一点。实际上，这些**快速操作**可以*教会*你很多关于C#编程语言的知识，因为它每年都在不断发展和变化。
- en: With the mechanics of refactoring in Visual Studio out of the way, let’s explore
    some additional refactorings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio的重构机制处理完毕后，让我们探索一些额外的重构。
- en: Introducing locals
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入局部变量
- en: One of the problems the `CalculatePrice` method has is that there are a few
    expressions, such as `carryOn * 30M` and `bags * 40M`, that appear multiple times
    throughout the method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculatePrice`方法存在的问题之一是，有几个表达式，如`carryOn * 30M`和`bags * 40M`，在方法中多次出现。'
- en: These are small issues but can lead to maintainability problems. If the nature
    of the expressions changed, we would need to modify multiple places within our
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是小问题，但可能导致可维护性问题。如果表达式的性质发生了变化，我们就需要修改代码中的多个地方。
- en: In general, one of the reasons you may want to refactor code is if you find
    yourself modifying multiple places to make a single change on a regular basis.
    For example, if the pricing structure changed we should modify multiple lines
    of code to support the new pricing model. Each one of those lines we should modify
    is a place we might fail to make a change. Missing changes like this typically
    introduce bugs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能想要重构代码的一个原因是你发现自己经常需要修改多个地方以进行单一更改。例如，如果定价结构发生变化，我们应该修改多行代码以支持新的定价模型。我们应该修改的每一行都可能是我们可能未能进行更改的地方。这种遗漏的更改通常会导致错误。
- en: Even if we didn’t miss any code that needed to be modified, most developers
    would prefer to have to make a change in one place instead of multiple.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有错过任何需要修改的代码，大多数开发者也更愿意在一个地方而不是多个地方进行修改。
- en: The **Introduce local** refactoring can help with this by introducing a local
    variable containing the result of the expression.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**引入局部**重构可以通过引入包含表达式结果的局部变量来帮助你。'
- en: 'To use this refactoring, select the expression that is repeated as shown in
    *Figure 2**.3*, noting that Visual Studio helpfully highlights any places it is
    repeated:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此重构，选择如*图 2.3*所示的重复表达式：
- en: '![Figure 2.3 – Selecting a repeated expression in Visual Studio](img/B21324_02_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 在 Visual Studio 中选择重复的表达式](img/B21324_02_03.jpg)'
- en: Figure 2.3 – Selecting a repeated expression in Visual Studio
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 在 Visual Studio 中选择重复的表达式
- en: Next, use the **Quick Action** button by pressing *Ctrl* + *.* or clicking on
    the screwdriver icon.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过按 *Ctrl* + .* 或点击螺丝刀图标来使用**快速操作**按钮。
- en: A note on the Quick Actions icon
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于快速操作图标的说明
- en: The **Quick Action** button sometimes appears as a light bulb and sometimes
    appears as a screwdriver, depending on your code analysis rules and the exact
    issues a line is facing. They are effectively the same option, but the light bulb
    tells you a suggested refactoring is present while a screwdriver indicates a less
    critical refactoring option to consider.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速操作**按钮有时显示为灯泡，有时显示为螺丝刀，这取决于你的代码分析规则以及一行所面临的确切问题。它们实际上是相同的选项，但灯泡告诉你存在一个建议的重构，而螺丝刀则表示一个不太关键的考虑重构选项。'
- en: Once the context menu is open, expand the right arrow next to **Introduce local**
    by using the arrow keys to navigate the menu. This will let you view more detailed
    options.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上下文菜单打开，使用箭头键导航菜单，通过展开**引入局部**旁边的右箭头。这将让你查看更多详细选项。
- en: '![Figure 2.4 – Drilling into the specialized forms of the Introduce local refactoring](img/B21324_02_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 深入了解引入局部重构的特殊形式](img/B21324_02_04.jpg)'
- en: Figure 2.4 – Drilling into the specialized forms of the Introduce local refactoring
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 深入了解引入局部重构的特殊形式
- en: Here it gives you the ability to introduce a local variable just for the expression
    you selected or to do so **for all occurrences** of this expression. I generally
    recommend using the **for all occurrences**option, but it will depend on the context
    of what you’re trying to improve.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里它为你提供了仅为你所选的表达式引入局部变量的能力，或者为该表达式的**所有出现**这样做。我通常建议使用**所有出现**选项，但这将取决于你试图改进的上下文。
- en: 'Once you select the **Introduce local** option, Visual Studio will prompt you
    for a name for your variable (see *Figure 2**.5*):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择**引入局部**选项，Visual Studio 将提示你为变量命名（见*图 2.5*）：
- en: '![Figure 2.5 – Naming your new local variable](img/B21324_02_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 为你的新局部变量命名](img/B21324_02_05.jpg)'
- en: Figure 2.5 – Naming your new local variable
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 为你的新局部变量命名
- en: Type in the name you would like and then press *Enter* to make the box disappear.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你想要的名字，然后按 *Enter* 键使框消失。
- en: 'In my case, I called the variable `fee` and it replaced it in both lines as
    shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我将变量命名为 `fee` 并在两行中替换了它，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this is certainly cleaner for the carry-on baggage fee logic, there’s
    still a `bags * 40M` expression repeated in the checked baggage logic and a `total
    * HolidayFeePercent` expression that is also repeated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实使行李费用逻辑更清晰，但在托运行李逻辑中仍然有一个重复的 `bags * 40M` 表达式，以及一个重复的 `total * HolidayFeePercent`
    表达式。
- en: You can use the **Introduce local** refactoring to make complex lines more understandable
    by pulling some logic out of dense lines into their own smaller lines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**引入局部**重构通过将一些逻辑从密集的行中拉出来到它们自己的较小行，使复杂的行更容易理解。
- en: 'Applying the **Introduce local** refactoring throughout this method results
    in a longer method, but one that’s easier to understand:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个方法中应用**引入局部变量**的重构会导致方法更长，但更容易理解：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a programming instructor, I saw many students under the mistaken assumption
    that the shortest way to implement something was always the best.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名编程讲师，我看到了许多学生错误地认为实现某事的最短方式总是最好的。
- en: Instead, the best code tends to be the code that’s easier to maintain over time,
    less likely to break, and easier to think about as you go about development tasks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好的代码往往是那些随着时间的推移更容易维护、更不容易出错、在开发任务中更容易思考的代码。
- en: Less code is often easier to think about, but when code gets too concise or
    too complex it can be hard to maintain. Find a happy medium between brevity and
    readability, keeping in mind that many times, programmers skim code looking for
    a specific section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码越少往往越容易思考，但当代码过于简洁或过于复杂时，维护起来可能很困难。在简洁性和可读性之间找到一个平衡点，记住很多时候，程序员只是快速浏览代码以寻找特定的部分。
- en: Introducing constants
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入常量
- en: The `const` value that will never change during the program’s runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行期间永远不会改变的`const`值。
- en: However, **Introduce constant** is often used for a different purpose than **Introduce
    local**. While **Introduce local** tends to be used to reduce repetition or simplify
    complex lines of code, **Introduce constant** is often used to eliminate **magic
    numbers** or **magic strings** from code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**引入常量**通常用于与**引入局部变量**不同的目的。虽然**引入局部变量**倾向于用于减少重复或简化复杂的代码行，但**引入常量**通常用于从代码中消除**魔法数字**或**魔法字符串**。
- en: In programming, a magic number is a number that exists in your code without
    any explanation of what that number means or why it is there. This is bad because
    the person maintaining your code later doesn’t understand why that number was
    chosen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，魔法数字是在代码中存在但没有解释其含义或为什么存在的数字。这是不好的，因为后来维护你代码的人不明白为什么选择了这个数字。
- en: 'The `CalculatePrice` method has three magic numbers: `30M`, `40M`, and `50M`,
    representing the various baggage fee amounts.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculatePrice`方法有三个魔法数字：`30M`、`40M`和`50M`，代表各种行李费用金额。'
- en: 'Introducing a constant for these is the same as introducing a local. Just highlight
    the number and open the **Quick Actions** menu, then select **Introduce constant**
    and then **Introduce constant for all occurrences** in the sub-menu as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些引入一个常量与引入一个局部变量相同。只需突出显示数字并打开**快速操作**菜单，然后选择**引入常量**，然后在子菜单中选择**为所有出现引入常量**，如图所示：
- en: '![Figure 2.6 – Introducing a constant for all occurrences of the 40M decimal
    literal](img/B21324_02_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 为所有出现的 40M 十进制字面量引入一个常量](img/B21324_02_06.jpg)'
- en: Figure 2.6 – Introducing a constant for all occurrences of the 40M decimal literal
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 为所有出现的 40M 十进制字面量引入一个常量
- en: 'Doing this to the various magic numbers in our application and choosing appropriate
    names results in the following new constants at the top of the class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们应用程序中的各种魔法数字这样做，并选择合适的名称，结果在类的顶部得到以下新的常量：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Introducing these constants has the added benefit of putting our price rules
    in a centralized place, making them more discoverable by new developers joining
    the team.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这些常量还有一个额外的优点，就是把我们的价格规则集中在一个地方，使新加入团队的开发者更容易发现。
- en: 'This also makes our code a lot easier to read:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得我们的代码更容易阅读：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Programmers spend disproportionally more time *reading* code rather than *writing*
    code. Optimizing your code for maintainability is a key habit that will help your
    application resist technical debt as time goes by.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在阅读代码上花费的时间不成比例地多于编写代码。优化代码以保持可维护性是一个关键习惯，这将帮助你的应用程序随着时间的推移抵抗技术债务。
- en: Introducing parameters
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入参数
- en: One refactoring technique I wish I saw more people use is the **Introduce**
    **parameter** refactoring.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望看到更多人使用的重构技术之一是**引入** **参数**重构。
- en: This refactoring takes an expression or variable in a method and removes it
    from the method entirely, instead adding its value as a new parameter to the method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构将方法中的表达式或变量移除，并将其完全从方法中删除，而是将其值作为新的参数添加到方法中。
- en: 'For example, right now the `CalculatePrice` method has logic inside of it for
    determining which travel dates should be considered for holiday travel:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在`CalculatePrice`方法内部有逻辑来确定哪些旅行日期应被视为假日旅行：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is logic that could become more complex as more holidays are added and
    holidays from different countries are considered. As the code is written now,
    the additional complexity would need to go into this `if` statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加更多假期并考虑不同国家的假期时，这种逻辑可能会变得更加复杂。按照现在的代码编写方式，额外的复杂性需要放入这个`if`语句中。
- en: Instead, introducing a parameter for `isHoliday` gives the callers of this method
    the responsibility of telling whether the method is holiday travel or not. This
    ultimately allows us to leave this method to focus on pricing the customer’s baggage
    and to be aware of holidays but it is not responsible for determining what is
    and what isn’t a holiday.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，为`isHoliday`引入一个参数，让这个方法的调用者负责告诉这个方法是否是假日旅行。这最终使我们能够让这个方法专注于为客户定价行李，并意识到假期，但它不负责确定什么是假期，什么不是假期。
- en: 'Introducing a parameter can be done by selecting the variable or expression
    you wish to move to a parameter and then triggering the **Quick** **Actions**
    menu:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择你希望移动到参数中的变量或表达式，然后触发**快速** **操作**菜单，可以引入参数：
- en: '![Figure 2.7 – Introducing a parameter using the Quick Actions menu](img/B21324_02_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 使用快速操作菜单引入参数](img/B21324_02_07.jpg)'
- en: Figure 2.7 – Introducing a parameter using the Quick Actions menu
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 使用快速操作菜单引入参数
- en: There are multiple options to choose from when introducing a parameter. Choosing
    **and update call sites directly** is usually a good option – provided you review
    the code it generates.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入参数时，有多种选择。选择**直接更新调用点**通常是不错的选择——前提是你审查了它生成的代码。
- en: 'Once we introduce the parameter and name it appropriately, the holiday fee
    logic becomes much easier to read:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们引入参数并适当地命名它，假期费用逻辑就变得更容易阅读：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Introducing a parameter also changed the method signature line to add a Boolean
    `isHoliday` parameter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 引入参数还改变了方法签名行，添加了一个布尔`isHoliday`参数：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a result of this refactoring, any code that called the `CalculatePrice` method
    now calculates and passes a value for `isHoliday` to the method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这次重构，现在调用`CalculatePrice`方法的任何代码现在都会计算并传递一个`isHoliday`的值给该方法。
- en: I find that **Introduce parameter** is particularly helpful for letting a method
    focus on just a few key pieces of logic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现**引入参数**特别有助于让一个方法只关注几块关键逻辑。
- en: It can also be very helpful in places where you have very similar methods of
    doing similar things but only differing by a few key details. It can sometimes
    be possible to merge many different methods into a single method that takes in
    a few details as parameters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有很多类似的方法来做类似的事情，但只有几个关键细节不同的情况下，这也可以非常有帮助。有时，可以将许多不同的方法合并成一种方法，该方法接受一些细节作为参数。
- en: 'For example, the following code might perform logging for different actions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码可能对不同操作进行日志记录：
- en: Fee.cs
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Fee.cs
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These two methods both take in a numeric fee and write the charge name and charged
    fee to the console. In fact, the only way they differ is the charge name.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都接受一个数值费用，并将收费名称和收费金额写入控制台。实际上，它们唯一的区别就是收费名称。
- en: 'This code could be consolidated into a single method by introducing a parameter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入参数，可以将这段代码合并成一个单一的方法：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Never underestimate the value of making a method more generalized by having
    outside code provide additional details.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要低估通过让外部代码提供额外细节来使方法更加通用的价值。
- en: With the charge logic largely improved, let’s move on to the final method in
    the code that has several warnings associated with it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上改进了收费逻辑后，让我们继续到最后一个方法，这个方法有几个相关的警告。
- en: Removing unreachable and unused code
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除不可达和未使用的代码
- en: If you opened the beginning code from this chapter in Visual Studio, you would
    likely notice that `CalculatePriceFlat` and a few variables inside it appear in
    gray with a number of wavy underscore suggestions as shown in *Figure 2**.8*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开了本章的初始代码在Visual Studio中，你可能会注意到`CalculatePriceFlat`和其中的一些变量以灰色显示，并带有许多波浪下划线建议，如图*图2.8*所示。
- en: '![Figure 2.8 – The CalculatePriceFlat method with gray text for many lines
    of code](img/B21324_02_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 带灰色文本的多行代码的CalculatePriceFlat方法](img/B21324_02_08.jpg)'
- en: Figure 2.8 – The CalculatePriceFlat method with gray text for many lines of
    code
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 带灰色文本的多行代码的CalculatePriceFlat方法
- en: Visual Studio can sometimes detect when variables, parameters, and even methods
    are not being used. If it does so, Visual Studio usually renders these identifiers
    in more muted tones and often includes suggestions to investigate or remove these
    items.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio有时可以检测到变量、参数甚至方法没有被使用。如果它这样做，Visual Studio通常会以更暗淡的色调渲染这些标识符，并经常包括调查或删除这些项目的建议。
- en: In this case, nothing is ever calling the `CalculatePriceFlat` method, and nothing
    is referencing the `numBags` parameter. The `total` variable is declared and given
    a value but is never read from after that, and the final `return` line is unreachable
    given the return line above it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有任何东西调用`CalculatePriceFlat`方法，也没有任何东西引用`numBags`参数。`total`变量被声明并赋予了一个值，但从那以后再也没有被读取过，并且由于上面的返回行，最后的`return`语句是不可达的。
- en: Each one of these issues can be addressed with a *remove unused member*, *remove
    unused variable*, or *remove unreachable* *code* refactoring.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过*删除未使用成员*、*删除未使用变量*或*删除不可达代码*重构来解决。
- en: 'All these refactorings do what you’d expect: they remove the offending code.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些重构都做了你期望的事情：它们删除了有问题的代码。
- en: Since nothing is calling the method at all, the entire method can be removed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有任何东西调用该方法，整个方法都可以被删除。
- en: Removing unused parameters
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除未使用参数
- en: 'There’s another piece of code from earlier that can be removed as well: the
    `CalculatePrice` method has a `travelTime` parameter that is no longer being used
    after we introduced the `isHoliday` parameter.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一段早期的代码可以被删除：`CalculatePrice`方法有一个`travelTime`参数，在我们引入`isHoliday`参数之后就不再使用了。
- en: There is no *remove unused parameter* in Visual Studio at the time of writing,
    but you can remove it safely using some of the method-level refactorings we’ll
    discuss in the next chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Visual Studio中没有*删除未使用参数*的功能，但你可以使用我们将在下一章讨论的一些方法级别的重构安全地删除它。
- en: 'To perform this refactoring, select the `travelTime` parameter and then select
    **Change signature...** as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此重构，请选择`travelTime`参数，然后选择如图所示**更改签名…**：
- en: '![Figure 2.9 – Changing the signature of a method](img/B21324_02_09.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 修改方法签名](img/B21324_02_09.jpg)'
- en: Figure 2.9 – Changing the signature of a method
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 修改方法签名
- en: Clicking **Change signature…** will show the **Change** **Signature** dialog.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**更改签名…**将显示**更改签名**对话框。
- en: 'Select the `travelTime` parameter and click **Remove**. The parameter will
    appear crossed out in the dialog:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`travelTime`参数并点击**删除**。参数将在对话框中显示为被划掉：
- en: '![Figure 2.10 – The Change Signature dialog with travelTime removed](img/B21324_02_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 移除travelTime后的更改签名对话框](img/B21324_02_10.jpg)'
- en: Figure 2.10 – The Change Signature dialog with travelTime removed
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 移除travelTime后的更改签名对话框
- en: Click **OK** and the dialog will close and the parameter will be removed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**，对话框将关闭，参数将被删除。
- en: Any code that was referencing your method will also have their signatures updated
    to not pass anything for the `travelTime` parameter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何引用你的方法的代码也将更新它们的签名，不再为`travelTime`参数传递任何内容。
- en: Avoiding pitfalls when removing code
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除代码时的陷阱
- en: 'One cautionary note on removing code: be particularly careful about removing
    `public` members from code. Sometimes Visual Studio is not aware of all the places
    using code. This is particularly true for serialization/deserialization logic,
    properties that exist for data binding, and members that are accessed using reflection.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于删除代码的一个注意事项：在删除代码时，特别小心删除`public`成员。有时Visual Studio没有意识到所有使用代码的地方。这尤其适用于序列化/反序列化逻辑、用于数据绑定的属性以及使用反射访问的成员。
- en: Additionally, if your code is being deployed as a **NuGet package** or otherwise
    being shared in other projects, it is possible that code outside of your solution
    may depend on a method or parameter, and your change could cause their code to
    no longer compile.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的代码作为**NuGet包**或其他方式在其他项目中共享，可能存在代码之外的部分依赖于某个方法或参数，你的更改可能导致它们的代码无法编译。
- en: Reminder on testing
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 测试提醒
- en: It is *your* responsibility to test any refactorings you make and ensure they
    do not bring about unintended changes in program behavior.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你做出的任何重构并确保它们不会导致程序行为出现意外的变化，这是你的责任。
- en: That may sound scary, but don’t let these edge cases stop you from removing
    dead code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很可怕，但不要让这些边缘情况阻止你删除死代码。
- en: I’ve known a number of developers hesitant to remove code in case they need
    it later. Instead, these developers will either keep the code there untouched
    or comment the entire block of code out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道许多开发者犹豫不决，担心他们以后可能需要代码。相反，这些开发者要么保留代码不变，要么将整个代码块注释掉。
- en: The problem with commenting out dead code is that it increases the amount of
    distracting and unhelpful comments in a file. This reduces the amount of importance
    developers place on the comments that are present and also increases the amount
    of scrolling the developers must do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉死代码的问题在于，它增加了文件中分散注意力且无用的注释的数量。这减少了开发者对现有注释重要性的重视，并增加了开发者必须滚动的次数。
- en: Delete dead code. Your code should be in source control anyway, so if you really
    need to find the code later, you can look at the history to recover it – assuming,
    of course, you checked the code into source control to begin with.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 删除死代码。你的代码应该已经在源代码控制中，所以如果你真的需要稍后找到代码，你可以查看历史记录来恢复它——当然，前提是你一开始就将其提交到源代码控制。
- en: Extracting methods
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取方法
- en: Our code is now looking fairly clean, but the `CalculatePrice` method has a
    lot of logic in it for the checked baggage price calculation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码看起来相当整洁，但`CalculatePrice`方法中包含了很多用于行李托运价格计算的逻辑。
- en: This logic is complex enough for us to extract a method just for this logic
    and call that method from our existing code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段逻辑足够复杂，我们可以只为这段逻辑提取一个方法，并从现有代码中调用该方法。
- en: To do this, select the lines of code that represent the method you want to extract.
    Be mindful of the various `{}` instances that you select, as your selection must
    make sense as a related block of code to Visual Studio. See the following screenshot.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，选择代表你想要提取的方法的代码行。请注意你选择的各个`{}`实例，因为你的选择必须作为与 Visual Studio 相关的代码块有意义。请参阅以下截图。
- en: '![Figure 2.11 – Extracting a method from a block of code](img/B21324_02_11.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 从代码块中提取方法](img/B21324_02_11.jpg)'
- en: Figure 2.11 – Extracting a method from a block of code
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 从代码块中提取方法
- en: Once your block of code is selected, open the **Quick Actions** menu, choose
    **Extract Method**, and then name the method in the prompt before pressing *Enter*
    to confirm your name.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了代码块，打开**快速操作**菜单，选择**提取方法**，然后在提示中命名方法，按下 *Enter* 键确认您的名称。
- en: '![Figure 2.12 – Naming the extracted method](img/B21324_02_12.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 命名提取的方法](img/B21324_02_12.jpg)'
- en: Figure 2.12 – Naming the extracted method
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 命名提取的方法
- en: 'This will result in a new method being added to your code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的代码中添加一个新的方法：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that Visual Studio will make the method `private` by default and will mark
    the method as `static` if it does not access instance members on the class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Visual Studio 默认会将方法设置为`private`，如果方法不访问类上的实例成员，它还会将方法标记为`static`。
- en: I generally prefer `private` methods, but your preferences on `static` may vary
    depending on what method you’re working with and whether it makes sense for the
    method to ultimately be `static`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常更喜欢`private`方法，但你对`static`的偏好可能会根据你正在处理的方法以及该方法最终是否应该为`static`而有所不同。
- en: 'The extract method refactoring also removes the code from the original method
    and replaces it with a call to the new method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提取方法重构还会从原始方法中删除代码，并用对新方法的调用替换它：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This results in a much more concise and readable **CalculatePrice method** and
    makes it easier to think about everything the method is doing. This reduced complexity
    greatly improves the long-term quality of the method by helping developers fully
    understand the method and avoids costly mistakes that can occur when maintaining
    complex blocks of code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得**CalculatePrice 方法**更加简洁易读，并使得思考方法所做的一切变得更加容易。这种降低的复杂性大大提高了方法的长期质量，因为它帮助开发者完全理解该方法，并避免了在维护复杂代码块时可能出现的昂贵错误。
- en: Refactoring manually
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动重构
- en: Up until this point, we’ve performed a number of refactoring operations supported
    by Visual Studio. These have been fairly safe given the quality of the tools we’ve
    used, but there are some things the built-in tools just won’t do.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经执行了 Visual Studio 支持的许多重构操作。鉴于我们使用的工具质量，这些操作相当安全，但内置工具有一些事情是做不到的。
- en: Visual Studio is powerful, but it can’t think about code like a human can (despite
    the exciting new AI features we’ll talk about in [*Chapter 11*](B21324_11.xhtml#_idTextAnchor236),
    *AI-Assisted Refactoring with GitHub* *Copilot Chat*).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio功能强大，但它不能像人类一样思考代码（尽管我们将在[*第11章*](B21324_11.xhtml#_idTextAnchor236)
    *使用GitHub的AI辅助重构与Copilot Chat*中讨论的令人兴奋的新AI功能）。
- en: Sometimes there will be opportunities to improve the code that no built-in refactoring
    can perform for you. At those points, you’ll have to make the changes manually.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会有机会改进代码，而内置的重构工具无法为你完成。在这些点上，你必须手动进行更改。
- en: The `ApplyCheckedBagFee` method we extracted earlier is a good method, but a
    few things could be improved.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提取的`ApplyCheckedBagFee`方法是一个好的方法，但还有一些事情可以改进。
- en: First, the method takes in a total, increases it by a fee, and then returns
    that new total. It’d be easier for others to understand the method if the method
    returned the fee instead of the adjusted total.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该方法接收一个总数，将其增加费用，然后返回这个新总数。如果方法返回费用而不是调整后的总数，其他人更容易理解该方法。
- en: Secondly, the method is performing the same `Console.WriteLine` operation twice.
    Additionally, all other `WriteLine` statements in the class are in the `CalculatePrice`
    method, making the user interface slightly hard to fully trace.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，该方法执行了两次相同的`Console.WriteLine`操作。此外，类中所有其他的`WriteLine`语句都在`CalculatePrice`方法中，这使得用户界面稍微难以完全追踪。
- en: 'Let’s modify the method so that it returns only the fee, doesn’t require the
    `total` parameter, and doesn’t log anything:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改该方法，使其只返回费用，不需要`total`参数，并且不记录任何内容：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we’ll need to update the code that calls this method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新调用此方法的代码：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the result is stored in a `bagFee` variable, `total` is no longer
    passed to `ApplyCheckedBagFee`, and `Console.WriteLine` now appears here in this
    method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果存储在`bagFee`变量中，`total`不再传递给`ApplyCheckedBagFee`，并且`Console.WriteLine`现在出现在这个方法中。
- en: Additionally, the `ApplyCheckedBagFee` name might not apply anymore since the
    method no longer actually applies the fee, but rather calculates it. In this case,
    applying the *rename method* refactoring would help the final code have a more
    appropriate name.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ApplyCheckedBagFee`的名称可能不再适用，因为该方法不再实际应用费用，而是计算它。在这种情况下，应用**重命名方法**重构将有助于最终代码有一个更合适的名称。
- en: Testing refactored code
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试重构后的代码
- en: As I mentioned earlier, it is *your responsibility* to ensure that your refactoring
    efforts have not altered how the system fundamentally behaves.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，确保你的重构工作没有改变系统的基本行为，这是**你的责任**。
- en: In our case, this means that `BaggageCalculator` should still calculate the
    same prices it did before for any valid set of inputs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这意味着`BaggageCalculator`应该仍然为任何有效的输入集计算与之前相同的价格。
- en: One of the many tools we have at our disposal for determining whether code still
    meets our needs is running **unit tests**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来确定代码是否仍然满足我们需求的许多工具之一是运行**单元测试**。
- en: We’ll talk more about unit tests in [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133),
    *Unit Testing*, but for now, know that unit tests are code that verifies that
    other code is working as expected.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B21324_06.xhtml#_idTextAnchor133) *单元测试*中更多地讨论单元测试，但现在，要知道单元测试是验证其他代码按预期工作的代码。
- en: '`BaggageCalculator` has five tests that can be run by clicking on the **Test**
    menu and then choosing **Run** **All Tests**.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaggageCalculator`有五个可以通过点击**测试**菜单然后选择**运行所有测试**来运行的测试。'
- en: 'The **Test Explorer** window should show all tests as passing with green check
    marks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试资源管理器**窗口应显示所有测试都通过，带有绿色的勾选标记：'
- en: '![Figure 2.13 – Five passing tests in Test Explorer](img/B21324_02_13.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 测试资源管理器中的五个通过测试](img/B21324_02_13.jpg)'
- en: Figure 2.13 – Five passing tests in Test Explorer
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 测试资源管理器中的五个通过测试
- en: If a test is now failing and didn’t fail before, this is a good thing, since
    it means the test found an issue you caused in the code’s behavior. Investigate
    the failing test and then resolve the issue before continuing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试现在失败了，而之前没有失败，这是一个好事，因为这意味着测试发现了你在代码行为中引起的问题。调查失败的测试，然后在继续之前解决问题。
- en: We’ll explore testing in much more detail in *Part 2* of this book, but as it
    stands, it appears that our refactorings have been successful.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的**第2部分**中更详细地探讨测试，但就目前而言，看起来我们的重构是成功的。
- en: Final code
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    repository, inside the `Chapter02/Ch2FinalCode` folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终重构代码可在 [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    仓库的 `Chapter02/Ch2FinalCode` 文件夹中找到。
- en: The code we produced in this chapter is simple, readable, and maintainable.
    Certainly, there are things that could still be improved, but the code is less
    likely to cause issues as it grows in complexity in the future.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们产生的代码简单、易读、易于维护。当然，还有一些可以改进的地方，但随着代码复杂性的增加，未来出现问题的可能性较小。
- en: Refactoring in other editors
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他编辑器中的重构
- en: Before we end the chapter, let’s talk about refactoring in editors other than
    Visual Studio.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们来谈谈除了 Visual Studio 之外的其他编辑器中的重构。
- en: 'This book primarily focuses on refactoring in Visual Studio because that’s
    the current primary development environment for .NET developers. However, there
    are a few other editors and extensions that are frequently used for .NET development
    and offer refactoring support:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本书主要关注 Visual Studio 中的重构，因为它是当前 .NET 开发者的主要开发环境。然而，还有一些其他编辑器和扩展经常用于 .NET 开发，并提供重构支持：
- en: '**Visual** **Studio Code**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual** **Studio Code**'
- en: '**JetBrains Rider**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains Rider**'
- en: '**JetBrains ReSharper** (Visual Studio Extension)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains ReSharper** (Visual Studio 扩展)'
- en: These tools will not be featured in examples throughout the remainder of the
    book since Visual Studio is the primary editing experience. However, most of what
    I’ll show you in the remainder of the book is also possible using these tools.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Visual Studio 是主要的编辑体验，这些工具将不会在本书余下的示例中展示。然而，本书余下部分展示的大部分内容也可以使用这些工具实现。
- en: Refactoring in Visual Studio Code with the C# Dev Kit
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C# 开发工具包在 VS Code 中进行重构
- en: '**Visual Studio Code** (**VS Code**) is rapidly becoming a highly capable editing
    environment for .NET projects with its C# extension.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code** (**VS Code**) 通过其 C# 扩展，正迅速成为 .NET 项目的强大编辑环境。'
- en: Where VS Code really comes into its own is with the newer **C# Dev Kit**, which
    gives an editing experience almost identical to Visual Studio, including the solution
    explorer. The C# Dev Kit integrates with the other C# extensions to provide code
    suggestions and refactoring **Quick Actions** with the same style of light bulb
    icons you see in Visual Studio.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 在使用较新的 **C# 开发工具包** 时真正发挥其优势，它提供了几乎与 Visual Studio 相同的编辑体验，包括解决方案资源管理器。C#
    开发工具包与其他 C# 扩展集成，提供与 Visual Studio 中相同的风格的光泡图标，以提供代码建议和重构 **快速操作**。
- en: '![Figure 2.14 – Refactoring with the C# Dev Kit in VS Code](img/B21324_02_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 在 VS Code 中使用 C# 开发工具包进行重构](img/B21324_02_14.jpg)'
- en: Figure 2.14 – Refactoring with the C# Dev Kit in VS Code
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 在 VS Code 中使用 C# 开发工具包进行重构
- en: VS Code won’t give you the full set of refactoring options Visual Studio currently
    does, but it is cross-platform and will work on Mac and Linux.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 不会提供 Visual Studio 当前所拥有的全部重构选项，但它支持跨平台，可以在 Mac 和 Linux 上运行。
- en: Licensing note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证说明
- en: VS Code is free, but the C# Dev Kit extension requires a paid Visual Studio
    license key.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 是免费的，但 C# 开发工具包扩展需要付费的 Visual Studio 许可证密钥。
- en: I expect we’ll see VS Code featured much more prominently in .NET development
    with the improvements from the C# Dev Kit and VS Code’s cross-platform capabilities,
    along with its ability to run in-browser to some extent through **GitHub Codespaces**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计，随着 C# 开发工具包的改进以及 VS Code 的跨平台能力，以及它通过 **GitHub Codespaces** 在一定程度上在浏览器中运行的能力，VS
    Code 将在 .NET 开发中更加突出地展示。
- en: Refactoring in JetBrains Rider
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JetBrains Rider 中的重构
- en: JetBrains Rider is a separate editor developed on the same set of editing software
    used by the popular **IntelliJ** Java editor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains Rider 是一个独立的编辑器，它使用的是与流行的 **IntelliJ** Java 编辑器相同的编辑软件集。
- en: Rider works with most .NET projects and has a fantastic set of refactoring capabilities
    built in. These capabilities will often be similar to those mentioned in this
    book, but the exact naming and user experience will be slightly different.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Rider 与大多数 .NET 项目兼容，并内置了一套出色的重构功能。这些功能通常与本书中提到的类似，但具体的命名和用户体验会有所不同。
- en: '![Figure 2.15 – Refactoring in JetBrains Rider](img/B21324_02_15.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – JetBrains Rider 中的重构](img/B21324_02_15.jpg)'
- en: Figure 2.15 – Refactoring in JetBrains Rider
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – JetBrains Rider 中的重构
- en: Like VS Code, one major advantage Rider has over Visual Studio is that it is
    fully cross-platform and can run on macOS or Linux.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与VS Code一样，Rider相比Visual Studio的一个主要优势是它是完全跨平台的，可以在macOS或Linux上运行。
- en: Refactoring in Visual Studio with ReSharper
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ReSharper在Visual Studio中进行重构
- en: If you love working with Visual Studio but want the same rich set of refactorings
    that Rider offers, JetBrains also offers a Visual Studio extension called **ReSharper**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用Visual Studio，但又想获得Rider提供的同样丰富的重构功能，JetBrains还提供了一款名为**ReSharper**的Visual
    Studio扩展。
- en: ReSharper replaces many Visual Studio features with enhanced versions, including
    Visual Studio’s code analysis and refactoring tools.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ReSharper用增强版本替换了Visual Studio的许多功能，包括Visual Studio的代码分析和重构工具。
- en: '![Figure 2.16 – Refactoring with ReSharper in Visual Studio](img/B21324_02_16.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – 在Visual Studio中使用ReSharper进行重构](img/B21324_02_16.jpg)'
- en: Figure 2.16 – Refactoring with ReSharper in Visual Studio
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 在Visual Studio中使用ReSharper进行重构
- en: Nowadays, Visual Studio tends to have most of the refactoring capabilities ReSharper
    and Rider offer, but the capabilities of ReSharper and Rider can sometimes be
    a bit more advanced.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Visual Studio往往拥有ReSharper和Rider提供的绝大多数重构功能，但ReSharper和Rider的功能有时可能更先进一些。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we explored refactoring by taking a class with a bit
    of complexity and applied targeted refactorings to make it easier to read, maintain,
    and expand.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过选择一个稍微有些复杂性的类，并应用有针对性的重构来使其更容易阅读、维护和扩展，来探讨了重构。
- en: We went from a modestly complex class to a relatively simple one by following
    a set of repeatable actions that transformed the code from one form to another
    without changing its overall behavior or result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过遵循一系列可重复的动作，将代码从一种形式转换为另一种形式，而不改变其整体行为或结果，从相对复杂的类转变为相对简单的类。
- en: Although Visual Studio supports very capable refactoring tools, it is up to
    you as an experienced developer to know when you might want to apply each individual
    refactoring, based on the current level of complexity of your code and the code
    smells you’re observing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Visual Studio支持非常强大的重构工具，但作为经验丰富的开发者，你需要根据你代码的当前复杂程度和观察到的代码异味来决定何时应用每个单独的重构。
- en: Over the next three chapters, we’ll explore the built-in refactorings in more
    depth by exploring refactorings related to methods, classes, and individual lines
    of code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将通过探索与方法、类和单个代码行相关的重构来更深入地探讨内置的重构。
- en: Questions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are some ways of triggering Quick Actions for a block of code?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些方法可以触发代码块中的快速操作？
- en: Does Visual Studio ever indicate that refactorings are possible or recommended?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio是否曾表明可以进行或推荐重构？
- en: How can you know what a Quick Action will do before performing it?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行之前，你如何知道快速操作会做什么？
- en: Are Visual Studio Quick Actions the only way to refactor code?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio快速操作是否是重构代码的唯一方式？
- en: Further reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about refactoring in Visual Studio and other
    environments at these URLs:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址找到有关Visual Studio和其他环境中重构的更多信息：
- en: '*Quick Actions* *Overview*: [https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions](https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions
    )'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速操作* 概述：[https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions](https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions)'
- en: '*JetBrains Rider vs Visual Studio (with and without* *ReSharper)*: [https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/](https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JetBrains Rider与Visual Studio（带和不带* *ReSharper* *）比较*：[https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/](https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/)'
- en: '*Announcing C# Dev Kit for Visual Studio* *Code*: [https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/](https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*宣布Visual Studio Code的C#开发工具包*：[https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/](https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/)'
