<html><head></head><body>
        

                            
                    <h1 class="header-title">Acting with Commands</h1>
                
            
            
                
<p>In the previous chapter, we went through the implementation process for a simple domain model. This model has one entity, and several value objects and domain services. The model represents just one area of our system, and we deliberately kept everything else out of scope. We discussed how the domain model project needs to be isolated from anything else, and how domain services can be part of the model although their implementation can be done in the application layer. Now, we are going to learn about putting our domain model in action. Hitherto, we have not been referencing the domain model from anywhere, which makes it rather useless. To start using the model in our application, we need to be able to call the model. In addition, we need to be able to persist all changes that happen in the model, so we do not lose the system state.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Application layer—the outer edge of the onion architecture</li>
<li>Calling the domain model from the web API</li>
<li>Persisting the domain model changes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>In addition to the technical requirements from <a href="034423e8-8080-4073-bd08-b98a129384a4.xhtml" target="_blank">Chapter 5</a>, <em>Implementing the Model</em>, you need to install Docker, because we will be using containers to run necessary infrastructure components, such as databases. Docker is supported on all popular platforms, including Windows, macOS, and Linux. Please refer to the Docker installation documentation (<a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>) if you need to know more about how to install it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Outside the domain model</h1>
                
            
            
                
<p>We strive to keep our domain model intact from anything that is related to infrastructure, persistence, execution, and communication. This makes the domain model pure and keeps it focused on the business. However, we still need to create the whole system around it, keeping the domain model as the system core.</p>
<p>The whole world of runtime surrounds our domain model, and in this section, we are going to dissect all necessary components that are required to build a proper system and look at how these components need to be bound together, with each other and with the domain model.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exposing the web API</h1>
                
            
            
                
<p>Our system needs to have some visibility to users, and therefore, at some point, we will need to build a user interface. This topic is covered as we move on further, but right now we need to be able to expose our application in a way that the future UI can be built on top of it. We expect our system to have more than one UI potentially. Think about a <strong>single-page web application</strong> (<strong>SPA</strong>) and a mobile app. As a backend for both types of frontends, we need to build a web API. I would avoid the term REST API since it is much more than a simple web API and we aren't going to explore this topic in depth. Instead, we will concentrate on making some calls to our domain model via HTTP, to do something useful.</p>
<p>Let's start by creating an ASP.NET Web API controller, where we will put handlers for some of the HTTP endpoints. To do this, we need to add a class to our <kbd>Marketplace</kbd> project, because right now we will not be working inside the domain model, but outside it.</p>
<p>Before we add a controller, let's create a project folder called <kbd>Api</kbd>, to put all controllers and related services in one place. We will add different types of components to the application project later on, so it is better to keep things tidy from the beginning. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Public API contracts</h1>
                
            
            
                
<p>To serve HTTP requests, we need more than just a controller. The controller needs to accept strongly typed requests, and the collection of those requests will be our public API and the models for those requests will be our contracts. Let's prepare a place where we'll put these models and create a folder called <kbd>Contracts</kbd>, in the application project.</p>
<p class="mce-root"/>
<p>Contracts are <strong>data-transfer objects</strong> (<strong>DTOs</strong>) and <strong>plain-old</strong> <strong>C# objects</strong> (<strong>POCOs</strong>). It means that they have no logic, they only contain primitive types and do not require any tricks to be serialized and deserialized. Practically, you can add complex types to your DTOs just because some complex types are used in many contracts. An example of such a type could be the <kbd>Address</kbd> type.</p>
<p>Imagine we have the following contract class:</p>
<pre>public class UpdateCustomerAddressDetails<br/>{<br/>    public string BillingStreet { get; set; }<br/>    public string BillingCity { get; set; }<br/>    public string BillingPostalCode { get; set; }<br/>    public string BillingCountry { get; set; }<br/>    public string DeliveryStreet { get; set; }<br/>    public string DeliveryCity { get; set; }<br/>    public string DeliveryPostalCode { get; set; }<br/>    public string DeliveryCountry { get; set; }<br/>}</pre>
<p>It is very convenient to use the complex type instead of listing all properties for two addresses separately. After we add a new type called <kbd>Address</kbd>, our contract will be much more compact:</p>
<pre>public class Address<br/>{<br/>    public string Street { get; set; }<br/>    public string City { get; set; }<br/>    public string PostalCode { get; set; }<br/>    public string Country { get; set; }<br/>}<br/><br/>public class UpdateCustomerAddressDetails<br/>{<br/>    public Address BillingAddress { get; set; }<br/>    public Address DeliveryAddress { get; set; }<br/>}</pre>
<p>Be aware that complex types add compatibility issues since when you change the type, all contracts that use it will also change and this change will be implicit. Since you have no internal consumers of this contract, you will not be able to see whether the clients that use this contract will be affected. Such information can only be obtained by tests.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Speaking about changes, remember that everything you publish outside of your development machine is considered public. The public API is something that anyone who has appropriate permissions can use. Effectively, this means that you are not in control of who is using your API anymore. Therefore, any change in the published API can potentially break other parts of the system or other systems. Changes in public contracts need to be crafted with care since there are both non-breaking changes and breaking changes.</p>
<p>Some changes in POCO types are considered non-breaking, such as the following:</p>
<ul>
<li>Changing property type so any value of the type that was used before can be serialized to the new type. For example, we can change a property from being an integer to string, and it will be compatible.</li>
<li>Adding a new property is also considered a non-breaking change. This is because when we try to deserialize an XML or JSON object that does not have this new property because the sender hasn't updated their contracts yet, most popular serializers will accept it and will use a default value if the value is not supplied.</li>
</ul>
<p>Our software evolves, and of course, it is not always possible to make non-breaking changes. This means that we should be prepared to make breaking changes. We already discussed how the public API is something that is shared by default as soon as it is made public. Therefore, we need to ensure that when we make a breaking change, everyone who is using the old API will not get exceptions and will be able to work as before, at least for some time. This is done by <strong>API versioning</strong>. You probably have encountered different API versions for popular services such as GitHub or Twitter. For example, while I am writing this, the Twitter API documentation tells me to use this call to get the timeline of the tweet: <kbd>GET https://api.twitter.com/1.1/statuses/home_timeline.json</kbd>. As you can see, they have <kbd>1.1</kbd> as part of the URI, and it is their current stable API version. We could assume that they also have other versions and some of those older versions might still be operational and in use. So, in our API, we will also use versioned contracts although we don't expect many changes in the beginning.</p>
<p>We already know what operations we can do with our domain, so we can add some contracts to call these operations from the outside world. Let's create a file where we put our first contracts. We already have the <kbd>Contracts</kbd> folder, so we can create a new C# class file called <kbd>ClassifiedAds.cs</kbd> in this folder. After the file is in place, we can add our first contract there:</p>
<pre>using System;<br/><br/>namespace Marketplace.Contracts<br/>{<br/>    public static class ClassifiedAds<br/>    {<br/>        public static class V1<br/>        {<br/>            public class Create<br/>            {<br/>                public Guid Id { get; set; }<br/>                public Guid OwnerId { get; set; }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Here, we use nested static classes, <kbd>ClassifiedAds</kbd> and <kbd>V1</kbd>, as a replacement for namespaces, so we can have more versions in one file when necessary. This method allows us to use static members import to keep code more concise.</p>
<p>What we have here is a <em>command</em>. I first mentioned <em>commands</em> in <a href="948b7834-c47c-4321-a91c-2ba58068c52e.xhtml" target="_blank">Chapter 1</a>, <em>Why Domain-Driven Design?</em>, when we discussed CQRS. Commands allow users and other systems to execute actions in our domain model. When a command is successfully processed, the domain model state changes and new domain events are emitted. Now, when we have one command implemented in code, we need to accept this command coming from the outside world, and we'll use an HTTP endpoint for this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP endpoints</h1>
                
            
            
                
<p>Since the most obvious communication method for APIs nowadays is using synchronous HTTP calls, we will start with this. We will be using the ASP.NET Web API. Therefore, we need to add a controller that will accept our commands. Let's add a file called <kbd>ClassifiedAdsCommandsApi.cs</kbd> to the <kbd>Api</kbd> folder of our executable project, make the class inherit from <kbd>Controller</kbd>, and add one <kbd>Post</kbd> method to handle the command that we added in the previous section:</p>
<pre>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Marketplace.Api<br/>{<br/>    [Route("/ad")]<br/>    public class ClassifiedAdsCommandsApi : Controller<br/>    {<br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; Post(<br/>            Contracts.ClassifiedAds.V1.Create request)<br/>        {<br/>            // handle the request here<br/><br/>            return Ok();<br/>        }<br/>    }<br/>}</pre>
<p>We are not doing anything there yet. Instead, we are creating a web API that will accept commands from the outside world. We will add code that handles these commands later. Remember, this is our adapter for the HTTP infrastructure, which finds its place in the outermost layer of the onion architecture. That's we call this layer<strong> the edge</strong> because there is nothing outside of it, which we can consider a part of our app. The application can have multiple ways to communicate with the outside world, so if we added some other edge, such as messaging, we would expect for this new communication adapter to process the same commands.</p>
<p>Now, we need to add more code to the application startup to make the web API work. There are a few things we need to do to the <kbd>Program</kbd> class:</p>
<p class="mce-root"/>
<ol>
<li style="list-style-type: none">
<ul>
<li>Build the configuration.</li>
<li>Configure the web host.</li>
<li>Execute the web host.</li>
</ul>
</li>
</ol>
<p>To do these operations, we need the <kbd>Program</kbd> class to look like this:</p>
<pre>using System.IO;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using static System.Environment;<br/>using static System.Reflection.Assembly;<br/><br/>namespace Marketplace<br/>{<br/>    public static class Program<br/>    {<br/>        static Program() =&gt; <br/>            CurrentDirectory = Path.GetDirectoryName(GetEntryAssembly().Location);<br/><br/>        public static void Main(string[] args)<br/>        {<br/>            var configuration = BuildConfiguration(args);<br/><br/>            ConfigureWebHost(configuration).Build().Run();<br/>        }<br/><br/>        private static IConfiguration BuildConfiguration(string[] args)<br/>            =&gt; new ConfigurationBuilder()<br/>                .SetBasePath(CurrentDirectory)<br/>                .Build();<br/><br/>        private static IWebHostBuilder ConfigureWebHost(<br/>            IConfiguration configuration)<br/>            =&gt; new WebHostBuilder()<br/>                .UseStartup&lt;Startup&gt;()<br/>                .UseConfiguration(configuration)<br/>                .ConfigureServices(services =&gt; <br/>                    services.AddSingleton(configuration))<br/>                .UseContentRoot(CurrentDirectory)<br/>                .UseKestrel();<br/>    }<br/>}</pre>
<p>There is not much going on here. We ensure that our current directory is where the executable is located because this is where we also can find the configuration file. We then read the configuration, and from the configuration, we create the web host and start it. Right now, we have no configuration file and therefore no configuration, but we will be adding some later.</p>
<p>Now, we are using the <kbd>Startup</kbd> class to configure services, and it needs some attention as well. In the <kbd>Startup</kbd> class, we need to configure the web API so it can use our controller. In addition, we need an easy way to interact with the API without having any user interface yet. One nice and easy way is to use Swagger (<a href="https://swagger.io/">https://swagger.io/</a>) integration with the Web API. Before we can start using it, we need to add a Swagger Web API integration NuGet package, <kbd>Swashbuckle.AspNetCore</kbd>. With the new <kbd>.csproj</kbd> file format, the easiest way to do add the integration is probably by adding the package reference directly to the project file. Here, you can see the new content for the <kbd>Marketplace.csproj</kbd> file, and the changes are highlighted:</p>
<pre>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;<br/>  &lt;PropertyGroup&gt;<br/>    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;<br/>  &lt;/PropertyGroup&gt;<br/>  &lt;ItemGroup&gt;<br/>    &lt;PackageReference Include="Microsoft.AspNetCore.App" /&gt;<br/>    <strong>&lt;PackageReference Include="Swashbuckle.AspNetCore" Version="4.0.1" /&gt;</strong><br/>  &lt;/ItemGroup&gt;<br/>  &lt;ItemGroup&gt;<br/>    &lt;ProjectReference Include="..\Marketplace.Domain\Marketplace.Domain.csproj" /&gt;<br/>  &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;</pre>
<p>The <kbd>Swashbuckle.AspNetCore</kbd> package might have a different version at the moment you are reading this book. Use the latest available version.</p>
<p>When you save the project file, your IDE will install the package and add the reference to your project.</p>
<p>Now, we can change the <kbd>Startup</kbd> class, so it registers web API internals, our controller, and all necessary Swagger generation. Also, we add an embedded version of the Swagger UI so we can test our API directly from the browser, without any additional software:</p>
<pre>using Microsoft.AspNetCore.Builder;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using Swashbuckle.AspNetCore.Swagger;<br/>using static System.Environment;<br/>// ReSharper disable UnusedMember.Global<br/><br/>namespace Marketplace<br/>{<br/>    public class Startup<br/>    {<br/>        public Startup(IHostingEnvironment environment, <br/>            IConfiguration configuration)<br/>        {<br/>            Environment = environment;<br/>            Configuration = configuration;<br/>        }<br/><br/>        private IConfiguration Configuration { get; }<br/>        private IHostingEnvironment Environment { get; }<br/><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            services.AddMvc();<br/>            services.AddSwaggerGen(c =&gt;<br/>                c.SwaggerDoc("v1",<br/>                    new Info<br/>                    {<br/>                        Title = "ClassifiedAds",<br/>                        Version = "v1"<br/>                    }));<br/>        }<br/><br/>        public void Configure(IApplicationBuilder app, <br/>            IHostingEnvironment env)<br/>        {<br/>            if (env.IsDevelopment())<br/>            {<br/>                app.UseDeveloperExceptionPage();<br/>            }<br/><br/>            app.UseMvcWithDefaultRoute();<br/>            app.UseSwagger();<br/>            app.UseSwaggerUI(c =&gt;<br/>                c.SwaggerEndpoint(<br/>                    "/swagger/v1/swagger.json", <br/>                    "ClassifiedAds v1"));<br/>        }<br/>    }<br/>}</pre>
<p>With everything in place now, we are ready to start the application for the first time. After pressing <em>F5</em>, you should see the following at the console:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3323e3c0-cb60-4cda-8bb5-71846121e722.png"/></p>
<p>The application finally runs</p>
<p>Now, let's open the Swagger UI by going to <kbd>http://localhost:5000/swagger</kbd> in the browser. We should see one operation (POST), and when we expand it, the following should appear:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0cb25b4e-48ce-4930-9a4d-8d82bcfcd8ff.png" style="width:54.75em;height:42.17em;"/></p>
<p>Swagger user interface for testing the API</p>
<p class="mce-root">You can click on the Try it out button and send some requests to the API, but it won't do anything because we always return the <kbd>200 OK</kbd> response.</p>
<p>We completed all the necessary steps to expose a primitive web API endpoint, and have the bootstrap code to support it. We also created one API contract that represents the command to create a classified ad. It is time to make this command work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Application layer</h1>
                
            
            
                
<p>The edge—in our case, it is a simple web API—accepts requests from the outside world. The main job for our edge component is to accept some request, sent as a JSON document, XML document, message via RabbitMQ, or any other communication channel and serialization type; convert it to a command; and then ensure this command gets handled.</p>
<p>The edge can, of course, work directly with the domain model, but this would mean we accept the fact that we will always be working with one edge type only, with one communication protocol. Also, edge components are usually heavily dependent on the communication infrastructure—while this is fine for integration tests, creating unit tests for such components might be challenging.</p>
<p>To isolate the communication infrastructure from the actual request handling, we can introduce the application layer. In this layer, we need a component that will accept commands from the edge and use our domain model to handle these commands. Such a component is called<strong> application service</strong>.</p>
<p class="mce-root">If you refer to <a href="bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml" target="_blank">Chapter 4</a>, <em>Designing the Model</em>, and look at the picture of the onion architecture, you will find application services between the infrastructure and the domain model. Application services have no dependency on the transport that is used to send commands from the outside.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">However, the services need to have a way to load and store entities, because a typical operation of an application service would be to execute a command like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b62dfcda-7863-4220-bcbc-248f4aa5ff68.png" style="width:37.75em;height:41.08em;"/></p>
<p>Typical interaction flow </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are a couple of exceptions in this flow. When the application service receives a command that requires creating a new entity, it won't load anything from the entity storage, since there is nothing to load yet. It will create the entity and save it to the entity store. Also, when handling a command requires deleting an entity, the application service will load the entity, but not necessarily save it back. It might just delete this entity from the store instead, but this very much depends on a model. For example, if the business requires keeping all the data, we might just mark the entity as deleted and then persist changes to the entity store.</p>
<p>Let's add a new application service class to our project and write some code. First, we need a new file in the <kbd>Api</kbd> folder of our executable web API project. Some might argue that application services aren't part of the API, but for now, we have only one edge and there is no real reason to separate them. The new filename would be <kbd>ClassifiedAdApplicationService.cs</kbd>, and it has the following code:</p>
<pre>namespace Marketplace.Api<br/>{<br/>    public class ClassifiedAdsApplicationService<br/>    {<br/>        public void Handle(Contracts.ClassifiedAds.V1.Create command)<br/>        {<br/>            // we need to create a new Classified Ad here<br/>        }<br/>    }<br/>}</pre>
<p>Now, we need to call the application service from our API. We need to add the application serves as a dependency to our controller, and in the startup, we will register the dependency in the ASP.NET Core service locator. First, we do the registration. Since our application service class has no dependencies yet, we can use a singleton, so we add one line to the <kbd>ConfigureServices</kbd> method of the <kbd>Startup</kbd> class:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSingleton(new ClassifiedAdsApplicationService());<br/>    ...<br/>}</pre>
<p>When this is done, we can add the <kbd>ClassifiedAdsApplicationService</kbd> class as a dependency to the <kbd>ClassifiedAdsCommandsApi</kbd> controller and call the <kbd>Handle</kbd> method from our <kbd>Post</kbd> method:</p>
<pre>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Marketplace.Api<br/>{<br/>    [Route("/ad")]<br/>    public class ClassifiedAdsCommandsApi : Controller<br/>    {<br/>        private readonly ClassifiedAdsApplicationService _applicationService;<br/><br/>        public ClassifiedAdsCommandsApi(<br/>            ClassifiedAdsApplicationService applicationService)<br/>            =&gt; _applicationService = applicationService;<br/><br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; Post(<br/>            Contracts.ClassifiedAds.V1.Create request)<br/>        {<br/>            _applicationService.Handle(request);<br/><br/>            return Ok();<br/>        }<br/>    }<br/>}</pre>
<p>In the next section, we will dive into command handling, including saving entities to an entity store and retrieving them. We will add more commands and handlers for those commands too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling commands</h1>
                
            
            
                
<p>In the previous section, we created a simple web API and learned that the API is the <em>edge</em> of our application. The edge talks with the outside world and accepts requests via HTTP or another communication protocol. To execute these requests, we need an <em>application service</em> that works as an intermediary between edge components and the domain model. The application service is also responsible for persisting entities.</p>
<p>Going forward, we will learn more about handling commands and persistence. Also, we will discuss handling exceptions and checking whether incoming requests are valid.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The command handler pattern</h1>
                
            
            
                
<p>There are several ways to handle commands in CQRS. One established pattern is to use command handlers. It is not specific to CQRS but it is being widely used because it is a very good fit. The command handler is a class that has one method to handle a single command type. For example, we might have a command handler such as this:</p>
<pre>public class CreateClassifiedAdHandler : <br/>    IHandleCommand&lt;Contracts.ClassifiedAds.V1.Create&gt;<br/>{<br/>    private readonly IEntityStore _store;<br/><br/>    public CreateClassifiedAdHandler(IEntityStore store) <br/>        =&gt; _store = store;<br/><br/>    public Task Handle(Contracts.ClassifiedAds.V1.Create command)<br/>    {<br/>        var classifiedAd = new ClassifiedAd(<br/>            new ClassifiedAdId(command.Id), <br/>            new UserId(command.OwnerId));<br/><br/>        return _store.Save(classifiedAd);<br/>    }<br/>}</pre>
<p>Two interfaces are used by the command handler earlier. The interfaces look like this:</p>
<pre>public interface IHandleCommand&lt;in T&gt;<br/>{<br/>    Task Handle(T command);<br/>}<br/><br/>public interface IEntityStore<br/>{<br/>    Task&lt;T&gt; Load&lt;T&gt;(string id);<br/>    Task Save&lt;T&gt;(T entity);<br/>}</pre>
<p>Bear in mind that the <kbd>IEntityStore</kbd> interface is simplified and not all persistence methods can be represented by such an interface.</p>
<p>Make no mistake, I am not trying to seed the idea of generic repositories in your head. In fact, the entity store is not the exact math of the repository pattern. When the purpose of repositories is to mimic a collection of objects and hide the persistence, the entity store is a complete opposite. It does not represent a collection. It does exactly what it tells you about - persist one single object and retrieves it back. And while generic repositories are often considered as an anti-pattern, I wouldn't apply the same for the entity store interface.</p>
<p>We then can use this command handler in the API:</p>
<pre>using System.Threading.Tasks;<br/>using Marketplace.Contracts;<br/>using Microsoft.AspNetCore.Mvc;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    [Route("/ad")]<br/>    public class ClassifiedAdsCommandsApi : Controller<br/>    {<br/>        private readonly IHandleCommand&lt;V1.Create&gt;<br/>            _createAdCommandHandler;<br/><br/>        public ClassifiedAdsCommandsApi(<br/>            IHandleCommand&lt;V1.Create&gt; <br/>            createAdCommandHandler<br/>        ) =&gt;<br/>            _createAdCommandHandler = createAdCommandHandler;<br/><br/>        [HttpPost]<br/>        public Task Post(V1.Create request) =&gt; <br/>            _createAdCommandHandler.Handle(request);<br/>    }<br/>}</pre>
<p>You can see here that we reference the command handler via the <kbd>IHandleCommand</kbd> interface. It gives us some freedom in choosing the implementation we want to use. To start with, we can register the implementation we already have:</p>
<pre>services.AddSingleton&lt;IEntityStore, RavenDbEntityStore&gt;();<br/>services.AddScoped&lt;<br/>    IHandleCommand&lt;Contracts.ClassifiedAds.V1.Create&gt;,<br/>    CreateClassifiedAdHandler&gt;();</pre>
<p>Here, we register the <kbd>RavenDbEntityStore</kbd> class, which implements <kbd>IEntityStore</kbd>. We aren't going to look at the actual implementation here, but since <kbd>RavenDb</kbd> is the document database, such a class could be trivial to implement.</p>
<p class="mce-root">What we have done so far is very straightforward, but since we are using the <kbd>IHandleCommand&lt;T&gt;</kbd> interface in our API, we can do something more interesting. For example, we can create a generic command handler that retries failures:</p>
<pre>public class RetryingCommandHandler&lt;T&gt; : IHandleCommand&lt;T&gt;<br/>{<br/>    static RetryPolicy _policy = Policy<br/>          .Handle&lt;InvalidOperationException&gt;()<br/>          .Retry();<br/><br/>    private IHandleCommand&lt;T&gt; _next;<br/><br/>    public RetryingCommandHandler(IHandleCommand&lt;T&gt; next)<br/>        =&gt; _next = next;<br/>    <br/>    public Task Handle(T command) <br/>        =&gt; _policy.ExecuteAsync(() =&gt; _next.Handle(command));<br/>}</pre>
<p>We just need to change the service registration to look like this:</p>
<pre>services.AddScoped&lt;IHandleCommand&lt;V1.Create&gt;&gt;(c =&gt;<br/>    new RetryingCommandHandler&lt;V1.Create&gt;(<br/>        new CreateClassifiedAdHandler(c.GetService&lt;RavenDbEntityStore&gt;())));</pre>
<p>Here, we wrap the actual command handler inside the generic retry handler. Since they both implement the same interface, we can build a pipeline using a composition of these classes. We can continue adding more elements to the chain, such as using a circuit breaker or a logger.</p>
<p>We can add more properties to the command class (remember the weak schema), but the only handler that we might want to change because of this would be the actual command handler. All transient handlers will remain unchanged because we are using the command type, which is a complex type, as a parameter, so the interface definition itself doesn't change.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The command handler pattern is compelling, and it adheres to the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>). At the same time, each HTTP method in our API would require a separate command handler as a dependency. It is not a big deal if we have two or three methods, but we might have a little more than that. We might predict that we will have more than 10 methods in our classified ad web API, and an adequate number of command handlers, just by looking at the result of our EventStorming session. Command handlers need the entity store as a dependency, and since all web API controllers are instantiated per scope, all command handlers will be instantiated and injected as well, with all their dependencies. It is possible to mitigate the instantiation of a vast dependency tree by using factory delegates instead of dependencies per request, so each method would be able to instantiate its handler:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Marketplace.Contracts;<br/>using Microsoft.AspNetCore.Mvc;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    [Route("/ad")]<br/>    public class ClassifiedAdsCommandsApi : Controller<br/>    {<br/>        private readonly Func&lt;IHandleCommand&lt;V1.Create&gt;&gt;<br/>            _createAdCommandHandlerFactory;<br/><br/>        public ClassifiedAdsCommandsApi(<br/>            Func&lt;IHandleCommand&lt;V1.Create&gt;&gt; createAdCommandHandlerFactory) <br/>            =&gt; _createAdCommandHandlerFactory = createAdCommandHandlerFactory;<br/><br/>        [HttpPost]<br/>        public Task Post(V1.Create request) =&gt; <br/>            _createAdCommandHandlerFactory().Handle(request);<br/>    }<br/>}</pre>
<p>This approach would require more advanced registration since we aren't using the actual type, but a delegate. Another solution might be to use <kbd>Lazy&lt;IHandleCommand&lt;T&gt;&gt;</kbd> as a dependency. Again, it will require more complex registration. The registration challenge might be resolved by using another dependency-injection container, such as Autofac, which supports automatic factory delegates and <kbd>Lazy&lt;T&gt;</kbd> out of the box.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In this book, we will not be using the command handler pattern, but instead, we will implement command handling using the application service. We already started to implement a simple service in this section and will continue in the next section. The command handler detour exists to bring a better overview of useful patterns since no pattern is good enough for all use cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Application service</h1>
                
            
            
                
<p>In fact, how our application service will look and behave is very similar to a bunch of command handlers. A <em>classic</em> application service exposes some methods with multiple parameters, like this:</p>
<pre>public interface IPaymentApplicationService<br/>{<br/>    Guid Authorize(<br/>        string creditCardNumber, <br/>        int expiryYear,<br/>        int expiryMonth,<br/>        int cvcCode,<br/>        intcamount);<br/>    void Capture(Guid authorizationId);<br/>}</pre>
<p>Using this kind of declaration is perfectly fine, except it doesn't play that well with the composition. It is not easy to add such an application service to a pipeline, where we have logging, retry policies, and so on. To make a pipeline, we need all our handlers to have compatible parameters, but these methods of <kbd>IPaymentApplicationService</kbd> just don't allow us to go that way. Every other call in the pipeline must have the same set of parameters, and as soon as we want to add one more parameter to any method, we are doomed to make numerous changes in multiple classes that form our pipeline. This is not something we'd like to do.</p>
<p>Alternatively, we can have one application service class that implements multiple <kbd>IHandle&lt;T&gt;</kbd> interfaces. This would work, but each command will then require a separate bootstrapping code, although we are adding the same elements to our pipeline:</p>
<pre>services.AddScoped&lt;IHandleCommand&lt;V1.Create&gt;&gt;(c =&gt;<br/>    new RetryingCommandHandler&lt;V1.Create&gt;(<br/>        new CreateClassifiedAdHandler(c.GetService&lt;RavenDbEntityStore&gt;())));<br/>services.AddScoped&lt;IHandleCommand&lt;V1.Create&gt;&gt;(c =&gt;<br/>    new RetryingCommandHandler&lt;V1.Rename&gt;(<br/>        new RenameClassifiedAdHandler(c.GetService&lt;RavenDbEntityStore&gt;())));<br/>// more handlers need to be added with the same composition</pre>
<p>Alternatively, we can generalize our application service to handle any type of command, and use the C# 7 advanced pattern-matching feature again (like we did with event handling). In this case, the application service signature would look like this:</p>
<pre>public interface IApplicationService<br/>{<br/>    Task Handle(object command);<br/>}</pre>
<p>All our previous filters for the pipeline, such as the retry filter or the logging filter, can implement this simple interface. Since those classes don't need to get a hold of the command's content, everything will work just fine. Our classified ad service would then look like this:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Marketplace.Framework;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    public class ClassifiedAdsApplicationService <br/>        : IApplicationService<br/>    {<br/>        public async Task Handle(object command)<br/>        {<br/>            switch (command)<br/>            {<br/>                case V1.Create cmd:<br/>                    // we need to create a new Classified Ad here<br/>                    break;<br/><br/>                default:<br/>                    throw new InvalidOperationException(<br/>                        $"Command type {command.GetType().FullName} is <br/>                        unknown");<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>By implementing our application service like this, we will have a single dependency to handle for all of our API calls, and we keep the door open to compose a more complex command processing pipeline, just as we were able to do with individual command handlers.</p>
<p>Of course, the tradeoff here is that we have one class that handles several commands and some might see it as an SRP violation. At the same time, the level of cohesion for this class is high, and we will see more of it later in this chapter when we will adequately handle several commands and make calls to our application service from the edge.</p>
<p>Let's now add more commands and extend our application service and the HTTP edge accordingly.</p>
<p>First, we need to get back to our entity and check what actions we can command it to perform. These actions are as following:</p>
<ol>
<li>Set the title.</li>
<li>Update the text.</li>
<li>Update the price.</li>
<li>Request to publish.</li>
</ol>
<p>We can add four commands to execute these actions, since we could expect, based on our EventStorming sessions, that this is what our users would like to do.</p>
<p>The expanded commands list would look like this:</p>
<pre>using System;<br/><br/>namespace Marketplace.Contracts<br/>{<br/>    public static class ClassifiedAds<br/>    {<br/>        public static class V1<br/>        {<br/>            public class Create<br/>            {<br/>                public Guid Id { get; set; }<br/>                public Guid OwnerId { get; set; }<br/>            }<br/><br/>            public class SetTitle<br/>            {<br/>                public Guid Id { get; set; }<br/>                public string Title { get; set; }<br/>            }<br/><br/>            public class UpdateText<br/>            {<br/>                public Guid Id { get; set; }<br/>                public string Text { get; set; }<br/>            }<br/><br/>            public class UpdatePrice<br/>            {<br/>                public Guid Id { get; set; }<br/>                public decimal Price { get; set; }<br/>                public string Currency { get; set; }<br/>            }<br/><br/>            public class RequestToPublish<br/>            {<br/>                public Guid Id { get; set; }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Each command needs to have the ID of the entity it is going to operate on. Other properties are command-specific.</p>
<p>Second, we can extend our edge to accept these commands as HTTP requests. The code for the new API version is as follows:</p>
<pre>using System.Threading.Tasks;<br/>using Marketplace.Contracts;<br/>using Microsoft.AspNetCore.Mvc;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    [Route("/ad")]<br/>    public class ClassifiedAdsCommandsApi : Controller<br/>    {<br/>        private readonly ClassifiedAdsApplicationService <br/>        _applicationService;<br/><br/>        public ClassifiedAdsCommandsApi(<br/>            ClassifiedAdsApplicationService applicationService)<br/>            =&gt; _applicationService = applicationService;<br/><br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; Post(V1.Create request)<br/>        {<br/>            await _applicationService.Handle(request);<br/>            return Ok();<br/>        }<br/><br/>        [Route("name")]<br/>        [HttpPut]<br/>        public async Task&lt;IActionResult&gt; Put(V1.SetTitle request)<br/>        {<br/>            await _applicationService.Handle(request);<br/>            return Ok();<br/>        }<br/><br/>        [Route("text")]<br/>        [HttpPut]<br/>        public async Task&lt;IActionResult&gt; Put(V1.UpdateText request)<br/>        {<br/>            await _applicationService.Handle(request);<br/>            return Ok();<br/>        }<br/><br/>        [Route("price")]<br/>        [HttpPut]<br/>        public async Task&lt;IActionResult&gt; Put(V1.UpdatePrice request)<br/>        {<br/>            await _applicationService.Handle(request);<br/>            return Ok();<br/>        }<br/><br/>        [Route("publish")]<br/>        [HttpPut]<br/>        public async Task&lt;IActionResult&gt; Put(V1.RequestToPublish request)<br/>        {<br/>            await _applicationService.Handle(request);<br/>            return Ok();<br/>        }<br/>    }<br/>}</pre>
<p>You might already see some candidates for creating a useful abstraction or routine. You can probably also predict some issues with this code when it will run in production. The preceding edge code also violates an important principle that the API client needs to only sends valid commands to the command handler. In our code, there is nothing that does such checks. Don't worry; we will get back to the API code and solve some of those issues. For now, let's concentrate on the essential bits.</p>
<p>As you can see, our application service is expected to handle five commands. We need to take care that it does that. The new code for our application service would be the following:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Marketplace.Contracts;<br/>using Marketplace.Domain;<br/>using Marketplace.Framework;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    public class ClassifiedAdsApplicationService <br/>        : IApplicationService<br/>    {<br/>        private readonly IEntityStore _store;<br/>        private ICurrencyLookup _currencyLookup;<br/><br/>        public ClassifiedAdsApplicationService(<br/>            IEntityStore store, ICurrencyLookup currencyLookup)<br/>        {<br/>            _store = store;<br/>            _currencyLookup = currencyLookup;<br/>        }<br/><br/>        public async Task Handle(object command)<br/>        {<br/>            ClassifiedAd classifiedAd;<br/>            switch (command)<br/>            {<br/>                case V1.Create cmd:<br/>                    if (await _store.Exists&lt;ClassifiedAd&gt;(cmd.Id.ToString()))<br/>                        throw new InvalidOperationException(<br/>                            $"Entity with id {cmd.Id} already exists");<br/><br/>                    classifiedAd = new ClassifiedAd(<br/>                        new ClassifiedAdId(cmd.Id),<br/>                        new UserId(cmd.OwnerId));<br/><br/>                    await _store.Save(classifiedAd);<br/>                    break;<br/><br/>                case V1.SetTitle cmd:<br/>                    classifiedAd = await _store.Load&lt;ClassifiedAd&gt;(cmd.Id.ToString());<br/>                    if (classifiedAd == null)<br/>                        throw new InvalidOperationException(<br/>                            $"Entity with id {cmd.Id} cannot be found");<br/><br/>                    classifiedAd.SetTitle(ClassifiedAdTitle.FromString(cmd.Title));<br/>                    await _store.Save(classifiedAd);<br/>                    break;<br/><br/>                case V1.UpdateText cmd:<br/>                    classifiedAd = await _store.Load&lt;ClassifiedAd&gt;(cmd.Id.ToString());<br/>                    if (classifiedAd == null)<br/>                        throw new InvalidOperationException(<br/>                            $"Entity with id {cmd.Id} cannot be found");<br/><br/>                    classifiedAd.UpdateText(ClassifiedAdText.FromString(cmd.Text));<br/>                    await _store.Save(classifiedAd);<br/>                    break;<br/><br/>                case V1.UpdatePrice cmd:<br/>                    classifiedAd = await _store.Load&lt;ClassifiedAd&gt;(cmd.Id.ToString());<br/>                    if (classifiedAd == null)<br/>                        throw new InvalidOperationException(<br/>                            $"Entity with id {cmd.Id} cannot be found");<br/><br/>                    classifiedAd.UpdatePrice(<br/>                        Price.FromDecimal(cmd.Price, cmd.Currency, _currencyLookup));<br/>                    await _store.Save(classifiedAd);<br/>                    break;<br/><br/>                case V1.RequestToPublish cmd:<br/>                    classifiedAd = await _store.Load&lt;ClassifiedAd&gt;(cmd.Id.ToString());<br/>                    if (classifiedAd == null)<br/>                        throw new InvalidOperationException(<br/>                            $"Entity with id {cmd.Id} cannot be found");<br/><br/>                    classifiedAd.RequestToPublish();<br/>                    await _store.Save(classifiedAd);<br/>                    break;<br/><br/>                default:<br/>                    throw new InvalidOperationException(<br/>                        $"Command type {command.GetType().FullName} is unknown");<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Here, we again use the <kbd>IEntityStore</kbd> abstraction. This interface is very simple:</p>
<pre>using System.Threading.Tasks;<br/><br/>namespace Marketplace.Framework<br/>{<br/>    public interface IEntityStore<br/>    {<br/>        /// &lt;summary&gt;<br/>        /// Loads an entity by id<br/>        /// &lt;/summary&gt;<br/>        Task&lt;T&gt; Load&lt;T&gt;(string entityId) where T : Entity;<br/><br/>        /// &lt;summary&gt;<br/>        /// Persists an entity<br/>        /// &lt;/summary&gt;<br/>        Task Save&lt;T&gt;(T entity) where T : Entity;<br/><br/>        /// &lt;summary&gt;<br/>        /// Check if entity with a given id already exists<br/>        /// &lt;typeparam name="T"&gt;Entity type&lt;/typeparam&gt;<br/>        Task&lt;bool&gt; Exists&lt;T&gt;(string entityId);<br/>    }<br/>}</pre>
<p>We will be implementing this interface for different persistence types.</p>
<p>As you can see, handling the <kbd>Create</kbd> command looks different from handling all other commands. This is natural since when we create a new entity, we need to ensure it does not exist yet. When we handle operations on the existing entity, it works the other way around. In this case, we need to ensure that the entity exists, otherwise, we cannot perform the operation and must throw an exception.</p>
<p>Another thing worth mentioning is that the application service is responsible for translating primitive types, such as string or decimal, to value objects. The edge always uses serializable types that have no dependencies on the domain model. The application service, however, operates with domain concerns; it needs to tell our domain model what to do, and since our domain model prefers to receive data as value objects, the application service is then responsible for the conversion.</p>
<p>The code for handling commands for an existing entity looks very similar to handling updates for existing entities. In fact, only the line where we call the entity method is different. Therefore, we can significantly simplify the <kbd>Handle</kbd> method by using a straightforward generalization and replace the <kbd>switch</kbd> pattern-matching operator with the switch expression:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Marketplace.Domain;<br/>using Marketplace.Framework;<br/>using static Marketplace.Contracts.ClassifiedAds;<br/><br/>namespace Marketplace.Api<br/>{<br/>    public class ClassifiedAdsApplicationService<br/>        : IApplicationService<br/>    {<br/>        private readonly IClassifiedAdRepository _repository;<br/>        private readonly ICurrencyLookup _currencyLookup;<br/><br/>        public ClassifiedAdsApplicationService(<br/>            IClassifiedAdRepository repository,<br/>            ICurrencyLookup currencyLookup<br/>        )<br/>        {<br/>            _repository = repository;<br/>            _currencyLookup = currencyLookup;<br/>        }<br/><br/>        public Task Handle(object command) =&gt;<br/>            command switch<br/>            {<br/>                V1.Create cmd =&gt;<br/>                    HandleCreate(cmd),<br/>                V1.SetTitle cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.SetTitle(<br/>                            ClassifiedAdTitle.FromString(cmd.Title)<br/>                        )<br/>                    ),<br/>                V1.UpdateText cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.UpdateText(<br/>                            ClassifiedAdText.FromString(cmd.Text)<br/>                        )<br/>                    ),<br/>                V1.UpdatePrice cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.UpdatePrice(<br/>                            Price.FromDecimal(<br/>                                cmd.Price,<br/>                                cmd.Currency,<br/>                                _currencyLookup<br/>                            )<br/>                        )<br/>                    ),<br/>                V1.RequestToPublish cmd =&gt;<br/>                    HandleUpdate(<br/>                        cmd.Id,<br/>                        c =&gt; c.RequestToPublish()<br/>                    ),<br/>                _ =&gt; Task.CompletedTask<br/>            };<br/><br/>        private async Task HandleCreate(V1.Create cmd)<br/>        {<br/>            if (await _repository.Exists(cmd.Id.ToString()))<br/>                throw new InvalidOperationException(<br/>                    $"Entity with id {cmd.Id} already exists");<br/><br/>            var classifiedAd = new ClassifiedAd(<br/>                new ClassifiedAdId(cmd.Id),<br/>                new UserId(cmd.OwnerId)<br/>            );<br/><br/>            await _repository.Save(classifiedAd);<br/>        }<br/><br/>        private async Task HandleUpdate(<br/>            Guid classifiedAdId,<br/>            Action&lt;ClassifiedAd&gt; operation<br/>        )<br/>        {<br/>            var classifiedAd = await _repository.Load(<br/>                classifiedAdId.ToString()<br/>            );<br/>            if (classifiedAd == null)<br/>                throw new InvalidOperationException(<br/>                    $"Entity with id {classifiedAdId} cannot be found"<br/>                );<br/><br/>            operation(classifiedAd);<br/><br/>            await _repository.Save(classifiedAd);<br/>        }<br/>    }<br/>}</pre>
<p>From the application service code, it becomes clear that the application service itself plays the vital role of an intermediary between the application edge and the domain model. An edge could be anything that communicates with the outside world. We used the HTTP API as an example, but it could also be a messaging interface or something entirely different. The important requirement for the edge would be the ability to accept commands, check them, and engage the application service to handle those commands.</p>
<p class="mce-root">When we handle a command, no matter whether we use multiple command handlers or single application service, the sequence of operations is usually very similar. A command handler needs to fetch a persisted entity from the entity store, call the domain model to do the work, and then persist changes. In our example, we only called one method of the entity, but this is not always the case. We will look deeper into this when we discuss the consistency and transactional boundaries in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at how the intent of our users can be represented as commands that those users send to our system. We learned how these commands can be handled, looked at several examples of the command handler pattern, and then got to the application service.</p>
<p>We looked at API versioning; although it is not directly related to the book topic, the practice is too important to ignore. We will touch upon the versioning topic in <a href="75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml" target="_blank">Chapter 10</a>, <em>Event Sourcing</em>.</p>
<p>Our application service grew throughout this chapter, and we used one of the latest features of C#, a gift from the functional world, called <strong>advanced pattern matching</strong>. We used this feature to simplify the application service interface, which ended up having just a single method. By doing this, we also enabled using a composition, yet another functional-style approach, to chain command handling with operational concerns, such as logging and retries. We will also look at how this can help us check the validity of commands.</p>
<p>In the next chapter, we will take a closer look at entity persistence. We will learn what types of consistency we need to deal with and how important it is to understand the consistency boundaries.</p>


            

            
        
    </body></html>