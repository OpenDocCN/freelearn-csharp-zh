- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Externalization of Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权的外部化
- en: The previous chapter was about business rules management in general. In this
    chapter, we will analyze a particular case of authorization management, since
    the rights and privileges of users are one of the most common uses of business
    rules that you can find in many applications. Since there exist two standards
    for authorization management (as already explored in [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271))
    we will quickly explain the first and more complete standard, namely **XACML**
    (short for, **eXtensible Access Control Markup Language**) because it helps understand
    how it relates to the **Single Responsibility Principle** (**SRP**); then, we
    will create a more complete example with the new, lighter, standard, which is
    **OPA** (short for, **Open** **Policy Agent**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章是关于业务规则管理的一般性内容。在本章中，我们将分析授权管理的特定案例，因为用户的权利和特权是许多应用程序中可以找到的常见业务规则使用之一。由于存在两个授权管理标准（如已在[*第
    8 章*](B21293_08.xhtml#_idTextAnchor271)中探讨），我们将快速解释第一个更完整的标准，即**XACML**（代表**可扩展访问控制标记语言**），因为它有助于理解它与**单一责任原则**（**SRP**）的关系；然后，我们将使用新的、更轻的标准**OPA**（代表**开放**
    **策略代理**）创建一个更完整的示例。
- en: We will then end this chapter (and the series of four chapters on the different
    parts of an ideal information system) by reflecting on how to implement this authorization
    in practice, which will open the way to the analysis and the implementation of
    the information system for `DemoEditor`, which has accompanied us so far, illustrating
    with examples the concepts studied, and it will, of course, also serve as a practical
    example of the implementations of what we learned in the previous chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以此结束本章（以及关于理想信息系统不同部分的四个章节系列），通过反思如何在实践中实施这种授权，这将开启对伴随我们至今的`DemoEditor`信息系统的分析和实施之路，通过示例说明所研究的概念，当然，这还将作为我们在上一章所学内容的实际应用示例。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A BRMS and authorization management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BRMS 和授权管理
- en: Applying authorization to our same information system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将授权应用于我们的同一信息系统中
- en: A BRMS and authorization management
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BRMS 和授权管理
- en: As I quickly mentioned in the previous chapter, there is a functional domain
    in the `DemoEditor` sample information system where an externalized business rules
    engine would be interesting, and this domain is one of authorization. Before explaining
    the need to clarify the semantics of the “rights” business domain, examine the
    main paradigms to implement authorization in software applications, and also explain
    one of the standards associated with this function, which decomposes very well
    the different responsibilities it entails.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在上一章中简要提到的，在`DemoEditor`示例信息系统中存在一个功能域，在这个域中，外部化的业务规则引擎会很有趣，而这个域就是授权。在解释澄清“权利”业务域的语义需求之前，先考察在软件应用程序中实现授权的主要范例，并解释与该功能相关的一个标准，该标准很好地分解了它所涉及的不同责任。
- en: The semantics of identity and authorization management
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份和授权管理的语义
- en: 'As explained in [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318), semantics
    is the foundation of all things in architecture, and we will clarify the terms
    we use for certain concepts in order to not incorrectly define the business domain
    model. Thus, it is important to clearly define the different subdomains of **Identity
    and Authorization Management** (**IAM**) and how we name things inside of them.
    Let’s start with the concept associated with **identification** (who you are)
    and **authentication** (how you can prove your identity):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第 9 章*](B21293_09.xhtml#_idTextAnchor318)中所述，语义是架构中所有事物的基石，我们将明确界定我们用于某些概念的术语，以避免错误地定义业务域模型。因此，明确定义**身份和授权管理**（**IAM**）的不同子域以及我们在其中如何命名事物是很重要的。让我们从与**识别**（你是谁）和**认证**（你如何证明你的身份）相关的概念开始：
- en: '![Figure 13.1 – Identification and authentication semantics](img/Figure_13.1_B21293.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 识别和认证语义](img/Figure_13.1_B21293.jpg)'
- en: Figure 13.1 – Identification and authentication semantics
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 识别和认证语义
- en: A first – and very important – point is that authorization should depend only
    on your identity (and, of course, some elements of context, but we will come to
    that later) and never on how you prove your identity. At least, this is how we
    are going to work on the information system for now. Of course, we may in the
    future have to take into account that some authentication methods are safer than
    others and that some applications may request a strong form of multi-factor authentication
    to open certain features. But this use case will be handled with the addition
    of attributes to identification to account for this. After all, even in this situation,
    an application does not need to know exactly what you authenticated but, rather,
    how strong a trust it can have in the identity that it is provided with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个首要的——并且非常重要的——观点是，授权应仅依赖于你的身份（当然，还有一些上下文元素，但我们会稍后讨论）以及你如何证明你的身份，而不是证明身份的方式。至少，这是我们目前将在信息系统上采取的做法。当然，我们可能在将来需要考虑某些身份验证方法比其他方法更安全，以及某些应用程序可能要求进行强多因素身份验证才能打开某些功能。但这个用例将通过向身份识别添加属性来处理，以考虑这一点。毕竟，即使在这种情况下，应用程序也不需要确切知道你进行了什么身份验证，而是知道它对提供的身份可以有多少信任。
- en: There are already some cases like this in the standard identity profiles associated
    with OAuth; for example, in addition to the `email` attribute, the contact profile
    can provide an `email_validated` attribute that specifies that the identity provider
    has verified that the identified user indeed has control of a certain email address.
    This is a way of augmenting trust in the identification without the identity consumer
    knowing anything about *how* the email has been verified. We are not going to
    dig deeper into authentication, as this is a hugely sophisticated domain, and
    what we want to model precisely is the authorization domain. For now, let’s just
    remember that a given user can be authenticated by different accounts/ways to
    prove its identity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在与OAuth关联的标准身份配置文件中已经存在一些类似的情况；例如，除了`email`属性外，联系配置文件还可以提供一个`email_validated`属性，该属性指定身份提供者已验证该标识用户确实控制了某个电子邮件地址。这是一种在不让身份消费者了解电子邮件是如何被验证的情况下增强对身份识别信任的方法。我们不会深入探讨身份验证，因为这个领域非常复杂，而我们想要精确建模的是授权领域。现在，我们只需记住，一个特定的用户可以通过不同的账户/方式来证明其身份进行身份验证。
- en: The important aspect of what will follow is that users can belong to groups,
    which ultimately will bring them some commonalities in rights management. These
    groups can be formed in a hierarchical tree in order to ease complex management.
    Bear in mind that we are still in the identification domain, so belonging to a
    group does not directly give you certain rights. Groups are simply part of your
    identity, as are any other attributes such as `lastname` or `firstname`, to give
    examples from the OpenID Connect/JWT/OAuth standards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的重要方面是，用户可以属于不同的组，这最终将使他们在权利管理方面具有一些共同点。这些组可以形成一个层次树，以简化复杂的管理。请记住，我们仍然处于身份识别领域，因此属于一个组并不直接赋予你某些权利。组只是你身份的一部分，就像`lastname`或`firstname`等其他任何属性一样，例如从OpenID
    Connect/JWT/OAuth标准中举例。
- en: 'Let’s now discuss the other half of IAM, which is **authorization** management.
    The main semantics are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论IAM的另一半，即**授权**管理。主要语义如下：
- en: '![Figure 13.2 – Authorization semantics](img/Figure_13.2_B21293.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 授权语义](img/Figure_13.2_B21293.jpg)'
- en: Figure 13.2 – Authorization semantics
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 授权语义
- en: The preceding diagram is, of course, just an example, and you may have your
    vocabulary for the terms used within it. But this is precisely the goal of such
    a semantics analysis; I know that some people use the word “*profiles*” to describe
    the groups of people from the identification domain, that some use the word “*group*”
    to discuss authorization groups, and that some others replace “*role*” with “*profile*.”
    But there are also people using other vocabulary, and the important thing is not
    who is right; as long as there is no established standard, everyone is. The important
    thing is to be able to understand univocally what we talk about. In this book,
    a group will be an entity that organizes sets of users that are similar in their
    identity, while a role will be a set of authorizations that are often used together.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表当然只是一个例子，你可能有你自己的词汇来描述其中的术语。但这正是这种语义分析的目的；我知道有些人用“*profiles*”这个词来描述身份域中的人群组，有些人用“*group*”来讨论授权组，还有一些人用“*profile*”来代替“*role*”。但也有人使用其他词汇，重要的是不是谁是对的；只要没有建立标准，每个人都是。重要的是能够明确理解我们谈论的内容。在这本书中，一个组将是一个组织用户集的实体，这些用户在身份上相似，而一个角色将是一组经常一起使用的授权。
- en: Let’s explain in just a bit more detail the concept of permission, which is
    defined by pointing to a resource and an operation (or several, if this is easier
    in your model). For example, removing a book from the data referential service
    may be something that only some editors have the right to do; we would then design
    the corresponding permission by pointing to the `book` resource and the `DELETE`
    verb. The use of the REST-based vocabulary is, of course, intentional – first,
    it makes it more precise to explain what we mean; second, it allows for a precise
    alignment of what will happen in the software. In this case, this permission will
    be associated with the possibility of sending a `DELETE` verb to the `/api/books`
    API, and it is thus implemented without any possible confusion in the books data
    referential service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下权限的概念，它通过指向资源和一个操作（或多个，如果这在你的模型中更容易）来定义。例如，从数据引用服务中删除书籍可能是只有一些编辑有权利做的事情；然后我们会通过指向“book”资源和“DELETE”动词来设计相应的权限。使用基于REST的词汇当然是故意的——首先，它使解释我们想要表达的意思更加精确；其次，它允许在软件中精确地对齐将要发生的事情。在这种情况下，这个权限将与向`/api/books`
    API发送`DELETE`动词的可能性相关联，因此它在书籍数据引用服务中得到了无任何混淆的实现。
- en: 'Of course, some permissions are linked – a senior editor will not only be able
    to delete books but also create, modify, and read them. This is where roles come
    into play – grouping together many permissions that make sense together. This
    is where semantics is also important. Naming the editor role is a difficult choice
    because we will tend to use the word `editors` for two things that are fundamentally
    different: the group to which all users belong when they `editors` for the identification
    group and use a name such as `book-editor` for the role.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一些权限是相互关联的——高级编辑不仅能够删除书籍，还能创建、修改和阅读它们。这就是角色发挥作用的地方——将许多有意义的权限组合在一起。这也是语义也很重要的地方。命名编辑角色是一个困难的选择，因为我们倾向于将“编辑”这个词用于两件本质上不同的事情：当“编辑”用于识别组时，所有用户都属于这个组，而对于角色则使用像“book-editor”这样的名称。
- en: 'Semantics is important in another area – since there are several applications
    in an information system and each of them (at least the data referential service)
    deals with specific resources, it is important to specify the main resource in
    the name of the role; otherwise, they would get confused with each other. By the
    way, this is how we will group the two previous schemas, showing this multiplicity
    of “rights management targets” against the unicity of identification concerns:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 语义在另一个领域也很重要——由于信息系统中有多个应用程序，并且每个应用程序（至少是数据引用服务）都处理特定的资源，因此在角色的名称中指定主要资源是很重要的；否则，它们会相互混淆。顺便说一下，这就是我们将如何将前两个模式分组的方式，展示“权利管理目标”的多样性相对于识别关注点的唯一性：
- en: '![Figure 13.3 – Each application takes care of its authorizations](img/Figure_13.3_B21293.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 每个应用程序负责其授权](img/Figure_13.3_B21293.jpg)'
- en: Figure 13.3 – Each application takes care of its authorizations
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 每个应用程序负责其授权
- en: Before we go into more detail about what is in the **Authorization** boxes,
    let’s make a useful digression on the way IAM is handled in many applications
    and how it should be used to obtain a neat business/IT alignment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地讨论**授权**框中包含的内容之前，让我们对许多应用程序中处理IAM的方式以及如何使用它来实现业务/IT的整洁对齐进行一次有用的偏离。
- en: A digression on IAM implementation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IAM实施的偏离
- en: 'In most existing information systems, identification is still handled directly
    by many applications, leading to the well-known antipattern represented here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现有的信息系统中，身份验证仍然由许多应用程序直接处理，导致这里所表示的众所周知的反模式：
- en: '![Figure 13.4 – An antipattern where IAM is in many applications](img/Figure_13.4_B21293.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – IAM在许多应用程序中的反模式](img/Figure_13.4_B21293.jpg)'
- en: Figure 13.4 – An antipattern where IAM is in many applications
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – IAM在许多应用程序中的反模式
- en: These multiple implementations of a unique feature are one of the most observed
    misalignment patterns in existing information systems. It leads not only to the
    duplication of accounts, making it more difficult to manage access rights, but
    also to the duplication of different passwords, which is a pain for users and
    quickly causes security issues because lots of them will use similar passwords
    across their line of business applications, making a password breach suddenly
    more impactful because the attack surface is increased.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些独特功能的多次实现是现有信息系统中观察到的最常见的不对齐模式之一。这不仅导致账户的重复，使得管理访问权限更加困难，还导致不同密码的重复，这对用户来说是一个痛点，并迅速引发安全问题，因为许多用户将在他们的业务应用程序中跨业务使用相似的密码，这使得密码泄露突然更具影响，因为攻击面增加了。
- en: 'One method that is often used by companies to compensate for this difficulty
    is to automate the “newcomer” process and implement some kind of tool that will
    automatically create accounts in every application of the information system.
    Unless you only have a legacy application and no intention of modernizing your
    system (for example, because the activity will be closed in a few years), this
    is always the worst move that can be done, as it tends to crystallize the problem
    – since you have added another (potentially costly) component to the system, you
    will be even less keen on changing it again. The following diagram shows the second
    antipattern in this approach:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 公司常用的一种方法来弥补这种困难是自动化“新来者”流程，并在信息系统的每个应用程序中实施某种工具，以自动创建账户。除非你只有遗留应用程序，并且没有现代化系统的意图（例如，因为活动将在几年内关闭），否则这始终是可能采取的最糟糕的行动，因为它往往会固化问题——既然你已经向系统中添加了另一个（可能成本高昂）的组件，你将更不愿意再次更改它。以下图表显示了这种方法的第二个反模式：
- en: '![Figure 13.5 – The process for a newcomer in its coupled version](img/Figure_13.5_B21293.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 新来者耦合版本的过程](img/Figure_13.5_B21293.jpg)'
- en: Figure 13.5 – The process for a newcomer in its coupled version
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 新来者耦合版本的过程
- en: 'This diagram shows all the additional problems:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表显示了所有额外的问题：
- en: The process is designed in the upper functional layer, but it cannot be modified
    by the business persons, since its execution is based on a job executed by an
    **ETL** application and, thus, can only be modified by technicians, which creates
    some time coupling (a change of regulation will be applied not when the business
    needs it but when the IT department can get around to in its many projects).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该流程设计在上层功能层，但业务人员无法修改它，因为它的执行基于由**ETL**应用程序执行的任务，因此只能由技术人员修改，这造成了一些时间耦合（法规的变化将在业务需要时不会应用，而是在IT部门能够在其众多项目中抽出时间时应用）。
- en: Talking about the many things the IT has to do, did you notice that the only
    actor in the BPMN is **IT**? This is logical since all tasks have been designed
    to be automated and IT is considered responsible for managing the users inside
    the software, simply because they are the ones who have installed it or know how
    to access the APIs. This is a very common problem; instead of having functional
    administrators taking full responsibility for their applications, they rely entirely
    on IT for this. Although this can be considered normal for technical tasks, this
    is a problem in this case because trusting IT to add users and determining their
    default permissions can be a recipe for regulatory disaster. After all, how could
    you be mad at an intern who has dealt with an urgent ticket from accounting by
    creating a user with a default password, not knowing that, in this legacy application,
    users are created by default with full rights, which allows the newcomer user
    to access the bank accounts of the company and empty them on their very first
    day in the job?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谈到IT需要做的许多事情，你是否注意到BPMN中的唯一参与者是**IT**？这是合理的，因为所有任务都设计为自动化，IT被认为负责管理软件内的用户，仅仅因为他们是安装它或知道如何访问API的人。这是一个非常普遍的问题；而不是让功能管理员对其应用程序承担全部责任，他们完全依赖IT来做这件事。虽然这可以被认为是技术任务的正常情况，但在这个案例中，这是一个问题，因为信任IT添加用户并确定他们的默认权限可能会成为监管灾难的配方。毕竟，你怎么能责怪一个处理了会计紧急工单的实习生，他通过创建一个默认密码的用户来解决问题，却不知道在这个遗留应用程序中，用户默认拥有全部权限，这允许新来的用户在公司上班的第一天就访问公司的银行账户并将它们清空？
- en: The process is directly implemented inside an ETL application, which is the
    number one misalignment antipattern. If you continue in this direction, very soon,
    all the business processes of the company will depend on one piece of software
    that, in addition, is a single point of failure in your IT system. What if it
    is discontinued? What if the editor suddenly raises prices? What if there is a
    general failure?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该流程直接在ETL应用程序内部实现，这是最大的不匹配反模式。如果你继续沿着这个方向前进，很快，公司的所有业务流程都将依赖于一个软件，而这个软件不仅是你的IT系统中的单点故障。如果它被停止使用怎么办？如果编辑突然提高价格怎么办？如果发生一般性故障怎么办？
- en: In some cases, the person doing the implementation may be lucky enough to be
    able to call a nice, backward compatible, and well-documented API such as on `Application
    A`, allowing for some kind of decoupling, or even the possibility to expose this
    API in the BCM. But in `Application B`, the API talks directly to a library of
    the application, making this interoperation brittle to any change of version.
    In `Application C`, it is even worse, since the only way found to automate the
    creation of an account was to insert lines directly into the database. The behavior
    might become completely erratic in the next version, or even as soon as you roll
    out in production because you have forgotten an important part of the persistence
    in your script, and so on.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，实施人员可能足够幸运，能够调用一个良好、向后兼容且文档齐全的API，例如在`Application A`上，这允许进行某种解耦，甚至有可能在BCM中公开此API。但在`Application
    B`中，API直接与应用程序的库进行通信，这使得这种互操作性对版本变更非常脆弱。在`Application C`中，情况甚至更糟，因为找到的自动化创建账户的唯一方法是将行直接插入数据库。在下一个版本中，行为可能会变得完全不可预测，或者甚至在生产中推出时就会发生，因为你忘记在脚本中持久化的重要部分，等等。
- en: 'The preceding approach tends to embed in a system this antipattern, where each
    application takes care of its own identification and even authentication, whereas
    it should only handle authorization (this antipattern has to stay there, since
    the application handles the resources, and the permissions apply to these). Instead
    of this, the right move would be to progressively adopt the following correct
    pattern:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法倾向于将这种反模式嵌入到系统中，其中每个应用程序都负责自己的标识甚至身份验证，而它应该只处理授权（这个反模式必须保留，因为应用程序处理资源，权限适用于这些资源）。相反，正确的做法是逐步采用以下正确的模式：
- en: '![Figure 13.6 – A correct map of IAM responsibility](img/Figure_13.6_B21293.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – IAM责任的正确映射](img/Figure_13.6_B21293.jpg)'
- en: Figure 13.6 – A correct map of IAM responsibility
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – IAM责任的正确映射
- en: 'In this case, the identification and authentication responsibilities are implemented
    by a dedicated piece of software (in our example, an Apache Keycloak IAM server,
    plugged into a Microsoft AD user directory) and all applications still take care
    of authorization on the resource they respectively manage, but they point to this
    unique identification feature that they need to apply the right permissions (again,
    without knowing anything about the authentication process). Of course, this would
    not be done in one day; you need to progressively equip your information system
    with an application that supports externalized authentication/identification.
    Nowadays, almost all modern enterprise-grade applications do so, and if they are
    browser-based, it is even possible in some cases to handle these responsibilities
    with a frontend protecting them if needed. And since you will likely always keep
    some legacy applications, you will certainly end up with a “middle of the journey”
    information system such as the following, which is already much better and easier
    to handle:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，身份验证和认证责任由专门的软件实现（在我们的例子中，是一个Apache Keycloak IAM服务器，连接到Microsoft AD用户目录），而所有应用程序仍然负责它们各自管理的资源的授权，但它们指向这个唯一的身份验证特征，以应用正确的权限（再次强调，无需了解任何关于认证过程的信息）。当然，这不会在一天内完成；您需要逐步用支持外部化认证/识别的应用程序装备您的信息系统。如今，几乎所有现代企业级应用程序都这样做，如果它们是基于浏览器的，在某些情况下甚至可以使用前端来保护这些责任。而且由于您很可能会保留一些遗留应用程序，您最终会拥有一个“中途”的信息系统，如下所示，这已经好得多，也更易于处理：
- en: '![Figure 13.7 – The process for a newcomer in a perfectly aligned version](img/Figure_13.7_B21293.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 完美对齐版本的新手流程](img/Figure_13.7_B21293.jpg)'
- en: Figure 13.7 – The process for a newcomer in a perfectly aligned version
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 完美对齐版本的新手流程
- en: 'Do not be put out by the added complexity to the diagram; it is simply more
    complete because I have added more details – in particular, the hardware layer,
    which had not been shown before. In this part of the information system, many
    advantages can be seen on the right of the diagram, but we will discuss them now
    in more detail:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为图中增加的复杂性而感到沮丧；这仅仅是因为我增加了更多的细节——特别是硬件层，之前并未展示过。在这个信息系统部分，可以在图的右侧看到许多优点，但我们将现在更详细地讨论它们：
- en: The implementation of the process can now be dedicated to any tool, and it will
    not have any coupling to the technical stack (except for the call to the Apache
    Keycloak API to add a global user, but it is extremely rare, as this can be based
    on the LDIF standard and a change of software would not be visible by the process
    users).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以将流程的实施专门化到任何工具上，并且它将不会与技术栈有任何耦合（除了调用Apache Keycloak API添加全局用户，但这极为罕见，因为这可以基于LDIF标准，并且软件更改对流程用户是不可见的）。
- en: If the process had to be modified – for example, by adding another step for
    a legacy application that had been forgotten in the first version – it could be
    done by decision-makers alone. In the new version, this additional task would
    work like the existing one for the legacy accounting system – when a user-based
    task is completed, an email would be sent to the functional administrator of the
    application, together with a link to the procedure to add the requested user.
    When done, this person would click on a link in the email received to signal that
    the task is done, which would also close the process.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要修改流程——例如，为在第一版中遗忘的遗留应用程序添加另一个步骤——这可以由决策者独立完成。在新版本中，这个额外任务将像现有的遗留会计系统任务一样工作——当基于用户的任务完成时，会向应用程序的功能管理员发送一封电子邮件，附带添加所需用户的流程链接。完成操作后，这个人会点击收到的电子邮件中的链接，以表示任务已完成，这也会关闭流程。
- en: The first task dedicated to the IT department would still be manual, as there
    would be a form to fill in (the one from Apache Keycloak or – as represented here
    – a form provided by the BPMN engine that would call the API from Keycloak associated
    with the `Create user` function of the BCM). If the API from Keycloak follows
    the LDIF standard, it could be considered as the standardized unique point associated
    with the function in the information system, making it easier to replace Keycloak
    with another software if needed.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门分配给IT部门的第一项任务仍然是手动的，因为需要填写一个表格（Apache Keycloak的表格或——如这里所示——由BPMN引擎提供的表格，该表格会调用与BCM的“创建用户”功能关联的Keycloak
    API）。如果Keycloak的API遵循LDIF标准，它可以被认为是与信息系统中的功能相关联的标准化唯一点，这使得在需要时替换Keycloak为其他软件变得更容易。
- en: In addition, Keycloak acts as an indirection layer to the actual user’s directory.
    If this had to change to another directory, or even use identity federation and
    several directories, this would be transparent for any user of the API associated
    with the `Create` `user` function.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Keycloak充当实际用户目录的间接层。如果这需要更改为另一个目录，或者甚至使用身份联合和多个目录，这对与“创建用户”功能关联的API的任何用户来说都是透明的。
- en: Of course, the problem of the legacy application would not completely disappear,
    but at least, in this configuration, the legacy impact is progressively reduced
    and the right functions are ready for the new and more modern applications to
    work in the way they should. Also, the legacy application is isolated into a silo
    and will be easier to discard in the future. In this example, we could start by
    removing the task from the process, and then suppress the old application with
    its locally coupled identification and authentication features. Finally, we have
    to verify that the old server with an unsupported or exotic, hard-to-maintain
    operating system does not serve any other software role in the system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，遗留应用程序的问题不会完全消失，但至少，在这个配置中，遗留的影响会逐渐减少，并且正确的功能已经准备好以应有的方式为新和更现代的应用程序工作。此外，遗留应用程序被隔离到一个孤岛中，将来丢弃它将更容易。在这个例子中，我们可以从移除流程中的任务开始，然后抑制带有其本地耦合的识别和认证功能的旧应用程序。最后，我们必须验证那个使用不受支持或异类、难以维护的操作系统旧行服务器是否在系统中扮演任何其他软件角色。
- en: Role-based access control and attribute-based access control models
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制和基于属性的访问控制模型
- en: After that rather long – but hopefully useful – digression into IAM implementations,
    we will return to where we were before, which is the fact that, in a good information
    system, identification and authentication features are unique for all applications,
    but the authorization feature is duplicated for each resource. Indeed, only the
    application that handles the resources knows how to handle the permissions on
    them. In our example with the book data referential service, we saw that a role
    called `book-edition` would make sense. But what about in an archiving system?
    Chances are we would find roles such as `archivist` or `readonly-verifier` in
    there, but `book-edition` would make no sense.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在对IAM实现进行了相当长——但希望是有用的——的离题之后，我们将回到之前的地方，即在一个好的信息系统中，识别和认证功能对所有应用程序都是唯一的，但授权功能对每个资源都是重复的。确实，只有处理资源的应用程序才知道如何处理其上的权限。在我们的书籍数据参考服务示例中，我们看到一个名为`book-edition`的角色是有意义的。但在一个存档系统中呢？我们可能会在那里找到像`archivist`或`readonly-verifier`这样的角色，但`book-edition`就没有意义了。
- en: This is not to say that we could not find common role names between applications;
    on the contrary – similar names should be considered carefully because they do
    not mean the same thing. This is why it is so dangerous, even though it is frequently
    done, to name roles `administrator`. Of course, everyone understands what this
    means –users with this role can perform every operation in the software. But,
    specifically, the definition of “everything” can differ from one software to another.
    If you add to this situation a group called `administrators` inside your users’
    directory, which is supposed to mean that the users in this group should have
    full permissions in every application, the confusion is increased.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说我们找不到应用程序之间的共同角色名称；相反——相似的名字应该仔细考虑，因为它们并不意味着相同的事情。这就是为什么即使它经常发生，将角色命名为“管理员”是如此危险。当然，每个人都知道这意味着什么——拥有这个角色的用户可以在软件中执行每个操作。但是，具体来说，“一切”的定义可能因软件而异。如果你在你的用户目录中添加一个名为“管理员”的组，这个组本应意味着这个组中的用户应该在每个应用程序中拥有完全权限，那么混淆就会增加。
- en: I personally recommend restricting this situation to `domain-administrator`
    and arranging for your IT department to never be a functional administrator of
    an application, only of the machines they are installed on (which does not prevent
    them from indirectly seeing or manipulating data, but this is another problem
    that should be dealt with by contractual standards and full traceability of administrative
    actions).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人建议将这种情况限制在`domain-administrator`上，并安排您的IT部门永远不要成为应用程序的功能管理员，而只是它们安装的机器的管理员（这并不阻止他们间接地查看或操作数据，但这又是另一个应该通过合同标准和行政行为的完全可追溯性来解决的问题）。
- en: 'To account for this, a better representation of the preceding diagram would
    be the following one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这一点，前述图表的更好表示方式如下：
- en: '![Figure 13.8 – Affecting authorizations on permissions rather than resources](img/Figure_13.8_B21293.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 在权限上影响授权而不是资源](img/Figure_13.8_B21293.jpg)'
- en: Figure 13.8 – Affecting authorizations on permissions rather than resources
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 在权限上影响授权而不是资源
- en: 'The left-hand side is not as detailed in the preceding diagram, but this is
    what we wanted. Since we stated that authorizations should be based on identity,
    how could we do this in practice? One of the easiest and most commonly used ways
    is the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图中的左侧并不那么详细，但这正是我们想要的。既然我们说授权应该基于身份，那么在实践中我们该如何做呢？最容易和最常用的方法之一如下：
- en: '![Figure 13.9 – A pure role-based access control approach](img/Figure_13.9_B21293.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 纯基于角色的访问控制方法](img/Figure_13.9_B21293.jpg)'
- en: Figure 13.9 – A pure role-based access control approach
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 纯基于角色的访问控制方法
- en: 'When roles are associated (or “mapped”) to groups or directly to users, the
    paradigm of rights management is called **Role-Based Access Control** (**RBAC**).
    The main advantage of this approach is that it is very simple to implement. Since
    the person who administrated rights only sees the role, the diagram could even
    be represented like this from their point of view:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当角色与组或直接与用户关联（或称为“映射”）时，这种基于权利管理的范式被称为**基于角色的访问控制**（**RBAC**）。这种方法的优点在于它非常容易实现。由于管理权利的人只看到角色，因此从他们的角度来看，图表甚至可以表示如下：
- en: '![Figure 13.10 – A documented RBAC approach](img/Figure_13.10_B21293.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 记录的RBAC方法](img/Figure_13.10_B21293.jpg)'
- en: Figure 13.10 – A documented RBAC approach
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 记录的RBAC方法
- en: 'This eases the work of developers as well because, as long as they respect
    the contractual text-based definition of the rights associated with the role,
    they can choose whatever implementation method for the role they prefer, or even
    a mix of them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这也简化了开发者的工作，因为他们只要尊重与角色关联的基于文本的权利定义，就可以选择他们偏好的任何角色实现方法，甚至可以混合使用：
- en: '![Figure 13.11 – Other possible role implementations in RBAC](img/Figure_13.11_B21293.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – RBAC中的其他可能的角色实现](img/Figure_13.11_B21293.jpg)'
- en: Figure 13.11 – Other possible role implementations in RBAC
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – RBAC中的其他可能的角色实现
- en: The textual definition of the role may cause some trouble, due to the text’s
    imprecise nature and the potential for knowledge to become outdated over time,
    it is subject to approximation, particularly if the editor role has a high personnel
    turnover and/or does not document clearly its software features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的文本定义可能会引起一些麻烦，因为文本的不精确性和知识随时间过时的可能性，它容易产生近似，尤其是如果编辑角色有高的人员流动率且/或没有清楚地记录其软件功能。
- en: 'Since pure RBAC is quite restrictive, applications often allow for the direct
    mapping of granular permissions to users or groups, as schematized here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纯RBAC相当限制性，应用程序通常允许直接将细粒度权限映射到用户或组，如下所示：
- en: '![Figure 13.12 – Fine-grained permission as an improvement on RBAC](img/Figure_13.12_B21293.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 作为RBAC改进的细粒度权限](img/Figure_13.12_B21293.jpg)'
- en: Figure 13.12 – Fine-grained permission as an improvement on RBAC
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 作为RBAC改进的细粒度权限
- en: This extends the possibilities, but it also makes it much more difficult for
    functional administrators to keep track of the rights given to different users
    if these cases become more than just exceptions. As the number of users increases,
    the use of groups and roles becomes more and more important. The temptation to
    delegate some rights administration responsibility increases as well, but it is
    essential to implement this with rigid rules and train people carefully, as it
    can quickly become a mess, where users with the same job title end up with different
    rights, depending on who has given them these rights. Even worse, some users end
    up with full permissions on the software because the new functional administrator
    does not understand precisely how the rights management system works. This is
    yet another reason to not give this responsibility to IT, however tempting this
    may be, because they would have control of the technical part of the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩展了可能性，但同时也使得功能管理员在情况超过仅仅例外时，跟踪赋予不同用户的权利变得更加困难。随着用户数量的增加，使用组和角色变得越来越重要。将一些权利管理责任委托出去的诱惑也随之增加，但必须用严格的规则来实施，并仔细培训人员，因为事情可能会迅速变得混乱，拥有相同职位名称的用户最终会拥有不同的权利，这取决于谁赋予了他们这些权利。更糟糕的是，一些用户最终获得了对软件的完全权限，因为新的功能管理员并不完全理解权限管理系统是如何工作的。这又是另一个原因，不要将这项责任交给IT部门，尽管这可能很有诱惑力，因为他们将控制应用程序的技术部分。
- en: 'Another, more sophisticated, way to extend the RBAC features is to shift to
    what is called **Attribute-Based Access Control** (**ABAC**). In this rights management
    paradigm, rules are set that link attributes from the identification to attributes
    of the resources:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种扩展RBAC功能更复杂的方法是转向所谓的**基于属性的访问控制**（**ABAC**）。在这个权利管理范式中，会设置一些规则，将标识符的属性与资源的属性相链接：
- en: '![Figure 13.13 – An ABAC approach](img/Figure_13.13_B21293.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13 – ABAC方法](img/Figure_13.13_B21293.jpg)'
- en: Figure 13.13 – An ABAC approach
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – ABAC方法
- en: This allows us, for example, to overcome the limitations that would happen with
    RBAC in our sample `DemoEditor` information system, if authors simply added a
    `book-edition` role. Indeed, this role would either give them the right to read
    and write books, `books` resource but not specific books.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够，例如，克服在样本`DemoEditor`信息系统中使用RBAC时可能遇到的限制，如果作者只是添加了一个`book-edition`角色。实际上，这个角色要么会给他们阅读和编写书籍的权利，`books`资源但不限于特定的书籍。
- en: 'This is a job for ABAC, and the attributes it would use are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是ABAC的工作，它将使用的属性如下：
- en: '![Figure 13.14 – An ABAC implementation with a BRMS](img/Figure_13.14_B21293.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14 – 带有BRMS的ABAC实现](img/Figure_13.14_B21293.jpg)'
- en: Figure 13.14 – An ABAC implementation with a BRMS
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 带有BRMS的ABAC实现
- en: You will notice that permissions are still represented – and we could include
    roles as well – because ABAC is not exclusive of RBAC but, rather, complements
    it in its forthcoming.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到权限仍然被表示出来——我们也可以包括角色——因为ABAC并不是排斥RBAC，而是在其未来发展中与之相辅相成。
- en: 'What would happen technically in such a scenario is the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，技术上会发生以下情况：
- en: An application would call the `GET` verb on `/api/books/978-2409002205`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序会在`/api/books/978-2409002205`上调用`GET`动词。
- en: This request would be accompanied by a bearer-based authentication header.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个请求会伴随着基于令牌的认证头。
- en: The JWT token would include the custom attribute providing the author internal
    identifier (or another way to go would be to base the association to the author
    on the email or another standard attribute).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT令牌将包括提供作者内部标识符的自定义属性（或者另一种方法是将作者关联基于电子邮件或另一个标准属性）。
- en: Upon reception of this request, the books referential service application would
    call the authorization central API, providing it with everything it knows about
    the request – the incoming JWT-born identity, the attributes of the book requested,
    and so on.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收到这个请求后，图书参考服务应用程序会调用授权中心API，并向它提供它所知道的所有关于请求的信息——传入的JWT生成的身份，请求的图书属性等等。
- en: The authorization app would find the rule that applies to the situation – in
    this case, `GET` on a book.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权应用程序会找到适用于该情况的规则——在这种情况下，对书籍的`GET`操作。
- en: It would first check that the incoming user has `author_id` and that this is
    the ID associated with one of the authors of the given book (looking at the `book_mainauthor_id`
    attribute and – if necessary – the `book_secondaryauthors_ids` array of attributes).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它首先会检查传入的用户是否有`author_id`，并且这个ID与给定书籍的作者之一相关联（查看`book_mainauthor_id`属性，如果需要，还可以查看`book_secondaryauthors_ids`属性数组）。
- en: It would then check that the initial request to the book referential service
    does not contain something such as `$expand=release-information`, since this data
    will not be seen by the author.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它会检查最初的请求到书籍参考服务不包含像`$expand=release-information`这样的内容，因为作者将看不到这些数据。
- en: It would realize it needs to check that the author has not been blocked and
    would call a `GET` request to `/api/authors/x24b72`. This would be done with a
    privileged account with full read rights, as we consider that the BRMS has a justified
    “right to know” due to its function in the system.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会意识到需要检查作者没有被阻止，并调用一个`GET`请求到`/api/authors/x24b72`。这将使用具有完全读权限的特权账户进行，因为我们认为BRMS由于其系统中的功能，有正当的“知情权”。
- en: An alternative to this would be for the books referential service to provide
    an extended view of the book, just as if there had been a call to `/api/books/978-2409002205?$expand=authors`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为这种方法的替代方案，书籍参考服务可以提供书籍的扩展视图，就像调用`/api/books/978-2409002205?$expand=authors`一样。
- en: For most advanced authorization systems, these three checks would be done in
    parallel to save time.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数高级授权系统，这三个检查会并行进行以节省时间。
- en: If everything is correct, the BRMS will send a `200 OK` HTTP response to the
    call from the books referential service.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一切正常，BRMS将向书籍参考服务的调用发送`200 OK` HTTP响应。
- en: The book referential service would then grant the requested access.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，书籍参考服务会授予请求的访问权限。
- en: Of course, if anything goes wrong in these steps, the request will be refused
    with a `403 Forbidden` status code. This could happen if the rules are not respected,
    but also if the BRMS system does not respond in time. This behavior is expected,
    as the so-called “graceful degradation” would imply, for security reasons, that
    the system does not take any risk to disclose date data or allow any operation
    if it is not sure it is allowed. This means that the authorization is another
    SPOF in the system and should be operated corresponding to this requested level
    of service.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果这些步骤中发生任何错误，请求将被拒绝，并返回`403 Forbidden`状态码。这可能发生在规则不被遵守的情况下，也可能发生在BRMS系统没有及时响应的情况下。这种行为是预期的，因为所谓的“优雅降级”意味着，出于安全原因，系统不会冒任何风险来披露数据或允许任何操作，如果它不确定这是否被允许。这意味着授权是系统中的另一个SPOF（单点故障），应该按照这个请求的服务级别进行操作。
- en: I hesitate to discuss **ReBAC** (**Relationship-Based Access Control**), which
    looks like a nice complement to the RBAC and ABAC paradigms but, at the time of
    writing, has not yet reached a mature enough state. In a nutshell, the principle
    of ReBAC is to manage authorizations based on links between entities; hence, it
    has a strong link to DDD. For example, this approach allows you to easily give
    writing permission to an author on their books while keeping the books of other
    authors with read-only permissions. This can, of course, also be done with ABAC,
    but ReBAC makes it a little bit simpler, by basing its functioning on relationships
    instead of simply attributes. To read a bit more about ReBAC, you can start at
    [https://en.wikipedia.org/wiki/Relationship-based_access_control](https://en.wikipedia.org/wiki/Relationship-based_access_control)
    and then check what OSO states about this mode at [https://www.osohq.com/academy/relationship-based-access-control-rebac](https://www.osohq.com/academy/relationship-based-access-control-rebac).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我犹豫是否要讨论**ReBAC（基于关系的访问控制**），它看起来是RBAC和ABAC范式的良好补充，但在撰写本文时，它尚未达到足够成熟的阶段。简而言之，ReBAC的原则是基于实体之间的链接来管理授权；因此，它与DDD有很强的联系。例如，这种方法允许你轻松地给某位作者在其书籍上赋予写权限，同时保持其他作者的书籍只有只读权限。当然，这也可以用ABAC来实现，但ReBAC通过基于关系而不是简单地基于属性来运作，使其变得稍微简单一些。要了解更多关于ReBAC的信息，你可以从[https://en.wikipedia.org/wiki/Relationship-based_access_control](https://en.wikipedia.org/wiki/Relationship-based_access_control)开始，然后查看OSO关于这种模式的观点[https://www.osohq.com/academy/relationship-based-access-control-rebac](https://www.osohq.com/academy/relationship-based-access-control-rebac)。
- en: OpenFGA ([https://openfga.dev/](https://openfga.dev/)) is also a project that
    is worth looking at if you need a clean external authorization management system
    that is ReBAC-capable. Although still nascent, the project has already been referenced
    as a Cloud Native Computing Foundation project. If you want to check out what
    it could do for your authorization needs, one of the best ways to start is to
    tweak the samples provided in the sandbox ([https://play.fga.dev/sandbox](https://play.fga.dev/sandbox)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFGA（[https://openfga.dev/](https://openfga.dev/））也是一个值得关注的开源项目，如果你需要一个干净的外部授权管理系统，并且支持ReBAC。尽管它还处于起步阶段，但该项目已经被引用为云原生计算基金会项目。如果你想了解它能为你的授权需求做什么，最好的开始方式之一是调整沙盒中提供的示例（[https://play.fga.dev/sandbox](https://play.fga.dev/sandbox)）。
- en: The XACML approach
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XACML方法
- en: Now that the different organizations of rights management have been discussed,
    we will start discussing a bit more about implementation and, by now, you will
    certainly have started wondering what kind of norms and standards are available
    to us. Since we have discussed the different steps to realize an ABAC implementation,
    it would be interesting to study one of the most complete specifications and explain
    how it would fit into these ABAC steps.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了不同组织形式的权利管理，我们将开始讨论更多关于实现的内容，到现在，你肯定已经开始思考我们有哪些规范和标准可供选择。由于我们已经讨论了实现ABAC的步骤，研究最完整的规范之一并解释它如何适应这些ABAC步骤将很有趣。
- en: '**XACML** (**eXtensible Access Control Markup Language**) specifies how access
    control can be executed and administered. It is one of the most advanced ways
    to handle authorization and establishes five different responsibilities to do
    so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**XACML**（**可扩展访问控制标记语言**）指定了如何执行和管理访问控制。这是处理授权的最先进方法之一，它建立了五个不同的责任来实现这一点：'
- en: The policy administration point is where rules are defined
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略管理点是定义规则的地方
- en: The policy retrieval point is where they are stored
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略检索点是它们存储的地方
- en: The policy decision point is the engine that decides which decision should be
    taken
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略决策点是决定应该采取哪个决策的引擎
- en: The policy information point is where additional attributes that are necessary
    for rule evaluation are gathered
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略信息点是收集用于规则评估的必要附加属性的地方
- en: The policy enforcement point is the place where the result of the decision is
    applied
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略执行点是应用决策结果的地方
- en: 'How these five responsibilities are spread across one or many applications
    defines how sophisticated a system will be. In the most simple approach, all five
    responsibilities can be implemented inside the data referential service that ultimately
    has to apply the enforcement point (since the data referential service is the
    one who owns the data, this cannot be externalized). In this mode, the data referential
    service not only stores the data but also stores the rules, executes them, and
    decides what it should do depending on the outcome. The only instance in which
    a responsibility could still be considered as external is if the referential service
    needs some external data, but it could very well store that as well. In this case,
    the responsibilities are affected like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个责任如何在单个或多个应用程序中分布，定义了系统的复杂程度。在最简单的方法中，所有五个责任都可以在最终必须应用执行点的数据引用服务中实现（因为数据引用服务是拥有数据的一方，所以不能外部化）。在这种模式下，数据引用服务不仅存储数据，还存储规则，执行它们，并根据结果决定应该做什么。唯一可能仍然被视为外部责任的情况是，如果引用服务需要一些外部数据，但它也可以很好地存储这些数据。在这种情况下，责任会受到以下影响：
- en: '![Figure 13.15 – All authorization responsibilities integrated into an application](img/Figure_13.15_B21293.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15 – 所有授权责任集成到应用程序中](img/Figure_13.15_B21293.jpg)'
- en: Figure 13.15 – All authorization responsibilities integrated into an application
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 – 所有授权责任集成到应用程序中
- en: 'By contrast, this is how we could spread the responsibilities in the previous
    organization of responsibilities we discussed previously:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这是我们之前讨论的责任组织形式中如何分配责任的方式：
- en: '![Figure 13.16 – Authorization responsibilities completely spread across dedicated
    services](img/Figure_13.16_B21293.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图13.16 – 授权责任完全分散到专用服务中](img/Figure_13.16_B21293.jpg)'
- en: Figure 13.16 – Authorization responsibilities completely spread across dedicated
    services
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 – 授权责任完全分散到专用服务中
- en: 'In this very clean (but, of course, more expensive to set up) approach, each
    responsibility is completely separated, and the BRMS and data referential service
    work together in order to orchestrate them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种非常干净（但当然，设置成本更高）的方法中，每个责任都是完全分离的，BRMS和数据参考服务一起工作，以协调它们：
- en: Before any first interaction, a functional user connects to the PAP and designs
    the rules (just like what was done in the example previously with the DMN use).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何第一次交互之前，一个功能性的用户连接到PAP并设计规则（就像之前在DMN使用示例中所做的那样）。
- en: These rules are stored in the associated database, which is the PRP.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些规则存储在相关的数据库中，即PRP。
- en: The books referential service receives the initial request. It cannot make decisions
    on its own and delegates the PDP.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考书籍的服务接收初始请求。它不能自行做出决定，并将PDP委托出去。
- en: It communicates to the deployed BRE the context of the call, in order to get
    a decision from it.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将调用部署的BRE的调用上下文，以便从中获取决定。
- en: The PDP needs to retrieve the rules in order to process them. It could call
    the PRP, but luckily, it has a local clone in our case, where we made the hypothesis
    that the JBPM server has been used and the console deployed a standalone runtime
    container for the rules execution.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDP需要检索规则以便处理。它可以调用PRP，但幸运的是，在我们的情况下，它有一个本地副本，我们假设使用了JBPM服务器，控制台部署了一个用于规则执行的独立运行时容器。
- en: The PDP may also need some additional information that it could collect through
    the PIP, which retrieves the `blocked` status for the author.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDP可能还需要一些额外的信息，它可以通过PIP收集，以检索作者的`blocked`状态。
- en: The PDP sends the result of its rules decision engine back to the books referential
    service.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDP将其规则决策引擎的结果发送回参考书籍的服务。
- en: As with the PEP, the books referential service uses the decision sent by the
    PDP to allow (or not) access to its data and possibly respond to the HTTP response
    that was presented.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与PEP一样，参考书籍的服务使用PDP发送的决定来允许（或不允许）访问其数据，并可能响应所呈现的HTTP响应。
- en: Before we show you a practical example of how to set this up, let me make another
    digression, this time on how services should be separated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向您展示如何设置此配置的实际示例之前，让我再进行一次小插曲，这次是关于服务应该如何分离。
- en: A digression on the granularity of microservices
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于微服务粒度的小插曲
- en: First of all, let’s draw a diagram for a less sophisticated and more common
    situation, where each data referential service contains its own PRP and PDP in
    addition to the PEP. In this case, the PAP is generally minimal, as rules are
    integrated into the code and do not allow for easy management, which means that
    PRP is simply the code base itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为一种不太复杂且更常见的情况绘制一个图表，其中每个数据参考服务除了PEP外还包含自己的PRP和PDP。在这种情况下，PAP通常是最低限度的，因为规则集成到代码中，不允许轻松管理，这意味着PRP仅仅是代码库本身。
- en: '![Figure 13.17 – The problem of authorization management when data is cloned](img/Figure_13.17_B21293.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图13.17 – 数据克隆时的授权管理问题](img/Figure_13.17_B21293.jpg)'
- en: Figure 13.17 – The problem of authorization management when data is cloned
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 – 数据克隆时的授权管理问题
- en: 'Can you spot the potential problem? The books referential service does not
    hold the author’s PDP/PRP, which is logical, since it is not responsible for it.
    However, it still stores a clone of the author’s data in order to quickly respond
    to API calls such as `/api/books/978-2409002205?$expand=authors`. This means that,
    since it does not know how to filter this kind of data, it might create a breach
    of confidential data if care is not taken. In a four-layer diagram, this problem
    can be seen from a strange misalignment that appears this way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现潜在的问题吗？参考书籍的服务不持有作者的PDP/PRP，这是合乎逻辑的，因为它对此不负责。然而，它仍然存储了作者数据的副本，以便快速响应如`/api/books/978-2409002205?$expand=authors`之类的API调用。这意味着，由于它不知道如何过滤这类数据，如果不小心处理，可能会造成机密数据的泄露。在四层图中，这个问题可以从一个奇怪的错位中看出，如下所示：
- en: '![Figure 13.18 – A representation of the authorization antipattern in the four-layer
    diagram](img/Figure_13.18_B21293.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图13.18 – 四层图中授权反模式的表示](img/Figure_13.18_B21293.jpg)'
- en: Figure 13.18 – A representation of the authorization antipattern in the four-layer
    diagram
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – 四层图中授权反模式的表示
- en: This kind of misalignment arises from the fact that authorization has been trusted
    by the application that stores the data. This way, since the data is duplicated,
    there are in fact two potentially different ways to apply authorization to the
    same data! This situation can also happen when we externalize data in a BRMS because
    the runtime and the PAP may not be synchronized, but the advantages in this case
    are much more important than the actual drawbacks. Indeed, the decoupling between
    the JBPM console and the BRE runtime container bears lots of added value – the
    console is a complex server whereas the runtime container is very light; it is
    much better to separate them because errors are prone to happen in the first,
    whereas the second one should have an excellent level of service. When the console
    is used to deploy a standalone server, it can then crash without this being a
    problem. The runtime, conversely, can be made extremely robust, since it is stripped
    of almost every bit of code that is not immediately necessary to execute the functions.
    The fact that the console deploys versions of the rulesets makes it possible to
    create as many runtime servers as needed for performance reasons (thus, you also
    avoid the SPOF problem, since this service is required by many others and should
    be extremely stable) without any risk of a lack of consistency, which would be
    a big problem (imagine explaining to your customers that their rights of access
    to their tenant data vary on every new request).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不匹配源于数据存储应用程序信任了授权。这种方式，由于数据被重复，实际上存在两种可能不同的方式来对相同的数据应用授权！这种情况也可能发生在我们在 BRMS
    中外部化数据时，因为运行时和 PAP 可能没有同步，但在这个情况下，优势远比实际缺点更重要。事实上，JBPM 控制台和BRE 运行时容器之间的解耦带来了很多附加价值——控制台是一个复杂的服务器，而运行时容器非常轻量；将它们分开是更好的选择，因为错误更容易在第一个中发生，而第二个应该有出色的服务水平。当控制台用于部署独立服务器时，它可能会崩溃，但这不会成为问题。相反，运行时可以变得极其健壮，因为它去除了几乎所有不是立即执行函数所必需的代码。控制台部署规则集版本的事实使得可以根据性能需求创建所需数量的运行时服务器（因此，你也避免了单点故障问题，因为这项服务被许多其他服务所需要，并且应该非常稳定），而不会存在任何一致性问题，这会是一个大问题（想象一下向你的客户解释他们的租户数据访问权在每次新请求中都会变化）。
- en: Still, this does not mean that all responsibilities should always be added to
    as many services and different processes as possible. Of course, it may be useful,
    but, as is often the case in information architecture, the most important thing
    is to strike the right balance. There have been so many pointless discussions
    on the internet over which is best between microservices and monolith applications
    that you can almost surmise the quality of an article just by looking at its title.
    Of course, the only correct response to what is best is, “*It depends,*” and any
    competent software architect knows that this is not a “one-size-fits-all” situation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着应该尽可能地将所有责任添加到尽可能多的服务和不同的流程中。当然，这可能是有用的，但正如在信息架构中经常发生的那样，最重要的是找到正确的平衡点。互联网上关于微服务和单体应用哪种更好的无意义讨论已经太多了，你几乎可以通过查看文章标题来推测文章的质量。当然，对“什么才是最好的”的唯一正确回答是，“*这取决于*”，任何合格的软件架构师都知道这并不是一个“一刀切”的情况。
- en: '![Figure 13.19 – Service granularity advantages and drawbacks](img/Figure_13.19_B21293.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.19 – 服务粒度优缺点](img/Figure_13.19_B21293.jpg)'
- en: Figure 13.19 – Service granularity advantages and drawbacks
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.19 – 服务粒度优缺点
- en: I realize I have been saying this every chapter or so, but it’s worth repeating
    – what should be a priority in the granularity of services for business functions?
    If you know that the authorization rules change very rarely and having to wait
    for a new release is not a problem, then implement what should be a priority in
    the granularity of services for business functions directly in the code of the
    associated referential service; you will get the best performance, and you only
    will have to deal with the problem of securing cloned data if you have some. If
    it is an issue, consider calling the other referential service if there is any
    doubt; it will also be a way to refresh part of your cloned data. Conversely,
    if you can foresee that authorization rules are going to change frequently or
    there are external circumstances, such as regulation, then consider progressively
    extracting responsibilities from your data referential service. Foreseeing this
    kind of thing is admittedly a fine line between over-anticipating and adopting
    too much of a DRY approach, but this is where judgment, long-time expertise, and
    having suffered from many previous experiences come in handy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到我每隔一章就会说这句话，但重复一遍是有价值的——在业务功能的粒度中，什么应该是优先考虑的？如果你知道授权规则很少改变，并且等待新版本发布不是问题，那么可以直接在相关参考服务的代码中实现业务功能粒度中应该优先考虑的部分；这将带来最佳性能，并且如果你有克隆数据，你只需处理数据安全的问题。如果有问题，考虑在有任何疑问时调用其他参考服务；这也会是刷新你部分克隆数据的一种方式。相反，如果你可以预见授权规则将频繁更改或存在外部情况，例如法规，那么考虑逐步从你的数据参考服务中提取责任。预见这类事情确实是在过度预测和采用过多DRY（Don't
    Repeat Yourself）方法之间的一条细线，但这就是判断、长期的专业知识和从许多先前经验中吸取教训发挥作用的地方。
- en: Applying authorization to our sample information system
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将授权应用于我们的示例信息系统
- en: XACML was explained previously but is quite a complex mechanism to put in place.
    Also, there is not a reference implementation of the protocol, although several
    products exist such as WSO², Balana, Axiomatics, or products from AT&T. Although
    these all have their place in big information systems such as banks or insurance,
    they would be oversized for the small information system that we have decided
    to simulate in our example, so we are going to use something lighter and closer
    to the main internet protocols.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: XACML之前已经解释过了，但它是实施起来相当复杂的机制。此外，虽然存在几个产品，如WSO²、Balana、Axiomatics或AT&T的产品，但没有协议的参考实现。尽管这些产品在银行或保险等大型信息系统中都有自己的位置，但它们对于我们决定在示例中模拟的小型信息系统来说可能过大，因此我们将使用更轻量级且更接近主要互联网协议的方案。
- en: The Open Policy Agent alternative
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Open Policy Agent的替代方案
- en: Open Policy Agent is a project that is supported by the Cloud Native Computing
    Foundation and that proposes a nice decoupling between grammar to describe policies.
    In short, OPA is to XACML what REST is to SOAP – a lightweight alternative that
    takes on 80% of the job with 20% of the complexity. Instead of installing a full-blown
    XACML server to show an example of externalizing the authorization responsibility,
    we are going to use Docker to customize an authorization engine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Open Policy Agent是一个由云原生计算基金会支持的项目，它提出了描述策略语法的良好解耦。简而言之，OPA对于XACML就像REST对于SOAP一样——一个轻量级的替代方案，以20%的复杂性完成80%的工作。为了展示如何将授权责任外部化，我们不会安装完整的XACML服务器，而是将使用Docker来定制一个授权引擎。
- en: OPA uses a declarative language named `Rego` to describe the policies that should
    be applied to data to make decisions. It can then execute these policies to provide
    JSON results that can be exploited in other services, or another part of the code
    if you use the OPA implementation as a component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: OPA使用名为`Rego`的声明性语言来描述应用于数据以做出决策的策略。然后它可以执行这些策略，提供JSON结果，这些结果可以在其他服务或如果你使用OPA实现作为组件的情况下被利用。
- en: 'Technically, what will happen is that a request like the following will be
    sent to OPA, and it will respond with whether the requested access should be authorized
    or not:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，将会发送如下请求到OPA，并且它会响应请求的访问是否应该被授权：
- en: '[PRE0]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, the user `jpgou` requests full access to the `content` petal
    of the book, identified under the ISBN number `978-2409002205` in the system.
    If this is granted by the OPA server, it will respond with something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户`jpgou`请求对书籍的`content`花瓣的完全访问权限，该书籍在系统中的ISBN号为`978-2409002205`。如果OPA服务器批准了这个请求，它将响应如下：
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before diving into the technology again, we need to be precise about what we
    want to achieve from a functional point of view.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次深入研究技术之前，我们需要明确从功能角度我们想要实现什么。
- en: The functional needs of DemoEditor
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DemoEditor 的功能需求
- en: Let’s return to our `DemoEditor` sample and describe what should be done from
    the authorization’s point of view. Of course, in a publishing company, authors
    have permission to provide the content of books and adjust it as they will, but
    they should never be able to read the content of another author’s book, in order
    to avoid plagiarism or even intellectual property theft. Since there are editors
    who take care of authors, it is logical that they can at least read the content
    of the books from the authors they manage. Salespersons, on the other hand, do
    not have any editing responsibility, so they may know some information about the
    book to prepare sales and orders but have no reason to know anything about the
    editing process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `DemoEditor` 示例，并描述从授权的角度应该做什么。当然，在一家出版社，作者有权限提供书籍内容并根据需要调整，但他们绝不应该能够阅读另一位作者书籍的内容，以避免剽窃甚至知识产权盗窃。由于有编辑负责作者，因此他们至少可以阅读他们管理的作者的书的内容，这是合乎逻辑的。另一方面，销售人员没有任何编辑责任，所以他们可能只知道一些关于书籍的信息来准备销售和订单，但没有理由了解任何关于编辑过程的信息。
- en: In this short description of the stakes at play in the rights management of
    `DemoEditor`, it is quite clear that pure RBAC will not be enough, and we will
    have to resort to ABAC to complete RBAC since there are rules based on the attributes
    of the book, namely who is the author, and even other information such as the
    link between authors and their editors. RBAC is simply not enough because an author
    has more rights on their own books than on the ones from a different author, although
    they both will benefit from the `author` authorization profile.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `DemoEditor` 权限管理中涉及的风险的简要描述中，很明显，纯RBAC将不足以满足需求，我们必须求助于ABAC来补充RBAC，因为存在基于书籍属性的规则，即谁是作者，甚至其他信息，如作者与其编辑之间的联系。RBAC本身是不够的，因为作者对自己书籍的权利比对其他作者书籍的权利更大，尽管他们都将从
    `author` 授权配置文件中受益。
- en: As will be explained in more detail in the following section, we will also add
    a few rules, such as the fact that salespersons can only see the book once it
    has reached a certain status, or another one allowing us to block the rights for
    an author that does not respect the editing contract and should be denied permissions.
    To do so, we will use the same metaphor that we used in [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318),
    where designating the different categories of data for books is like placing them
    in the petals of a flower, the core of which contains the most important, entity-defining
    data, such as the ISBN number and the title of the book. Although it may be tempting
    to define these petals based on the authorization rules, it is important to keep
    in mind they have to be drawn from functional constraints, and authorization management
    is one of them, but still only one of them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如下文将更详细地解释，我们还将添加一些规则，例如销售人员只能看到书籍达到一定状态后才能看到，或者另一个规则允许我们阻止不遵守编辑合同的作者的权利，并应拒绝其权限。为此，我们将使用我们在
    [*第9章*](B21293_09.xhtml#_idTextAnchor318) 中使用的相同隐喻，即为书籍的不同类别数据指定，就像将它们放在花朵的花瓣中，其中最核心的部分包含最重要的、定义实体的数据，如书籍的ISBN号码和标题。虽然根据授权规则定义这些花瓣可能很有吸引力，但重要的是要记住它们必须从功能约束中提取，而授权管理就是其中之一，但仍然只是其中之一。
- en: Creating the authorization policies
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建授权策略
- en: 'Starting with the definition of the authorization policies will allow us to
    do two things simultaneously:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义授权策略开始，将允许我们同时做两件事：
- en: Explain what kind of authorization behavior we intend to put in place and how
    the data referential service for the books should work
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释我们打算实施哪种授权行为以及书籍的数据引用服务应该如何工作
- en: Explore some of the `Rego` syntax and what is at play when externalizing authorizations
    with such a mechanism
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索一些 `Rego` 语法以及使用这种机制外部化授权时涉及的内容
- en: 'When writing the `policy.rego` file (just an arbitrary name) for the authorization
    management of the books data referential service, we need to start with a package
    name, which allows us to separate rules from different groups when they are executed
    in the same engine. The beginning of the file also contains some instructions
    to import specific keywords and functions (OPA supports plugins and extensions
    of the grammar to ease its use) or prepare data (which we will come back to further
    on in the chapter):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写用于书籍数据引用服务授权管理的`policy.rego`文件（只是一个任意的名称）时，我们需要从包名开始，这允许我们在同一引擎中执行不同组的规则时将规则分开。文件的开始部分还包含一些导入特定关键字和函数（OPA支持插件和语法扩展以简化其使用）或准备数据的说明（我们将在本章后面进一步讨论）：
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The body of the file then generally starts with a pattern where a main authorization
    attribute, which we will call `allow`, is broken down into several finer-grained
    decision policies. What we want to achieve is an authorization engine that, when
    exposed to a type of access, will send as a result whether this access should
    be granted or not. We will come back to this part later when demonstrating how
    to apply the rules engine, but for now, let’s continue with the policy-defining
    file and show how the behavior we discussed will be implemented:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的主体部分通常从一个模式开始，其中主要授权属性，我们将称之为`allow`，被分解为几个更细粒度的决策策略。我们想要实现的是一个授权引擎，当暴露于某种访问类型时，将发送一个结果，表明是否应该授予这种访问。我们将在演示如何应用规则引擎时回到这部分，但现在，让我们继续政策定义文件，并展示我们讨论的行为将如何实现：
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to implement security best practices, access is forbidden by default.
    This allows for what is called “graceful degradation” – if there is a problem
    in the authorization subsystem, it will default to the safest situation. In our
    case, the safest approach is to not allow access, since a lack of availability
    is, of course, less of a problem than disclosing data to a person who should not
    have been able to see it, with all the business consequences such an event could
    have. This is what the first line in the preceding code is about – setting to
    `false` the default value of the `allow` attribute.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实施安全最佳实践，默认情况下禁止访问。这允许所谓的“优雅降级”——如果授权子系统出现问题，它将默认到最安全的情况。在我们的情况下，最安全的做法是不允许访问，因为当然，缺乏可用性比向那些本不应该看到这些数据的人披露数据的问题要小得多，这种事件可能带来的所有商业后果也是如此。这正是前面代码的第一行所涉及的内容——将`allow`属性的默认值设置为`false`。
- en: The second operation states that, in order to make `allow` become `true`, we
    need to pass five different decisions, each of them needing to be evaluated to
    `true`. These decisions are, of course, named in such a way they will be easy
    to understand and debug (setting authorizations correctly is somewhat of a challenge,
    but this will almost never be 100% correct at the first attempt). The rest of
    the file will basically be about detailing these five main decisions, but before
    we declare how they work, we need to prepare some data. Indeed, as we will explain
    in the next section, we need some referential service data in order for the engine
    to make decisions. For example, since we stated that editors should have access
    to books from the authors they coach, there will be an obvious need for the engine
    to know about the links between authors and editors. Some other information, such
    as the status attribute of the book, will also be useful. All this data will mostly
    come from the data referential service to the engine, but it will be basic data,
    and we may glean some information from it before actually using the whole set
    of data to infer decisions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作说明，为了使`allow`变为`true`，我们需要通过五个不同的决策，每个决策都需要评估为`true`。当然，这些决策的命名方式使得它们易于理解和调试（正确设置授权是一项挑战，但几乎永远不会在第一次尝试时就达到100%正确）。文件的其他部分基本上将详细说明这五个主要决策，但在我们声明它们的工作方式之前，我们需要准备一些数据。确实，正如我们将在下一节中解释的，我们需要一些引用服务数据，以便引擎做出决策。例如，既然我们声明编辑应该能够访问他们指导的作者的书，那么引擎了解作者和编辑之间的链接将是一个明显的需求。其他一些信息，如书籍的状态属性，也将是有用的。所有这些数据将主要来自数据引用服务到引擎，但将是基本数据，我们可能在实际使用整个数据集来推断决策之前从中获取一些信息。
- en: 'One such piece of information is the roles the current user owns. As stated
    previously, we will need some bits of RBAC, even if it is not enough. That means
    the user will be linked to some roles, some of them directly and some of them
    through the user belonging to identification groups. The following grammar expresses
    precisely this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一条信息是当前用户拥有的角色。如前所述，我们将需要一些 RBAC（基于角色的访问控制）的片段，即使它不足以满足所有需求。这意味着用户将与一些角色相关联，其中一些是直接关联的，而另一些则是通过属于识别组的用户间接关联的。以下语法精确地表达了这一点：
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Groups can be found in a piece of data called `directory`, by looking at the
    entry in the list designated by the value of the input variable called `user`.
    Once this user is found in the list, the `groups` attribute will provide the list
    of identification groups. These will then be used to retrieve the roles associated
    with the groups, leveraging a collection called `group_mappings`. The same logic
    will be applied to a collection that sends the roles directly applied to a user,
    and the two role lists will simply be merged by the last operation shown in the
    preceding code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 组可以在一个名为 `directory` 的数据块中找到，通过查看由名为 `user` 的输入变量值指定的列表中的条目。一旦在这个列表中找到该用户，`groups`
    属性将提供识别组的列表。然后，这些组将被用来检索与组关联的角色，利用一个名为 `group_mappings` 的集合。相同的逻辑也将应用于直接应用于用户的角色的集合，并且这两个角色列表将通过前面代码中显示的最后一个操作简单地合并。
- en: 'We will also need information about the author potentially associated with
    the user. This is something I have not explained fully yet, briefly mentioning
    the fact that an author uses a user to access the information system from `DemoEditor`
    even if they are not really part of an organization, or at least not employees
    of it. This means that, first, access will have to be provided to them (we will
    come back to how to do this when implementing the associated function). This also
    means that there should be a way somehow to associate these two entities in the
    information system. A method that happens quite often is to use a verified `email`
    attribute to link them together. For the moment, we will just consider that the
    user’s information is contained in the `author` entity. The rule to retrieve the
    association is quite easy to write – it simply loops over the list of authors,
    and if the `user` associated with an author is the one the request for access
    relates to, then the author is the one we are looking for:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要有关可能与用户关联的作者的信息。这对我来说还没有完全解释清楚，只是简要地提到，即使作者实际上不是组织的一部分，或者至少不是其员工，他们也会使用
    `DemoEditor` 访问信息系统。这意味着，首先，必须为他们提供访问权限（我们将在实现相关函数时回到如何做到这一点）。这也意味着，在信息系统中应该有某种方式将这两个实体关联起来。一种相当常见的方法是使用经过验证的
    `email` 属性将它们联系起来。目前，我们只需考虑用户信息包含在 `author` 实体中。检索关联的规则相当容易编写——它只是遍历作者列表，如果与作者关联的
    `user` 是请求访问相关的用户，那么该作者就是我们正在寻找的：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In fact, we should refer to authors rather than just an author because we know
    there will functionally be only one, but technically, we will use a list even
    if the name of the variable remains in the singular form, `user_author`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该提到作者而不是仅仅一个作者，因为我们知道在功能上可能只有一个，但在技术上，我们甚至将使用一个列表，即使变量的名称仍然是单数形式，`user_author`。
- en: 'The same applies to the book that the request talks about, as we need to retrieve
    its ID from the list of data to be able to make some decisions from rules on book
    attributes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于请求中提到的书籍，因为我们需要从数据列表中检索其 ID，以便能够根据书籍属性上的规则做出一些决策：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the case of an author, we also have to retrieve the list of books they are
    the writer of because some rules apply to this as well:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的情况下，我们还需要检索他们作为作者所写的书籍列表，因为一些规则也适用于这一点：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that all the necessary data is collected, we can start discussing the rules
    themselves, taking the five units of rules separately and breaking them down even
    more. The first rule that applies is that permissions should be owned by the user
    associated with the request. It will not be enough to grant access, but this is
    nonetheless a necessary constraint. In order to know whether the user should be
    allowed access to the resource they requested, all accesses provided by roles
    should be studied. If one corresponds to the type of resource and the operation
    requested, then it is a match, and the permission is applied:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有必要的数据都已收集，我们可以开始讨论规则本身，分别考虑五个规则单元，并将它们进一步分解。首先适用的规则是权限应由与请求关联的用户拥有。仅授予访问权限是不够的，但这仍然是一个必要的约束。为了知道用户是否应该被允许访问他们请求的资源，应该研究角色提供的所有访问。如果其中之一对应于请求的资源类型和操作，那么它就是一个匹配项，权限将被应用：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following rule makes it happen that if someone gets a right to `books.content`,
    `books.sales`, or `books.editing` (one of the petals of the flower corresponding
    to the data referential service), then they automatically obtain a right to the
    core of the flower, which is logical, since having access to some data without
    being able to link it to a given entity would not prove to be very useful:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则使得以下情况发生：如果某人获得了`books.content`、`books.sales`或`books.editing`（对应数据引用服务的花朵的一个花瓣），那么他们自动获得花朵核心的权利，这是合乎逻辑的，因为如果能够访问某些数据，但不能将其与特定实体关联，那么这不会非常有用：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we have two rules with the same name (`permission_associated_to_role`)
    instead of two rules with different names inside the same group, there is a big
    difference in processing, as it means that rules are considered to be separate
    by an “or” operator (and not all needs to be true for the result to be true, such
    as what was set up previously for `allow`). Also, we are even going to add a third
    case where this part of the policy should be granted, namely when the access provided
    contains `all` as an operation. In this case, whether the requested operation
    is `read`, `write`, or any other value, it will be granted (at least based on
    this criteria):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个具有相同名称（`permission_associated_to_role`）的规则，而不是在同一组内具有不同名称的两个规则，因此在处理上存在很大差异，这意味着规则被认为是通过“或”运算符分开的（结果为真不需要所有条件都为真，例如之前为`allow`设置的），我们甚至还将添加第三个情况，即当访问提供的内容包含`all`作为操作时，这部分策略应该被授予。在这种情况下，无论请求的操作是`read`、`write`还是任何其他值，都将被授予（至少基于这个标准）：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, the question should be, how is `user_accesses_by_roles` calculated? Well,
    this time, it is a bit more complicated, with a sub-decision that walks through
    some tree-like hierarchy of profiles and their associated accesses, contained
    in the `roles` entity of the data provided. We will return to the definition in
    the next section, but for now, it is important to know that we will use a hierarchy
    to set managers on top, and then salespersons and editors below, and authors under
    their editors. The interesting bit in this approach will be how easy it is to
    make it so that the role above receives all the permissions of the one below in
    the tree. After all, if a salesperson has the right to write the sales values,
    it is logical that their manager has at least the same rights. The syntax is harder
    to read, but do not worry about this, as the OPA documentation is well-written,
    and there are many examples available for even the most convoluted rules:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题应该是，`user_accesses_by_roles`是如何计算的？这次，它稍微复杂一些，有一个子决策会遍历一些树状层次结构，包括在提供的数据的`roles`实体中包含的配置文件及其相关访问。我们将在下一节中返回定义，但就目前而言，重要的是要知道我们将使用一个层次结构来设置经理在顶部，然后是销售人员和平面编辑，以及作者在其编辑之下。这种方法中有趣的部分将是如何使上面的角色在树中接收下面角色的所有权限。毕竟，如果销售人员有权利编写销售值，那么他们的经理至少应该有相同的权利。语法更难阅读，但不要担心这一点，因为OPA文档写得很好，而且有很多示例，即使是复杂的规则也有：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When dealing with the rule stating that an author can only have rights on books
    they are authors of, we need to apply a little trick. As usual, we start by setting
    access to false, in order to respect security best practices. And we will set
    it to `true` if we can follow the link of authoring when in the case of a book
    writer, and also simply in the case where the user is not a book writer. That
    may sound too relaxed a constraint, but remember that this is not the complete
    result. In this case, this is just the piece of decision that is about the link
    between an author and their books; if we are dealing with an editor, this rule
    simply does not apply, but some others will, and all of them need to align in
    order for the final, summarizing decision to be positive. The result is the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理规定作者只能对其所写的书有权利的规则时，我们需要应用一个小技巧。像往常一样，我们首先将访问设置为`false`，以遵守安全最佳实践。如果我们可以在书籍作者的情况下跟随作者链接，或者简单地在这种情况下用户不是书籍作者，我们将将其设置为`true`。这听起来可能过于宽松，但请记住，这并不是完整的成果。在这种情况下，这仅仅是关于作者和他们的书籍之间链接的决策部分；如果我们处理的是编辑，这个规则根本不适用，但其他一些规则将适用，并且所有这些规则都需要一致，以便最终的总结性决策是积极的。结果是以下内容：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By now, you should start to be better accustomed to the `Rego` syntax, but
    the third part of the global authorization scheme still requires some thinking,
    as it needs you to traverse the whole organizational chart in order to retrieve
    the link between editors and “their” authors, since we need to apply the rule
    that an editor only has rights on books from the authors they manage:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该开始更熟悉`Rego`语法，但全球授权方案的第三部分仍然需要一些思考，因为它需要你遍历整个组织结构以检索编辑和“他们”的作者之间的链接，因为我们需要应用规则，即编辑只能对其管理的作者的书有权利：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The fourth part of the global decision is simpler – it considers that salespersons
    cannot see a book if it is not in a published or archived status. Again, in order
    to account for the “or” approach, we need to calculate twice the `readable_for_sales`
    attribute, initially set to `false` for security reasons, respectively for the
    two values of the status allowing access to the salespersons:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 全球决策的第四部分更简单——它认为销售人员如果一本书不在已发布或存档状态，就不能看到这本书。同样，为了考虑到“或”方法，我们需要计算两次`readable_for_sales`属性，最初出于安全原因设置为`false`，分别对应允许销售人员访问的状态值：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The fifth and final part of the decision is even simpler, and we will not explain
    the code, simply the rule – if an author has been blocked, they cannot have any
    access to any book:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 决策的第五和最后一部分甚至更简单，我们不会解释代码，只解释规则——如果一个作者已被阻止，他们不能访问任何书籍：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once syntax is complete, we need a second type of information to make a decision.
    This is what decision data is about.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 语法完成之后，我们需要第二种类型的信息来做出决策。这就是决策数据的内容。
- en: Adding some data in order to make decisions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一些数据以便做出决策
- en: 'We had hinted in the previous section about the fact that data should be provided
    (and even inferred from other data) in order for the rules engine to be able to
    make a decision. Next, we will show what kinds of information we should put in
    place for our example to work. First, we need the definition of roles (remember
    that a role is a set of rights, each composed of a resource type and an operation
    type):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已暗示了数据应提供（甚至从其他数据中推断）以便规则引擎能够做出决策的事实。接下来，我们将展示我们应该为我们的示例设置哪些类型的信息。首先，我们需要角色的定义（记住，角色是一组权利，每个权利由资源类型和操作类型组成）：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding JSON content also defines the notion of `parent`, which creates
    a tree of roles, with, for example, `book-sales` and `book-edition` placed under
    `book-direction`, which means that a director will automatically receive all the
    permissions granted by default to a salesperson *and* the ones granted to editors,
    in addition of course to the ones described directly on the role itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON内容还定义了`parent`的概念，它创建了一个角色树，例如，`book-sales`和`book-edition`被放置在`book-direction`下，这意味着导演将自动获得默认授予销售人员的所有权限，以及授予编辑的权限，当然还包括直接在角色本身上描述的权限。
- en: 'Some data about books will be sent in order to apply some specific rules that
    need this. In the following example, I have shown a list because I tested different
    combinations. In actual use, we could simply send the data associated with the
    only book we request OPA for to decide on its access, and nothing more, in order
    to preserve performance. Here is the associated data:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将有关书籍的一些数据发送，以便应用需要这些数据的特定规则。在以下示例中，我展示了一个列表，因为我测试了不同的组合。在实际使用中，我们可以简单地发送与请求
    OPA 决定访问权限的唯一书籍相关的数据，以保持性能。以下是相关数据：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that the preceding code is not expressed in a JSON array but as a structure.
    The same is true for data about authors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码不是用 JSON 数组表达，而是作为一个结构。关于作者的数据也是如此：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The organizational chart allows us to define who is the big boss (`frfra`),
    define which salespersons and editors are below him (three persons in my example),
    and finally, to place two authors below the editor, codenamed `mnfra`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 组织结构图允许我们定义谁是“大老板”（`frfra`），定义哪些销售人员编辑在他之下（我的例子中有三个人），最后，将两位作者放置在编辑之下，代号 `mnfra`：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then simulate what would be sent by a user directory – for example, the
    groups that each user belongs to. This is somewhat artificial, as we would normally
    extract this for the JWT token that has been passed through identification, but
    this is what we will do when hitting the difficulty in code. For now, we will
    stay quite symbolic with the following tree:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们模拟用户目录可能会发送的内容——例如，每个用户所属的组。这有点人为，因为我们通常会从通过身份验证传递的 JWT 令牌中提取这些信息，但这就是我们在代码中遇到困难时将要做的。现在，我们将保持以下树状结构的象征性：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Of course, now we have the groups, we need the mappings to link them to roles
    in a true RBAC approach:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们有了组，我们需要映射来将它们链接到角色，以实现真正的 RBAC 方法：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And since we have decided to be as complete as possible, we will allow – beyond
    pure RBAC – the possibility to also state some direct association between a user
    and a role, without the group intermediary:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们决定尽可能完整，我们将允许——除了纯 RBAC 以外——也声明一些用户和角色之间的直接关联，而不需要组作为中介：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that everything is set for the server to output some results (rules and
    data), we can go to the next step, which is setting up a real OPA server, feeding
    it with these two files, and trying out some decisions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，服务器可以输出一些结果（规则和数据），我们可以进行下一步，即设置一个真实的 OPA 服务器，用这两个文件给它提供数据，并尝试一些决策。
- en: Deploying a Docker-based OPA server
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 Docker 的 OPA 服务器部署
- en: 'It is so easy to deploy with Docker that we would be asking for trouble not
    using it to test OPA. The command line to run the server is extremely simple:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 部署如此简单，不使用它来测试 OPA 就会麻烦不断。运行服务器的命令行非常简单：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the server is up, we will start with a call to push policy definitions
    in it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，我们将开始调用将其中的策略定义推送到服务器：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another call is used to send the data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个调用发送数据：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we are able to test the OPA server with a simple request that is shown
    in the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够使用以下代码中展示的简单请求来测试 OPA 服务器：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When called with the following command to send this text content to a `POST`-using
    API, the OPA server will send a result in JSON, the rest of the command taking
    care of retrieving only the part of the result we are interested in:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用以下命令将此文本内容发送到使用 `POST` 的 API 时，OPA 服务器将以 JSON 格式发送结果，其余的命令负责检索我们感兴趣的响应部分：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If executed as is, this normally sends `true`, meaning that this context of
    the request is granted by the OPA server. If you get rid of the last part of the
    command and display the whole response, you will get something like the following,
    which is really useful for debugging, since it shows the values for all intermediate
    decisions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接执行，这通常会发送 `true`，意味着请求的上下文由 OPA 服务器授权。如果你删除命令的最后部分并显示整个响应，你将得到如下内容，这对于调试非常有用，因为它显示了所有中间决策的值：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Testing the authorizations
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试授权
- en: These sample authorizations are not very complicated, but the level of complexity
    is enough to be hard to handle manually. There are many specific cases that pose
    questions. For example, if I told you that a manager requests access to the sales
    data of a book that has not been published yet, what do you think would happen?
    And, more importantly, what do you think should happen?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例授权并不复杂，但复杂程度足以手动处理起来困难。有许多具体案例提出了问题。例如，如果我说一位经理请求访问尚未出版的书籍的销售数据，你认为会发生什么？更重要的是，你认为应该发生什么？
- en: Also, the `Rego` syntax has a steep learning curve. Writing the rules presented
    previously took me a few hours, if not a day since I am not a specialist, and
    I am not sure they work exactly the way I think they do.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Rego` 语法的学习曲线很陡峭。编写之前展示的规则花费了我几个小时，如果不是一整天，因为我不是一名专家，而且我不确定它们是否确实按照我预期的那样工作。
- en: This is where having good testers is of utmost importance, and their ability
    to define a testing campaign, find all the corner cases, discuss them with the
    product owners/customers, and so on will be a great help. Such a test campaign
    will be created using a Gherkin syntax (see the following sample scenarios). If
    you use a tool such as SpecFlow, you can create many of these scenarios and test
    them automatically so that every modification to the rules grammar does not break
    anything. Once your complete set of tests is ready, you will obtain a report on
    whether all the series of tests have passed, ultimately reassuring you that all
    modes you have thought of are correct.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么拥有优秀的测试人员至关重要，他们能够定义测试活动，找出所有边缘情况，与产品负责人/客户进行讨论等等，这将非常有帮助。这样的测试活动将使用 Gherkin
    语法创建（见以下示例场景）。如果您使用像 SpecFlow 这样的工具，您可以创建许多这些场景并自动测试它们，以确保规则的语法修改不会破坏任何东西。一旦您的完整测试集准备就绪，您将获得一个报告，显示所有测试系列是否通过，最终让您放心，您考虑到的所有模式都是正确的。
- en: 'In order to install SpecFlow in Visual Studio, follow the instructions at [https://docs.specflow.org/projects/getting-started/en/latest/index.html](https://docs.specflow.org/projects/getting-started/en/latest/index.html).
    Then, you will need to create a project of type `SpecFlow Project`. The result
    will be some classes with examples of how to use SpecFlow, and we are going to
    adapt them to our specific needs, which is to test the authorization rules we
    have set up in OPA. We will use xUnit as the underlying test framework here, but
    you can, of course, modify this to your preferences:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Visual Studio 中安装 SpecFlow，请遵循 [https://docs.specflow.org/projects/getting-started/en/latest/index.html](https://docs.specflow.org/projects/getting-started/en/latest/index.html)
    上的说明。然后，您需要创建一个类型为 `SpecFlow Project` 的项目。结果将是一些示例类，展示如何使用 SpecFlow，我们将根据我们的特定需求对其进行调整，即测试我们在
    OPA 中设置的授权规则。在这里，我们将使用 xUnit 作为底层测试框架，但当然，您可以根据自己的喜好进行修改：
- en: '![Figure 13.20 – Creating a SpecFlow project](img/Figure_13.20_B21293.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.20 – 创建 SpecFlow 项目](img/Figure_13.20_B21293.jpg)'
- en: Figure 13.20 – Creating a SpecFlow project
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20 – 创建 SpecFlow 项目
- en: 'The structure of the project created will be based on a sample called `Calculator`,
    and the very first action is to change the names to fit our own purpose, which
    is to test OPA:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的项目结构将基于一个名为 `Calculator` 的示例，并且第一个动作是将名称更改为符合我们自己的目的，即测试 OPA：
- en: '![Figure 13.21 – The SpecFlow project structure](img/Figure_13.21_B21293.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.21 – SpecFlow 项目结构](img/Figure_13.21_B21293.jpg)'
- en: Figure 13.21 – The SpecFlow project structure
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21 – SpecFlow 项目结构
- en: 'The `OPA.feature` content is, in the first step, modified to the following
    Gherkin content:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，`OPA.feature` 的内容被修改为以下 Gherkin 内容：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This syntax should be easy to read, even for non-developers; the idea of behavior-driven
    development is that functional people are able to express their requirements in
    such a language, called Gherkin (which has many more sophisticated features than
    we show here for simplicity reasons). In order for this Gherkin syntax to be transformed
    into an automated xUnit test, we need to create a correspondence between the lines
    in the scenario and the C# functions that implement this part of the test. This
    is done in the `OPAStepDefinitions.cs` file. For example, for the `Given` and
    `And` keywords (which are of the same notion), the corresponding functions will
    be as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法应该很容易阅读，即使对于非开发者来说也是如此；行为驱动开发的思想是，功能人员能够用这种语言表达他们的需求，这种语言称为 Gherkin（为了简单起见，我们在这里展示了比这更复杂的功能）。为了将这种
    Gherkin 语法转换为自动化的 xUnit 测试，我们需要在场景的行和实现此测试部分的功能的 C# 函数之间建立对应关系。这是在 `OPAStepDefinitions.cs`
    文件中完成的。例如，对于 `Given` 和 `And` 关键字（它们具有相同的概念），相应的函数将如下所示：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the initialization part of the class containing this function, we will,
    of course, have a member to store the books (and other lists for other entities
    needed for the test scenarios):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含此函数的类的初始化部分，我们当然会有一个成员来存储书籍（以及为测试场景所需的其他实体所需的其他列表）：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The corresponding classes contain all that is needed to vary the context of
    the rules. As you can see, the first name and last name of the authors have not
    been integrated into the model, since we have a strong assurance that they cannot
    impact the output of the rules engine:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的类包含所有需要改变规则上下文的内容。正如您所看到的，作者的名字和姓氏尚未整合到模型中，因为我们有充分的信心认为它们不会影响规则引擎的输出：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will allow us, upon calling on the function associated with the `When`
    keyword, to realize the call to the so-called System Under Test (what we want
    to validate is the OPA server, which should have been started and customized with
    the `Rego` content and will listen on port `8181` in our setup):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够在调用与 `When` 关键字关联的函数时，实现所谓的系统测试（我们想要验证的是 OPA 服务器，它应该已经启动并使用 `Rego` 内容进行了定制，并将监听我们设置中的端口
    `8181`）：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final part of the test execution is carried out by the method associated
    with the `Then` keyword, which is the one running the asserts in order to simulate
    an automated test:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行的最后一部分是由与 `Then` 关键字关联的方法执行的，该方法运行断言以模拟自动化测试：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You now can display the Test Explorer by accessing it from the menu or using
    the *Ctrl* + *E* + *T* shortcut. The tests might not display at first, and you
    may have to run the solution generation for them to appear. Once they are displayed,
    you can run the scenarios one by one or simultaneously, and if everything works
    fine, they should confirm the rules work as intended and display everything with
    ticks on circles:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过从菜单访问或使用 *Ctrl* + *E* + *T* 快捷键来显示测试资源管理器。测试可能最初不会显示，您可能需要运行解决方案生成来使它们出现。一旦它们显示出来，您可以逐个或同时运行场景，如果一切正常，它们应该确认规则按预期工作，并在圆圈上显示勾选标记：
- en: '![Figure 13.22 – The results of the SpecFlow tests](img/Figure_13.22_B21293.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.22 – SpecFlow 测试的结果](img/Figure_13.22_B21293.jpg)'
- en: Figure 13.22 – The results of the SpecFlow tests
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22 – SpecFlow 测试的结果
- en: Six scenarios are not a lot for such a complex set of policies, and in the real
    world, a few dozen such scenarios would be welcome to form such a powerful harness
    that everyone would be convinced the system works perfectly as expected. But again,
    since this is not the main subject of the book, we will leave the automated tests
    of authorization rules here. By the way, I showed automated BDD tests created
    with SpecFlow because this is the framework I am used to, but there are alternatives
    that may be more suitable, depending on your needs and context. The important
    thing is not whether you use SpecFlow, Postman, or any other method but that such
    important rules as authorizations should be verified carefully.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 六个场景对于这样一组复杂的策略来说并不多，在现实世界中，几十个这样的场景将受到欢迎，以形成一个强大的测试框架，使每个人都确信系统按预期完美工作。但再次强调，由于这不是本书的主要内容，我们将在这里停止对授权规则的自动化测试。顺便说一句，我展示了使用
    SpecFlow 创建的自动化 BDD 测试，因为这是我习惯的框架，但根据您的需求和上下文，可能还有其他更合适的替代方案。重要的是，您是否使用 SpecFlow、Postman
    或任何其他方法，但重要的是像授权这样重要的规则应该得到仔细验证。
- en: Challenges with OPA
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OPA 面临的挑战
- en: OPA is a great approach to authorization rule implementation, but it still offers
    some challenges.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: OPA 是一种优秀的授权规则实现方法，但它仍然带来了一些挑战。
- en: First of all, there is the complexity of writing rules, as previously discussed.
    Although this is quite logical as we try to fit some complex functional algorithms
    into just a few keywords, it can really be limiting for those trying to adopt
    OPA and the `Rego` syntax, only to be held up by many incorrect attempts at writing
    the right rule.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如之前讨论的那样，编写规则的复杂性。尽管我们试图将一些复杂的函数算法拟合到仅仅几个关键字中，这本身是相当逻辑的，但它确实限制了那些试图采用 OPA
    和 `Rego` 语法的人，他们可能会因为许多错误的规则编写尝试而被阻碍。
- en: 'I personally experienced this, and to be perfectly honest, I still do not really
    understand how the following rule works:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人有过这样的经历，而且坦白说，我仍然不太明白以下规则是如何工作的：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I know that it does because I have tested it, and I can see the point about
    walking through a tree and picking some data of the path, but the additional recurrent
    valuation of `access` combined with the use of the `_` keyword and the `reachable`
    function just make it too hard for me to write this on my own, without referring
    to some examples that others have written. It may be a lack of practice, but I
    have tried my fair share of exotic languages over almost four decades of programming,
    and I still think `Rego` might be one of the most complicated logics I have encountered.
    After a few attempts at using OpenFGA, it may be simpler to provide an equivalent
    authorization rule, but I cannot make a commitment to this, since I have not yet
    used this technology in a production-ready module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这是真的，因为我已经测试过了，我可以看到遍历树并选择路径上一些数据的观点，但是 `access` 的额外递归评估以及 `_` 关键字和 `reachable`
    函数的使用，使得我很难自己编写，除非参考别人写的示例。这可能是因为缺乏实践，但我在近四十年的编程生涯中尝试过许多稀有语言，我仍然认为 `Rego` 可能是我遇到的最复杂的逻辑之一。尝试使用
    OpenFGA 几次后，可能更容易提供等效的授权规则，但我不能对此做出承诺，因为我还没有在生产就绪的模块中使用这项技术。
- en: Luckily, some documentation such as [https://www.openpolicyagent.org/docs/latest/policy-reference/](https://www.openpolicyagent.org/docs/latest/policy-reference/)
    shows advanced examples, and I also found great advanced tips at [https://www.fugue.co/blog/5-tips-for-using-the-rego-language-for-open-policy-agent-opa](https://www.fugue.co/blog/5-tips-for-using-the-rego-language-for-open-policy-agent-opa),
    while links such as [https://medium.com/@agarwalshubhi17/rego-cheat-sheet-5e25faa6eee8](mailto:https://medium.com/@agarwalshubhi17/rego-cheat-sheet-5e25faa6eee8)
    provided some clear explanation on how these complex syntaxes work.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一些文档，例如 [https://www.openpolicyagent.org/docs/latest/policy-reference/](https://www.openpolicyagent.org/docs/latest/policy-reference/)
    展示了高级示例，我还在 [https://www.fugue.co/blog/5-tips-for-using-the-rego-language-for-open-policy-agent-opa](https://www.fugue.co/blog/5-tips-for-using-the-rego-language-for-open-policy-agent-opa)
    找到了一些高级技巧，而像 [https://medium.com/@agarwalshubhi17/rego-cheat-sheet-5e25faa6eee8](mailto:https://medium.com/@agarwalshubhi17/rego-cheat-sheet-5e25faa6eee8)
    这样的链接则对这些复杂语法的工作原理提供了清晰的解释。
- en: Another challenge with OPA might come from the fact that HTTP API calls can
    cause performance problems if done in volume. And if your authorization rules
    are complex, chances are that you will be obliged to apply them to business entities
    one by one. So, how would you handle some calls requesting a list of entities?
    Calling the API hundreds of times or more is not an option. And what is true for
    a local Docker container is even more true for a service in the cloud such as
    OSO ([https://www.osohq.com/](https://www.osohq.com/)) that proposes a SaaS solution
    for authorization rules.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: OPA 的另一个挑战可能来自这样一个事实：大量的 HTTP API 调用可能会导致性能问题。如果你的授权规则很复杂，那么你很可能会被迫逐个应用到业务实体上。那么，你将如何处理请求实体列表的调用呢？调用
    API 成百上千次显然不是可行的选择。而对于本地 Docker 容器来说，这一点对于云服务（如 OSO [https://www.osohq.com/](https://www.osohq.com/)，它提供授权规则的
    SaaS 解决方案）来说更是如此。
- en: Of course, the best approach is still paginating results, which is also good
    not only for ecological reasons, helping to reduce the strain on resources, but
    also for ergonomic reasons, by providing users with screens that are less cluttered
    with data and easier to read and comprehend. However, cases where you need volume
    may remain, and calling an HTTP server many times is not an elegant option anyway.
    Luckily, OPA can be accessed directly from your code if you use the Go language,
    or even as a WebAssembly module, making it possible (although not currently easy)
    to integrate it at the code level from many platforms.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好的方法仍然是分页显示结果，这不仅对生态友好，有助于减轻资源压力，而且从人体工程学角度来看，为用户提供更少数据杂乱、更容易阅读和理解的屏幕。然而，在某些需要大量数据的情况下，多次调用HTTP服务器并不是一个优雅的选择。幸运的是，如果您使用Go语言，可以直接从您的代码中访问OPA，或者甚至作为一个WebAssembly模块，这使得从许多平台在代码级别集成它成为可能（尽管目前并不容易）。
- en: 'Here’s a final thing to note on authorization management – in this chapter,
    you have seen a simplified version of the grammar and data that will be applied
    more realistically in the upcoming chapters. For example, I used simple identifiers
    instead of URN, some attributes were repeated in order to ease rule execution,
    and so on. I could have shown the policies in their final form but considered
    it better to show the work in progress for two reasons:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在授权管理方面，这里有一个需要注意的最终事项——在本章中，您已经看到了将要更真实地应用于后续章节中的语法和数据简化版本。例如，我使用了简单的标识符而不是URN，一些属性被重复使用以简化规则执行，等等。我本可以展示最终形式的策略，但考虑到以下两个原因，我认为展示工作进展状态更好：
- en: Avoiding this additional complexity made it easier to concentrate on the subject
    of authorization rules
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免这种额外的复杂性使得集中精力研究授权规则主题变得更容易
- en: Showing these adjustments at the precise moment we need to make them will hopefully
    also make them more understandable, as the situation will show how the simple
    approach could cause an evolution problem and help explain the change
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们需要做出这些调整的精确时刻展示这些调整，希望也能使它们更容易理解，因为情况将展示简单方法可能导致的演变问题，并有助于解释变化
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed what a Business Rules Management System does, how
    useful it can be in an information system, and how we could implement one, starting
    with a functional example and then demonstrating another example relating to authorizations,
    which are one of the most used sets of business rules in software applications.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了业务规则管理系统的作用，它在信息系统中的有用性，以及我们如何实现它，从功能示例开始，然后演示了与授权相关的另一个示例，授权是软件应用程序中最常用的业务规则集之一。
- en: Just like for BPMN engines, BRMS engines are not used very often. In fact, business
    rules are – in the great majority of cases – implemented in code expressions or
    compiled into applications. This is absolutely normal because a BRMS represents
    an important investment, and implementing such complex applications really needs
    a strong business case, where business rules change very frequently or are associated
    with strict regulatory or marketing constraints, such as the necessity to trace
    all business rules and their changes, the capacity to simulate the effects of
    new versions of sets of business rules, and so on. We can conclude, then, that
    this approach is currently limited to very rare contexts. Things may, of course,
    change in the future, with the industrialization of information system design
    that we really long for, but at the present time, BPMNs and BRMSs are an effort
    that is almost always overkill.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就像BPMN引擎一样，BRMS引擎并不常用。事实上，在绝大多数情况下，业务规则都是通过代码表达式实现的，或者编译到应用程序中。这绝对是正常的，因为BRMS代表了一个重要的投资，而实现如此复杂的应用程序确实需要一个强大的业务案例，其中业务规则频繁变化或与严格的监管或营销约束相关，例如需要跟踪所有业务规则及其变化，能够模拟业务规则集新版本的影响，等等。因此，我们可以得出结论，这种方法目前仅限于非常罕见的情况。当然，随着我们渴望的信息系统设计的工业化，未来事情可能会发生变化，但到目前为止，BPMNs和BRMSs几乎总是过度设计的工作。
- en: And since two of the three parts of the ideal system are not worth using in
    most of an organization, this means this ideal system is really utopic. Moreover,
    even a centralized **Master Data Management** (**MDM**) approach is complicated.
    The MDM practices per se are applicable to every business domain, so there is
    no problem with a data referential service; they are not very complicated to set
    up, as we will see in practice in [*Chapter 15*](B21293_15.xhtml#_idTextAnchor548),
    and they bring lots of business value and advantages. However, the ideal system
    aims for generic MDM, dynamically adjusting to every entity in the business context
    of an application. This step further is also out of the scope of this book, though
    static code generation for a data referential service is becoming a viable option,
    as we will show at the end of [*Chapter 15*](B21293_15.xhtml#_idTextAnchor548).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于理想系统的三个部分中有两个在大多数组织中不值得使用，这意味着这个理想系统实际上是非常乌托邦的。此外，即使是集中式的**主数据管理**（**MDM**）方法也很复杂。MDM实践本身适用于每个业务领域，因此数据参考服务没有问题；它们设置起来并不复杂，正如我们将在[*第15章*](B21293_15.xhtml#_idTextAnchor548)中看到的那样，并且它们带来了大量的商业价值和优势。然而，理想系统追求的是通用的MDM，能够动态地适应应用业务环境中的每个实体。这一步也超出了本书的范围，尽管为数据参考服务生成静态代码正在成为一种可行的选择，正如我们将在[*第15章*](B21293_15.xhtml#_idTextAnchor548)的结尾展示的那样。
- en: 'In addition, we have shown that the three responsibilities of an ideal information
    system are, ultimately, quite entangled with each other:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经表明，理想信息系统的三个职责最终是相互交织的：
- en: MDM uses business rules in its validation of data
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDM在其数据验证过程中使用业务规则
- en: A BRMS needs data from MDM in order to apply the business rules and decide their
    output value
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BRMS需要从MDM获取数据以便应用业务规则并决定其输出值
- en: A BPMN serves mainly as a collector of data to feed the MDM, while also consuming
    data from the MDM
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN主要作为一个数据收集器，为MDM提供数据，同时也从MDM消耗数据
- en: A BPMN also uses business rules in order to know where to go in the different
    gateways (and, sometimes, to calculate some additional data during a given task)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN也使用业务规则来确定在不同网关中的走向（有时，在给定任务期间计算一些额外的数据）
- en: All this proves that, technically, this assembly of three generic servers for
    MDM, a BPMN, and a BRMS is not so feasible, and neither achieves a perfect decoupling.
    So, why did we bother in [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164) and the
    last three chapters to talk about such an ideal system? Again, the answer lies
    in the business/IT alignment. The ideal system is not something that can be realized
    in practice in information systems today (and certainly not for at least a few
    more decades), but it has the great advantage of forcing an architect to think
    in terms of three generic, always applicable, functional responsibilities. Even
    if you use a unique software application, knowing how to separate the data management,
    business rules management, and business process execution provides a great step
    toward decoupling your information system (which is not achieved at all with *n*-tier
    architecture, for example). As you will see in the coming chapters, constructing
    an information system with these principles in mind will help us achieve a very
    complex goal, which is to be able to modify important functional rules and behaviors
    very easily and, in most cases, without any significant impact on the implementation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都证明，从技术上讲，这个由MDM、BPMN和BRMS三个通用服务器组成的组合并不那么可行，也没有实现完美的解耦。那么，为什么我们在[*第5章*](B21293_05.xhtml#_idTextAnchor164)和最后三章中要讨论这样一个理想系统呢？答案再次在于业务/IT的协同。理想系统并不是今天信息系统实践中可以实现的（当然，至少在接下来的几十年内也不可能实现），但它有一个巨大的优势，就是迫使架构师从三个通用、始终适用的功能职责的角度来思考。即使你使用一个独特的软件应用，了解如何分离数据管理、业务规则管理和业务流程执行，也能为解耦你的信息系统迈出重要的一步（例如，*n*-层架构根本无法实现解耦）。正如你将在接下来的章节中看到的，本着这些原则构建信息系统将帮助我们实现一个非常复杂的目标，即能够非常容易地修改重要的功能规则和行为，在大多数情况下，对实施没有显著影响。
- en: In the next chapter, we will use everything we have learned so far to design
    the information system of `DemoEditor`. In the following chapters, we will finally
    get hands-on and implement all the different parts of this information system,
    using C# and .NET as a programming platform and Docker as deployment architecture.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用到目前为止所学的所有知识来设计`DemoEditor`的信息系统。在接下来的章节中，我们将最终动手实现这个信息系统的各个不同部分，使用C#和.NET作为编程平台，以及Docker作为部署架构。
- en: 'Part 3: Building a Blueprint Application with .NET'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：使用 .NET 构建蓝图应用程序
- en: After a theoretical part and one on the architecture principles, we will now
    dive deep into the technical aspects of the method by implementing some important
    parts of the sample information system. We will create some ASP.NET services implementing
    the API contracts and a graphical user interface that uses them and implements
    some of the business processes. Since some features have been externalized to
    bring more industrial-grade quality, we will also show how to interact with these
    modules in a lowly coupled way. Plugging the services into the Apache Keycloak
    IAM, using standards such as OAuth and JWT, will of course be an important step,
    but we will also show electronic document management systems in a standard way
    and talk about many other external services. Finally, the external execution of
    business processes will be shown, with both orchestration and choreographic paradigms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论部分和架构原则部分之后，我们将通过实现示例信息系统的某些重要部分来深入探讨该方法的技术方面。我们将创建一些实现API契约的ASP.NET服务，以及使用这些服务并实现一些业务流程的图形用户界面。由于一些功能已被外部化以提高工业级质量，我们还将展示如何以松耦合的方式与这些模块交互。将服务插入Apache
    Keycloak IAM，使用如OAuth和JWT等标准，当然是一个重要步骤，但我们还将以标准方式展示电子文档管理系统，并讨论许多其他外部服务。最后，将展示业务流程的外部执行，包括编排和协奏范式。
- en: 'This part has the following chapters:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 14*](B21293_14.xhtml#_idTextAnchor503), *Decomposing the Functional
    Responsibilities*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21293_14.xhtml#_idTextAnchor503), *分解功能职责*'
- en: '[*Chapter 15*](B21293_15.xhtml#_idTextAnchor548), *Plugging Standard External
    Modules*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21293_15.xhtml#_idTextAnchor548), *插入标准外部模块*'
- en: '[*Chapter 16*](B21293_16.xhtml#_idTextAnchor588), *Creating a Write-Only Data
    Referential Service*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B21293_16.xhtml#_idTextAnchor588), *创建只写数据引用服务*'
- en: '[*Chapter 17*](B21293_17.xhtml#_idTextAnchor608), *Adding Query to the Data
    Referential Service*'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B21293_17.xhtml#_idTextAnchor608), *向数据引用服务添加查询*'
- en: '[*Chapter 18*](B21293_18.xhtml#_idTextAnchor622), *Deploying Data Referential
    Services*'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B21293_18.xhtml#_idTextAnchor622), *部署数据引用服务*'
- en: '[*Chapter 19*](B21293_19.xhtml#_idTextAnchor634), *Designing a Second Data
    Referential Service*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第19章*](B21293_19.xhtml#_idTextAnchor634), *设计第二个数据引用服务*'
- en: '[*Chapter 20*](B21293_20.xhtml#_idTextAnchor647), *Creating a Graphical User
    Interface*'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第20章*](B21293_20.xhtml#_idTextAnchor647), *创建图形用户界面*'
- en: '[*Chapter 21*](B21293_21.xhtml#_idTextAnchor674), *Extending the Interfaces*'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第21章*](B21293_21.xhtml#_idTextAnchor674), *扩展接口*'
- en: '[*Chapter 22*](B21293_22.xhtml#_idTextAnchor709), *Integrating Business Processes*'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第22章*](B21293_22.xhtml#_idTextAnchor709), *集成业务流程*'
