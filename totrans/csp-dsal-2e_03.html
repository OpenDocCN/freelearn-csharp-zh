<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor088"/>3</h1>
<h1 id="_idParaDest-62"><a id="_idTextAnchor089"/>Arrays and Sorting</h1>
<p>As a developer, you have certainly stored various collections within your applications, such as data of users, books, and logs. One of the natural ways of storing such data is by using arrays. However, have you ever thought about their variants? For example, have you heard about jagged arrays? In this chapter, you will see arrays in action, together with examples and detailed descriptions.</p>
<p>You can use an array to <code>int</code>, <code>string</code>, as well as a user-defined class or record. Just keep in mind that <strong class="bold">the number of elements in an array cannot be changed after initialization</strong>. For this reason, you will not be able to easily add a new item at the end of the array or insert an element in a given position within the array while moving the remaining items one position further. If you need such features, you can use another data structure, namely a list and its variants, which will be described in the following chapter.</p>
<p>While developing applications in the C# language, you can benefit from a few variants of arrays, namely <strong class="bold">single-dimensional arrays</strong>, <strong class="bold">multi-dimensional arrays</strong>, and <strong class="bold">jagged arrays</strong>. In this chapter, you will also get to know seven <strong class="bold">sorting algorithms</strong>, namely <strong class="bold">selection sort</strong>, <strong class="bold">insertion sort</strong>, <strong class="bold">bubble sort</strong>, <strong class="bold">merge sort</strong>, <strong class="bold">Shell sort</strong>, <strong class="bold">quicksort</strong>, and <strong class="bold">heap sort</strong>. For each, you will see an illustration-based example, the implementation code, and a step-by-step explanation. You will also see their performance analysis, presented with charts.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Single-dimensional arrays</li>
<li>Multi-dimensional arrays</li>
<li>Jagged arrays</li>
<li>Sorting algorithms</li>
</ul>
<h1 id="_idParaDest-63"><a id="_idTextAnchor090"/>Single-dimensional arrays</h1>
<p>Let’s start with the simplest variant of arrays, namely single-dimensional ones. <code>0</code>, while the last one has an index equal to the length of the array minus one.</p>
<p class="callout-heading">Imagine a single-dimensional array</p>
<p class="callout">If you want to better imagine a single-dimensional array, take your eyes off this book for a moment and look at the chest of drawers or wardrobe in your room. A standard chest of drawers consists of several drawers and a single-dimensional array looks similar. It also has several elements (as drawers), which are accessible via the index. You cannot change the size of the array in the same way as you cannot change the number of drawers since the furniture is prepared. An array has one significant advantage over a chest of drawers, namely all its “drawers” are always working as expected.</p>
<p>An example of a single-dimensional array is shown in the following figure:</p>
<div><div><img alt="Figure 3.1 – Example of a single-dimensional array" src="img/B18069_03_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Example of a single-dimensional array</p>
<p>It contains five <a id="_idIndexMarker250"/>elements with the following values: <code>9</code>, <code>-11</code>, <code>6</code>, <code>-12</code>, and <code>1</code>. The first element has an index equal to <code>0</code>, while the last one has an index equal to <code>4</code>.</p>
<p>To use a single-dimensional array, you need to declare and initialize it. The declaration is very simple because you just need to <a id="_idIndexMarker251"/>specify a type of element and a name, as follows:</p>
<pre class="source-code">
<strong class="bold">type[]</strong> name;</pre> <p>The declaration of an array with integer values is shown in the following line:</p>
<pre class="source-code">
<code>new</code> operator, as shown here:</p>
<pre class="source-code">
numbers = <strong class="bold">new int[5];</strong></pre> <p>Of course, you can combine a declaration and initialization in the same line, as follows:</p>
<pre class="source-code">
int[] numbers = new int[5];</pre> <p>Unfortunately, all the elements currently have default values – that is, zeros in the case of integer values. Thus, you need to set the values of particular elements. You can do this using the <code>[]</code> operator and an index of an element, as shown in the following code:</p>
<pre class="source-code">
<strong class="bold">numbers[0]</strong> = 9;
<strong class="bold">numbers[1]</strong> = -11;
<strong class="bold">numbers[2]</strong> = 6;
<strong class="bold">numbers[3]</strong> = -12;
<strong class="bold">numbers[4]</strong> = 1;</pre> <p>Moreover, you can combine a declaration and initialization of array elements to specific values using one of the following variants:</p>
<pre class="source-code">
int[] numbers = new int[] { 9, -11, 6, -12, 1 };
int[] numbers = { 9, -11, 6, -12, 1 };</pre> <p>Another approach involves using the <strong class="bold">collection expression</strong>, as follows:</p>
<pre class="source-code">
int[] numbers = <code>[]</code> operator and by specifying the index, as shown in the following line of code:</p>
<pre class="source-code">
int middle = <code>2</code>) from the <code>numbers</code> array and store it as a value of the <code>middle</code> variable.</p>
<p>The array has some properties that can be useful while developing applications. For example, the <code>Length</code> property makes it possible to get the size of the array, namely the number of elements stored within it. If you want to access the last item in the array, regardless of its size, you <a id="_idIndexMarker252"/>can use the following line of code:</p>
<pre class="source-code">
int last = numbers<strong class="bold">[numbers.Length - 1]</strong>;</pre> <p>You can simplify this with the <strong class="bold">index operator</strong>, as follows:</p>
<pre class="source-code">
int last = numbers<code>[^2]</code>, the third by <code>[^3]</code>, and so on.</p>
<p>The other property is named <code>Rank</code> and returns the number of dimensions of the array. Usage of this property is shown in the following line of code:</p>
<pre class="source-code">
int rank = numbers.<code>Array</code> class, such as <code>Exists</code>, to check whether there is any element in the array that matches the given predicate. For example, you can easily verify whether the array contains any element whose value is greater than zero, as follows:</p>
<pre class="source-code">
bool anyPositive = Array.<code>TrueForAll</code> to check whether all elements meet the provided predicate, such as to ensure that there are no zeros in the array:</p>
<pre class="source-code">
bool noZeros = Array.<code>Find</code> method:</p>
<pre class="source-code">
int firstNegative = Array.<code>FindAll</code> method. The following code shows how to get all negative numbers:</p>
<pre class="source-code">
int[] negatives = Array.<code>IndexOf</code> method, which returns an index of the first found occurrence of the value or <code>-1</code>, if not found:</p>
<pre class="source-code">
int index = Array.<code>ForEach</code>. It allows you to perform some operations for all the elements in the array. As an example, you can use it to write the absolute value of each array element in the console, as shown in the following code:</p>
<pre class="source-code">
Array.<strong class="bold">ForEach</strong>(numbers, 
    e =&gt; Console.WriteLine(Math.Abs(e)));</pre> <p>As you can see, even for as simple a data structure as a single-dimensional array, you have a lot of useful built-in features. Let’s continue learning them and take a look at the two next methods, namely <code>Reverse</code> and <code>Sort</code>. According to their names, the first allows you to reverse the order of the elements, either for the whole array or only within some range. This is presented in the following line of code, which reverses the first three elements:</p>
<pre class="source-code">
Array.<code>Sort</code> method has even more variants. In its simplest form, it sorts the whole array. After running the following line, you’ll get the array with the elements sorted from the smallest to the biggest:</p>
<pre class="source-code">
Array.<code>for</code> loop and simply iterate through suitable indices and assign a given value. However, you can use the <code>Fill</code> method instead. The following line places <code>3</code> as a value of all elements in the array:</p>
<pre class="source-code">
Array.<code>Clear</code>, which makes it possible to clear the whole array or a range of its elements. For example, you can fill the whole array with the default value of the integer type, namely zeros, using the following line of code:</p>
<pre class="source-code">
Array.<code>Copy</code>, which copies a range of elements from the source array to the destination array. You can use one out of a few variants, such as to specify indices from both arrays. As an example, let’s copy <code>3</code> elements (specified as <code>length</code>) from the <code>numbers</code> array (as the source array), starting from the first element (source index set to <code>0</code>), and place them in the <code>subarray</code> array, starting from the first element (destination index set to <code>0</code>):</p>
<pre class="source-code">
int[] subarray = new int[3];
Array.<code>Contains</code> and <code>Max</code>.</p>
<p class="callout-heading">Have you ever heard about extension methods?</p>
<p class="callout">If not, think of them as methods that are “added” to a particular existing type (both built-in or user-defined) and can be called in the same way as when they are defined directly as instance methods. The declaration of an extension method requires you to specify it within a static class as a static method with the first parameter indicating the type to which you want to “add” this method with the <code>this</code> keyword.</p>
<p>You can use the <code>Contains</code> extension method to check whether the array contains an element passed as the parameter. As an example, let’s learn how to ensure that the <code>numbers</code> array contains <code>6</code> as one of its elements:</p>
<pre class="source-code">
bool contains = numbers.<code>Contains</code> method is not the only available extension method. Among others, you can find <code>All</code> and <code>Any</code>. The first (<code>All</code>) checks whether all of the elements match the given predicate, while the other (<code>Any</code>) verifies whether at least one element meets the condition. You can use them to ensure that there are no zeros in the array and check whether there is at least one positive element, as shown here:</p>
<pre class="source-code">
bool noZeros = numbers.<strong class="bold">All</strong>(n =&gt; n != 0);
bool anyPositive = numbers.<code>Min</code> and <code>Max</code> extension methods, as shown here:</p>
<pre class="source-code">
int min = numbers.<strong class="bold">Min</strong>();
int max = numbers.<code>Average</code> and <code>Sum</code> methods, which easily calculate the average value <a id="_idIndexMarker256"/>of all of the elements, as well as their sum:</p>
<pre class="source-code">
double avg = numbers.<strong class="bold">Average</strong>();
int sum = numbers.<strong class="bold">Sum</strong>();</pre> <p>After this short introduction to single-dimensional arrays, it’s high time to take a look at an example of how to apply such arrays in real-world scenarios.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find a lot of interesting information about arrays and their various variants in the context of the C# language at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/</a>.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor093"/>Example – month names</h2>
<p>To summarize what you’ve learned<a id="_idIndexMarker257"/> about single-dimensional arrays, let’s use an array to store names of months, written in English. Such names should be obtained automatically, not by hardcoding them in the code.</p>
<p>The implementation is shown here:</p>
<pre class="source-code">
using System.Globalization;
CultureInfo culture = new("en");
<strong class="bold">string[] months = new string[12];</strong>
for (int month = 1; month &lt;= 12; month++)
{
    DateTime firstDay = new(DateTime.Now.Year, month, 1);
    string name = firstDay.ToString("MMMM", culture);
    <strong class="bold">months[month - 1] = name;</strong>
}
<strong class="bold">foreach (string m in months)</strong>
{
    Console.WriteLine(m);
}</pre> <p>First, you create a new instance of the <code>CultureInfo</code> class (from the <code>System.Globalization</code> namespace), passing <code>en</code> as a parameter, to later get the names of months in English. Then, you declare a new single-dimensional array and initialize it with default values. It contains <code>12</code> elements to store the names of all the months in a year. Then, the <code>for</code> loop is <a id="_idIndexMarker258"/>used to iterate through the numbers of all months – that is, from <code>1</code> to <code>12</code>. For each of them, a <code>DateTime</code> instance representing the first day in a particular month from the current year is created.</p>
<p>The name of the month is obtained by calling the <code>ToString</code> method on the <code>DateTime</code> instance, passing the proper format of the date (<code>MMMM</code>), as well as specifying the culture. Then, the name is stored in the array using the <code>[]</code> operator and an index of the element. It is worth noting that the index is equal to the current value of the <code>month</code> variable minus one. Such subtraction is necessary because the first element in the array has an index equal to zero, instead of one.</p>
<p>The next interesting part of the code is the <code>foreach</code> loop, which iterates through all elements of the array. For each of them, the name of the month is shown in the console:</p>
<pre class="console">
January
February (...)
December</pre> <p>As mentioned earlier, single-dimensional arrays are not the only available variant. You will learn more about multi-dimensional arrays in the following<a id="_idTextAnchor094"/><a id="_idTextAnchor095"/> section.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor096"/>Multi-dimensional arrays</h1>
<p>The arrays in the C# language do not <a id="_idIndexMarker259"/>need to have only one dimension. It is possible to create two-dimensional arrays as well. As you will see, multi-dimensional arrays are very useful and are frequently used while developing various applications.</p>
<p class="callout-heading">Imagine a two-dimensional array</p>
<p class="callout">If you want to imagine a two-dimensional <a id="_idIndexMarker260"/>array, take a break, close your eyes, and play Sudoku. If you don’t know what this is, Sudoku is a popular game that requires you to fill empty cells of a 9x9 board with numbers from 1 to 9. However, each row, each column, and each 3x3 box can only contain unique numbers. Surprise – this board forms a two-dimensional array! You can point to any place on the board by specifying its <em class="italic">row</em> and <em class="italic">column</em>, the same as in the case of a two-dimensional array. And if you are a bit tired of solving such puzzles with a pencil and a piece of paper, take a look at <a href="B18069_09.xhtml#_idTextAnchor367"><em class="italic">Chapter 9</em></a>, <em class="italic">See in Action</em>, where you will learn how to create an algorithm for solving a Sudoku puzzle!</p>
<p>An example two-dimensional array that stores integer values is shown here:</p>
<div><div><img alt="Figure 3.2 – Example of a two-dimensional array" src="img/B18069_03_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Example of a two-dimensional array</p>
<p>First, you need to declare and initialize a two-dimensional array with <code>5</code> rows and <code>3</code> columns, as shown in the following line of code:</p>
<pre class="source-code">
int<strong class="bold">[,]</strong> numbers = new int<strong class="bold">[5, 3]</strong>;
numbers<strong class="bold">[0, 0]</strong> = 9; (...)</pre> <p>You can combine a declaration with an initialization in a bit different way as well:</p>
<pre class="source-code">
int[,] numbers = new int[,]
{ 
    <strong class="bold">{ 9, 5, -9 }, </strong>
<strong class="bold">    { -11, 4, 0 }, </strong>
<strong class="bold">    { 6, 115, 3 }, </strong>
<strong class="bold">    { -12, -9, 71 }, </strong>
<strong class="bold">    { 1, -6, -1 }</strong> 
};</pre> <p>A small explanation is <a id="_idIndexMarker261"/>necessary for the way you access particular elements from a two-dimensional array. Let’s take a look at the following example:</p>
<pre class="source-code">
int number = numbers<strong class="bold">[2, 1]</strong>;
numbers<code>2</code>) and second column (index equal to <code>1</code>) is obtained (that is, <code>115</code>) and set as a value of the <code>number</code> variable. The other line replaces <code>-11</code> with <code>11</code> in the second row and the first column.</p>
<p>Now that you’ve learned about one-dimensional and two-dimensional arrays, let’s proceed to three-dimensional ones. Do you know how to understand this structure?</p>
<p class="callout-heading">Imagine a three-dimensional array</p>
<p class="callout">If you want to better imagine a <a id="_idIndexMarker262"/>three-dimensional array, launch a game in which you can create buildings from blocks. You place each of them in a specified location on the board, in <em class="italic">X</em> and <em class="italic">Y</em> coordinates. However, you can also build the next building floors, so you can specify the block’s <em class="italic">Z</em> coordinate as well. In such circumstances, you operate in a three-dimensional world with three-dimensional arrays!</p>
<p>An example three-dimensional array is presented in the following figure:</p>
<div><div><img alt="Figure 3.3 – Example of a three-dimensional array" src="img/B18069_03_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Example of a three-dimensional array</p>
<p>If you want to create a three-dimensional array, you can use the following code:</p>
<pre class="source-code">
int<strong class="bold">[,,]</strong> numbers = new int<strong class="bold">[3, 2, 3]</strong>;</pre> <p>The remaining operations can<a id="_idIndexMarker263"/> be performed similarly as in the case of arrays with a different number of dimensions. Of course, you need to specify three indices while accessing a particular element of the array.</p>
<p>So far, you’ve learned about one-, two-, and three-dimensional arrays. But is it possible to use four-dimensional arrays? Of course!</p>
<p class="callout-heading">Imagine a four-dimensional array</p>
<p class="callout">Imagining a four-dimensional array is not very <a id="_idIndexMarker264"/>easy, but let’s try to do so! Once again, think about the three-dimensional game board we mentioned previously, but with content that changes depending on your level in the game. In this way, you can access a particular block in the three-dimensional world using <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> coordinates. To get a target value, you need to use another dimension, namely by providing your current level. In this way, you will get different results depending on the fourth dimension. Not so difficult, right?</p>
<p>You can declare such an array using the following line of code:</p>
<pre class="source-code">
int<strong class="bold">[,,,]</strong> numbers = new int<strong class="bold">[5, 4, 3, 2]</strong>;</pre> <p>If you need more dimensions, you can apply them. However, please keep in mind that using more dimensions can be<a id="_idIndexMarker265"/> quite difficult to understand and your code can be more difficult to follow and maintain in the future.</p>
<p>With this introduction to the topic of multi-dimensional arrays out of the way, let’s proceed to some examples. They will show you how to use such data structures in t<a id="_idTextAnchor097"/><a id="_idTextAnchor098"/>he real world.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor099"/>Example – multiplication table</h2>
<p>This first example shows basic operations being <a id="_idIndexMarker266"/>performed on a two-dimensional array to present a multiplication table. It stores the results of the multiplication of all integer values in the range from <code>1</code> to <code>10</code> in the array and present them in the console:</p>
<pre class="console">
 1   2   3   4   5   6   7   8   9  10
 2   4   6   8  10  12  14  16  18  20
 3   6   9  12  15  18  21  24  27  30
 4   8  12  16  20  24  28  32  36  40
 5  10  15  20  25  30  35  40  45  50
 6  12  18  24  30  36  42  48  54  60
 7  14  21  28  35  42  49  56  63  70
 8  16  24  32  40  48  56  64  72  80
 9  18  27  36  45  54  63  72  81  90
10  20  30  40  50  60  70  80  90 100</pre> <p>Let’s take a look at the declaration and initialization of the array:</p>
<pre class="source-code">
int[,] results = new int[10, 10];</pre> <p>Here, a two-dimensional array with <code>10</code> rows and <code>10</code> columns is created and its elements are initialized to default values – that is, to zeros. When the array is ready, you fill it with the results of the multiplication, as well as present the result in the console. Such a task can be performed using two <code>for</code> loops, as shown here:</p>
<pre class="source-code">
for (int i = 0; i &lt; <strong class="bold">results.GetLength(0)</strong>; i++)
{
    for (int j = 0; j &lt; <strong class="bold">results.GetLength(1)</strong>; j++)
    {
        <strong class="bold">results[i, j] = (i + 1) * (j + 1);</strong>
        Console.Write($"{<strong class="bold">results[i, j]</strong>,4}");
    }
    Console.WriteLine();
}</pre> <p>In the preceding code, you can see the <code>GetLength</code> method, which is called on the <code>results</code> array. This method returns the number of elements in a particular dimension – that is, the first (when passing <code>0</code> as the parameter) and the second (<code>1</code> as the parameter). In both cases, a <a id="_idIndexMarker267"/>value of <code>10</code> is returned, according to the values specified during the array’s initialization. Another important part of the code is the way of setting the value of an element. To do so, you must provide two indices.</p>
<p>The multiplication results, after converting them into <code>string</code> values, have different lengths, from one character (as in the case of <code>4</code> as a result of <code>2*2</code>) to three (<code>100</code> from <code>10*10</code>). To improve their presentation, you need to write each result in <code>4</code> characters. Therefore, if an integer value takes less space, leading spaces should be added. As an example, <code>1</code> will be shown with three leading spaces (<code>___1</code>, where <code>_</code> is a space), while <code>100</code> will be shown with only one space (<code>_100</code>). You can achieve this goal by using a proper composite format string (namely, <code>,4</code>) within the inte<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/>rpolated string.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor102"/>Example – game map</h2>
<p>Another example is a program that presents a map of a game. This map is a rectangle with 6 rows and 8 columns. Each element <a id="_idIndexMarker268"/>of the array specifies a type of terrain as grass, sand, water, or brick (also referred to as wall). Each place on the map should be shown in a particular color (such as green for grass), as well as using a custom character that depicts the terrain type (such as <code>≈</code> for water), as shown in the following figure:</p>
<div><div><img alt="Figure 3.4 – ﻿Screenshot of the game map example" src="img/B18069_03_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Screenshot of the game map example</p>
<p>Let’s start by creating two auxiliary methods that make it possible to get a particular color and character depending on the terrain’s type (<code>GetColor</code> and <code>GetChar</code>, respectively). The code for these <a id="_idIndexMarker269"/>methods is as follows:</p>
<pre class="source-code">
ConsoleColor <strong class="bold">GetColor</strong>(char terrain)
{
    return terrain switch
    {
        'g' =&gt; ConsoleColor.Green,
        's' =&gt; ConsoleColor.Yellow,
        'w' =&gt; ConsoleColor.Blue,
        _ =&gt; ConsoleColor.DarkGray
    };
}
char <strong class="bold">GetChar</strong>(char terrain)
{
    return terrain switch
    {
        'g' =&gt; '\u201c',
        's' =&gt; '\u25cb',
        'w' =&gt; '\u2248',
        _ =&gt; '\u25cf'
    };
}</pre> <p>As you can see, the code of the <code>GetColor</code> method is self-explanatory. However, the <code>GetChar</code> method returns a proper Unicode character depending on the character’s value (<code>g</code>, <code>s</code>, <code>w</code>, or <code>b</code>). For example, in the case of water, the <code>'\u2248'</code> value is returned, which is <a id="_idIndexMarker270"/>a representation of the <code>≈</code> character.</p>
<p>Let’s take a look at the remaining part of the code. Here, you configure the map, as well as present it in the console. The code is as follows:</p>
<pre class="source-code">
using System.Text;
char[,] map =
{
    { 's', 's', 's', 'g', 'g', 'g', 'g', 'g' },
    { 's', 's', 's', 'g', 'g', 'g', 'g', 'g' },
    { 's', 's', 's', 's', 's', 'b', 'b', 'b' },
    { 's', 's', 's', 's', 's', 'b', 's', 's' },
    { 'w', 'w', 'w', 'w', 'w', 'b', 'w', 'w' },
    { 'w', 'w', 'w', 'w', 'w', 'b', 'w', 'w' }
};
Console.OutputEncoding = <strong class="bold">Encoding.UTF8</strong>;
for (int r = 0; r &lt; map.GetLength(0); r++)
{
    for (int c = 0; c &lt; map.GetLength(1); c++)
    {
        Console.ForegroundColor = <strong class="bold">GetColor(map[r, c])</strong>;
        Console.Write(<strong class="bold">GetChar(map[r, c])</strong> + " ");
    }
    Console.WriteLine();
}
Console.ResetColor(); </pre> <p>This code should not require additional comments or explanations. Just keep in mind that to use Unicode values in the console output, don’t forget to choose the UTF-8 encoding by setting the <code>Encoding.UTF8</code> value for the <code>OutputEncoding</code> property. You can set the foreground <a id="_idIndexMarker271"/>color for the console using the <code>ForegroundColor</code> property. If you want to reset such a color to the default one, just call the <code>ResetColor</code> method, as presented in the last line.</p>
<p>So far, you’ve learned about both single- and multi-dimensional arrays, but one more variant remains to be presented in this book, namely jagged arrays. Let’s continue reading to lea<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>rn more about them.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor105"/>Jagged arrays</h1>
<p>The last variant of arrays to be described in this book is <strong class="bold">jagged arrays</strong>, also referred to as an <strong class="bold">array of arrays</strong>. It sounds complicated, but<a id="_idIndexMarker272"/> fortunately, it is very simple. A jagged array can be understood as <strong class="bold">a single-dimensional array, where each element is another array</strong>. Of <a id="_idIndexMarker273"/>course, such inner arrays can have different lengths or they can even be not initialized.</p>
<p class="callout-heading">Imagine a jagged array</p>
<p class="callout">If you want to better imagine a jagged array, stop reading this book for a moment, open your calendar, and switch its view so that it presents the whole year. It contains 365 or 366 boxes, depending on the year. For each day, you have a different number of meetings. On some days, you have three meetings, while on others, only one or even zero. Your holidays are marked in the calendar and blocked for meetings. You can easily imagine an application of a jagged array in this case. Each day box is an element of this array and it contains an array with data of meetings organized on a particular day. If this day is during your holidays, a related item is not initialized. This makes a jagged array much easier to visualize.</p>
<p>An example jagged array is<a id="_idIndexMarker274"/> presented in the following figure:</p>
<div><div><img alt="Figure 3.5 – Example of a jagged array" src="img/B18069_03_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Example of a jagged array</p>
<p>This jagged array contains four<a id="_idIndexMarker275"/> elements. The first has an array with two elements (<code>9</code> and <code>5</code>). The second element has an array with three elements (<code>0</code>, <code>-3</code>, and <code>12</code>). The third is not initialized (<code>null</code>), while the last one is an array with only one element (<code>54</code>).</p>
<p>Before proceeding to the example, it is worth mentioning the way of declaring and initializing a jagged array since it is a bit different from the arrays we’ve already described. Let’s take a look at the following code snippet:</p>
<pre class="source-code">
int<strong class="bold">[][]</strong> numbers = <strong class="bold">new int[4][]</strong>; 
numbers[0] = <strong class="bold">new int[] { 9, 5 }</strong>; 
numbers[1] = <strong class="bold">new int[] { 0, -3, 12 }</strong>; 
numbers[3] = <strong class="bold">new int[] { 54 }</strong>; </pre> <p>This code can be simplified with a collection expression, as follows:</p>
<pre class="source-code">
int[][] numbers = new int[4][];
numbers[0] = <strong class="bold">[9, 5]</strong>;
numbers[1] = <strong class="bold">[0, -3, 12]</strong>;
numbers[3] = <code>numbers</code> array is initialized with default<a id="_idIndexMarker276"/> values, namely <code>null</code>. For this reason, we need to manually initialize particular elements, as shown in the following three lines of code. It is worth noting that the third element is not initialized.</p>
<p>You can also write the preceding code in a different way, as shown here:</p>
<pre class="source-code">
int[][] numbers =
{
    <strong class="bold">new int[] { 9, 5 },</strong>
<strong class="bold">    new int[] { 0, -3, 12 },</strong>
<strong class="bold">    null!,</strong>
<strong class="bold">    new int[] { 54 }</strong>
};</pre> <p>That’s not all – an even shorter variant is available:</p>
<pre class="source-code">
int[][] numbers =
[
    <strong class="bold">[9, 5],</strong>
<strong class="bold">    [0, -3, 12],</strong>
<strong class="bold">    null!,</strong>
<strong class="bold">    [54]</strong>
];</pre> <p>How can you access a particular element from a jagged array? Let’s see:</p>
<pre class="source-code">
int number = numbers<strong class="bold">[1][2]</strong>;
numbers<code>number</code> variable to <code>12</code> – that is, to the value of the third element (index equal to <code>2</code>) from the array, which is the second element of the jagged array. The other line changes the value of the second element within the array, which is the second element <a id="_idIndexMarker277"/>of the jagged array, from <code>-3</code> to <code>50</code>.</p>
<p>Now that we’ve introduced jagged arrays, l<a id="_idTextAnchor106"/>et’s look at an example.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor107"/>Example – yearly transport plan</h2>
<p>In this example, you’ll learn how to develop a program that creates a plan for your transportation for the whole year. For each day of each month, the application draws one of the available means of <a id="_idIndexMarker278"/>transport, such as by car, by bus, by subway, by bike, or simply on foot. In the end, the program presents the generated plan, as shown in the following screenshot:</p>
<div><div><img alt="Figure 3.6 – Screenshot of the yearly transport plan example" src="img/B18069_03_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Screenshot of the yearly transport plan example</p>
<p>First, let’s declare the enumeration type with constants representing types of transport:</p>
<pre class="source-code">
public enum <strong class="bold">MeanEnum</strong> { Car, Bus, Subway, Bike, Walk }</pre> <p>The next part of the code is as follows:</p>
<pre class="source-code">
Random random = new();
int meansCount = Enum.GetNames&lt;MeanEnum&gt;().Length;
int year = DateTime.Now.Year;
<strong class="bold">MeanEnum[][] means = new MeanEnum[12][];</strong>
for (int m = 1; m &lt;= 12; m++)
{
    int daysCount = DateTime.DaysInMonth(year, m);
    <strong class="bold">means[m - 1] = new MeanEnum[daysCount];</strong>
    for (int d = 1; d &lt;= daysCount; d++)
    {
        int mean = random.Next(meansCount);
        <strong class="bold">means[m - 1][d - 1] = (MeanEnum)mean;</strong>
    }
} </pre> <p>First, a new instance of the <code>Random</code> class is created. This will be used to draw a suitable means of transport from the <a id="_idIndexMarker279"/>available ones. In the next line, we get the number of available transport types. Then, the jagged array is created. It is assumed that it has <code>12</code> elements, representing all months in the current year.</p>
<p>Next, a <code>for</code> loop is used to iterate through all the months within the year. In each iteration, the number of days is obtained using the <code>DaysInMonth</code> static method of <code>DateTime</code>. Each element of the jagged array is a single-dimensional array with <code>MeanEnum</code> values. The length of such an inner array depends on the number of days in a month. For instance, it is set to <code>31</code> elements for January and <code>30</code> elements for April.</p>
<p>The next <code>for</code> loop iterates through all the days of the month. Within this loop, you draw a transport type and set it as a value of a suitable element within an array that is an element of the jagged array.</p>
<p>The next part of the code is related to presenting the plan in the console:</p>
<pre class="source-code">
string[] months = GetMonthNames();
int nameLength = months.Max(n =&gt; n.Length) + 2;
<strong class="bold">for (int m = 1; m &lt;= 12; m++)</strong>
{
    string month = months[m - 1];
    Console.Write($"{month}:".PadRight(nameLength));
    <strong class="bold">for (int d = 1; d &lt;= means[m - 1].Length; d++)</strong>
    {
        <strong class="bold">MeanEnum mean = means[m - 1][d - 1];</strong>
<strong class="bold">        (char character, ConsoleColor color) = Get(mean);</strong>
        Console.ForegroundColor = ConsoleColor.White;
        Console.BackgroundColor = color;
        Console.Write(character);
        Console.ResetColor();
        Console.Write(" ");
    }
    Console.WriteLine();
} </pre> <p>First, a single-dimensional<a id="_idIndexMarker280"/> array with month names is created using the <code>GetMonthNames</code> method, which will be presented and described later. Then, a value of the <code>nameLength</code> variable is set to the maximum necessary length of text for storing the month name. To do so, the <code>Max</code> extension method is used to find the maximum length of text from the collection with names of months. The obtained result is increased by <code>2</code> to reserve space for a colon and a space.</p>
<p>A <code>for</code> loop is used to iterate through all the elements of the jagged array – that is, through all months. In each iteration, the month’s name is presented in the console. The next <code>for</code> loop is used to iterate through all the items of the current element of the jagged array – that is, through all the days of the month. For each day, proper colors are set (for the foreground and background), and a suitable character is shown. Both a color and a character are returned by the <code>Get</code> method, taking the <code>MeanEnum</code> value as a parameter. This method will be<a id="_idIndexMarker281"/> shown a bit later.</p>
<p>Now, let’s take a look at the implementation of the <code>GetMonthNames</code> method:</p>
<pre class="source-code">
string[] <strong class="bold">GetMonthNames</strong>()
{
    CultureInfo culture = new("en");
    string[] names = new string[12];
    foreach (int m in <strong class="bold">Enumerable.Range(1, 12)</strong>)
    {
        DateTime firstDay = new(DateTime.Now.Year, m, 1);
        string name = firstDay.ToString("MMMM", culture);
        names[m - 1] = name;
    }
    return names;
} </pre> <p>This code is self-explanatory, but let’s focus on the line where we call the <code>Range</code> method. It returns a collection of<a id="_idTextAnchor108"/> integer values from <code>1</code> to <code>12</code>. Therefore, we can use it together with the <code>foreach</code> loop, instead of a simple <code>for</code> loop iterating from <code>1</code> to <code>12</code>. Just think about it as an alternative way of solving the same problem.</p>
<p>Finally, it is worth mentioning the <code>Get</code> method. It allows us to use one method instead of two, namely returning a character and a color for a given transport type. By returning data as a value tuple, the code is shorter and simpler, as shown here:</p>
<pre class="source-code">
<strong class="bold">(char Char, ConsoleColor Color) Get</strong>(MeanEnum mean)
{
    return mean switch
    {
        MeanEnum.Bike =&gt; ('B', ConsoleColor.Blue),
        MeanEnum.Bus =&gt; ('U', ConsoleColor.DarkGreen),
        MeanEnum.Car =&gt; ('C', ConsoleColor.Red),
        MeanEnum.Subway =&gt; ('S', ConsoleColor.Magenta),
        MeanEnum.Walk =&gt; ('W', ConsoleColor.DarkYellow),
        _ =&gt; throw new Exception("Unknown type")
    };
}</pre> <p>Arrays are everywhere in this chapter! Now that we’ve learned about this data structure and its C# implementation-related topics, we can focus on some algorithms that are strictly related to arrays, namely <a id="_idIndexMarker282"/>sorting algorithms. Are you ready to get to know a few of them? If so, let’s <a id="_idTextAnchor109"/>proceed to the next section.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor110"/>Sorting algorithms</h1>
<p>Many algorithms use arrays for a very broad range of applications. However, one of the most common tasks is <strong class="bold">sorting an array to arrange its elements in the correct order, either ascending or descending</strong>. Of course, you can sort data of various types, including numbers, strings, or even instances of <a id="_idIndexMarker283"/>user-defined classes. However, to keep things a bit simpler, here, we will only focus on sorting integer values.</p>
<p class="callout-heading">Imagine a sorting algorithm</p>
<p class="callout">You benefit from the sorting procedure frequently in your daily life! For example, your inbox is sorted in a way to present the newest messages first (by sending date in descending order), your calendar presents a day plan sorted by hours (by event start date in ascending order), as well as your list of tasks shows entries from the most important to the least important (by priority in descending order). That’s not all – at work, you sort documents by their issue date, then you choose a suitable road to home from the variants sorted by time to reach the destination, and in the evening, you change programs on the TV using a remote control according to the predefined order of channels.</p>
<p>Sorting algorithms involve many approaches and are also a popular subject of research. There are a lot of sorting<a id="_idIndexMarker284"/> types, including selection sort, insertion sort, bubble sort, merge sort, Shell sort, quicksort, and heap sort. These will be expla<a id="_idTextAnchor111"/>ined in detail in this chapter. However, these are not all of the available approaches. Various types differ in their performance results, which is one of the most important aspects that you should take into account while choosing your sorting implementation. This topic will be analyzed at the end of this chapter to give you some tips in this area.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">Array sorting is a popular topic that’s presented in various resources in books and research papers, as well as online. For example, you can read more about sorting algorithms presented in this chapter at Wikipedia, as well as you can take a look at some implementation codes at Wikibooks. You can browse for more information about the merge sort at <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a> and <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort</a>, about Shell sort at <a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a> and <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort</a>, about quicksort at <a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a> and <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort</a>, and about heap sort at <a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a> and <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort</a>. In a similar way, you can find information about other sorting algorithms. Of course, Wikipedia, together with Wikibooks, is not the only available source of content regarding such algorithms. There are a huge number of websites dedicated to this subject. Some of them also contain animations that show how various algorithms operate. This can help you visualize how they work.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor112"/>Selection sort</h2>
<p>Let’s start with <strong class="bold">selection sort</strong>, which is<a id="_idIndexMarker285"/> one of the simplest sorting algorithms. <strong class="bold">This algorithm divides the array into two parts, namely sorted and unsorted</strong>. First, the<a id="_idIndexMarker286"/> sorted part is empty. In the following iterations, <strong class="bold">the algorithm finds the smallest element in the unsorted part and exchanges it with the first element in the unsorted part</strong>. Thus, the sorted part increases by one element. This sounds quite simple, doesn’t it?</p>
<p>To better understand the selection sort algorithm, let’s take a look at the following iterations for an array with nine elements (<code>-11</code>, <code>12</code>, <code>-42</code>, <code>0</code>, <code>1</code>, <code>90</code>, <code>68</code>, <code>6</code>, and <code>-9</code>), as shown in the following <a id="_idIndexMarker287"/>figure:</p>
<div><div><img alt="Figure 3.7 – Illustration of the selection sort algorithm" src="img/B18069_03_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Illustration of the selection sort algorithm</p>
<p>Bold lines are used to present <a id="_idIndexMarker288"/>the borders between the sorted and unsorted parts of the array. First (<em class="italic">Step 1</em>), the border is located just at the top of the array, which means that the sorted part is empty. Here, the algorithm finds the smallest value in the unsorted part (namely <code>-42</code>) and swaps it with the first element in this part (<code>-11</code>). The result is shown in <em class="italic">Step 2</em>, where the sorted part contains one element (<code>-42</code>), while the unsorted part consists of eight elements. In the next step, the algorithm finds <code>-11</code> as the smallest value in the unsorted part and swaps it with <code>12</code>, which is the first element in the unsorted part. As a result, the sorted part consists of two elements, namely <code>-42</code> and <code>-11</code>, while the unsorted part contains only seven elements, as shown in <em class="italic">Step 3</em>. The aforementioned steps are performed a few times until only one element is left in the unsorted part. The final result is shown in <em class="italic">Step 9</em>.</p>
<p>With that, you know how the selection sort algorithm works, but what role is performed by the <code>i</code> and <code>m</code> indicators shown on the left in the preceding diagram? They are related to the variables that are used in the implementation of this algorithm. So, it is time to see the code in the C# language!</p>
<p>The implementation is created within the <code>Sort</code> method, which takes the <code>a</code> array as the parameter and sorts it using selection sort:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    <strong class="bold">for (int i = 0; i &lt; a.Length - 1; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        int minIndex = i;</strong>
<strong class="bold">        int minValue = a[i];</strong>
<strong class="bold">        for (int j = i + 1; j &lt; a.Length; j++)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            if (a[j] &lt; minValue)</strong>
            <strong class="bold">{</strong>
<strong class="bold">                minIndex = j;</strong>
<strong class="bold">                minValue = a[j];</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">        (a[i], a[minIndex]) = (a[minIndex], a[i]);</strong>
<strong class="bold">    }</strong>
}</pre> <p>A <code>for</code> loop is used to iterate through the elements until only one item is left in the unsorted part. Thus, the number of iterations<a id="_idIndexMarker289"/> of the loop is equal to the length of the array minus one (<code>a.Length - 1</code>). In each iteration, another <code>for</code> loop is used to find the smallest value in the unsorted part (<code>minValue</code>, from the <code>i + 1</code> index until the end of the array), as well as to store an index of the smallest value (<code>minIndex</code>, referred to as the <code>m</code> indicator in the preceding diagram). Finally, the smallest element in the unsorted part (with an index equal to <code>minIndex</code>) is swapped with the first element in the unsorted part (the <code>i</code> index).</p>
<p>That’s all! Let’s use the following code to test the implementation of the selection sort algorithm:</p>
<pre class="source-code">
int[] array = [-11, 12, -42, 0, 1, 90, 68, 6, -9];
<strong class="bold">Sort(array);</strong>
Console.WriteLine(string.Join(" | ", array));</pre> <p>In the preceding code, an array is declared and initialized. Then, the <code>Sort</code> method is called, passing the <code>array</code> as a<a id="_idIndexMarker290"/> parameter. Finally, the <code>string</code> value is created by joining elements of the array, separated by <code>|</code>. The result is shown in the console:</p>
<pre class="console">
-42 | -11 | -9 | 0 | 1 | 6 | 12 | 68 | 90</pre> <p>Since we’re talking about various algorithms, one of the most important topics is computational complexity, especially<a id="_idIndexMarker291"/> time complexity. In the case of selection sort, both <code>for</code> loops (one within the other), each iterating through many elements of the array, which contains <em class="italic">n</em> elements. For this reason, the complexity is indicated as <em class="italic">O(n</em>2<em class="italic">)</em>.</p>
<p class="callout-heading">A small reminder about computational complexity</p>
<p class="callout">You learned about computational complexity in the previous chapter. As a quick reminder, there are a few variants, such as <a id="_idIndexMarker292"/>for the worst or average case. This complexity can be interpreted as the number of basic operations that need to be performed by the algorithm, depending on the input size (<em class="italic">n</em>). The time complexity can be specified using Big O notation – for example, as <em class="italic">O(n)</em>, <em class="italic">O(n</em>2<em class="italic">)</em>, <em class="italic">O(n log(n))</em> or <em class="italic">O(1)</em>. As an example, the <em class="italic">O(n)</em> notation indicates that the number of operations increases linearly with the input size (<em class="italic">n</em>).</p>
<p>With that, you’ve learned about selection sort. If you are interested in another approach to sorting, proceed to the next sec<a id="_idTextAnchor113"/>t<a id="_idTextAnchor114"/>ion, where insertion sort is presented.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor115"/>Insertion sort</h2>
<p><strong class="bold">Insertion sort</strong> is another algorithm that makes it<a id="_idIndexMarker293"/> possible to sort a single-dimensional<a id="_idIndexMarker294"/> array simply. Here, <strong class="bold">the array is divided into two parts, namely sorted and unsorted</strong>. However, at the beginning, the first element is included in the sorted part. In each iteration, <strong class="bold">the algorithm takes the first element from the unsorted part and places it in a suitable location within the sorted part, to leave the sorted part in the correct order</strong>. Such operations are repeated until the unsorted part is empty.</p>
<p>As an example, let’s take a look <a id="_idIndexMarker295"/>at an illustration of sorting an array with<a id="_idIndexMarker296"/> nine elements (<code>-11</code>, <code>12</code>, <code>-42</code>, <code>0</code>, <code>1</code>, <code>90</code>, <code>68</code>, <code>6</code>, and <code>-9</code>) using insertion sort:</p>
<div><div><img alt="Figure 3.8 – Illustration of the insertion sort algorithm" src="img/B18069_03_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Illustration of the insertion sort algorithm</p>
<p>First, only one element (namely <code>-11</code>) is located in the sorted part (<em class="italic">Step 1</em>). Then, you take the first element from the unsorted part (<code>12</code>). In this case, the location of this element does not need to be changed, so the sorted part is increased to two elements, namely <code>-11</code> and <code>12</code>. Then, you take <code>-42</code> as the first element in the unsorted part and you move it to the correct location in the sorted part. To do so, you need to perform two swap operations, as shown in <em class="italic">Step 2</em>. Thus, the length of the sorted part is increased to three elements, namely <code>-42</code>, <code>-11</code>, and <code>12</code>. In <em class="italic">Step 3</em>, you take <code>0</code> as the first element from the unsorted part and perform one swap operation to place it in the correct position, just before <code>12</code>, as presented in <em class="italic">Step 4</em>. At the same time, the size of the sorted part is increased to four already sorted elements, namely <code>-42</code>, <code>-11</code>, <code>0</code>, and <code>12</code>. Such operations are repeated until the unsorted part is empty (<em class="italic">Step 9</em>).</p>
<p>The implementation code for the insertion sort algorithm is very simple:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    <strong class="bold">for (int i = 1; i &lt; a.Length; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        int j = i;</strong>
<strong class="bold">        while (j &gt; 0 &amp;&amp; a[j] &lt; a[j - 1])</strong>
<strong class="bold">        {</strong>
<strong class="bold">            (a[j], a[j - 1]) = (a[j - 1], a[j]);</strong>
<strong class="bold">            j--;</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre> <p>A <code>for</code> loop is used to iterate through all elements in the unsorted part. Thus, the initial value of the <code>i</code> variable is set to <code>1</code>, instead of <code>0</code>, because the unsorted part contains one element at the beginning. In <a id="_idIndexMarker297"/>each iteration of the <code>for</code> loop, a <code>while</code> loop is executed to move the first element <a id="_idIndexMarker298"/>from the unsorted part of the array (with the index equal to <code>i</code>) to the correct location within the sorted part, by swapping.</p>
<p>Finally, it is worth mentioning the time complexity of the insertion sort algorithm. Similarly, as in the case of the selection sort, both <code>for</code> and <code>while</code>) placed one within the other, which could iterate mul<a id="_idTextAnchor116"/>t<a id="_idTextAnchor117"/>iple times, depending on the input size (<em class="italic">n</em>).</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor118"/>Bubble sort</h2>
<p>The third sorting algorithm<a id="_idIndexMarker299"/> we’ll cover is <strong class="bold">bubble sort</strong>. Its way of operation is very<a id="_idIndexMarker300"/> simple. <strong class="bold">The algorithm just iterates through the array and compares adjacent elements. If they are located in an incorrect order, they are swapped.</strong> It sounds very easy, doesn’t it? Unfortunately, the algorithm is not efficient and its usage with large collections can cause performance-related problems.</p>
<p>To better understand <a id="_idIndexMarker301"/>how the algorithm works, let’s take a look at the following<a id="_idIndexMarker302"/> figure, which shows how the algorithm operates in the case of sorting a single-dimensional array with nine elements (<code>-11</code>, <code>12</code>, <code>-42</code>, <code>0</code>, <code>1</code>, <code>90</code>, <code>68</code>, <code>6</code>, and <code>-9</code>):</p>
<div><div><img alt="Figure 3.9 – Illustration of the bubble sort algorithm" src="img/B18069_03_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Illustration of the bubble sort algorithm</p>
<p>In each step, the algorithm compares two adjacent elements in the array and swaps them, if necessary. For example, in <em class="italic">Step 1</em>, <code>-11</code> and <code>12</code> are compared. They are placed in the correct order, so it is not necessary to swap such elements. In <em class="italic">Step 2</em>, the next adjacent elements are compared (namely <code>12</code> and <code>-42</code>). This time, such elements are not placed in the correct order, so<a id="_idIndexMarker303"/> they are swapped. The aforementioned operations are performed many times. Finally, the array is sorted, as shown in <em class="italic">Step 72</em>.</p>
<p>The algorithm seems to<a id="_idIndexMarker304"/> be very easy, but what about its implementation? Is it also simple? Fortunately, yes! You just need to use two loops, compare adjacent elements, and swap them if necessary. That’s all! Let's take a look at the following code snippet:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    <strong class="bold">for (int i = 0; i &lt; a.Length; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        for (int j = 0; j &lt; a.Length - 1; j++)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            if (a[j] &gt; a[j + 1]) </strong>
<strong class="bold">            {</strong>
<strong class="bold">                (a[j], a[j + 1]) = (a[j + 1], a[j]);</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre> <p>Here, two <code>for</code> loops are used, together with a comparison and swapping. As mentioned previously, this algorithm is not efficient and its application can cause problems related to performance, especially in the case of large collections of data. However, it is possible to use a bit more efficient version of the bubble sort algorithm by introducing a simple modification. It is based on the assumption that <strong class="bold">comparisons should be stopped when no changes are discovered during one iteration through the array</strong>. The code is as<a id="_idIndexMarker305"/> follows:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    for (int i = 0; i &lt; a.Length; i++)
    {
        <strong class="bold">bool isAnyChange = false;</strong>
        for (int j = 0; j &lt; a.Length - 1; j++)
        {
            if (a[j] &gt; a[j + 1])
            {
                <strong class="bold">isAnyChange = true;</strong>
                (a[j], a[j + 1]) = (a[j + 1], a[j]);
            }
        }
        <strong class="bold">if (!isAnyChange) { break; }</strong>
    }
}</pre> <p>By introducing such a simple modification, the number of steps can decrease. In the preceding example, it decreases from 72 steps to 56 steps.</p>
<p>Before moving on to the next <a id="_idIndexMarker306"/>sorting algorithm, it is worth mentioning the time complexity of the bubble sort algorithm. As you may have already guessed, <strong class="bold">both worst and average cases</strong> are the same as in the case of the selec<a id="_idTextAnchor119"/>t<a id="_idTextAnchor120"/>ion and insertion sort algorithms – that is, <strong class="bold">O(n</strong>2<strong class="bold">)</strong>.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor121"/>Merge sort</h2>
<p>The fourth sorting algorithm operates in a significantly different way than the three already presented. This approach is <a id="_idIndexMarker307"/>named <strong class="bold">merge sort</strong>. <strong class="bold">This algorithm recursively splits the array in half until the array contains only one element, which is sorted. Then, the algorithm merges the already sorted subarrays (starting with these with only one element) into the sorted array.</strong> Finally, the whole array<a id="_idIndexMarker308"/> is sorted and the algorithm stops its operation.</p>
<p>To better understand the merge sort algorithm, let’s take a look at the following iterations for an array with six elements (<code>-11</code>, <code>12</code>, <code>-42</code>, <code>0</code>, <code>90</code>, and <code>-9</code>):</p>
<div><div><img alt="Figure 3.10 – Illustration of the merge sort algorithm" src="img/B18069_03_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Illustration of the merge sort algorithm</p>
<p>First (<em class="italic">Step 1</em>), you have the whole unsorted array, which you split into two parts, namely (<code>-11</code>, <code>12</code>, <code>-42</code>) and (<code>0</code>, <code>90</code>, <code>-9</code>), as shown in <em class="italic">Step 2</em>. In the next step, each of these subarrays is further split into (<code>-11</code>), (<code>12</code>, <code>-42</code>), (<code>0</code>), and (<code>90</code>, <code>-9</code>). In <em class="italic">Step 4</em>, you have the whole array divided into the subarrays with only one element each, namely (<code>-11</code>), (<code>12</code>), (<code>-42</code>), (<code>0</code>), (<code>90</code>), and (<code>-9</code>). Next, you merge all of these subarrays, together with sorting. Thus, in <em class="italic">Step 5</em>, you have <a id="_idIndexMarker309"/>three subarrays – that is, (<code>-11</code>, <code>12</code>), (<code>-42</code>, <code>0</code>), and (<code>-9</code>, <code>90</code>). Please keep in mind that these subarrays are already sorted. In <em class="italic">Step 6</em>, you need to merge and sort them further into (<code>-42</code>, <code>-11</code>, <code>0</code>, <code>12</code>) and (<code>-9</code>, <code>90</code>). Finally, you have the whole array sorted, namely (<code>-42</code>, <code>-11</code>, <code>-9</code>, <code>0</code>, <code>12</code>, <code>90</code>).</p>
<p>Does this seem simpler than<a id="_idIndexMarker310"/> just reading the textual description of the algorithm?  If so, let’s proceed to its implementation:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    <strong class="bold">if (a.Length &lt;= 1) { return; }</strong>
    <strong class="bold">int m = a.Length / 2;</strong>
<strong class="bold">    int[] left = GetSubarray(a, 0, m - 1);</strong>
<strong class="bold">    int[] right = GetSubarray(a, m, a.Length - 1);</strong>
<strong class="bold">    Sort(left);</strong>
<strong class="bold">    Sort(right);</strong>
<strong class="bold">    int i = 0, j = 0, k = 0;</strong>
<strong class="bold">    while (i &lt; left.Length &amp;&amp; j &lt; right.Length)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (left[i] &lt;= right[j]) { a[k] = left[i++]; }</strong>
<strong class="bold">        else { a[k] = right[j++]; }</strong>
<strong class="bold">        k++;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    while (i &lt; left.Length) { a[k++] = left[i++]; }</strong>
<strong class="bold">    while (j &lt; right.Length) { a[k++] = right[j++]; }</strong>
}</pre> <p>The <code>Sort</code> method is called <code>a</code>. To stop <a id="_idIndexMarker311"/>infinitely calling this method recursively, you must specify the stop condition at the beginning. It simply checks whether the size of the array is not greater than 1. It is related to the assumption that you cannot further divide an array with one element only, because it is already sorted.</p>
<p>Next, you calculate an<a id="_idIndexMarker312"/> index of the middle element and store it as a value of <code>m</code>. In the following two lines, you call the auxiliary <code>GetSubarray</code> method, which creates a new array with only a part of elements, either from its left-hand side (with indices from <code>0</code> to <code>m-1</code>, stored as <code>left</code>) or the right-hand side (from <code>m</code> to the length of the array minus 1, stored as <code>right</code>). You will see its implementation after the explanation of the <code>Sort</code> method. Coming back to the explanation of the <code>Sort</code> method, you then recursively call the <code>Sort</code> method, passing the <code>left</code> and <code>right</code> subarrays.</p>
<p>The remaining part of the code is related to merging subarrays into the whole sorted array. Of course, this procedure is performed step by step, merging the subarrays into bigger and bigger subarrays until the whole array is sorted. You use a <code>while</code> loop to iterate through the <code>left</code> and <code>right</code> subarrays. You use three auxiliary variables, namely <code>i</code> as an index of the currently analyzed element from the <code>left</code> array, <code>j</code> from the <code>right</code> array, and <code>k</code> from the <code>a</code> array. Initially, all of them are set to <code>0</code>, so you keep an eye on the first element of the <code>left</code>, <code>right</code>, and <code>a</code> arrays.</p>
<p>Within the <code>while</code> loop, you check whether the current element from the <code>left</code> array (with the <code>i</code> index) is not greater than the current element from the <code>right</code> array (with the <code>j</code> index). If so, you place the current element from the <code>left</code> array as the first element in the <code>a</code> array. You also increase the <code>i</code> index, which means that the second element from the <code>left</code> array is the current one. If this condition is not met – that is, the current element from the <code>right</code> array is smaller than the current element from the <code>left</code> array – you use the current element from the <code>right</code> array as the first element in the <code>a</code> array and increase the <code>j</code> index. Finally, you increase the <code>k</code> index to keep an eye on the second element from the <code>a</code> array. The <code>while</code> loop ends when you are out of bounds of either the <code>left</code> or <code>right</code> array.</p>
<p>What about when some elements haven’t been analyzed yet from the <code>left</code> or <code>right</code> arrays? To handle such cases, you use two additional <code>while</code> loops. These allow you to place the remaining elements<a id="_idIndexMarker313"/> from either the <code>left</code> or <code>right</code> array on the remaining places in the <code>a</code> array. As you can see, the <code>Sort</code> method is equipped with a very simple way of merging two <a id="_idIndexMarker314"/>arrays into one, together with their sorting.</p>
<p>While explaining the algorithm’s implementation, the <code>GetSubarray</code> auxiliary method was mentioned. So, let’s show its code, together with a short explanation:</p>
<pre class="source-code">
int[] <strong class="bold">GetSubarray</strong>(int[] a, int si, int ei)
{
    int[] result = new int[ei - si + 1];
    <strong class="bold">Array.Copy(a, si, result, 0, ei - si + 1);</strong>
    return result;
}</pre> <p>This method uses the <code>Copy</code> static method of the <code>Array</code> class to copy a part of the source array (<code>a</code>) to the declared and initialized here destination array (<code>result</code>). To perform this task, you need to take the correct number of elements, namely <code>ei</code> <code>–</code> <code>si</code> <code>+</code> <code>1</code>. Here, <code>ei</code> stands for <em class="italic">end index</em> and <code>si</code> stands for <em class="italic">start index</em>. You need to copy elements between arrays starting with the <code>si</code> index in the source array (<code>a</code>) and store them starting from the <code>0</code> index in the destination array (<code>result</code>).</p>
<p>Of course, you can fill a subarray in different ways, such as using a <code>for</code> loop, which iterates through elements and copies them accordingly. If you want, you can prepare the alternative implementation on your own and then compare it during the performance tests, which you will see later in this chapter.</p>
<p>What about the time complexity? It’s not very easy to specify it in the case of the merge sort algorithm compared to the other sorting algorithms I’ve presented. However, its time complexity is much better and can be indicated as <strong class="bold">O(n log(n))</strong><strong class="bold"> for both average and worst cases</strong>. You will see what this means in practice while analyzing the performance results.</p>
<p>However, you still have some algorithms to learn about, so let’s proceed to the next one.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor122"/>Shell sort</h2>
<p>A different approach to<a id="_idIndexMarker315"/> sorting is used in the <strong class="bold">Shell sort</strong> algorithm, whose name comes from its author’s name. It is a variation of the <a id="_idIndexMarker316"/>already presented insertion sort. <strong class="bold">The algorithm performs h-</strong><strong class="bold">sorting</strong><strong class="bold"> to sort virtual subarrays consisting of elements with a distance equal to h, using the insertion sort. At the beginning, h is set to half of the array’s length and is divided by 2 in each iteration, until it is equal to 1.</strong> This description can <a id="_idIndexMarker317"/>seem a bit complicated, but it is a surprisingly efficient algorithm with a very simple implementation.</p>
<p>First, let’s take a look at a figure that should make this topic much simpler and easier to understand than just the plain text:</p>
<div><div><img alt="Figure 3.11 – Illustration of the Shell sort algorithm" src="img/B18069_03_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Illustration of the Shell sort algorithm</p>
<p>As the source array contains 7 elements, the initial <code>h</code> value is set to <code>3</code>. So, now, it is time for <code>0</code>, <code>3</code>, <code>6</code>), (<code>1</code>, <code>4</code>), and (<code>2</code>, <code>5</code>). The first virtual subarray consists of (<code>-11</code>, <code>-15</code>, <code>-13</code>), so you sort it and receive (<code>-15</code>, <code>-13</code>, <code>-11</code>). The second is (<code>12</code>, <code>-4</code>) and forms (<code>-4</code>, <code>12</code>) after sorting. The last is (<code>13</code>, <code>-9</code>) and is sorted into (<code>-9</code>, <code>13</code>). When 3-sorting is <a id="_idIndexMarker318"/>completed, you calculate the next <em class="italic">h</em> value, simply by dividing the current value by 2. The result is 1 and it is also the last <em class="italic">h</em>-sorting iteration, namely <strong class="bold">1-sorting</strong>. Now, you <a id="_idIndexMarker319"/>perform a simple insertion sort.</p>
<p>The illustration and description look pretty simple, don’t they? Let's write some C# code to implement the Shell sort algorithm, as shown below:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    <strong class="bold">for (int h = a.Length / 2; h &gt; 0; h /= 2)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        for (int i = h; i &lt; a.Length; i++)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            int j = i;</strong>
            <strong class="bold">int ai = a[i];</strong>
<strong class="bold">            while (j &gt;= h &amp;&amp; a[j - h] &gt; ai)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                a[j] = a[j - h];</strong>
<strong class="bold">                j -= h;</strong>
<strong class="bold">            }</strong>
<strong class="bold">            a[j] = ai;</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
<code>for</code> loop is used to calculate proper values of <code>h</code>, starting with the array (<code>a</code>) length divided by <code>2</code>. It is further divided by <code>2</code> after each iteration and the last acceptable value is <code>1</code>.</p>
<p>The next <code>for</code> loop calculates the <code>i</code> index, starting with <code>h</code>, and increases it until the end of the array is reached. This part is<a id="_idIndexMarker320"/> used to perform the insertion sort on virtual subarrays.</p>
<p>Within the loop, you can use the <code>ai</code> variable to store the current value of the element with the <code>i</code> index, so you can replace it later with another value. Then, a <code>while</code> loop is used to shift elements in the <a id="_idIndexMarker321"/>virtual subarray to find the correct location for <code>ai</code>. Finally, you store the <code>ai</code> variable in the location indicated by the <code>j</code> variable.</p>
<p>As you can see, the implementation is very short and quite simple. What’s more, this algorithm is efficient and can be used for sorting large collections of data, as you will see later in this chapter. But what about the time complexity? <strong class="bold">In the worst case, it is</strong> <strong class="bold">O(n</strong>2<strong class="bold">)</strong>. However, its <strong class="bold">average time complexity is about </strong><strong class="bold">O(n log(n))</strong>.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor123"/>Quicksort</h2>
<p>The sixth sorting algorithm <a id="_idIndexMarker322"/>described in this book is <strong class="bold">quicksort</strong>. It is one of the popular algorithms from the <a id="_idIndexMarker323"/>divide and conquer group and divides a problem into a set of smaller ones. How does it work?</p>
<p><strong class="bold">The algorithm picks some value (for example, from the last element of the array) as a pivot. Then, it reorders the array in such a way that values lower than the pivot are placed before it (forming the lower subarray), while values greater than or equal to the pivot are placed</strong><strong class="bold"><a id="_idIndexMarker324"/></strong><strong class="bold"> after it (the higher subarray). Such a process is called </strong><strong class="bold">partitioning</strong><strong class="bold">. Next, the algorithm recursively sorts each of the aforementioned subarrays. Each subarray is further divided into the next two subarrays, and so on. The recursive calls stop when there are one or zero elements in a subarray because in such a case, there is nothing </strong><strong class="bold">to sort</strong>.</p>
<p>The preceding description may sound a bit complicated. However, the following figure and the algorithm’s implementation should remove any doubts.</p>
<p>The following diagram shows how the <a id="_idIndexMarker325"/>quicksort algorithm sorts a single-dimensional array with nine <a id="_idIndexMarker326"/>elements (<code>-11</code>, <code>12</code>, <code>-42</code>, <code>0</code>, <code>1</code>, <code>90</code>, <code>68</code>, <code>6</code>, and <code>-9</code>):</p>
<div><div><img alt="Figure 3.12 – Illustration of the quicksort algorithm" src="img/B18069_03_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Illustration of the quicksort algorithm</p>
<p>In our case, it is assumed that the pivot is chosen as a value of the last element of the subarray that is currently being sorted. In <em class="italic">Step 1</em>, <code>-9</code> is chosen as the pivot. Then, it is necessary to swap <code>12</code> with <code>-42</code> (<em class="italic">Step 1</em>), as well as <code>12</code> with <code>-9</code> (<em class="italic">Step 2</em>), to ensure that only values lower than the pivot (<code>-11</code>, <code>-42</code>) are in the lower subarray and only values greater than or equal to the pivot (<code>0</code>, <code>1</code>, <code>90</code>, <code>68</code>, <code>6</code>, <code>12</code>) are placed in the higher subarray (<em class="italic">Step 3</em>). Then, the algorithm is called recursively for both aforementioned subarrays, namely (<code>-11</code>, <code>-42</code>, from <em class="italic">Step 4</em>) and (<code>0</code>, <code>1</code>, <code>90</code>, <code>68</code>, <code>6</code>, <code>12</code>, from <em class="italic">Step 7</em>), so that they are processed in the same way as the input array.</p>
<p>As an example, <em class="italic">Step 7</em> shows that <code>12</code> is chosen as the pivot. After partitioning, the subarray is divided into two <a id="_idIndexMarker327"/>other subarrays, namely (<code>0</code>, <code>1</code>, <code>6</code>) and (<code>90</code>, <code>68</code>). For both, other pivot elements are chosen, namely <code>6</code> and <code>68</code>. After performing such operations for all<a id="_idIndexMarker328"/> the remaining parts of the array, you receive the result shown in <em class="italic">Step 16</em>.</p>
<p>It is worth mentioning that the pivot can be selected variously in other implementations of this algorithm. Now that you understand how the algorithm works, let’s proceed to its implementation. It’s no more complicated than the examples shown earlier, and it uses <strong class="bold">recursion</strong> to call the sorting method for subarrays. The main code is as follows:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
<strong class="bold">    SortPart(a, 0, a.Length - 1);</strong>
}</pre> <p>The <code>Sort</code> method takes only one parameter, namely the array that should be sorted. It just calls the <code>SortPart</code> method, which makes it possible to <code>SortPart</code> method is shown here:</p>
<pre class="source-code">
void <strong class="bold">SortPart</strong>(int[] a, int l, int u)
{
    if (l &gt;= u) { return; }
    int pivot = a[u];
    int j = l - 1;
    for (int i = l; i &lt; u; i++)
    {
        if (a[i] &lt; pivot)
        {
            j++;
            (a[j], a[i]) = (a[i], a[j]);
        }
    }
    int p = j + 1;
    (a[p], a[u]) = (a[u], a[p]);
    SortPart(a, l, p - 1);
    SortPart(a, p + 1, u);
}</pre> <p>First, the method checks whether the array (or subarray) has at least two elements by comparing the values of the <code>l</code> (<em class="italic">lower index</em>) and <code>u</code> (<em class="italic">upper index</em>) variables. If not, you return from this method. Otherwise, you perform the partitioning phase.</p>
<p>Here, the pivot is chosen as a value of the last<a id="_idIndexMarker329"/> element in the array (or subarray) and stored as a value of the <code>pivot</code> variable. Then, a <code>for</code> loop is used to rearrange the array using comparisons and swapping<a id="_idIndexMarker330"/> elements. You need to perform this stage to ensure that values lower than the pivot are placed before it, while values greater than or equal to the pivot are placed after it.</p>
<p>Finally, you store a new index of the pivot value as <code>p</code> and perform swapping to place it there. The <code>p</code> variable is also used to calculate lower and upper bounds for subarrays, namely as (<code>l</code>, <code>p-1</code>) and (<code>p+1</code>, <code>u</code>). Such ranges are then used while calling the <code>SortPart</code> method recursively for the lower and upper parts. That’s all!</p>
<p>What about the time complexity? It has <strong class="bold">O(n log(n)) average time complexity, despite having O(n</strong>2<strong class="bold">) worst time complexity</strong>. Does this look similar to Shell sort to you? If so, you are right! You are coming closer and closer to the end of this chapter, where you will see results <a id="_idIndexMarker331"/>from conducting performance tests on various sorting algorithms.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor124"/>Heap sort</h2>
<p>The last approach we’ll cover is <a id="_idIndexMarker332"/>based on an interesting data structure known as a <strong class="bold">binary heap</strong>. To<a id="_idIndexMarker333"/> give you a brief introduction, <strong class="bold">it is a tree-based structure where each node contains either zero, one, or two child nodes</strong>. You’ll learn more<a id="_idIndexMarker334"/> about trees and their variants later in this book.</p>
<p>It won’t come as a surprise to you that the sorting solution is named <strong class="bold">heap sort</strong>. <strong class="bold">First, the algorithm </strong><strong class="bold"><a id="_idIndexMarker335"/></strong><strong class="bold">builds a </strong><strong class="bold">max-heap</strong><strong class="bold"> from the array (the </strong><strong class="bold">heapify</strong><strong class="bold"> operation). Then, it repeats a</strong><strong class="bold"><a id="_idIndexMarker336"/></strong><strong class="bold"> few steps until there is only one element in </strong><strong class="bold">the heap:</strong></p>
<ol>
<li><strong class="bold">Swap the first element (root with the maximum value) with the </strong><strong class="bold">last element.</strong></li>
<li><strong class="bold">Remove the last element (which is currently the maximum value) from </strong><strong class="bold">the heap.</strong></li>
<li><strong class="bold">Build the </strong><strong class="bold">max-heap again.</strong></li>
</ol>
<p>By performing these operations, you efficiently receive the sorted array.</p>
<p>As a new data structure must be introduced here, let’s look at what the binary heap looks like and how the algorithm operates to sort the example array:</p>
<div><div><img alt="Figure 3.13 – Illustration of the heap sort algorithm" src="img/B18069_03_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Illustration of the heap sort algorithm</p>
<p>The input array consists of six elements, namely <code>-11</code>, <code>12</code>, <code>-42</code>, <code>0</code>, <code>90</code>, and <code>-9</code>. You form a binary heap from it by placing the first element as a <em class="italic">root</em> and then by adding two of its child nodes: <code>12</code> and <code>-42</code>. You do not have more space at this level of the heap, so let’s add the following two elements from the array (<code>0</code> and <code>90</code>) as child nodes to the node with <code>12</code>. The last element from the array is left. You must place it as a child node of the node with <code>-42</code>. As you can see, you<a id="_idIndexMarker337"/> can easily map an array to a binary heap data structure and use an array as a <a id="_idIndexMarker338"/>data structure to store the data of a binary heap.</p>
<p class="callout-heading">Interesting properties of a binary heap</p>
<p class="callout">Remember that a root node in a binary <a id="_idIndexMarker339"/>heap, represented by an array, is available at <code>array[0]</code>. If you need to access the data of a parent node of the <em class="italic">i</em>-th element, you can get it from <code>array[(i-1)/2]</code>. The left and right child nodes of the <em class="italic">i</em>-th element are available in <code>array[(2*i)+1]</code> and <code>array[(2*i)+2]</code>, respectively.</p>
<p>The next operation, which takes an important role in the heap sort algorithm, is named <code>90</code> is located as the <em class="italic">root</em>. It contains <code>12</code> and <code>-9</code> as nodes. The node with <code>12</code> contains child nodes with smaller values, namely <code>0</code> and <code>-11</code>. The node with <code>-9</code> contains only one element, which is also smaller than it, namely <code>-42</code>.</p>
<p class="callout-heading">Max-heap is not the only option</p>
<p class="callout">You can also <a id="_idIndexMarker340"/>use the <em class="italic">heapify</em> operation to form the <strong class="bold">min-heap</strong>. It is similar to the max-heap, but each node needs <a id="_idIndexMarker341"/>to meet the condition that the values of its child nodes are greater than or equal to the parent node’s value.</p>
<p>Let’s proceed to the second row of the preceding figure. Here, the last element of the array (<code>90</code>) is already sorted. This is the result of swapping the root (previously, <code>90</code>) with the last element in the array (previously, <code>-42</code>). Then, you must perform another <em class="italic">heapify</em> operation and receive the max-heap with <code>12</code> as the <em class="italic">root</em>. The aforementioned actions are repeated until the heap contains only <a id="_idIndexMarker342"/>one element. In the end, you receive the sorted array, as shown in <a id="_idIndexMarker343"/>the bottom-right corner of the preceding figure.</p>
<p>At this point, you should be ready to analyze the implementation code in the C# language:</p>
<pre class="source-code">
void <strong class="bold">Sort</strong>(int[] a)
{
    <strong class="bold">for (int i = a.Length / 2 - 1; i &gt;= 0; i--)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        Heapify(a, a.Length, i);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    for (int i = a.Length - 1; i &gt; 0; i--)</strong>
<strong class="bold">    {</strong>
        <strong class="bold">(a[0], a[i]) = (a[i], a[0]);</strong>
<strong class="bold">        Heapify(a, i, 0);</strong>
<strong class="bold">    }</strong>
}</pre> <p>The <code>Sort</code> method contains two <code>for</code> loops. The first performs the initial <em class="italic">heapify</em> operation to prepare the <em class="italic">max-heap</em>. You can do so by calling the <code>Heapify</code> multiple times, namely in reverse order and on each node that is not a leaf. Then, you have the array with data forming the <em class="italic">max-heap</em>.</p>
<p>The second <code>for</code> loop is performed until there is at least one element in the heap. In each iteration, it swaps the <em class="italic">root</em> element (with an index equal to <code>0</code>) with the last element, which has an index equal to <code>i</code>. Then, you need to restore the <em class="italic">max-heap</em> property, which you do by calling the <code>Heapify</code> method, regarding the affected part of the heap.</p>
<p>Now, let’s take a look at the code of the <code>Heapify</code> method:</p>
<pre class="source-code">
void <strong class="bold">Heapify</strong>(int[] a, int n, int i)
{
    int max = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    max = l &lt; n &amp;&amp; a[l] &gt; a[max] ? l : max;
    max = r &lt; n &amp;&amp; a[r] &gt; a[max] ? r : max;
    if (max != i)
    {
        (a[i], a[max]) = (a[max], a[i]);
        Heapify(a, n, max);
    }
}</pre> <p>It takes three parameters, namely an array (<code>a</code>), the number of elements in a heap (<code>n</code>), as well as an index of an element (<code>i</code>), which is a root of a subtree that should be <em class="italic">heapified</em>. First, you get an index of the maximum<a id="_idIndexMarker344"/> element (<em class="italic">root</em>, as <code>max</code>), as well as its left and right children (<code>l</code> and <code>r</code>, respectively). You can calculate indices according to the formulas presented earlier, namely <code>2*i+1</code> and <code>2*i+2</code>.</p>
<p>In the following two lines, you check whether the left child index (<code>l</code>) is still within the heap (<code>l&lt;n</code>) and whether the element with this index (<code>a[l]</code>) is greater than the current root value (<code>a[max]</code>). If so, you<a id="_idIndexMarker345"/> update the root index (<code>max</code>). In the same way, you check the right child and adjust the <code>max</code> variable, if necessary.</p>
<p>In the next line, you check whether the <em class="italic">root</em> index changed during the mentioned operations. If so, this means that the current <em class="italic">root</em> is not the biggest value and you need to swap two elements in the array, namely representing the <em class="italic">root</em> (the <code>i</code> index) and the biggest value (the <code>max</code> index). Next, you recursively perform the <em class="italic">heapify</em> operation for the affected subtree, namely a tree with a new root value.</p>
<p>After this detailed explanation, it is worth mentioning the time complexity. It is very important in this case because the method is efficient and can be used successfully while sorting large data collections. <strong class="bold">The time complexity is </strong><strong class="bold">O(n log(n))</strong>.</p>
<p>Despite learning about seven different sorting algorithms, please keep in mind that there are many more such algorithms <a id="_idIndexMarker346"/>available, including <strong class="bold">block sort</strong>, <strong class="bold">tree sort</strong>, <strong class="bold">cube sort</strong>, <strong class="bold">strand sort</strong>, and <strong class="bold">cycle sort</strong>. If you are interested in this topic, I strongly encourage you to take a look at<a id="_idIndexMarker347"/> them on your own. In the meantime, let’s compare the algorithms we’ve covered in this chapter.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor125"/>Performance analysis</h2>
<p>To perform some tests, you need <a id="_idIndexMarker348"/>to configure your environment. So, let’s start by preparing the code for running various sorting algorithms using the same input arrays.</p>
<p>Do you remember that each implementation presented in this chapter involves the <code>Sort</code> method, taking only one parameter (namely the <code>a</code> array)? Now, you can benefit from this assumption and create the <code>AbstractSort</code> abstract class, which requires you to implement this method while deriving from this class.</p>
<p>The code for the abstract class is as follows:</p>
<pre class="source-code">
public abstract class <strong class="bold">AbstractSort</strong>
{
    public abstract void <strong class="bold">Sort</strong>(int[] a);
}</pre> <p>Then, you need to prepare a separate class for each sorting algorithm (such as <code>SelectionSort</code> or <code>HeapSort</code>) according to the following template:</p>
<pre class="source-code">
public class <strong class="bold">SelectionSort</strong>
    : <strong class="bold">AbstractSort</strong>
{
    public override void <strong class="bold">Sort</strong>(int[] a) { (...) }
}</pre> <p>Since all the classes representing sorting algorithms derive from the base abstract class (<code>AbstractSort</code>)you can <a id="_idIndexMarker349"/>easily create a list containing their instances:</p>
<pre class="source-code">
<strong class="bold">List&lt;AbstractSort&gt;</strong> algorithms = new()
{
    new <strong class="bold">SelectionSort</strong>(),
    new <strong class="bold">InsertionSort</strong>(),
    new <strong class="bold">BubbleSort</strong>(),
    new <strong class="bold">MergeSort</strong>(),
    new <strong class="bold">ShellSort</strong>(),
<strong class="bold">    </strong>new <strong class="bold">QuickSort</strong>(),
    new <strong class="bold">HeapSort</strong>()
};</pre> <p>The most interesting part of the code is shown here:</p>
<pre class="source-code">
<strong class="bold">for (int n = 0; n &lt;= 100000; n += 10000)</strong>
{
    Console.WriteLine($"\nRunning tests for n = {n}:");
    <strong class="bold">List&lt;(Type Type, long Ms)&gt; milliseconds = [];</strong>
    for (int i = 0; i &lt; 5; i++)
    {
        int[] array = GetRandomArray(n);
        int[] input = new int[n];
        <strong class="bold">foreach (AbstractSort algorithm in algorithms)</strong>
        {
            array.CopyTo(input, 0);
            Stopwatch stopwatch = Stopwatch.StartNew();
            <strong class="bold">algorithm.Sort(input);</strong>
            stopwatch.Stop();
            Type type = algorithm.GetType();
            long ms = stopwatch.ElapsedMilliseconds;
            <strong class="bold">milliseconds.Add((type, ms));</strong>
        }
    }
    List&lt;(Type, double)&gt; results = milliseconds
        .GroupBy(r =&gt; r.Type)
        .Select(r =&gt;
            (r.Key, r.Average(t =&gt; t.Ms))).ToList();
    foreach ((Type type, double avg) in results)
    {
        Console.WriteLine($"{type.Name}: {avg} ms");
    }
}</pre> <p>Here, you use a <code>for</code> loop to choose suitable values of <code>n</code>, which is the length of the input array used for sorting. You<a id="_idIndexMarker350"/> start with an array with zero elements (<code>n</code> = <code>0</code>) and end with hundreds of thousands of elements (<code>n</code> = <code>100000</code>), increasing the size by <code>10000</code> in each iteration. The values of <code>n</code> will be <code>0</code>, <code>10000</code>, <code>20000</code>, and <code>30000</code>, up to <code>100000</code>.</p>
<p>In each iteration, you create a new instance of the list (<code>milliseconds</code>) . Each its element stores a tuple consisting of two elements, namely a type of the sorting algorithm class (<code>Type</code>) and elapsed milliseconds of execution (<code>Ms</code>). Then, you use another <code>for</code> loop to perform such tests <code>5</code> times. In each of them, you get a random array (<code>array</code>) with a given size by calling <code>GetRandomArray</code>, which will be used as a template for each test. Next, you declare and initialize the input array (<code>input</code>).</p>
<p>The next part involves a <code>foreach</code> loop and iterates through all instances of classes deriving from <code>AbstractSort</code>. For each of them, you create an input array by copying elements from <code>array</code> to <code>input</code>. Then, you start the stopwatch and call the <code>Sort</code> method. As soon as it has finished running, you stop the stopwatch and add results to the <code>milliseconds</code> list.</p>
<p>The last part of the code is <a id="_idIndexMarker351"/>related to calculating the average result for each sorting algorithm and its presentation in the console. To do so, you use a few extension methods, such as <code>GroupBy</code>, <code>Select</code>, and <code>Average</code>, as well as a <code>foreach</code> loop.</p>
<p>The <code>GetRandomArray</code> method was mentioned earlier, so let’s take a look at it:</p>
<pre class="source-code">
int[] <strong class="bold">GetRandomArray</strong>(long length)
{
    Random random = new();
    int[] array = new int[length];
    for (int i = 0; i &lt; length; i++) 
    {
        array[i] = random.Next(-100000, 100000);
    }
    return array;
}</pre> <p>It uses the <code>Random</code> class to get a random integer value in the range of <code>&lt;-100,000, 100,000)</code>. The whole array is filled with such random values.</p>
<p>At this point, your environment is ready and you can perform tests! So, let’s run the code and see the results. I received the following values:</p>
<div><div><img alt="Figure 3.14 – Results of analyzing the performance of ﻿the sorting algorithms" src="img/B18069_03_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Results of analyzing the performance of the sorting algorithms</p>
<p>Apart from the table and its data, let’s take<a id="_idIndexMarker352"/> a look at the chart:</p>
<div><div><img alt="Figure 3.15 – Comparison of the sorting algorithms’ performance results" src="img/B18069_03_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Comparison of the sorting algorithms’ performance results</p>
<p>As you can see, the worst results are received for bubble sort, then the insertion sort and selection sort algorithms. For an array with 100,000 elements, they need almost 33 seconds (bubble sort), almost 14 seconds (insertion sort), and more than 5 seconds (selection sort). Such values <a id="_idIndexMarker353"/>look extremely high compared to the results of merge sort, Shell sort, quicksort, and heap sort. These algorithms needed between 12 and 28 milliseconds! Does this seem surprising? It shouldn’t if you recall time complexity.</p>
<p>Let’s remember the average time complexity for the mentioned algorithms:</p>
<ul>
<li><em class="italic">O(n</em>2<em class="italic">)</em>: Selection sort, insertion sort, and bubble sort</li>
<li><em class="italic">O(n log(n))</em>: Merge sort, Shell sort, quicksort, and heap sort</li>
</ul>
<p>Oh, so it seems that such time complexities really have an importance! ;-) If you earlier had any doubts, it’s the high time to take attention to the algorithms you use in your applications. You should choose them carefully and optimize the solution to handle various amounts of data that need to be processed.</p>
<p class="callout-heading">Don’t forget about performance</p>
<p class="callout">Taking care of performance is important not only for sorting but for all operations that you perform in your mobile applications, web applications, APIs, and long-running background services. Let’s try to write efficient code and test it not only by meeting the functional requirements but also by taking care of non-functional ones, such as those related to performance.</p>
<p>In the previous chart, you almost cannot see any data regarding the algorithms with <em class="italic">O(n log(n))</em> time complexity, so <a id="_idIndexMarker354"/>let’s prepare another set of tests. Now, you can choose only these algorithms and increase the maximum number of <em class="italic">n</em> to one million! You can see my results in the following chart:</p>
<div><div><img alt="Figure 3.16 – Comparison of the sorting algorithms’ performance results" src="img/B18069_03_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – Comparison of the sorting algorithms’ performance results</p>
<p>There are some differences here, especially between quicksort and the remaining ones, namely Shell sort, merge sort, and heap sort. However, such changes are only visible with quite a huge input size and can be caused by the implementation details. All of the sorting algorithms with <em class="italic">O(n log(n))</em> time complexity are good solutions for sorting and can handle various amounts of data. It is also worth noting that these results were received on my device, so you may get different results. However<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>, the relationship between the received <a id="_idIndexMarker355"/>number of elapsed milliseconds should be consistent.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor128"/>Summary</h1>
<p>Arrays are among the most common data structures that are used while developing various kinds of applications, such as mobile, web, or distributed ones. However, this topic is not as easy as it seems to be because even arrays can be divided into a few variants, namely <strong class="bold">single-dimensional</strong> and <strong class="bold">multi-dimensional</strong>, such as two-dimensional and three-dimensional, as well as <strong class="bold">jagged arrays</strong>, also referred to as arrays of arrays.</p>
<p>While talking about arrays, don’t forget about <strong class="bold">sorting algorithms</strong>, which are one of the most popular algorithms used with this data structure. There are plenty of sorting algorithms that differ by their concept, application, implementation details, and performance results. In this chapter, you learned about seven different sorting algorithms, namely <strong class="bold">selection sort</strong>, <strong class="bold">insertion sort</strong>, <strong class="bold">bubble sort</strong>, <strong class="bold">merge sort</strong>, <strong class="bold">Shell sort</strong>, <strong class="bold">quicksort</strong>, and <strong class="bold">heap sort</strong>. Each of them was described, visualized in figures, and written in C# code.</p>
<p>At the end of this chapter, you saw how important time complexity is and how big an impact it can have on <strong class="bold">performance results</strong> while you’re using algorithms with different computational complexity, such as <em class="italic">O(n</em>2<em class="italic">)</em> and <em class="italic">O(n log(n))</em>. You learned how to prepare a simple environment for the performance tests and run them to get the results. They were later shown in a table, as well as in charts, together with an explanation.</p>
<p>Are you ready to learn other data structures? If so, proceed to the next chapter, where you’ll learn about various <strong class="bold">variants of lists</strong>, namely simple, generic, sorted, as well as singly, doubly, and circular linked. You will see their implementation and a few examples of how you can use them in real-world examples.</p>
</div>
</body></html>