- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: There’s a Big Ball of Mud on Your Plate of Spaghetti
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的意大利面盘上有一大团泥巴
- en: Welcome to what is potentially your last day on the job. Your project is about
    to be canceled. Your customers are angry. Your boss is freaking out. Your boss’s
    boss is in Antigua, but when she comes back next week, heads will probably roll.
    There’s no way to sugar-coat it. You might want to update your résumé and brush
    up on your algorithms, so that you’re ready for an imminent job search.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到可能是您在岗位上最后一天。您的项目即将被取消。您的客户很生气。您的老板快要疯了。您的老板的老板正在安提瓜，但当她下周回来时，可能有人要丢官帽。没有方法可以美化这个事实。您可能想要更新您的简历，并复习一下您的算法，以便为即将到来的求职做好准备。
- en: How did it come to this? We had a plan. The hardware architecture was simple.
    The first few releases went off without a hitch and our users were delighted.
    Our client even presented a whole new set of feature requests and signed a contract
    extension. How have we found ourselves at the precipice of sure and sudden doom?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何走到这一步的？我们本来有一个计划。硬件架构很简单。最初的几版发布都进行得非常顺利，我们的用户都很满意。我们的客户甚至提出了一整套新的功能请求，并签署了合同延期。我们是如何发现自己站在必然且突然的灾难边缘的？
- en: The situation we have found ourselves in here is far from unique. According
    to many academic accounts, five out of six software projects are canceled. Others
    fail by running behind schedule or over budget. Software projects are hard. There’s
    no such thing as a *simple* program. There’s really no project that you can knock
    out in a week, then ship, and that’s the end. It doesn’t work that way. This phenomenon
    is unique to the software industry. Structural engineers who design bridge are
    pretty much done when the bridge opens for public traffic. Electrical engineers
    design and test circuits on breadboards, then hand those designs off to be manufactured.
    Aeronautical engineers, such as my grandfather, who designed power plants (as
    in, engines) for Beechcraft, generally designed and prototyped engines, but didn’t
    do much beyond that. It was up to others to manufacture the engine, mount it on
    the aircraft, and others to maintain the engine.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现自己所处的这种情况远非独特。根据许多学术报告，六分之五的软件项目都被取消了。其他项目由于进度落后或超支而失败。软件项目很难。没有所谓的*简单*程序。实际上没有哪个项目可以在一周内完成，然后发货，就结束了。事情不是这样运作的。这种现象是软件行业特有的。设计桥梁的结构工程师在桥梁对公众开放交通时基本上就完成了。电气工程师在面包板上设计和测试电路，然后将这些设计转交给他人进行制造。像我的祖父这样的航空工程师，他们为比奇飞机设计动力装置（即发动机），通常设计并原型化发动机，但并没有做太多。其他人负责制造发动机，将其安装在飞机上，其他人负责维护发动机。
- en: In contrast, software engineers must design, build, test, and often maintain
    the systems that they develop in a continuous delivery environment. Many projects
    are never “done.” I’ve been working on the same software project for the last
    9 years. We certainly haven’t built the perfect project with perfect architecture,
    but the project has endured. New features are produced, and bugs are discovered
    and fixed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，软件工程师必须在持续交付环境中设计、构建、测试，并且经常维护他们开发的系统。许多项目永远不会“完成”。我过去9年一直在同一个软件项目上工作。我们当然没有构建一个具有完美架构的完美项目，但项目已经持续了下来。新的功能被开发出来，并且发现了错误并得到了修复。
- en: What differentiates projects that run continually for many years from the vast
    majority that get canceled? While there are many ways this can happen, we’re going
    to focus solely on the design and architecture of our software. I’ll start with
    how it very often goes wrong. In keeping with the title of this book, we’ll spend
    some time in this chapter discussing a set of antipatterns. While I haven’t directly
    introduced the concept of patterns yet, I suspect that you can make an educated
    guess about what they are, along with what their antithesis is. A **pattern**,
    for now, is simply a formally explained, abstract, best practice solution to a
    common development requirement. An **antipattern** is a formal example of what
    you shouldn’t do. Patterns are arguably good. Antipatterns are inarguably bad.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使得那些持续运行多年的项目与大量被取消的项目有所不同？虽然这种情况可能以许多方式发生，但我们将专注于我们软件的设计和架构。我将从它经常出错的地方开始。遵循本书的标题，我们将在本章中花一些时间讨论一系列的反模式。虽然我还没有直接介绍模式的概念，但我怀疑您可以对它们以及它们的对立面做出有根据的猜测。**模式**，目前来说，是一个正式解释的、抽象的、最佳实践解决方案，用于解决常见的开发需求。**反模式**是一个正式的例子，说明了您不应该做什么。模式可以说是好的。反模式无疑是坏的。
- en: 'This chapter will present some of the most common antipatterns, including the
    following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些最常见的反模式，包括以下内容：
- en: Stovepipe systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 煤气管系统
- en: The Big Ball of Mud
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大泥球
- en: The Golden Hammer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金锤
- en: Once we’ve learned about a few antipatterns, we’ll focus in later chapters on
    principles and patterns designed to combat and correct the circumstances where
    antipatterns have either taken hold or might soon take hold. In [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036),
    *Prepping for Practical Real-World Applications of Patterns in C#*, I will prepare
    you for your work with patterns. Software development is an odd business in that
    we all come to it traveling different roads. I am personally self-taught. I started
    when I was 12 years old. The only books about computer programming were available
    for purchase at Radio Shack. There were about a dozen. We didn’t have resources
    such as **Packt Publishing** plying the market with fascinating and useful books
    on every facet of software development. In 1991, the year that I graduated from
    university, a computer science degree would have focused on software development
    for mainframes using FORTRAN, which is a far cry from the work I do now. The mainframe
    programming course I took in 1987 was the last class to use punch cards. If you’re
    not sure what they are, go look them up. I’ll wait. Are you back? Are you horrified?
    Me too. The point is, there are a lot of people such as me out there who learned
    programming out of necessity, and they learned informally.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了一些反模式，在后面的章节中，我们将重点关注旨在对抗和纠正反模式已经或可能很快占据主导地位的情况的原则和模式。在 [*第二章*](B18605_02.xhtml#_idTextAnchor036)
    中，*为C#中模式在现实世界中的应用做准备*，我将为你与模式的工作做好准备。软件开发是一个奇怪的行业，我们每个人都有不同的道路来到这里。我本人是自学成才的。我12岁时就开始了。关于计算机编程的唯一书籍可以在Radio
    Shack购买。大约有十几本。我们没有像 **Packt Publishing** 这样在市场上用关于软件开发各个方面的迷人而有用的书籍来吸引人的资源。1991年，我大学毕业那年，计算机科学学位将专注于使用FORTRAN为主机开发软件，这与我现在的工作相去甚远。我在1987年上的主机编程课程是最后一个使用穿孔卡的课程。如果你不确定它们是什么，去查查。我会等你。你回来了吗？你害怕了吗？我也是。重点是，像我这样的人还有很多，他们出于必要性学习编程，而且是非正式地学习的。
- en: There are many university-trained software developers out there, but not all
    software development programs are the same. Computer science programs focus on
    elements such as mathematical theory and algorithm development but teach only
    a minimal amount of practice. Software engineering programs, boot camps, and trade
    schools have more of an engineering focus, where you learn to build software with
    less of a focus on the theory. Regardless of where you started, [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036)
    aims to ensure that you understand the most important formal engineering concepts
    needed in order to work with patterns. Patterns were created using a set of rules
    and [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036) covers those rules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多受过大学教育的软件开发者，但并非所有软件开发课程都是一样的。计算机科学课程侧重于数学理论和算法开发等元素，但只教授很少的实践内容。软件工程课程、训练营和贸易学校则更侧重于工程，在那里你学习如何构建软件，而较少关注理论。无论你从哪里开始，[*第二章*](B18605_02.xhtml#_idTextAnchor036)
    的目标是确保你理解在运用模式时所需的最重要形式化工程概念。模式是通过一系列规则创建的，[*第二章*](B18605_02.xhtml#_idTextAnchor036)
    讲述了这些规则。
- en: 'In *Chapters 3*, *4*, and *5*, we cover patterns in earnest using a story format.
    I’ve done this in the hope of creating a learning experience very different than
    my own, having read some of the more heavy-handed academic treatments of design
    patterns. The patterns that I have selected for this book come from what is perhaps
    the seminal work on patterns in the software industry, *Design Patterns: Elements
    of Reusable Object-Oriented Software*, by Eric Gamma, Richard Helm, Ralph Johnson,
    and John Vlissides. These four authors are known collectively as **The Gang of
    Four** (**GoF**), and the book that they wrote is colloquially referred to as
    *The GoF book* or just *GoF*. *The GoF book* contains 23 patterns, broken down
    into three categories:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '在 *第三章*、*第四章* 和 *第五章* 中，我们将使用故事格式认真介绍模式。我这样做是为了创造一种与我自己阅读的一些更严厉的学术设计模式处理方式截然不同的学习体验。我为这本书选定的模式来自可能是软件行业模式的开创性工作，即
    Eric Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 所著的 *Design Patterns: Elements
    of Reusable Object-Oriented Software*。这四位作者共同被称为 **四人帮** (**GoF**)，他们所写的书通常被称为
    *The GoF book* 或简称为 *GoF*。*The GoF book* 包含23个模式，分为三个类别：'
- en: '**Creational patterns** deal with the creation of objects beyond simply using
    the new keyword.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模式**处理对象的创建，而不仅仅是使用new关键字。'
- en: '**Structural patterns** deal with the way that you structure your classes to
    maximize flexibility, reduce tight coupling, and help you focus on reusability.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**处理你如何结构化你的类以最大化灵活性、减少紧密耦合并帮助你关注可重用性。'
- en: '**Behavioral patterns** deal with how objects interact with one another.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**处理对象之间如何交互。'
- en: 'The creational patterns I’ll be covering in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)include
    the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[*第3章*](B18605_03.xhtml#_idTextAnchor063)中涵盖以下创建模式：
- en: The **Simple Factory** (technically not a pattern)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单工厂**（技术上不是一个模式）'
- en: The **Factory Method pattern**
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法模式**'
- en: The **Abstract Factory pattern**
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**'
- en: The **Builder pattern**
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者模式**'
- en: The **Object Pool pattern**
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象池模式**'
- en: The **Singleton pattern**
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**'
- en: 'Within the realm of structural patterns, in [*Chapter 4*](B18605_04.xhtml#_idTextAnchor078),
    I’ll be covering the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构模式的领域内，在[*第4章*](B18605_04.xhtml#_idTextAnchor078)中，我将涵盖以下内容：
- en: The **Decorator pattern**
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰者模式**'
- en: The **Façade pattern**
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观模式**'
- en: The **Composite pattern**
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合模式**'
- en: The **Bridge pattern**
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接模式**'
- en: 'Practical pattern coverage will conclude in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089)
    with this set of behavioral patterns:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的模式覆盖将在[*第5章*](B18605_05.xhtml#_idTextAnchor089)中通过这一组行为模式结束：
- en: The **Command pattern**
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令模式**'
- en: The **Iterator pattern**
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器模式**'
- en: The **Observer pattern**
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者模式**'
- en: The **Strategy pattern**
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式**'
- en: Again, I’ll point out that this book is designed to focus on real-world software
    development. In the real world, we don’t always perfectly follow the rules presented
    in [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036). Many books present a perfect
    experience. Expert authors always present all of their examples as perfect on
    the first try. I won’t be doing that because that isn’t in keeping with reality.
    As we flow through *Chapters 3*, *4*, and *5*, we will find ourselves faced with
    “gotchas” that you will find in actual practice. There’s no way around them. Even
    if you execute the patterns and strategies in these chapters perfectly, nobody
    can foretell the future. In [*Chapter 6*](B18605_06.xhtml#_idTextAnchor110), a
    plot twist in our story arises and we have a chance to rethink everything that
    we’ve done up to that point. In [*Chapter 6*](B18605_06.xhtml#_idTextAnchor110),
    we’ll design a new system based on an old one using the patterns that we’ve learned
    so far. [*Chapter 6*](B18605_06.xhtml#_idTextAnchor110) is all about creating
    a design and a plan. In [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136), we implement
    that plan.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次指出，这本书的设计是为了关注现实世界的软件开发。在现实世界中，我们并不总是完美地遵循在[*第2章*](B18605_02.xhtml#_idTextAnchor036)中提出的规则。许多书籍展示了一个完美的体验。专家作者总是将他们的所有示例第一次尝试就展示为完美的。我不会这样做，因为这不符合现实。当我们进入*第3章*、*第4章*和*第5章*时，我们会发现自己面临实际实践中会遇到的“陷阱”。没有回避的办法。即使你完美地执行这些章节中的模式和策略，也没有人能预测未来。在[*第6章*](B18605_06.xhtml#_idTextAnchor110)中，我们的故事中出现了一个转折，我们有机会重新思考我们之前所做的一切。在[*第6章*](B18605_06.xhtml#_idTextAnchor110)中，我们将基于我们迄今为止学到的模式设计一个新的系统。[*第6章*](B18605_06.xhtml#_idTextAnchor110)完全是关于创建设计和计划。在[*第7章*](B18605_07.xhtml#_idTextAnchor136)中，我们实施这个计划。
- en: I won’t be covering every pattern covered by the GoF. Instead, I’ll be focusing
    on the patterns you are most likely to need as a C# .NET software developer working
    in the field. I’ve selected my list of patterns based on popularity, usefulness,
    and complexity. Complex patterns that are not often seen in the wild have been
    omitted from the main text of the book. That said, I do circle back in [*Chapter
    8*](B18605_08.xhtml#_idTextAnchor152) to give you a rundown on the patterns that
    I didn’t cover, and the usual advice on where to go from there.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会涵盖GoF所涵盖的所有模式。相反，我将专注于你作为在现实世界中工作的C# .NET软件开发者最可能需要的模式。我已经根据流行度、有用性和复杂性选择了我的模式列表。那些在野外不常看到且复杂的模式已被从正文的主文中省略。话虽如此，我在[*第8章*](B18605_08.xhtml#_idTextAnchor152)中回顾了那些我没有涵盖的模式，并给出了通常的建议，告诉你接下来该怎么做。
- en: This book assumes that you have a few years of experience working with C#. In
    addition to my day job, I have taught software development at colleges for the
    last 25 years. I presently teach at Southern Methodist University’s Full Stack
    Code Bootcamp. Some of the programs I taught focused on C#, while others haven’t.
    At SMU we teach JavaScript. If you’re coming to this book without recent C# experience,
    or perhaps with none at all, I’ve added [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    at the end of the book. It is designed to give you what I hope is enough orientation
    in the C# language to make the rest of the book useful. The truth about patterns
    is they are language-agnostic. They apply to any object-oriented language, and
    I’ve even seen some of them shoehorned into languages that are not object-oriented
    with arguable levels of success.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您有几年使用C#的经验。除了我的日常工作外，我在过去25年里一直在大学教授软件开发。我现在在南方卫理公会大学的全栈代码训练营教授。我教授的一些课程侧重于C#，而其他课程则不是。在SMU，我们教授JavaScript。如果您没有最近的C#经验，或者可能完全没有，我在书的末尾添加了[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)。它旨在为您提供足够的C#语言导向，以便使本书的其余部分有用。关于模式的真实情况是它们是语言无关的。它们适用于任何面向对象的语言，我甚至看到一些模式被强行应用到非面向对象的语言中，并且有争议的成功程度。
- en: Technical requirements
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter presents some code examples. Most books always present exemplary
    code that makes sense for you to follow in the creation of the project. The code
    in this chapter is terrible on purpose. It isn’t strictly necessary that you follow
    along by creating the project, but you’re welcome to do so if you’d like.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一些代码示例。大多数书籍总是提供一些示例代码，这些代码对于你在创建项目时遵循是有意义的。本章中的代码故意很糟糕。您不一定需要通过创建项目来跟随，但如果您愿意，欢迎这样做。
- en: 'If this is the case, you’ll need the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，您将需要以下内容：
- en: A computer running the Windows OS. I’m using Windows 10\. Since the projects
    are simple command-line projects, I’m pretty sure everything here would also work
    on a Mac or Linux, but I haven’t tested the projects on these operating systems.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Windows操作系统的计算机。我使用的是Windows 10。由于项目是简单的命令行项目，我相当确信这里的一切也应在Mac或Linux上工作，但我还没有在这些操作系统上测试过这些项目。
- en: A supported IDE, such as Visual Studio, JetBrains Rider, or Visual Studio Code
    with C# extensions. I’m using Rider 2021.3.3.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个受支持的IDE，例如Visual Studio、JetBrains Rider或带有C#扩展的Visual Studio Code。我使用的是Rider
    2021.3.3。
- en: Some version of the .NET SDK. Again, the projects are simple enough that our
    code shouldn’t be reliant on any particular version. I happen to use the .NET
    Core 6 SDK and my code’s syntax may reflect that.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些版本的.NET SDK。再次强调，项目足够简单，我们的代码不应该依赖于任何特定版本。我恰好使用的是.NET Core 6 SDK，我的代码的语法可能反映了这一点。
- en: An instance of SQL Server and basic knowledge of SQL. I want to restate that
    the code in this chapter is designed to be a realistic example of throwaway code.
    C# and SQL Server go together as peanut butter and jam do, which adds to the realism.
    Some readers may not be comfortable working in SQL Server, especially without
    **Entity Framework** (**EF**) used for its presentation. This is the only place
    in this book where a database is even mentioned. If you have no experience with
    databases, don’t worry. The example is really meant to be read more than tried.
    If you want to try it, any version of SQL Server should work. I’ll be using SQL
    Server 2019.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SQL Server实例和基本的SQL知识。我想重申，本章中的代码旨在成为可丢弃代码的现实示例。C#和SQL Server就像花生酱和果酱一样搭配，这增加了现实感。一些读者可能不习惯在SQL
    Server中工作，尤其是没有使用**Entity Framework**（**EF**）进行展示的情况下。这本书中唯一提到数据库的地方就是这里。如果您没有数据库经验，请不要担心。示例的真正目的是阅读而不是尝试。如果您想尝试，任何版本的SQL
    Server都应该可以工作。我将使用SQL Server 2019。
- en: You can find the code files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-1/](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-1/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-1/](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-1/)。
- en: No battle plan survives first contact with the enemy
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有战斗计划能在与敌人首次接触后幸存
- en: 'There’s an old saying: *if you fail to plan, you plan to fail*. Only the rankest
    amateur would dive into a project IDE-first without at least considering how the
    project ought to be structured. The typical first steps might involve roughing
    out a package and object structure, or maybe designing the structure of a relational
    database that will persist the data used by our software. Someone who’s got a
    few projects under their belt might even draw some diagrams using the **Unified
    Modeling Language** (**UML**).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有句老话：“如果你没有计划，你就是在计划失败”。只有最业余的人才会在没有至少考虑项目应该如何结构的情况下，首先使用项目IDE进行项目。典型的第一步可能包括草拟一个包和对象结构，或者设计一个将持久化我们软件所使用数据的**关系数据库**的结构。那些有过几个项目经验的人甚至可能会用**统一建模语言**（**UML**）绘制一些图表。
- en: We begin by taking a set of user stories and we shape our code into something
    that on the surface meets the requirements in front of us. Soon, we’re in an agile
    groove swing. We’ve achieved velocity! We create a feature, show it to the customer,
    get feedback, revise, and continuously deliver. That’s usually how the troubles
    begin.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从一组用户故事开始，将我们的代码塑造成表面上满足我们面前要求的样子。很快，我们就进入了敏捷的节奏。我们实现了速度！我们创建了一个功能，向客户展示，获取反馈，修改，并持续交付。通常，麻烦就是这样开始的。
- en: Our first major anti-pattern, the stovepipe system, comes from the seminal book
    on the subject, *AntiPatterns*, by Brown, et al., which I’ve listed as suggested
    reading at the end of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第一大反模式，即烟囱系统，来源于该主题的开创性书籍，布朗等人所著的《反模式》（*AntiPatterns*），我在本章末尾将其列为推荐阅读。
- en: The Stovepipe system
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烟囱系统
- en: Once upon a time, in just about any industrialized society, people heated their
    homes and cooked using a cast-iron *potbelly* stove. These stoves burned coal
    or wood for fuel. Over time, the exhaust vent for the stove, called the stovepipe,
    since it was literally a pipe sticking out of the stove, would build up with corrosive
    deposits, which led to leaky stovepipes. The fumes from a burning stove are potentially
    life-threatening within a small, enclosed space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，在几乎任何工业化社会中，人们使用铸铁的*大肚子*炉子来供暖和烹饪。这些炉子以煤或木材为燃料。随着时间的推移，炉子的排气口，即烟囱，因为它是从炉子中伸出的管道，会积累腐蚀性沉积物，导致烟囱泄漏。在狭小的封闭空间内，燃烧炉子的烟雾可能具有致命的风险。
- en: 'Here’s what an actual stovepipe looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的是真正的烟囱的样子：
- en: '![Figure 1.1 – A stove with a stovepipe. ](img/B18605_Figure_1.1.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 带有烟囱的炉子](img/B18605_Figure_1.1.jpg)'
- en: Figure 1.1 – A stove with a stovepipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 带有烟囱的炉子。
- en: The stovepipe required constant maintenance to prevent asphyxiation. This was
    usually done by the owner of the stove, who was unlikely to be a stove repair
    professional. The stove was repaired using tools and materials that were readily
    available. This made for very ad hoc patch jobs, rather than clean, well-thought-out
    repairs done with **original equipment manufacturer** (**OEM**) grade materials
    and the proper tools.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 烟囱需要持续的维护以防止窒息。这通常由炉子的所有者来完成，他们不太可能是炉子维修专业人士。炉子的维修使用的是随手可得的工具和材料。这导致了非常随意的修补工作，而不是使用**原始设备制造商**（**OEM**）级材料和适当的工具完成的干净、经过深思熟虑的维修。
- en: Now, think about how this might relate to a software project. The initial release
    is designed with great care, with an implementation that perfectly matches the
    design. The natural tendency during software maintenance is to fix things quickly
    and get the patched version released and out the door. As with our amateurish
    stove repairs, our analysis of the holes in the software design and implementation
    are perfunctory and incomplete. There is pressure to solve this quickly. Everybody
    is watching you. Every minute the application is *down* costs the company money
    and you risk losing the *employee of the month* parking spot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想想这如何与一个软件项目相关。初始发布是精心设计的，实现与设计完美匹配。在软件维护期间，自然趋势是快速修复问题，并尽快发布修补版本。就像我们业余的炉子维修一样，我们对软件设计和实现的漏洞的分析是草率的和不完整的。有压力要快速解决这个问题。每个人都看着你。应用程序每分钟“宕机”都会给公司造成损失，你还有可能失去“本月员工”的停车位。
- en: This happens to everyone and everyone generally caves to human frailties. You
    then implement the quickest, easiest thing you can think of – it’s done and the
    patch is out the door. The crisis is over.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在每个人身上，而且每个人通常都会屈服于人性的弱点。然后，你实施你能想到的最快、最简单的事情——它完成了，补丁已经发布出去。危机结束了。
- en: 'Or is it? Dun dun dun! Small ad hoc fixes have a negative cumulative effect
    over time, referred to as technical debt, just as the corrosive deposits on a
    stovepipe do. How can you tell whether the systems that you’re working on are
    stovepipe systems? Let’s explore the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是吗？咚咚咚！小型临时修复随着时间的推移会产生负面的累积效应，这被称为技术债务，就像管道上的腐蚀性沉积物一样。你如何判断你正在工作的系统是否是管道式系统？让我们探讨以下内容：
- en: Stovepipe systems are monolithic by their very nature. It is not easy to get
    data in or out of this kind of system, and integrating software built this way
    into a larger enterprise architecture is cumbersome or impossible.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道式系统由于其本质上是单一的。很难将数据输入或输出到这种系统中，并且将这种方式的软件集成到更大的企业架构中既繁琐又不可能。
- en: Stovepipe systems are very brittle. When you make one of these small ad hoc
    repairs, you generally find that the fix breaks other parts of the application.  Usually,
    this isn’t discovered until after the breaking fix has been released.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道式系统非常脆弱。当你对这些小型的临时修复进行操作时，通常会发现修复会破坏应用程序的其他部分。通常，这种破坏直到修复后的版本发布后才会被发现。
- en: Stovepipe systems can’t be easily extended as new business requirements emerge.
    When a project starts, you’re given a set of requirements. You build the software
    that meets those requirements. After it’s released, a new feature is requested
    that you couldn’t possibly have predicted. You realize that there’s no way to
    implement that feature without redesigning the whole app. Anytime you’re tempted
    to throw out the baby with the bathwater and just start over, you’re working on
    a stovepipe system.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着新的业务需求的产生，管道式系统难以轻松扩展。当项目开始时，你会得到一组需求。你构建满足这些需求的软件。发布后，会要求添加一个你无法预见的全新功能。你意识到，没有重新设计整个应用程序就无法实现这个功能。任何时候你都有可能因为想要把“洗澡水连同婴儿一起倒掉”而从头开始，那么你就是在处理一个管道式系统。
- en: Stovepipe systems built on component architectures are generally incapable of
    sharing those components with other enterprise applications. The level of code
    reuse between projects is very low.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件架构构建的管道式系统通常无法与其他企业应用程序共享这些组件。项目之间的代码复用程度非常低。
- en: Stovepipe systems are often found on projects with high turnover. This makes
    sense. You start a new job, replacing the last developer, and you feel pressure
    to get something working quickly to show your new boss that hiring you wasn’t
    a huge mistake. You do your best to piece something together to fix a problem.
    You have no knowledge of the existing architecture or what’s been tried, and perhaps
    failed, in the past. Now amplify this by considering two or three further re-staffing
    efforts, with several months between each new hire’s start dates.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道式系统通常出现在人员流动率高的项目中。这很合理。你开始一份新工作，取代了最后一位开发者，你感到压力要快速让某物工作以向你的新老板证明雇佣你不是一个大错误。你尽力拼凑一些东西来解决问题。你对现有的架构或过去尝试过（可能失败）的东西一无所知。现在考虑一下，在每次新员工开始日期之间有几个月的时间，进行两三次进一步的重新人员配备。
- en: Stovepipe systems are often indicated when the development team is using new
    or unfamiliar technologies, stacks, or languages. Given that the same pressure
    to produce something quickly exists, while the team is simultaneously required
    to work with tools and languages that they’ve never used before, this leads to
    the same pattern of *just getting something working and released*. You will also
    encounter stovepipe systems in start-ups, corporate acquisitions, and mergers
    for these same reasons.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发团队使用新的或陌生的技术、技术栈或语言时，通常会指示管道式系统。鉴于存在快速生产东西的压力，同时团队还必须使用他们以前从未使用过的工具和语言，这会导致相同的模式：只是让某物工作并发布。你也会在初创公司、企业收购和合并中遇到管道式系统，原因相同。
- en: Does any of this sound familiar? Naturally, we’re not talking about anything
    you’ve ever written! Isn’t this just a little bit reminiscent of code you’ve seen
    other people write? Maybe your competitors? Maybe your students? Even if you own
    up to writing a stovepipe system, don’t beat yourself up. It is far and away the
    most popular pattern in software development today. Sometimes, a stovepipe system
    is fine. Remember, not every physical edifice needs to be supported by fluted
    ivory columns, and there’s a very legitimate argument to be made for getting the
    software to market and worrying about the rest later. However, if your objective
    is to build software that’s still useful and profitable 10 years or more down
    the road, keep reading. We’ll have those stovepipes replaced with functional,
    modular, well-constructed systems in no time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来熟悉吗？当然，我们不是在谈论你曾经编写过的任何东西！这难道不是让你想起了你看到别人编写的代码吗？也许是你的竞争对手？也许是你的学生？即使你承认编写过烟囱系统，也不要自责。这现在是软件开发中最流行的模式。有时，烟囱系统是可以接受的。记住，并非每个物理建筑都需要由有凹槽的象牙柱支撑，而且关于将软件推向市场并在以后再处理其他问题的论点是很有道理的。然而，如果你的目标是构建10年或更长时间后仍然有用和有利可图的软件，请继续阅读。我们将很快用功能性强、模块化、结构良好的系统替换这些烟囱系统。
- en: The Big Ball of Mud
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《大泥球》
- en: Around the same time Brown, et al. were writing their book on antipatterns,
    another research team was engaged in a similar effort. The product of their work
    was titled *Big Ball of Mud*, by Foote and Yoder (1997), which I’ve listed in
    the *Further reading* section at the end of this chapter. It’s their work that
    inspires the title of this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大概在同一时间，布朗等人正在撰写关于反模式的书籍时，另一支研究团队也在进行类似的工作。他们工作的成果被命名为《大泥球》，由福特和约德（1997年）所著，我在本章末尾的“进一步阅读”部分列出了这本书。正是他们的工作启发了本章的标题。
- en: The Big Ball of Mud antipattern is remarkably similar to our outline of stovepipe
    systems. However, the authors go into greater depth on how these systems understandably
    come to be.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 《大泥球》反模式与我们关于烟囱系统的概述惊人地相似。然而，作者们更深入地探讨了这些系统是如何合理地形成的。
- en: 'They often start with **throwaway code**. I think this is self-explanatory.
    It’s code that you knock out in a few hours, or even a few weeks, that serves
    as a rough prototype. It proves to you and perhaps your stakeholders that the
    problem in front of you is soluble. It might even be good enough to demonstrate
    to the client. This is where the trap is sprung. The prototype is good enough
    to publish, so, at the behest of your boss, you do. We’ll simulate this later
    in this chapter in a section titled *A throwaway code example* by intentionally
    building a prototype that is good enough to ship, but not good enough to survive
    extension. This rough prototype will do everything asked of us. Right after this
    imaginary software project ships its first release, we’ll then find ourselves
    faced with a second factor in the construction of a Big Ball of Mud: **piecemeal
    growth**. A project manager might refer to this pejoratively as *scope creep*.
    I have been a consulting software engineer and a corporate software engineer.
    I can tell you the project management view of scope creep as being something negative
    is misinformed. While it is a source of frustration from a planning and billing
    perspective, new requirements coming in after the initial release are the hallmark
    of a successful system. It is my strongest advice that you begin every project
    with the idea that it will be wildly successful. This may seem overly optimistic,
    but it is in fact the worst-case scenario if you have published throwaway code.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常从**废弃代码**开始。我认为这很容易理解。这是你花几个小时甚至几周时间敲出来的代码，作为粗糙的原型。它向你和可能的项目利益相关者证明，你面前的问题是可以解决的。它甚至可能足够好，可以向客户展示。这就是陷阱出现的地方。原型足够好可以发布，所以，在你老板的要求下，你发布了它。我们将在本章的“废弃代码示例”部分通过故意构建一个足够好可以发货但不足以扩展的原型来模拟这一点。这个粗糙的原型将完成我们所要求的一切。在这个虚构的软件项目发布第一个版本后，我们就会发现自己面临构建大泥球时的第二个因素：**零散增长**。项目经理可能会贬义地称之为“范围蔓延”。我曾是一名咨询软件工程师和公司软件工程师。我可以告诉你，从项目管理角度来看，将范围蔓延视为负面的事情是错误的。虽然从计划和计费的角度来看，初始发布后出现的新需求是令人沮丧的，但新需求的出现是成功系统的标志。我最强烈的建议是，你开始每个项目时都要有它将非常成功的想法。这听起来可能过于乐观，但实际上，如果你发布了废弃代码，这是最坏的情况。
- en: Piecemeal growth leads to a strategy called **keeping it working**. Again, this
    needs little explanation. As bugs and new features are identified, you just fix
    the offending bits and make the program satisfy the new set of requirements. And,
    oh, by the way, we need this done by next week.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 零散的增长导致了一种被称为**保持运行**的策略。再次强调，这不需要太多解释。当发现错误和新功能时，你只需修复有问题的部分，使程序满足新的需求集。顺便说一句，我们下周就需要完成这项工作。
- en: After the second release, *keeping it working* becomes your daily job description.
    If your program is really successful, you will start to hire people to help you
    with *keeping it working*, which naturally amplifies the problems and technical
    debt as the project continues to grow.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次发布之后，**保持运行**变成了你的日常工作描述。如果你的程序真的非常成功，你将开始雇佣人来帮助你**保持运行**，这自然会放大问题和技术债务，因为项目继续增长。
- en: 'To reiterate, this sounds very similar to our elucidation of a stovepipe system.
    Foote and Yoder consider in more detail the forces that lead to our unfortunate
    muddy circumstances. Forces, as in nature, are outside actors that you can rarely
    ever control. These forces consist of the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这听起来与我们阐述的管道系统非常相似。福特和约德更详细地考虑了导致我们不幸混乱状况的力量。力量，就像自然界一样，是外部因素，你很少能控制。这些力量包括以下内容：
- en: Time
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间
- en: Cost
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本
- en: Experience
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经验
- en: Skill
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技能
- en: Visibility
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性
- en: Complexity
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性
- en: Change
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化
- en: Scale
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模
- en: Let’s talk a little more about each.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地谈谈每个方面。
- en: Time
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间
- en: 'You may not be given enough time to seriously consider the long-term ramifications
    of the architectural choices that you’re currently making. Time also limits your
    project by limiting what you can accomplish with what you’re allotted. Most developers
    and project managers try to get around this by padding their estimates. In my
    experience, Parkinson’s law is true: projects where time estimates are padded,
    or even doubled, usually expand to fill or exceed the time allotted.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有足够的时间来认真考虑你目前所做的架构选择的长期影响。时间也限制了你的项目，限制了你可以用分配的资源完成的事情。大多数开发人员和项目经理试图通过增加他们的估计来解决这个问题。在我的经验中，帕金森定律是正确的：那些时间估计被增加，甚至翻倍的项目，通常会扩展到填满或超过分配的时间。
- en: Cost
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成本
- en: Most projects don’t have an infinite budget. Those that do are open source projects
    that have no monetary budget at all, instead substituting it with the time of
    volunteers, which is itself a cost. Architecture is expensive. The people with
    the knowledge and experience to develop a sound architecture are rare, though
    slightly less inaccessible given that you are reading this book. They tend to
    draw higher salaries, and the expense involved in the effort to create and maintain
    proper architecture doesn’t pay off immediately in the minds of your stakeholders,
    bosses, or customers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目没有无限的预算。那些有无限预算的是开源项目，它们根本没有任何货币预算，而是用志愿者的时间来代替，这本身也是一种成本。架构很昂贵。拥有知识和经验来开发良好架构的人很少，尽管由于你正在阅读这本书，他们稍微不那么难以接触。他们倾向于获得更高的薪水，而创建和维护适当架构的努力所涉及的成本在利益相关者、老板或客户的心中并不立即得到回报。
- en: Good architecture requires time, both on the part of the development staff and
    the architect, but also domain experts who know the business behind the software.
    The domain experts are rarely dedicated to the software development effort. They
    have regular jobs with real requirements and deadlines outside the software project.
    Involving a business consultant who bills at $250 USD per hour is eating up time
    that could be billable, but you honestly can’t complete the project without this
    access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的架构需要时间，不仅需要开发人员和架构师的时间，还需要了解软件背后业务领域的领域专家的时间。领域专家很少致力于软件开发工作。他们有常规的工作，有真实的需求和项目外的截止日期。聘请每小时收费250美元的商业顾问正在消耗本可以收费的时间，但你诚实地讲，没有这种访问，你无法完成项目。
- en: Experience
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验
- en: Software developers are experts in software development. They rarely have expertise
    in the business domain where they are building solutions. For example, it’s rare
    that someone building a system that quotes insurance policies has worked as an
    actuary or even an adjuster. Lack of experience in the business domain makes the
    job of modeling software a process of trial and error, which naturally affects
    the program’s architecture.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者是软件开发方面的专家。他们很少在构建解决方案的业务领域拥有专业知识。例如，构建引用保险政策的系统的人很少曾是精算师，甚至调整员。在业务领域的经验不足使得软件建模成为一项试错的过程，这自然会影响到程序的架构。
- en: Skill
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技能
- en: Not all software developers have equal levels of skill. Some are new to the
    field. Some are slower learners than others. Some learned to use a few golden
    hammers (more on this later) and refuse to upskill any further. And there’s always
    a superstar on the project that makes everybody else feel as though they’re a
    poser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有软件开发者都拥有相同水平的技能。有些人刚进入这个领域。有些人学习速度比其他人慢。有些人学会了使用一些“黄金锤子”（稍后会更详细地讨论）并且拒绝进一步提升技能。而且，在项目中总有一个超级明星，让其他人感觉自己像是在装模作样。
- en: Visibility
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视性
- en: You can’t see inside a working program. Sure, you can fire up a debugger, but
    normal people can’t look around the architecture of your code the same way that
    they can inspect the architecture of a physical structure such as an office building.
    For this reason, architecture is neglected. Your boss will not likely give you
    a fat bonus for your amazing abstractions and interface structures. They will,
    however, reward you for shipping early. This leads to a very human, lackadaisical
    attitude toward how your code is structured.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法看到正在运行程序内部。当然，你可以启动调试器，但普通人无法像检查一座办公楼等物理结构的架构那样检查你的代码架构。因此，架构常常被忽视。你的老板不太可能因为你惊人的抽象和接口结构给你一个丰厚的奖金。然而，他们会奖励你早点交付。这导致了一种非常人性化的、漫不经心的态度，对待你的代码结构。
- en: Complexity
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性
- en: Complex problem domains beget muddy architectures. Imagine modeling a collection
    of modern light bulbs. That’s pretty easy. Properties such as wattage, light output
    in lumens, and input voltage jump out at you as if they are second nature. Now,
    imagine modeling a light bulb in 1878\. You’re in uncharted territory. Thomas
    Edison patented his first light bulb in 1879 and is famously quoted as saying
    that he had discovered two thousand ways to not build a light bulb. If the domain
    is complex or unexplored, you should expect a bumpy ride as far as your architecture
    is concerned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的问题领域会产生混乱的架构。想象一下建模一组现代灯泡。这很简单。如瓦数、光输出（以流明为单位）和输入电压等属性会跃然纸上，仿佛它们是第二本能。现在，想象一下在1878年建模一个灯泡。你进入了未知领域。托马斯·爱迪生在1879年获得了他的第一个灯泡的专利，并且著名地引用说，他已经发现了两千种不制造灯泡的方法。如果领域复杂或未探索，你应该预期你的架构将面临坎坷。
- en: Change
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变化
- en: 'Change is the one thing that always remains constant. Foote and Yoder wrote
    that when we devise an architecture, it is based entirely upon a supposition:
    a set of assumptions about the future wherein we expect changes and extensions
    to that architecture to be bound only to the realm of possibilities that we have
    considered so far. This is all well and good, except another truism invariably
    surfaces: no battle plan survives first contact with the enemy. The change requests
    will come in the most inconvenient form, at the most inconvenient time, and it’s
    your job to deal with that. The easy way out is always the most palatable to the
    stakeholders but it is what leads to a Big Ball of Mud.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 变化是唯一始终如一的事情。福特和约德写道，当我们设计架构时，它完全基于一个假设：一套关于未来的假设，我们期望对那个架构的更改和扩展仅限于我们迄今为止考虑的可能性领域。这听起来很好，但不可避免地会出现另一个真理：没有战斗计划能在与敌人首次接触后幸存。变更请求将以最不方便的形式出现，在最不方便的时间，而你的工作就是处理这些请求。对利益相关者来说，最容易的方法总是最令人愉悦的，但它正是导致大泥球（Big
    Ball of Mud）的原因。
- en: Scale
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规模
- en: Creating a system to be used by 100 people in total is a very different problem
    than creating a system that can process 10,000 requests per second. The style
    in which you write your code is different. Your reliance on highly performant
    algorithms is largely absent in a small system, but vital to the success of a
    large one. Rarely do projects start at the scale typically considered by Google
    or Amazon. Successful projects must be able to scale up according to how successful
    they become.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个供100人使用的系统与创建一个每秒可以处理10,000个请求的系统是非常不同的问题。你编写代码的风格也不同。在一个小系统中，你高度依赖高性能算法的情况很少见，但在一个大型系统中，这是至关重要的。很少有项目从谷歌或亚马逊通常考虑的规模开始。成功的项目必须能够根据其成功程度进行扩展。
- en: The Golden Hammer
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黄金锤子
- en: Another important antipattern you should learn to recognize is generally a product
    of some marketing organization or salesperson in a company outside your own. It
    happens when some killer app, framework, infrastructure component, or tool is
    presented as the panacea for all your software development woes. It slices, it
    dices, it makes julienne fries, and it automatically refactors itself while speeding
    up the execution of your code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该学会识别的重要反模式通常是一些营销组织或你公司外部销售人员的产品。这种情况发生在某个杀手级应用、框架、基础设施组件或工具被展示为解决你所有软件开发问题的万能药。它切片，它切块，它制作法式炸薯条，并在加速代码执行的同时自动重构自己。
- en: 'The antipattern is described as the **Golden Hammer**. Behold a fully-rendered
    CGI representation in *Figure 1.2*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式被描述为**金锤**。请看 *图 1.2* 中的完整渲染的 CGI 表示：
- en: '![Figure 1.2 – When you’re given a golden hammer, everything is a nail. ](img/B18605_Figure_1.2.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 当你有一把金锤时，一切都是钉子。](img/B18605_Figure_1.2.jpg)'
- en: Figure 1.2 – When you’re given a golden hammer, everything is a nail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 当你有一把金锤时，一切都是钉子。
- en: Silicon snake oil salespeople will visit you, take you out to someplace fancy,
    and try to convince you that the database tool, platform, or **whatever-as-a-service**
    (**WaaS**) that they’re selling can be the entire basis for your company’s software.
    Consider Microsoft SQL Server for a minute. At its most basic, SQL Server is a
    relational database. It stores your data in tables that you can query. Related
    tables of data can be joined and filtered allowing a developer who understands
    the **Structured Query Language** (**SQL**) to produce reporting data in any format
    or configuration. This is a common functionality found in every relational database
    tool from *Microsoft Access* and *SQLite* to *Oracle* and *Microsoft SQL Server*.
    Since SQL is a standardized language, offering this basic functionality is little
    more than *table* stakes. Just so we understand each other, all puns are intended.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 硅谷油销售员会拜访你，带你到一些高档的地方，并试图说服你，他们出售的数据库工具、平台或**任何作为服务**（**WaaS**）可以成为你公司软件的全部基础。考虑一下微软的
    SQL Server。在最基本的情况下，SQL Server 是一个关系型数据库。它将你的数据存储在你可以查询的表中。相关数据表可以连接和筛选，允许理解 **结构化查询语言**（**SQL**）的开发者以任何格式或配置生成报告数据。这是每个关系型数据库工具都具备的常见功能，从
    *Microsoft Access* 和 *SQLite* 到 *Oracle* 和 *Microsoft SQL Server*。由于 SQL 是一种标准化的语言，提供这种基本功能不过是
    *桌面赌注*。仅为了我们相互理解，所有的双关语都是有意为之。
- en: So, how could Microsoft expect to charge money for something that you can get
    for free in open source offerings such as *MySQL* and *PostgreSQL*? Granted, SQL
    Server got started before they did when there were fewer rivals in the marketplace,
    but SQL Server is one of the most popular platforms for managing data today. This
    is because SQL Server’s value contribution doesn’t end with tabular data storage.
    As the product has grown over the years, new features and ancillary tools have
    been added. You have the ability to load and analyze data in novel and sophisticated
    ways using *SQL Server Analysis Services*. *SQL Server Reporting Services* allows
    you to create reports using SQL and then present those reports graphically to
    whoever might need them by emailing the reports as PDFs. It also allows users
    to access the report on the server and play around with the data without needing
    to know SQL or have access to the underlying code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，微软怎么能期望为那些在开源产品如 *MySQL* 和 *PostgreSQL* 中可以免费获得的东西收费呢？当然，SQL Server 在市场上竞争对手较少的时候就已经开始发展了，但
    SQL Server 仍然是今天最受欢迎的数据管理平台之一。这是因为 SQL Server 的价值贡献不仅仅局限于表格数据存储。随着产品多年的发展，新增了许多功能和辅助工具。您可以使用
    *SQL Server Analysis Services* 以新颖和复杂的方式加载数据和分析数据。*SQL Server Reporting Services*
    允许您使用 SQL 创建报告，然后将这些报告以图形方式呈现给可能需要它们的人，通过发送 PDF 格式的报告电子邮件。它还允许用户在服务器上访问报告，并可以无需了解
    SQL 或访问底层代码的情况下对数据进行操作。
- en: There are supported workflows for working with AI and machine learning projects
    using R and Python, and you can make bits of code in C# that process in the database
    such as a native stored procedure. *SQL Server Integration Services* allows you
    to ingest and publish data to a variety of different databases, software services,
    and industry formats. This leads to the ability to integrate your software and
    services with your business partners and customers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有支持的工作流程用于使用R和Python处理AI和机器学习项目，你可以用C#编写一些代码，这些代码在数据库中处理，例如本地的存储过程。*SQL Server
    Integration Services* 允许你将数据导入并发布到各种不同的数据库、软件服务和行业格式。这导致你能够将你的软件和服务与你的商业伙伴和客户集成。
- en: 'In short, if you tried hard enough, you could probably write a great deal of
    an application, if not an entire one, solely using SQL Server’s ecosystem. SQL
    Server is the Golden Hammer. Every problem now looks as if it’s something that
    can be solved with SQL Server. I want to point out that I am not vilifying SQL
    Server. It’s a reliable and cost-effective set of tools. I go out of my way to
    recommend it at parties and my advice is always well received. Note to self: find
    better parties. I picked on SQL Server because I’ve seen it happen with this particular
    tool. If you spend too much time reading the marketing material for SQL Server,
    it would be easy for you to walk away with the same conclusion: that SQL Server
    is all you need. Maybe it is, but you should only make that decision after you
    understand the Golden Hammer antipattern, lest you wind up painting yourself into
    a technological corner.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你足够努力，你可能会写出一个相当大的应用程序，如果不是整个应用程序，仅使用SQL Server的生态系统。SQL Server是金锤。现在每个问题看起来都像是可以用SQL
    Server解决的问题。我想指出的是，我并不是在诋毁SQL Server。它是一套可靠且经济的工具集。我会在聚会上不遗余力地推荐它，我的建议总是受到欢迎。提醒自己：找到更好的聚会。我之所以挑剔SQL
    Server，是因为我看到了这个特定工具发生的事情。如果你花太多时间阅读SQL Server的市场营销材料，你很容易得出同样的结论：SQL Server是你所需要的所有东西。也许它确实是，但你应该在了解金锤反模式之后才做出这个决定，以免你最终陷入技术困境。
- en: The Golden Hammer also emerges when a developer learns about some technology
    that was unknown to them before. They use it. They like it. They’re rewarded for
    it in the form of fast or novel solutions to a problem. Since that worked out
    so well, and since they’ve gone to the effort of adding a new skill to their skill
    set, they try to use that tool or technique to solve every problem that they encounter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个开发者了解到他们之前不知道的一些技术时，金锤也会出现。他们使用了这项技术，他们喜欢它。他们因为快速或新颖的解决方案而得到了奖励。由于效果如此之好，并且他们已经努力将一项新技能添加到他们的技能集中，他们试图使用这个工具或技术来解决他们遇到的每一个问题。
- en: Once, I took over a project that was in trouble. The lead programmer on a small
    team was being let go and most of his team left shortly after I replaced him.
    Interpersonal drama aside, I set out to understand the new project and the business
    domain by going through the existing code base.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，我接管了一个陷入困境的项目。一个小团队的主程序员被解雇了，在他被替换后不久，他的大部分团队成员也离开了。抛开人际冲突不谈，我通过审查现有的代码库来了解新的项目和业务领域。
- en: I asked around and, as it turned out, the original staff on the project were
    with a consulting firm. The firm sent a couple of their ace developers over to
    meet and gather requirements. Upon seeing the prototypes that the client had themselves
    produced in Excel, using **Visual Basic for Applications** (**VBA**), the consultants
    concluded that they could produce *real code* in a *real language* and have a
    fully converted program running in under a month.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我四处询问，结果发现这个项目的原始团队成员都在一家咨询公司。该公司派了几位顶尖的开发者过来会面并收集需求。在看到客户自己用**Visual Basic
    for Applications**（**VBA**）在Excel中制作的原型后，顾问们得出结论，他们可以用**真正的语言**编写**真正的代码**，并在一个月内完成一个完全转换的程序。
- en: Two years went by with no usable deliverables. The ace developers either grossly
    underestimated the prototype they were working with or overestimated their capabilities.
    I think it was a little of both. Most developers look down their noses at VBA.
    I’ll admit that I used to, even though I’ve written quite a bit of VBA code. The
    consultants erroneously concluded that VBA is simplistic. They believed anything
    written in VBA would involve a trivial amount of effort to convert to a language
    as powerful as C#, backed by the equally powerful .NET Framework and SQL Server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两年过去了，没有可用的交付成果。顶尖的开发者要么大大低估了他们正在工作的原型，要么高估了自己的能力。我认为两者都有。大多数开发者都看不起 VBA。我必须承认，尽管我写过相当多的
    VBA 代码，我以前也这样认为。顾问错误地认为 VBA 是简单的。他们认为用 VBA 编写的任何东西都只需要微不足道的努力就可以转换为像 C# 这样强大的语言，由同样强大的
    .NET 框架和 SQL Server 支持。
- en: After a few months with very little progress, the consulting firm pulled their
    ace developers off the project to work on something else and the project was staffed
    entirely by junior developers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月几乎没有进展后，咨询公司撤回了顶尖的开发者去从事其他工作，项目完全由初级开发者组成。
- en: 'Given the antipatterns we’ve covered so far, you can already see where this
    story is headed. I inherited this code after two and half years without a viable
    release. As I went through the existing code, I was able to see where the junior
    developers had encountered some tool or technique. It was as if I was looking
    at rings on a tree:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们迄今为止已经讨论的反模式，你现在已经可以看到这个故事将走向何方。我在两年半没有可行的发布之后继承了这段代码。在我审查现有代码的过程中，我能够看到初级开发者遇到了某些工具或技术。这就像我正在观察树上的年轮：
- en: '![Figure 1.3 – The effects of new developers discovering a golden hammer are
    analogous to tree rings in their code. ](img/B18605_Figure_1.3(old).jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 新开发者发现黄金锤子的影响与他们的代码中的年轮相似。](img/B18605_Figure_1.3(old).jpg)'
- en: Figure 1.3 – The effects of new developers discovering a golden hammer are analogous
    to tree rings in their code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 新开发者发现黄金锤子的影响与他们的代码中的年轮相似。
- en: You can tell exactly where they have learned that a stored procedure can be
    used in SQL Server because, from that point forward, the business logic suddenly
    moved out of the code and into the database. This is usually a bad idea. It’s
    often done because you can change the business rules without compiling and publishing
    a new executable, allowing you to make minor or major adjustments. This is roughly
    akin to working on the engine of an airplane while it’s flying at 1,261 knots
    (about 1,453 mph or 2,336 km/h) at 30,000 feet (9,144 m).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以确切地知道他们是在哪里了解到在 SQL Server 中可以使用存储过程，因为从那时起，业务逻辑突然从代码中移出，进入了数据库。这通常是一个坏主意。这样做通常是因为你可以在不编译和发布新可执行文件的情况下更改业务规则，允许你进行小的或大的调整。这大约相当于在飞机以
    1,261 节（约 1,453 英里/小时或 2,336 公里/小时）的速度在 30,000 英尺（9,144 米）高空飞行时对其引擎进行工作。
- en: Somewhere else, you can tell they have read a book on patterns because the code
    changes. Suddenly, everything has interfaces and uses the factory pattern, which
    we’ll cover later in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063). Some of
    this was good. I could see that they were improving. However, a lot of it was
    someone picking up a new hammer and using it to bang everything around it into
    the shape of something useful. This was evident mainly because they were never
    given a chance to go back and refactor their earlier work. They used different
    techniques at different points in time. They weren’t always using the best tool
    for the job, but they were motivated by the forces we discussed earlier. They
    did their best with what they had, as with our stovepipe repair jobs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他地方，你可以看出他们读过一本关于模式的书籍，因为代码发生了变化。突然之间，一切都有了接口，并使用了工厂模式，我们将在[第 3 章](B18605_03.xhtml#_idTextAnchor063)中稍后讨论。其中一些是好的。我可以看出他们在进步。然而，很多都是有人捡起新的锤子，用它来敲打周围的一切，使其变得有用。这主要因为从未给他们机会回过头来重构早期的工作。他们在不同时间使用了不同的技术。他们并不总是使用最适合工作的工具，但他们受到了我们之前讨论的力量的驱动。他们尽其所能，就像我们的烟囱修理工作一样。
- en: A throwaway code example
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个废弃的代码示例
- en: 'Let’s take a look at some throwaway code. Remember, throwaway code is written
    quickly, with little thought to architecture. It’s good enough to ship but not
    good enough to survive extension. Consider a program designed to ingest log data
    from a popular web server, and subsequently analyze and present salient information
    in the form of a report rendered in HTML. You will be analyzing logs from NGINX
    (pronounced ‘engine-ex’), one of the most popular web server programs in use today.
    I usually write a user story in an issue tracker, but I’ll write it as a Markdown
    file in lieu, and I’ll include it with my project so that I have a record of my
    requirements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些临时代码。记住，临时代码是快速编写的，对架构的考虑很少。它足够用于发布，但不足以应对扩展。考虑一个旨在从流行的网络服务器中获取日志数据、随后分析和以
    HTML 报告形式呈现关键信息的程序。您将分析来自 NGINX（发音为‘engine-ex’）的日志，它是目前使用最广泛的网络服务器程序之一。我通常在问题跟踪器中编写用户故事，但这次我将用
    Markdown 文件代替，并将其包含在我的项目中，以便我有记录我的需求的记录：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Your team decides to use C# and SQL Server to read, parse, and store the data
    for analysis. They decide that, while there are several good templating systems
    out there, nobody on the team has ever used any of them. Time is short and HTML
    is simple, so we’ll just write our own code to convert our results represented
    by the results of SQL statements. Let’s dive in! The requirements stipulate a
    console application, so that’s the project type I used when creating it in my
    IDE. I won’t be walking you through creating the project. I’m assuming you know
    how to create a console application using the new project options in Visual Studio.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队决定使用 C# 和 SQL Server 来读取、解析和存储用于分析的数据。他们决定，尽管市面上有几种不错的模板系统，但团队中没有人使用过任何一种。时间紧迫，HTML
    简单，所以我们只需编写自己的代码来将 SQL 语句的结果表示的结果转换为我们的结果。让我们开始吧！需求规定了一个控制台应用程序，因此我在我的 IDE 中创建项目时使用了这种项目类型。我不会向您展示如何创建项目。我假设您知道如何使用
    Visual Studio 中的新项目选项创建控制台应用程序。
- en: 'The input data from an NGINX log looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 NGINX 日志的输入数据如下所示：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you create a console app project in Visual Studio, it creates a file called
    `Program.cs`. We’re not going to do anything with `Program.cs` yet. I’m going
    to start by creating a new class file to represent a log entry. I’ll call it `NginxLogEntry`.
    I can see in my sample data that we have a date field, so I know that I’m going
    to need internationalization, owing to the cultural info needed to render a date.
    So, let’s get the basics in place with a `using` statement for the globalization
    package, a namespace, and the class. Visual Studio likes to mark the classes with
    an internal access modifier. Call me old-fashioned. I always change them to `public`,
    assuming that’s appropriate, and in this case, it is:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Visual Studio 中创建控制台应用程序项目时，它会创建一个名为 `Program.cs` 的文件。我们目前不会对 `Program.cs`
    做任何事情。我将首先创建一个新的类文件来表示日志条目。我将称它为 `NginxLogEntry`。我在我的样本数据中可以看到有一个日期字段，所以我将需要国际化，因为渲染日期需要文化信息。因此，让我们通过全球化包的
    `using` 语句、命名空间和类来设置基本设置。Visual Studio 喜欢使用内部访问修饰符标记类。叫我老派吧。我总是将它们更改为 `public`，假设这是合适的，在这种情况下，确实如此：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the basics out of the way, let’s set up our member variables. Aside from
    a couple of constructors, that’s really all we’ll need since this class is designed
    to represent the line entries in the log.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基本设置完成之后，让我们设置我们的成员变量。除了几个构造函数之外，这基本上就是我们所需要的，因为这个类的设计是为了表示日志中的行条目。
- en: 'The fields we’re interested in are visually identifiable in the preceding data
    sample:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的字段在先前的数据样本中可以直观识别：
- en: '`ServerIPAddress` represents the IP address of the web server from which the
    log was taken.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerIPAddress` 表示从其中获取日志的网络服务器的 IP 地址。'
- en: '`RequestDateTime` represents the date and time of each request in the log.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestDateTime` 表示日志中每个请求的日期和时间。'
- en: '`Verb` represents the HTTP `verb` or `request` method. We’ll be supporting
    four, though there are many more available.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Verb` 表示 HTTP 的 `verb` 或 `request` 方法。我们将支持四种，尽管还有更多可用。'
- en: '`Route` represents the route of the request. Our sample is from a RESTful API.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Route` 表示请求的路径。我们的样本来自 RESTful API。'
- en: '`ResponseCode` represents the HTTP response code for the request. Successful
    codes are in the 200 and 300 range. Unsuccessful codes are in the 400 and 500
    range.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseCode` 表示请求的 HTTP 响应代码。成功的代码在 200 和 300 范围内。不成功的代码在 400 和 500 范围内。'
- en: '`SizeInBytes` represents the size of the data returned by the request.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SizeInBytes` 表示请求返回的数据的大小。'
- en: '`RequestingAgent` represents the HTTP agent used to make the request. This
    is usually a reference to the web browser used, but in all the cases in our sample,
    it is a client written in Python 3 using the popular `requests` library.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestingAgent`代表用于发起请求的HTTP代理。这通常是指使用的网络浏览器，但在我们样本中的所有情况下，它都是用Python 3编写的客户端，使用了流行的`requests`库。'
- en: 'In addition to our fields, I’ll start with an `enum` to store the four acceptable
    values for the HTTP methods, which I’ve called `HTTPVerbs`. The rest are represented
    with straightforward auto-properties:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的字段外，我还将从一个`enum`开始，用于存储HTTP方法的四个可接受值，我将其称为`HTTPVerbs`。其余的用简单的自动属性表示：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that I’ve got my enumeration and properties in place, I’m going to make
    a couple of constructors. I want one constructor that allows me to pass in a line
    from the log. The constructor will parse the line and return a fully populated
    class with the log line as an input. Here’s the top of the first constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经设置了枚举和属性，我将创建几个构造函数。我希望有一个构造函数允许我传入一个日志行。构造函数将解析该行，并返回一个包含日志行的完整类。以下是第一个构造函数的顶部代码：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, I’ll take the log line being passed in and split it into a string array,
    using the `.Split()` method, which is part of the `string` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我会使用`.Split()`方法将传入的日志行分割成一个字符串数组，这是`string`类的一部分：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While developing, I run into some corner cases. Sometimes, the log lines don’t
    have 12 fields, as I expect. To account for this, I add a conditional that detects
    log lines that come in with fewer than 12 parts. This rarely happens but when
    it does, I want to send them to the console so that I can see what is going on.
    This is the kind of thing you’d probably take out. I’m embracing my inner stovepipe
    developer here, so I’m leaving it in:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我遇到了一些边缘情况。有时，日志行没有12个字段，正如我所预期的。为了解决这个问题，我添加了一个条件，用于检测包含少于12个部分的日志行。这种情况很少发生，但一旦发生，我希望将它们发送到控制台，以便我可以看到发生了什么。这类事情你可能想要移除。在这里，我正在拥抱我内心的管道开发者，所以我会保留它：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s set to work taking apart the line based on the split. It’s pretty
    easy to pick out the server IP address as the first element of the split array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据分割来拆分这一行。从分割数组中挑选出服务器IP地址作为第一个元素很容易：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We don’t care about those two dashes in positions 1 and 2\. We can see the
    date in the third position. Dealing with dates has always been slightly more fun
    than your average root canal. Think about all the formatting and the parsing needed
    just to get it into something we know will work with the database code that we’ll
    eventually write. Thankfully, C# handles this with aplomb. We pull out the date
    parts and we use a custom date format parser. I don’t really care about expressing
    the date in terms of locale, so I’ll use `InvariantCulture` as the second argument
    in the date parse:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不关心位置1和2上的那两个破折号。我们可以在第三个位置看到日期。处理日期总是比平均的根管手术更有趣。想想看，为了将日期格式化并解析成我们知道最终可以与数据库代码一起工作的格式，需要做多少工作。幸运的是，C#处理这个问题得心应手。我们提取日期部分，并使用自定义日期格式解析器。我并不关心用地区格式表达日期，所以我会使用`InvariantCulture`作为日期解析的第二个参数：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we get to work parsing the HTTP verb. It needs to conform to the `enum`
    we defined at the top of the class. I start by pulling the relevant word and making
    sure it’s clean by giving it a quick trim. Then, I cast it to the enumeration
    type. I probably should have used `tryParse()`, but I didn’t. It still works with
    the input sample if I don’t, and that’s the kind of thinking that lands us in
    a stovepipe prison later:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始解析HTTP动词。它需要符合我们在类顶部定义的`enum`。我开始提取相关的单词，并通过快速修剪确保它是干净的。然后，我将它转换为枚举类型。我可能应该使用`tryParse()`，但我没有。如果没有这样做，它仍然可以与输入样本一起工作，这就是那种让我们最终陷入管道监狱的思考方式：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Route` value, the `ResponseCode` value, and the `SizeInBytes` value are
    just grabbed based on their position. In the latter two cases, I just used `int.parse()`
    to turn them into integers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`值、`ResponseCode`值和`SizeInBytes`值只是根据它们的位位置获取的。在后两种情况下，我使用了`int.parse()`将它们转换为整数：'
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, I need the `RequestingAgent`. The sample data has some pesky double
    quotes that I don’t want to capture, so I’ll just use the `string.replace()` method
    to replace them with `null`, effectively getting rid of them:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要`RequestingAgent`。样本数据有一些讨厌的双引号，我不想捕获它们，所以我将使用`string.replace()`方法将它们替换为`null`，从而有效地去除它们：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I now have a very useful constructor that does my line parsing for me automatically.
    Nice!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在有一个非常有用的构造函数，它可以自动为我解析行。太棒了！
- en: 'My second constructor is more standard fare. I’d like to create `NginxLogEntry`
    by simply passing in all the relevant data elements:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第二个构造函数更符合标准。我想通过简单地传递所有相关数据元素来创建`NginxLogEntry`：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This class begins as all do – with property definitions. We have a requirement
    to store the log data in SQL Server. For this, I created a database on my laptop
    running SQL Server 2019\. If you don’t have any experience with SQL Server, don’t
    worry. This is the only place it’s mentioned. You don’t need SQL knowledge to
    work with patterns in this book. I created a new database called `WebLogEntries`,
    then created a table that matches my object structure. The **Data Definition Language**
    (**DDL**) to create the table looks as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类开始时，就像所有类一样——从属性定义开始。我们有一个要求将日志数据存储在SQL Server中。为此，我在运行SQL Server 2019的笔记本电脑上创建了一个数据库。如果你没有SQL
    Server的经验，不用担心。这是唯一提到它的地方。你不需要SQL知识来处理这本书中的模式。我创建了一个名为`WebLogEntries`的新数据库，然后创建了一个与我的对象结构相匹配的表。创建表的**数据定义语言**（**DDL**）如下所示：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, I have added the ubiquitous auto-incrementing primary key field,
    simply called `id`. I also added a field to track when the record was entered
    and set its default value to SQL Server’s `GETDATE()` function, which yields the
    current date on the server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我添加了一个无处不在的自增主键字段，简单地称为`id`。我还添加了一个字段来跟踪记录何时被输入，并将其默认值设置为SQL Server的`GETDATE()`函数，该函数返回服务器上的当前日期。
- en: Let’s move on to the code that reads and writes data with SQL Server. I think
    most people would use an `SQLServerStorage`. If you’re following along, don’t
    forget to add the `Systems.Data` package via **NuGet**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写使用SQL Server读取和写入数据的代码。我认为大多数人会使用`SQLServerStorage`。如果你在跟着做，别忘了通过**NuGet**添加`Systems.Data`包。
- en: 'As before, I’ll start with the dependencies:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我会从依赖项开始：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, I’ll set up the class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将设置这个类：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unlike the data class we created earlier, this one is all about the methods.
    The first method I’ll make stores the data in the database using a direct connection.
    If you’ve only ever used EF, and you understand SQL (which you should), I highly
    recommend you try this style and test it for speed against your usual EF-driven
    code. You’ll see a huge difference, especially at scale. I’ll get off my proverbial
    soapbox now and get back to creating the `StoreLogLine` method. It takes in the
    `NginxLogEntry` class that we just wrote as its sole input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的数据类不同，这个类完全是关于方法的。我将创建的第一个方法将使用直接连接将数据存储在数据库中。如果你只使用过EF，并且理解SQL（你应该理解），我强烈建议你尝试这种风格，并测试它与你的常规EF驱动代码的速度。你将看到巨大的差异，尤其是在规模上。我现在要从我的比喻肥皂箱上下来，回到创建`StoreLogLine`方法。它接受我们刚刚编写的`NginxLogEntry`类作为其唯一输入：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let’s connect to the database. I use the `using` syntax for this. If
    you’ve not used this before (see what I did there?), it’s very convenient since
    it handles the timely closure and destruction of whatever you create. In this
    case, I’m creating a database connection. Even in throwaway code, there are things
    you just don’t do, such as open a connection to a resource and fail to close it.
    It’s just so rude! This line sets up my connection. I also recommend a strong
    database password. As usual, I can hide behind the excuse that it’s throwaway
    code. At this point, I’ve likely repeated this more times than your local government
    has told you to wear a mask. And as with your local government, it probably won’t
    be the last time you hear it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们连接到数据库。我使用`using`语法来做这件事。如果你之前没有使用过它（看看我做了什么？），它非常方便，因为它会处理你创建的任何东西的及时关闭和销毁。在这种情况下，我正在创建一个数据库连接。即使在临时代码中，也有一些事情你绝对不应该做，比如打开一个资源连接却未能关闭它。这真是太无礼了！这一行设置了我的连接。我还建议设置一个强大的数据库密码。像往常一样，我可以以临时代码为借口。到目前为止，我可能已经重复了比当地政府告诉你们戴口罩的次数还要多。而且就像你的当地政府一样，这可能不是你最后一次听到它：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, I’ll build my `StringBuilder` class, which is part of `System.Text`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将构建我的`StringBuilder`类，它是`System.Text`的一部分：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let’s open the connection, then execute our SQL statement:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开连接，然后执行我们的SQL语句：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Fabulous! Now that we’re writing data, it stands to reason that we should also
    read it. Otherwise, our class would be really cruddy. Or maybe it wouldn’t be?
    I’ll let you mull that over while I type out the next method signature:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！既然我们现在正在写入数据，那么也应该读取它。否则，我们的类将非常糟糕。或者，也许它不会这么糟糕？在我输入下一个方法签名的同时，我会让你思考这个问题：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `read` method is going to return a list of `NginxLogEntry` instances. This
    is why we made that second constructor in the `NginxLogEntry` class earlier. I’ll
    start by instantiating an empty list to use as the return value. After that I’ll
    make a really simple SQL statement to read all the records from the database:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 方法将返回一个 `NginxLogEntry` 实例的列表。这就是为什么我们在 `NginxLogEntry` 类中提前创建了第二个构造函数。我将首先实例化一个空列表，用作返回值。之后，我将创建一个非常简单的
    SQL 语句，从数据库中读取所有记录：'
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the same `using` syntax as before, I’ll open a connection and read the
    records:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前相同的 `using` 语法，我将打开一个连接并读取记录：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the `select` statement executed, I’ll use a reader to get the data out
    line by line, and for each record, I’ll instantiate a `NginxLogEntry` class. Since
    it’s supposed to be prototype code, I’m relying on the positions in the dataset
    for data retrieval. This is not uncommon, but it is fairly brittle. A restructuring
    of the table will break this code later. But it’s throwaway code! See? I told
    you that you’d hear it again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了 `select` 语句后，我将使用一个读取器逐行获取数据，并为每条记录实例化一个 `NginxLogEntry` 类。由于它应该是原型代码，我依赖于数据集中的位置来检索数据。这并不罕见，但它相当脆弱。表的重构将使这段代码在以后失效。但这是废弃代码！看到了吗？我告诉过你会再听到它：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that I’ve constructed the object using the data from the table, I’ll add
    it to my `logLines` list and return the list. The `using` statement handles the
    closure of all the database resources that I created along the way:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经使用表中的数据构建了对象，我将它添加到我的 `logLines` 列表中，并返回这个列表。`using` 语句处理了我创建的所有数据库资源的关闭：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To sum it up, the class has two methods. The first, `StoreLogLine`, takes an
    instance of the `NginxLogEntry` class and converts the data into a SQL statement
    compatible with our table structure. We then perform the `insert` operation. Since
    I used the `using` syntax to open the connection to the database, that connection
    is automatically closed when we leave the scope of the method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这个类有两个方法。第一个，`StoreLogLine`，接受 `NginxLogEntry` 类的一个实例，并将数据转换为与我们的表结构兼容的
    SQL 语句。然后我们执行 `insert` 操作。由于我使用了 `using` 语法来打开数据库连接，当我们离开方法的作用域时，该连接会自动关闭。
- en: The second operation works in reverse. `RetrieveLogLines` executes a select
    statement that retrieves all our data from the table and converts it into a list
    of `NginxLogEntry` objects. The list is returned at the close of the method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作是相反的。`RetrieveLogLines` 执行一个选择语句，从表中检索所有数据，并将其转换为 `NginxLogEntry` 对象的列表。方法结束时返回这个列表。
- en: The last component is the output component. The class is called `Report`. Its
    job is to convert the records requested from the database into an HTML table,
    which is then written to a file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组件是输出组件。这个类叫做 `Report`。它的任务是将数据库请求的记录转换为 HTML 表格，然后写入文件。
- en: 'I’ll set up the class with the dependencies and begin the class with the usual
    setup:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我将设置类依赖关系，并以通常的方式开始类设置：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, I’ll add the method to generate the report:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将添加生成报告的方法：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I’ll now use the `SQLServerStorage` class that we made earlier:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将使用我们之前创建的 `SQLServerStorage` 类：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I have the data. Now, I’ll use another `StringBuilder` to generate the HTML.
    It’s table code because this is absolutely not a book on frontend design:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我有数据。现在，我将使用另一个 `StringBuilder` 生成 HTML。这是表格代码，因为这本书绝对不是关于前端设计的：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we have a wonderful C# one-liner to output the file so that it’s ready
    for viewing in your favorite browser:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个美妙的 C# 单行代码来输出文件，以便在您最喜欢的浏览器中查看：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It might be ugly, but it works. I’ll say it once again just because I can. It’s
    throwaway code! One trick I advocate when writing throwaway code is to make it
    so incredibly ugly that nobody in their right mind would put their name to it.
    I think I’ve accomplished that here. I just used a string builder to create my
    HTML. No spaces or formatting. It’s basically a minified HTML file, which is,
    of course, an intended feature and not at all inspired by laziness.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来很丑，但它确实有效。我再说一遍，因为我可以。这是废弃代码！我在编写废弃代码时提倡的一个技巧是让它变得如此丑陋，以至于任何正常人都不会把自己的名字放在上面。我想我已经做到了。我只是使用字符串构建器创建我的
    HTML。没有空格或格式。它基本上是一个压缩的 HTML 文件，当然，这是一个预期特性，绝不是因为懒惰。
- en: There’s one last thing to do before we put this baby to bed. We need to edit
    the `Program.cs` file Visual Studio created as the project’s entry point. This
    file glues all the other pieces together. The most recent editions of most C#
    IDEs generate the entry point for console apps within the `Program.cs` file. This
    isn’t new. What is new is the format this file takes. The new format lacks the
    usual constructor and class setup we’ve seen so far in the classes we created
    from scratch. Behind the scenes, the compiler is generating those definitions
    for us, but it makes `Program.cs` look different from everything else. Rather
    than present all the usual boilerplate, it’s straight to business.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将这个宝贝放好之前，还有最后一件事要做。我们需要编辑Visual Studio为项目入口点创建的`Program.cs`文件。这个文件将所有其他部分粘合在一起。大多数C#
    IDE的最新版本在`Program.cs`文件中生成控制台应用程序的入口点。这不是什么新鲜事。新鲜的是这个文件的格式。新的格式缺少我们迄今为止在从头创建的类中看到的常规构造函数和类设置。在幕后，编译器正在为我们生成这些定义，但这使得`Program.cs`看起来与其他所有内容都不同。它不是展示所有常规样板，而是直接进入正题。
- en: 'We’ll start by using the `WebLogReporter` class that we just created:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用我们刚刚创建的`WebLogReporter`类：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’ll do a perfunctory and minimal test to make sure the right number of arguments
    were passed in from the command line. We need a path to the log file and an output
    path. If you don’t pass in the right number of arguments, we’ll give you a little
    command-line hint, then exit with a non-zero code, in case this is part of some
    sequence of automation. I know, it’s throwaway code, but I’m not a barbarian:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一次例行且最小的测试，以确保从命令行传递了正确的参数数量。我们需要日志文件的路径和输出路径。如果您没有传递正确的参数数量，我们将给出一些命令行提示，然后以非零代码退出，以防这是自动化序列的一部分。我知道，这是废弃的代码，但我也不是野蛮人：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we check whether the log input file exists. If it doesn’t, we alert the
    user to our disappointment and again exit with non-zero code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们检查日志输入文件是否存在。如果不存在，我们向用户表达我们的失望，并再次以非零代码退出：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If they make it this far, we’re assuming everything is good and we get to work:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们能走到这一步，我们假设一切顺利，我们可以开始工作了：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We instantiate `SQLServerStorageClass` so we can store our records as we read
    them in:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化`SQLServerStorageClass`，这样我们就可以在读取记录时将其存储：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we open the input log file, and with a `foreach` loop, we take each line
    and use our parsing constructor in `NginxLogEntry` to create an `NginxLogEntry`
    object. We then feed that to our database class. If we encounter a line that’s
    a problem, we write out a message that states where the problem occurred so that
    we can review it later:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打开输入日志文件，使用`foreach`循环逐行读取，并使用`NginxLogEntry`中的解析构造函数创建一个`NginxLogEntry`对象。然后我们将它传递给我们的数据库类。如果我们遇到有问题的一行，我们将输出一条消息，说明问题发生的位置，以便我们稍后可以审查：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We’ve parsed the log data and written it to the database. All that’s left is
    to use the `Report` class to write out our HTML:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解析了日志数据并将其写入数据库。剩下要做的就是使用`Report`类来输出我们的HTML：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To sum up, the `Program.cs` file contains the main program. The current version
    of C# allows us to dispense with the usual class definition in the main file for
    the project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`Program.cs`文件包含主程序。当前的C#版本允许我们省略项目主文件中的常规类定义。
- en: First, we check to make sure the user entered two arguments. It’s hardly a bulletproof
    check, but it’s good enough to demo.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查用户是否输入了两个参数。这几乎不是一个坚不可摧的检查，但对于演示来说已经足够好了。
- en: Next, after making sure the input log file is a legitimate path, we open the
    file, read it line by line, and save each line to the database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在确保输入日志文件是合法路径之后，我们打开文件，逐行读取，并将每一行保存到数据库中。
- en: Once we’ve read all our lines, we read back the data from the database and convert
    it to HTML using the report object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们读取了所有行，我们就从数据库中读取数据，并使用报告对象将其转换为HTML。
- en: 'Your program is complete; you demonstrate it to the customer, and they are
    delighted! A week later, their boss has lunch with your boss, and a new requirement
    comes in stating the client would now like to support logs from two other web
    server formats: Apache and IIS. They’d also like to select the output from several
    different formats, including the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序已经完成；您向客户演示了它，他们非常高兴！一周后，客户的老板和您的老板共进午餐，然后出现了一个新的需求，表示客户现在希望支持两种其他Web服务器日志格式：Apache和IIS。他们还希望从以下几种不同的格式中选择输出：
- en: HTML (which we have already delivered)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML（我们已交付）
- en: Adobe **PDFs**
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adobe **PDFs**
- en: Markdown
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Markdown
- en: '**JavaScript Object Notation** (**JSON**)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法** (**JSON**)'
- en: The purpose of the last format, JSON, is that it allows outside clients to ingest
    that data into other systems for further analysis, such as capturing trend data
    over time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种格式JSON的目的在于它允许外部客户端将数据摄入其他系统进行进一步分析，例如捕捉随时间变化的趋势数据。
- en: While these concise descriptions of the requirements are hardly what we’d want
    when building a real extension to our program, they are enough to get you thinking.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些对需求的简洁描述在我们构建程序的实际扩展时几乎不是我们想要的，但它们足以让你开始思考。
- en: What would you do?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你会怎么做？
- en: Have we built a stovepipe system? If not, is there a chance it might evolve
    into one? Pause for a moment and think about this before reading further.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否建立了一个烟囱系统？如果不是，它有可能演变成一个吗？在继续阅读之前，请暂停一下，思考这个问题。
- en: 'I believe we have built a stovepipe system. Here’s why:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们已经建立了一个烟囱系统。原因如下：
- en: Our classes are all single-purpose and coupled directly to the web server log
    formats
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的所有类都是单功能的，并且直接与网络服务器日志格式耦合
- en: Our software is directly coupled with SQL Server
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的软件直接与SQL Server耦合
- en: Our output to HTML is the only possible output, given that we didn’t create
    an interface or structure to abstract the output operation and format
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的输出到HTML是唯一可能的输出，因为我们没有创建一个接口或结构来抽象输出操作和格式
- en: You might be thinking that the second set of requirements was unknown at the
    time we created our first release. That’s accurate. You might further defend your
    idea by stating you are not psychic, and there’s no way you could have known you
    would need to extend the program per the second set of requirements. You’re right
    there too. Nobody is prescient. But despite that, you know, if for no other reason
    than you’ve read this chapter so far, that any successful program must support
    extension. This is true because you know your first iteration has now begotten
    a request for a second and that always entails changes and additions to the requirements.
    We can never know how the requirements will change, but we do know that they will
    change.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为，在我们创建第一个版本时，第二套需求是未知的。这是准确的。你还可以进一步捍卫你的观点，声称你不是先知，没有方法你能知道你需要根据第二套需求扩展程序。你是对的。没有人是先知的。但尽管如此，你知道，至少因为你已经阅读了这一章，任何成功的程序都必须支持扩展。这是因为你知道你的第一次迭代现在已经产生了对第二次迭代的要求，而这总是意味着需求的变化和增加。我们永远不知道需求会如何变化，但我们确实知道它们会变化。
- en: How can patterns help?
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式如何帮助？
- en: These factors are undoubtedly part of your professional life right now. Perhaps
    only a few of them are at play at a time. If you stay in software development
    for any length of time, you’ll undoubtedly encounter them all at some point. Remember,
    everything we’ve talked about so far is an antipattern. All this negative energy
    needs a counterbalance. You might even be tempted to say that you need to bring
    balance to the force. Instead of becoming a dark Jedi, maybe something less radical
    will do. You can learn to use patterns to balance and ultimately defeat the antipatterns
    and the forces that create and enable them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些因素无疑是你们现在职业生活的一部分。也许只有其中的一小部分在起作用。如果你在软件开发领域待的时间足够长，你无疑会在某个时候遇到它们所有。记住，我们迄今为止所讨论的一切都是反模式。所有这些负面能量都需要一个平衡。你甚至可能想说是需要平衡力量。而不是成为一个黑暗的绝地武士，也许一些不那么激进的方法会更好。你可以学会使用模式来平衡，最终战胜反模式和创造并使他们得以存在的力量。
- en: I think it’s time we formally introduced the concept that I have left to your
    imagination thus far. I could offer my own definition of patterns but I’d rather
    stand on the shoulders of giants. From the days since Grace Hopper logged the
    first bug on the Mark II at Harvard in 1947 (see *Figure 1.4*), programmers and
    computer scientists have been facing the same problems over and over again. We
    get a little bit smarter every time and we write down what we did. If you take
    the distilled experience and knowledge gleaned through hard-won trial and error
    over the course of seven decades, from the early wartime pioneers to the most
    recent graduates, you wind up with a set of patterns, which are descriptions of
    solutions to consistently recurring problems.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在是时候正式引入我迄今为止留给你们想象的概念了。我可以提供自己对模式的定义，但我更愿意站在巨人的肩膀上。从1947年Grace Hopper在哈佛大学的Mark
    II上记录下第一个错误以来（见*图1.4*），程序员和计算机科学家一直在反复面对同样的问题。我们每次都会变得稍微聪明一点，并将我们所做的事情记录下来。如果你从七十年间通过艰苦的试验和错误所获得的提炼经验和知识来看，从早期的战争先驱到最近的毕业生，你最终会得到一套模式，这些模式是对反复出现的问题的解决方案的描述。
- en: '![Figure 1.4 – The very first computer bug was literally a bug (moth) that
    had crawled into the relays of the Mark II computer at Harvard University ](img/B18605_Figure_1.4.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 首个计算机故障实际上是一只（蛾）爬进了哈佛大学Mark II计算机的继电器中](img/B18605_Figure_1.4.jpg)'
- en: Figure 1.4 – The very first computer bug was literally a bug (moth) that had
    crawled into the relays of the Mark II computer at Harvard University
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 首个计算机故障实际上是一只（蛾）爬进了哈佛大学Mark II计算机的继电器中
- en: The idea of patterns originated in the field of architecture, that is, traditional
    architecture, with respect to the design and creation of buildings. In 1977, Christopher
    Alexander documented a pattern language designed to form the basis for the best
    practices for building towns. The book describes two hundred and fifty-three patterns
    presented as the paragon of architectural design. The book breaks everything down
    into objects. I find it fascinating that the language doesn’t even change when
    you adapt the seminal book on architectural patterns to our explanation of software
    patterns. I’d characterize the book as being the synthesis of a language used
    to describe objects in the real world and how to mold spaces and objects together
    to achieve harmony. As with the motto of the Vulcans in the TV and film franchise
    *Star Trek*, the goal of the language of patterns is *infinite diversity expressed
    in infinite combinations*. Alexander himself describes a pattern as a solution
    to problems that occur frequently enough that every practitioner will likely recognize
    them. He then describes a solution in a way that isn’t directly tied to any implementation.
    Keeping it flexible in this way, the same solution may be used on a million projects
    and in a million slightly different ways.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的想法起源于建筑领域，即传统建筑，与建筑的设计和创造有关。1977年，克里斯托弗·亚历山大记录了一种模式语言，旨在为城镇建设的最佳实践奠定基础。这本书描述了253个模式，作为建筑设计的典范。这本书将一切分解为对象。我发现，即使将建筑模式的经典著作改编为软件模式的解释，语言也没有发生变化。我将这本书描述为描述现实世界中对象的语言及其如何塑造空间和对象以实现和谐的合成。正如电视剧和电影系列《星际迷航》中
    Vulcans 的格言一样，模式语言的目标是*无限多样性，通过无限组合表达*。亚历山大本人将模式描述为对经常出现的问题的解决方案，每个从业者都可能认识它们。然后他以一种不直接关联任何实现的方式描述解决方案。以这种方式保持灵活性，相同的解决方案可以在数百万个项目中以及数百万种略有不同的方式中使用。
- en: Let’s shift focus from the world of building architecture to the realm of software
    architecture. We revisit the famous GoF. They define a design pattern as an abstraction
    of a recurring problem that pinpoints the chief elements of design structure,
    focusing on the idea of creating reusable object-oriented software.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将焦点从建筑世界转移到软件架构领域。我们回顾了著名的GoF。他们将设计模式定义为对重复出现的问题的抽象，它指出了设计结构的主要元素，专注于创建可重用面向对象软件的思想。
- en: Patterns are going to be the weapon that we can use to overcome the antipatterns
    and dark forces that prevail in both the loftiest corporate institutions and most
    hallowed halls in small business.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 模式将成为我们用来克服那些在最高级的公司机构和中小企业中最神圣的殿堂中盛行的反模式和黑暗力量的武器。
- en: Are you ready to fight the darkness? Roll up your sleeves and let’s get to work!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好与黑暗作战了吗？卷起袖子，让我们开始工作吧！
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter initiated our discussion of patterns by defining antipatterns.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过定义反模式开始了我们对模式的讨论。
- en: We learned that if we design software only with a mind toward meeting the requirements,
    we will build a system that can’t be extended easily. These systems are called
    *Stovepipe systems* because over time, they degenerate structurally as an exhaust
    vent on a coal-burning stove does. You will invariably reach a point where maintaining
    and extending such a system is untenable. Nobody wants to be the one to tell the
    bosses that you need six months with no new releases so that you can rebuild the
    company’s cash-cow product. Designing with patterns will help you avoid these
    kinds of pitfalls.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，如果我们只从满足需求的角度设计软件，我们将构建一个难以扩展的系统。这些系统被称为*烟囱系统*，因为随着时间的推移，它们在结构上会像烧煤炉的排气孔一样退化。你不可避免地会达到一个点，在这个点上，维护和扩展这样的系统是不切实际的。没有人愿意成为告诉老板你需要六个月没有新发布，以便你可以重建公司现金牛产品的那个人的角色。使用模式进行设计将帮助你避免这些类型的陷阱。
- en: 'We also learned about a similar antipattern called *the Big Ball of Mud*. Foote
    and Yoder described the prevailing forces that we all recognize in our daily work
    lives: time, cost, experience, skill, visibility, complexity, change, and scale.
    These forces confound our ability to write good code in the first place. Even
    if we can write good code for our first release, these forces erode systems over
    time, such as a tiny stream forming the Grand Canyon.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了一个类似的反模式，称为*大泥球*。福特和约德描述了我们都在日常工作中认识到的普遍力量：时间、成本、经验、技能、可见性、复杂性、变化和规模。这些力量阻碍了我们最初编写好代码的能力。即使我们可以在第一个版本中编写出好代码，这些力量也会随着时间的推移侵蚀系统，就像一条小溪最终形成大峡谷一样。
- en: 'We saw an example of throwaway code, which is how most projects are born. We
    now know what bad practice it is to just clean up the throwaway code and then
    ship it. It pays to spend the time to architect projects properly and assume the
    worst-case scenario: that your software will be wildly successful. If it is, you
    can absolutely count on feature requests and new requirements that you never even
    imagined when you wrote the throwaway prototype.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一个废弃代码的例子，这就是大多数项目诞生的过程。我们现在知道，仅仅清理废弃代码然后发货是一种不良的做法。花时间正确地设计项目并假设最坏的情况：你的软件会取得巨大的成功。如果是这样，你可以绝对地依赖那些你甚至在编写废弃原型时都没有想象到的功能请求和新需求。
- en: Patterns can be thought of as a language that defines common software design
    elements, coupled with an abstract solution that can be implemented in many different
    ways. They aren’t tied to a particular language or technology stack. As you learn
    to use patterns, your software will become more robust owing to a stronger foundation.
    Your projects will be able to support your inevitable success by providing avenues
    for future features and expansion that you couldn’t have conceived of when you
    started your project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以被看作是一种定义常见软件设计元素的“语言”，结合了一个可以以许多不同方式实现的抽象解决方案。它们并不依赖于特定的语言或技术栈。随着你学习使用模式，你的软件将因为更坚实的基础而变得更加健壮。你的项目将通过提供未来功能和扩展的途径来支持你不可避免的成功，这些途径是你开始项目时无法想象的。
- en: In the next chapter, I’ll prepare you for your patterns journey with the C#
    programming language. I will cover some popular idioms and practices in relation
    to object-oriented programming. In particular, pay close attention to the presentation
    of SOLID methodology, because it is the foundation upon which successful patterns
    are implemented.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将使用C#编程语言为你准备模式之旅。我将涵盖一些与面向对象编程相关的一些流行惯用和做法。特别是，请注意SOLID方法论的展示，因为它是成功模式实施的基础。
- en: If you are new, or perhaps returning to C# having worked with other object-oriented
    languages, I want to direct you to [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    at the end of the book. I wrote this for my students and colleagues who have an
    interest in learning about patterns but have focused on other languages, such
    as JavaScript or Python. Patterns are language-agnostic. Learning these patterns
    exclusive of a language is possible. However, I believe that we all learn best
    by doing, and that means you need an implementation language. The neat thing about
    programming languages is that they are pretty much all the same. All of them use
    variables, objects, methods, collections, and loops.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个新手，或者可能是在使用过其他面向对象语言后返回C#，我想要你参考书末的[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)。我为那些对学习模式感兴趣但专注于其他语言（如JavaScript或Python）的学生和同事写了这个附录。模式是语言无关的。在不考虑语言的情况下学习这些模式是可能的。然而，我相信我们都是通过实践来学习的，这意味着你需要一种实现语言。编程语言的好处是它们基本上都是一样的。它们都使用变量、对象、方法、集合和循环。
- en: In [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178), I’ll cover the
    object-oriented features of the C# language. I’ve alluded to my idea that newer
    developers within the field are the most at risk in terms of knowing the language
    reasonably well but simultaneously clinging to Golden Hammers and using C# to
    produce stovepipe software. I have a great many students who learn JavaScript
    from me and who, at my strong encouragement, want to take the next steps in their
    journey by learning C#. Given how differently inheritance and common structures
    such as objects and classes work between the two languages, you’ll undoubtedly
    detect my desire to be inclusive. I had originally written this appendix to be
    [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036), but I didn’t want to bear the
    expense of having the C# crowd cry out, “I’m BORED.” Even if you’re a C# veteran,
    I encourage you to peruse the chapter. You might find I’ve explained things a
    little differently from many other authors, and certainly differently from an
    academic textbook.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)中，我将介绍C#语言的面向对象特性。我暗示了我的想法，即该领域的较新手开发者最有可能在合理掌握语言的同时，却仍然坚持使用“黄金锤子”并用C#来制作烟囱式软件。我有许多学生从我这学习JavaScript，并且在我的强烈鼓励下，他们希望通过学习C#来继续他们的旅程。鉴于两种语言在继承和常见结构（如对象和类）之间的不同工作方式，你无疑会察觉到我的包容性愿望。我最初写这个附录是为了成为[*第二章*](B18605_02.xhtml#_idTextAnchor036)，但我不想承担C#群体大喊“无聊”的费用。即使你是C#的老手，我也鼓励你浏览这一章。你可能会发现我解释事物的方式与其他许多作者略有不同，当然与学术教科书相比更是如此。
- en: Questions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What, in your own words, is a pattern? What is an antipattern?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话来说，什么是模式？什么是反模式？
- en: What antipatterns have you seen in your own work before?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在自己的工作中见过哪些反模式？
- en: What is a stovepipe system? Can you point to an example from your own body of
    work? Don’t worry, I won’t tell.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是烟囱式系统？你能从你自己的作品中指出一个例子吗？别担心，我不会说的。
- en: Can you think of a time when you wielded a Golden Hammer? What was the hammer
    and what did you perceive as the nails?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到一个你使用“黄金锤子”的时刻吗？这把锤子是什么，你认为是钉子的是什么？
- en: Further reading
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Alexander, C. (1977). *A pattern language: towns, buildings, construction*.
    Oxford University Press'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alexander, C. (1977). 《模式语言：城镇、建筑、建造》。牛津大学出版社
- en: 'Brown, W. H., Malveau, R. C., McCormick, H.W. S., & Mowbray, T. J. (1998). *AntiPatterns:
    refactoring software, architectures, and projects in crisis*. John Wiley & Sons,
    Inc.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brown, W. H., Malveau, R. C., McCormick, H.W. S., & Mowbray, T. J. (1998). 《反模式：危机中的软件、架构和项目的重构》。John
    Wiley & Sons, Inc.
- en: Foote, B., & Yoder, J. (1997). *Big Ball of Mud*. Pattern languages of program
    design, 4, 654–692\. Retrieved from [http://www.laputan.org/pub/foote/mud.pdf](http://www.laputan.org/pub/foote/mud.pdf)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foote, B., & Yoder, J. (1997). *大泥球*. 程序设计模式语言，第4卷，第654–692页。来自[http://www.laputan.org/pub/foote/mud.pdf](http://www.laputan.org/pub/foote/mud.pdf)
- en: 'Gamma, E., Helm, R., Johnson, R., Vlissides, J., & Patterns, D. (1995). *Elements
    of reusable object-oriented software* (Vol. 99.) Reading, Massachusetts: Addison-Wesley'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gamma, E., Helm, R., Johnson, R., Vlissides, J., & Patterns, D. (1995). 《可重用面向对象软件元素》（第99卷）.
    马萨诸塞州雷丁：Addison-Wesley
- en: Johnson, J. (1995). *Creating Chaos*. American Programmer, July 1995
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Johnson, J. (1995). 《创造混沌》。美国程序员，1995年7月
- en: 'Nazeer, H. (2020). *A pattern language: towns, buildings, construction (review)*.
    Journal of Research in Architecture and Planning, Vol. 29, Second Issue'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nazeer, H. (2020). *《模式语言：城镇、建筑、建造（评论）》*. 建筑与规划研究杂志，第29卷，第二期
