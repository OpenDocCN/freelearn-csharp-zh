["```cs\npublic class Teacher{\n    public Guid Id { get; set; }\n    public string FirstName { get; set; } = string.Empty;\n    public string LastName { get; set; } = string.Empty;\n    public string Email { get; set; } = string.Empty;\n    public string? Phone { get; set; }\n    public string? Bio { get; set; }\n}\n```", "```cs\n    Query, in the GraphQL/Queries folder, as shown here:\n\n    ```", "```cs\n\n    The `Query` class will be used to define the queries that can be executed by the client. It has one method named `GetTeachers()`, which returns a list of teachers.\n    ```", "```cs\n    Query type to the schema.\n    ```", "```cs\n    /graphql URL.\n    ```", "```cs\n    type Query {  teachers: [Teacher!]!}type Teacher {  id: UUID!  firstName: String!  lastName: String!  email: String!  phone: String  bio: String}\n    ```", "```cs\n    query {    teachers {        id        firstName        lastName        email        phone        bio    }}\n    ```", "```cs\n    query {    teachers {        firstName        lastName        email        phone    }}\n    ```", "```cs\n    public record AddTeacherInput(    string FirstName,    string LastName,    string Email,    string? Phone,    string? Bio);\n    ```", "```cs\n    public class AddTeacherPayload{    public Teacher Teacher { get; }    public AddTeacherPayload(Teacher teacher)    {        Teacher = teacher;    }}\n    ```", "```cs\n    public class Mutation{    public async Task<AddTeacherPayload> AddTeacherAsync(        AddTeacherInput input,        [Service] AppDbContext context)    {        var teacher = new Teacher        {            Id = Guid.NewGuid(),            FirstName = input.FirstName,            LastName = input.LastName,            Email = input.Email,            Phone = input.Phone,            Bio = input.Bio        };        context.Teachers.Add(teacher);        await context.SaveChangesAsync();        return new AddTeacherPayload(teacher);    }}\n    ```", "```cs\n    builder.Services    .AddGraphQLServer()    .AddQueryType<Query>()    .AddMutationType<Mutation>();\n    ```", "```cs\n    type Mutation {  addTeacher(input: AddTeacherInput!): AddTeacherPayload!}input AddTeacherInput {  firstName: String!  lastName: String!  email: String!  phone: String  bio: String}type AddTeacherPayload {  teacher: Teacher!}\n    ```", "```cs\n    mutation addTeacher {  addTeacher(    input: {      firstName: \"John\"      lastName: \"Smith\"      email: \"john.smith@sampleschool.com\"      phone: \"1234567890\"      bio: \"John Smith is a math teacher.\"    }  ) {    teacher {      id    }  }}\n    ```", "```cs\n    public async Task<Teacher?> GetTeacher(Guid id, [Service] AppDbContext context) =>    await context.Teachers.FindAsync(id);\n    ```", "```cs\n    query getTeacher($id: UUID!) {  teacher(id: $id) {    id    firstName    lastName    email    phone  }}\n    ```", "```cs\n    {  \"id\": \"00000000-0000-0000-0000-000000000401\"}\n    ```", "```cs\npublic enum CourseType{\n    Core,\n    Elective,\n    Lab\n}\n```", "```cs\nenum CourseType {  CORE\n  ELECTIVE\n  LAB\n}\n```", "```cs\npublic class Teacher{\n    public Guid Id { get; set; }\n    public string FirstName { get; set; } = string.Empty;\n    public string LastName { get; set; } = string.Empty;\n    public Guid DepartmentId { get; set; }\n    public Department Department { get; set; } = default!;\n}\npublic class Department\n{\n    public Guid Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public string? Description { get; set; }\n    // other properties\n}\n```", "```cs\ntype Teacher {  id: UUID!\n  firstName: String!\n  lastName: String!\n  departmentId: UUID!\n  department: Department!\n}\ntype Department {\n  id: UUID!\n  name: String!\n  description: String\n}\n```", "```cs\npublic class Department{\n    public Guid Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public string? Description { get; set; }\n    public List<Teacher> Teachers { get; set; } = new();\n}\n```", "```cs\ntype Department {  id: UUID!\n  name: String!\n  description: String\n  teachers: [Teacher!]!\n}\n```", "```cs\npublic class Department{\n    public Guid Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public string? Description { get; set; }\n    public List<Teacher>? Teachers { get; set; }\n}\n```", "```cs\ntype Department {  id: UUID!\n  name: String!\n  description: String\n  teachers: [Teacher!]\n}\n```", "```cs\ntype Query {  teachers: [Teacher!]!\n  teacher(id: UUID!): Teacher\n}\ntype Mutation {\n  addTeacher(input: AddTeacherInput!): AddTeacherPayload!\n}\n```", "```cs\npublic async Task<List<Teacher>> GetTeachers([Service] AppDbContext context) =>    await context.Teachers.Include(x => x.Department).ToListAsync();\n```", "```cs\nquery{  teachers{\n    id\n    firstName\n    lastName\n    department{\n      id\n      name\n      description\n    }\n  }\n}\n```", "```cs\n{  \"data\": {\n    \"teachers\": [\n      {\n        \"id\": \"00000000-0000-0000-0000-000000000401\",\n        \"firstName\": \"John\",\n        \"lastName\": \"Doe\",\n        \"department\": {\n          \"id\": \"00000000-0000-0000-0000-000000000001\",\n          \"name\": \"Mathematics\",\n          \"description\": \"Mathematics Department\"\n        }\n      },\n      {\n        \"id\": \"00000000-0000-0000-0000-000000000402\",\n        \"firstName\": \"Jane\",\n        \"lastName\": \"Doe\",\n        \"department\": {\n          \"id\": \"00000000-0000-0000-0000-000000000001\",\n          \"name\": \"Mathematics\",\n          \"description\": \"Mathematics Department\"\n        }\n      }\n    ]\n  }\n}\n```", "```cs\npublic async Task<Teacher?> GetTeacher(Guid id, [Service] AppDbContext context) =>   await context.Teachers.FindAsync(id);\n```", "```cs\n    public class TeacherType : ObjectType<Teacher>{    protected override void Configure(IObjectTypeDescriptor<Teacher> descriptor)    {        descriptor.Field(x => x.Department)            .Name(\"department\")            .Description(\"This is the department to which the teacher belongs.\")            .Resolve(async context =>            {                var department = await context.Service<AppDbContext>().Departments.FindAsync(context.   Parent<Teacher>().DepartmentId);                return department;            });    }}\n    ```", "```cs\n    public class Query{    // Omitted for brevity    public TeacherType? Teacher { get; set; } = new();}\n    ```", "```cs\n    public class QueryType : ObjectType<Query>{    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)    {        descriptor.Field(x => x.Teacher)            .Name(\"teacher\")            .Description(\"This is the teacher in the school.\")            .Type<TeacherType>()            .Argument(\"id\", a => a.Type<NonNullType<UuidType>>())            .Resolve(async context =>            {                var id = context.ArgumentValue<Guid>(\"id\");                var teacher = await context.Service<AppDbContext>().Teachers.FindAsync(id);                return teacher;            });    }}\n    ```", "```cs\n    builder.Services    .AddGraphQLServer()    .AddQueryType<QueryType>()    .AddMutationType<Mutation>();\n    ```", "```cs\n    query ($id: UUID!) {  teacher(id: $id) {    firstName    lastName    email    department {      name      description    }  }}\n    {  \"id\": \"00000000-0000-0000-0000-000000000401\"}\n    ```", "```cs\npublic class TeacherResolvers{\n    public async Task<Department> GetDepartment([Parent] Teacher teacher, [Service] IDbContextFactory<AppDbContext> dbContextFactory)\n    {\n        await using var dbContext = await dbContextFactory.CreateDbContextAsync();\n        var department = await dbContext.Departments.FindAsync(teacher.DepartmentId);\n        return department;\n    }\n}\n```", "```cs\ndescriptor.Field(x => x.Department)    .Description(\"This is the department to which the teacher belongs.\")\n    .ResolveWith<TeacherResolvers>(x => x.GetDepartment(default, default));\n```", "```cs\npublic class Query{\n    // Omitted for brevity\n    public List<TeacherType> Teachers { get; set; } = new();\n}\n```", "```cs\npublic class QueryType : ObjectType<Query>{\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\n    {\n        descriptor.Field(x => x.Teachers)\n            .Name(\"teachers\") // This configuration can be omitted if the name of the field is the same as the name of the property.\n            .Description(\"This is the list of teachers in the school.\")\n            .Type<ListType<TeacherType>>()\n            .Resolve(async context =>\n            {\n                var teachers = await context.Service<AppDbContext>().Teachers.ToListAsync();\n                return teachers;\n            });\n        // Omitted for brevity\n    }\n}\n```", "```cs\nquery{  teachers{\n    id\n    firstName\n    lastName\n    department{\n      id\n      name\n      description\n    }\n  }\n}\n```", "```cs\n{  \"errors\": [\n    {\n      \"message\": \"Unexpected Execution Error\",\n      \"locations\": [\n        {\n          \"line\": 6,\n          \"column\": 5\n        }\n      ],\n      \"path\": [\n        \"teachers\",\n        7,\n        \"department\"\n      ],\n      \"extensions\": {\n        \"message\": \"A second operation was started on this context instance before a previous operation completed. This is usually caused by different threads concurrently using the same instance of DbContext. For more information on how to avoid threading issues with DbContext, see https://go.microsoft.com/fwlink/?linkid=2097913.\",\n        ...\n      }\n    },\n  ]\n}\n```", "```cs\nProgram.cs file to register the AppDbContext class, as follows:\n\n```", "```cs\n\nThe preceding code allows HotChocolate to manage the lifetime of `AppDbContext` for resolvers.\nThe `RegisterDbContext<TDbContext>()` method can specify how `DbContext` should be injected. There are three options:\n\n*   `DbContextKind.Synchronized`: This is to ensure that `DbContext` is never used concurrently. `DbContext` is still injected as a scoped service.\n*   `DbContextKind.Resolver`: This way will resolve the scoped `DbContext` for each resolver. This option is the default configuration. From the perspective of the resolver, `DbContext` is a transient service, so HotChocolate can execute multiple resolvers concurrently without any issues.\n*   `DbContextKind.Pooled`: This mechanism will create a pool of `DbContext` instances. It leverages the `DbContextPool` feature of EF Core. HotChocolate will resolve `DbContext` from the pool for each resolver. When the resolver is completed, `DbContext` will be returned to the pool. In this way, `DbContext` is also like a transient service for each resolver, so HotChocolate can parallelize the resolvers as well.\n\nTo demonstrate how to benefit from the pooled `DbContext`, we will use the `DbContextKind.Pooled` option. This approach requires a couple of additional steps:\n\n1.  First, we need to register `DbContext` using the `AddPooledDbContextFactory()` method instead of the `AddDbContext()` method. Update the `Program.cs` file as follows:\n\n    ```", "```cs\n\n    The preceding code registers `AppDbContext` as a pooled service using the `AddPooledDbContextFactory()` method. Then, we use the `RegisterDbContext()` method to register `AppDbContext` as a pooled service for HotChocolate resolvers.\n\n     2.  Update the `Configure()` method in the `QueryType` file to use the pooled `DbContext`:\n\n    ```", "```cs\n\n    The preceding code uses `IDbContextFactory<TDbContext>` to create a new `AppDbContext` instance for each resolver. Then, it retrieves the `Teacher` objects from the database using the new `AppDbContext` instance.\n\n    One thing to note is that we need to use the `await using` statement to dispose of the `AppDbContext` instance after the resolver is completed in order to return the `AppDbContext` instance to the pool.\n\n     3.  Update the other resolvers as well. For example, the resolver of the `Teacher` type looks like this:\n\n    ```", "```cs\n\n    Now, we can test the `teachers` field again. You will see that all the teachers with the department information can be retrieved correctly.\n\nSo, everything looks good. But wait. If you check the logs, you will find that there are many database queries for each `Department` object:\n![Figure 12.4 – Database queries for each Department object](img/B18971_12_04.jpg)\n\nFigure 12.4 – Database queries for each Department object\nWhat is the reason behind this? Let us find out in the next section.\nUsing data loaders\nIn the previous section, we learned how to integrate HotChocolate with EF Core. We also learned how to use the `DbContextPool` feature to fetch data in multiple resolvers. However, we found that there are many database queries for each `Department` object in the `Teacher` list. That is because the resolvers for each `Department` object are executed separately, querying the database by each `DepartmentId` property in the list. This is similar to the *N+1* problem we discussed in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012). The difference is that the *N+1* problem occurs on the client side in REST APIs, while it occurs on the server side in GraphQL. To solve this problem, we need to find a way to load the batch data efficiently.\nHotChocolate provides a `DataLoader` mechanism to solve the *N+1* problem. The data loader fetches data in batches from the data source. Then, the resolver can retrieve the data from the data loader, rather than querying the data source directly. The data loader will cache the data for the current request. If the same data is requested again, the resolver can retrieve the data from the data loader directly. This can avoid unnecessary database queries.\nBefore we learn how to use the data loader to solve the *N+1* problem, let's prepare the examples. We already have a `Teachers` query to query the list of teachers, and each teacher has a `Department` object. Now, we want to add a `Departments` query to query the list of departments, and each department has a list of teachers. We will use the following steps to add the `Departments` query:\n\n1.  The `Department` type is defined as follows:\n\n    ```", "```cs\n\n     2.  The `Department` class has a list of `Teacher` objects. Following the convention, we can define a `DepartmentType` class as follows:\n\n    ```", "```cs\n\n    The preceding code is similar to `TeacherType`, which we defined previously. `DepartmentType` has a `Teachers` field of the `ListType<TeacherType>` type. Then, we use the `ResolveWith()` method to define the resolver. The resolver retrieves the `Teacher` objects from the database using the `DepartmentId` property of the `Department` object.\n\n     3.  Add a new field in the `Query` class, as follows:\n\n    ```", "```cs\n\n     4.  Then, configure the `Departments` field in the `QueryType` as follows:\n\n    ```", "```cs\n\n    If you check the logs, you will find that the following database queries are executed multiple times:\n\n    ```", "```cs\n\nThe preceding query is executed for each `Department` object. This is also an *N+1* problem, as we discussed previously. Next, we will use the data loader to solve these *N+1* problems.\nBatch data loader\nFirst, let's optimize the `teachers` query. To retrieve the `teachers` data with the department information, we want to execute two SQL queries only. One is to retrieve the `teachers` data, and the other is to retrieve the department data. Then, HotChocolate should be able to map the `department` data to the teachers in memory, instead of executing a SQL query for each teacher.\nFollow these steps to use the data loader:\n\n1.  Create a folder named `DataLoaders` in the `GraphQL` folder, then create a new `DepartmentByTeacherIdBatchDataLoader` class, as follows:\n\n    ```", "```cs\n\n    The preceding code defines a data loader to fetch the batch data for the `Department` object. The parent resolver, which is the `teachers` query, will get a list of `Teacher` objects. Each `Teacher` object has a `DepartmentId` property. `DepartmentByTeacherIdBatchDataLoader` will fetch the `Department` objects for the `DepartmentId` values in the list. The list of the `Department` objects will be converted to a dictionary. The key of the dictionary is the `DepartmentId` property and the value is the `Department` object. Then, the parent resolver can map the `Department` object to the `Teacher` object in memory.\n\n     2.  Update the `TeacherResolvers` class as follows:\n\n    ```", "```cs\n\n    Instead of querying the database directly, the resolver uses `DepartmentByTeacherIdBatchDataLoader` to fetch the `Department` object for the `DepartmentId` property of the `Teacher` object. The `DepartmentByTeacherIdBatchDataLoader` will be injected by HotChocolate automatically.\n\n     3.  Run the application and test the `teachers` query again. Now, you will see only two SQL queries are executed:\n\n    ```", "```cs\n\n    As we see, the first query is to get the list of the teachers, and the second query is to use the `IN` clause to query the departments that match the `DepartmentId` values in the list. This is much more efficient than the previous approach.\n\nAs it fetches the batch data for the `Department` object, it is called a batch data loader. This data loader is often used for one-to-one relationships, such as one `Teacher` object has one `Department` object. Note that this one-to-one relationship is not the same as the one-to-one relationship in the database. In GraphQL, the one-to-one relationship means that one object has one child object.\nGroup data loader\nNext, let's optimize the `departments` query. In this case, one `Department` object has a list of `Teacher` objects. We can use the group data loader to fetch the `Teacher` objects for each `Department` object. The group data loader is similar to the batch data loader. The difference is that the group data loader fetches a list of objects for each key. The batch data loader fetches a single object for each key.\nFollow these steps to use the group data loader:\n\n1.  Create a `TeachersByDepartmentIdDataLoader` class in the `DataLoaders` folder, and add the following code:\n\n    ```", "```cs\n\n    The preceding code defines a group data loader, which returns an `ILookup<Guid, Teacher>` object in the `LoadGroupedBatchAsync()` method. The `ILookup<Guid, Teacher>` object is similar to a dictionary. The key of the dictionary is the `DepartmentId` property and the value is a list of `Teacher` objects. The parent resolver can map the `Teacher` objects to the `Department` object in memory.\n\n     2.  Update the `DepartmentResolvers` class as follows:\n\n    ```", "```cs\n\n    The preceding code uses `TeachersByDepartmentIdDataLoader` to fetch the `Teacher` objects for the `Department` object. `TeachersByDepartmentIdDataLoader` will be injected by HotChocolate automatically.\n\n     3.  Run the application and test the `departments` query again. Now, you will see only two SQL queries are executed:\n\n    ```", "```cs\n\n    That is exactly what we want. The first query is to get the list of the departments, and the second query is to use the `IN` clause to query the teachers that match the `DepartmentId` values in the list. This approach reduces the number of database queries significantly.\n\nIn this case, each `Department` object has a list of `Teacher` objects, so this kind of data loader is called a group data loader. It is often used for one-to-many relationships, such as one `Department` object has a list of `Teacher` objects.\nHotChocolate supports cache data loader as well. It also supports using multiple data loaders in a resolver. As they are not used often, we will not discuss them in this chapter. You can refer to the documentation for more details: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12/start](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12/start).\nDependency injection\nIn the previous code examples, we use `IDbContextFactory<AppDbContext>` and `AppDbContext` directly in the resolvers. In order to encapsulate our data access logic, we can add a service layer to implement our business logic. HotChocolate supports dependency injection for resolvers. In this section, we will learn how to inject other services into the resolvers.\nTo demonstrate how to use dependency injection in HotChocolate, we will add an interface named `ITeacherService` and a class named `TeacherService`, as follows:\n\n```", "```cs\n\nThe preceding code encapsulates the data access logic in the `TeacherService` class. Then, we need to register `ITeacherService` in the `Program.cs` file, as follows:\n\n```", "```cs\n\n HotChocolate uses the same approach to register the services as ASP.NET Core, but injecting the services is a little different. In ASP.NET Core, we can inject the services into the controller constructor, while HotChocolate does not recommend constructor injection. Instead, HotChocolate recommends using the method-level injection. First, the GraphQL type definitions are singleton objects. If we use constructor injection, the services will be injected as singleton objects as well. This is not what we want. Second, sometimes HotChocolate needs to synchronize the resolvers to avoid concurrency issues. If we use constructor injection, HotChocolate cannot control the lifetime of the services. Note that this applies to the HotChocolate GraphQL types and resolvers only. For other services, we can still use constructor injection.\nLet us see how to use the method-level injection.\nUsing the Service attribute\nWe can use `HotChocolate.ServiceAttribute` to inject services into the resolvers. For example, we can add a `GetTeachersWithDI` method in the `Query` class as follows:\n\n```", "```cs\n\nNote that the `Service` attribute is from the `HotChocolate` namespace, not the `Microsoft.AspNetCore.Mvc` namespace. With this attribute, `ITeacherService` will be injected into the `teacherService` parameter automatically.\nIf we have many services in the project, using the attribute for each service is tedious. HotChocolate provides a `RegisterServices()` method to simplify the injection. We can update the `Program.cs` file as follows:\n\n```", "```cs\n\nNow, we can remove the `Service` attribute from the `GetTeachersWithDI()` method. HotChocolate can still inject `ITeacherService` automatically, as shown here:\n\n```", "```cs\n\nThis will save us a lot of time.\nUnderstanding the lifetime of the injected services\nWe have learned that, in ASP.NET Core, we can inject the services as singleton, scoped, or transient services. HotChocolate offers more options for the lifetime of the injected services. When we use the `Service` attribute or the `RegisterService()` method to inject the services, we can specify the `ServiceKind` property to control the lifetime of the services. The `ServiceKind` has the following options:\n\n*   `ServiceKind.Default`: This is the default option. The service will be injected as the same lifetime in the registered service in the DI container.\n*   `ServiceKind.Synchronized`: This option is similar to the synchronized `DbContext`. The resolver using the service will be executed sequentially. The synchronization only happens in the same request scope.\n*   `ServiceKind.Resolver`: This option is to resolve the service for each resolver scope. The service will be disposed of after the resolver is completed.\n*   `ServiceKind.Pooled`: This option is similar to the pooled `DbContext`. The service needs to be registered as an `ObjectPool<T>` instance in the ASP.NET Core DI container. The resolver will get the service from the pool and return it to the pool after the resolver is completed.\n\nTo specify the `ServiceKind` for the injected services, we can add a `ServiceKind` parameter in the `Service` attribute or the `RegisterService()` method. For example, we can update the `GetTeachersWithDI()` method as follows:\n\n```", "```cs\n\nThe preceding code specifies the `ServiceKind` as `ServiceKind.Resolver`. So, `ITeacherService` will be resolved for each resolver scope.\nIf we use the `RegisterServices()` method to register the services, we can specify the `ServiceKind` in the `RegisterServices()` method, as follows:\n\n```", "```cs\n\nTo inject the services in the `Resolve()` method, we can get the service from the `context` object, as follows:\n\n```", "```cs\n\nThe preceding code uses the `context.Service<T>()` method to get `ITeacherService` from the `context` object, which is similar to injecting `IDbContextFactory<AppDbContext>` in the previous examples.\nInterface and union types\nHotChocolate supports the use of interfaces and union types in GraphQL. In this section, we will explore how to incorporate these features into your GraphQL schema. Interfaces provide a way to group types that share common fields, while union types allow for the creation of a single type that can return different object types. With HotChocolate, you can easily implement these features to enhance the functionality of your GraphQL schema.\nInterfaces\nTo prepare the examples of GraphQL interfaces, we have an `ISchoolRoom` interface and two classes that implement the interface, as follows:\n\n```", "```cs\n\nThe two classes both implement the `ISchoolRoom` interface, but they have some different properties. You can find the model classes and the model configurations in the sample code.\nThe service layer is defined in the `ISchoolRoomService` interface and the `SchoolRoomService` class, as follows:\n\n```", "```cs\n\nThe `GetSchoolRoomsAsync()` method retrieves a list of `LabRoom` objects and a list of `Classroom` objects from the database. Then, it combines the two lists into a single list of `ISchoolRoom` objects.\nWe also need to register `ISchoolRoomService` in the `Program.cs` file, as follows:\n\n```", "```cs\n\n To define an interface in HotChocolate, we need to use the `InterfaceType<T>` class. The `InterfaceType<T>` class is used to define an interface type in the schema. Follow these steps to define an interface type using the code-first API:\n\n1.  Create a class named `SchoolRoomType` in the `Types` folder:\n\n    ```", "```cs\n\n    The preceding code defines an interface type for the `ISchoolRoom` interface.\n\n     2.  Create two new classes for `LabRoom` and `Classroom`, as follows:\n\n    ```", "```cs\n\n    In the preceding code, we use the `Implements()` method to specify the interface implemented by the object type.\n\n     3.  Add a query field in the `Query` class:\n\n    ```", "```cs\n\n     4.  Configure the `SchoolRooms` field in the `QueryType` class:\n\n    ```", "```cs\n\n    In the preceding code, we use the `Service()` method to get `ISchoolRoomService` from the `context` object. Then, we use the `GetSchoolRoomsAsync()` method to retrieve the list of `ISchoolRoom` objects. The result includes both `LabRoom` and `Classroom` objects.\n\n     5.  Next, we need to explicitly register `LabRoomType` and `ClassroomType` in `SchemaBuilder`. Update the `Program.cs` file as follows:\n\n    ```", "```cs\n\n     6.  Run the application and check the generated schema. You will find the interface definition and its implementations, as shown here:\n\n    ```", "```cs\n\n     7.  Next, we can use the `SchoolRoom` interface to query both the `LabRoom` and `Classroom` objects. For example, we can use the following query to retrieve the `LabRoom` objects:\n\n    ```", "```cs\n\n    In the response, you can see that the `LabRoom` object has the `subject`, `equipment`, and `hasChemicals` properties, while the `Classroom` object has the `hasComputers`, `hasProjector`, and `hasWhiteboard` properties. This can be helpful when we want to query complex objects with different properties.\n\nAlthough interfaces provide flexibility for querying objects with different properties, we need to note that interfaces can be used for output types only. We cannot use interfaces for input types or arguments.\nUnion types\nUnion types are similar to interfaces. The difference is that union types do not need to define any common fields. Instead, union types can combine multiple object types into a single type.\nFollow the same approach as the previous section to prepare the models for union types. You can find an `Equipment` class and a `Furniture` class in the `Models` folder, as follows:\n\n```", "```cs\n\nThe `Equipment` class and the `Furniture` class have some different properties. You can find the model configurations in the sample code. We also need to add the services for both classes. You can find the following code in the `Services` folder.\nHere is the code for the `IEquipmentService` interface and the `EquipmentService` class:\n\n```", "```cs\n\nHere is the code for the `IFurnitureService` interface and the `FurnitureService` class:\n\n```", "```cs\n\nThe preceding code should be straightforward. Do not forget to register the services in the `Program.cs` file, as follows:\n\n```", "```cs\n\nNext, let's create the union types following these steps:\n\n1.  Create two classes named `EquipmentType` and `FurnitureType`, as follows:\n\n    ```", "```cs\n\n    The preceding code defines the `EquipmentType` and `FurnitureType` object types. These two object types are just normal object types.\n\n     2.  Create a new class named `SchoolItemType`, as follows:\n\n    ```", "```cs\n\n    The preceding code defines a union type named `SchoolItem`. A union type must inherit from the `UnionType` class. Then, we use the `Type` method to specify the object types that are included in the union type. In this case, the `SchoolItem` union type includes the `EquipmentType` and `FurnitureType` object types.\n\n    As we already registered these two types in the union type, we do not need to register them again in the `Program.cs` file.\n\n     3.  Add a query field in the `Query` class:\n\n    ```", "```cs\n\n     4.  Configure the resolver for the `SchoolItems` field in the `QueryType` class, as shown here:\n\n    ```", "```cs\n\n    We retrieve a list of `Equipment` and `Furniture` objects from the database. We then combine these two lists into a single list of objects, as the object type is the base type of all types in C#. This allows us to use the object type to effectively combine the two lists.\n\n     5.  Run the application and check the generated schema. You will find the union type defined as follows:\n\n    ```", "```cs\n\n    A union type is represented as a union of a list of object types using the `|` symbol. In this case, the `SchoolItem` union type includes the `Equipment` and `Furniture` object types.\n\n     6.  Then, we can query the `SchoolItem` union type, as follows:\n\n    ```", "```cs\n\n    In the response, you can see that the `Equipment` object has the `condition` and `brand` properties, while the `Furniture` object has the `color` and `material` properties. However, even though the `Equipment` and `Furniture` objects have some of the same properties (such as `Id`, `Name`, and so on.), the query must specify the properties for each object type. For example, we cannot use the following query:\n\n    ```", "```cs\n\n    The preceding query will cause an error, as follows:\n\n    ```", "```cs\n\nPlease note that the `SchoolItem` union type is not a base type of the `Equipment` and `Furniture` object types. If you want to query the common properties of the object types, you can use the interface type instead of the union type.\nFiltering, sorting, and pagination\nIn this section, we will learn how to implement filtering, sorting, and pagination in HotChocolate. These features are very important for a real-world application. We will use the `Student` object as an example to demonstrate how to implement these features. The `Student` class is defined as follows:\n\n```", "```cs\n\nTo use filtering, sorting, and pagination, we need to install the `HotChocolate.Data` NuGet package. If you already installed the `HotChocolate.Data.EntityFramework` package following the previous sections, you do not need to install the `HotChocolate.Data` package again. The `HotChocolate.Data` package is a dependency of the `HotChocolate.Data.EntityFramework` package. If not, you can install the `HotChocolate.Data` package using the following command:\n\n```", "```cs\n\n Let’s begin with filtering!\nFiltering\nHotChocolate supports filtering on the object type. A question is how we translate the GraphQL filter to the SQL-native queries. If the resolver exposes an `IQueryable` interface, HotChocolate can translate the GraphQL filter to SQL-native queries automatically. But we can also implement the filtering logic in the resolver manually. In this section, we will explore how to use filtering in HotChocolate.\nTo enable filtering on the `Student` object type, follow these steps:\n\n1.  First, we need to register the `Filtering` middleware in the `Program.cs` file, as follows:\n\n    ```", "```cs\n\n     2.  Add a query field in the `Query` class:\n\n    ```", "```cs\n\n     3.  Apply the filtering in the resolver of the `Students` field in the `QueryType`:\n\n    ```", "```cs\n\n    The preceding code uses the `UseFiltering()` method to enable filtering on the `Students` field. Then, we use the `AsQueryable()` method to expose the `IQueryable` interface. This allows HotChocolate to translate the GraphQL filter to SQL-native queries automatically.\n\n     4.  Run the application and check the generated schema. You will find the `students` query has a `StudentFilterInput` filter, as shown here:\n\n    ```", "```cs\n\n    HotChocolate automatically inspects the `Student` object type and generates the filter input type. The `StudentFilterInput` filter includes all the properties of the `Student` object type by default.\n\n     5.  Next, we can filter the `students` query, as follows:\n\n    ```", "```cs\n\n    You can find the generated SQL query in the logs, as follows:\n\n    ```", "```cs\n\n    The preceding SQL query uses the `WHERE` clause to filter the `Student` objects, which means the filtering is done in the database.\n\n     6.  The filtering can be defined in the variable as well. For example, we can use the following query to filter the `Student` objects:\n\n    ```", "```cs\n\n    The result is the same as the previous query. You can also try other operators to filter the `Student` objects. For example, the following variable uses the `in` operator to filter the `Student` objects:\n\n    ```", "```cs\n\n    The following variable uses the `gt` operator to filter the students who were born after `2001-01-01`:\n\n    ```", "```cs\n\nThe generated filter input type contains all the properties of the object type. Sometimes, we do not need to filter all the properties. For example, we may want to allow filtering on a few properties only. In this case, we can create a custom filter input type and specify the properties we want to filter. Follow these steps to create a custom filter input type:\n\n1.  Create a `Filters` folder in the `GraphQL` folder. Then, add a new class named `StudentFilterType`, as follows:\n\n    ```", "```cs\n\n     2.  Then, we need to specify the filter input type in the resolver. Update the resolver for the `students` query, as follows:\n\n    ```", "```cs\n\n     3.  Check the generated schema. You will find `StudentFilterInput` only contains the fields we specified in `StudentFilterType`, as shown here:\n\n    ```", "```cs\n\n     4.  If the model has many properties but we only want to ignore a few properties, we can use the `Ignore()` method to ignore the properties we do not want to filter. For example, we can update `StudentFilterType` as follows:\n\n    ```", "```cs\n\n    The preceding code defines a custom `StudentStringOperationFilterInputType` filter. The `StudentStringOperationFilterInputType` filter only includes the `eq` and `contains` operations. Then, we can use the `StudentStringOperationFilterInputType` filter in `StudentFilterType`, as follows:\n\n    ```", "```cs\n\n    Now, the `StudentFilterInput` filter only includes the `eq` and `contains` operations for the `FirstName` and `LastName` properties.\n\n     5.  The filter supports `and` and `or` operations. You can find an `and` and `or` property in the `StudentFilterInput` filter. These two fields are used to combine multiple filters. The `and` field means the filter must match all the conditions. The `or` field means the filter must match at least one condition. For example, we can use the following query to filter the `Student` objects whose first name is John and who were born after 2001-01-01 using the `and` operation:\n\n    ```", "```cs\n\n    The variables are defined as follows:\n\n    ```", "```cs\n\nIn the preceding examples, we expose the `IQueryable` interface in the resolver, so HotChocolate can translate the GraphQL filter to SQL-native queries automatically. However, sometimes, we cannot expose the `IQueryable` interface in the resolver. In this case, we need to implement the filtering logic in the resolver manually. The code would be more complex. Let us see how to implement the filtering logic in the resolver manually:\n\n1.  The methods to retrieve the list of the `Student` type by the group ID are defined in the `IStudentService` interface, as follows:\n\n    ```", "```cs\n\n    We have two methods for `eq` and `in` operations. The `GetStudentsByGroupIdAsync()` method retrieves the list of `Student` objects by the group ID. The `GetStudentsByGroupIdsAsync()` method retrieves the list of `Student` objects by the list of group IDs. These two methods return the list of `Student` objects instead of the `IQueryable` interface. So, we need to implement the filtering logic in the resolver manually.\n\n     2.  Define a customized filter for the `Student` type as follows:\n\n    ```", "```cs\n\n    In the preceding code, we define a custom filter input type named `CustomStudentFilterInput`. The `CustomStudentFilterInput` filter only includes the `GroupId` property. To make the filter more simple, we disable the `and` and `or` operations. Then, we define a custom filter input type named `CustomStudentGuidOperationFilterInput`. The `CustomStudentGuidOperationFilterInput` filter only includes the `eq` and `in` operations. Note that we need to specify the names of the filter input types. Otherwise, HotChocolate will report name conflicts because we already have a `StudentFilterInput` filter.\n\n     3.  Add a new query type in the `Query` class:\n\n    ```", "```cs\n\n     4.  Configure the resolver and manually filter the data in the `QueryType` class, as follows:\n\n    ```", "```cs\n\n    The preceding code is a bit complex. We need to get the filter from the `context` object. Then, we check whether the filter contains the `groupId` property. If the filter contains the `groupId` property, we check whether the `eq` or `in` operation is specified. If the `eq` operation is specified, we retrieve the list of `Student` objects by the group ID. If the `in` operation is specified, we retrieve the list of `Student` objects by the list of group IDs. If the `eq` or `in` operation is not specified, we retrieve all the `Student` objects.\n\n     5.  Run the application and check the generated schema. You will find the `studentsWithCustomFilter` query has a `CustomStudentFilterInput` filter, as shown here:\n\n    ```", "```cs\n\n    To filter the `Student` objects by `groupId`, we can define the following variable:\n\n    ```", "```cs\n\n    To filter the `Student` objects by the list of group IDs, we can define the following variable:\n\n    ```", "```cs\n\nAs the filtering variables may vary in different cases, the logic to filter the data may be different. It is recommended to use the `IQueryable` interface if possible, so that HotChocolate can translate the GraphQL filter to SQL-native queries automatically.\nSorting\nIn this section, we will learn how to use sorting in HotChocolate. The sorting is similar to filtering. We can use the `UseSorting()` method to enable sorting on the object type. If we use the `IQueryable` interface in the resolver, HotChocolate can translate the GraphQL sorting to SQL-native queries automatically. Otherwise, we need to implement the sorting logic in the resolver manually.\nTo enable sorting on the `Student` object type, the `HotChocolate.Data` package is required. Follow the step just before the *Filtering* section to install the `HotChocolate.Data` package if you have not installed it yet. Then, follow these steps to enable sorting on the `Student` object type:\n\n1.  Register the `Sorting` middleware in the `Program.cs` file, as follows:\n\n    ```", "```cs\n\n     2.  Update the resolver for the `students` query:\n\n    ```", "```cs\n\n    Note that `UseSorting()` must be placed after `UseFiltering`.\n\n     3.  Then, run the application and check the generated schema. You will find the `students` query has an `orderBy` argument, as shown here:\n\n    ```", "```cs\n\n    The `StudentSortInput` type includes all the properties of the `Student` object type. The `SortEnumType` type is an enum type, as follows:\n\n    ```", "```cs\n\n    The `SortDirection` type includes two values: `ASC` and `DESC`. The `ASC` value means the sorting is ascending. The `DESC` value means the sorting is descending.\n\n     4.  Next, we can query the `Student` type with sorting. The following query will sort the results by first name:\n\n    ```", "```cs\n\n    The sorting variable supports multiple properties. For example, the following query variable will sort the results by first name and last name:\n\n    ```", "```cs\n\n    The preceding SQL query uses the `ORDER BY` clause to sort the `Student` objects, which means the sorting is done in the database.\n\nSimilar to filtering, the default sorting includes all the properties of the object type. If we want to sort on specific properties only, we can create a custom sort input type and specify the properties we want to sort. Follow these steps to create a custom sort input type:\n\n1.  Create a folder named `Sorts` in the `GraphQL` folder. Add a new class named `StudentSortType`, as follows:\n\n    ```", "```cs\n\n    The preceding code defines a custom sort input type, which only includes the `FirstName`, `LastName`, and `DateOfBirth` properties.\n\n    Similar to the filter input type, you can explicitly specify the properties you want to sort, or you can ignore the properties you do not want to sort.\n\n     2.  Update the resolver to apply the custom sort input type:\n\n    ```", "```cs\n\n     3.  Run the application and check the schema. You will see that `StudentSortInput` now has three properties only:\n\n    ```", "```cs\n\nThe query is similar to the previous example, so we will not repeat it here.\nPagination\nPagination is a common feature in web API development. In this section, we will learn how to use pagination in HotChocolate.\nSimilar to filtering and sorting, we need to install the `HotChocolate.Data` package to use pagination. HotChocolate supports two types of pagination:\n\n*   **Cursor-based pagination**: This is the default pagination in HotChocolate. It uses a cursor to indicate the current position in the list. The cursor is usually an ID or a timestamp, which is opaque to the client.\n*   `skip` and `take` arguments to paginate the list.\n\nLet’s first use cursor-based pagination to paginate the `Student` objects. As we introduced before, if we use the `IQueryable` interface in the resolver, HotChocolate can translate the GraphQL pagination to SQL-native queries automatically. Follow the next steps to use cursor-based pagination for the `students` query:\n\n1.  Update the resolver for the `students` query:\n\n    ```", "```cs\n\n    Note that `UsePaging()` must be placed before `UseFiltering()` and `UseSorting()`.\n\n     2.  Run the application and check the generated schema. You will find that the `students` query now is the `StudentsConnection` type:\n\n    ```", "```cs\n\n    In GraphQL, the connection type is a standard way to paginate the list. The `StudentsConnection` type includes three fields: `pageInfo`, `edges`, and `nodes`. The `nodes` field is a list of the `Student` objects. The `edges` and `pageInfo` fields are defined in the `StudentsEdge` and `PageInfo` types as follows:\n\n    ```", "```cs\n\n     3.  Next, we can query the paginated `Student` objects as follows:\n\n    ```", "```cs\n\n    The result contains a `cursor` field for each `Student` object. The `cursor` field is an opaque string, which is used to indicate the current position in the list. The `pageInfo` field indicates whether there are more pages. In this case, the `hasNextPage` field is `true`, which means there are more pages.\n\n     4.  To query the next page, we need to specify the `after` parameter:\n\n    ```", "```cs\n\n    The preceding SQL query uses the `OFFSET` and `FETCH` clauses to paginate the `Student` objects, which means the pagination is handled in the database.\n\n     5.  To query the previous page, we need to specify the `before` parameter, as in this example:\n\n    ```", "```cs\n\n     6.  We can specify the options for pagination in the `UsePaging()` method. For example, we can specify the default page size and include the total count in the `UsePaging()` method, as follows:\n\n    ```", "```cs\n\n    You can see the `totalCount` field in the response. The default page size is `5`.\n\n     7.  We can use pagination with filtering and sorting. The following query will filter the `Student` objects by first name and sort the results by first name and then by last name:\n\n    ```", "```cs\n\n    After querying the first page, we can query the next page, as follows:\n\n    ```", "```cs\n\n    You can also define the `after` parameter in the query variable, as follows:\n\n    ```", "```cs\n\nThe query language of GraphQL is very flexible. We cannot list all the possible queries here. You can try different queries by yourself.\nHotChocolate supports offset-based pagination as well. To use offset-based pagination, we need to use the `UseOffsetPaging()` method instead of the `UsePaging()` method. Follow these steps to use offset-based pagination:\n\n1.  Update the resolver for the `students` query:\n\n    ```", "```cs\n\n    The preceding code uses the `UseOffsetPaging()` method to enable offset-based pagination instead of cursor-based pagination.\n\n     2.  Run the application and check the generated schema. You will find the `students` query is now the `StudentsCollectionSegment` type:\n\n    ```", "```cs\n\n    You should be familiar with the `skip` and `take` arguments. The `skip` argument is used to skip the first `n` items. The `take` argument is used to take the first `n` items. We already used these two methods in LINQ to implement the pagination.\n\n     3.  Next, we can query the paginated `Student` objects as follows:\n\n    ```", "```cs\n\n     4.  To query the next page, we need to specify the `skip` and `take` parameters, as follows:\n\n    ```", "```cs\n\n     5.  You can define the `skip` and `take` parameters in the query variable as follows:\n\n    ```", "```cs\n\n     6.  We can specify the pagination options in the `UseOffsetPaging` method:\n\n    ```", "```cs\n\n    You can include the `totalCount` field in the response now.\n\n     7.  We can use pagination with filtering and sorting. The following query will filter the `Student` objects by first name and sort the results by first name and then by last name, and then fetch the second page:\n\n    ```", "```cs\n\n    The generated SQL query is shown here:\n\n    ```", "```cs\n\nThe preceding SQL query shows that the pagination is handled in the database.\nVisualizing the GraphQL schema\nWhen the GraphQL API becomes more complex, it is difficult to understand the schema. We can use `GraphQL Voyager` to visualize the GraphQL schema. `GraphQL Voyager` is an open-source project that can visualize the GraphQL schema in an interactive graph. It is a frontend application that can be integrated with the GraphQL API. To use it in our ASP.NET Core application, we can use the `GraphQL.Server.Ui.Voyager` package. This package is part of the GraphQL.NET project.\nFollow these steps to use GraphQL Voyager in our application:\n\n1.  Install the `GraphQL.Server.Ui.Voyager` package using the following command:\n\n    ```", "```cs\n    app.MapGraphQLVoyager();\n    ```", "```cs\n    app.MapGraphQLVoyager(\"/voyager\");\n    ```", "```cs\n\n     2.  Run the application and navigate to the `ui/voyager` URL. You will see the following page:\n\n![Figure 12.5 – The GraphQL Voyager UI](img/B18971_12_05.jpg)\n\nFigure 12.5 – Overview of the GraphQL Voyager UI\nVisualizing the GraphQL schema can be beneficial for your team. Doing so allows you to share the schema with your team members, making it easier to collaborate and stay on the same page.\nSummary\nIn this chapter, we explored how to use HotChocolate and Entity Framework Core to create a GraphQL API. We discussed how to define object types, queries, and mutations, as well as how to use dependency injection to inject the `DbContext` instance and services into the resolver. We also introduced the data loader, which can reduce the number of queries to the database. Additionally, we discussed interface and union types, which are useful for defining polymorphic types. Finally, we explored how to use filtering, sorting, and pagination in HotChocolate.\nIn the next chapter, we will discuss SignalR, which is a real-time communication library in ASP.NET Core.\nFurther reading\nIt is important to note that GraphQL is a comprehensive query language and there are many features that we were unable to cover in this chapter. For example, GraphQL supports subscriptions, which enable real-time communication with the GraphQL API. To learn more about HotChocolate and GraphQL, please refer to the following resources:\n\n*   [https://graphql.org/learn/](https://graphql.org/learn/)\n*   [https://chillicream.com/docs/hotchocolate/](https://chillicream.com/docs/hotchocolate/)\n\nIn a microservice architecture, we can use Apollo Federation to create a GraphQL gateway. Apollo Federation can combine multiple GraphQL APIs into a single GraphQL API. We will not cover Apollo Federation here as it is out of the scope of this book. To learn more about Apollo Federation, please refer to the following resources:\n\n*   [https://www.apollographql.com/](https://www.apollographql.com/)\n*   [https://github.com/apollographql](https://github.com/apollographql)\n\n```"]