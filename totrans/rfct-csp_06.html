<html><head></head><body>
<div id="_idContainer100">
<h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.2.1">Unit Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the first part of this book, we covered the process of refactoring and some of the more common refactoring techniques. </span><span class="koboSpan" id="kobo.3.2">Now, it’s time for us to take a step back and remind ourselves of what refactoring is: </span><em class="italic"><span class="koboSpan" id="kobo.4.1">refactoring is the process of changing the form or shape of the code without changing how </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">it behaves</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In other words, we can make our code as clean and easy to maintain as we can, but if those changes introduce bugs, that’s not refactoring since refactoring is about changing the form of code </span><em class="italic"><span class="koboSpan" id="kobo.8.1">without changing its behavior</span></em><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">To improve our code without introducing bugs, we need a safety net: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.10.1">unit testing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we’ll explore unit tests and cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Understanding testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">unit tests</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Testing code </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">with xUnit</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">unit tests</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Exploring other </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">testing frameworks</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Adopting a </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">testing mindset</span></span></li>
</ul>
<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">The starting code for this chapter is available from GitHub at </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.27.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">Chapter06/Ch6BeginningCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.29.1"> folder.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.30.1">Understanding testing and unit tests</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Whenever I was</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.32.1"> managing or mentoring another developer and they wanted to make a change to a system I’d ask them a question: </span><em class="italic"><span class="koboSpan" id="kobo.33.1">“How can you be sure your change won’t </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.34.1">break things?”</span></em></span></p>
<p><span class="koboSpan" id="kobo.35.1">This simple question can be deceptively hard to answer, but every answer I’ve ever heard boils down to a single </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">concept: testing.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">I </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.38.1">define </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">testing</span></strong><span class="koboSpan" id="kobo.40.1"> as </span><em class="italic"><span class="koboSpan" id="kobo.41.1">the process of verifying software functionality and detecting unwanted changes to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.42.1">program behavior</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">This testing could be done by a human, such as a developer or a quality assurance analyst, or it could be done via software, depending on the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">test involved.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.46.1">Types of tests and the testing pyramid</span></h2>
<p><span class="koboSpan" id="kobo.47.1">Testing is a </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.48.1">broad field that encompasses many different types of activities, including </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Manual testing</span></strong><span class="koboSpan" id="kobo.51.1">, which</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.52.1"> involves a person performing some activity manually and verifying </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">the outcome.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Exploratory testing</span></strong><span class="koboSpan" id="kobo.55.1">, a </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.56.1">subset of manual testing that focuses on exploring how the system reacts to things to find new types </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">of bugs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.58.1">Unit tests</span></strong><span class="koboSpan" id="kobo.59.1">, in </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.60.1">which small parts of the software system are tested </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">in isolation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Component tests</span></strong><span class="koboSpan" id="kobo.63.1">, where</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.64.1"> larger components of the system </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">are tested.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Integration tests</span></strong><span class="koboSpan" id="kobo.67.1">, which</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.68.1"> involve two components, such as an API and a database, that are </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">tested together.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.70.1">End-to-end tests</span></strong><span class="koboSpan" id="kobo.71.1">, in </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.72.1">which entire paths through the system are tested. </span><span class="koboSpan" id="kobo.72.2">This usually involves multiple sets of components interacting </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">in sequence.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.74.1">Most of these activities are automated tests where computer code interacts with the system to verify its behavior. </span><span class="koboSpan" id="kobo.74.2">We’ll talk more about what factors make up good tests at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Automated tests do have some drawbacks. </span><span class="koboSpan" id="kobo.76.2">First, automated tests take time to create. </span><span class="koboSpan" id="kobo.76.3">Typically, a human must write code or use some tool to script out the test. </span><span class="koboSpan" id="kobo.76.4">Secondly, these tests often require ongoing maintenance as the software system changes to stay relevant. </span><span class="koboSpan" id="kobo.76.5">Finally, these tests can offer a false sense of security. </span><span class="koboSpan" id="kobo.76.6">For example, let’s say a developer wrote a test to navigate to the “book a flight” web page and verify that open seats display as available. </span><span class="koboSpan" id="kobo.76.7">This test may pass even if the web page has obvious errors and misalignments on it, simply because the test was only coded to check a small part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">web page.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">On the other hand, human testers are intelligent. </span><span class="koboSpan" id="kobo.78.2">They have free agency and initiative and can make objective judgments about software that machines cannot. </span><span class="koboSpan" id="kobo.78.3">They can find issues that nobody ever thought of writing a test for, and they can provide valuable feedback about the functionality of your products. </span><span class="koboSpan" id="kobo.78.4">However, people are usually a lot slower than automated tests and it may take some time for a quality assurance analyst to test a feature once it is ready </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">for testing.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">There are strengths and weaknesses when it comes to both automated and manual tests. </span><span class="koboSpan" id="kobo.80.2">One is not better than the other; instead, they combine to make for an effective solution to quality issues in </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">software projects.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">A popular concept in </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.83.1">software quality is the idea of a </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">testing pyramid</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">A testing pyramid shows the various types of tests an organization might perform. </span><span class="koboSpan" id="kobo.85.3">Additionally, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.86.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.87.1">.1</span></em><span class="koboSpan" id="kobo.88.1">, the width of each segment of the pyramid indicates the </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.89.1">quantity of that type </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">of test:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.91.1"><img alt="Figure 6.1 – An example of a testing pyramid" src="image/B21324_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1">Figure 6.1 – An example of a testing pyramid</span></p>
<p><span class="koboSpan" id="kobo.93.1">In a testing pyramid, such as this one, the items at the base should be the most numerous and the items at the top of the pyramid should be the rarest. </span><span class="koboSpan" id="kobo.93.2">Almost every diagram of a testing pyramid is different in the exact types of tests listed in the pyramid, but all of them agree that the most common form of testing should be the unit test and the least common should be </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">manual testing.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Many organizations </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.96.1">get this wrong early in their software development maturity. </span><span class="koboSpan" id="kobo.96.2">When that happens, they have a lot of manual tests, few unit tests, and typically no end-to-end, integration, or component tests. </span><span class="koboSpan" id="kobo.96.3">As a result, the pyramid would look a little like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.97.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.100.1"><img alt="Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and no other tests" src="image/B21324_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.101.1">Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and no other tests</span></p>
<p><span class="koboSpan" id="kobo.102.1">This pyramid </span><em class="italic"><span class="koboSpan" id="kobo.103.1">should</span></em><span class="koboSpan" id="kobo.104.1"> look ridiculous because having very little test automation is almost always a recipe for slow processes, delayed releases, and software bugs reaching </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">production environments!</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">The larger your system becomes, the less feasible manual testing will be and the longer it will take to discover </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">bugs manually.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">The solution to this is </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">automated testing</span></strong><span class="koboSpan" id="kobo.110.1">, particularly</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.111.1"> automated </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">unit testing.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.113.1">Unit tests</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Unit tests</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.115.1"> are small methods of code that test other methods in your system to verify those methods perform correctly given a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">specific scenario.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.117.1">More succinctly, unit tests are code that tests </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">other code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.120.1">Already familiar with tests?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.121.1">You may already be familiar with unit tests if you work with unit tests regularly. </span><span class="koboSpan" id="kobo.121.2">If that’s true, you may want to skim the rest of this chapter and resume with the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">next one.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">To illustrate the idea of unit testing, let’s look at a simple method that generates a flight </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">status message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
public class Flight {
</span><strong class="bold"><span class="koboSpan" id="kobo.126.1">  public string BuildMessage(string id, string status){</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.127.1">    return $"Flight {id} is {status}";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.128.1">  }</span></strong><span class="koboSpan" id="kobo.129.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.130.1">While this </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.131.1">method is very simple, let’s think about the steps we’d need to take to verify it </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">works correctly:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.133.1">Instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Flight</span></strong><span class="koboSpan" id="kobo.135.1"> class and store that object in </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">a variable.</span></span></li>
<li><span class="koboSpan" id="kobo.137.1">Declare a pair of string variables representing </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">id</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.139.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">status</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">Invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">BuildMessage</span></strong><span class="koboSpan" id="kobo.144.1"> method on our flight object from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.145.1">Step 1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">Store the result of </span><em class="italic"><span class="koboSpan" id="kobo.148.1">Step 3</span></em><span class="koboSpan" id="kobo.149.1"> in a new </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">string variable.</span></span></li>
<li><span class="koboSpan" id="kobo.151.1">Verify the string we just stored matched what </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">we expected.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.153.1">This is essentially what a unit test would do. </span><span class="koboSpan" id="kobo.153.2">It would instantiate your class, </span><em class="italic"><span class="koboSpan" id="kobo.154.1">arrange</span></em><span class="koboSpan" id="kobo.155.1"> the variables it needs, </span><em class="italic"><span class="koboSpan" id="kobo.156.1">act</span></em><span class="koboSpan" id="kobo.157.1"> on the method the unit test is trying to verify, and finally </span><em class="italic"><span class="koboSpan" id="kobo.158.1">assert</span></em><span class="koboSpan" id="kobo.159.1"> that the result of the method matched what we expected. </span><span class="koboSpan" id="kobo.159.2">We call this pattern the </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">arrange/act/assert</span></strong><span class="koboSpan" id="kobo.161.1"> pattern</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.162.1"> and we’ll discuss it more later in </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">To help illustrate this concept, here’s a sample test for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">BuildMessage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
public class FlightTests {
</span><strong class="bold"><span class="koboSpan" id="kobo.168.1">  [Fact]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.169.1">  public void GeneratedMessageShouldBeCorrect() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.170.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.171.1">// Arrange</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.172.1">    Flight flight = new();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.173.1">    string id = "CSA1234";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.174.1">    string status = "On Time";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.175.1">    // Act</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.176.1">    string message = flight.BuildMessage(id, status);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.177.1">    // Assert</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.178.1">    Assert.Equal("Flight CSA1234 is On Time", message);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.179.1">  }</span></strong><span class="koboSpan" id="kobo.180.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.181.1">Don’t worry</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.182.1"> about the specific syntax here as we’ll get into this shortly. </span><span class="koboSpan" id="kobo.182.2">For now, understand that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">GeneratedMessageShouldBeCorrect</span></strong><span class="koboSpan" id="kobo.184.1"> method is an example of a unit test that tests a small unit of code to verify a specific piece </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">of functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Specifically, this method verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">Flight</span></strong><span class="koboSpan" id="kobo.188.1"> class’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">BuildMessage</span></strong><span class="koboSpan" id="kobo.190.1"> method calculates and returns an accurate status message given the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">id</span></strong><span class="koboSpan" id="kobo.192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">status</span></strong><span class="koboSpan" id="kobo.194.1"> parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">it receives.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">This test can be run quickly alongside all the other tests in the solution and will either pass if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">BuildMessage</span></strong><span class="koboSpan" id="kobo.198.1"> method is acting as expected or will fail if the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">BuildMessage</span></strong><span class="koboSpan" id="kobo.200.1"> ever changes, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.201.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.204.1"><img alt="Figure 6.3 – A failing unit test" src="image/B21324_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.205.1">Figure 6.3 – A failing unit test</span></p>
<p><span class="koboSpan" id="kobo.206.1">Test failures such as this are helpful because they highlight bugs that developers might otherwise release into production without the failing test flagging the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">potential issue.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">In the next section, we’ll explore unit tests more by introducing the most popular unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">framework: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.210.1">xUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.212.1">Testing code with xUnit</span></h1>
<p><span class="koboSpan" id="kobo.213.1">xUnit.net, commonly </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.214.1">referred to as xUnit, is currently the most popular unit testing library in .NET, followed </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.215.1">by </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">NUnit</span></strong><span class="koboSpan" id="kobo.217.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">MSTest</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">All </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.220.1">three libraries provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Attributes</span></strong><span class="koboSpan" id="kobo.222.1"> that you can use to identify your test code, as we’ll see shortly. </span><span class="koboSpan" id="kobo.222.2">Using these attributes lets</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.223.1"> a test runner, such as Visual Studio’s </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.225.1">, recognize</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.226.1"> your methods as unit tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">run them.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">This</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.229.1"> chapter’s code starts with most of the classes from the chapters up to this point, organized into various namespaces inside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Chapter6</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.231.1">project</span></strong><span class="koboSpan" id="kobo.232.1"> within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">Chapter6BeginningCode</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.234.1">solution</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.236.1">Solutions and projects</span></p>
<p class="callout"><span class="koboSpan" id="kobo.237.1">In .NET, a project represents a distinct assembly of .NET code that accomplishes some purpose. </span><span class="koboSpan" id="kobo.237.2">Different projects have different types, from desktop applications to web servers to class libraries and test projects. </span><span class="koboSpan" id="kobo.237.3">Solutions, on the other hand, group all of these projects together into a collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">interrelated projects.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">In the remainder of this chapter, we’ll write tests for a number of the classes from the previous chapters. </span><span class="koboSpan" id="kobo.239.2">Since xUnit is currently the most popular testing library, let’s start by adding a new xUnit test project to </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">the solution.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.241.1">Creating an xUnit Test Project</span></h2>
<p><span class="koboSpan" id="kobo.242.1">To </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.243.1">add a new project to a solution, right-click on the solution’s name at the top of </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.245.1">, just below the search bar, and then choose </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Add</span></strong><span class="koboSpan" id="kobo.247.1">, followed by </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.248.1">New Project…</span></strong></span></p>
<p><span class="koboSpan" id="kobo.249.1">Next, search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">xUnit</span></strong><span class="koboSpan" id="kobo.251.1"> and select the </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">xUnit Test Project</span></strong><span class="koboSpan" id="kobo.253.1"> result with the C# label attached to it, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.254.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.255.1">.4</span></em><span class="koboSpan" id="kobo.256.1">. </span><span class="koboSpan" id="kobo.256.2">Note that there are also versions of this test project that use other languages, such as VB </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">or F#:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.258.1"><img alt="Figure 6.4 – Selecting the xUnit Test Project option" src="image/B21324_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">Figure 6.4 – Selecting the xUnit Test Project option</span></p>
<p><span class="koboSpan" id="kobo.260.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">Next</span></strong><span class="koboSpan" id="kobo.262.1">, then </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.263.1">give your test project a meaningful name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Chapter6XUnitTests</span></strong><span class="koboSpan" id="kobo.265.1">, and click </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.266.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1"> again.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">After this, you'll need to select the version of .NET to use. </span><span class="koboSpan" id="kobo.268.2">Since the code in this book uses </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">.NET 8</span></strong><span class="koboSpan" id="kobo.270.1">,  you can select that option and </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.272.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">This should open a new file in your editor that contains some basic </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">test code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">UnitTest1.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
namespace Chapter6XUnitTests {
    public class UnitTest1 {
        [Fact]
        public void Test1() {
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.278.1">Additionally, a new project was added to your solution that now appears in </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.280.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.281.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.282.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.284.1"><img alt="Figure 6.5 – The test project in Solution Explorer" src="image/B21324_06_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.285.1">Figure 6.5 – The test project in Solution Explorer</span></p>
<p><span class="koboSpan" id="kobo.286.1">There </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.287.1">are still a few more steps that we’ll need to do to test our code in the other project. </span><span class="koboSpan" id="kobo.287.2">But before we do that, it may surprise you that the code xUnit created is already a runnable </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">unit test.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">Test</span></strong><span class="koboSpan" id="kobo.291.1"> menu at the top of Visual Studio and then select </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">Run All Tests</span></strong><span class="koboSpan" id="kobo.293.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.295.1"> should now show your </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Test1</span></strong><span class="koboSpan" id="kobo.297.1"> unit test, which will turn into a green check mark once the test runs, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.298.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.299.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.301.1"><img alt="Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is visible" src="image/B21324_06_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.302.1">Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is visible</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.303.1">Troubleshooting</span></p>
<p class="callout"><span class="koboSpan" id="kobo.304.1">If you do not see </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.306.1"> after running your tests, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">View</span></strong><span class="koboSpan" id="kobo.308.1"> menu and then select </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">You may also need to build your solution before running tests becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">an option.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">Note</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.313.1"> that our current test isn’t much of a test and we still haven’t covered the code or how it works. </span><span class="koboSpan" id="kobo.313.2">We’ll get there shortly, but first, let’s take the final step in setting up our tests and connect our test project to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Chapter6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1"> project.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.316.1">Connecting the xUnit Test Project to your main project</span></h2>
<p><span class="koboSpan" id="kobo.317.1">In .NET, projects </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.318.1">can depend on code in other projects. </span><span class="koboSpan" id="kobo.318.2">This allows you to have a class defined in one project and another project uses that class. </span><span class="koboSpan" id="kobo.318.3">This is something we’ll need to be able to do to test code from our unit test project. </span><span class="koboSpan" id="kobo.318.4">So, we’ll need to set up a project dependency from the test project to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Chapter6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1"> project.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">Dependencies</span></strong><span class="koboSpan" id="kobo.323.1"> node inside of the test project in </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.325.1"> and choose </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Add Project Reference…</span></strong><span class="koboSpan" id="kobo.327.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.328.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.329.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.331.1"><img alt="Figure 6.7 – Adding a project reference to our test project" src="image/B21324_06_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">Figure 6.7 – Adding a project reference to our test project</span></p>
<p><span class="koboSpan" id="kobo.333.1">After this, click the checkmark next to </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Chapter6</span></strong><span class="koboSpan" id="kobo.335.1"> and click </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">OK</span></strong><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">This will add a reference from your test project to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Chapter6</span></strong><span class="koboSpan" id="kobo.339.1"> project so that the test project can now reference classes defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">other project.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">With all this in place, we’re ready to write our first </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">real test.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.343.1">Writing your first unit test</span></h2>
<p><span class="koboSpan" id="kobo.344.1">Our first tests </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.345.1">will test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">BaggageCalculator</span></strong><span class="koboSpan" id="kobo.347.1"> class we built in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.348.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.349.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">BaggageCalculator</span></strong><span class="koboSpan" id="kobo.351.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">CalculatePrice</span></strong><span class="koboSpan" id="kobo.353.1"> method with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">method signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.355.1">
public decimal CalculatePrice(int bags, int carryOn,
  int passengers, bool isHoliday)</span></pre>
<p><span class="koboSpan" id="kobo.356.1">We also know the following rules for </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">this method:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.358.1">All carry-on baggage costs $30 </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">per bag</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">The first checked bag a passenger checks in </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">costs $40</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Each subsequent checked bag </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">costs $50</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">If the travel occurs during the holidays, a 10% surcharge </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">is applied</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.366.1">We won’t be able to test all this logic in a single test, and we shouldn’t try. </span><span class="koboSpan" id="kobo.366.2">Unit tests should be small and related to one specific piece of logic. </span><span class="koboSpan" id="kobo.366.3">If a test fails, that failure should tell you a lot about what is wrong in your system. </span><span class="koboSpan" id="kobo.366.4">If unit tests try to do too much, they become harder to understand and a failure tells you less about what </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is wrong.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">Let’s start by taking our </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">UnitTest1</span></strong><span class="koboSpan" id="kobo.370.1"> class and renaming it using the rename refactoring we covered in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.371.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.372.1">. </span><span class="koboSpan" id="kobo.372.2">Tests are generally named after the class they test. </span><span class="koboSpan" id="kobo.372.3">Since our class tests </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">BaggageCalculator</span></strong><span class="koboSpan" id="kobo.374.1">, let’s rename </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">BaggageCalculatorTests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Next, we’ll rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Test1</span></strong><span class="koboSpan" id="kobo.380.1"> method to reflect what we’re trying to verify. </span><span class="koboSpan" id="kobo.380.2">The name of this test will show up in a test failure. </span><span class="koboSpan" id="kobo.380.3">So, my general rule of thumb is that if I get a notification that a test failed, its name alone should tell me what </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">went wrong.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">In our case, we’re trying to verify that carry-on baggage is priced correctly. </span><span class="koboSpan" id="kobo.382.2">So, let’s rename </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Test1</span></strong><span class="koboSpan" id="kobo.384.1"> to something </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">like </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">CarryOnBaggageIsPricedCorrectly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Our code now reads </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
namespace Chapter6XUnitTests {
  </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">public class BaggageCalculatorTests</span></strong><span class="koboSpan" id="kobo.392.1"> {
    </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">[Fact]</span></strong><span class="koboSpan" id="kobo.394.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">public void CarryOnBaggageIsPricedCorrectly()</span></strong><span class="koboSpan" id="kobo.396.1"> {
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.397.1">Before we </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.398.1">move on to writing our test code, let’s highlight a few </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">key things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.400.1">First, our method has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Fact</span></strong><span class="koboSpan" id="kobo.402.1"> attribute applied to it. </span><span class="koboSpan" id="kobo.402.2">This lets xUnit tell the test runner about our test and effectively registers the test for </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">potential execution.</span></span></li>
<li><span class="koboSpan" id="kobo.404.1">Next, </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">CarryOnBaggageIsPricedCorrectly</span></strong><span class="koboSpan" id="kobo.406.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">void</span></strong><span class="koboSpan" id="kobo.408.1"> and accepts no parameters. </span><span class="koboSpan" id="kobo.408.2">Test methods using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">Fact</span></strong><span class="koboSpan" id="kobo.410.1"> attribute cannot accept parameters and must either return </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">void</span></strong><span class="koboSpan" id="kobo.412.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Task</span></strong><span class="koboSpan" id="kobo.414.1"> for asynchronous tests. </span><span class="koboSpan" id="kobo.414.2">We’ll discuss </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Theory</span></strong><span class="koboSpan" id="kobo.416.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">InlineData</span></strong><span class="koboSpan" id="kobo.418.1"> later in this chapter as they allow you to pass in parameters to </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">unit tests.</span></span></li>
<li><span class="koboSpan" id="kobo.420.1">Finally, both the class and the method are </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">public</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">Both must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">public</span></strong><span class="koboSpan" id="kobo.424.1"> for the unit test to appear in the </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">test runner.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.426.1">Now that we’ve covered some of the basic mechanics of unit tests, let’s follow the </span><em class="italic"><span class="koboSpan" id="kobo.427.1">arrange</span></em><span class="koboSpan" id="kobo.428.1">/</span><em class="italic"><span class="koboSpan" id="kobo.429.1">act</span></em><span class="koboSpan" id="kobo.430.1">/</span><em class="italic"><span class="koboSpan" id="kobo.431.1">assert</span></em><span class="koboSpan" id="kobo.432.1"> pattern to build </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">our test.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.434.1">Organizing tests with Arrange/Act/Assert</span></h2>
<p><span class="koboSpan" id="kobo.435.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">arrange/act/assert pattern</span></strong><span class="koboSpan" id="kobo.437.1"> is a </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.438.1">structural pattern that’s used when writing tests. </span><span class="koboSpan" id="kobo.438.2">When</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.439.1"> following </span><em class="italic"><span class="koboSpan" id="kobo.440.1">arrange</span></em><span class="koboSpan" id="kobo.441.1">/</span><em class="italic"><span class="koboSpan" id="kobo.442.1">act</span></em><span class="koboSpan" id="kobo.443.1">/</span><em class="italic"><span class="koboSpan" id="kobo.444.1">assert</span></em><span class="koboSpan" id="kobo.445.1">, you perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">following steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.447.1">Arrange</span></strong><span class="koboSpan" id="kobo.448.1"> the things that you need for your tests by </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">declaring variables.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.450.1">Act</span></strong><span class="koboSpan" id="kobo.451.1"> on the specific thing you’re trying </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">to test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.453.1">Assert</span></strong><span class="koboSpan" id="kobo.454.1"> that the result of your action produced the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">desired outcome.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.456.1">Let’s start by arranging the code. </span><span class="koboSpan" id="kobo.456.2">Since we’re testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">CalculatePrice</span></strong><span class="koboSpan" id="kobo.458.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">BaggageCalculator</span></strong><span class="koboSpan" id="kobo.460.1"> class, we’ll need to instantiate an instance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">baggage calculator.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">We also </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.463.1">know we’ll need to pass in the number of checked and carry-on bags, as well as the number of passengers and whether the travel is during a holiday season. </span><span class="koboSpan" id="kobo.463.2">These values should be whatever we think will make the most relevant or representative test, so they’re up to </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">our discretion.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Filling out our </span><em class="italic"><span class="koboSpan" id="kobo.466.1">arrange</span></em><span class="koboSpan" id="kobo.467.1"> section with variable declarations results in the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
[Fact]
public void CarryOnBaggageIsPricedCorrectly() {
    // Arrange
</span><strong class="bold"><span class="koboSpan" id="kobo.470.1">    BaggageCalculator calculator = new();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.471.1">    int carryOnBags = 2;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.472.1">    int checkedBags = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.473.1">    int passengers = 1;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.474.1">    bool isHoliday = false;</span></strong></pre>
<p><span class="koboSpan" id="kobo.475.1">Here, we’re setting up everything we need to carry out the </span><em class="italic"><span class="koboSpan" id="kobo.476.1">act</span></em><span class="koboSpan" id="kobo.477.1"> phase. </span><span class="koboSpan" id="kobo.477.2">Also, note that I included an </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">// Arrange</span></strong><span class="koboSpan" id="kobo.479.1"> comment to group related code together. </span><span class="koboSpan" id="kobo.479.2">This is something I and many other developers I know do in our test code to help </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">organize tests.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">Now that we have our variables in place, we can act upon the code we’re testing: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">CalculatePrice</span></strong><span class="koboSpan" id="kobo.483.1"> method. </span><span class="koboSpan" id="kobo.483.2">To do this, we must call the method and store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">decimal</span></strong><span class="koboSpan" id="kobo.485.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">it returns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.487.1">
// Act
decimal result = </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">calculator.CalculatePrice(checkedBags,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.489.1">  carryOnBags, passengers, isHoliday)</span></strong><span class="koboSpan" id="kobo.490.1">;</span></pre>
<p><span class="koboSpan" id="kobo.491.1">Unlike the </span><em class="italic"><span class="koboSpan" id="kobo.492.1">arrange</span></em><span class="koboSpan" id="kobo.493.1"> section, the </span><em class="italic"><span class="koboSpan" id="kobo.494.1">act</span></em><span class="koboSpan" id="kobo.495.1"> section is very brief, usually only a single line long. </span><span class="koboSpan" id="kobo.495.2">This is because the </span><em class="italic"><span class="koboSpan" id="kobo.496.1">act</span></em><span class="koboSpan" id="kobo.497.1"> section focuses on the thing you’re trying to test. </span><span class="koboSpan" id="kobo.497.2">We call the method we’re testing on the calculator object that was instantiated earlier and pass it the parameters it needs to do </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">its job.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.499.1">The system under test</span></p>
<p class="callout"><span class="koboSpan" id="kobo.500.1">In our example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">calculator</span></strong><span class="koboSpan" id="kobo.502.1"> variable stores the instance of the class we’re testing. </span><span class="koboSpan" id="kobo.502.2">This is commonly referred </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.503.1">to as the </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">system under test</span></strong><span class="koboSpan" id="kobo.505.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.506.1">SUT</span></strong><span class="koboSpan" id="kobo.507.1">). </span><span class="koboSpan" id="kobo.507.2">Some teams use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">sut</span></strong><span class="koboSpan" id="kobo.509.1"> variable name for the object they’re about </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">to test.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Here’s </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.512.1">the cool thing: from our test’s perspective, we don’t care how it does its job. </span><span class="koboSpan" id="kobo.512.2">All we care about is that we give the method a set of inputs and we expect a </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">specific output.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">We verify this behavior in our </span><em class="italic"><span class="koboSpan" id="kobo.515.1">assert</span></em><span class="koboSpan" id="kobo.516.1"> section by asserting that one or more things are true. </span><span class="koboSpan" id="kobo.516.2">If these things turn out </span><em class="italic"><span class="koboSpan" id="kobo.517.1">not</span></em><span class="koboSpan" id="kobo.518.1"> to be true, our test will fail. </span><span class="koboSpan" id="kobo.518.2">If all of them turn out to be true, the test </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">will pass.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">Assertions typically use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Assert</span></strong><span class="koboSpan" id="kobo.522.1"> class to verify that values match their expected value. </span><span class="koboSpan" id="kobo.522.2">In our case, the scenario has 2 carry-on bags and no other bags. </span><span class="koboSpan" id="kobo.522.3">At $30 per carry-on bag, this should work out to $60, so our test code becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
// Assert
</span><strong class="bold"><span class="koboSpan" id="kobo.525.1">Assert.Equal(60m, result);</span></strong></pre>
<p><span class="koboSpan" id="kobo.526.1">The first parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Equal</span></strong><span class="koboSpan" id="kobo.528.1"> method is the expected value. </span><span class="koboSpan" id="kobo.528.2">That’s the value </span><em class="italic"><span class="koboSpan" id="kobo.529.1">you</span></em><span class="koboSpan" id="kobo.530.1"> expect your result to be. </span><span class="koboSpan" id="kobo.530.2">You should </span><em class="italic"><span class="koboSpan" id="kobo.531.1">not</span></em><span class="koboSpan" id="kobo.532.1"> be calculating this value in code; otherwise, you risk repeating the same potentially bad logic in the code you’re testing to </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">begin with!</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">The second parameter is the actual value, which is almost always the result of calling your method in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.535.1">act</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">Often, developers new to testing expect the first parameter to be the actual value and the second value to be the expected value. </span><span class="koboSpan" id="kobo.537.2">However, this is incorrect and will lead to confusing test failures with </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">swapped values.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">For example, if the result was 50 and we verified it correctly with </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Assert.Equal(60m, result);</span></strong><span class="koboSpan" id="kobo.541.1"> as we did earlier, you’d see a failure </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
  Assert.Equal() Failure
  Expected: 60
  Actual:   </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">50</span></strong></pre>
<p><span class="koboSpan" id="kobo.545.1">This is helpful and tells the developer what </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">went wrong.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">If you </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.548.1">confused the two parameters and wrote </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">Assert.Equal(result, 60m);</span></strong><span class="koboSpan" id="kobo.550.1"> you’d get this much more </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">confusing message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
  Assert.Equal() Failure
  Expected: </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">50</span></strong><span class="koboSpan" id="kobo.554.1">
  Actual:   60</span></pre>
<p><span class="koboSpan" id="kobo.555.1">This mistake has caused a lot of confusion and hair loss for me in the past. </span><span class="koboSpan" id="kobo.555.2">Do yourself a favor and remember that the first parameter is always the value you expect the result </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">In </span><a href="B21324_09.xhtml#_idTextAnchor189"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.558.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.559.1">, </span><em class="italic"><span class="koboSpan" id="kobo.560.1">Advanced Unit Testing</span></em><span class="koboSpan" id="kobo.561.1">, we’ll introduce a cleaner way of writing assertions with</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.562.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">Shouldly</span></strong><span class="koboSpan" id="kobo.564.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.566.1"> libraries. </span><span class="koboSpan" id="kobo.566.2">For now, remember</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.567.1"> that the expected value goes first and the actual value </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">goes second.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.569.1">Other Assert methods</span></p>
<p class="callout"><span class="koboSpan" id="kobo.570.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Assert</span></strong><span class="koboSpan" id="kobo.572.1"> class </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.573.1">has more methods than just </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">Assert.Equal</span></strong><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">Assert.True</span></strong><span class="koboSpan" id="kobo.577.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Assert.False</span></strong><span class="koboSpan" id="kobo.579.1"> to verify whether a boolean condition is true or false. </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">Assert.Null</span></strong><span class="koboSpan" id="kobo.581.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Assert.NotNull</span></strong><span class="koboSpan" id="kobo.583.1"> can help verify if something is or isn’t null. </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">Assert.Contains</span></strong><span class="koboSpan" id="kobo.585.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Assert.DoesNotContain</span></strong><span class="koboSpan" id="kobo.587.1"> will verify the presence or absence of an element in a collection. </span><span class="koboSpan" id="kobo.587.2">These are just a few of the methods available through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">Assert</span></strong><span class="koboSpan" id="kobo.589.1"> class. </span><span class="koboSpan" id="kobo.589.2">For each of these messages, you can also provide a custom failure message to use when an assertion causes your test </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">to fail.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Now that we’ve added our first unit test, let’s talk specifically about what makes a test pass and what makes a </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">test fail.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.593.1">Understanding tests and exceptions</span></h2>
<p><span class="koboSpan" id="kobo.594.1">Every </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.595.1">unit </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.596.1">test that runs will pass – unless it encounters something that makes </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">it fail.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">That failure could be an </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Assert</span></strong><span class="koboSpan" id="kobo.600.1"> statement not matching the expected value, or it could be your program or test throwing an exception without </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">catching it.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">When you investigate how </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Assert</span></strong><span class="koboSpan" id="kobo.604.1"> methods are implemented, you’ll see that they all throw exceptions when their conditions aren’t met. </span><span class="koboSpan" id="kobo.604.2">When these exceptions are thrown, the test runner catches them and fails the test, displaying the failure message and stack </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">trace appropriately.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">This is why an empty test will pass even without any </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Assert</span></strong><span class="koboSpan" id="kobo.608.1"> statements, and this is why you generally never write a </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">try</span></strong><span class="koboSpan" id="kobo.610.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">catch</span></strong><span class="koboSpan" id="kobo.612.1"> block in your unit tests unless you are explicitly trying to verify some form of </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">exception-handling logic.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">Armed with this understanding of what makes a test fail, let’s write a </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">second test.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.616.1">Adding additional test methods</span></h2>
<p><span class="koboSpan" id="kobo.617.1">Just like </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.618.1">classes can have multiple methods inside of them, test classes can have multiple test methods inside of them. </span><span class="koboSpan" id="kobo.618.2">This is because unit tests are just code in every sense of the word. </span><span class="koboSpan" id="kobo.618.3">Unit tests live in classes that are ordinary in every regard, except they live in a special project type and individual unit test methods have </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">[Fact]</span></strong><span class="koboSpan" id="kobo.620.1"> just before the method </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">is declared.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">Let’s illustrate this by adding a test for the next scenario: </span><em class="italic"><span class="koboSpan" id="kobo.623.1">The first checked bag costs $40</span></em><span class="koboSpan" id="kobo.624.1">. </span><span class="koboSpan" id="kobo.624.2">Here’s what that test would </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
[Fact]
public void FirstCheckedBagShouldCostExpectedAmount() {
  // Arrange
  BaggageCalculator calculator = new();
  </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">int carryOnBags = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.628.1">  int checkedBags = 1;</span></strong><span class="koboSpan" id="kobo.629.1">
  int passengers = 1;
  bool isHoliday = false;
  // Act
  decimal result = calculator.CalculatePrice(checkedBags,
carryOnBags, passengers, isHoliday);
  // Assert
  Assert.Equal(</span><strong class="bold"><span class="koboSpan" id="kobo.630.1">40m</span></strong><span class="koboSpan" id="kobo.631.1">, result);
}</span></pre>
<p><span class="koboSpan" id="kobo.632.1">There are a lot of similarities between this test and the prior one, but the key differences are that the number of carry-on and checked bags has changed to match the new scenario we’re testing, and the expected total is now $40 instead </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">of $60.</span></span></p>
<p><span class="koboSpan" id="kobo.634.1">Each test you write should be different. </span><span class="koboSpan" id="kobo.634.2">However, if you start to notice a lot of commonalities between tests, it’s probably time to refactor your </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">unit tests.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.636.1">Refactoring unit tests</span></h1>
<p><span class="koboSpan" id="kobo.637.1">Unit tests </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.638.1">are code, and like other types of code, they can degrade in quality over time when not given proper respect and </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">proactive refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">Hence, when you see code smells such as duplicated code that appears in most of your tests, it’s a sign that your tests need to </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">be refactored.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">In this section, we’ll explore several ways of refactoring your </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">test code.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.644.1">Parameterizing tests with Theory and InlineData</span></h2>
<p><span class="koboSpan" id="kobo.645.1">When </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.646.1">we think about the similarities between our two tests, they only vary based on the values being passed into the method we’re testing and the value we expect the result </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">Thinking about our test method, this is a clear case where it’d be wonderful to have parameters that could go into one test method that could represent multiple unit tests, each testing something slightly different, but with </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">similar code.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">As you may recall from earlier, unit tests that use </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">Fact</span></strong><span class="koboSpan" id="kobo.652.1"> cannot have any parameters to them. </span><span class="koboSpan" id="kobo.652.2">However, xUnit gives us another attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Theory</span></strong><span class="koboSpan" id="kobo.654.1"> that allows us to pass data into the unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">as parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">There are multiple different ways of providing data to these parameters, but the most common way is to use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">InlineData</span></strong><span class="koboSpan" id="kobo.658.1"> attribute to provide the test parameter data next to </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">Here’s an</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.661.1"> example of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Theory</span></strong><span class="koboSpan" id="kobo.663.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">InlineData</span></strong><span class="koboSpan" id="kobo.665.1"> to test four different scenarios around baggage pricing using the same </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">test code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.667.1">[Theory]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.668.1">[InlineData(0, 0, 1, false, 0)]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.669.1">[InlineData(2, 3, 2, false, 190)]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.670.1">[InlineData(2, 1, 1, false, 100)]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.671.1">[InlineData(2, 3, 2, true, 209)]</span></strong><span class="koboSpan" id="kobo.672.1">
public void BaggageCalculatorCalculatesCorrectPrice</span><strong class="bold"><span class="koboSpan" id="kobo.673.1">(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.674.1">  int carryOnBags, int checkedBags, int passengers,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.675.1">  bool isHoliday, decimal expected)</span></strong><span class="koboSpan" id="kobo.676.1"> {
    // Arrange
    BaggageCalculator calculator = new();
    // Act
    decimal result = calculator.CalculatePrice        (</span><strong class="bold"><span class="koboSpan" id="kobo.677.1">checkedBags, carryOnBags, passengers, isHoliday</span></strong><span class="koboSpan" id="kobo.678.1">);
    // Assert
    Assert.Equal(</span><strong class="bold"><span class="koboSpan" id="kobo.679.1">expected</span></strong><span class="koboSpan" id="kobo.680.1">, result);
}</span></pre>
<p><span class="koboSpan" id="kobo.681.1">While this is only a single method, each </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">InlineData</span></strong><span class="koboSpan" id="kobo.683.1"> line represents a unique unit test and, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.684.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.685.1">.8</span></em><span class="koboSpan" id="kobo.686.1">, it will show up as an individual test in the </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">test runner:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.688.1"><img alt="Figure 6.8 – The four theory-based tests in Test Explorer grouped under a single test" src="image/B21324_06_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.689.1">Figure 6.8 – The four theory-based tests in Test Explorer grouped under a single test</span></p>
<p><span class="koboSpan" id="kobo.690.1">Although </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.691.1">using </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">Theory</span></strong><span class="koboSpan" id="kobo.693.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">Fact</span></strong><span class="koboSpan" id="kobo.695.1"> can initially be harder to read, the maintainability advantage is huge. </span><span class="koboSpan" id="kobo.695.2">First, parameterized tests have less code duplication. </span><span class="koboSpan" id="kobo.695.3">Secondly, if you need to update your tests later, you only need to update a single method instead of the many separate methods if you wrote the same tests </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Fact</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.699.1">Initializing test code with constructors and fields</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">Theory</span></strong><span class="koboSpan" id="kobo.701.1"> isn’t </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.702.1">the only way to improve your test code. </span><span class="koboSpan" id="kobo.702.2">If you find that your tests do a lot of work that is potentially sharable, you can introduce private methods to help organize your </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">For example, let’s say you wanted to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.706.1"> class from </span><a href="B21324_05.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.707.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.708.1"> and you wanted to start with testing that adding a flight to the schedule via </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">ScheduleFlight</span></strong><span class="koboSpan" id="kobo.710.1"> results in that flight showing up when </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">GetAllFlights</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.712.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">To do this, you’ve created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">FlightSchedulerTests</span></strong><span class="koboSpan" id="kobo.715.1"> class and are working on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">ScheduleFlightShouldAddFlight</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.717.1">unit test.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">As you begin to write the test, you notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">ScheduleFlight</span></strong><span class="koboSpan" id="kobo.720.1"> method requires an </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">IFlightInfo</span></strong><span class="koboSpan" id="kobo.722.1"> instance, which, in turn, needs several </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">AirportEvent</span></strong><span class="koboSpan" id="kobo.724.1"> objects. </span><span class="koboSpan" id="kobo.724.2">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">AirportEvent</span></strong><span class="koboSpan" id="kobo.726.1"> objects require their own </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Airport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1"> instances.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">These dependencies result in you writing a lot of </span><em class="italic"><span class="koboSpan" id="kobo.730.1">arrange</span></em><span class="koboSpan" id="kobo.731.1"> code to set up for </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">your test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.733.1">
[Fact]
public void ScheduleFlightShouldAddFlight() {
  // Arrange
  Airport airport1 = new() {
    Code = "DNA",
    Country = "United States",
    Name = "Dotnet Airport"
  };
  Airport airport2 = new() {
    Code = "CSI",
    Country = "United Kingdom",
    Name = "C# International Airport"
  };
  FlightScheduler scheduler = new();
  PassengerFlightInfo flight = new() {
    Id = "CS2024",
    Status = FlightStatus.OnTime,
    Departure = new AirportEvent() {
        Location = airport1,
        Time = DateTime.Now,
    },
    Arrival = new AirportEvent() {
        Location = airport2,
        Time = DateTime.Now.AddHours(2)
    }
  };</span></pre>
<p><span class="koboSpan" id="kobo.734.1">This large volume of code isn’t necessarily </span><em class="italic"><span class="koboSpan" id="kobo.735.1">bad</span></em><span class="koboSpan" id="kobo.736.1">, but it does distract from the rest of the test </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.737.1">method, which performs the scheduling and verifies that the flight </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">was added:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.739.1">
  // Act
  scheduler.ScheduleFlight(flight);
  // Assert
  IEnumerable&lt;IFlightInfo&gt; result =
    scheduler.GetAllFlights();
  Assert.NotNull(result);
  Assert.Contains(flight, result);
}</span></pre>
<p><span class="koboSpan" id="kobo.740.1">While a lengthy </span><em class="italic"><span class="koboSpan" id="kobo.741.1">arrange</span></em><span class="koboSpan" id="kobo.742.1"> section isn’t the end of the world, other tests may likely want to create their own </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.744.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">Airport</span></strong><span class="koboSpan" id="kobo.746.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">AirportEvent</span></strong><span class="koboSpan" id="kobo.748.1">, which would lead to very similar code showing up </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">between tests.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">To help improve the readability of our arrange method, we can introduce fields for the two airports and set them up in </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.752.1">
public class FlightSchedulerTests {
</span><strong class="bold"><span class="koboSpan" id="kobo.753.1">  private readonly Airport _airport1;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.754.1">  private readonly Airport _airport2;</span></strong><span class="koboSpan" id="kobo.755.1">
  public FlightSchedulerTests() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">_airport1 = new()</span></strong><span class="koboSpan" id="kobo.757.1"> {
        Code = "DNA",
        Country = "United States",
        Name = "Dotnet Airport"
    };
    </span><strong class="bold"><span class="koboSpan" id="kobo.758.1">_airport2 = new()</span></strong><span class="koboSpan" id="kobo.759.1"> {
        Code = "CSI",
        Country = "United Kingdom",
        Name = "C# International Airport"
    };
  }</span></pre>
<p><span class="koboSpan" id="kobo.760.1">When</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.761.1"> xUnit runs your test code, it will instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">FlightSchedulerTests</span></strong><span class="koboSpan" id="kobo.763.1"> class once for every unit test in that class. </span><span class="koboSpan" id="kobo.763.2">This means that any logic in the constructor or field initializers will run whenever any test in that class </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">is run.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">This lets us simplify the </span><em class="italic"><span class="koboSpan" id="kobo.766.1">arrange</span></em><span class="koboSpan" id="kobo.767.1"> section of our </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">test considerably:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.769.1">
// Arrange
FlightScheduler scheduler = new();
PassengerFlightInfo flight = new() {
    Id = "CS2024",
    Status = FlightStatus.OnTime,
    Departure = new AirportEvent() {
        </span><strong class="bold"><span class="koboSpan" id="kobo.770.1">Location = _airport1,</span></strong><span class="koboSpan" id="kobo.771.1">
        Time = DateTime.Now
    },
    Arrival = new AirportEvent() {
        Lo</span><strong class="bold"><span class="koboSpan" id="kobo.772.1">cation = _airport2,</span></strong><span class="koboSpan" id="kobo.773.1">
        Time = DateTime.Now.AddHours(2)
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.774.1">This process can be repeated as needed. </span><span class="koboSpan" id="kobo.774.2">For example, if you wanted to reuse the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.776.1"> between tests, you could add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">_flight</span></strong><span class="koboSpan" id="kobo.778.1"> field and initialize it in the constructor </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">The refactoring process isn’t about minimizing the size of the </span><em class="italic"><span class="koboSpan" id="kobo.781.1">arrange</span></em><span class="koboSpan" id="kobo.782.1"> section; it’s about keeping </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.783.1">code duplication low while keeping the important aspects of your test visible to other developers reading </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">your code.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.785.1">Sharing test code with methods</span></h2>
<p><span class="koboSpan" id="kobo.786.1">Another </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.787.1">technique you can use to keep your code focused is to extract reusable methods from your test code to help accomplish common </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.788.1">arrange</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.789.1"> tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">For example, if you wanted to test that removing a flight correctly removes the flight from the scheduler, you’d need a test that looks a lot like the test we </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">just covered.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">When you think about it, both tests don’t care much about the specifics of the flight being added – they care that when a flight is scheduled, it appears in the list of flights and that when a flight is removed, it should no longer </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">be included.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">To accomplish this, we can extract a method to create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">Flight</span></strong><span class="koboSpan" id="kobo.796.1"> object. </span><span class="koboSpan" id="kobo.796.2">This method could take in a flight identifier and return the created flight, as </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.798.1">private PassengerFlightInfo CreateFlight(string id)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.799.1">  =&gt; new()</span></strong><span class="koboSpan" id="kobo.800.1"> {
    Status = FlightStatus.OnTime,
</span><strong class="bold"><span class="koboSpan" id="kobo.801.1">    Id = id,</span></strong><span class="koboSpan" id="kobo.802.1">
    Departure = new AirportEvent() {
      Location = _airport1,
      Time = DateTime.Now
    },
    Arrival = new AirportEvent() {
      Location = _airport2,
      Time = DateTime.Now.AddHours(2)
    }
  };</span></pre>
<p><span class="koboSpan" id="kobo.803.1">Our prior test can now call this method to create </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">its flight:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.805.1">
[Fact]
public void ScheduleFlightShouldAddFlight() {
  // Arrange
  FlightScheduler scheduler = new();
  </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">PassengerFlightInfo flight = CreateFlight("CS2024");</span></strong><span class="koboSpan" id="kobo.807.1">
  // Act
  scheduler.ScheduleFlight(flight);
  // Assert
  IEnumerable&lt;IFlightInfo&gt; result =
    scheduler.GetAllFlights();
  Assert.NotNull(result);
  Assert.Contains(flight, result);
}</span></pre>
<p><span class="koboSpan" id="kobo.808.1">See how </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.809.1">much more focused this method is? </span><span class="koboSpan" id="kobo.809.2">You can quickly read it and get the intent of the test without having to focus on all the mechanics needed to create </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">the flight.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.811.1">Testing void methods</span></p>
<p class="callout"><span class="koboSpan" id="kobo.812.1">One question I often encounter is “How do you test </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">void</span></strong><span class="koboSpan" id="kobo.814.1"> methods since they don’t return anything?” </span><span class="koboSpan" id="kobo.814.2">Most of the time, when you write tests, you test the return value of a method, but with </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">void</span></strong><span class="koboSpan" id="kobo.816.1"> methods, you test the side effects of that method. </span><span class="koboSpan" id="kobo.816.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">ScheduleFlight</span></strong><span class="koboSpan" id="kobo.818.1"> test is an example of how a </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">void</span></strong><span class="koboSpan" id="kobo.820.1"> method can be tested. </span><span class="koboSpan" id="kobo.820.2">In our case, the side effect of scheduling a flight </span><em class="italic"><span class="koboSpan" id="kobo.821.1">should</span></em><span class="koboSpan" id="kobo.822.1"> be that the flight is present later when we’re getting all the flights from </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">the scheduler.</span></span></p>
<p><span class="koboSpan" id="kobo.824.1">Now, let’s look at the flight removal test, which uses the </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">same method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.826.1">
[Fact]
public void RemoveShouldRemoveFlight() {
  // Arrange
  FlightScheduler scheduler = new();
  </span><strong class="bold"><span class="koboSpan" id="kobo.827.1">PassengerFlightInfo flight = CreateFlight("CS2024");</span></strong><span class="koboSpan" id="kobo.828.1">
  scheduler.ScheduleFlight(flight);
  // Act
  scheduler.RemoveFlight(flight);
  // Assert
  IEnumerable&lt;IFlightInfo&gt; result =
    scheduler.GetAllFlights();
  Assert.NotNull(result);
  Assert.DoesNotContain(flight, result);
}</span></pre>
<p><span class="koboSpan" id="kobo.829.1">This </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.830.1">method is focused on the task of scheduling a flight and then removing it, and then verifying that the flight is no longer on the list of flights. </span><span class="koboSpan" id="kobo.830.2">If adding and removing a flight doesn’t remove it from the list of flights, that would be a bug and the test </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">would fail.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.832.1">Sharing methods between test classes</span></p>
<p class="callout"><span class="koboSpan" id="kobo.833.1">If you find that many of your test classes would benefit from the same “helper” methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">CreateFlight</span></strong><span class="koboSpan" id="kobo.835.1">, you may want to consider moving these helpers to a static class in your test project. </span><span class="koboSpan" id="kobo.835.2">This pattern is sometimes referred to as the </span><strong class="bold"><span class="koboSpan" id="kobo.836.1">ObjectMother</span></strong><span class="koboSpan" id="kobo.837.1"> or Builder pattern</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.838.1"> and is described further in the </span><em class="italic"><span class="koboSpan" id="kobo.839.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.840.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1"> section.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.842.1">Alternatively, you could introduce a base testing class, move your shared methods to that class, and then have your tests inherit from that class. </span><span class="koboSpan" id="kobo.842.2">Test classes and test projects are just like normal code and many of the refactoring tricks we used in part 1 of this book will help improve your tests </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.844.1">Before we close out this chapter with a discussion on adopting a testing mindset, let’s briefly look at a pair of other popular C# </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">testing frameworks.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.846.1">Exploring other testing frameworks</span></h1>
<p><span class="koboSpan" id="kobo.847.1">Beyond xUnit, the </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.848.1">next most popular testing frameworks are </span><strong class="bold"><span class="koboSpan" id="kobo.849.1">NUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.850.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.851.1">MSTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.853.1">These two frameworks operate in very similar ways to xUnit but with slight differences in the syntax you use to declare a </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">unit test.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">I’ve had the opportunity to program professionally and recreationally in all three major testing frameworks and I can tell you that these differences are largely cosmetic. </span><span class="koboSpan" id="kobo.855.2">That said, you will find that certain frameworks have specific features that might not be present in </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">the others.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.857.1">Testing with NUnit</span></h2>
<p><span class="koboSpan" id="kobo.858.1">Of the three</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.859.1"> testing frameworks, NUnit’s syntax is my favorite because</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.860.1"> it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">Test</span></strong><span class="koboSpan" id="kobo.862.1"> name for both unit tests that require no parameters (equivalent to an xUnit </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">Fact</span></strong><span class="koboSpan" id="kobo.864.1">) and those that do (equivalent to an </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">xUnit </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Theory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">Here’s a parameterized test that verifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">Load</span></strong><span class="koboSpan" id="kobo.870.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">PassengerFlightInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.874.1">
public class PassengerFlightTests {
</span><strong class="bold"><span class="koboSpan" id="kobo.875.1">    [TestCase(6)]</span></strong><span class="koboSpan" id="kobo.876.1">
    public void AddPassengerShouldAdd(int passengers) {
        // Arrange
        PassengerFlightInfo flight = new();
        // Act
        flight.Load(passengers);
        // Assert
        int actual = flight.Passengers;
</span><strong class="bold"><span class="koboSpan" id="kobo.877.1">        Assert.AreEqual(passengers, actual);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.878.1">        Assert.That(actual, Is.EqualTo(passengers));</span></strong><span class="koboSpan" id="kobo.879.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.880.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">NUnit</span></strong><span class="koboSpan" id="kobo.882.1">, Test and </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">TestCase</span></strong><span class="koboSpan" id="kobo.884.1"> replace Theory and </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">InlineData</span></strong><span class="koboSpan" id="kobo.886.1">. </span><span class="koboSpan" id="kobo.886.2">If this test were not parameterized, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">TestCase</span></strong><span class="koboSpan" id="kobo.888.1"> would </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">become </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">Test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.892.1">The</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.893.1"> assert section of this test is a little different. </span><span class="koboSpan" id="kobo.893.2">The first thing to note is that NUnit’s assertion method is </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">Assert.AreEqual</span></strong><span class="koboSpan" id="kobo.895.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">Assert.Equal</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">While this is a minor difference, I find that the code reads a </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">bit better.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">Below the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">Assert.AreEqual</span></strong><span class="koboSpan" id="kobo.901.1"> line is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">Assert.That</span></strong><span class="koboSpan" id="kobo.903.1"> line. </span><span class="koboSpan" id="kobo.903.2">This is NUnit’s newer constraint model of unit tests; it reads a bit more fluently and reduces your chances of confusing parameters like the expected and actual values on an assertion. </span><span class="koboSpan" id="kobo.903.3">Both ways of writing NUnit tests are valid and </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">work fine.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">One final note: in NUnit, all tests in a test class share the same class instance. </span><span class="koboSpan" id="kobo.905.2">This means that values stored in fields or properties on your tests will be shared by all tests in that test class. </span><span class="koboSpan" id="kobo.905.3">This is different from xUnit which creates a new test class instance for each test that runs. </span></p>
<p><span class="koboSpan" id="kobo.906.1">With NUnit explored, let's look </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">at MSTest.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.908.1">Testing with MSTest</span></h2>
<p><span class="koboSpan" id="kobo.909.1">MSTest’s official name was </span><strong class="bold"><span class="koboSpan" id="kobo.910.1">Visual Studio Unit Testing Framework</span></strong><span class="koboSpan" id="kobo.911.1">, but the framework </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.912.1">has come to </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.913.1">be known as </span><strong class="bold"><span class="koboSpan" id="kobo.914.1">MSTest</span></strong><span class="koboSpan" id="kobo.915.1"> throughout the community and even throughout Microsoft’s </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">internal documentation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.917.1">MSTest V2</span></p>
<p class="callout"><span class="koboSpan" id="kobo.918.1">While MSTest had a poor reputation for nearly a decade due to a lack of feature parity between it and NUnit and xUnit, Microsoft revised MSTest in 2016, calling it </span><strong class="bold"><span class="koboSpan" id="kobo.919.1">MSTest V2</span></strong><span class="koboSpan" id="kobo.920.1"> and bringing many improvements to the framework to the point where it is now on par with </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">its competitors.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">Like NUnit, MSTest </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.923.1">uses a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">TestMethod</span></strong><span class="koboSpan" id="kobo.925.1"> attribute to mark both parameterized and unparameterized unit tests. </span><span class="koboSpan" id="kobo.925.2">However, unlike both NUnit and xUnit, MSTest also requires a </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">TestClass</span></strong><span class="koboSpan" id="kobo.927.1"> attribute on the class itself to make the individual tests discoverable. </span><span class="koboSpan" id="kobo.927.2">This is something to watch out for when writing tests in MSTest as it’s another thing you can miss to make your tests not show up in the </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">test runner.</span></span></p>
<p><span class="koboSpan" id="kobo.929.1">Let’s look at a </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.930.1">sample parameterized test in MSTest that verifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">FullName</span></strong><span class="koboSpan" id="kobo.932.1"> property of</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.933.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">Passenger</span></strong><span class="koboSpan" id="kobo.935.1"> class from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">BoardingProcessor</span></strong><span class="koboSpan" id="kobo.937.1"> class from </span><a href="B21324_03.xhtml#_idTextAnchor045"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.938.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.939.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.940.1">[TestClass]</span></strong><span class="koboSpan" id="kobo.941.1">
public class PassengerTests {
</span><strong class="bold"><span class="koboSpan" id="kobo.942.1">  [TestMethod]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.943.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.944.1">[DataRow("Calvin", "Allen", "Calvin Allen")]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.945.1">  [DataRow("Matthew", "Groves", "Matthew Groves")]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.946.1">  [DataRow("Sam", "Gomez", "Sam Gomez")]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.947.1">  [DataRow("Brad", "Knowles", "Brad Knowles")]</span></strong><span class="koboSpan" id="kobo.948.1">
  public void PassengerNameShouldBeCorrect(string first,
    string last, string expected) {
    // Arrange
    Passenger passenger = new() {
      FirstName = first,
      LastName = last,
    };
    // Act
    string fullName = passenger.FullName;
    // Assert
    </span><strong class="bold"><span class="koboSpan" id="kobo.949.1">Assert.AreEqual(expected, fullName);</span></strong><span class="koboSpan" id="kobo.950.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.951.1">Here, this parameterized test evaluates the name of each of this book’s technical reviewers from </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">DataRow</span></strong><span class="koboSpan" id="kobo.953.1">, just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">InlineData</span></strong><span class="koboSpan" id="kobo.955.1"> does in xUnit or </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">TestCase</span></strong><span class="koboSpan" id="kobo.957.1"> does </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">in NUnit.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">While the MSTest syntax is different, there are many similarities between it and the other </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">test frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.961.1">The major</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.962.1"> differences between MSTest and NUnit are the inclusion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">TestClass</span></strong><span class="koboSpan" id="kobo.964.1"> attribute and the names </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">TestMethod</span></strong><span class="koboSpan" id="kobo.966.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">DataRow</span></strong><span class="koboSpan" id="kobo.968.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">Test</span></strong><span class="koboSpan" id="kobo.970.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">TestCase</span></strong><span class="koboSpan" id="kobo.972.1">, respectively. </span><span class="koboSpan" id="kobo.972.2">Even the naming of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">Assert.AreEqual</span></strong><span class="koboSpan" id="kobo.974.1"> methods are identical between the </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">two frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.976.1">Ultimately, these</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.977.1"> three testing frameworks are all very similar and serve a powerful role in your goal of high-quality software. </span><span class="koboSpan" id="kobo.977.2">I’ve found that I can work effectively in any of the three frameworks. </span><span class="koboSpan" id="kobo.977.3">While I tend to prefer NUnit’s syntax, I use xUnit in new projects because xUnit has largely become the </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">community standard.</span></span></p>
<p><span class="koboSpan" id="kobo.979.1">My recommendation is to pick the library whose syntax you like the most and use that for your projects and focus your efforts on writing good tests and adopting a </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">testing mindset.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.981.1">Adopting a testing mindset</span></h1>
<p><span class="koboSpan" id="kobo.982.1">Let’s take a </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.983.1">step back and talk about why a book on refactoring features an entire series of chapters around testing. </span><span class="koboSpan" id="kobo.983.2">The reason is that code that needs to be refactored is often a bit more volatile and tends to break more easily when changed. </span><span class="koboSpan" id="kobo.983.3">Since the art of refactoring is about changing the form of the software without changing its behavior, introducing bugs when refactoring is undesirable </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">and unacceptable.</span></span></p>
<p><span class="koboSpan" id="kobo.985.1">This is where tests come in. </span><span class="koboSpan" id="kobo.985.2">Tests give you the confidence you and your team need to be able to improve your code. </span><span class="koboSpan" id="kobo.985.3">Your legacy code may or may not have tests around it already, so the responsibility and necessity of ensuring good tests are present falls to you before you perform any </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">testing work.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">This requires you to adopt a testing mindset. </span><span class="koboSpan" id="kobo.987.2">This phrase refers to thinking about tests at the </span><em class="italic"><span class="koboSpan" id="kobo.988.1">beginning</span></em><span class="koboSpan" id="kobo.989.1"> of the development process as a vital component of software development and refactoring, not as </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">an afterthought.</span></span></p>
<p><span class="koboSpan" id="kobo.991.1">While we’ll explore this concept at length in the next chapter as we discuss </span><strong class="bold"><span class="koboSpan" id="kobo.992.1">test-driven development</span></strong><span class="koboSpan" id="kobo.993.1">, let’s touch on a few considerations that will help you be successful with tests in your organization and adopt a </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">testing mindset.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.995.1">Incorporating testing into your workflow</span></h2>
<p><span class="koboSpan" id="kobo.996.1">Testing </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.997.1">should be a standard part of your everyday life as a </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">software engineer.</span></span></p>
<p><span class="koboSpan" id="kobo.999.1">This means that you should think about testing whenever you make any change to a system, whether the change is a new feature, fixing a bug, or paying down technical debt </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">through refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">This requires a shift of mentality from seeing tests as tedious or something you ought to do to thinking of tests as things that have intrinsic value to the codebase and even to the larger organization. </span><span class="koboSpan" id="kobo.1001.2">This is because tests provide value through their role as a sort of “living documentation” of your codebase, their ability to provide a safety net against certain types of bugs in the future, and their ability to give you and the business confidence in the code </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">you’re writing.</span></span></p>
<p><span class="koboSpan" id="kobo.1003.1">You will, of course, bump into pieces of software that are significantly harder to test. </span><span class="koboSpan" id="kobo.1003.2">These might be pieces of code working with the user interface or they might be pieces of code with very strong dependencies to </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">other systems.</span></span></p>
<p><span class="koboSpan" id="kobo.1005.1">We’ll touch more on dependencies later in this section and again in </span><em class="italic"><span class="koboSpan" id="kobo.1006.1">Chapters 8</span></em><span class="koboSpan" id="kobo.1007.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1008.1">9</span></em><span class="koboSpan" id="kobo.1009.1">, but testing the user interface is typically done with specialized tools and libraries and varies based on whether you are testing a web, desktop, or mobile application. </span><span class="koboSpan" id="kobo.1009.2">As a result, user interface testing is outside the scope of this book. </span><span class="koboSpan" id="kobo.1009.3">However, isolating dependencies is usually a strong part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">that process.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.1011.1">Isolating dependencies</span></h2>
<p><span class="koboSpan" id="kobo.1012.1">When we talk </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.1013.1">about isolating dependencies, this means that when we test a piece of code, testing it shouldn’t alter </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">anything else.</span></span></p>
<p><span class="koboSpan" id="kobo.1015.1">For example, when we’re trying to verify that scheduling a flight adds the flight to the list of flights in the system, we don’t want the system to send an email with a flight confirmation every time we run our </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">unit test!</span></span></p>
<p><span class="koboSpan" id="kobo.1017.1">Such an example might look </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
public class FlightScheduler {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1020.1">private readonly EmailClient _email = new();</span></strong><span class="koboSpan" id="kobo.1021.1">
  public void ScheduleFlight(Flight flight) {
     // other logic omitted...
</span><span class="koboSpan" id="kobo.1021.2">     _</span><strong class="bold"><span class="koboSpan" id="kobo.1022.1">email.SendMessage($"Flight {flight.Id} confirmed");</span></strong><span class="koboSpan" id="kobo.1023.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1024.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.1026.1"> has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">EmailClient</span></strong><span class="koboSpan" id="kobo.1028.1"> class and calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">SendMessage</span></strong><span class="koboSpan" id="kobo.1030.1"> on the client every time a flight is scheduled. </span><span class="koboSpan" id="kobo.1030.2">This is a strong dependency from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.1032.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">EmailClient</span></strong><span class="koboSpan" id="kobo.1034.1"> class and will result in an undesirable side effect of sending emails when this code </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">is tested.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">Side effects</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.1037.1"> such as sending emails or interacting with the filesystem or a database are often undesirable in unit tests, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">discuss shortly.</span></span></p>
<p><span class="koboSpan" id="kobo.1039.1">While it’s good for systems to be able to do these things, we want to test our units of code in isolation without them having side effects we don’t like. </span><span class="koboSpan" id="kobo.1039.2">We can work around this via a process called </span><strong class="bold"><span class="koboSpan" id="kobo.1040.1">dependency injection</span></strong><span class="koboSpan" id="kobo.1041.1">, where</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.1042.1"> a class is no longer responsible for creating the dependencies it needs but gets them </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">from others.</span></span></p>
<p><span class="koboSpan" id="kobo.1044.1">A more testable version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.1046.1"> would look </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1048.1">
public class FlightScheduler {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1049.1">private readonly IEmailClient _email;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1050.1">  public FlightScheduler(IEmailClient email) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1051.1">    _email = email;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1052.1">  }</span></strong><span class="koboSpan" id="kobo.1053.1">
  public void ScheduleFlight(Flight flight) {
     // other logic omitted...
</span><span class="koboSpan" id="kobo.1053.2">     _email.SendMessage($"Flight {flight.Id} confirmed");
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1054.1">Here, the dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">EmailClient</span></strong><span class="koboSpan" id="kobo.1056.1"> class is injected into this class in its constructor and a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.1058.1"> interface is used so that we can use a different implementation of this interface for testing. </span><span class="koboSpan" id="kobo.1058.2">This test-specific version wouldn’t have the negative side effect of sending emails, making it </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">more acceptable.</span></span></p>
<p><span class="koboSpan" id="kobo.1060.1">Dependency injection</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.1061.1"> and </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.1062.1">its related terms, </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">inversion of control</span></strong><span class="koboSpan" id="kobo.1064.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1065.1">dependency inversion</span></strong><span class="koboSpan" id="kobo.1066.1">, are</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1067.1"> complex topics that take some </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1068.1">time to grasp. </span><span class="koboSpan" id="kobo.1068.2">So, we’ll revisit them in </span><a href="B21324_08.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1069.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1070.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1071.1">Avoiding Code Anti-Patterns with SOLID</span></em><span class="koboSpan" id="kobo.1072.1">. </span><span class="koboSpan" id="kobo.1072.2">Additionally, experienced testers may be crying out that a mocking framework such as Moq or NSubstitute can help with some of these concerns. </span><span class="koboSpan" id="kobo.1072.3">We’ll cover these libraries in </span><a href="B21324_07.xhtml#_idTextAnchor161"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1073.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">For now, let’s move on to talking about other factors that constitute good and </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">bad tests.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.1077.1">Evaluating good and bad tests</span></h2>
<p><span class="koboSpan" id="kobo.1078.1">Good </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1079.1">unit tests should be </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1081.1">Fast to run</span></strong><span class="koboSpan" id="kobo.1082.1">: If tests take minutes to run, developers won’t </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">run them.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1084.1">Reliable and repeatable</span></strong><span class="koboSpan" id="kobo.1085.1">: Tests shouldn’t randomly fail or pass or fail based on the day of the week, time of day, or which other tests were </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">run earlier.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1087.1">Independent from one another</span></strong><span class="koboSpan" id="kobo.1088.1">: One test should never impact another test passing or failing and tests shouldn’t need to be run in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">certain order.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1090.1">Isolated</span></strong><span class="koboSpan" id="kobo.1091.1">: They should be kept independent of dependencies such as databases, files on disk, cloud resources, or external APIs. </span><span class="koboSpan" id="kobo.1091.2">Not only do these things slow down your tests but if we’re testing these interactions, that’s an </span><em class="italic"><span class="koboSpan" id="kobo.1092.1">integration test</span></em><span class="koboSpan" id="kobo.1093.1">, not a </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">unit test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1095.1">Readable</span></strong><span class="koboSpan" id="kobo.1096.1">: Tests serve as examples of how to interact with your classes. </span><span class="koboSpan" id="kobo.1096.2">Additionally, when a test fails, its failure should be easy </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">to understand.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1098.1">Portable</span></strong><span class="koboSpan" id="kobo.1099.1">: Tests shouldn’t require significant machine setup and should be runnable on any developer’s machine or another machine as part of a </span><strong class="bold"><span class="koboSpan" id="kobo.1100.1">continuous integration/continuous delivery</span></strong><span class="koboSpan" id="kobo.1101.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1102.1">CI/CD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">) pipeline.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1104.1">In contrast, bad tests take time to run, are “flaky” and randomly fail, cannot be run in parallel or out of order, are difficult to understand regarding what they’re testing or why, and require</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1105.1"> a lot of manual configuration to </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">run reliably.</span></span></p>
<p><span class="koboSpan" id="kobo.1107.1">In general, you want to favor many small unit tests that are fast to run, easy to understand, and reliable over more ambitious tests that test too many things at once, leading to slow tests that lead to unclear and unreliable </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">test failures.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.1109.1">Thoughts on code coverage</span></h2>
<p><span class="koboSpan" id="kobo.1110.1">I can’t talk </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1111.1">about unit testing without introducing </span><strong class="bold"><span class="koboSpan" id="kobo.1112.1">code coverage</span></strong><span class="koboSpan" id="kobo.1113.1">. </span><span class="koboSpan" id="kobo.1113.2">Code coverage is</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1114.1"> the lines of code that run as part of any unit test. </span><span class="koboSpan" id="kobo.1114.2">If a test causes the line of code to run, it is considered covered; otherwise, it is considered </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">not covered.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">Several tools calculate code coverage, including Visual Studio Enterprise and JetBrains ReSharper, which we talked about briefly in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1117.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.1118.1">. </span><span class="koboSpan" id="kobo.1118.2">If you have Visual Studio Enterprise, you can calculate code coverage by selecting the </span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">Test</span></strong><span class="koboSpan" id="kobo.1120.1"> menu and then </span><strong class="bold"><span class="koboSpan" id="kobo.1121.1">Analyze Code Coverage for All Tests</span></strong><span class="koboSpan" id="kobo.1122.1">. </span><span class="koboSpan" id="kobo.1122.2">This will show the lines of code that are covered and not covered by unit tests, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1123.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1124.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.1126.1"><img alt="Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise" src="image/B21324_06_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1127.1">Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise</span></p>
<p><span class="koboSpan" id="kobo.1128.1">These coverage results will highlight any lines that are not covered by unit tests, such as the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">Unload</span></strong><span class="koboSpan" id="kobo.1130.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.1132.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1133.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1134.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.1136.1"><img alt="Figure 6.10 – Covered lines are highlighted in blue, while lines without tests are highlighted in red (line 14)" src="image/B21324_06_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1137.1">Figure 6.10 – Covered lines are highlighted in blue, while lines without tests are highlighted in red (line 14)</span></p>
<p><span class="koboSpan" id="kobo.1138.1">Code coverage is </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1139.1">one of those topics that can be divisive. </span><span class="koboSpan" id="kobo.1139.2">On</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1140.1"> the one hand, code coverage gives you a metric that shows how much of your code is executed by any test. </span><span class="koboSpan" id="kobo.1140.2">This gives you a meaningful way of measuring the extent of your unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">safety net.</span></span></p>
<p><span class="koboSpan" id="kobo.1142.1">However, code coverage can be deceptive. </span><span class="koboSpan" id="kobo.1142.2">Just running a line of code does not mean that the effects of that line are verified by a unit test. </span><span class="koboSpan" id="kobo.1142.3">This can lead to a false sense of security around your </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">Additionally, when organizations prioritize work that increases the code coverage percentage or requires a certain minimum percentage of code coverage for new work, this can lead to tests that focus on the less risky aspects of your software system. </span><span class="koboSpan" id="kobo.1144.2">For example, do you need to write a unit test to verify code that throws an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">ArgumentNullException</span></strong><span class="koboSpan" id="kobo.1146.1"> error when a null value is passed to a method, or is your time better </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">spent elsewhere?</span></span></p>
<p><span class="koboSpan" id="kobo.1148.1">Often, the most critical areas of your application may already appear to be covered by your code coverage metrics, but no tests verify that these lines </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">work correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.1150.1">My personal feeling is that code coverage is one of many useful metrics to monitor but should not be used to significantly drive the behavior of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1151.1">development teams.</span></span></p>
<p><span class="koboSpan" id="kobo.1152.1">See the </span><em class="italic"><span class="koboSpan" id="kobo.1153.1">Further reading</span></em><span class="koboSpan" id="kobo.1154.1"> section for more information on code coverage and how to get started </span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">calculating it.</span></span></p>
<p><span class="koboSpan" id="kobo.1156.1">We’ll explore other metrics in </span><a href="B21324_12.xhtml#_idTextAnchor259"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1157.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.1158.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1159.1">Code Analysis in Visual Studio</span></em><span class="koboSpan" id="kobo.1160.1">, but for now, let’s conclude this chapter with some closing thoughts on </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">unit testing.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.1162.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1163.1">Unit testing is a powerful way to verify that refactoring code does not introduce bugs, document your classes, and prevent bugs from occurring in </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.1165.1">Unit tests are code that tests other code. </span><span class="koboSpan" id="kobo.1165.2">In .NET, project unit tests are usually performed with xUnit, NUnit, or MSTest. </span><span class="koboSpan" id="kobo.1165.3">Each testing framework provides assertions that verify that code behaves correctly or fails a test if the actual value doesn’t match the </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">expected value.</span></span></p>
<p><span class="koboSpan" id="kobo.1167.1">When we write unit tests, we typically structure our tests in the </span><em class="italic"><span class="koboSpan" id="kobo.1168.1">arrange</span></em><span class="koboSpan" id="kobo.1169.1">/</span><em class="italic"><span class="koboSpan" id="kobo.1170.1">act</span></em><span class="koboSpan" id="kobo.1171.1">/</span><em class="italic"><span class="koboSpan" id="kobo.1172.1">assert</span></em><span class="koboSpan" id="kobo.1173.1"> pattern, which sets up the thing being tested in the </span><em class="italic"><span class="koboSpan" id="kobo.1174.1">arrange</span></em><span class="koboSpan" id="kobo.1175.1"> step, does a single action in the </span><em class="italic"><span class="koboSpan" id="kobo.1176.1">act</span></em><span class="koboSpan" id="kobo.1177.1"> step, and verifies the correctness of the action’s result in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1178.1">assert</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1"> step.</span></span></p>
<p><span class="koboSpan" id="kobo.1180.1">In the next chapter, we’ll explore testing more with </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">test-driven development.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1182.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1183.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1185.1">Which unit testing framework syntax do you like </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">the most?</span></span></li>
<li><span class="koboSpan" id="kobo.1187.1">What are the most complex parts of your application? </span><span class="koboSpan" id="kobo.1187.2">Are </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">they tested?</span></span></li>
<li><span class="koboSpan" id="kobo.1189.1">How would you test a method that calculates the credit score of </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">an applicant?</span></span></li>
<li><span class="koboSpan" id="kobo.1191.1">How do you test a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">void</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1"> method?</span></span></li>
<li><span class="koboSpan" id="kobo.1194.1">What things can you do to help test code stay clean </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">and readable?</span></span></li>
</ol>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.1196.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1197.1">You can find more information about the materials discussed in this chapter by checking out the </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1199.1">Types of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1200.1">Tests</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/core/testing/"><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">https://learn.microsoft.com/en-us/dotnet/core/testing/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1203.1">Visual Studio Test </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1204.1">Explorer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">: </span></span><a href="https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer"><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1207.1">xUnit</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">: </span></span><a href="https://xunit.net/"><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">https://xunit.net/</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1210.1">NUnit</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">: </span></span><a href="https://nunit.org/"><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">https://nunit.org/</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1213.1">MSTest</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest"><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1216.1">The ObjectMother </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1217.1">Pattern</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">: </span></span><a href="https://www.martinfowler.com/bliki/ObjectMother.html"><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">https://www.martinfowler.com/bliki/ObjectMother.html</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1220.1">Code </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1221.1">Coverage</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">: </span></span><a href="https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested"><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested</span></span></a></li>
</ul>
</div>
</body></html>