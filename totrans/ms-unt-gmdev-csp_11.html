<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"/>7</h1>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor113" class="calibre6 pcalibre1 pcalibre"/>Contributing to Existing Code Bases in Unity with C#</h1>
<p class="calibre3">Welcome to <a href="B22017_07.xhtml#_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 7</em></a>. This chapter will equip you with essential collaboration skills for working in development teams using C#. We will explore <strong class="bold">version control systems</strong> (<strong class="bold">VCSs</strong>), code merging, and conflict resolution for seamless teamwork. We will also cover mastering <a id="_idIndexMarker432" class="calibre6 pcalibre1 pcalibre"/>version control, collaborating with shared repositories, and resolving conflicts using C#. Finally, we will get an understanding of existing code bases to navigate structures, review documentation, and communicate effectively. Mastering all these skills will promote effective team contribution and maintain code quality in Unity projects.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Introducing VCSs</li>
<li class="calibre11">Collaborating and resolving conflicts with C#</li>
<li class="calibre11">Understanding existing code bases</li>
</ul>
<h1 id="_idParaDest-110" class="calibre5"><a id="_idTextAnchor114" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You will need the following to follow this chapter:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Primary IDE - Visual Studio 2022</strong>: The tutorials and code samples are crafted using Visual Studio 2022. Ensure it’s installed to follow along seamlessly. Feel free to explore Rider or other IDEs if you prefer, though instructions are tailored for Visual Studio.</li>
<li class="calibre11"><strong class="bold">GitHub Desktop</strong>: Ensure it’s installed to follow along seamlessly.</li>
</ul>
<h1 id="_idParaDest-111" class="calibre5"><a id="_idTextAnchor115" class="calibre6 pcalibre1 pcalibre"/>Introducing VCSs</h1>
<p class="calibre3">A VCS is a tool <a id="_idIndexMarker433" class="calibre6 pcalibre1 pcalibre"/>used in software development to manage changes to files. It acts like a detailed record keeper, documenting every alteration made to project files.</p>
<p class="calibre3">Here’s why it matters:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Tracking changes</strong>: In a collaborative project, multiple people may work on the same files. A VCS records all modifications, ensuring transparency and accountability.</li>
<li class="calibre11"><strong class="bold">Facilitating collaboration</strong>: With a VCS, team members can see who made specific changes and when. This transparency fosters smooth collaboration and prevents conflicts.</li>
<li class="calibre11"><strong class="bold">Reverting changes</strong>: Mistakes happen, but a VCS allows us to revert to earlier versions of files if needed. It acts as a safety net, providing a way to undo errors.</li>
<li class="calibre11"><strong class="bold">Maintaining organization</strong>: A VCS helps maintain orderliness by categorizing changes and providing a structured approach to managing project files. It enables teams to work efficiently and stay organized.</li>
</ul>
<p class="calibre3">In conclusion, a VCS is a crucial tool for software development teams. It helps keep track of changes, encourages teamwork, allows for fixing mistakes, and ensures that projects stay organized.</p>
<p class="calibre3">In the upcoming section, we will delve into understanding VCSs, exploring the two main types: distributed and centralized systems.</p>
<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor116" class="calibre6 pcalibre1 pcalibre"/>Understanding VCSs</h2>
<p class="calibre3">When you create a new repository in your VCS, you open up the main branch. This is also known as the trunk master. The trunk master serves as the starting point for the main code base, which then goes through compilation and deployment to reach the end user.</p>
<p class="calibre3">But what about branches? Branching occurs when code is extracted from the master branch to create separate paths. This allows us to modify the code without impacting the main version directly. By using branches, we avoid the need to consolidate all changes in one place; instead, we can track modifications to our code over time. The VCS can then integrate these separate branches back into the main one. If we’re not prepared to merge other changes into the main branch, we can store them in a separate branch and merge them later.</p>
<p class="calibre3">Having a good <a id="_idIndexMarker434" class="calibre6 pcalibre1 pcalibre"/>branching strategy is important to prevent conflicts and errors in the code. Luckily, robust VCSs make it easy for teams to sync with the main branch and resolve any potential conflicts – even after changes have been made to the main branch.</p>
<p class="calibre3">Now that we’ve grasped the fundamental workings of VCSs, let’s explore the two primary types that play a pivotal role in shaping collaborative development processes: distributed and centralized systems.</p>
<h3 class="calibre9">Distributed VCSs</h3>
<p class="calibre3">A <strong class="bold">distributed VCS</strong>, or <strong class="bold">DVCS</strong>, is a<a id="_idIndexMarker435" class="calibre6 pcalibre1 pcalibre"/> type of VCS <a id="_idIndexMarker436" class="calibre6 pcalibre1 pcalibre"/>where every user has a complete copy of the project’s repository on their local computer. This means that you can work on the project even when they’re offline.</p>
<p class="calibre3">The following diagram shows the<a id="_idIndexMarker437" class="calibre6 pcalibre1 pcalibre"/> structure of a DVCS:</p>
<div><div><img alt="Figure 7.1 – DVCS structure" src="img/B22017_07_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – DVCS structure</p>
<p class="calibre3">Here’s how it works:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Local copies</strong>: With<a id="_idIndexMarker438" class="calibre6 pcalibre1 pcalibre"/> a DVCS, each user has their own local copy of the entire project’s history, including all files and changes made over time. This allows you to work independently and make changes without relying on a central server.</li>
<li class="calibre11"><strong class="bold">Flexible collaboration</strong>: Since each user has their own copy of the repository, they can work on different features or fixes without interfering with each other’s work. They can commit changes to their local repository and share them with others later.</li>
<li class="calibre11"><strong class="bold">Enhanced security</strong>: Because <a id="_idIndexMarker439" class="calibre6 pcalibre1 pcalibre"/>the entire project history is stored locally, a DVCS provides redundancy and security. Even if the central server goes down, you can continue working on your local copies and later sync changes with the central repository once it’s back online.</li>
<li class="calibre11"><strong class="bold">Efficient branching and merging</strong>: DVCS systems such as <strong class="bold">Git</strong> offer powerful branching and merging capabilities. You can create branches to work on new features or experiment with changes without affecting the main project. You can later merge your changes back into the main branch when ready.</li>
</ul>
<p class="calibre3">Git is an example <a id="_idIndexMarker440" class="calibre6 pcalibre1 pcalibre"/>of a DVCS. It allows users to maintain their own complete copy of the project’s repository on their local computer. This means that you have access to the entire project history and can work on it even when you’re offline.</p>
<p class="calibre3">With Git, you can create branches to work on new features or fixes without affecting the main code base. These branches can later be merged back into the main branch once your changes are complete.</p>
<p class="calibre3">Git also facilitates collaboration among team members by allowing you to share your changes with others through a shared remote repository. Other team members can then pull your changes from the remote repository to their local copies.</p>
<p class="calibre3">Overall, Git’s distributed nature and powerful branching capabilities make it a preferred choice for many development teams. It provides flexibility, efficiency, and seamless collaboration for managing and tracking changes in software projects.</p>
<p class="calibre3">In summary, a DVCS allows us to work independently, collaborate effectively, and maintain project history and integrity, even in decentralized environments. It provides flexibility, security, and powerful features for managing and tracking changes in software projects.</p>
<h3 class="calibre9">Centralized VCSs</h3>
<p class="calibre3">A <strong class="bold">centralized VCS</strong> (<strong class="bold">CVCS</strong>) is a<a id="_idIndexMarker441" class="calibre6 pcalibre1 pcalibre"/> type of VCS where<a id="_idIndexMarker442" class="calibre6 pcalibre1 pcalibre"/> there is a single central repository that stores all files and their respective versions.</p>
<p class="calibre3">The following diagram<a id="_idIndexMarker443" class="calibre6 pcalibre1 pcalibre"/> shows the structure of a CVCS:</p>
<div><div><img alt="Figure 7.2 – CVCS structure" src="img/B22017_07_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – CVCS structure</p>
<p class="calibre3">Here’s how <a id="_idIndexMarker444" class="calibre6 pcalibre1 pcalibre"/>it works:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Single repository</strong>: In a CVCS, all users access and work on the same central repository. This means that there is only one copy of the project’s history, stored on a central server.</li>
<li class="calibre11"><strong class="bold">Limited offline access</strong>: Since the repository is centralized, users typically need to be connected to the central server to access files and make changes. This can limit the ability to work offline or in environments with limited connectivity.</li>
<li class="calibre11"><strong class="bold">Collaborative workflow</strong>: Users commit their changes directly to the central repository, where they are visible to all team members. This facilitates collaboration<a id="_idIndexMarker445" class="calibre6 pcalibre1 pcalibre"/> and ensures that everyone is working with the latest version of the code.</li>
<li class="calibre11"><strong class="bold">Potential bottlenecks</strong>: In a CVCS, the central server can become a bottleneck, especially in large <a id="_idIndexMarker446" class="calibre6 pcalibre1 pcalibre"/>teams or projects with heavy usage. If the server goes down, developers may be unable to access or commit changes until it is restored.</li>
<li class="calibre11"><strong class="bold">Limited branching</strong>: CVCS systems typically offer limited branching capabilities compared to distributed systems such as Git. Users may need to coordinate closely to avoid conflicts when working on different features or changes.</li>
</ul>
<p class="calibre3"><strong class="bold">SVN</strong>, or <strong class="bold">Subversion</strong>, is an <a id="_idIndexMarker447" class="calibre6 pcalibre1 pcalibre"/>example of a CVCS. In SVN, there is a single central repository that stores all project files and their respective versions.</p>
<p class="calibre3">Unlike DVCSs such as Git, SVN does not provide users with their own local copies of the entire project’s history. Instead, users interact directly with the central repository to access files and make changes.</p>
<p class="calibre3">SVN facilitates a collaborative workflow by allowing developers to commit their changes directly to the central repository. This ensures that everyone is working with the latest version of the code and helps maintain project integrity.</p>
<p class="calibre3">While SVN lacks some of the flexibility and offline capabilities of DVCSs, it remains a popular choice for many development teams, especially in centralized environments where strict control over the code base is desired.</p>
<p class="calibre3">In summary, a CVCS relies on a single central repository for storing and managing project files and versions. While it facilitates collaboration and provides a centralized <strong class="bold">source of truth</strong> (<strong class="bold">SoT</strong>), it <a id="_idIndexMarker448" class="calibre6 pcalibre1 pcalibre"/>may pose challenges in terms of offline access, potential bottlenecks, and limited branching capabilities.</p>
<p class="calibre3">Next, let’s delve into essential Git commands.</p>
<p class="calibre3">In the following table, you’ll <a id="_idIndexMarker449" class="calibre6 pcalibre1 pcalibre"/>find essential Git commands. Make sure you have Git installed on your system:</p>
<table class="no-table-style" id="table001-2">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Command</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git init</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Initializes a new Git repository in the current directory</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git clone [url]</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Clones an existing Git repository from a remote server to your local machine</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git add [file]</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Adds a file or changes to the staging area to be included in the next commit</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git commit -m "[message]"</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Commits changes to the local repository with a descriptive message</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git push</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Uploads local repository content to a remote repository</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git <a id="_idTextAnchor117" class="calibre6 pcalibre1 pcalibre"/>pull</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Downloads changes from a remote repository and merges them into the local repository</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git status</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Displays the status of the working directory and the staging area</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git log</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Shows a list of commits in the repository, along with details such as author, date, and commit message</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git branch</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Lists all branches in the local repository</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git checkout [branch]</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Switches to the specified branch</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="img---caption" lang="en-US" xml:lang="en-US"><strong class="source-inline1">git merge [branch]</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Merges changes from the specified branch into the current branch</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>git <a id="_idTextAnchor118" class="calibre6 pcalibre1 pcalibre"/></code><code>remote -v</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Lists all remote repositories associated with the local repository</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3">Many commands may be overwhelming, especially considering our book’s context. Instead, we’ll rely<a id="_idIndexMarker450" class="calibre6 pcalibre1 pcalibre"/> on <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) tools such as the GitHub Desktop app for version control, where most actions can be performed through <a id="_idIndexMarker451" class="calibre6 pcalibre1 pcalibre"/>the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). Feel free to depend on the GUI for all processes.</p>
<p class="calibre3">In the next section, we will explore best practices for collaborating on code and resolving conflicts efficiently.</p>
<h1 id="_idParaDest-113" class="calibre5"><a id="_idTextAnchor119" class="calibre6 pcalibre1 pcalibre"/>Collaborating and resolving conflicts with C#</h1>
<p class="calibre3">Navigating collaborative environments and maintaining code quality are vital aspects of software development. Let’s explore effective collaboration, conflict resolution, and code quality maintenance in the following sections.</p>
<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor120" class="calibre6 pcalibre1 pcalibre"/>Best practices for collaborating</h2>
<p class="calibre3">Effective<a id="_idIndexMarker452" class="calibre6 pcalibre1 pcalibre"/> collaboration is essential for successful project development, and adopting best practices ensures smooth teamwork and code management throughout the process. The following are some best practices to follow when working with VCSs:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Frequent and incremental commits for a streamlined workflow</strong>: Making small, frequent commits is an uncomplicated yet highly effective enhancement for your workflow, even though it poses a challenge for some developers. In the context of other project management tools, where tasks are typically broken down into manageable parts, the same approach should be applied to commits. Each commit should specifically correspond to one task or ticket unless a single line of code miraculously addresses multiple issues. For more extensive features, it’s beneficial to break them down into smaller tasks and create commits for each one. The primary advantage of opting for smaller commits is the increased ease of detecting and reverting undesired changes in case something goes wrong.</li>
<li class="calibre11"><strong class="bold">Prioritize getting the latest changes</strong>: Make it a habit to fetch the latest changes <a id="_idIndexMarker453" class="calibre6 pcalibre1 pcalibre"/>from the repository into your working copy whenever it’s feasible. It’s not advisable to work in isolation as this raises the risk of encountering merge conflicts.</li>
<li class="calibre11"><strong class="bold">Mindful committing for a smooth workflow</strong>: Refrain from making hasty commits. The <strong class="source-inline1">commit -a</strong> command, or its equivalents, should only be employed during the initial commit of a project, typically when the project consists solely of <strong class="source-inline1">README.md</strong> files. A commit should exclusively encompass files pertinent to the specific change being committed to the repository. Exercise caution, especially when dealing with Unity projects, as certain modifications may inadvertently affect multiple files, such as scenes, Prefabs, or Sprite Atlases, even if not intended. Accidentally committing changes to a scene that another team member is concurrently editing can lead to complications for them during their own commit process, necessitating the merging of your changes beforehand.</li>
<li class="calibre11"><strong class="bold">Crafting clear commit messages</strong>: Maintain clarity in your commit messages as they narrate the evolution of your project. It’s more convenient to trace the addition of new gameplay mechanics in your game when the commit message explicitly states, “<strong class="source-inline1">implemented new enemy behavior for level 3" rather than opting for a more casual expression such as, "added some cool stuff to level 3</strong>.” When utilizing a task ticketing system such as Jira or GitLab, it’s advantageous to include a ticket number in your commit message. Many systems can be configured to integrate with smart commits, enabling you to reference tickets and update their status directly from your commit message. For instance, a commit message such as “<strong class="source-inline1">JRA-123 #close #comment task completed</strong>” would close the JRA-123 Jira ticket and append the comment “task completed” to the ticket.</li>
</ul>
<p class="calibre3">In the realm of collaborative coding, mastering these best practices not only fosters seamless teamwork but also streamlines code management throughout project development.</p>
<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor121" class="calibre6 pcalibre1 pcalibre"/>Mastering branching and merging in collaboration</h2>
<p class="calibre3">Understanding <a id="_idIndexMarker454" class="calibre6 pcalibre1 pcalibre"/>branching and merging strategies for collaborative development is crucial for effective teamwork in software projects. Next <a id="_idIndexMarker455" class="calibre6 pcalibre1 pcalibre"/>are some ideas and guidelines to assist you with this.</p>
<p class="calibre3">The following are some crafting branching and merging strategies:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Feature branches</strong>: Work on new features or fixes in separate branches. This practice maintains the cleanliness of the main branch while enabling us to work independently.</li>
<li class="calibre11"><strong class="bold">Release branches</strong>: Create branches specifically for release candidates to stabilize the code base before deployment.</li>
<li class="calibre11"><strong class="bold">Hotfix branches</strong>: Establish branches to address critical issues or bugs in production without disrupting ongoing development.</li>
<li class="calibre11"><strong class="bold">Long-lived branches</strong>: Some projects may require long-lived branches for ongoing development efforts or specific feature sets.</li>
</ul>
<p class="calibre3">Exploring branches, forks, and pull requests offers valuable insights into the intricacies of collaborative coding and VCSs:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Branches</strong>: Create feature branches for each new task or feature you work on. This keeps changes isolated and makes it easier to review and merge code.</li>
<li class="calibre11"><strong class="bold">Forks</strong>: In open source projects, contributors often fork the main repository to work on changes independently. Forks allow for experimentation without affecting the original code base.</li>
<li class="calibre11"><strong class="bold">Pull requests</strong>: Pull requests (or merge requests) are a key mechanism for proposing changes and initiating code review. They provide a structured way to discuss and approve modifications before merging them into the main branch.</li>
<li class="calibre11"><strong class="bold">Code reviews</strong>: Emphasize the importance of thorough code reviews in the pull request process. Reviewing code helps maintain code quality, identify potential issues, and share knowledge among team members.</li>
</ul>
<p class="calibre3">Encouraging a clear branching and merging strategy, along with effective use of branches, forks, and pull requests, promotes collaboration, code quality, and project stability in software development teams.</p>
<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor122" class="calibre6 pcalibre1 pcalibre"/>Mastering code conflict management</h2>
<p class="calibre3">Understanding<a id="_idIndexMarker456" class="calibre6 pcalibre1 pcalibre"/> the nature of code conflicts and how to resolve them is essential for seamless collaboration and project success. Let’s delve into common types of conflicts and learn practical techniques for resolving them in Unity projects.</p>
<h3 class="calibre9">Exploring code conflict origins and navigating conflict resolution in Unity projects</h3>
<p class="calibre3">Understanding <a id="_idIndexMarker457" class="calibre6 pcalibre1 pcalibre"/>the origins of code conflicts is crucial for maintaining a harmonious development environment<a id="_idIndexMarker458" class="calibre6 pcalibre1 pcalibre"/> and ensuring smooth collaboration among team members, Let’s delve into specific points that contribute to these conflicts:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Merge conflicts</strong>: When multiple contributors modify the same file or code block, conflicting changes can arise during merging</li>
<li class="calibre11"><strong class="bold">Structural changes</strong>: Renaming files, relocating directories, or altering project structures can introduce conflicts</li>
<li class="calibre11"><strong class="bold">Dependency dilemmas</strong>: Incompatible dependencies or divergent library versions across project components can lead to conflicts</li>
<li class="calibre11"><strong class="bold">Branch divergence</strong>: Significant deviations from the main branch make merging changes back into the main code base challenging</li>
</ul>
<p class="calibre3">Next, we’ll explore two methods to resolve conflicts:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Manual conflict resolution</strong>: Learn to review conflicting changes in code files and decide which modifications to retain, modify, or discard</li>
<li class="calibre11"><strong class="bold">Version control integration</strong>: Explore<a id="_idIndexMarker459" class="calibre6 pcalibre1 pcalibre"/> how Git and other VCSs integrate with Unity, offering built-in merge tools and third-party plugins for conflict resolution</li>
</ul>
<p class="calibre3">Next, let’s engage in practical conflict resolution.</p>
<h3 class="calibre9">Practical conflict solving</h3>
<p class="calibre3">After <a id="_idIndexMarker460" class="calibre6 pcalibre1 pcalibre"/>understanding the causes of conflicts, it’s essential to learn how to resolve them. I’ll share an example of a conflict from one of my current projects and how I successfully resolved it. While the conflict wasn’t significant, the approach used for resolving code conflicts applies universally. Let’s proceed with resolving code conflicts using GitHub Desktop and Visual Studio.</p>
<p class="calibre3">When your local changes conflict with modifications made to the same file on the remote server, the following panel will be displayed:</p>
<div><div><img alt="Figure 7.3 – Resolve conflict panel in GitHub Desktop" src="img/B22017_07_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Resolve conflict panel in GitHub Desktop</p>
<p class="calibre3">When this panel appears, it signals the need to compare and decide between conflicting versions of the same file from different sources. In GitHub Desktop, this panel represents the conflict resolution interface. By clicking the drop-down button, you can select your <a id="_idIndexMarker461" class="calibre6 pcalibre1 pcalibre"/>preferred editing program, such as Visual Studio or Visual Studio Code. For this example, when you select Visual Studio as the default program, the editor will open. You can choose to click on the <strong class="bold">Open Merge Editor</strong> option, as illustrated in the following figure:</p>
<div><div><img alt="Figure 7.4 – Conflict mode in Visual Studio" src="img/B22017_07_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Conflict mode in Visual Studio</p>
<p class="calibre3">In the Merge Editor, you’ll notice there are three sections: the incoming or remote version, the current or local version, and the resulting file after merging. Here, you need to review the changes and decide whether to combine them or keep one version based on the flow of the feature or task requirements. Once you or the responsible senior has finished editing, click on <strong class="bold">Accept Merge</strong>:</p>
<div><div><img alt="Figure 7.5 – Merge Editor in Visual Studio" src="img/B22017_07_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Merge Editor in Visual Studio</p>
<p class="calibre3">After <a id="_idIndexMarker462" class="calibre6 pcalibre1 pcalibre"/>closing the Merge Editor, you’ll notice that the sidebar now includes an option to commit the changes. Then, you can click on <strong class="bold">Commit Staged</strong> in the side panel to push the changes after the merge, as you can see in the following figure:</p>
<div><div><img alt="Figure 7.6 – File after editing the conflict" src="img/B22017_07_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.6 – File after editing the conflict</p>
<p class="callout-heading">Remember</p>
<p class="callout">You’ll need to focus, especially when the same file is involved in two different tasks, ensuring that the logic of both tasks continues to work properly.</p>
<p class="calibre3">Let’s use the <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) to resolve merge conflicts efficiently.</p>
<h3 class="calibre9">Exploring code conflict origins and navigating conflict resolution using the CLI</h3>
<p class="calibre3">The CLI remains<a id="_idIndexMarker463" class="calibre6 pcalibre1 pcalibre"/> a fundamental and widely used method for resolving Git conflicts. While GUIs are available and can provide visual aids for conflict resolution, many developers, particularly those comfortable with terminal-based workflows, prefer the command line as their default approach. The CLI offers granular control, precise navigation through code changes, and efficient merging capabilities, making it a robust tool for managing Git conflicts effectively.</p>
<p class="calibre3">To test this, ensure<a id="_idIndexMarker464" class="calibre6 pcalibre1 pcalibre"/> you have another branch in your project. We will then modify the same file in the two branches to create a conflict and resolve it. Let’s get started:</p>
<ol class="calibre15">
<li class="calibre11">Navigate to your project directory and open the terminal there, or use the <strong class="source-inline1">cd</strong> command in the terminal to navigate to your project directory.</li>
<li class="calibre11">Alternatively, ensure that you are currently in one of your other branches. In my case, I have a branch called <strong class="source-inline1">feature/branch-name</strong>.</li>
<li class="calibre11">Use the <strong class="source-inline1">git checkout branch-name</strong> command to switch to the desired branch, as demonstrated in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.7 – Checkout feature branch" src="img/B22017_07_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Checkout feature branch</p>
<ol class="calibre15">
<li value="4" class="calibre11">Now, let’s make a modification to a file. In my case, I’ll comment out a line in a script, as shown in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.8 – Commenting out a line in a function" src="img/B22017_07_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Commenting out a line in a function</p>
<ol class="calibre15">
<li value="5" class="calibre11">We need to add and commit that file using <strong class="source-inline1">git add filename</strong> followed by <strong class="source-inline1">git commit -m "commit message"</strong>, as you can see in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.9 – Committing changes" src="img/B22017_07_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Committing changes</p>
<ol class="calibre15">
<li value="6" class="calibre11">Push your changes:</li>
</ol>
<div><div><img alt="Figure 7.10 – Pushing changes" src="img/B22017_07_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Pushing changes</p>
<ol class="calibre15">
<li value="7" class="calibre11">Now, we<a id="_idIndexMarker465" class="calibre6 pcalibre1 pcalibre"/> can go to another branch; in my case, I will return to the main branch using the <strong class="source-inline1">git </strong><strong class="source-inline1">checkout</strong> command:</li>
</ol>
<div><div><img alt="Figure 7.11 – Returning to the main branch" src="img/B22017_07_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Returning to the main branch</p>
<ol class="calibre15">
<li value="8" class="calibre11">Modify the same file to make a conflict, then we need to add, commit, and push changes.</li>
<li class="calibre11">Then, return to the feature branch again.</li>
<li class="calibre11">Next, execute the <strong class="source-inline1">merge</strong> command from the main branch, as illustrated in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.12 – Merging from the main branch" src="img/B22017_07_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Merging from the main branch</p>
<p class="calibre3">We can also use the <code>git status</code> command to identify the file or files that require conflict resolution:</p>
<div><div><img alt="Figure 7.13 – Checking conflict files" src="img/B22017_07_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Checking conflict files</p>
<ol class="calibre15">
<li value="11" class="calibre11">Open<a id="_idIndexMarker466" class="calibre6 pcalibre1 pcalibre"/> the file in the editor to resolve the conflict, as illustrated in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.14 – Conflict code" src="img/B22017_07_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Conflict code</p>
<ol class="calibre15">
<li value="12" class="calibre11">After making the necessary edits, add and commit the file:</li>
</ol>
<div><div><img alt="Figure 7.15 – Commit after solving the conflict" src="img/B22017_07_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Commit after solving the conflict</p>
<ol class="calibre15">
<li value="13" class="calibre11">Use <strong class="source-inline1">git status</strong> to ensure everything is clear:</li>
</ol>
<div><div><img alt="Figure 7.16 – Checking status" src="img/B22017_07_16.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Checking status</p>
<ol class="calibre15">
<li value="14" class="calibre11">Now, push the branch after resolving the conflict:</li>
</ol>
<div><div><img alt="Figure 7.17 – Pushing the feature branch" src="img/B22017_07_17.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Pushing the feature branch</p>
<p class="calibre3">By using <a id="_idIndexMarker467" class="calibre6 pcalibre1 pcalibre"/>the CLI, we can efficiently resolve conflicts in Git repositories by navigating to the project directory, switching to the branch containing the conflict, modifying the conflicting file, adding and committing the changes, pushing the branch, and finally merging the changes with the main branch.</p>
<p class="calibre3">In summary, mastering code conflict management involves understanding conflict origins and resolution techniques. In this section, we explored common conflict types such as merge conflicts and structural changes, and we delved into practical conflict resolution methods using tools such as GitHub Desktop, Visual Studio, and the CLI. By learning to navigate conflicts effectively, we ensure smooth collaboration and project success in Unity projects.</p>
<p class="calibre3">In the upcoming section, we will explore how to effectively work with existing projects, providing instructions and a practical example for guidance.</p>
<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor123" class="calibre6 pcalibre1 pcalibre"/>Understanding existing code bases</h1>
<p class="calibre3">When delving<a id="_idIndexMarker468" class="calibre6 pcalibre1 pcalibre"/> into an existing code base, there are key steps to take to familiarize yourself with its structure and functionality:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Project structure and organization</strong>: Begin by exploring the project’s directory structure and organization. Understand how files and folders are arranged and grouped according to functionality or modules.</li>
<li class="calibre11"><strong class="bold">Review documentation</strong>: Look for any available documentation, including README files, wiki pages, or inline comments within the code. Documentation can provide valuable insights into the project’s purpose, architecture, and design decisions.</li>
<li class="calibre11"><strong class="bold">Identify key components and relationships</strong>: Identify key components, modules, and<a id="_idIndexMarker469" class="calibre6 pcalibre1 pcalibre"/> their relationships within the code base. Determine how different parts of the code interact with each other and understand the overall architecture.</li>
<li class="calibre11"><strong class="bold">Utilize code analysis tools and integrated development environment (IDE) features</strong>: Make use of code analysis tools and features provided by your IDE to explore code dependencies, inheritance hierarchies, and function calls. Tools such as static code analyzers can help identify potential issues or areas for improvement.</li>
<li class="calibre11"><strong class="bold">Understand coding standards and conventions</strong>: Familiarize yourself with coding standards and conventions used in the project. Pay attention to naming conventions, code formatting, and documentation practices to ensure consistency across the code base.</li>
<li class="calibre11"><strong class="bold">Communicate with team members</strong>: Engage with team members or project leads to gain insights into the code base and its design decisions. Discuss any questions or uncertainties you have and leverage their expertise to deepen your understanding.</li>
</ul>
<p class="calibre3">Beginning work on an existing project demands time and dedication to grasp its complexities. Yet, this initial exploration establishes a base for fruitful contributions, ensuring the project’s durability and ease of maintenance. As you familiarize yourself with the code base, you’ll gain the ability to suggest improvements, tackle problems, and engage in effective collaboration with the project team.</p>
<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor124" class="calibre6 pcalibre1 pcalibre"/>Practical exploration for the existing code base</h2>
<p class="calibre3">We’ll illustrate<a id="_idIndexMarker470" class="calibre6 pcalibre1 pcalibre"/> the code review process with an example, either after following the preceding steps or by considering these steps beforehand.</p>
<p class="calibre3">If you’re assigned a task in a new project, you can either proceed independently following these steps, seek guidance from your senior or leader if needed, or check if there’s a similar approach already implemented in the game.</p>
<p class="calibre3">My preferred method is to begin at the end and work backward to the source. For example, if you’re dealing with UI logic, start by examining the button’s onclick action to determine which function it calls. Then, navigate to that script to review the function.</p>
<p class="calibre3">Then, you can examine the logic and check for additional calls to other scripts. Continue this process until you reach the core of the logic. Sometimes, a function may involve numerous calls to other scripts, so review them one by one to comprehend how they interact. This process enhances your understanding of the project. If the logic involves managers, you’ll grasp their responsibilities. Consequently, when you tackle tasks related to these managers in the future, you’ll be better equipped to understand and connect the logic effectively.</p>
<p class="calibre3">If you’re assigned a new task and realize the manager, such as one handling player or game data, lacks a necessary function, you can simply append a new function to that manager. This approach allows you to expand the manager’s capabilities to accommodate your requirements seamlessly.</p>
<p class="calibre3">When collaborating with a third party, it’s beneficial to examine example scenes or scripts to grasp their functionality. By experimenting with and modifying these examples, you can gain insights into their usage and adapt them for your own features, focusing only on the essential logic needed for your project.</p>
<p class="calibre3">Now, let’s see an example we will follow to see how we can understand the existing code base.</p>
<p class="calibre3"><strong class="bold">Example</strong>:</p>
<p class="calibre3">I’m currently examining the sound toggle function in the <code>SettingsView</code> script, which handles muting or unmuting the sound effects in another project I’m involved in:</p>
<ol class="calibre15">
<li class="calibre11">I begin by navigating to the <strong class="source-inline1">SettingsView</strong> script in the hierarchy and locating the toggle button.</li>
<li class="calibre11">Then, I examine the action triggered when the value changes and identify the associated function or functions. Additionally, it’s important to verify if the toggle is<a id="_idIndexMarker471" class="calibre6 pcalibre1 pcalibre"/> referenced in the view script and if the function is attached through code. As illustrated in the following figure, the function can be found in the <strong class="bold">Inspector</strong>:</li>
</ol>
<div><div><img alt="Figure 7.18 – SoundToggle component" src="img/B22017_07_18.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.18 – SoundToggle component</p>
<ol class="calibre15">
<li value="3" class="calibre11">Next, we should navigate to the <strong class="source-inline1">SettingsView</strong> script to examine the logic of <strong class="source-inline1">OnSoundClicked</strong>, as illustrated in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.19 – OnSoundClicked function in the SettingsView script" src="img/B22017_07_19.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.19 – OnSoundClicked function in the SettingsView script</p>
<ol class="calibre15">
<li value="4" class="calibre11">In<a id="_idIndexMarker472" class="calibre6 pcalibre1 pcalibre"/> the <code>SetSFXVolume</code> function, as shown in the next figure, you can observe its associated logic:</p></li>
</ol>
<div><div><img alt="Figure 7.20 – SetSFXVolume function in the AudioManager script" src="img/B22017_07_20.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.20 – SetSFXVolume function in the AudioManager script</p>
<ol class="calibre15">
<li value="5" class="calibre11">In the <strong class="source-inline1">SetSFXVolume</strong> function, we adjust the sound effects volume in the audio mixer, enabling us to control all audio sources linked to this mixer, muting or unmuting their sound. Additionally, the second line manages the sound state data, facilitating its persistence and storage locally or in the cloud.</li>
<li class="calibre11">We will now examine the function responsible for setting the sound state in the <strong class="source-inline1">GameData</strong> script, which manages the game’s data, as you can see in the following figure:</li>
</ol>
<div><div><img alt="Figure 7.21 – SetSoundState function in the GameData script" src="img/B22017_07_21.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.21 – SetSoundState function in the GameData script</p>
<p class="calibre3">In summary, the advantage we gain is the presence of a script dedicated to audio control within the game, equipped with functions that can be utilized in future tasks <a id="_idIndexMarker473" class="calibre6 pcalibre1 pcalibre"/>related to audio management. Additionally, there exists a script named <code>GameData</code>, tasked with managing the game’s data. This allows us to reference it later for any data-related requirements, such as retrieving saved data or storing new data states.</p>
<p class="calibre3">This example is straightforward to follow, but the steps are comprehensive. Feel free to apply these steps to your projects or when you’re dealing with new ones.</p>
<h1 id="_idParaDest-119" class="calibre5"><a id="_idTextAnchor125" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we learned about working with existing code in Unity using C#. We explored how to use VCSs, merge code, and fix conflicts when collaborating on projects. By understanding these concepts, we can work better with other developers and maintain code quality. The chapter also covered how to understand project structures, review documentation, and communicate effectively with team members. By taking the time to understand existing projects, we can contribute more effectively and make better decisions.</p>
<p class="calibre3">In <a href="B22017_08.xhtml#_idTextAnchor127" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 8</em></a>, we’ll look at adding outside assets and features to Unity games using C#. We’ll learn how to use pre-made assets to improve game visuals and add new features such as analytics and monetization. Get ready for new ways to enhance your games in the upcoming chapter!</p>
</div>
</body></html>