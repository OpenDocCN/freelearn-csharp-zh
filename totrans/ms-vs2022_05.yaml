- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-Platform App UI Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into the realm of cross-platform development using Visual
    Studio 2022, with a focus on .NET **MAUI** ( **Multi-Platform App UI** ). We will
    gain comprehensive insights into building applications that seamlessly run on
    multiple platforms using .NET MAUI. The topics cover an introduction to .NET MAUI,
    an exploration of the essential tools for efficient development, debugging on
    various devices, and practical guidance on migrating from Xamarin to . NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to MAUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring tools for MAUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging on devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration from Xamarin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the culmination of this chapter, we’ll be equipped to productively and playfully
    craft compelling multi-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s embark on this expedition of mastering Visual Studio for MAUI development
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch05](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch05)
    .
  prefs: []
  type: TYPE_NORMAL
- en: To access the WordPuzzle project in this chapter, check out the following GitHub
    repository at [https://github.com/dotnet/maui-samples/tree/main/8.0/Apps/WordPuzzle](https://github.com/dotnet/maui-samples/tree/main/8.0/Apps/WordPuzzle)
    .
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MAUI** , is a versatile framework that enables developers to craft native
    applications for both mobile and desktop platforms, using C# and XAML. With MAUI,
    developers can target Android, iOS, macOS, and Windows devices from a unified
    code base.'
  prefs: []
  type: TYPE_NORMAL
- en: This open-source framework builds upon the foundation of Xamarin.Forms, extending
    its capabilities to cover desktop scenarios while aiming for enhanced performance,
    flexibility, and the ability to consolidate app logic and UI layout within one
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of cross-platform development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-platform development frameworks have revolutionized app development by
    enabling code sharing across multiple platforms. Xamarin.Forms, for instance,
    has empowered companies to share over 95 percent of their code base, maximizing
    development investments. However, the landscape has evolved, prompting the emergence
    of frameworks such as MAUI to address previous limitations and adapt to the evolving
    demands of app development.
  prefs: []
  type: TYPE_NORMAL
- en: What is MAUI?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developed by Microsoft, MAUI is an open source framework designed to facilitate
    the creation of native cross-platform apps using a single code base. It builds
    upon the foundation of Xamarin.Forms, enriching it with additional features, such
    as a unified project structure, and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging .NET 6, MAUI integrates the latest advancements, performance enhancements,
    and security updates from the .NET framework, enabling developers to harness the
    extensive ecosystem of .NET libraries and tools to elevate their applications.
  prefs: []
  type: TYPE_NORMAL
- en: The key features of MAUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the key features of MAUI are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A single code base for multiple platforms** : MAUI streamlines project management
    by consolidating code, resources, and UI elements within a single project structure,
    reducing complexity, and saving time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced performance and responsiveness** : Engineered for improved performance,
    MAUI ensures smooth and efficient operation across all supported platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for native features and controls** : MAUI prioritizes native user
    interfaces, delivering a seamless user experience on all platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved developer productivity** : Features such as Hot Reload for XAML
    and CSS enable real-time visualization of UI changes, accelerating the development
    process significantly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve explored the key features and architecture of.NET MAUI, it’s
    clear that this framework represents a significant leap forward in app development.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of MAUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAUI adopts a strategy where it leverages the native capabilities of each platform
    while maintaining a single code base. This approach grants developers access to
    native platform features and UI controls through a unified API, facilitating the
    delivery of uncompromised user experiences while achieving higher code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI offers a unified framework for constructing user interfaces across
    both mobile and desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 5* *.1* (from [learn.microsoft.com](http://learn.microsoft.com)
    ) illustrates the high-level structure of a .NET MAUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The MAUI high-level structure (source: learn.microsoft.com)](img/B22218_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1 – The MAUI high-level structure (source: learn.microsoft.com)'
  prefs: []
  type: TYPE_NORMAL
- en: We can craft .NET MAUI applications on either a PC or a Mac. In our .NET MAUI
    app, our code will primarily interact with the .NET MAUI API. Then, the .NET MAUI
    subsequently accesses the native platform APIs directly. Moreover, our application
    code may directly engage with platform APIs when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end, the code is compiled into native app packages:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI facilitates the development of Android applications by compiling them
    from C# into an **intermediate language** ( **IL** ). This IL code is subsequently
    JIT-compiled into a native assembly upon an application’s launch. In contrast,
    iOS applications developed with .NET MAUI undergo **ahead-of-time** ( **AOT**
    ) compilation directly from C# into native ARM assembly code before deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS applications, .NET MAUI taps into Mac Catalyst, a feature provided
    by Apple. This feature permits iOS apps, constructed using UIkit, to operate on
    macOS platforms. Additionally, it supports the integration of AppKit and necessary
    platform-specific APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to Windows applications, .NET MAUI employs the **Windows UI 3**
    ( **WinUI 3** ) toolkit. This approach enables the creation of native Windows
    desktop applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an understanding of what MAUI is, let’s dive into exploring
    the tools offered by Visual Studio to enhance our MAUI experience.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the tools for MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, to explore the tools offered by Visual Studio for MAUI, we
    will start by creating a basic application. By building this application, we will
    gain hands-on experience with the various tools and features available in Visual
    Studio for MAUI development. This practical approach will ensure that we not only
    understand the purpose of these tools but also learn how to effectively utilize
    them, enhancing our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple MAUI app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must ensure that we have the latest version of Visual Studio 2022
    with the MAUI workload installed. If you don’t have it installed, you can update
    your Visual Studio from the Visual Studio Installer or with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the Visual Studio Installer to install the MAUI workload or
    check whether the version you have is up to date, by launching your Visual Studio
    Installer and clicking on the button to modify your installed Visual Studio (see
    *Figure 5* *.2* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Modifying Visual Studio’s workload](img/B22218_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Modifying Visual Studio’s workload
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are all set. We can create our new MAUI project by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new project. Select **MAUI** as the project
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The .NET MAUI App template](img/B22218_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The .NET MAUI App template
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that an MAUI project has a shared code base that targets multiple
    platforms. In a.NET MAUI setup, the common code base resides within the shared
    project. Conversely, each platform-specific project houses the unique code tailored
    to its respective environment (e.g., **Platforms** | **Android** , **Platforms**
    | **iOS** , **Platform** | **Tizen** , **Platforms** | **MacCatalyst** , and **Platforms**
    | **Windows** ), as shown in *Figure 5* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The MAUI folder architecture](img/B22218_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The MAUI folder architecture
  prefs: []
  type: TYPE_NORMAL
- en: In the **Shared** project, we find the main page’s XAML file, under **MainPage.xaml**
    . This is where we design our app’s UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our example, we will simply build an app, with a button to click on to show
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by designing the UI. To do that, we open **MainPage.xaml** in
    the **Shared** project and replace its content with the following XAML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This XAML code snippet defines the basic structure of **ContentPage** in our
    .NET MAUI application. This page contains **StackLayout** , which is a simple
    layout that arranges its children in a single line that can be oriented horizontally
    or vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we implement the logic by opening **MainPage.xaml.cs** in the **Shared**
    project and adding the following C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is C# code-behind for the **MainPage** class in a .NET MAUI application.
    This code complements the XAML markup you shared earlier, defining the behavior
    of **ContentPage** . Specifically, it includes the implementation of the **OnButtonClicked**
    method, which updates the text of a label named **MessageLabel** when a button
    is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can run the app. The **Start** button allows us to select an emulator
    or device as the target (see *Figure 5* *.5* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Launching Android Emulator](img/B22218_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Launching Android Emulator
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can choose **Android Emulator** ; when we launch it for the
    first time, Visual Studio will prompt us with a wizard to install it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we launch our app, we will see a button labeled **Click Me** (see
    *Figure 5* *.6* ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Android Emulator](img/B22218_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Android Emulator
  prefs: []
  type: TYPE_NORMAL
- en: When we click the button, the text below it changes to **You clicked** **the
    button!** .
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic example to get us started with MAUI. Now that we have a running
    app, we can explore all the tools offered by Visual Studio to enhance our MAUI
    development experience.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore XAML Live Preview to leverage instant UI modification.
  prefs: []
  type: TYPE_NORMAL
- en: XAML Live Preview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **XAML Live Preview** feature in Visual Studio, when used with the Windows
    machine executer, allows developers to see real-time updates of their XAML UI
    changes without the need to manually save or rebuild a project. This feature is
    particularly useful for quickly iterating on UI designs and ensuring that the
    changes are reflected immediately in the preview window.
  prefs: []
  type: TYPE_NORMAL
- en: To enable **XAML Live Preview** , look for the *video camera* icon in the *Visual
    Studio toolbar* . This icon is the **XAML Live Preview** button. Clicking on it
    will enable the Live Preview feature.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The XAML Live Preview button](img/B22218_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The XAML Live Preview button
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can open the **XAML Live Preview** directly through the Visual
    Studio top bar menu in **Debug** mode; navigate to **Debug** | **Windows** | **XAML**
    **Live Preview** .
  prefs: []
  type: TYPE_NORMAL
- en: This action allows us to dock an XAML preview window alongside Visual Studio,
    adjacent to our code base. As we modify the XAML code, the changes are reflected
    in the XAML Live Preview window almost instantly. This allows us to see the impact
    of our changes immediately, without the need to save or rebuild a project.
  prefs: []
  type: TYPE_NORMAL
- en: While hovering over an element, we can retrieve a variety of style information
    and identify the file in which the element is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we hover over the **MyButton** element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – An element’s style properties](img/B22218_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – An element’s style properties
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5* *.8* , we can retrieve properties such as **TextColor** and **BackgroundColor**
    value of the **MyButton** define in **MainPage.xaml** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we can smoothly interact with the preview by scrolling and zooming.
    Besides scrolling with the scroll bars, we can also utilize the following interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: A *mouse wheel* , both vertical and horizontal (if our mouse supports it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *touchpad* two-finger scroll, both vertical and horizontal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Ctrl* key press, paired with a *mouse* *drag* action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, for zooming, we can use the following interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Zoom in** or **Zoom out** buttons in the bottom-left corner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Ctrl* + *plus sign* ( *+* ) or *Ctrl* + *minus sign* ( *-* ) keyboard shortcut
    press, if we prefer using a keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Ctrl* key press paired with a *mouse wheel* action, or a *pinch-to-zoom*
    action with the *touchpad* . A bonus of using a mouse is maintaining more precise
    control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we can add rulers to help us to define the size and position of
    our element. **Rulers** assist us in aligning elements within our application.
    They present distances, measured in application units. This feature helps us verify
    the spacing between different components of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second set of toolbar buttons governs the rulers, as shown in *Figure 5*
    *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The rulers toolbar](img/B22218_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The rulers toolbar
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a list of the main functionalities offered by the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add vertical ruler** : This adds a single vertical ruler. Clicking this button
    multiple times consecutively will position new rulers to avoid overlapping existing
    ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add horizontal ruler** : This inserts a single horizontal ruler, functioning
    similarly to the vertical ruler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove all rulers** : This clears all rulers at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select ruler color** : This adjusts the color of the rulers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toggle ruler visibility** : This toggles the visibility of all rulers with
    a single click.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rulers are designed to be keyboard-friendly. We can navigate through them using
    the *Tab* key. Utilizing the *arrow* keys allows us to move rulers one pixel at
    a time, or we can press *Ctrl* along with the *arrow* keys to move them by 10
    app units at a time. Pressing the *Del* key deletes the currently selected ruler.
    Additionally, we can delete a ruler using the mouse, by selecting the **Delete**
    **Ruler** button.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add rulers to an element while using **Element Selection** . Right-clicking
    adds vertical rulers, and holding the *Shift* key while right-clicking adds horizontal
    rulers.
  prefs: []
  type: TYPE_NORMAL
- en: When working in an application with multiple windows, we can choose which window
    to display by using the **Window combo** box. Alternatively, we can use the **Show
    in XAML Live Preview** button in the application toolbar that’s on the window
    you want to preview, as we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: The XAML Live Preview feature significantly speeds up the development process
    by providing immediate feedback on UI changes, making it easier to design and
    debug XAML-based applications such as MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: XAML Live Preview provides an selecting elements feature that mirrors the selection
    process in a running application. This functionality enables us to locate elements
    in either the Live Visual Tree or within the source XAML. Live Visual Tree is
    another tool that helps us understand the XAML structure of our MAUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the possibilities offered by the Live Visual Tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Live Visual Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Live Visual Tree** feature in Visual Studio provides a real-time, hierarchical
    view of the UI elements in our application, allowing us to inspect and modify
    the UI structure directly within the IDE. This feature is particularly useful
    for debugging layout issues, understanding the visual tree, and making dynamic
    changes to your UI during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to follow with the same code base to illustrate the functionality
    of this feature, with a more complex project, I cloned the WordPuzzle application
    of the GitHub repository: [https://github.com/dotnet/maui-samples/tree/main/8.0/Apps/WordPuzzle](https://github.com/dotnet/maui-samples/tree/main/8.0/Apps/WordPuzzle)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Live Visual Tree feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To utilize the Live Visual Tree feature, we need to debug our application. By
    default, the **Live Visual Tree** window is located on the left side of the IDE
    for Windows and on the right side for Mac. If you can’t find it, you can display
    it by navigating to the top menu bar – **Debug** | **Window** | **Live** **Visual
    Tree** .
  prefs: []
  type: TYPE_NORMAL
- en: 'While open, the **Live Visual Tree** window shows the hierarchy of the UI elements
    that we can easily explore and follow, seeing how our application layouts are
    presented (see *Figure 5* *.10* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Live Visual Tree](img/B22218_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Live Visual Tree
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced the Live Visual Tree, let’s explore the top menu
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Live Visual Tree top menu bar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Live Visual Tree *top menu bar* provides some handy features to navigate
    through the code base and help us debug our layouts.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5* *.11* shows the Live Visual Tree top menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The Live Visual Tree menu](img/B22218_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The Live Visual Tree menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore these features of the Live Visual Tree with a comprehensive overview
    of how we can utilize them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select Elements in the Running Application** : This feature enables us to
    pick a UI element within the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Live Visual Tree then automatically updates to display the corresponding
    node in the tree, along with its properties. This functionality is invaluable
    for swiftly identifying and inspecting specific elements within our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Display Layout Adorners in the Running Application** : This mode showcases
    horizontal and vertical lines outlining the bounds of the selected object, along
    with rectangles indicating the margins. These visual aids make it easy to align
    and space UI elements, aiding in the identification of layout issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preview Selection** : This mode reveals the XAML declaration of the selected
    element, provided we have access to an application’s source code. It’s a convenient
    feature for swiftly navigating to the source code of a selected element in the
    Live Visual Tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Just My XAML** : By default, the Live Visual Tree streamlines the view of
    XAML elements using the **Just My XAML** feature. This functionality hides elements
    that we’re probably not directly interested in, simplifying navigation through
    the tree. We can toggle this feature on and off using the **Show Just My XAML**
    button on the **Live Visual Tree** toolbar. Note that Visual Studio for Mac does
    not currently support this feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the Live Tree View and XAML preview features are seamlessly supported by
    the Hot Reload feature provided by Visual Studio 2022. **Hot Reload** works by
    monitoring the source code for changes. When a change is detected, Hot Reload
    applies the changes to the running application without requiring a full rebuild.
    This means we can see the effects of our changes immediately, without losing the
    current state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the main tooling to enhance our experience with MAUI
    development, in the next section, we’ll see how we can debug our application directly
    on devices.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging on devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen earlier in this chapter, we can easily run our app as a **universal**
    **windows platform** ( **UWP)** or through an emulator of each existing device’s
    OS. Debugging a .NET MAUI app directly on a device using Visual Studio involves
    several steps. This process allows us to test our app on a real device, which
    can be particularly useful for testing features that require specific hardware
    capabilities, or for performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will follow a step-by-step guide on how to do debugging
    on a device.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Developer Mode on our device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To debug your MAUI application on a device, it’s essential to first activate
    **Developer Mode** . However, the steps to do this differ, based on the device’s
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the steps to enable Developer Mode on Windows, Android, and iOS
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For Windows devices** : Go to **Settings** | **Update and Security | For
    Developers** and select **Developer Mode** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Android devices** : Navigate to **Settings** | **About phone** | **Software
    information** and select the **Build number** option, tapping it seven times to
    unlock **Developer Options** . Afterward, return to **Settings** | **Developer
    options** and turn on USB debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For iOS devices** : You need to have a Mac with Xcode installed. Connect
    your iOS device to your Mac, open Xcode, go to **Window** | **Devices and Simulators**
    , select your device, and enable **Connect** **via network** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of the **Developer Mode** option can vary, depending on the user
    interface of your device. If you’re having trouble locating USB debugging, it
    is helpful to refer to your device’s manual for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Networking device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step is to connect the device to the computer. This process will depend
    on our device. Let’s explore both main use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Android, it’s preferable to use USB, as it’s the easiest and most
    reliable method.
  prefs: []
  type: TYPE_NORMAL
- en: Once connected, your device will ask you to confirm whether you trust the computer
    if it’s the first time you’ve debugged on it. You also have the option to select
    **Always allow from this computer** to avoid this prompt in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, it’s possible to debug an Android device over Wi-Fi, eliminating
    the need for a physical connection to the computer. Although this method requires
    more effort to set up, it can be beneficial when the device is situated far from
    the computer and a constant cable connection is impractical.
  prefs: []
  type: TYPE_NORMAL
- en: iOS with Hot Restart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hot Restart** is a feature in Visual Studio 2022 that allows you to quickly
    redeploy your app to an iOS device without having to go through the full build
    and deploy process. This can significantly speed up your development cycle, especially
    when you’re making frequent changes and need to test them on a device. Here’s
    how to use Hot Restart for iOS deployment in Visual Studio 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Hot Restart, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, in the Visual Studio toolbar, choose **iOS Local Devices** from the **Debug**
    target drop-down menu, and then select **Local Device** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – iOS Local Devices](img/B22218_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – iOS Local Devices
  prefs: []
  type: TYPE_NORMAL
- en: This action prompts the **Setup Hot Restart** setup wizard to launch on the
    start of the debugging, guiding us through the process of setting up a local iOS
    device for Hot Restart deployment. Then, select **Next** to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: If iTunes isn’t installed, the setup wizard prompts us to download it. We can
    install iTunes either from the Microsoft Store or Apple’s website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect your iOS device to your development machine using a USB cable,
    and trust your development machine when prompted on the device. Once your local
    iOS device is detected, click **Next** in the setup wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure **Hot Restart** to use your individual Apple Developer Program account
    by clicking the **Sign in with an individual account** hyperlink and providing
    your App Store Connect API key data. Clicking **Finish** completes the setup wizard,
    adding your Apple Developer Program account to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer** , right-click on your project and select **Properties**
    . Under **iOS** | **Bundle Signing** , choose **Automatic Provisioning** from
    the **Scheme** drop-down menu and click **Configure** **Automatic Provisioning**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure Automatic Provisioning** dialog, select the team for your
    Connect API key, and then Visual Studio completes the automatic provisioning process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click **OK** to dismiss the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to launch the debugging session targeting our device.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the debugging session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, Visual Studio will recognize our device, and the option to debug directly
    on it appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Android Local Devices](img/B22218_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Android Local Devices
  prefs: []
  type: TYPE_NORMAL
- en: When we select the **Debug-on-Device** option, our application installs on the
    phone. Subsequently, we must initiate the application to commence debugging, similar
    to how we do it on emulators or Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about MAUI, exploring the tools available in Visual Studio, and
    debugging on local devices, you may find yourself with an existing Xamarin project
    to migrate to MAUI. Let’s explore how to leverage Visual Studio extensions to
    achieve this effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Migrate from Xamarin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to migrate a legacy project written with Xamarin
    to a cutting-edge MAUI application. First, we will explore the key difference
    between MAUI and Xamarin. Then, finally, we will install the .NET Upgrade Assistant
    to use to migrate our project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the key differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAUI is considered the successor to Xamarin; however, there are some key differences
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Xamarin** is a framework within the .NET ecosystem that enables developers
    to create cross-platform applications using C# and .NET. It supports major platforms
    such as Android, iOS, and Windows (UWP). Xamarin facilitates the development of
    native applications, ensuring high performance and native user experiences by
    compiling code into platform-specific native binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, MAUI is the next iteration of Xamarin.Forms, designed to streamline
    cross-platform development further. It expands platform support to include Android,
    iOS, macOS, and Windows, aiming for a unified code base across these platforms.
    MAUI prioritizes modern development practices, focusing on performance optimization
    and delivering native-like experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms provide a comprehensive set of UI controls and layouts that are
    rendered natively on each supported platform. While developers share code across
    platforms, Xamarin.Forms ensure that UI elements conform to the native look and
    feel of each platform, ensuring consistency across devices.
  prefs: []
  type: TYPE_NORMAL
- en: Further to this, MAUI introduces a fresh collection of controls and layouts
    designed to enhance efficiency and flexibility. It aims to deliver a modern, unified
    UI experience across all supported platforms, bridging the gap between native
    and cross-platform app development.
  prefs: []
  type: TYPE_NORMAL
- en: In order to migrate our legacy Xamarin project, we have two options – doing
    it manually or using the Upgrade Assistant. Let’s explore how to use the .NET
    Upgrade Assistant.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET Upgrade Assistant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the options to migrate our project is to modify each file of a Xamarin
    project to MAUI by creating a new MAUI project. This way could be time-consuming
    and need a complete understanding of the project. However, it’s a great option
    for large and complicated projects.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can use the **.NET Upgrade Assistant** to facilitate our process.
    The .NET Upgrade Assistant can be installed either as a Visual Studio extension
    or a.NET command-line tool. Here, in our example, we will use it as a Visual Studio
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The.NET Upgrade Assistant is available for installation as a Visual Studio
    extension or a.NET command-line tool through the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: While Visual Studio is active, navigate to **Extensions** | **Manage Extensions**
    to open the **Manage** **Extensions** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Manage Extensions** window, search for **upgrade** in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the . **NET Upgrade Assistant** option, and then click **Install** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Installing the extension .NET Upgrade Assistant](img/B22218_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Installing the extension .NET Upgrade Assistant
  prefs: []
  type: TYPE_NORMAL
- en: Once the extension finishes downloading, the installation will be launched when
    Visual Studio is closed, and then follow the instructions to install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After installation, right-click on the project node in the **Solution Explorer**
    and select **Upgrade** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Select Upgrade](img/B22218_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Select Upgrade
  prefs: []
  type: TYPE_NORMAL
- en: 'That will open up a window to select between two options (see *Figure 5* *.16*
    ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In-place project upgrade** : This will replace the legacy project with the
    new one.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Side-by-side project upgrade** : This will create a new project containing
    the new MAUI project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The upgrade options](img/B22218_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – The upgrade options
  prefs: []
  type: TYPE_NORMAL
- en: I advise choosing the **Side-by-side project upgrade** option to ensure the
    safety of our working Xamarin project until the upgrade has been successfully
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we just need to follow the steps of the wizard to complete the upgrade.
    The upgrade assistant is a good option for relatively simple projects. However,
    at the end of the process, we may need to make some manual adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: For complex and large projects, the upgrade should be done manually, following
    the step-by-step instructions found in books dedicated to MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on a journey into the depths of multi-platform
    app UI development using Visual Studio 2022, with a focus on .NET MAUI. From unraveling
    the essence of .NET MAUI to mastering essential tools for efficient development,
    debugging across diverse devices, and seamlessly transitioning from Xamarin, we’ve
    equipped ourselves with the knowledge and skills necessary to craft compelling
    multi-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout our exploration, we’ve gained a comprehensive understanding of .NET
    MAUI’s core principles and significance in modern application development. We’ve
    delved into the arsenal of tools tailored for .NET MAUI development within Visual
    Studio 2022, harnessing their power to create, preview, and debug applications,
    with confidence and precision.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the latest features of Visual Studio 2022
    to enhance our web development experience.
  prefs: []
  type: TYPE_NORMAL
