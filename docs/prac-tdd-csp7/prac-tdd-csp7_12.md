# 第十二章：历史代码问题

本章全部关于历史代码。如果你从未处理过历史代码，那么你很幸运，并且知道它终将到来。有些人可能永远被困在维护开发中。你的生活就是历史代码。无论情况如何，本章都是关于处理历史代码的。我们希望要么防止历史代码的产生，要么将其反击到它起源的深处。

在本章中，我们讨论：

+   什么因素使代码成为历史代码

+   历史代码可能引发的问题

+   历史代码如何阻碍测试

+   我们可以采取哪些措施来应对和反击历史代码问题

# 什么是历史代码？

你们中的大多数人可能都不得不处理过令人讨厌的历史代码项目。在那个项目中工作并不有趣；代码一团糟，你想要找到编写它的人，并想知道他们在编写代码时在想什么。

在你的职业生涯中，你曾经或将会成为别人眼中的那个人。我们都会编写出自己以后不会感到自豪的代码。但为什么代码会变得如此糟糕？一个项目何时会变成历史代码？最后，我们可以做些什么来防止这种情况发生？

# 为什么代码会变坏？

简而言之，代码变坏是因为我们害怕改变它。为什么代码的不改变会导致它变坏？你希望，当代码被编写时，它是当时开发者能够编写出的最好的代码。所以，那应该是一段好的代码，对吧？这是一个复杂的问题，但暂时假设，当代码最初被编写时，它是一段值得骄傲的代码。但这仍然提出了一个问题，它是如何变坏的？

答案就在你的面前。你之所以看到这段代码，是因为它需要改变。很可能，你不是第一个需要修改这段代码的人。所以，这并不是一个开发者尽力编写好代码所编写的代码。这段代码是由许多开发者编写的。尽管如此，每个开发者都应该尽力编写好代码。那么，这段代码又是如何变坏的？

正是因为我们害怕改变代码，所以才会产生恐惧。当我们不得不改变代码时，我们通常尽量只做最小的改动，以使所需的更新能够正常工作。毕竟，我们不想因为重构了整个代码而强迫自己或 QA 团队进行全面回归测试，对吧？因此，我们修改代码；我们改变它预期的工作方式。但我们不能改变其结构，也不能修改最初编写代码的开发者的决策。

随着时间的推移，进行这些小的改动并害怕修改原始开发者的结构和架构决策，会导致严重的代码退化。很快，代码将包含大量的条件语句和方法，这些语句和方法已经无法在页面上显示。包含这些代码的类将增长到包含数十个方法，而文件长度也将达到数千行。

# 一个项目何时会变成历史代码？

这是一个很多人以很多不同方式回答的问题。通常，当一个应用程序不再有人愿意对其进行工作时，它就变成了遗留代码。

在一开始，应用程序是按照一个小而明确的目的来构建的。随着时间的推移，系统的范围和广度可能会超出其原始意图。当任何对应用程序的更改导致开发者与应用程序的设计背道而驰时，它将引起摩擦。

如前所述，应用程序的设计并不是因为开发者担心应用程序会崩溃而简单地改变。因此，越来越多的冗余代码被添加到系统中。好吧，那么这需要多长时间？我们何时停止将新的修改硬塞到现有应用程序中，而只是重新编写它？

说实话，冗余代码是从原始开发者第一次编写应用程序时就开始添加的。当你开始开发一个新应用程序，或者甚至在现有应用程序中开发一个新功能时，你开始有一个初步的设计在心中。每个人都是这样做的。一些开发者会在白板上绘制设计或制作完整的**UML**（**统一建模语言**）图。其他开发者只是有一个在头脑中的想法来指导决策。无论如何，当你坐下来开发应用程序时，你都有一个想要的设计。

你发现设计问题并开始修改它需要多长时间？你可能写了一行代码就不得不改变你的设计，或者你可能完成了 75%的工作才发现了问题。这很大程度上取决于你正在解决的问题的复杂性和你的计划的详细程度。无论你的计划多么周密，你都会发现一个问题，并在第一次质量审查之前开始改变你的设计。

你一做出改变，就是在添加冗余代码，所以几乎所有的时候，你都在一个没有为强制放入其中的代码而设计的系统中工作。换句话说，即使你正在开发一个新应用程序，你下一次工作时可能也会编写遗留代码。

在软件中，冗余代码是指任何不必要的或过于复杂的代码。

# 我们能做些什么来防止遗留代码的退化？

真的必须做些什么来阻止这种退化，对吧？考虑到这本书的主题，答案可能很容易预测。但让我用迈克尔·费瑟斯关于遗留代码定义的引言来回答：

对我来说，遗留代码就是没有测试的代码。

- 迈克尔·费瑟斯，《与遗留代码有效工作》

正如我们在前面的章节中讨论的那样，测试允许你重构。改变代码结构的能力正是可以防止遗留代码的腐烂和退化。

当测试可以防止遗留代码的形成时，请注意，它们本身并不能防止遗留问题的出现。这需要团队中每个人的奉献精神，理解将冗余引入系统是一种负面行为，必须避免。如果你感觉自己正在与系统的设计作对，那么将应用程序重构为适合今天需求且足够灵活以适应明天需求的设计就是你的责任。

使系统灵活并不像你想象的那么困难。遵循 SOLID 原则（在第三章中讨论，设置 JavaScript 环境），将有助于产生可维护和灵活的系统。即使是一个灵活的系统，也需要纪律和决心来维持识别和修复应用程序中摩擦的标准。

寻找这种摩擦的过程可以被认为是**PDD**（**痛苦驱动开发**）。这个概念意味着做最简单的事情来解决你现有的问题，并积极识别在将来对应用程序进行修改时出现的任何摩擦。

PDD 可以应用于任何系统，包括应用程序、你的团队和你的个人生活。遵循这个策略，你将痴迷于消除所有事物的摩擦，可能会有些过分。因此，重要的是要记住，你可能是在寻找这种摩擦的唯一一个人，而其他人可能对自身造成的痛苦一无所知。此外，记住人们通常不喜欢有人指出他们的无知。

# 由遗留代码引起的典型问题

我们害怕处理遗留代码是有原因的。但是，我们在处理遗留代码时害怕的是什么？不是代码本身；代码不会伤害我们。相反，我们害怕的是听到我们引入了错误。这是开发者最害怕听到的词。错误意味着我们失败了，我们不得不再次处理遗留代码。

探索在处理遗留代码时可能遇到的问题类型，我们发现有几个。首先，因为我们不了解代码，对某一部分的更改可能会在应用程序的另一个部分产生意外的副作用。另一个问题是代码可能过度优化，或者是由试图在编写时显得聪明的人编写的。最后，紧密耦合可能会使更新代码变得困难。

# 意外的副作用

在推动应用程序走向遗留领域的所有变化中，通常应用程序中的方法或函数会在意想不到的地方被使用，远离你正在更改的代码。

有两个主要的 SOLID 原则违反导致了这个问题，而且同样的两个原则可以帮助你避免未来发生。第一个是**OCP**（**开放封闭原则**），第二个是**LSP**（**里氏替换原则**）。

# 开放封闭原则与遗留代码

如前所述，开放封闭原则指出代码应该易于扩展但不易于修改。这个原则旨在防止遗留代码的问题。

如果你被要求进行的修改将改变应用程序特定部分的行为，那么尝试克隆相关的方法并修改克隆。然后，需要变更的应用程序部分可以调用克隆，这样就可以防止变更影响除了你打算影响的部分以外的任何应用程序部分。

在我们确定我们刚刚避免的代码没有在其他地方被应用程序使用之前，我们不能删除它。最终，一旦我们确定旧代码确实是孤立的并且没有被使用，我们希望清理并删除未使用的方法，以保持一个稍微少一些冗余的代码库。

另一方面，如果变更是为了修复一个错误，那么修复过程就稍微复杂一些。你必须首先确定这个错误是否应该在代码可能被使用的所有地方修复，或者这个错误是否仅与应用程序的特定部分相关。如果有疑问，可以回退到克隆方法，只影响应用程序的有意部分。

# Liskov 替换原则和遗留代码

如何确定变更应该影响整个应用程序还是仅仅影响一个部分呢？一种方法就是采用 LSP（里氏替换原则）。简单来说，LSP 表示一个类应该做它听起来应该做的事情。任何会改变这种行为的变更都应该是一个不同的依赖。

也就是说，任何改变行为的变更可能应该是一个新的方法或一个新的类，其中包含适当的方法。这将防止在应用程序的其他部分产生意外的副作用，并保持你的代码更干净。

# 过度优化

人们常说，过早的优化是件坏事。那么，优化究竟是什么呢？一般来说，优化就是减少从 A 点到 B 点的步骤数量。在计算机程序中，这意味着减少计算结果所需的循环次数。

优化代码的一个不幸副作用是代码通常变得难以阅读和理解。优化往往会以这种方式使代码变得晦涩难懂，以至于只有编写它的人才能理解它，而且经过一段时间，他们可能也无法理解它了。

事实是，难以理解的代码是难以更改的代码。这就是为什么在需要之前发生的优化是坏事的原因。

那么，何时需要优化呢？当明确当前实现未来无法在合理的时间内满足系统需求时，就需要进行优化。

合理的时间框架取决于所需优化的复杂性和业务的速度。当业务快速增长时，需求将沿着相同的曲线增长。

一个行动较慢的公司可能需要几个月的时间来规划和准备，才能将工作分配给开发者。在这种情况下，提前几个月规划优化是合理的。重要的是要监控应用程序的性能，以便预测这些需求。

# 过于聪明的代码

大多数开发者开始编写代码是因为他们喜欢这样做。很少能找到一个进入这个领域仅仅是因为他们听说可以赚很多钱的开发者。一直为公司编写同样的无聊代码可能会导致开发者偶尔想要找点乐趣。

当开发者感到无聊时，他们会想出有趣且往往过于复杂的解决方案，而这些解决方案实际上并不需要。有时，开发者会想出他们能想到的最聪明的解决方案来解决问题。

聪明解决方案的问题是，为了修复一个问题，你必须比修复它的人更有技能。所以，如果你写了你能写的最聪明的代码，那么你就不再有资格调试代码了，你带来的，以及每个人的，进步都会停滞。

# 与第三方软件的紧密耦合

每个人都会使用一些第三方插件或库。在软件社区中，不可避免地，你将不得不依赖他人的代码。当你使用那段代码时，你不知道的是其质量、稳定性以及满足你未来需求的能力。

考虑到这一点，直接依赖第三方提供的类和接口是个坏主意。相反，使用六边形架构，也称为端口和适配器。对于任何使用 C#的开发者来说，这包括抽象.NET 框架。

任何你和你的团队没有编写的代码都应该被抽象化，以保护你的代码免受潜在的外部变化的影响。这包括在公司内部由不同团队编写的代码。如果它不在你的控制之下，就将其放在抽象层后面。首选的抽象方式是一个或多个提供所需功能的接口。

# 阻碍添加测试的问题

截止日期很紧张。范围不断变化。我们根本没有时间写测试。把功能推出门更重要。我们都有过这样的经历。无论情况如何，有时你会发现自己在从事一个没有考虑到测试的项目。

总是觉得时间不够用来做正确的事，但总有时间来重做。

那么，你可能会遇到哪些问题，阻止你向遗留应用程序添加测试？

当一个系统没有考虑到测试时，在稍后添加测试可能会非常困难。具有具体依赖和紧密耦合的类会使软件应用程序难以测试。像大型类和函数、Demeter 法则违反、全局状态和静态方法等问题也会使系统变得非常难以测试。

就像从摇摇晃晃的基础开始建造房屋一样，不可测试的代码会滋生出更多不可测试的代码。除非系统的某些部分可以从应用程序的其他部分中解耦，否则不可测试的趋势很可能会持续下去，而且通常就是这样。

# 直接依赖框架和第三方代码

如前一章所述，对框架和第三方代码的依赖会导致紧密耦合的系统。例如，每次在 C#中调用`new`运算符时，都会对该特定类产生直接依赖。我们希望尽可能减少这些依赖。

记住，甚至框架依赖也应该避免，或者至少尽可能抽象化。回想一下`DateTime`的例子，在示例应用程序中，我们能够为测试目的提供自己的`DateTime`值。

在类或文件顶部出现的任何`using`或`import`语句都应该仔细考虑，并在可能的情况下避免。相反，确保你的代码依赖于一个定义直接在你控制下的*接口*。这样，你可以最小化耦合，并在你自己的类和方法中隔离功能。这将帮助你编写更干净、更易于测试的代码。

# 德米特法则

德米特法则在其最简单形式中表明，*每个单元应该只对其他单元有有限的知识：只有与当前单元“紧密”相关的单元*。进一步来说，*每个单元应该只与其朋友交流；不要与陌生人交流*。简单来说，*只与你的直接朋友交流*。

当一个类或函数了解其直接控制之外的某个事物的内部工作时，那么那里就存在一些紧密耦合。为了测试一个违反德米特法则的方法，所需的设置量通常相当大。为了测试一个违反德米特法则的类的方法，你必须设置另一个类或方法，或者提供一个合理的模拟实现，以便有效地进行测试。

记住，保持你的测试方法小巧灵活，这样它们就能快速运行，并且易于理解。如果你遵循这个规则，你的生产代码可能也会同样简单且易于遵循。从长远来看，这将是有益的，因为将来维护起来会更容易。

# 构造函数中的工作

当创建一个具有构造函数逻辑的新类实例时，通常很难测试该类。如果由于某种原因，你需要设置一个需要不同值或行为而不是构造函数中设置的测试场景，那么进行测试将会非常困难。最好是尽量减少构造函数中的工作，并提取辅助方法或某些其他更容易测试和在其他地方更好地实现的情况。

请记住，特定的模式可能证明是设置特定类或函数的更好替代方案。你应该熟悉常见的软件模式以及如何最好地实现它们。这将帮助你通过解决其他人之前已经解决的问题来增长应用程序。通过利用已知的软件模式，你可以更容易地在系统内的代码中传达你的意图。

例如，构建器模式可能被用来构建具有适当值的对象，否则这些值将添加到构造函数中。

以以下`Car`类的例子为例：

```cs
public Car(string make, string model, int doors)
{
  Make = make;
  Model = model;
  Doors = doors;
}
```

你可以轻松地编写一个构建器类来构建特定类型的汽车，例如`ToyotaCamryBuilder`或`FordMustangBuilder`。创建丰田凯美瑞或福特野马的新实例将非常容易、简单和干净。更不用说，这将非常容易进行测试。

# 全局状态

全局状态容易受到应用程序远处部分的副作用的影响。这些副作用将改变你运行代码的结果。近年来，函数式编程已经流行起来，因为其一个原则是减少副作用，因为它们可能导致系统中的不可预测和不受欢迎的行为。相反，你应该努力将你的代码分解成所谓的纯函数。纯函数接受输入并产生输出。对于任何给定的输入，输出总是相同的。

# 静态方法

静态方法本身并不坏，但它们确实暗示了责任错位的代码异味。静态任何事物都告诉你，你把代码放在了错误的地方。它不与作用域内其他代码共享任何共同点，可能应该被移除并放在与其朋友在一起的地方。

# 大类和函数

类的大小真的重要吗？拥有一个大方法或函数有什么问题？大类和函数通常意味着复杂性。记住 SOLID 原则以及每个字母代表的意义。一个大类或方法很可能会违反一个或多个原则。

我们希望我们的类和函数小而只有一个改变的理由（*单一职责原则*）。一个大类很可能会隐藏可以并且应该分解成两个或更多独立且不同的类的逻辑。一个大方法或函数同样经常隐藏两个或更多方法。寻找保持你的方法简单的方法，并留意可能的逻辑边界，以便将较小的辅助程序、类和实用工具分离出来。

类和函数应该逻辑上划分和分组。系统的目的应该通过与应用程序相关的文件名称和分组容易理解。系统的结构应该是简单且对负责增强和维护应用程序的人来说有意义的。

# 处理遗留问题

我们一直在讨论遗留代码的所有问题。现在是我们解决这些问题的时候了。我们必须做的第一件事是使目标遗留代码恢复理智，然后我们可以开始测试，最终修复代码，让它从死亡中复活。

# 安全的重构

术语重构经常被错误地使用。当你重构时，你只是在改变代码的结构。如果代码的逻辑和/或签名发生变化，那么这不算是重构。这是一个变化；很可能是破坏性的变化。

如果我在更改代码的结构（重构），那么我永远不会同时更改其行为。如果我在更改调用某些逻辑的接口时，我永远不会同时更改逻辑本身。

– Kent Beck

安全的重构是指保证不会意外破坏代码的重构。其他不是有意改变代码行为但可能意外改变行为的更改被认为是不可安全的重构。这些通常涉及对代码的私有区域的更改，这些区域没有直接暴露给应用程序的消费者。

# 将值转换为变量

可以做的第一件简单的事情之一是将任何硬编码的值提取出来，由变量来表示。拥有变量可以更快、更一致地更新。这也有助于传达意图。

在创建变量时，确保变量的名称足够描述性，以适应变量的作用域。作用域短的变量可以有短名称。另一方面，作用域长的变量必须有更长、更描述性的名称。变量与其使用地点的距离越远，就需要越多的描述性，以便不会丢失它所代表的上下文。

检查变量的作用域，确保它们的作用域不大于必要的范围。还要检查那些本应具有更大作用域但被传递给私有方法而不是作为类成员的变量。

目前不建议更新依赖于可能移动到类作用域的变量的私有和受保护的方法。相反，注意它们，并在添加了测试之后移动它们。

# 提取方法

与遗留代码一起工作通常涉及处理非常长的代码。任何超过二十行的代码都可以被认为是长的。最好将方法保持得尽可能小，甚至只有几行。

一个大的方法可能意味着代码违反了单一职责原则。需要做的事情是找到方法中的缝隙。可以通过注释方法的不同部分来找到缝隙。一旦你注释了部分，你就已经识别出了缝隙。

缝隙

在代码中，这是两段业务逻辑相遇的位置。通常，你可能将私有方法被公共方法调用的位置称为公共方法中的“接缝”。代码在那个位置已经被缝合在一起。在这种情况下，没有私有方法，所以我们正在确定我们想要接缝的位置。

那些接缝中的每一个可能都是一个可以提取的低级方法。在大多数编辑器和 IDE 中，突出显示你想要提取的代码，然后使用通过右键单击、上下文菜单或菜单栏提供的提取方法重构功能。

# 提取一个类

就像方法一样，有时一个大的方法实际上应该是一个类。在提取方法的过程中，如果你提取了三个或更多的方法，那么你很可能发现了一个需要提取的类。

提取类与提取方法类似，并且很可能被你的编辑器或 IDE 支持。分组并突出显示你想要提取的代码，然后使用提取类菜单选项。

如果你的编辑器不支持提取类，并不意味着一切都完了。相反，突出显示并剪切出你想要放入类中的所有提取方法。创建一个新的类文件，并将这些方法粘贴到新类中。最后，用新类和方法的实例化和调用替换原始方法中对这些方法的调用。

# 抽象第三方库和框架代码

现在我们已经抽象了变量、方法和类，是时候抽象第三方库、框架代码以及我们刚刚创建的类了。

首先，让我们从框架细节开始。像`DateTime`、`Random`和`Console`这样的东西最好隐藏在你设计的适合你应用程序需求的类后面。这样做有几个原因；最重要的是，将这些放入它们自己的类中将允许进行测试。如果不将这些抽象为单独的类，几乎不可能使用像`DateTime`这样的会自行更改值的对象进行测试。

接下来是第三方库。任何代码调用第三方库以创建新类的位置，你都需要将其抽象为一个新类，专门用于利用那个第三方库。目前，用实例化你的类来替换实例化第三方库的调用。

最后，我们现在可以处理代码中留下的对`new`的调用。代码中任何调用`new`的地方都需要用依赖注入来替换。这将允许进行测试，并使代码在未来更加干净和灵活。

为了在不修改类签名的情况下创建依赖注入，我们将使用一种称为“穷人依赖注入”的模式，也称为属性注入。下面是一个 C#中属性注入的示例。几乎不需要修改就可以在 JavaScript 中完成相同的操作：

```cs
public class Example
{
  private Injected _value;
  public Injected Value
  {
    get => _value = _value ?? new Injected();
    set => _value = value;
  }
}
```

使用这种模式，可以在需要时让类懒加载其依赖项。也可以为测试或其他目的设置依赖项的值。尽管在这个模式的快速示例中没有展示，但最好让属性和后置变量是接口类型。这将使注入其他值更容易。

# 早期测试

如果一个大型且复杂的应用程序没有被正确分割，那么知道如何以及在哪里开始编写测试可能是一项相当艰巨的任务。通过在测试遗留系统方面进行一些实践，这将会变得更容易。

在遗留系统中何时编写测试可以很容易地回答：“当它有意义时。”向任何企业主推销这个想法，即应该花费时间（和金钱）回头编写测试来覆盖遗留系统的现有功能，可能会很困难。在添加增强功能或解决缺陷时添加测试要合理得多。当你正在代码中工作，并且立即有关于你希望测试的功能的上下文时，这就是开始测试遗留应用程序部分的最佳时机。

那么，你如何开始为遗留系统编写测试呢？隔离那些可以轻松测试的小函数。根据需要提取方法和更小的类。确保功能没有被修改，但代码只是被重新组织以方便测试性。

可能需要将私有方法更改为受保护的，以便可以进行测试。改变方法的范围确实使其更易于访问，并可能减少有效抽象，但如果这种改变是为了帮助测试，那么这种权衡几乎总是值得的。你也可能考虑，使私有方法公开可能更适合不同的实用程序或辅助类，因此可以保持公开。这取决于具体的方法，但确实有可用的选项可以帮助使遗留系统更具可测试性。

# 黄金标准测试

黄金标准测试，或称特征测试，是那些仅定义方法预期功能的测试。如果你要向遗留系统添加测试，你可能会首先编写黄金标准测试来定义系统的“快乐路径”。你可能运行应用程序以确定给定方法基于给定输入返回的值，然后编写一个测试来复制这些结果。

使用黄金标准测试是因为它们提供了捷径。通常，为了测试遗留代码，你可能需要抽象第三方库并设置某种类型的依赖注入。你可能还必须对代码进行重大重构，才能达到可以测试任何东西的程度。通过使用黄金标准测试，大部分这项工作可以暂时绕过。唯一需要的抽象是屏幕输出、日期/时间和随机。几乎所有其他东西都可以直接使用。

这将为测试套件提供一个基线，并有助于确保预期的功能在未来的重构或修改中不会发生变化。黄金标准测试并不验证正确性；它们只是确认系统做了系统应该做的事情。

作为基础，黄金标准测试提供了一定程度的安慰，以防止任何不希望的行为变化。这些可能不足以提供足够的代码覆盖率，并且应该添加额外的测试来覆盖边缘情况和系统中的替代路径。

随着测试套件的成长和覆盖率的提高和完整性，可能证明删除原始黄金标准测试是明智的。再次强调，你希望你的测试套件能够快速执行，以便始终运行并经常运行。删除可能多余的测试将有助于在运行测试时最小化反馈周期。换句话说，如果你知道你破坏了某些东西，测试完成得更快，你更有可能运行测试。

# 测试所有潜在结果

测试一个方法的所有可能值并不一定很重要。例如，在黄金标准测试的例子中，你当然不希望用所有可能的值运行应用程序，以便为每种可能性编写测试。测试执行路径的每个路径要重要得多。

如果一个方法足够小，其潜在结果范围有限，那么编写一些测试来覆盖所有潜在场景应该是相当简单的。以下方法为例：

```cs
public int GetPercent(int current, int maximum)
{
  if (maximum == 0)
  {
    throw new DivideByZeroException();
  }

  return (int) ((double) current / maximum * 100);
}
```

通过此方法有哪些潜在路径？你可能编写哪些测试来确保充分的覆盖？

首先，你可能考虑编写一个测试，假设*最大值*输入参数等于`0`。这应该涵盖此场景中的`DivideByZeroException`。

接下来，你可能编写一个测试，其中*当前*参数为`0`，确保此方法的结果始终为零，假设*最大值*非零。

最后，你可能想要编写一个或多个测试来验证上述算法确实根据输入正确地计算百分比。

在这一点上，你可能想添加测试来检查负值或检查 C#正在进行的舍入，但请记住，我们正在处理遗留代码，并且从业务的角度来看，这段代码是按原样工作的。你没有关于产生此代码的业务需求的记录，因此测试超过代码告诉你的内容是不必要的，甚至可能是不负责任的。所以，如果你认为代码在它没有覆盖某些业务标准或可能产生不正确值方面有缺陷，与你的业务讨论这些问题，并共同做出决定。任何对代码的更改都必须通过错误或新工作来实现。

# 前进

一旦遗留系统已经足够重构，并且添加了一个全面的测试套件，你就可以开始将应用程序视为非遗留、当前或当代系统。现在，添加新功能和平息任何新发现的缺陷应该变得非常简单。从这一点开始，任何新请求的功能都应该能够轻松添加，并且有信心其他系统部分不会受到负面影响。

遗留应用程序不再被视为遗留。有了全面的测试套件，你现在可以安全地以测试驱动开发的方式继续前进，并在添加每个新功能时编写测试。记住，要像生产系统中的任何部分一样保持你的测试干净和重构良好。

以上面的`GetPercent`示例为例，你该如何修改它以返回两位小数？当然是通过编写新的测试来实现！首先创建一个基于输入值返回两位小数的测试。

你的测试可能看起来像这样：

```cs
[Fact]
public void ItReturnsTwoDecimalPlaces()
{
  // Arrange
  // Act
  var result = GetPercent(1, 3);
  // Assert
  Assert.Equal(33.33, result);
}
```

现在，修改现有的方法以只返回两位小数。我们将把这个作为练习留给读者。

# 修复错误

在遗留系统中修复错误是一项危险的任务。请记住，任何现有行为可能已经在系统的其他部分或由应用程序的外部消费者考虑在内。通过修复错误，你可能会破坏其他人依赖的功能，尽管是错误的。因此，在执行之前，应该仔细考虑代码执行结果的任何更改。

# 自由地进行不安全的重构

重构，按照定义，是在不修改其行为的情况下修改代码的结构。安全的重构包括变量注入、方法提取等。不安全的重构将影响代码的架构，代码与系统其他部分交互的方式，等等。通过拥有一个完全测试过的代码部分，你现在可以修改架构并确信这部分仍然在做它应该做的事情。

# 摘要

在本章中，我们讨论了如何定义遗留代码以及遗留代码可能引起的问题。遗留代码可能会阻碍测试，但现在你应该知道如何反击遗留问题。

在第十三章，“解开混乱”，我们将探讨在遗留系统中可能会遇到的一些相当极端的例子。我们将探讨安全的重构以及如何最好地将混乱解开成结构良好、可测试的代码。
