<html><head></head><body>
        

                            
                    <h1 class="header-title">Performing I/O Operations</h1>
                
            
            
                
<p>In any programming language, all applications are dependent upon some sort of data. These applications interact with one another, passing data present in different sources such as file objects and external web services.</p>
<p>In this chapter, we will look at the different functionalities provided in C# to access and utilize data in file objects and external web services.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Performing I/O operations on file objects</li>
<li>Different helper classes available in the <kbd>System.Net</kbd> namespace that help us with I/O operations</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>Like in the previous chapters covered in this book, the programs explained in this chapter will be developed in Visual Studio 2017.</p>
<p>Sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14">https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">File I/O operations</h1>
                
            
            
                
<p><strong>File</strong> is a very crude term representing a collection of data stored on a disk at a particular directory path. While writing C# applications, there are several occasions when we will need to use file objects:</p>
<ul>
<li>To store data in an application or pass it across to another application</li>
<li>To access configuration settings that are necessary for application execution</li>
<li>To access files that are present in a directory path</li>
</ul>
<p>These operations are called I/O operations. C# provides a namespace, <kbd>System.IO</kbd>, that has some helper classes. These helper classes help us execute I/O operations on file objects. In this section, we will look at those helper classes in C#. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with System.IO helper classes</h1>
                
            
            
                
<p>The <kbd>System.IO</kbd> namespace contains a collection of classes that allow us to do file manipulation in C#. It includes classes that allow us to do operations such as the following:</p>
<ul>
<li>Read data from a file</li>
<li>Write data to a file</li>
<li>Create/delete new files</li>
</ul>
<p>At different points during this chapter, through code examples, we will look at all of these I/O operations that we can perform on a file. However, before we start looking at those examples, we need to understand a very important concept, <em>Stream</em>, on which I/O operations are based. </p>
<p>A stream signifies a sequence of bytes exchanged between applications during an I/O operation. In C#, it's represented by an abstract class called <kbd>System.IO.Stream</kbd>. It provides a wrapper class to transfer bytes, and all classes that need to read/write bytes from any source must inherit from this particular class.</p>
<p>Before we move on to learn more about streams and how we deal with it them in C#, let's first look at how we deal with drives, directories, and some other basic operations with files.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Drives and directories</h1>
                
            
            
                
<p>A drive represents a storage medium for the filesystem. It can be a hard drive, a CD, or any other storage type. In .NET Framework, we have a <kbd>DriveInfo</kbd> class in the <kbd>System.IO</kbd> namespace, which helps us access the filesystem information that is available on the drive. It provides methods that can help us access information such as name, size, and the free space available on the drive. Please refer to the following code implementation, in which we are looping through all the files available on the drive:</p>
<pre>DriveInfo[] allDrives = DriveInfo.GetDrives();<br/>foreach (DriveInfo d in allDrives)<br/>{<br/>     Console.WriteLine("Drive Name" + d.Name);<br/>     Console.WriteLine(" Drive type " + d.DriveType);<br/>     if (d.IsReady == true)<br/>     {<br/>         Console.WriteLine("Available space ", d.AvailableFreeSpace);<br/>         Console.WriteLine("Total size in bytes ", d.TotalSize);<br/>     }<br/>}<br/>Console.ReadLine();</pre>
<p>In the preceding piece of code, we are browsing through all the drives (that is, C, D, E, and so on) available on the filesystem and are publishing information related to the following: </p>
<ul>
<li>The name of the drive</li>
<li>The type of drive, that is, fixed, RAM, CD ROM, removable, and so on</li>
<li>The total available memory size on the drive</li>
<li>The total free memory available on the drive</li>
</ul>
<p>If we execute the code, the execution will loop through all the drives that are present in the filesystem. Once a drive is retrieved, the execution will retrieve certain properties about the drive, such as free space, total size, and drive type. Thus, when we execute the program, we will get the following output. Please note that we may not get all the information as it also depends upon the security permissions on the directory:</p>
<div><img src="img/afdd2c02-9e45-42c1-80be-08f0ee2b310d.png" style=""/></div>
<p>In the system in which we are executing this program, we just have a C drive. Thus, while the program is executing, we are showing the properties of the C drive. </p>
<p class="mce-root"/>
<p>There are other properties on the <kbd>driveinfo</kbd> object as well. If we click on Go to Definition on the <kbd>DriveInfo</kbd> class, we can see the attributes of the class. Please visit the following link for more information: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2</a>.</p>
<p class="mce-root">Each drive in a filesystem comprises directories and files. A directory in itself can comprise multiple sub-directories and files. If we need to do an operation on a particular directory, we do it using the <kbd>DirectoryInfo</kbd> class in C#. In the following code snippet, we are creating an object of the <kbd>DirectoryInfo</kbd> class, passing the location of a particular directory path:</p>
<pre>DirectoryInfo directoryInfo = new DirectoryInfo("C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples");<br/>foreach (DirectoryInfo f in directoryInfo.GetDirectories())<br/>{<br/>     Console.WriteLine("Directory Name is" + f.Name);<br/>     Console.WriteLine("Directory created time is " + f.CreationTime);<br/>     Console.WriteLine("Directory last modified time is " + f.LastAccessTime);<br/>}</pre>
<p>For the <kbd>directoryInfo</kbd> object, we are then looping through all the child directories and are showing the information related to the following:</p>
<ul>
<li>Name of the directory</li>
<li>Time the directory was created</li>
<li>Time the directory was last modified</li>
</ul>
<p class="mce-root"/>
<p>When we execute the preceding program, we do so on the <kbd>C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples</kbd> file path. Please note that this is where we have been placing the codebase for the chapters we've got through in this book. Thus, when we execute this program, it will loop through the sub-folders of all those chapters and will fetch information such as <kbd>Directory Name</kbd>, <kbd>Directory created time</kbd>, and <kbd>Directory last modified time</kbd>. The following is the output that we will get for the program:</p>
<div><img src="img/f4612923-6053-45fa-bd9e-66bfc4286adb.png" style=""/></div>
<p>There are additional operations available with the <kbd>DirectoryInfo</kbd> object. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking whether the directory exists</h1>
                
            
            
                
<p>Using a particular directory path, we can identify if any directory with that path exists in the filesystem or not. In the code implementation, we are creating a <kbd>DirectoryInfo</kbd> object and then using the <kbd>Exists</kbd> property to check whether the directory exists in the filesystem:</p>
<pre class="mce-root">DirectoryInfo directoryInfoExists = new DirectoryInfo("C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples\\Chapter 20");<br/>if (directoryInfoExists.Exists)<br/>{<br/>     Console.WriteLine("It exists");<br/>}<br/>else<br/>{<br/>     Directory.CreateDirectory("Does not exist");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>If we execute the code using the path mentioned during the creation of the <kbd>DirectoryInfo</kbd> object, the program execution will determine whether there is a directory in the filesystem in the specified path. Thus, when the program is executed, as we do not currently have a sub-folder called <kbd>Chapter 20</kbd> in the <kbd>Book70483Samples</kbd> base folder we will see Does not exists in the console output window. The following is globally the relevant  output on the console window:</p>
<div><img src="img/bbe540ac-7c34-4fd9-ac85-449f85e1c677.png" style=""/></div>
<p>In the next section, we will look at how to create a directory in a filesystem using C#.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a directory</h1>
                
            
            
                
<p>Using the <kbd>DirectoryInfo</kbd> class, we can also create new directories in the filesystem. The following code illustrates how we create a new directory in the system:</p>
<pre>Directory.CreateDirectory("C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples\\Chapter 20"); <br/> </pre>
<p>If the preceding code is executed, it will create a subdirectory called <kbd>Chapter 20</kbd> in the root folder. </p>
<p>In the preceding code, we are passing an absolute path to create the directory. However, if we need to create a subdirectory in a particular directory, we can just execute the following code:</p>
<pre>DirectoryInfo subDirectory = parentDirectory.CreateSubdirectory("NameChildDirectory");</pre>
<p>In the preceding code, <kbd>parentDirectory</kbd> is the parent directory in which we want to create the subdirectory. <kbd>NameChildDirectory</kbd> is the name that we want to give to the child directory.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Looping through the files</h1>
                
            
            
                
<p>Using the <kbd>DirectoryInfo</kbd> class, we can also loop through the files present in the directory. The following code shows how we can loop through the files and access their properties:</p>
<pre>DirectoryInfo chapter20 = new DirectoryInfo("C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples\\Chapter 20");<br/>foreach (FileInfo f in chapter20.GetFiles())<br/>{<br/>     Console.WriteLine("File Name is " + f.FullName);<br/>     Console.WriteLine("Directory created time is " + f.CreationTime);<br/>     Console.WriteLine("Directory last modified time is " + f.LastAccessTime);<br/>}</pre>
<p>In the preceding code snippet, we are looping through the files present in the <kbd>Chapter 20</kbd> directory and showing the information present in it. In the <kbd>Chapter 20</kbd> folder, we have only one file: <kbd>dynamics365eula.txt</kbd>. Thus, when the program is executed, it will pick up the file and will read the file information present in it. To illustrate this, we are displaying the filename, the time the file was created, and the time the file was last accessed. So when the code is executed, we will get the following output:</p>
<div><img src="img/d9d8c047-0d90-4dd4-bfe0-928a8cdce0ce.png"/></div>
<p>Now that we have some knowledge about drives and <kbd>DirectoryInfo</kbd>, we will explore some helper classes that allow us to do operations on files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with files</h1>
                
            
            
                
<p>In this section, we will go through the helper classes that allow us to do operations on the files present in a directory. C# provides the <kbd>File</kbd> and <kbd>FileInfo</kbd> helper classes to do operations on files. While going through the following code snippets, we will be looking at some of the typical operations that we can do with file objects.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking whether a file exists</h1>
                
            
            
                
<p>This basically involves checking whether a file with the given path exists or not. This can help us write fail-safe code in such a way that we read a file only after establishing that it exists in the given path:</p>
<pre>string file = "C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples\\Chapter 20\\IO Operations.txt";<br/>if(File.Exists(file))<br/>{<br/>     Console.WriteLine("File Exists in the mentioned path");<br/>}<br/>else<br/>{<br/>     Console.WriteLine("File does not exists in the mentioned path");<br/>}</pre>
<p><kbd>File</kbd> is a static class available in the <kbd>System.IO</kbd> namespace. This class provides operations that we can use to execute functionalities related to file access. In the preceding code, we have declared a file path and, using the static <kbd>File</kbd> class, we are checking whether the file indeed exists in the given path. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving a file from one location to another</h1>
                
            
            
                
<p>In this operation, we basically cut the file from one location and paste it into another. The following code snippet shows how this can be done:</p>
<pre>string sourceFileLocation = "C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples\\Chapter 20\\IO Operations.txt";<br/> string targetFileLocation = "C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples\\Chapter 21\\New File.txt";<br/>if (File.Exists(sourceFileLocation))<br/>{<br/>     File.Move(sourceFileLocation, targetFileLocation); <br/>}<br/>else<br/>{<br/>     Console.WriteLine("File does not exists in the mentioned path");<br/>}</pre>
<p>In the preceding code snippet, we are first checking whether the file exists in a particular location. If the file is present in the location, we are copying it into another location.</p>
<p>Once the code is executed, we will notice that the file is cut from the source location and is pasted in to the target location. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Copying a file from one location to another</h1>
                
            
            
                
<p>In this operation, we basically copy the file from one location and paste it into another. Please note the <kbd>Move</kbd> operation will delete the file present in the source folder. However, the <kbd>Copy</kbd> operation will copy the file present in the source folder to the destination folder. The following code snippet shows how this can be done:</p>
<pre>if (File.Exists(targetFileLocation))<br/>{<br/>     File.Copy(targetFileLocation, sourceFileLocation);<br/>}<br/>else<br/>{<br/>     Console.WriteLine("File does not exists in the mentioned path");<br/>}</pre>
<p>When the code is executed, we will see that the file is copied from the source file location and pasted in to the target file location path.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a file </h1>
                
            
            
                
<p>In this operation, we delete a file present in the specified location:</p>
<pre>File.Delete(sourceFileLocation);</pre>
<p>When the code is executed, we will see that the file is deleted from the source file location. Once the code is executed, we will see that the file specified in the <kbd>sourceFileLocation</kbd> path has been deleted.</p>
<p>Please note that operations that work with the <kbd>File</kbd> class work the same way with the <kbd>FileInfo</kbd> class. The same implementations that we have done with the <kbd>File</kbd> class can be done via the <kbd>FileInfo</kbd> class as well.</p>
<p>In all the preceding examples, we have been hard-coding the path property of the file. This is not a recommended practice as it is error-prone. For example, if you look at the actual path of any file and compare it to what we need to supply in the program, you will notice a difference:</p>
<ul>
<li>Actual path: <kbd>C:\File Location\Chapter 20\Sample.txt</kbd></li>
<li>Path which we need to specify in the program: <kbd>C:\\File Location\\Chapter 20\\Sample.txt</kbd></li>
</ul>
<p class="mce-root"/>
<p>We need to provide some extra slashes in the path. Also, when we are combining the folder path with the file path, we need to concatenate them with an extra <kbd>\</kbd> as well. For these reasons, hardcoding the path is not a recommended practice. A better approach is to use the <kbd>Path</kbd> helper class. The following code shows how to use it:</p>
<pre>string sourceFileLocation = @"C:\UCN Code Base\Programming-in-C-Exam-70-483-MCSD-Guide\Book70483Samples\Chapter 20";<br/>string fileName = @"IO Operations.txt";<br/>string properFilePath = Path.Combine(sourceFileLocation, fileName);<br/>Console.WriteLine(Path.GetDirectoryName(properFilePath));<br/>Console.WriteLine(Path.GetExtension(properFilePath));<br/>Console.WriteLine(Path.GetFileName(properFilePath));<br/>Console.WriteLine(Path.GetPathRoot(properFilePath));</pre>
<p>In the preceding code implementation, we have declared a folder path. Please also note the use of <kbd>&amp;</kbd> before the filename. This is an escape character that allows us to not specify an extra <kbd>\</kbd> in the folder path structure.  We have also declared a filename and are now combining the two together using the helper static class: <kbd>Path</kbd>. Once we have combined them, we retrieve the properties in the resulting file path. If the code is executed, we get the following output:</p>
<div><img src="img/5c6a1269-e54e-48ec-a187-e1c11e4fab4f.png"/></div>
<p>Let's examine the output:</p>
<ul>
<li><kbd>Path.GetDirectoryName</kbd>: This returns the directory name of the combined path file. Note that it has the complete absolute directory path.</li>
<li><kbd>Path.GetExtension</kbd>: This returns the file extension of the combined path file. In this case, it's a <kbd>.txt</kbd> file.</li>
<li><kbd>Path.GetFileName</kbd>: This returns the name of the file. </li>
<li><kbd>Path.GetPathRoot</kbd>: This returns the root of the filepath. In this case, it's <kbd>C:</kbd>, hence it's mentioned in the output.</li>
</ul>
<p>Now that we are aware of basic operations on files, we will look at how to access and modify the contents of a file. For this, we will look at the operations available in <kbd>FileStream</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Stream object</h1>
                
            
            
                
<p>The main operations with files are related to reading, writing, retrieving, and updating text present in file. In .NET, these operations are performed using an exchange of bytes in I/O operations. This sequence of bytes is a stream, and in .NET, it's represented using the abstract <kbd>Stream</kbd> class. This class forms the basis of all I/O operations in .NET such as <kbd>FileStream</kbd> and <kbd>MemoryStream</kbd>.</p>
<p>With stream we can perform the following operations in .NET:</p>
<ul>
<li>Reading data in the stream object</li>
<li>Writing data into the stream object</li>
<li>Searching for or finding relevant information from the stream object </li>
</ul>
<p>Let's take a look at the different operations that are implemented using stream objects. In the next section, we will go through the <kbd>FileStream</kbd> object, which aids operations on the file object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">FileStream</h1>
                
            
            
                
<p>Using the <kbd>FileStream</kbd> object, we can read and write information back to the file in the directory. It's done using the <kbd>File</kbd> and <kbd>FileInfo</kbd> object we discussed in the previous section in this chapter. </p>
<p>Lets go through the following code example, in which we are writing information to a file:</p>
<pre>string sourceFileLocation = @"C:\UCN Code Base\Programming-in-C-Exam-70-483-MCSD-Guide\Book70483Samples\Chapter 20\Sample.txt";<br/>using (FileStream fileStream = File.Create(sourceFileLocation))<br/>{<br/>    string myValue = "MyValue";<br/>    byte[] data = Encoding.UTF8.GetBytes(myValue);<br/>    fileStream.Write(data, 0, data.Length);<br/>}</pre>
<p> In the preceding code implementation, we are doing the following:</p>
<ul>
<li>Opening the <kbd>Sample.txt</kbd> file that's present in the specified location</li>
<li>Creating a <kbd>File</kbd> object from it and then converting the data present in the file to a <kbd>FileStream</kbd> object</li>
<li>Writing data to the file using the <kbd>Write</kbd> operation available in the <kbd>FileStream</kbd> object</li>
</ul>
<p>Please note that we are using the <kbd>using</kbd> block for the <kbd>FileStream</kbd> object. Due to this, the <kbd>Dispose</kbd> method will be automatically called for the <kbd>FileStream</kbd> object. Therefore, the memory from unmanaged resources will be reclaimed automatically.</p>
<p>Please note that in the preceding implementation, we are encoding the string value before we are writing that data to the <kbd>FileStream</kbd> object.</p>
<p>Another way of handling the same functionality is to use the <kbd>StreamWriter</kbd> helper class. The following code implementation shows how it can be handled using the <kbd>StreamWriter</kbd> helper class:</p>
<pre>string sourceFileLocation = @"C:\UCN Code Base\Programming-in-C-Exam-70-483-MCSD-Guide\Book70483Samples\Chapter 20\Sample.txt";<br/>using (StreamWriter streamWriter = File.CreateText(sourceFileLocation))<br/>{<br/>    string myValue = "MyValue";<br/>    streamWriter.Write(myValue);<br/>} </pre>
<p>While choosing between the two helper classes, we need to consider the data we are dealing with. A <kbd>FileStream</kbd> object deals with an array of bytes. However, the <kbd>StreamWriter</kbd> class implements <kbd>TextWriter</kbd>. It only deals with string data and automatically encodes it into bytes so that we don't have to explicitly do it. However, in cases when we use the <kbd>FileStream</kbd> class, we must encode and decode the bytes to data into the string representation. </p>
<p>In the next section, we will look at some best practices relating to exception handling while dealing with file I/O operations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exception handling</h1>
                
            
            
                
<p>In any real-world scenario, multiple people might be working with the same file concurrently. Using threading in C#, we can lock objects while a particular operation is happening on a resource. However, such locking is not available on files present in the filesystem. </p>
<p class="mce-root"/>
<p>So, it's quite possible that files that are being accessed in the program have been moved or even deleted altogether by a different application or user. C# provides some exceptions with which we can handle such scenarios in a better way. Please refer to the following code implementation, where we are handling an exception:</p>
<pre>private static string ReadFileText()<br/>{<br/>    string path =@"C:\UCN Code Base\Programming-in-C-Exam-70-483-MCSD-          Guide\Book70483Samples\Chapter 20\Sample.txt";<br/>     if (File.Exists(path))<br/>     {<br/>         try<br/>         {<br/>             return File.ReadAllText(path);<br/>         }<br/>         catch (DirectoryNotFoundException) <br/>         {<br/>             return string.Empty; <br/>         }<br/>         catch (FileNotFoundException) <br/>         {<br/>             return string.Empty; <br/>         }<br/>     }<br/>     return string.Empty;<br/>}<br/><br/></pre>
<p>From a functionality perspective, in the preceding code we are reading file present in the given location. We are retrieving all the text present in the file and then passing it back to the calling function. Please also note the following best practices that we are using in the code implementation:</p>
<ul>
<li>In the code, we are first checking whether the file exists in the directory location using the <kbd>Exists</kbd> method. If the file exists, we proceed to extract data from the file.</li>
<li>Even though we have checked that the file exists before we proceed, there are still some circumstances in which the file is removed, deleted, or becomes inaccessible after the code moves to the next block. To handle such scenarios, we are catching the <kbd>DirectoryNotFoundException</kbd> and <kbd>FileNotFoundException</kbd> exceptions. <kbd>DirectoryNotFoundException</kbd> is thrown when the directory specified in the path no longer exists. <kbd>FileNotFoundException</kbd> is thrown when the file specified in the path no longer exists. </li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now that we have a fair understanding of how to execute I/O operations on a file, we will look at examples of calling external web services to get a response from them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading data from a network</h1>
                
            
            
                
<p>While developing applications in .NET Framework, we will encounter several scenarios where we need to call external APIs to get the required data. .NET Framework provides a <kbd>System.Net</kbd> namespace that provides a large number of helper classes that allow us to execute these operations. </p>
<p>In this section, we will go through an example in which we will use the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes to call the external APIs and process their responses. We will be calling an external page, and we also process the response that we will get from the call. We will also be looking at code examples in which we will learn how to make asynchronous calls to an external web server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WebRequest and WebResponse</h1>
                
            
            
                
<p><kbd>WebRequest</kbd> is an abstract base class provided by .NET Framework for accessing data from the internet. Using this class, we send a request to a particular URL, such as <kbd>www.google.com</kbd>. </p>
<p>On the other hand, <kbd>WebResponse</kbd> is an abstract class that provides a response from the URL called by the <kbd>WebRequest</kbd> class. </p>
<p class="mce-root">The <kbd>WebRequest</kbd> object is created by calling the static <kbd>Create</kbd> method. In the method, we pass the address URL that we want to call in the request. The request inspects the address we are passing to it and selects a protocol implementation, for example, HTTP or FTP. Based upon the web address passed, an appropriate instance of the derived class, such as <kbd>HttpWebRequest</kbd> for HTTP or <kbd>FtpWebRequest</kbd> for FTP, is returned when the <kbd>WebRequest</kbd> object is created. The <kbd>WebRequest</kbd> class also allows us to specify some other properties, such as the authentication and content type. Let's go through the following code implementation, which will help us learn more about this class:</p>
<pre>WebRequest request = null;<br/>HttpWebResponse response = null;<br/>Stream dataStream = null;<br/>StreamReader reader = null;<br/>try<br/>{<br/>    request = WebRequest.Create("http://www.google.com/search?q=c#");<br/>    request.Method = "GET";
    response = (HttpWebResponse)request.GetResponse();<br/>    dataStream = response.GetResponseStream();<br/>    reader = new StreamReader(dataStream);<br/>    Console.WriteLine(reader.ReadToEnd());<br/>}<br/>catch(Exception ex)<br/>{<br/>    Console.WriteLine(ex.ToString());<br/>}<br/>finally<br/>{<br/>    reader.Close();<br/>    dataStream.Close();<br/>    response.Close();<br/>}</pre>
<p>In the preceding code implementation, we are creating a <kbd>WebRequest</kbd> object for <kbd>http://google.com</kbd>.  We are using a <kbd>GET</kbd> method in the <kbd>HTTP</kbd> request and passing parameters embedded in the URL itself. As the protocol is <kbd>HTTP</kbd>, we are converting the <kbd>WebResponse</kbd> object to <kbd>httpWebResponse</kbd>.</p>
<p>Once we have captured the response, we are retrieving the stream of bytes into a  <kbd>Stream</kbd> object and are then using a <kbd>StreamReader</kbd> object to retrieve the response from <kbd>google.com</kbd>.</p>
<p>A very important thing to note here is that in the <kbd>finally</kbd> block, we are closing all the response, stream, and reader objects that have been created in the <kbd>try</kbd>...<kbd>catch</kbd> block. This is essential: as we are dealing with unmanaged resources, it's important to reclaim the memory for better performance. </p>
<p>For further reading, please refer to the following blog from Microsoft, which discusses the different parameters that we can set in the <kbd>WebRequest</kbd> object when we are making a call: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2</a>.</p>
<p>In the preceding code, we were making synchronous calls to the external web service and waiting for a response. However, in a real-world scenario, this may not be the ideal implementation. </p>
<p class="mce-root"/>
<p>The external server to which we are making a call may take some time to send us the response. Therefore, if our application continues to wait for a response during this time, the responsiveness of the application will be challenged. To avoid such scenarios, we can make I/O calls asynchronous. In the next section, we will learn why we need to look at making asynchronous I/O calls and how they're implemented in code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous I/O operations</h1>
                
            
            
                
<p>When we were going through the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> section, we wrote a program in which we made a call to <kbd>google.com</kbd>. In very crude terms, when the request is made, it's picked up by the Google server, which then assigns a thread to cater to this request. The thread then sends the response to the calling machine. </p>
<p>Theoretically, however, there is always a possibility that fewer free threads are available on the server. Also, there is the possibility that the server may take a long time to complete the request and send the response to the caller. </p>
<p>The challenge here is that we must design communication between the caller and the server is such a way that the performance and responsiveness of the application are not compromised. We do that by making the calls asynchronous. </p>
<p>If we make these operations asynchronous, we can rest assured that, while the server is processing the request and sending us the response, our application remains responsive and users can continue using the application. We do this using the <kbd>async</kbd>/<kbd>await</kbd> keywords. </p>
<p>Any method that is written asynchronously in C# must have the following characteristics:</p>
<ul>
<li>The method definition must have the <kbd>async</kbd> keyword to indicate that the method is executed asynchronously. </li>
<li>The method must have one of the following return types:
<ul>
<li><kbd>Task</kbd>: If the function has no return statements</li>
<li><kbd>Task&lt;TResult&gt;</kbd>: If the function has a return statement in which the object being returned is of type <kbd>TResult</kbd></li>
<li><kbd>Void</kbd>: If the function is an event handler</li>
</ul>
</li>
<li>In the function, we execute an asynchronous call to an external web server.</li>
<li>The function may have an <kbd>await</kbd> statement. The <kbd>await</kbd> statement basically tells the compiler that the application must wait at that statement for the asynchronous process executed by the external web server to finish.</li>
</ul>
<p>Let's go through all these points in the following code implementation:</p>
<pre>async Task&lt;int&gt; ExecuteOperationAsync()<br/>{<br/>    using (HttpClient client = new HttpClient())<br/>    {<br/>           Task&lt;string&gt; getStringTask = client.GetStringAsync("http://google.com");<br/>           ExecuteParallelWork();<br/>           string urlContents = await getStringTask;<br/>           return urlContents.Length;<br/>    } <br/>}</pre>
<p>Please refer to the following in the preceding code:</p>
<ul>
<li>We have defined a function called <kbd>ExecuteOperationAsync</kbd>. To indicate the asynchronous behavior of the function, we have used the <kbd>async</kbd> keyword in the function definition. </li>
<li>We have declared the return type of the function as <kbd>Task&lt;int&gt;</kbd>, which indicates that the function will return an object of type <kbd>int</kbd>.</li>
<li>We have declared an object of the <kbd>HttpClient</kbd> helper class and are making a call to <kbd>http://google.com</kbd>. We are making the request call asynchronously.</li>
<li>To ensure that the application carries on doing other work, we are calling the <kbd>ExecuteParallelWork</kbd> function so that, until the response arrives, the application does not stop processing. </li>
<li>We have used an <kbd>await</kbd> statement so that the compiler stops at that point and waits for the response for a asynchronous request call. Once the response is received, it checks the length of the response string and returns the result to the calling function.</li>
</ul>
<p>Now that we have a fair understanding of how asynchronous calls work in I/O operations, we will look at how to use them in I/O operations.</p>
<p>In the next section, we will look at how different I/O operations can be made asynchronous using this keyword.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Async operations on file</h1>
                
            
            
                
<p>In this section, we will learn how to perform I/O operations on a file asynchronously. This can be helpful in scenarios when the data that we are writing to the file is large. </p>
<p class="mce-root"/>
<p>The following code implementation shows how to write data to a file asynchronously. Please note that we must use the <kbd>FileStream</kbd> object to execute file I/O operations asynchronously:</p>
<pre>public async Task CreateFile()<br/>{<br/>   string path =@"C:\UCN Code Base\Programming-in-C-Exam-70-483-MCSD-              Guide\Book70483Samples\Chapter 20\New.txt";<br/>   using (FileStream stream = new FileStream(path,FileMode.Create,<br/>   FileAccess.Write, FileShare.None, 4096, true))<br/>   {<br/>       byte[] data = new byte[100000];<br/>       new Random().NextBytes(data);<br/>       await stream.WriteAsync(data, 0, data.Length);<br/>   }<br/>}</pre>
<p>In the preceding code implementation, we are creating a new file in a given directory location. The calling function does not require a value to be returned, so we have just set the return type as <kbd>Task</kbd>. To create the file and write data to it, we have used a <kbd>FileStream</kbd> object. For a detailed analysis of the properties passed in the constructor of the class, please refer to the following link: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2</a>.</p>
<p>After creating the object, we are generating a random sequence of bytes and are then writing it asynchronously to the <kbd>FileStream</kbd> object. </p>
<p>For a code implementation related to calling web requests asynchronously, we can refer to the implementation in the previous example where we created an object called <kbd>HttpClient</kbd> and made a call asynchronously. </p>
<p>In the next section, we will learn how to execute multiple I/O operations asynchronously and in a parallel manner. </p>
<p>This is quite useful in scenarios where the application must wait for the completion of different functions that are executing in parallel.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the await statement for parallel asynchronous calls</h1>
                
            
            
                
<p>While writing programs, we often come across situations in which we must wait for results from different asynchronous calls. This is required when the processing is dependent upon multiple responses from an external medium, such as web services. Let's look at the following code example:</p>
<pre>public async Task ExecuteMultipleRequestsInParallel()<br/>{<br/>    HttpClient client = new HttpClient();<br/>    Task google = client.GetStringAsync("http://www.google.com");<br/>    Task bing = client.GetStringAsync("http://www.bing.com");<br/>    Task yahoo = client.GetStringAsync("http://yahoo.com/");<br/>    await Task.WhenAll(google, bing, yahoo);<br/>}</pre>
<p>In the preceding code, we are executing asynchronous calls to different servers. Suppose we have to wait for the output from all of them before we can proceed; we can use the <kbd>WhenAll</kbd> statement. The <kbd>WhenAll</kbd> statement will ensure that the execution waits for responses from all three asynchronous calls before the processing can move ahead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary </h1>
                
            
            
                
<p>In this chapter, we learned how to execute I/O operations related to files and networks in C#. We went over namespaces that provide helper classes for executing I/O operations. We started with the basic operations that we can perform on drives and directories. We looked at code that we can use to loop through files in directories. </p>
<p>Then we looked at the helper classes that help us with I/O operations on files. We looked at the <kbd>File</kbd> and <kbd>FileInfo</kbd> classes, which help us create, copy, move, and delete files. We looked at best practices for dealing with directory and file paths. We then looked at s<em>treams</em>, or sequences of bytes, which allow us to edit information present in files. We then looked at best practices for exception handling in files.</p>
<p>After that, we looked at helper classes for dealing with I/O operations over networks. We looked at a code example in which we made HTTP calls over the internet. We then looked at a code implementation in which we made asynchronous I/O calls. Whenever possible, it's always beneficial to use asynchronous operations because it's better for the overall performance of the application. We went over code examples for executing asynchronous operations on both I/O and over the internet. </p>
<p class="mce-root"/>
<p>In the next chapter, we will look at how LINQ queries can we used in C# to work efficiently when we are querying different data sources, such as XML and SQL. Working with code examples, we will explore the different components of LINQ, along with the different operators that we can use while working with LINQ queries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Which syntax should we use to append text to a file?
<ol>
<li><kbd>File.CreateText</kbd></li>
<li><kbd>FileInfo.Create</kbd></li>
<li><kbd>File.Create</kbd></li>
<li><kbd>File.AppendText</kbd></li>
</ol>
</li>
<li>Which syntax should we use if the application needs to wait for asynchronous calls from multiple sources?
<ol>
<li><kbd>async</kbd></li>
<li><kbd>await</kbd></li>
<li><kbd>Task</kbd></li>
<li><kbd>Task.WhenAll</kbd></li>
</ol>
</li>
<li>Which one of the following statements is incorrect?
<ol>
<li><kbd>StreamWriter</kbd> only works with text; however, <kbd>FileStream</kbd> works with bytes.</li>
<li>We can lock files in .NET.</li>
<li>If we have an asynchronous function, it can have one of three return types: <kbd>Task</kbd>, <kbd>Task&lt;TResult&gt;</kbd>, and <kbd>Void</kbd>.</li>
<li><kbd>DirectoryNotFoundException</kbd> is thrown when the directory in the file path is no longer available.</li>
</ol>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Answers</h1>
                
            
            
                
<ol>
<li><strong>File.AppendText.</strong></li>
<li><strong>Task.WhenAll.</strong></li>
<li><strong>Except "B" that is we can lock files, all other statements are true.</strong></li>
</ol>


            

            
        
    </body></html>